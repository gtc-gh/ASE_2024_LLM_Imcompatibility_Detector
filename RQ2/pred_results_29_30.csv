Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,"<android.util.Half: int compare(short,short)>",29,30,"<android.util.Half: int compare(short,short)>","<android.util.Half: int compare(short,short)>",0,"{
    if (less(x, y))
        return -1;
    if (greater(x, y))
        return 1;
    // Collapse NaNs, akin to halfToIntBits(), but we want to keep
    // (signed) short value types to preserve the ordering of -0.0
    // and +0.0
    short xBits = (x & FP16_COMBINED) > FP16_EXPONENT_MAX ? NaN : x;
    short yBits = (y & FP16_COMBINED) > FP16_EXPONENT_MAX ? NaN : y;
    return (xBits == yBits ? 0 : (xBits < yBits ? -1 : 1));
}","{
    return FP16.compare(x, y);
}",1,"/**
 * <p>Compares the two specified half-precision float values. The following
 * conditions apply during the comparison:</p>
 *
 * <ul>
 * <li>{@link #NaN} is considered by this method to be equal to itself and greater
 * than all other half-precision float values (including {@code #POSITIVE_INFINITY})</li>
 * <li>{@link #POSITIVE_ZERO} is considered by this method to be greater than
 * {@link #NEGATIVE_ZERO}.</li>
 * </ul>
 *
 * @param x The first half-precision float value to compare.
 * @param y The second half-precision float value to compare
 *
 * @return  The value {@code 0} if {@code x} is numerically equal to {@code y}, a
 * value less than {@code 0} if {@code x} is numerically less than {@code y},
 * and a value greater than {@code 0} if {@code x} is numerically greater
 * than {@code y}
 */
","/**
 * <p>Compares the two specified half-precision float values. The following
 * conditions apply during the comparison:</p>
 *
 * <ul>
 * <li>{@link #NaN} is considered by this method to be equal to itself and greater
 * than all other half-precision float values (including {@code #POSITIVE_INFINITY})</li>
 * <li>{@link #POSITIVE_ZERO} is considered by this method to be greater than
 * {@link #NEGATIVE_ZERO}.</li>
 * </ul>
 *
 * @param x The first half-precision float value to compare.
 * @param y The second half-precision float value to compare
 *
 * @return  The value {@code 0} if {@code x} is numerically equal to {@code y}, a
 * value less than {@code 0} if {@code x} is numerically less than {@code y},
 * and a value greater than {@code 0} if {@code x} is numerically greater
 * than {@code y}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire body of the method has been changed to call FP16.compare(x, y), which implies a change in dependent API (method call), so the code change type is 1,5.","Since the logic of comparison has been offloaded to another API, it might return different values for some inputs, especially if FP16.compare has different handling for edge cases or NaN values, the CI type is 1."
1,<android.service.voice.VoiceInteractionService: void setUiHints(Bundle)>,29,30,<android.service.voice.VoiceInteractionService: void setUiHints(Bundle)>,<android.service.voice.VoiceInteractionService: void setUiHints(Bundle)>,0,"{
    if (hints == null) {
        throw new IllegalArgumentException(""Hints must be non-null"");
    }
    try {
        mSystemService.setUiHints(mInterface, hints);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (hints == null) {
        throw new IllegalArgumentException(""Hints must be non-null"");
    }
    try {
        mSystemService.setUiHints(hints);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Provide hints to be reflected in the system UI.
 *
 * @param hints Arguments used to show UI.
 */
","/**
 * Provide hints to be reflected in the system UI.
 *
 * @param hints Arguments used to show UI.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in the parameter list of the method mSystemService.setUiHints(): previously, it took two arguments (mInterface, hints) and now it takes only one argument (hints). Therefore, the code change type is 5.","Despite the dependent API changing its parameters, the overall semantic remains unchanged. The method still checks if hints are null, and throws the exact same exception if so; and in case of a RemoteException caught, the exception is rethrown in the same manner. Thus, there's no Compatibility Issue, as the API continues to behave as before from the caller's perspective."
2,<android.app.admin.DevicePolicyManager: String[] getAccountTypesWithManagementDisabled()>,29,30,<android.app.admin.DevicePolicyManager: String[] getAccountTypesWithManagementDisabled()>,<android.app.admin.DevicePolicyManager: String[] getAccountTypesWithManagementDisabled()>,0,"{
    throwIfParentInstance(""getAccountTypesWithManagementDisabled"");
    return getAccountTypesWithManagementDisabledAsUser(myUserId());
}","{
    return getAccountTypesWithManagementDisabledAsUser(myUserId(), mParentInstance);
}",1,"/**
 * Gets the array of accounts for which account management is disabled by the profile owner.
 *
 * <p> Account management can be disabled/enabled by calling
 * {@link #setAccountManagementDisabled}.
 *
 * @return a list of account types for which account management has been disabled.
 *
 * @see #setAccountManagementDisabled
 */
","/**
 * Gets the array of accounts for which account management is disabled by the profile owner
 * or device owner.
 *
 * <p> Account management can be disabled/enabled by calling
 * {@link #setAccountManagementDisabled}.
 * <p>
 * This method may be called on the {@code DevicePolicyManager} instance returned from
 * {@link #getParentProfileInstance(ComponentName)}. Note that only a profile owner on
 * an organization-owned device can affect account types on the parent profile instance.
 *
 * @return a list of account types for which account management has been disabled.
 *
 * @see #setAccountManagementDisabled
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed in that the call to getAccountTypesWithManagementDisabledAsUser() in the late version now includes an additional parameter, mParentInstance. This indicates a change in the dependent API, thus the code change type is 5.","Because the additional parameter passed to the dependent API call does not affect the overall method contract and the method return type and exception behavior remain unchanged, there is no Compatibility Issue, and the CI type is 0."
3,<android.view.textclassifier.TextClassificationConstants: int getGenerateLinksMaxTextLength()>,29,30,<android.view.textclassifier.TextClassificationConstants: int getGenerateLinksMaxTextLength()>,<android.view.textclassifier.TextClassificationConstants: int getGenerateLinksMaxTextLength()>,0,"{
    return mConfigParser.getInt(GENERATE_LINKS_MAX_TEXT_LENGTH, GENERATE_LINKS_MAX_TEXT_LENGTH_DEFAULT);
}","{
    return DeviceConfig.getInt(DeviceConfig.NAMESPACE_TEXTCLASSIFIER, GENERATE_LINKS_MAX_TEXT_LENGTH, GENERATE_LINKS_MAX_TEXT_LENGTH_DEFAULT);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to obtain the integer value has changed from mConfigParser.getInt(...) in the early version to DeviceConfig.getInt(...) in the late version. And the source of the configuration has been switched from mConfigParser to DeviceConfig. Therefore, it's classified as 'Other statement changed' and 'Dependent API changed', so the code change types are 4,5.","Since the method is used only to get configuration values and as long as the key 'GENERATE_LINKS_MAX_TEXT_LENGTH' remains the same and the default value 'GENERATE_LINKS_MAX_TEXT_LENGTH_DEFAULT' is unchanged, the behavior of the method will remain the same despite the change in how the value is retrieved. Hence, no compatibility issue is expected and the CI type is 0."
4,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void hideSoftInput(int,ResultReceiver)>",29,30,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void hideSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void hideSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""hideSoftInput()"");
    final boolean wasVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    if (mIsPreRendered) {
        if (DEBUG) {
            Log.v(TAG, ""Making IME window invisible"");
        }
        setImeWindowStatus(IME_ACTIVE | IME_INVISIBLE, mBackDisposition);
        applyVisibilityInInsetsConsumer(false);
        onPreRenderedWindowVisibilityChanged(false);
    } else {
        mShowInputFlags = 0;
        mShowInputRequested = false;
        doHideWindow();
    }
    final boolean isVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_HIDDEN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""hideSoftInput()"");
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingHideSoftInput) {
        Log.e(TAG, ""IME shouldn't call hideSoftInput on itself."" + "" Use requestHideSelf(int) itself"");
        return;
    }
    final boolean wasVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    applyVisibilityInInsetsConsumerIfNecessary(false);
    if (mIsPreRendered) {
        if (DEBUG) {
            Log.v(TAG, ""Making IME window invisible"");
        }
        setImeWindowStatus(IME_ACTIVE | IME_INVISIBLE, mBackDisposition);
        onPreRenderedWindowVisibilityChanged(false);
    } else {
        mShowInputFlags = 0;
        mShowInputRequested = false;
        doHideWindow();
    }
    final boolean isVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_HIDDEN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,"1,3,4",0,"The new condition has been added in the late version ('if' statement checking application's targetSdkVersion and mSystemCallingHideSoftInput), a new message logging (Log.e), and an invoke to 'applyVisibilityInInsetsConsumerIfNecessary' instead of 'applyVisibilityInInsetsConsumer'. These changes pertain to control dependencies, logging, and method invocation, so the code change types are 1 for return statement changed, 3 for control dependency change, and 4 for other statement changed.","Although there is a return statement added in the newly introduced 'if' block, it only affects the flow when certain conditions are met, specifically when getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R and !mSystemCallingHideSoftInput. It is meant to log an error and prevent further execution of the method, which isn't different behavior if it's operating as designed (logging an error in this case is not likely a compatibility change but more an adherence to correct usage of the API according to the new SDK version requirements). The rest of the method implementation remains consistent with the previous version, preserving the behavior of the API. There are no returns, throws, or changes that should affect the API's outward behavior under correct conditions, so there is no Compatibility Issue."
5,<android.app.Notification.StandardTemplateParams: StandardTemplateParams fillTextsFrom(Builder)>,29,30,<android.app.Notification.StandardTemplateParams: StandardTemplateParams fillTextsFrom(Builder)>,<android.app.Notification.StandardTemplateParams: StandardTemplateParams fillTextsFrom(Builder)>,0,"{
    Bundle extras = b.mN.extras;
    this.title = b.processLegacyText(extras.getCharSequence(EXTRA_TITLE));
    CharSequence text = extras.getCharSequence(EXTRA_BIG_TEXT);
    if (TextUtils.isEmpty(text)) {
        text = extras.getCharSequence(EXTRA_TEXT);
    }
    this.text = b.processLegacyText(text);
    this.summaryText = extras.getCharSequence(EXTRA_SUB_TEXT);
    return this;
}","{
    Bundle extras = b.mN.extras;
    this.title = b.processLegacyText(extras.getCharSequence(EXTRA_TITLE));
    this.text = b.processLegacyText(extras.getCharSequence(EXTRA_TEXT));
    this.summaryText = extras.getCharSequence(EXTRA_SUB_TEXT);
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The code change involves the removal of code related to EXTRA_BIG_TEXT (conditional check and assignment to this.text) and the modification of the assignment of this.text. So, the change types are 1 for the return statement change and 4 for other statements changed.","Because the conditional logic for assigning the text with potentially EXTRA_BIG_TEXT has been removed and directly assigns EXTRA_TEXT to this.text, the executing path of the method and the return value may be different. This leads to a CI type of 1 due to the potential for different return values."
6,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",29,30,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>","<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (!mAttachInfo.mViewRootImpl.mSurface.isValid()) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    // does not accept zero size surface.
    if (shadowSize.x == 0 || shadowSize.y == 0) {
        if (!sAcceptZeroSizeDragShadow) {
            throw new IllegalStateException(""Drag shadow dimensions must be positive"");
        }
        shadowSize.x = 1;
        shadowSize.y = 1;
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    final ViewRootImpl root = mAttachInfo.mViewRootImpl;
    final SurfaceSession session = new SurfaceSession();
    final SurfaceControl surfaceControl = new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).build();
    final Surface surface = new Surface();
    surface.copyFrom(surfaceControl);
    IBinder token = null;
    try {
        final Canvas canvas = surface.lockCanvas(null);
        try {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
            shadowBuilder.onDrawShadow(canvas);
        } finally {
            surface.unlockCanvasAndPost(canvas);
        }
        // repurpose 'shadowSize' for the last touch point
        root.getLastTouchPoint(shadowSize);
        token = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
        if (ViewDebug.DEBUG_DRAG) {
            Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token);
        }
        if (token != null) {
            if (mAttachInfo.mDragSurface != null) {
                mAttachInfo.mDragSurface.release();
            }
            mAttachInfo.mDragSurface = surface;
            mAttachInfo.mDragToken = token;
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
        }
        return token != null;
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        return false;
    } finally {
        if (token == null) {
            surface.destroy();
        }
        session.kill();
    }
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (!mAttachInfo.mViewRootImpl.mSurface.isValid()) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    // does not accept zero size surface.
    if (shadowSize.x == 0 || shadowSize.y == 0) {
        if (!sAcceptZeroSizeDragShadow) {
            throw new IllegalStateException(""Drag shadow dimensions must be positive"");
        }
        shadowSize.x = 1;
        shadowSize.y = 1;
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    final ViewRootImpl root = mAttachInfo.mViewRootImpl;
    final SurfaceSession session = new SurfaceSession();
    final SurfaceControl surfaceControl = new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build();
    final Surface surface = new Surface();
    surface.copyFrom(surfaceControl);
    IBinder token = null;
    try {
        final Canvas canvas = surface.lockCanvas(null);
        try {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
            shadowBuilder.onDrawShadow(canvas);
        } finally {
            surface.unlockCanvasAndPost(canvas);
        }
        // repurpose 'shadowSize' for the last touch point
        root.getLastTouchPoint(shadowSize);
        token = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
        if (ViewDebug.DEBUG_DRAG) {
            Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token);
        }
        if (token != null) {
            if (mAttachInfo.mDragSurface != null) {
                mAttachInfo.mDragSurface.release();
            }
            mAttachInfo.mDragSurface = surface;
            mAttachInfo.mDragToken = token;
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
        }
        return token != null;
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        return false;
    } finally {
        if (token == null) {
            surface.destroy();
        }
        session.kill();
    }
}",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
","/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
7,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",29,30,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>","<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.insert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    return insert(url, initialValues, null);
}",1,"/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
","/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
",-1,"[@Override, @Nullable]",[@Nullable],-1,-1,-1,-1,-1,-1,"1,5","1,2","The method now has a direct call to a different method with different parameters rather than inline implementation and exception handling has been removed. Also, the method definition suggests a change in dependent API. Therefore, the code change type is 1,5.","The new implementation lacks the exception handling for DeadObjectException and associated behaviour in the catch block, which was present in the old implementation, suggesting a potential Compatibility Issue due to different exception handlings. Additionally, because the internals of the new insert() method called are not known, it's uncertain if it would return the same values or throw the same exceptions under all circumstances as the early version's implementation. This uncertainty implies a potential Compatibility Issue with return values as well. Therefore, the CI type is 1,2."
9,<android.os.Parcel: void writeException(Exception)>,29,30,<android.os.Parcel: void writeException(Exception)>,<android.os.Parcel: void writeException(Exception)>,0,"{
    int code = 0;
    if (e instanceof Parcelable && (e.getClass().getClassLoader() == Parcelable.class.getClassLoader())) {
        // We only send Parcelable exceptions that are in the
        // BootClassLoader to ensure that the receiver can unpack them
        code = EX_PARCELABLE;
    } else if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    } else if (e instanceof ServiceSpecificException) {
        code = EX_SERVICE_SPECIFIC;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
    final long timeNow = sParcelExceptionStackTrace ? SystemClock.elapsedRealtime() : 0;
    if (sParcelExceptionStackTrace && (timeNow - sLastWriteExceptionStackTrace > WRITE_EXCEPTION_STACK_TRACE_THRESHOLD_MS)) {
        sLastWriteExceptionStackTrace = timeNow;
        final int sizePosition = dataPosition();
        // Header size will be filled in later
        writeInt(0);
        StackTraceElement[] stackTrace = e.getStackTrace();
        final int truncatedSize = Math.min(stackTrace.length, 5);
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < truncatedSize; i++) {
            sb.append(""\tat "").append(stackTrace[i]).append('\n');
        }
        writeString(sb.toString());
        final int payloadPosition = dataPosition();
        setDataPosition(sizePosition);
        // Write stack trace header size. Used in native side to skip the header
        writeInt(payloadPosition - sizePosition);
        setDataPosition(payloadPosition);
    } else {
        writeInt(0);
    }
    switch(code) {
        case EX_SERVICE_SPECIFIC:
            writeInt(((ServiceSpecificException) e).errorCode);
            break;
        case EX_PARCELABLE:
            // Write parceled exception prefixed by length
            final int sizePosition = dataPosition();
            writeInt(0);
            writeParcelable((Parcelable) e, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
            final int payloadPosition = dataPosition();
            setDataPosition(sizePosition);
            writeInt(payloadPosition - sizePosition);
            setDataPosition(payloadPosition);
            break;
    }
}","{
    AppOpsManager.prefixParcelWithAppOpsIfNeeded(this);
    int code = getExceptionCode(e);
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
    final long timeNow = sParcelExceptionStackTrace ? SystemClock.elapsedRealtime() : 0;
    if (sParcelExceptionStackTrace && (timeNow - sLastWriteExceptionStackTrace > WRITE_EXCEPTION_STACK_TRACE_THRESHOLD_MS)) {
        sLastWriteExceptionStackTrace = timeNow;
        writeStackTrace(e);
    } else {
        writeInt(0);
    }
    switch(code) {
        case EX_SERVICE_SPECIFIC:
            writeInt(((ServiceSpecificException) e).errorCode);
            break;
        case EX_PARCELABLE:
            // Write parceled exception prefixed by length
            final int sizePosition = dataPosition();
            writeInt(0);
            writeParcelable((Parcelable) e, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
            final int payloadPosition = dataPosition();
            setDataPosition(sizePosition);
            writeInt(payloadPosition - sizePosition);
            setDataPosition(payloadPosition);
            break;
    }
}",1,"/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link UnsupportedOperationException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
","/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link UnsupportedOperationException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5",2,"In the late version, there is an introduction of a new method call (AppOpsManager.prefixParcelWithAppOpsIfNeeded(this)), and refactoring to centralize exception code assignment (getExceptionCode(e)) and stack trace writing (writeStackTrace(e)). These changes fall under other statement changed (4) and dependent API changed (5) because there is both a change in the implementation structure and a reliance on new or modified methods. Exception handling has also changed because, in the previous version, if no code matched, it would throw a RuntimeException, while in the new version, this behavior is encapsulated within getExceptionCode(e), affecting exception handling flow, which is change type (2). The control dependency has changed because the long sequence of if-statements has been refactored into a separate method, which is change type (3).","The introduction of a new method call (prefixParcelWithAppOpsIfNeeded) does not by itself lead to a CI because it's unclear whether this method could affect the control flow that leads to exception throwing or not. However, the refactoring for exception handling directly changes how exceptions are handled in the method because now the throwing of the RuntimeException is handled within another method call (getExceptionCode(e)). Because exception handling was changed, it could potentially cause the method to throw an exception differently, which is a compatibility issue caused by potentially different exception handling, and that’s why the CI type here is 2."
10,<android.view.Display: DisplayCutout getCutout()>,29,30,<android.view.Display: DisplayCutout getCutout()>,<android.view.Display: DisplayCutout getCutout()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.displayCutout;
    }
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mMayAdjustByFixedRotation ? getDisplayAdjustments().getDisplayCutout(mDisplayInfo.displayCutout) : mDisplayInfo.displayCutout;
    }
}",1,"/**
 * Returns the {@link DisplayCutout}, or {@code null} if there is none.
 *
 * @see DisplayCutout
 */
","/**
 * Returns the {@link DisplayCutout}, or {@code null} if there is none.
 *
 * @see DisplayCutout
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency has changed with the addition of a conditional operator, and the return statement has been modified with either returning `getDisplayAdjustments().getDisplayCutout(mDisplayInfo.displayCutout)` or `mDisplayInfo.displayCutout` based on the value of `mMayAdjustByFixedRotation`, so the change type is 1,3.","Due to the additional check of `mMayAdjustByFixedRotation`, the return value of this method may differ; a different DisplayCutout object might be returned or the method may perform additional adjustments before returning. As such, the return value could potentially change, which classifies as a CI type 1."
11,"<android.content.IntentFilter: int matchData(String,String,Uri)>",29,30,"<android.content.IntentFilter: int matchData(String,String,Uri)>","<android.content.IntentFilter: int matchData(String,String,Uri)>",0,"{
    final ArrayList<String> types = mDataTypes;
    final ArrayList<String> schemes = mDataSchemes;
    int match = MATCH_CATEGORY_EMPTY;
    if (types == null && schemes == null) {
        return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
    }
    if (schemes != null) {
        if (schemes.contains(scheme != null ? scheme : """")) {
            match = MATCH_CATEGORY_SCHEME;
        } else {
            return NO_MATCH_DATA;
        }
        final ArrayList<PatternMatcher> schemeSpecificParts = mDataSchemeSpecificParts;
        if (schemeSpecificParts != null && data != null) {
            match = hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
        }
        if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
            // If there isn't any matching ssp, we need to match an authority.
            final ArrayList<AuthorityEntry> authorities = mDataAuthorities;
            if (authorities != null) {
                int authMatch = matchDataAuthority(data);
                if (authMatch >= 0) {
                    final ArrayList<PatternMatcher> paths = mDataPaths;
                    if (paths == null) {
                        match = authMatch;
                    } else if (hasDataPath(data.getPath())) {
                        match = MATCH_CATEGORY_PATH;
                    } else {
                        return NO_MATCH_DATA;
                    }
                } else {
                    return NO_MATCH_DATA;
                }
            }
        }
        // If neither an ssp nor an authority matched, we're done.
        if (match == NO_MATCH_DATA) {
            return NO_MATCH_DATA;
        }
    } else {
        // to force everyone to say they handle content: or file: URIs.
        if (scheme != null && !"""".equals(scheme) && !""content"".equals(scheme) && !""file"".equals(scheme)) {
            return NO_MATCH_DATA;
        }
    }
    if (types != null) {
        if (findMimeType(type)) {
            match = MATCH_CATEGORY_TYPE;
        } else {
            return NO_MATCH_TYPE;
        }
    } else {
        // an Intent that does not have a MIME type.
        if (type != null) {
            return NO_MATCH_TYPE;
        }
    }
    return match + MATCH_ADJUSTMENT_NORMAL;
}","{
    return matchData(type, scheme, data, false);
}",1,"/**
 * Match this filter against an Intent's data (type, scheme and path). If
 * the filter does not specify any types and does not specify any
 * schemes/paths, the match will only succeed if the intent does not
 * also specify a type or data.  If the filter does not specify any schemes,
 * it will implicitly match intents with no scheme, or the schemes ""content:""
 * or ""file:"" (basically performing a MIME-type only match).  If the filter
 * does not specify any MIME types, the Intent also must not specify a MIME
 * type.
 *
 * <p>Be aware that to match against an authority, you must also specify a base
 * scheme the authority is in.  To match against a data path, both a scheme
 * and authority must be specified.  If the filter does not specify any
 * types or schemes that it matches against, it is considered to be empty
 * (any authority or data path given is ignored, as if it were empty as
 * well).
 *
 * <p><em>Note: MIME type, Uri scheme, and host name matching in the
 * Android framework is case-sensitive, unlike the formal RFC definitions.
 * As a result, you should always write these elements with lower case letters,
 * and normalize any MIME types or Uris you receive from
 * outside of Android to ensure these elements are lower case before
 * supplying them here.</em></p>
 *
 * @param type The desired data type to look for, as returned by
 * Intent.resolveType().
 * @param scheme The desired data scheme to look for, as returned by
 * Intent.getScheme().
 * @param data The full data string to match against, as supplied in
 * Intent.data.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match
 * or {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 *
 * @see #match
 */
","/**
 * Match this filter against an Intent's data (type, scheme and path). If
 * the filter does not specify any types and does not specify any
 * schemes/paths, the match will only succeed if the intent does not
 * also specify a type or data.  If the filter does not specify any schemes,
 * it will implicitly match intents with no scheme, or the schemes ""content:""
 * or ""file:"" (basically performing a MIME-type only match).  If the filter
 * does not specify any MIME types, the Intent also must not specify a MIME
 * type.
 *
 * <p>Be aware that to match against an authority, you must also specify a base
 * scheme the authority is in.  To match against a data path, both a scheme
 * and authority must be specified.  If the filter does not specify any
 * types or schemes that it matches against, it is considered to be empty
 * (any authority or data path given is ignored, as if it were empty as
 * well).
 *
 * <p><em>Note: MIME type, Uri scheme, and host name matching in the
 * Android framework is case-sensitive, unlike the formal RFC definitions.
 * As a result, you should always write these elements with lower case letters,
 * and normalize any MIME types or Uris you receive from
 * outside of Android to ensure these elements are lower case before
 * supplying them here.</em></p>
 *
 * @param type The desired data type to look for, as returned by
 * Intent.resolveType().
 * @param scheme The desired data scheme to look for, as returned by
 * Intent.getScheme().
 * @param data The full data string to match against, as supplied in
 * Intent.data.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match
 * or {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 *
 * @see #match
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The late implementation calls matchData with four parameters instead of executing the logic directly within the method, which is a significant change to the entire structure of the method, and indicates that a dependent API has changed, thus the change types are 1,5.","The introduction of the 'matchData' call with an additional parameter could lead to a change in the returned value, as the behavior of 'matchData' could be different with this new variant. Therefore, this change could potentially cause a compatibility issue, specifically different return values or types, so the CI type is 1."
12,<android.content.pm.ModuleInfo: int hashCode()>,29,30,<android.content.pm.ModuleInfo: int hashCode()>,<android.content.pm.ModuleInfo: int hashCode()>,0,"{
    int hashCode = 0;
    hashCode = 31 * hashCode + Objects.hashCode(mName);
    hashCode = 31 * hashCode + Objects.hashCode(mPackageName);
    hashCode = 31 * hashCode + Boolean.hashCode(mHidden);
    return hashCode;
}","{
    int hashCode = 0;
    hashCode = 31 * hashCode + Objects.hashCode(mName);
    hashCode = 31 * hashCode + Objects.hashCode(mPackageName);
    hashCode = 31 * hashCode + Objects.hashCode(mApexModuleName);
    hashCode = 31 * hashCode + Boolean.hashCode(mHidden);
    return hashCode;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The change in the late version includes the addition of a new line that computes the hash code including the mApexModuleName. This changes the computation of the hash code by including an additional field, thus changing the 'hashCode()' method's behavior. That is why the code change types 1 (Return statement changed) and 4 (Other statement changed) are both present.","Since the computation of the hash code has been changed to include an additional field, 'mApexModuleName', it potentially leads to a different return value. This is a change in the method's behavior between versions, which could lead to incompatibilities if the hash code is being used in comparisons or for keys in hash-based collections. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
13,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern,RemoteViews)>",29,30,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern,RemoteViews)>","<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern,RemoteViews)>",0,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, new DatasetFieldFilter(filter));
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, null, new DatasetFieldFilter(filter));
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and a <a href=""#Filtering"">explicit filter</a>.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 * @param presentation the presentation used to visualize this field.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and a <a href=""#Filtering"">explicit filter</a>.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 * @param presentation the presentation used to visualize this field.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The change in the internal call from setLifeTheUniverseAndEverything(id, value, presentation, new DatasetFieldFilter(filter)) to setLifeTheUniverseAndEverything(id, value, presentation, null, new DatasetFieldFilter(filter)) involves passing different parameters to the internal method. This indicates a change in the dependent API, hence the code change type is 5.","The change appears to be an addition of a parameter to the method call within the implementation, which would not affect the API's externally observable behavior or the values it returns to the caller. Therefore, there is no Compatibility Issue, and the CI type is 0."
14,<android.app.Notification.Builder: Builder setRemoteInputHistory(CharSequence[])>,29,30,<android.app.Notification.Builder: Builder setRemoteInputHistory(CharSequence[])>,<android.app.Notification.Builder: Builder setRemoteInputHistory(CharSequence[])>,0,"{
    if (text == null) {
        mN.extras.putCharSequenceArray(EXTRA_REMOTE_INPUT_HISTORY, null);
    } else {
        final int N = Math.min(MAX_REPLY_HISTORY, text.length);
        CharSequence[] safe = new CharSequence[N];
        for (int i = 0; i < N; i++) {
            safe[i] = safeCharSequence(text[i]);
        }
        mN.extras.putCharSequenceArray(EXTRA_REMOTE_INPUT_HISTORY, safe);
    }
    return this;
}","{
    if (text == null) {
        mN.extras.putCharSequenceArray(EXTRA_REMOTE_INPUT_HISTORY, null);
    } else {
        final int itemCount = Math.min(MAX_REPLY_HISTORY, text.length);
        CharSequence[] safe = new CharSequence[itemCount];
        RemoteInputHistoryItem[] items = new RemoteInputHistoryItem[itemCount];
        for (int i = 0; i < itemCount; i++) {
            safe[i] = safeCharSequence(text[i]);
            items[i] = new RemoteInputHistoryItem(text[i]);
        }
        mN.extras.putCharSequenceArray(EXTRA_REMOTE_INPUT_HISTORY, safe);
        // Also add these messages as structured history items.
        mN.extras.putParcelableArray(EXTRA_REMOTE_INPUT_HISTORY_ITEMS, items);
    }
    return this;
}",1,"/**
 * Set the remote input history.
 *
 * This should be set to the most recent inputs that have been sent
 * through a {@link RemoteInput} of this Notification and cleared once the it is no
 * longer relevant (e.g. for chat notifications once the other party has responded).
 *
 * The most recent input must be stored at the 0 index, the second most recent at the
 * 1 index, etc. Note that the system will limit both how far back the inputs will be shown
 * and how much of each individual input is shown.
 *
 * <p>Note: The reply text will only be shown on notifications that have least one action
 * with a {@code RemoteInput}.</p>
 */
","/**
 * Set the remote input history.
 *
 * This should be set to the most recent inputs that have been sent
 * through a {@link RemoteInput} of this Notification and cleared once the it is no
 * longer relevant (e.g. for chat notifications once the other party has responded).
 *
 * The most recent input must be stored at the 0 index, the second most recent at the
 * 1 index, etc. Note that the system will limit both how far back the inputs will be shown
 * and how much of each individual input is shown.
 *
 * <p>Note: The reply text will only be shown on notifications that have least one action
 * with a {@code RemoteInput}.</p>
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The addition of creating and filling the `RemoteInputHistoryItem[] items` array and using `mN.extras.putParcelableArray(EXTRA_REMOTE_INPUT_HISTORY_ITEMS, items)` is considered a change in the implementation, but it doesn't modify the return value or the exception handling of the method; thus the change type is 4.","The method still returns `this` in both versions; hence there is no change in the return value or the control flow that affects what the method returns. Additionally, there are no exception handling changes. Therefore, there is no Compatibility Issue, so CI type is 0."
15,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,29,30,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method name that is called to send a broadcast intent has been changed from `broadcastIntent` to `broadcastIntentWithFeature`, and an additional parameter `getAttributionTag()` has been added to the call, so the type of change is 4,5 (Other statement changed and Dependent API changed).","Although there's a change in the method being called and an added parameter, this does not constitute a Compatibility Issue from the perspective of the calling code. The changes are internal to the implementation, and the method signature of `sendStickyBroadcast` remains the same. The API's behavior in terms of its return type (void) and the fact that it throws an exception don't change. Therefore, it doesn't have a Compatibility Issue."
16,"<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>",29,30,"<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>","<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>",0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (mForAugmentedAutofillOnly) {
            if (sVerbose)
                Log.v(TAG, ""notifyValueChanged(): ignoring on augmented only mode"");
            return;
        }
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + "":"" + virtualId + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + "":"" + virtualId + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}",1,"/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
","/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The control dependency has changed - the block of code checking `if (mForAugmentedAutofillOnly)` and the related logging statement have been removed.,"This change does not result in different return values or types nor does it introduce different exception handlings because it only alters when certain logs are produced and skipped an early return statement that depends on a condition (`mForAugmentedAutofillOnly`) which no longer exists in the late version. This change in control flow won't affect the external behavior of the method in terms of outputs or exceptions as the main functionality remains the same, so there is no Compatibility Issue."
17,<android.os.PowerManager: boolean isInteractive()>,29,30,<android.os.PowerManager: boolean isInteractive()>,<android.os.PowerManager: boolean isInteractive()>,0,"{
    try {
        return mService.isInteractive();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return mInteractiveCache.query(null);
}",1,"/**
 * Returns true if the device is in an interactive state.
 * <p>
 * When this method returns true, the device is awake and ready to interact
 * with the user (although this is not a guarantee that the user is actively
 * interacting with the device just this moment).  The main screen is usually
 * turned on while in this state.  Certain features, such as the proximity
 * sensor, may temporarily turn off the screen while still leaving the device in an
 * interactive state.  Note in particular that the device is still considered
 * to be interactive while dreaming (since dreams can be interactive) but not
 * when it is dozing or asleep.
 * </p><p>
 * When this method returns false, the device is dozing or asleep and must
 * be awoken before it will become ready to interact with the user again.  The
 * main screen is usually turned off while in this state.  Certain features,
 * such as ""ambient mode"" may cause the main screen to remain on (albeit in a
 * low power state) to display system-provided content while the device dozes.
 * </p><p>
 * The system will send a {@link android.content.Intent#ACTION_SCREEN_ON screen on}
 * or {@link android.content.Intent#ACTION_SCREEN_OFF screen off} broadcast
 * whenever the interactive state of the device changes.  For historical reasons,
 * the names of these broadcasts refer to the power state of the screen
 * but they are actually sent in response to changes in the overall interactive
 * state of the device, as described by this method.
 * </p><p>
 * Services may use the non-interactive state as a hint to conserve power
 * since the user is not present.
 * </p>
 *
 * @return True if the device is in an interactive state.
 *
 * @see android.content.Intent#ACTION_SCREEN_ON
 * @see android.content.Intent#ACTION_SCREEN_OFF
 */
","/**
 * Returns true if the device is in an interactive state.
 * <p>
 * When this method returns true, the device is awake and ready to interact
 * with the user (although this is not a guarantee that the user is actively
 * interacting with the device just this moment).  The main screen is usually
 * turned on while in this state.  Certain features, such as the proximity
 * sensor, may temporarily turn off the screen while still leaving the device in an
 * interactive state.  Note in particular that the device is still considered
 * to be interactive while dreaming (since dreams can be interactive) but not
 * when it is dozing or asleep.
 * </p><p>
 * When this method returns false, the device is dozing or asleep and must
 * be awoken before it will become ready to interact with the user again.  The
 * main screen is usually turned off while in this state.  Certain features,
 * such as ""ambient mode"" may cause the main screen to remain on (albeit in a
 * low power state) to display system-provided content while the device dozes.
 * </p><p>
 * The system will send a {@link android.content.Intent#ACTION_SCREEN_ON screen on}
 * or {@link android.content.Intent#ACTION_SCREEN_OFF screen off} broadcast
 * whenever the interactive state of the device changes.  For historical reasons,
 * the names of these broadcasts refer to the power state of the screen
 * but they are actually sent in response to changes in the overall interactive
 * state of the device, as described by this method.
 * </p><p>
 * Services may use the non-interactive state as a hint to conserve power
 * since the user is not present.
 * </p>
 *
 * @return True if the device is in an interactive state.
 *
 * @see android.content.Intent#ACTION_SCREEN_ON
 * @see android.content.Intent#ACTION_SCREEN_OFF
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation changed completely, previously calling mService.isInteractive() and in the new version calling mInteractiveCache.query(null), which indicates a Dependent API changed (different method being called to achieve the functionality). The return statement has also changed. Thus the code change type is 1,5.","Since the method's implementation now relies on a different mechanism or method to obtain the interactive state (mInteractiveCache.query(null) instead of mService.isInteractive()), it might return different values under certain conditions, which could lead to a change in behavior. Therefore, the CI type is 1."
18,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>",29,30,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>","<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mimeTypeFilter, ""mimeTypeFilter"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openTypedAssetFile(mPackageName, uri, mimeTypeFilter, opts, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    Objects.requireNonNull(mimeTypeFilter, ""mimeTypeFilter"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openTypedAssetFile(mPackageName, mAttributionTag, uri, mimeTypeFilter, opts, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,,,-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has been changed: the method Preconditions.checkNotNull() has been replaced by Objects.requireNonNull(), which does the same validation function, so this doesn't lead to a behavior change. Additionally, the parameter list for mContentProvider.openTypedAssetFile() has changed with the addition of mAttributionTag, making the change type 4 and 5.","The replacement of Preconditions.checkNotNull() with Objects.requireNonNull() does not introduce a compatibility issue as both functions perform null-checks and throw a NullPointerException if the checked object is null. The introduction of mAttriburationTag in the parameter list of mContentProvider.openTypedAssetFile() is indeed a change; however, assuming that the new version of mContentProvider.openTypedAssetFile() is correctly handling the extra parameter, it doesn't inherently indicate a behavior change in the context of this method's contract. Thus, no compatibility issue is detected based on the given information."
19,<android.net.NetworkRequest.Builder: Builder setNetworkSpecifier(String)>,29,30,<android.net.NetworkRequest.Builder: Builder setNetworkSpecifier(String)>,<android.net.NetworkRequest.Builder: Builder setNetworkSpecifier(String)>,0,"{
    /*
             * A StringNetworkSpecifier does not accept null or empty ("""") strings. When network
             * specifiers were strings a null string and an empty string were considered equivalent.
             * Hence no meaning is attached to a null or empty ("""") string.
             */
    return setNetworkSpecifier(TextUtils.isEmpty(networkSpecifier) ? null : new StringNetworkSpecifier(networkSpecifier));
}","{
    try {
        int subId = Integer.parseInt(networkSpecifier);
        return setNetworkSpecifier(new TelephonyNetworkSpecifier.Builder().setSubscriptionId(subId).build());
    } catch (NumberFormatException nfe) {
        // equivalent. Hence no meaning is attached to a null or empty ("""") string.
        return setNetworkSpecifier(TextUtils.isEmpty(networkSpecifier) ? null : new StringNetworkSpecifier(networkSpecifier));
    }
}",1,"/**
 * Sets the optional bearer specific network specifier.
 * This has no meaning if a single transport is also not specified, so calling
 * this without a single transport set will generate an exception, as will
 * subsequently adding or removing transports after this is set.
 * </p>
 * The interpretation of this {@code String} is bearer specific and bearers that use
 * it should document their particulars.  For example, Bluetooth may use some sort of
 * device id while WiFi could used ssid and/or bssid.  Cellular may use carrier spn.
 *
 * @param networkSpecifier An {@code String} of opaque format used to specify the bearer
 * specific network specifier where the bearer has a choice of
 * networks.
 */
","/**
 * Sets the optional bearer specific network specifier.
 * This has no meaning if a single transport is also not specified, so calling
 * this without a single transport set will generate an exception, as will
 * subsequently adding or removing transports after this is set.
 * </p>
 * If the {@code networkSpecifier} is provided, it shall be interpreted as follows:
 * <ul>
 * <li>If the specifier can be parsed as an integer, it will be treated as a
 * {@link android.net TelephonyNetworkSpecifier}, and the provided integer will be
 * interpreted as a SubscriptionId.
 * <li>If the value is an ethernet interface name, it will be treated as such.
 * <li>For all other cases, the behavior is undefined.
 * </ul>
 *
 * @param networkSpecifier A {@code String} of either a SubscriptionId in cellular
 * network request or an ethernet interface name in ethernet
 * network request.
 *
 * @deprecated Use {@link #setNetworkSpecifier(NetworkSpecifier)} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The control structure has changed with the addition of a try-catch block and a new dependent API, TelephonyNetworkSpecifier.Builder().setSubscriptionId(subId).build(), which causes a return statement changed, exception handling statement changed, and dependent API changed. Except the added code, statements inside the try-case do not have a matching counterpart in the early version. Other statements were also added regarding the parsing of integer and new exception handling, so the change types are 1,2,3,4,5.","The CI type is 1,2 because the added try-catch block can potentially return a different value due to the conversion of the networkSpecifier to a subscription ID and the creation of a TelephonyNetworkSpecifier object, which is a new behavior in contrast with the early version. Also, the late version can throw a NumberFormatException if the parsing fails which was not possible in the early version, thus leading to a CI due to exception handling changes as well."
21,"<android.util.Half: short copySign(short,short)>",29,30,"<android.util.Half: short copySign(short,short)>","<android.util.Half: short copySign(short,short)>",0,"{
    return (short) ((sign & FP16_SIGN_MASK) | (magnitude & FP16_COMBINED));
}","{
    return (short) ((sign & FP16.SIGN_MASK) | (magnitude & FP16.EXPONENT_SIGNIFICAND_MASK));
}",1,"/**
 * Returns the first parameter with the sign of the second parameter.
 * This method treats NaNs as having a sign.
 *
 * @param magnitude A half-precision float value providing the magnitude of the result
 * @param sign  A half-precision float value providing the sign of the result
 * @return A value with the magnitude of the first parameter and the sign
 * of the second parameter
 */
","/**
 * Returns the first parameter with the sign of the second parameter.
 * This method treats NaNs as having a sign.
 *
 * @param magnitude A half-precision float value providing the magnitude of the result
 * @param sign  A half-precision float value providing the sign of the result
 * @return A value with the magnitude of the first parameter and the sign
 * of the second parameter
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,5,0,"The late version uses different constants (FP16.SIGN_MASK and FP16.EXPONENT_SIGNIFICAND_MASK instead of FP16_SIGN_MASK and FP16_COMBINED), suggesting that they belong to a class or nested class named FP16 which is different from the early version. However, without knowing if the actual values of these constants have changed, it cannot be determined whether there is a different outcome, hence this is classified as a change in a dependent API (type 5).","No Compatibility Issue is detected because the change could be just a refactoring to use constants from a nested class or a different class. There is no indication that the values of the constants have changed, so the behavior should remain the same (type 0)."
23,"<android.app.AppOpsManager: int noteProxyOpNoThrow(String,String)>",29,30,"<android.app.AppOpsManager: int noteProxyOpNoThrow(String,String)>","<android.app.AppOpsManager: int noteProxyOpNoThrow(String,String)>",0,"{
    return noteProxyOpNoThrow(strOpToOp(op), proxiedPackageName);
}","{
    return noteProxyOpNoThrow(op, proxiedPackageName, Binder.getCallingUid(), null, null);
}",1,"/**
 * Like {@link #noteProxyOp(String, String)} but instead
 * of throwing a {@link SecurityException} it returns {@link #MODE_ERRORED}.
 *
 * <p>This API requires the package with the {@code proxiedPackageName} to belongs to
 * {@link Binder#getCallingUid()}.
 */
","/**
 * @deprecated Use {@link #noteProxyOpNoThrow(String, String, int, String, String)} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",1,"The method implementation has changed by adding more parameters to the 'noteProxyOpNoThrow' method call, so the change type is 4 and 5.","The 'noteProxyOpNoThrow' method is called with different arguments which can cause a different behavior in terms of return value or internal logic. Thus, the change can potentially lead to a compatibility issue of type 1."
24,<android.view.autofill.AutofillManager: void cancel()>,29,30,<android.view.autofill.AutofillManager: void cancel()>,<android.view.autofill.AutofillManager: void cancel()>,0,"{
    if (sVerbose)
        Log.v(TAG, ""cancel() called by app"");
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        cancelLocked();
    }
}","{
    if (sVerbose)
        Log.v(TAG, ""cancel() called by app or augmented autofill service"");
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        cancelLocked();
    }
}",1,"/**
 * Called to indicate the current autofill context should be cancelled.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method if the user does not post the
 * form but moves to another form in this page.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
","/**
 * Called to indicate the current autofill context should be cancelled.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method if the user does not post the
 * form but moves to another form in this page.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is only a change in the log message from ""cancel() called by app"" to ""cancel() called by app or augmented autofill service"". This change does not affect the logic of the method, hence it is classified as type 4, other statement changed.",There is no Compatibility Issue since the behavior of the method has not changed; it will operate in the same manner because the modification is limited to a log message and has no effect on program logic or returned values from the method.
25,"<android.app.slice.Slice.Builder: Builder addRemoteInput(RemoteInput,String,List<String>)>",29,30,"<android.app.slice.Slice.Builder: Builder addRemoteInput(RemoteInput,String,List<String>)>","<android.app.slice.Slice.Builder: Builder addRemoteInput(RemoteInput,String,List<String>)>",0,"{
    Preconditions.checkNotNull(remoteInput);
    mItems.add(new SliceItem(remoteInput, SliceItem.FORMAT_REMOTE_INPUT, subType, hints));
    return this;
}","{
    Objects.requireNonNull(remoteInput);
    mItems.add(new SliceItem(remoteInput, SliceItem.FORMAT_REMOTE_INPUT, subType, hints));
    return this;
}",1,"/**
 * Add remote input to the slice being constructed
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
","/**
 * Add remote input to the slice being constructed
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is from using Preconditions.checkNotNull(remoteInput) in the early version to Objects.requireNonNull(remoteInput) in the late version. Both methods achieve the same result which is checking if an object is not null, and they throw a NullPointerException if it is. Since the behavior does not alter the method's contract or functionality, the code change type is 4 (Other statement changed).","There is no Compatibility Issue because the change does not affect the outward behavior of the API. The null check still exists and will throw an exception if 'remoteInput' is null in both versions; thus, there is no change in the method's behavior from the perspective of an API consumer."
26,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>",29,30,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method broadcastIntent(...) is replaced by broadcastIntentWithFeature(...) with additional parameter getAttributionTag(), indicating a change in a dependent API. Therefore, the code change type is 5.","There is no Compatibility Issue detected since the modification is related to an underlying service method call, and the behavior from the perspective of the caller of sendOrderedBroadcast remains unaltered. The change does not affect the return value or the exception handling of the API method itself."
28,<android.widget.TextView: boolean performLongClick()>,29,30,<android.widget.TextView: boolean performLongClick()>,<android.widget.TextView: boolean performLongClick()>,0,"{
    boolean handled = false;
    boolean performedHapticFeedback = false;
    if (mEditor != null) {
        mEditor.mIsBeingLongClicked = true;
    }
    if (super.performLongClick()) {
        handled = true;
        performedHapticFeedback = true;
    }
    if (mEditor != null) {
        handled |= mEditor.performLongClick(handled);
        mEditor.mIsBeingLongClicked = false;
    }
    if (handled) {
        if (!performedHapticFeedback) {
            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        }
        if (mEditor != null)
            mEditor.mDiscardNextActionUp = true;
    } else {
        MetricsLogger.action(mContext, MetricsEvent.TEXT_LONGPRESS, TextViewMetrics.SUBTYPE_LONG_PRESS_OTHER);
    }
    return handled;
}","{
    if (DEBUG_CURSOR) {
        logCursor(""performLongClick"", null);
    }
    boolean handled = false;
    boolean performedHapticFeedback = false;
    if (mEditor != null) {
        mEditor.mIsBeingLongClicked = true;
    }
    if (super.performLongClick()) {
        handled = true;
        performedHapticFeedback = true;
    }
    if (mEditor != null) {
        handled |= mEditor.performLongClick(handled);
        mEditor.mIsBeingLongClicked = false;
    }
    if (handled) {
        if (!performedHapticFeedback) {
            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        }
        if (mEditor != null)
            mEditor.mDiscardNextActionUp = true;
    } else {
        MetricsLogger.action(mContext, MetricsEvent.TEXT_LONGPRESS, TextViewMetrics.SUBTYPE_LONG_PRESS_OTHER);
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of a conditional logging statement at the beginning of the method. It's a non-functional change and does not affect the logic or the behavior of the method. So, the code change type is 4.","There are no changes in the behavior of the API; therefore, it does not introduce a compatibility issue. The method still performs the same actions and returns the same values under the same conditions as before. The additional logging statement does not influence the method's functional outcome. Thus, the CI type is 0."
29,"<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl,int)>",29,30,"<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl,int)>","<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl,int)>",0,"{
    final LoadedApk packageInfo = systemContext.mPackageInfo;
    ContextImpl context = new ContextImpl(null, systemContext.mMainThread, packageInfo, null, null, null, 0, null, null);
    context.setResources(createResources(null, packageInfo, null, displayId, null, packageInfo.getCompatibilityInfo()));
    context.updateDisplay(displayId);
    return context;
}","{
    final LoadedApk packageInfo = systemContext.mPackageInfo;
    ContextImpl context = new ContextImpl(null, systemContext.mMainThread, packageInfo, null, null, null, null, 0, null, null);
    context.setResources(createResources(null, packageInfo, null, displayId, null, packageInfo.getCompatibilityInfo(), null));
    context.updateDisplay(displayId);
    context.mIsSystemOrSystemUiContext = true;
    return context;
}",1,"/**
 * System Context to be used for UI. This Context has resources that can be themed.
 * Make sure that the created system UI context shares the same LoadedApk as the system context.
 * @param systemContext The system context which created by
 * {@link #createSystemContext(ActivityThread)}.
 * @param displayId The ID of the display where the UI is shown.
 */
","/**
 * System Context to be used for UI. This Context has resources that can be themed.
 * Make sure that the created system UI context shares the same LoadedApk as the system context.
 * @param systemContext The system context which created by
 * {@link #createSystemContext(ActivityThread)}.
 * @param displayId The ID of the display where the UI is shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method implementations differ by an additional field being set on the `ContextImpl` object (`context.mIsSystemOrSystemUiContext = true;`). This change is classified as an 'Other statement changed' since it does not pertain to return statements, exception handling, control dependency, or a dependent API.","The change doesn't affect the API's return value, exception handling, or control flow. It introduces a new internal state setting to the `ContextImpl` object but this should not cause compatibility issues for the clients using `createSystemUiContext` method as the returned `ContextImpl` object still fulfills its contract. The additional internal state setting does not alter the method's behavior, as it's setting a new field that did not exist in the early version. It can be presumed that this new field’s default value in the early version is the same as the value being explicitly set in the late version. Therefore, there is no compatibility issue."
31,<android.content.pm.ShortcutInfo.Builder: Builder setIntents(Intent[])>,29,30,<android.content.pm.ShortcutInfo.Builder: Builder setIntents(Intent[])>,<android.content.pm.ShortcutInfo.Builder: Builder setIntents(Intent[])>,0,"{
    Preconditions.checkNotNull(intents, ""intents cannot be null"");
    Preconditions.checkNotNull(intents.length, ""intents cannot be empty"");
    for (Intent intent : intents) {
        Preconditions.checkNotNull(intent, ""intents cannot contain null"");
        Preconditions.checkNotNull(intent.getAction(), ""intent's action must be set"");
    }
    // Make sure always clone incoming intents.
    mIntents = cloneIntents(intents);
    return this;
}","{
    Objects.requireNonNull(intents, ""intents cannot be null"");
    Objects.requireNonNull(intents.length, ""intents cannot be empty"");
    for (Intent intent : intents) {
        Objects.requireNonNull(intent, ""intents cannot contain null"");
        Objects.requireNonNull(intent.getAction(), ""intent's action must be set"");
    }
    // Make sure always clone incoming intents.
    mIntents = cloneIntents(intents);
    return this;
}",1,"/**
 * Sets multiple intents instead of a single intent, in order to launch an activity with
 * other activities in back stack.  Use {@link TaskStackBuilder} to build intents. The
 * last element in the list represents the only intent that doesn't place an activity on
 * the back stack.
 * See the {@link ShortcutManager} javadoc for details.
 *
 * @see Builder#setIntent(Intent)
 * @see ShortcutInfo#getIntents()
 * @see Context#startActivities(Intent[])
 * @see TaskStackBuilder
 */
","/**
 * Sets multiple intents instead of a single intent, in order to launch an activity with
 * other activities in back stack.  Use {@link TaskStackBuilder} to build intents. The
 * last element in the list represents the only intent that doesn't place an activity on
 * the back stack.
 * See the {@link ShortcutManager} javadoc for details.
 *
 * @see Builder#setIntent(Intent)
 * @see ShortcutInfo#getIntents()
 * @see Context#startActivities(Intent[])
 * @see TaskStackBuilder
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The code changed the usage of Preconditions.checkNotNull to Objects.requireNonNull for null checks, which is a substitution of the API to check for null conditions; hence, the change type is 4. Additionally, because a dependent API (Preconditions.checkNotNull and Objects.requireNonNull) is altered in its usage, the change type is also 5.","There is no Compatibility Issue as the behavior of Objects.requireNonNull is logically equivalent to Preconditions.checkNotNull, so the change does not lead to a potential different return value or an exception handling. Both methods will throw a NullPointerException if their conditions are not met. Thus, the CI type is 0."
32,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,29,30,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,0,"{
    checkNotNull(surface, ""surface must not be null"");
    Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    int surfaceDataspace = SurfaceUtils.getSurfaceDataspace(surface);
    // See if consumer is flexible.
    boolean isFlexible = SurfaceUtils.isFlexibleConsumer(surface);
    StreamConfiguration[] configs = surfaceDataspace == HAL_DATASPACE_DEPTH ? mDepthConfigurations : surfaceDataspace == HAL_DATASPACE_DYNAMIC_DEPTH ? mDynamicDepthConfigurations : surfaceDataspace == HAL_DATASPACE_HEIF ? mHeicConfigurations : mConfigurations;
    for (StreamConfiguration config : configs) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}","{
    Objects.requireNonNull(surface, ""surface must not be null"");
    Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    int surfaceDataspace = SurfaceUtils.getSurfaceDataspace(surface);
    // See if consumer is flexible.
    boolean isFlexible = SurfaceUtils.isFlexibleConsumer(surface);
    StreamConfiguration[] configs = surfaceDataspace == HAL_DATASPACE_DEPTH ? mDepthConfigurations : surfaceDataspace == HAL_DATASPACE_DYNAMIC_DEPTH ? mDynamicDepthConfigurations : surfaceDataspace == HAL_DATASPACE_HEIF ? mHeicConfigurations : mConfigurations;
    for (StreamConfiguration config : configs) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
","/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is the usage of a different method to check for nullity (`checkNotNull` changed to `Objects.requireNonNull`). The logic remains the same, hence it's classified as 4 (Other statement changed).","There is no Compatibility Issue since the functionality of the non-null check remains the same between versions (both will throw a NullPointerException if the `surface` is null). The method for null-checking has been changed but this does not affect the behavior of the method from the caller's perspective, therefore the CI type is 0 (No Compatibility Issue)."
33,<android.widget.TextView: TextClassifier getTextClassificationSession()>,29,30,<android.widget.TextView: TextClassifier getTextClassificationSession()>,<android.widget.TextView: TextClassifier getTextClassificationSession()>,0,"{
    if (mTextClassificationSession == null || mTextClassificationSession.isDestroyed()) {
        final TextClassificationManager tcm = mContext.getSystemService(TextClassificationManager.class);
        if (tcm != null) {
            final String widgetType;
            if (isTextEditable()) {
                widgetType = TextClassifier.WIDGET_TYPE_EDITTEXT;
            } else if (isTextSelectable()) {
                widgetType = TextClassifier.WIDGET_TYPE_TEXTVIEW;
            } else {
                widgetType = TextClassifier.WIDGET_TYPE_UNSELECTABLE_TEXTVIEW;
            }
            mTextClassificationContext = new TextClassificationContext.Builder(mContext.getPackageName(), widgetType).build();
            if (mTextClassifier != null) {
                mTextClassificationSession = tcm.createTextClassificationSession(mTextClassificationContext, mTextClassifier);
            } else {
                mTextClassificationSession = tcm.createTextClassificationSession(mTextClassificationContext);
            }
        } else {
            mTextClassificationSession = TextClassifier.NO_OP;
        }
    }
    return mTextClassificationSession;
}","{
    if (mTextClassificationSession == null || mTextClassificationSession.isDestroyed()) {
        final TextClassificationManager tcm = getTextClassificationManagerForUser();
        if (tcm != null) {
            final String widgetType;
            if (isTextEditable()) {
                widgetType = TextClassifier.WIDGET_TYPE_EDITTEXT;
            } else if (isTextSelectable()) {
                widgetType = TextClassifier.WIDGET_TYPE_TEXTVIEW;
            } else {
                widgetType = TextClassifier.WIDGET_TYPE_UNSELECTABLE_TEXTVIEW;
            }
            mTextClassificationContext = new TextClassificationContext.Builder(mContext.getPackageName(), widgetType).build();
            if (mTextClassifier != null) {
                mTextClassificationSession = tcm.createTextClassificationSession(mTextClassificationContext, mTextClassifier);
            } else {
                mTextClassificationSession = tcm.createTextClassificationSession(mTextClassificationContext);
            }
        } else {
            mTextClassificationSession = TextClassifier.NO_OP;
        }
    }
    return mTextClassificationSession;
}",1,"/**
 * Returns a session-aware text classifier.
 * This method creates one if none already exists or the current one is destroyed.
 */
","/**
 * Returns a session-aware text classifier.
 * This method creates one if none already exists or the current one is destroyed.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method invoked to get the `TextClassificationManager` instance changed from `mContext.getSystemService(TextClassificationManager.class)` to `getTextClassificationManagerForUser()`, which indicates a change in a dependent API, so the code change type is 4,5. However, there are no other changes in control flow or return statements.","Since the change is related to how the `TextClassificationManager` is obtained and does not affect the control flow or the behavior of the API, as long as the returned object behaves the same, there should be no Compatibility Issue from this change, and thus the CI type is 0."
34,<android.app.ContextImpl: int getDisplayId()>,29,30,<android.app.ContextImpl: int getDisplayId()>,<android.app.ContextImpl: int getDisplayId()>,0,"{
    return mDisplay != null ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;
}","{
    final Display display = getDisplayNoVerify();
    return display != null ? display.getDisplayId() : Display.DEFAULT_DISPLAY;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to obtain the display object changed from using the field `mDisplay` directly to calling the `getDisplayNoVerify()` method. This is reflected in the API implementation change, so the change is classified as type 4 (Other statement changed) and 5 (Dependent API changed).","Although the implementation for obtaining the display has changed, the behavior of the method is preserved. Both versions return the display's ID or the `Display.DEFAULT_DISPLAY` if the display object is `null`. There is no indication that changing the method of obtaining the display object would result in a different return value or throw a new exception, given that `getDisplayNoVerify()` should also return the same `Display` object previously held in `mDisplay`. Thus, there is no Compatibility Issue."
36,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,long,ParcelFileDescriptor,int,IBackupManager)>",29,30,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,long,ParcelFileDescriptor,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,long,ParcelFileDescriptor,int,IBackupManager)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    // Ensure that any side-effect SharedPreferences writes have landed *before*
    // we may be about to rewrite the file out from underneath
    waitForSharedPrefs();
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // And bring live SharedPreferences instances up to date
        reloadSharedPreferences();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
            IoUtils.closeQuietly(newState);
        }
    }
}","{
    doRestoreInternal(data, appVersionCode, newState, token, callbackBinder, /* excludedKeys */
    null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The entire method implementation has been replaced with a call to another method doRestoreInternal(), but without knowing what doRestoreInternal() exactly does, we cannot determine how behavior might differ. Hence, a change to a dependent API has occurred, which is code change type 5.","Since we cannot assess the behavior of the new method doRestoreInternal(), we cannot definitively state that the change leads to a compatibility issue. Therefore, we have no evidence of a compatibility issue, and the CI type is 0."
39,<android.service.notification.ZenPolicy.Builder: Builder allowAllSounds()>,29,30,<android.service.notification.ZenPolicy.Builder: Builder allowAllSounds()>,<android.service.notification.ZenPolicy.Builder: Builder allowAllSounds()>,0,"{
    for (int i = 0; i < mZenPolicy.mPriorityCategories.size(); i++) {
        mZenPolicy.mPriorityCategories.set(i, STATE_ALLOW);
    }
    mZenPolicy.mPriorityMessages = PEOPLE_TYPE_ANYONE;
    mZenPolicy.mPriorityCalls = PEOPLE_TYPE_ANYONE;
    return this;
}","{
    for (int i = 0; i < mZenPolicy.mPriorityCategories.size(); i++) {
        mZenPolicy.mPriorityCategories.set(i, STATE_ALLOW);
    }
    mZenPolicy.mPriorityMessages = PEOPLE_TYPE_ANYONE;
    mZenPolicy.mPriorityCalls = PEOPLE_TYPE_ANYONE;
    mZenPolicy.mConversationSenders = CONVERSATION_SENDERS_ANYONE;
    return this;
}",1,"/**
 * Allows all notifications to bypass DND and unmutes all streams.
 */
","/**
 * Allows all notifications to bypass DND and unmutes all streams.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"An additional assignment statement 'mZenPolicy.mConversationSenders = CONVERSATION_SENDERS_ANYONE;' is introduced in the implementation, so the code change type is 4.","The new added assignment does not change the return value or the exception handling of the method. Since it simply modifies internal state, it is unlikely to cause a Compatibility Issue based on the given context. Therefore, the API does not introduce a Compatibility Issue, and the CI type is 0."
40,<android.app.ContextImpl: IBinder getActivityToken()>,29,30,<android.app.ContextImpl: IBinder getActivityToken()>,<android.app.ContextImpl: IBinder getActivityToken()>,0,"{
    return mActivityToken;
}","{
    return mToken;
}",1,,,-1,"[@Override, @UnsupportedAppUsage]","[@Override, @UnsupportedAppUsage]",-1,-1,-1,-1,-1,-1,"1,5",1,"The variable returned has changed from mActivityToken to mToken, and there is no indication that these two variables are the same, thus a change in the return type is possible, so the code change type is 1,5.","Since the returned variable has changed, this may cause a potential different return value which can cause a compatibility issue. Therefore, the CI type is 1."
41,<android.app.usage.UsageStatsManager: boolean isAppInactive(String)>,29,30,<android.app.usage.UsageStatsManager: boolean isAppInactive(String)>,<android.app.usage.UsageStatsManager: boolean isAppInactive(String)>,0,"{
    try {
        return mService.isAppInactive(packageName, mContext.getUserId());
    } catch (RemoteException e) {
    // fall through and return default
    }
    return false;
}","{
    try {
        return mService.isAppInactive(packageName, mContext.getUserId(), mContext.getOpPackageName());
    } catch (RemoteException e) {
    // fall through and return default
    }
    return false;
}",1,"/**
 * Returns whether the specified app is currently considered inactive. This will be true if the
 * app hasn't been used directly or indirectly for a period of time defined by the system. This
 * could be of the order of several hours or days.
 * @param packageName The package name of the app to query
 * @return whether the app is currently considered inactive
 */
","/**
 * Returns whether the specified app is currently considered inactive. This will be true if the
 * app hasn't been used directly or indirectly for a period of time defined by the system. This
 * could be of the order of several hours or days. Apps are not considered inactive when the
 * device is charging.
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} to query the
 * inactive state of other apps</p>
 *
 * @param packageName The package name of the app to query
 * @return whether the app is currently considered inactive or false if querying another app
 * without {@link android.Manifest.permission#PACKAGE_USAGE_STATS}
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API mService.isAppInactive has an additional parameter in its call, which changes from mService.isAppInactive(packageName, mContext.getUserId()) to mService.isAppInactive(packageName, mContext.getUserId(), mContext.getOpPackageName()). This change represents a change in the dependent API, so the code change type is 5.","Although there is a change in the dependent API, there is no indication that the nature of the information returned by the API has changed, nor is there any change in the exception handling or return statements within the method itself. Both versions have the same fallback to return false in case of a RemoteException. Therefore, there is no Compatibility Issue as per the given definition, and the API's return value behavior and exception handling behavior are preserved, which leads to pred_CI being 0."
42,<android.os.ServiceManagerProxy: IBinder checkService(String)>,29,30,<android.os.ServiceManagerProxy: IBinder checkService(String)>,<android.os.ServiceManagerProxy: IBinder checkService(String)>,0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IServiceManager.descriptor);
    data.writeString(name);
    mRemote.transact(CHECK_SERVICE_TRANSACTION, data, reply, 0);
    IBinder binder = reply.readStrongBinder();
    reply.recycle();
    data.recycle();
    return binder;
}","{
    return mServiceManager.checkService(name);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed to call another method (mServiceManager.checkService(name)) instead of directly interacting with Parcel and mRemote. This is a dependent API change, so the code change type is 5.","There is no CI as the external behavior of the API remains the same. The method still accepts a String and returns an IBinder, but the internal implementation now relies on a call to another method that performs the same operation. The return type and exception handling remain unchanged, so there is No Compatibility Issue."
43,"<android.util.Half: short min(short,short)>",29,30,"<android.util.Half: short min(short,short)>","<android.util.Half: short min(short,short)>",0,"{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return NaN;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return NaN;
    if ((x & FP16_COMBINED) == 0 && (y & FP16_COMBINED) == 0) {
        return (x & FP16_SIGN_MASK) != 0 ? x : y;
    }
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) < ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff) ? x : y;
}","{
    return FP16.min(x, y);
}",1,"/**
 * Returns the smaller of two half-precision float values (the value closest
 * to negative infinity). Special values are handled in the following ways:
 * <ul>
 * <li>If either value is NaN, the result is NaN</li>
 * <li>{@link #NEGATIVE_ZERO} is smaller than {@link #POSITIVE_ZERO}</li>
 * </ul>
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 * @return The smaller of the two specified half-precision values
 */
","/**
 * Returns the smaller of two half-precision float values (the value closest
 * to negative infinity). Special values are handled in the following ways:
 * <ul>
 * <li>If either value is NaN, the result is NaN</li>
 * <li>{@link #NEGATIVE_ZERO} is smaller than {@link #POSITIVE_ZERO}</li>
 * </ul>
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 * @return The smaller of the two specified half-precision values
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,"1,5",1,"The original implementation logic has been replaced with a single call to FP16.min(x, y), so there is both a return statement change since the method is now returning the result of a different operation, and a dependent API change because there's a new call to an external API, FP16.min. Hence, the code change type is 1,5.","Since the method now relies on an external API (FP16.min) which might have a completely different implementation than the original inline code, there's a potential difference in the return value. Therefore, there is a compatibility issue due to potential different return values, and the CI type is 1."
44,"<android.app.AppOpsManager: int startOp(String,int,String)>",29,30,"<android.app.AppOpsManager: int startOp(String,int,String)>","<android.app.AppOpsManager: int startOp(String,int,String)>",0,"{
    return startOp(strOpToOp(op), uid, packageName);
}","{
    return startOp(op, uid, packageName, null, null);
}",1,"/**
 * Report that an application has started executing a long-running operation.  Note that you
 * must pass in both the uid and name of the application to be checked; this function will
 * verify that these two match, and if not, return {@link #MODE_IGNORED}.  If this call
 * succeeds, the last execution time of the operation for this app will be updated to
 * the current time and the operation will be marked as ""running"".  In this case you must
 * later call {@link #finishOp(String, int, String)} to report when the application is no
 * longer performing the operation.
 * @param op The operation to start.  One of the OPSTR_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or
 * {@link #MODE_IGNORED} if it is not allowed and should be silently ignored (without
 * causing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
","/**
 * @deprecated use {@link #startOp(String, int, String, String, String)} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within the return statement has changed from startOp(strOpToOp(op), uid, packageName) to startOp(op, uid, packageName, null, null), indicating not only a change in the return statement but also a change in the dependent API's signature due to the number and types of parameters. Therefore, the code change type is 1,5.","The change in the return statement and the signature of the dependent API suggest that a different overload of the startOp method is being called, which could lead to a different return value or type. Thus, the compatibility issue here is of type 1."
46,<android.view.autofill.AutofillManager: UserData getUserData()>,29,30,<android.view.autofill.AutofillManager: UserData getUserData()>,<android.view.autofill.AutofillManager: UserData getUserData()>,0,"{
    try {
        final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
        mService.getUserData(receiver);
        return receiver.getParcelableResult();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}","{
    try {
        final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
        mService.getUserData(receiver);
        return receiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get user data for field classification."");
    }
}",1,"/**
 * Gets the user data used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 *
 * @return value previously set by {@link #setUserData(UserData)} or {@code null} if it was
 * reset or if the caller currently does not have an enabled autofill service for the user.
 */
","/**
 * Gets the user data used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 *
 * @return value previously set by {@link #setUserData(UserData)} or {@code null} if it was
 * reset or if the caller currently does not have an enabled autofill service for the user.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,2","1,2","The `catch` block handling `RemoteException` no longer has a return null statement; instead, it throws a new exception. Additionally, a new `catch` block for `SyncResultReceiver.TimeoutException` has been added that throws a `RuntimeException`. These changes alter both exception handling and return behavior, so the code change types are 1 and 2.","The removal of `return null` for the `RemoteException` and the introduction of a new `catch` block that throws a `RuntimeException` for `SyncResultReceiver.TimeoutException` means that the late version of the method may throw different exceptions and no longer returns null when it catches a `RemoteException`. This could lead to a different behavior from the client's perspective, as clients of the early version might expect a null return value instead of an exception. Therefore, the method has both different return values or types and different exception handlings, and the CI types are 1 and 2."
47,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor: Stub createIInputMethodSession()>,29,30,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor: Stub createIInputMethodSession()>,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor: Stub createIInputMethodSession()>,0,"{
    synchronized (mSessionLock) {
        return new InputMethodSessionImpl(mSessionLock, mCallbackImpl, mHandler, mFinished);
    }
}","{
    synchronized (mSessionLock) {
        return new InputMethodSessionImpl(mSessionLock, mCallbackImpl, mHandler, mCancellationGroup);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's a change in the argument passed to the constructor of InputMethodSessionImpl from mFinished to mCancellationGroup, so the code change type is 4.","The change in constructor parameter does not directly imply that there will be a different return value or exception thrown. If mFinished and mCancellationGroup are functionally equivalent in terms of maintaining the state required for proper creation and handling of an InputMethodSessionImpl object, then the behavior of the API would remain unchanged. Assuming the objects have been adequately replaced without altering the functional contract, there should be no compatibility issue, thus CI type is 0."
48,<android.widget.Toast: int getXOffset()>,29,30,<android.widget.Toast: int getXOffset()>,<android.widget.Toast: int getXOffset()>,0,"{
    return mTN.mX;
}","{
    if (isSystemRenderedTextToast()) {
        Log.e(TAG, ""getXOffset() shouldn't be called on text toasts, the result may not reflect"" + "" actual values."");
    }
    return mTN.mX;
}",1,"/**
 * Return the X offset in pixels to apply to the gravity's location.
 */
","/**
 * Return the X offset in pixels to apply to the gravity's location.
 *
 * <p><strong>Warning:</strong> Starting from Android {@link Build.VERSION_CODES#R}, for apps
 * targeting API level {@link Build.VERSION_CODES#R} or higher, this method shouldn't be called
 * on text toasts as its return value may not reflect actual value since text toasts are not
 * rendered by the app anymore.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version adds an 'if' statement that logs a warning but does not affect the execution flow or change the return statement, so the code change type is 4.","Since there is no change in the behavior related to the value returned by the API or in how an exception is thrown, there is no Compatibility Issue; hence, the CI type is 0."
52,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",29,30,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>","<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",0,"{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            result = ActivityTaskManager.getService().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData(this);
            intent.prepareToLeaveProcess(this);
            result = ActivityTaskManager.getService().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), getAttributionTag(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API changed from `migrateExtraStreamToClipData()` to `migrateExtraStreamToClipData(this)`, and the `startActivity` method now includes an additional parameter `getAttributionTag()`. Therefore, the code change types are 1 for the return statement change and 5 for the dependent API changed.","These changes in dependent API calls could potentially result in different return values, as the logic for data migration and starting activity might operate differently based on these changes. Consequently, this leads to a Compatibility Issue of type 1, caused by potential different return values."
54,<android.speech.tts.TextToSpeech: void shutdown()>,29,30,<android.speech.tts.TextToSpeech: void shutdown()>,<android.speech.tts.TextToSpeech: void shutdown()>,0,"{
    // Special case, we are asked to shutdown connection that did finalize its connection.
    synchronized (mStartLock) {
        if (mConnectingServiceConnection != null) {
            mContext.unbindService(mConnectingServiceConnection);
            mConnectingServiceConnection = null;
            return;
        }
    }
    // Post connection case
    runActionNoReconnect(new Action<Void>() {

        @Override
        public Void run(ITextToSpeechService service) throws RemoteException {
            service.setCallback(getCallerIdentity(), null);
            service.stop(getCallerIdentity());
            mServiceConnection.disconnect();
            // Context#unbindService does not result in a call to
            // ServiceConnection#onServiceDisconnected. As a result, the
            // service ends up being destroyed (if there are no other open
            // connections to it) but the process lives on and the
            // ServiceConnection continues to refer to the destroyed service.
            // 
            // This leads to tons of log spam about SynthThread being dead.
            mServiceConnection = null;
            mCurrentEngine = null;
            return null;
        }
    }, null, ""shutdown"", false);
}","{
    // Special case, we are asked to shutdown connection that did finalize its connection.
    synchronized (mStartLock) {
        if (mConnectingServiceConnection != null) {
            mContext.unbindService(mConnectingServiceConnection);
            mConnectingServiceConnection = null;
            return;
        }
    }
    // Post connection case
    runActionNoReconnect((ITextToSpeechService service) -> {
        service.setCallback(getCallerIdentity(), null);
        service.stop(getCallerIdentity());
        mServiceConnection.disconnect();
        // Context#unbindService does not result in a call to
        // ServiceConnection#onServiceDisconnected. As a result, the
        // service ends up being destroyed (if there are no other open
        // connections to it) but the process lives on and the
        // ServiceConnection continues to refer to the destroyed service.
        // 
        // This leads to tons of log spam about SynthThread being dead.
        mServiceConnection = null;
        mCurrentEngine = null;
        return null;
    }, null, ""shutdown"", false);
}",1,"/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
","/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change consists of using a lambda expression instead of an anonymous inner class for the runActionNoReconnect method implementation. However, the behavior of the method remains logically unchanged.","There is no Compatibility Issue because the lambda expression is functionally equivalent to the anonymous inner class it replaces, and there is no change in the return values or exception handling. The execution logic remains the same."
56,<android.view.textclassifier.ConversationActions.Request.Builder: Builder setMaxSuggestions(int)>,29,30,<android.view.textclassifier.ConversationActions.Request.Builder: Builder setMaxSuggestions(int)>,<android.view.textclassifier.ConversationActions.Request.Builder: Builder setMaxSuggestions(int)>,0,"{
    mMaxSuggestions = Preconditions.checkArgumentNonnegative(maxSuggestions);
    return this;
}","{
    if (maxSuggestions < -1) {
        throw new IllegalArgumentException(""maxSuggestions has to be greater than or "" + ""equal to -1."");
    }
    mMaxSuggestions = maxSuggestions;
    return this;
}",1,"/**
 * Sets the maximum number of suggestions you want. Value -1 means no restriction and
 * this is the default.
 */
","/**
 * Sets the maximum number of suggestions you want. Value -1 means no restriction and
 * this is the default.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",1,"The precondition check changed from using Preconditions.checkArgumentNonnegative(maxSuggestions) to an explicit if condition check for maxSuggestions < -1, and there are changes in the exception message and the assignment statement, so the code change type is 3,4.","The precondition check used to throw an IllegalArgumentException on precondition failure in both versions. However, the condition has changed. The early version would not accept negative values, but the late version accepts -1 as a valid input. This affects the behavior of the method because it now allows a new valid input (-1) which was not accepted before. This is a Compatibility Issue due to different return values (setting the maxSuggestions to -1 is now allowed), so the CI type is 1."
57,<android.hardware.biometrics.BiometricPrompt.Builder: BiometricPrompt build()>,29,30,<android.hardware.biometrics.BiometricPrompt.Builder: BiometricPrompt build()>,<android.hardware.biometrics.BiometricPrompt.Builder: BiometricPrompt build()>,0,"{
    final CharSequence title = mBundle.getCharSequence(KEY_TITLE);
    final CharSequence negative = mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
    final boolean useDefaultTitle = mBundle.getBoolean(KEY_USE_DEFAULT_TITLE);
    final boolean enableFallback = mBundle.getBoolean(KEY_ALLOW_DEVICE_CREDENTIAL);
    if (TextUtils.isEmpty(title) && !useDefaultTitle) {
        throw new IllegalArgumentException(""Title must be set and non-empty"");
    } else if (TextUtils.isEmpty(negative) && !enableFallback) {
        throw new IllegalArgumentException(""Negative text must be set and non-empty"");
    } else if (!TextUtils.isEmpty(negative) && enableFallback) {
        throw new IllegalArgumentException(""Can't have both negative button behavior"" + "" and device credential enabled"");
    }
    return new BiometricPrompt(mContext, mBundle, mPositiveButtonInfo, mNegativeButtonInfo);
}","{
    final CharSequence title = mBundle.getCharSequence(KEY_TITLE);
    final CharSequence negative = mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
    final boolean useDefaultTitle = mBundle.getBoolean(KEY_USE_DEFAULT_TITLE, false);
    final boolean deviceCredentialAllowed = mBundle.getBoolean(KEY_ALLOW_DEVICE_CREDENTIAL);
    @Authenticators.Types final int authenticators = mBundle.getInt(KEY_AUTHENTICATORS_ALLOWED, 0);
    final boolean willShowDeviceCredentialButton = deviceCredentialAllowed || (authenticators & Authenticators.DEVICE_CREDENTIAL) != 0;
    if (TextUtils.isEmpty(title) && !useDefaultTitle) {
        throw new IllegalArgumentException(""Title must be set and non-empty"");
    } else if (TextUtils.isEmpty(negative) && !willShowDeviceCredentialButton) {
        throw new IllegalArgumentException(""Negative text must be set and non-empty"");
    } else if (!TextUtils.isEmpty(negative) && willShowDeviceCredentialButton) {
        throw new IllegalArgumentException(""Can't have both negative button behavior"" + "" and device credential enabled"");
    }
    return new BiometricPrompt(mContext, mBundle, mPositiveButtonInfo, mNegativeButtonInfo);
}",1,"/**
 * Creates a {@link BiometricPrompt}.
 * @return a {@link BiometricPrompt}
 * @throws IllegalArgumentException if any of the required fields are not set.
 */
","/**
 * Creates a {@link BiometricPrompt}.
 *
 * @return An instance of {@link BiometricPrompt}.
 *
 * @throws IllegalArgumentException If any required fields are unset, or if given any
 * invalid combination of field values.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes the addition of a default value for `useDefaultTitle` in the `getBoolean` call, the addition of a new variable `authenticators` with its associated `getInt` call, and a change in the logic for `willShowDeviceCredentialButton`. The rest of the code remains the same, which includes the exception throwing conditions and the return statement, so the change types are 3 and 4.","Although there are changes in local variables and control logic, the exceptions thrown and the return statement have not been modified. Hence, these changes will not cause the API to return a different value or throw exceptions differently unless there would be changes in the subsequent processing of the `BiometricPrompt` constructor that are not visible within the scope of the provided code. Therefore, based on the given information, there is no compatibility issue since the changes in the method are unlikely to alter the API's contract from the perspective of the caller."
60,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,29,30,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,0,"{
    return runAction(new Action<Set<String>>() {

        @Override
        public Set<String> run(ITextToSpeechService service) throws RemoteException {
            String[] features = null;
            try {
                features = service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, e);
                return null;
            }
            if (features != null) {
                final Set<String> featureSet = new HashSet<String>();
                Collections.addAll(featureSet, features);
                return featureSet;
            }
            return null;
        }
    }, null, ""getFeatures"");
}","{
    return runAction((ITextToSpeechService service) -> {
        String[] features = null;
        try {
            features = service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
        } catch (MissingResourceException e) {
            Log.w(TAG, ""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, e);
            return null;
        }
        if (features != null) {
            final Set<String> featureSet = new HashSet<String>();
            Collections.addAll(featureSet, features);
            return featureSet;
        }
        return null;
    }, null, ""getFeatures"");
}",1,"/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features values are strings and their values must meet restrictions described in their
 * documentation.
 *
 * @param locale The locale to query features for.
 * @return Set instance. May return {@code null} on error.
 * @deprecated As of API level 21, please use voices. In order to query features of the voice,
 * call {@link #getVoices()} to retrieve the list of available voices and
 * {@link Voice#getFeatures()} to retrieve the set of features.
 */
","/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features values are strings and their values must meet restrictions described in their
 * documentation.
 *
 * @param locale The locale to query features for.
 * @return Set instance. May return {@code null} on error.
 * @deprecated As of API level 21, please use voices. In order to query features of the voice,
 * call {@link #getVoices()} to retrieve the list of available voices and
 * {@link Voice#getFeatures()} to retrieve the set of features.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,The change is a syntactical one: The anonymous inner class implementing `Action<Set<String>>` has been converted to a lambda expression. The behavior of the method is unchanged as it still performs the same logic.,"There are no changes in return values, exception handling, or control flow – only the syntax has been updated to use a lambda expression, thus there is no compatibility issue."
61,<android.view.contentcapture.ContentCaptureManager: void removeData(DataRemovalRequest)>,29,30,<android.view.contentcapture.ContentCaptureManager: void removeData(DataRemovalRequest)>,<android.view.contentcapture.ContentCaptureManager: void removeData(DataRemovalRequest)>,0,"{
    Preconditions.checkNotNull(request);
    try {
        mService.removeData(request);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(request);
    try {
        mService.removeData(request);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by the app to remove content capture data associated with some context.
 *
 * @param request object specifying what data should be removed.
 */
","/**
 * Called by the app to request the content capture service to remove content capture data
 * associated with some context.
 *
 * @param request object specifying what user data should be removed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from an implicit throw (e.rethrowFromSystemServer()) to an explicit throw statement (throw e.rethrowFromSystemServer()), so the code change type is 2.","Although the way the exception is thrown has changed, it does not cause a compatibility issue regarding the behaviour of the API. The API's behaviour of propagating the exception in case of failure remains the same, hence there is no compatibility issue in this aspect and the CI type is 0."
62,<android.app.ActivityManager.TaskDescription: String toString()>,29,30,<android.app.ActivityManager.TaskDescription: String toString()>,<android.app.ActivityManager.TaskDescription: String toString()>,0,"{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconRes: "" + mIconRes + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground + "" statusBarColor: "" + mStatusBarColor + (mEnsureStatusBarContrastWhenTransparent ? "" (contrast when transparent)"" : """") + "" navigationBarColor: "" + mNavigationBarColor + (mEnsureNavigationBarContrastWhenTransparent ? "" (contrast when transparent)"" : """");
}","{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground + "" statusBarColor: "" + mStatusBarColor + (mEnsureStatusBarContrastWhenTransparent ? "" (contrast when transparent)"" : """") + "" navigationBarColor: "" + mNavigationBarColor + (mEnsureNavigationBarContrastWhenTransparent ? "" (contrast when transparent)"" : """") + "" resizeMode: "" + ActivityInfo.resizeModeToString(mResizeMode) + "" minWidth: "" + mMinWidth + "" minHeight: "" + mMinHeight;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the toString() method has changed: the ""IconRes: "" + mIconRes part has been removed and "" resizeMode: "" + ActivityInfo.resizeModeToString(mResizeMode) + "" minWidth: "" + mMinWidth + "" minHeight: "" + mMinHeight has been added. As a result, the string returned by this method will have a different format and potentially different content. The code change is therefore of type 1 for the return statement change and type 4 for other statement change.","Since the returned string from the toString() method now excludes certain pieces of information and includes new details that were not present before, the change will cause the API to return a different value, specifically a different string representation of the TaskDescription. Hence, the compatibility issue type is 1."
63,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,29,30,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!mIsUserSeekable || !isEnabled()) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            if (isInScrollingContainer()) {
                mTouchDownX = event.getX();
            } else {
                startDrag(event);
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mIsDragging) {
                trackTouchEvent(event);
            } else {
                final float x = event.getX();
                if (Math.abs(x - mTouchDownX) > mScaledTouchSlop) {
                    startDrag(event);
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsDragging) {
                trackTouchEvent(event);
                onStopTrackingTouch();
                setPressed(false);
            } else {
                // Touch up when we never crossed the touch slop threshold should
                // be interpreted as a tap-seek to that location.
                onStartTrackingTouch();
                trackTouchEvent(event);
                onStopTrackingTouch();
            }
            // ProgressBar doesn't know to repaint the thumb drawable
            // in its inactive state when the touch stops (because the
            // value has not apparently changed)
            invalidate();
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsDragging) {
                onStopTrackingTouch();
                setPressed(false);
            }
            // see above explanation
            invalidate();
            break;
    }
    return true;
}","{
    if (!mIsUserSeekable || !isEnabled()) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            if (mThumb != null) {
                final int availableWidth = getWidth() - mPaddingLeft - mPaddingRight;
                mTouchThumbOffset = (getProgress() - getMin()) / (float) (getMax() - getMin()) - (event.getX() - mPaddingLeft) / availableWidth;
                if (Math.abs(mTouchThumbOffset * availableWidth) > getThumbOffset()) {
                    mTouchThumbOffset = 0;
                }
            }
            if (isInScrollingContainer()) {
                mTouchDownX = event.getX();
            } else {
                startDrag(event);
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mIsDragging) {
                trackTouchEvent(event);
            } else {
                final float x = event.getX();
                if (Math.abs(x - mTouchDownX) > mScaledTouchSlop) {
                    startDrag(event);
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsDragging) {
                trackTouchEvent(event);
                onStopTrackingTouch();
                setPressed(false);
            } else {
                // Touch up when we never crossed the touch slop threshold should
                // be interpreted as a tap-seek to that location.
                onStartTrackingTouch();
                trackTouchEvent(event);
                onStopTrackingTouch();
            }
            // ProgressBar doesn't know to repaint the thumb drawable
            // in its inactive state when the touch stops (because the
            // value has not apparently changed)
            invalidate();
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsDragging) {
                onStopTrackingTouch();
                setPressed(false);
            }
            // see above explanation
            invalidate();
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change is in the MotionEvent.ACTION_DOWN case block where a new block of code is added to handle mThumb. This change represents a new control branch added inside an existing control structure, and also new assignment statements for 'mTouchThumbOffset' and an if condition checking on 'mThumb'. Thus the change type is 3 for control dependency change, and 4 for other statement changed.","Despite the new code, the ultimate behavior of the onTouchEvent method regarding what it returns or the exceptions it might throw has not been altered. The API still returns 'true' for any touch event as long as the view is user-seekable and enabled, and there are no new exceptions being thrown. The additional calculations only affect the internal state regarding 'mTouchThumbOffset', but they don't change the observable output or exceptions thrown by the method. Thus, there is no Compatibility Issue expected based on the provided information."
64,"<android.view.textclassifier.TextLinks: int apply(Spannable,int,Function<TextLink, TextLinkSpan>)>",29,30,"<android.view.textclassifier.TextLinks: int apply(Spannable,int,Function<TextLink, TextLinkSpan>)>","<android.view.textclassifier.TextLinks: int apply(Spannable,int,Function<TextLink, TextLinkSpan>)>",0,"{
    Preconditions.checkNotNull(text);
    return new TextLinksParams.Builder().setApplyStrategy(applyStrategy).setSpanFactory(spanFactory).build().apply(text, this);
}","{
    Objects.requireNonNull(text);
    return new TextLinksParams.Builder().setApplyStrategy(applyStrategy).setSpanFactory(spanFactory).build().apply(text, this);
}",1,"/**
 * Annotates the given text with the generated links. It will fail if the provided text doesn't
 * match the original text used to create the TextLinks.
 *
 * <p><strong>NOTE: </strong>It may be necessary to set a LinkMovementMethod on the TextView
 * widget to properly handle links. See {@link TextView#setMovementMethod(MovementMethod)}
 *
 * @param text the text to apply the links to. Must match the original text
 * @param applyStrategy the apply strategy used to determine how to apply links to text.
 * e.g {@link TextLinks#APPLY_STRATEGY_IGNORE}
 * @param spanFactory a custom span factory for converting TextLinks to TextLinkSpans.
 * Set to {@code null} to use the default span factory.
 *
 * @return a status code indicating whether or not the links were successfully applied
 * e.g. {@link #STATUS_LINKS_APPLIED}
 */
","/**
 * Annotates the given text with the generated links. It will fail if the provided text doesn't
 * match the original text used to create the TextLinks.
 *
 * <p><strong>NOTE: </strong>It may be necessary to set a LinkMovementMethod on the TextView
 * widget to properly handle links. See {@link TextView#setMovementMethod(MovementMethod)}
 *
 * @param text the text to apply the links to. Must match the original text
 * @param applyStrategy the apply strategy used to determine how to apply links to text.
 * e.g {@link TextLinks#APPLY_STRATEGY_IGNORE}
 * @param spanFactory a custom span factory for converting TextLinks to TextLinkSpans.
 * Set to {@code null} to use the default span factory.
 *
 * @return a status code indicating whether or not the links were successfully applied
 * e.g. {@link #STATUS_LINKS_APPLIED}
 */
",-1,[@Status],[@Status],-1,-1,-1,-1,-1,-1,4,0,"The null check method has changed from Preconditions.checkNotNull(text) to Objects.requireNonNull(text), but both methods serve the same purpose of ensuring that the object is not null, and will throw the same NullPointerException. So the code change type is 4.",There is no Compatibility Issue here since the change does not affect the behavior or output of the method; both versions throw a NullPointerException if 'text' is null. The result from the method execution remains the same in both versions.
65,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,29,30,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,0,"{
    Preconditions.checkNotNull(callback);
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return false;
    }
    return mOnDestroyCallbacks.remove(callback) != null;
}","{
    Objects.requireNonNull(callback);
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return false;
    }
    return mOnDestroyCallbacks.remove(callback) != null;
}",1,"/**
 * Unregisters a previously registered onDestroy callback
 *
 * @param callback The callback to remove.
 * @return whether the callback was unregistered.
 */
","/**
 * Unregisters a previously registered onDestroy callback
 *
 * @param callback The callback to remove.
 * @return whether the callback was unregistered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method Preconditions.checkNotNull(callback) has been replaced by Objects.requireNonNull(callback), which is an equivalent method change. This change is classified as 'Other statement changed' (4).","There is no Compatibility Issue since both Preconditions.checkNotNull() and Objects.requireNonNull() serve the same purpose of checking for null references and throwing a NullPointerException if necessary. The behavior of the API remains consistent between versions, so the CI type is 0."
66,<android.view.textclassifier.TextClassifier: TextLanguage detectLanguage(Request)>,29,30,<android.view.textclassifier.TextClassifier: TextLanguage detectLanguage(Request)>,<android.view.textclassifier.TextClassifier: TextLanguage detectLanguage(Request)>,0,"{
    Preconditions.checkNotNull(request);
    Utils.checkMainThread();
    return TextLanguage.EMPTY;
}","{
    Objects.requireNonNull(request);
    Utils.checkMainThread();
    return TextLanguage.EMPTY;
}",1,"/**
 * Detects the language of the text in the given request.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * @param request the {@link TextLanguage} request.
 * @return the {@link TextLanguage} result.
 */
","/**
 * Detects the language of the text in the given request.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * @param request the {@link TextLanguage} request.
 * @return the {@link TextLanguage} result.
 */
",-1,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"The only change is the replacement of Preconditions.checkNotNull(request) with Objects.requireNonNull(request), which are equivalent, therefore the change type is 4.","Since Preconditions.checkNotNull() and Objects.requireNonNull() functionally do the same check for nullity, there is no difference in behavior between the versions, hence there is no compatibility issue, CI type is 0."
67,<android.view.contentcapture.ContentCaptureManager: ComponentName getServiceSettingsComponentName()>,29,30,<android.view.contentcapture.ContentCaptureManager: ComponentName getServiceSettingsComponentName()>,<android.view.contentcapture.ContentCaptureManager: ComponentName getServiceSettingsComponentName()>,0,"{
    final IBinder binder = ServiceManager.checkService(Context.CONTENT_CAPTURE_MANAGER_SERVICE);
    if (binder == null)
        return null;
    final IContentCaptureManager service = IContentCaptureManager.Stub.asInterface(binder);
    final SyncResultReceiver resultReceiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        service.getServiceSettingsActivity(resultReceiver);
        final int resultCode = resultReceiver.getIntResult();
        if (resultCode == RESULT_CODE_SECURITY_EXCEPTION) {
            throw new SecurityException(resultReceiver.getStringResult());
        }
        return resultReceiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    final IBinder binder = ServiceManager.checkService(Context.CONTENT_CAPTURE_MANAGER_SERVICE);
    if (binder == null)
        return null;
    final IContentCaptureManager service = IContentCaptureManager.Stub.asInterface(binder);
    final SyncResultReceiver resultReceiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        service.getServiceSettingsActivity(resultReceiver);
        final int resultCode = resultReceiver.getIntResult();
        if (resultCode == RESULT_CODE_SECURITY_EXCEPTION) {
            throw new SecurityException(resultReceiver.getStringResult());
        }
        return resultReceiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        Log.e(TAG, ""Fail to get service settings componentName: "" + e);
        return null;
    }
}",1,"// TODO: use ""lite"" options as it's done by activities from the content capture service
","// TODO: use ""lite"" options as it's done by activities from the content capture service
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,2,2,"An additional catch block for SyncResultReceiver.TimeoutException is added in the late version and also includes a new return statement within that block, hence the code change type is 2.","The added catch block for the new exception (SyncResultReceiver.TimeoutException) adds an additional code path that can potentially result in a different exception being handled, which could affect the behavior of the API. This change introduces a new exception handling path that would return null instead of throwing an exception, which leads to CI type 2."
68,"<android.widget.SimpleMonthView: boolean onKeyDown(int,KeyEvent)>",29,30,"<android.widget.SimpleMonthView: boolean onKeyDown(int,KeyEvent)>","<android.widget.SimpleMonthView: boolean onKeyDown(int,KeyEvent)>",0,"{
    // We need to handle focus change within the SimpleMonthView because we are simulating
    // multiple Views. The arrow keys will move between days until there is no space (no
    // day to the left, top, right, or bottom). Focus forward and back jumps out of the
    // SimpleMonthView, skipping over other SimpleMonthViews in the parent ViewPager
    // to the next focusable View in the hierarchy.
    boolean focusChanged = false;
    switch(event.getKeyCode()) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (event.hasNoModifiers()) {
                focusChanged = moveOneDay(isLayoutRtl());
            }
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (event.hasNoModifiers()) {
                focusChanged = moveOneDay(!isLayoutRtl());
            }
            break;
        case KeyEvent.KEYCODE_DPAD_UP:
            if (event.hasNoModifiers()) {
                ensureFocusedDay();
                if (mHighlightedDay > 7) {
                    mHighlightedDay -= 7;
                    focusChanged = true;
                }
            }
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
            if (event.hasNoModifiers()) {
                ensureFocusedDay();
                if (mHighlightedDay <= mDaysInMonth - 7) {
                    mHighlightedDay += 7;
                    focusChanged = true;
                }
            }
            break;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            if (mHighlightedDay != -1) {
                onDayClicked(mHighlightedDay);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_TAB:
            {
                int focusChangeDirection = 0;
                if (event.hasNoModifiers()) {
                    focusChangeDirection = View.FOCUS_FORWARD;
                } else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                    focusChangeDirection = View.FOCUS_BACKWARD;
                }
                if (focusChangeDirection != 0) {
                    final ViewParent parent = getParent();
                    // move out of the ViewPager next/previous
                    View nextFocus = this;
                    do {
                        nextFocus = nextFocus.focusSearch(focusChangeDirection);
                    } while (nextFocus != null && nextFocus != this && nextFocus.getParent() == parent);
                    if (nextFocus != null) {
                        nextFocus.requestFocus();
                        return true;
                    }
                }
                break;
            }
    }
    if (focusChanged) {
        invalidate();
        return true;
    } else {
        return super.onKeyDown(keyCode, event);
    }
}","{
    // We need to handle focus change within the SimpleMonthView because we are simulating
    // multiple Views. The arrow keys will move between days until there is no space (no
    // day to the left, top, right, or bottom). Focus forward and back jumps out of the
    // SimpleMonthView, skipping over other SimpleMonthViews in the parent ViewPager
    // to the next focusable View in the hierarchy.
    boolean focusChanged = false;
    switch(event.getKeyCode()) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (event.hasNoModifiers()) {
                focusChanged = moveOneDay(isLayoutRtl());
            }
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (event.hasNoModifiers()) {
                focusChanged = moveOneDay(!isLayoutRtl());
            }
            break;
        case KeyEvent.KEYCODE_DPAD_UP:
            if (event.hasNoModifiers()) {
                ensureFocusedDay();
                if (mHighlightedDay > 7) {
                    mHighlightedDay -= 7;
                    focusChanged = true;
                }
            }
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
            if (event.hasNoModifiers()) {
                ensureFocusedDay();
                if (mHighlightedDay <= mDaysInMonth - 7) {
                    mHighlightedDay += 7;
                    focusChanged = true;
                }
            }
            break;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
        case KeyEvent.KEYCODE_NUMPAD_ENTER:
            if (mHighlightedDay != -1) {
                onDayClicked(mHighlightedDay);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_TAB:
            {
                int focusChangeDirection = 0;
                if (event.hasNoModifiers()) {
                    focusChangeDirection = View.FOCUS_FORWARD;
                } else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                    focusChangeDirection = View.FOCUS_BACKWARD;
                }
                if (focusChangeDirection != 0) {
                    final ViewParent parent = getParent();
                    // move out of the ViewPager next/previous
                    View nextFocus = this;
                    do {
                        nextFocus = nextFocus.focusSearch(focusChangeDirection);
                    } while (nextFocus != null && nextFocus != this && nextFocus.getParent() == parent);
                    if (nextFocus != null) {
                        nextFocus.requestFocus();
                        return true;
                    }
                }
                break;
            }
    }
    if (focusChanged) {
        invalidate();
        return true;
    } else {
        return super.onKeyDown(keyCode, event);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
69,<android.app.InstantAppResolverService.ServiceHandler: void handleMessage(Message)>,29,30,<android.app.InstantAppResolverService.ServiceHandler: void handleMessage(Message)>,<android.app.InstantAppResolverService.ServiceHandler: void handleMessage(Message)>,0,"{
    final int action = message.what;
    switch(action) {
        case MSG_GET_INSTANT_APP_RESOLVE_INFO:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final int userId = (int) args.arg3;
                final String token = (String) args.arg4;
                final Intent intent = (Intent) args.arg5;
                final int sequence = message.arg1;
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + token + ""] Phase1 request;"" + "" prefix: "" + Arrays.toString(digestPrefix) + "", userId: "" + userId);
                }
                onGetInstantAppResolveInfo(intent, digestPrefix, UserHandle.of(userId), token, new InstantAppResolutionCallback(sequence, callback));
            }
            break;
        case MSG_GET_INSTANT_APP_INTENT_FILTER:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final int userId = (int) args.arg3;
                final String token = (String) args.arg4;
                final Intent intent = (Intent) args.arg5;
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + token + ""] Phase2 request;"" + "" prefix: "" + Arrays.toString(digestPrefix) + "", userId: "" + userId);
                }
                onGetInstantAppIntentFilter(intent, digestPrefix, UserHandle.of(userId), token, new InstantAppResolutionCallback(-1, /*sequence*/
                callback));
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}","{
    final int action = message.what;
    switch(action) {
        case MSG_GET_INSTANT_APP_RESOLVE_INFO:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final InstantAppRequestInfo request = (InstantAppRequestInfo) args.arg1;
                final IRemoteCallback callback = (IRemoteCallback) args.arg2;
                args.recycle();
                final int sequence = message.arg1;
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + request.getToken() + ""] Phase1 request;"" + "" prefix: "" + Arrays.toString(request.getHostDigestPrefix()) + "", userId: "" + request.getUserHandle().getIdentifier());
                }
                onGetInstantAppResolveInfo(request, new InstantAppResolutionCallback(sequence, callback));
            }
            break;
        case MSG_GET_INSTANT_APP_INTENT_FILTER:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final InstantAppRequestInfo request = (InstantAppRequestInfo) args.arg1;
                final IRemoteCallback callback = (IRemoteCallback) args.arg2;
                args.recycle();
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + request.getToken() + ""] Phase2 request;"" + "" prefix: "" + Arrays.toString(request.getHostDigestPrefix()) + "", userId: "" + request.getUserHandle().getIdentifier());
                }
                onGetInstantAppIntentFilter(request, new InstantAppResolutionCallback(-1, /*sequence*/
                callback));
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"4,5","1,5","The code structure inside the `case MSG_GET_INSTANT_APP_RESOLVE_INFO` and `case MSG_GET_INSTANT_APP_INTENT_FILTER` have been changed, including type castings and parameter extraction into a new `InstantAppRequestInfo` object and the addition of the `args.recycle()` method call. Therefore, this is classified as a change in ""Other statement changed"". Additionally, since a new class `InstantAppRequestInfo` is used and the method `onGetInstantAppResolveInfo` and `onGetInstantAppIntentFilter` now take different parameters, this is also classified as ""Dependent API changed"".","The type and number of parameters passed to the methods `onGetInstantAppResolveInfo` and `onGetInstantAppIntentFilter` are changed, which could cause a different behavior if these methods handle the inputs differently, hence there is a potential Compatibility Issue due to different return values or types (type 1) and potential dependent API change (type 5)."
70,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",29,30,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",0,"{
    Preconditions.checkNotNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeThemeGetAttributeValue(mObject, theme, resId, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = mApkAssets[cookie - 1].getStringFromPool(outValue.data);
        }
        return true;
    }
}","{
    Objects.requireNonNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeThemeGetAttributeValue(mObject, theme, resId, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = getPooledStringForCookie(cookie, outValue.data);
        }
        return true;
    }
}",1,"/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
","/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The code change includes the exception precondition check, switching from using Preconditions.checkNotNull to Objects.requireNonNull which is a change in a dependent API (the contract between the methods is the same for null check, so the behavior does not change), and the method used to obtain the string inside the `if` block has changed from mApkAssets[cookie - 1].getStringFromPool(outValue.data) to getPooledStringForCookie(cookie, outValue.data). This also counts as a change in a dependent API, as the implementation of getting the string value for 'outValue' could potentially be different. So, the code change type is 4,5.","The change in the method used to retrieve the string value (from the Assets) could potentially return different values to the caller. Therefore, we have a CI type of 1, which indicates a Compatibility Issue caused by potential different return values."
71,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>",29,30,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>","<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>",0,"{
    Log.d(TAG, ""onScannerRegistered() - status="" + status + "" scannerId="" + scannerId + "" mScannerId="" + mScannerId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mScannerId == -1) {
                    // Registration succeeds after timeout, unregister scanner.
                    mBluetoothGatt.unregisterScanner(scannerId);
                } else {
                    mScannerId = scannerId;
                    mBluetoothGatt.startScan(mScannerId, mSettings, mFilters, mResultStorages, ActivityThread.currentOpPackageName());
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mScannerId = -1;
            }
        } else if (status == ScanCallback.SCAN_FAILED_SCANNING_TOO_FREQUENTLY) {
            // applicaiton was scanning too frequently
            mScannerId = -2;
        } else {
            // registration failed
            mScannerId = -1;
        }
        notifyAll();
    }
}","{
    Log.d(TAG, ""onScannerRegistered() - status="" + status + "" scannerId="" + scannerId + "" mScannerId="" + mScannerId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mScannerId == -1) {
                    // Registration succeeds after timeout, unregister scanner.
                    mBluetoothGatt.unregisterScanner(scannerId);
                } else {
                    mScannerId = scannerId;
                    mBluetoothGatt.startScan(mScannerId, mSettings, mFilters, mResultStorages, mOpPackageName, mFeatureId);
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mScannerId = -1;
            }
        } else if (status == ScanCallback.SCAN_FAILED_SCANNING_TOO_FREQUENTLY) {
            // applicaiton was scanning too frequently
            mScannerId = -2;
        } else {
            // registration failed
            mScannerId = -1;
        }
        notifyAll();
    }
}",1,"/**
 * Application interface registered - app is ready to go
 */
","/**
 * Application interface registered - app is ready to go
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is the addition of the 'mFeatureId' parameter in the call to 'mBluetoothGatt.startScan', while the rest of the method remains unchanged. This suggests a change in the dependent method 'startScan', which implicates a code change type of 4,5 (Other statement changed, Dependent API changed).","Although there is a change in the dependent API, since this added parameter does not affect the control flow or the exception handling and does not introduce a new return statement or any other change to the method, there is no Compatibility Issue with this change. The existing behavior of registering the scanner, starting the scan, handling exceptions, and assigning 'mScannerId' is preserved, and no new code paths have been introduced that would alter the behavior as perceived by the caller of 'onScannerRegistered'. Thus, the CI type is 0 (No Compatibility Issue)."
72,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,29,30,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,0,"{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    if (targetSdk >= Build.VERSION_CODES.Q) {
        detectCredentialProtectedWhileLocked();
    }
    return this;
}","{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    if (targetSdk >= Build.VERSION_CODES.Q) {
        detectCredentialProtectedWhileLocked();
    }
    if (targetSdk >= Build.VERSION_CODES.R) {
        detectIncorrectContextUse();
    }
    return this;
}",1,"/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of SQLite cursors, Activities, and
 * other closable objects but will likely expand in future releases.
 */
","/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of SQLite cursors, Activities, and
 * other closable objects but will likely expand in future releases.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,5",0,"A new conditional check for `targetSdk >= Build.VERSION_CODES.R` and the corresponding method call `detectIncorrectContextUse()` have been added. This change in control structure corresponds to code change type 3. Additionally, since the newly added method `detectIncorrectContextUse()` is an internal method within the Builder and is not a separate public API on its own, this does not constitute a change in a dependent API, but it's a change internal to the Builder class. Thus the code change is 3.","The addition of new detection for `detectIncorrectContextUse()` inside the conditional does not alter the behavior of `detectAll()`. The existing functionality has not been modified, and the addition of this new feature will only enlarge the set of things `detectAll()` detects. This is consistent with the method's contract to detect all issues as defined by the API level of the application. Therefore, there is no compatibility issue in terms of changing return values or exceptions thrown, as the method's return value (`this`) and exception behavior are unaffected by the added detection. As such, the CI type is 0."
74,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,29,30,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; windowId: "" + mWindowId);
        builder.append(""; accessibilityViewId: "").append(getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "").append(getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        builder.append(""; traversalBefore: "").append(mTraversalBefore);
        builder.append(""; traversalAfter: "").append(mTraversalAfter);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "").append(mBoundsInParent);
    builder.append(""; boundsInScreen: "").append(mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; tooltipText: "").append(mTooltipText);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; contextClickable: "").append(isContextClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; importantForAccessibility: "").append(isImportantForAccessibility());
    builder.append(""; visible: "").append(isVisibleToUser());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: 0x"").append(Long.toHexString(mSourceNodeId));
        builder.append(""; windowId: 0x"").append(Long.toHexString(mWindowId));
        builder.append(""; accessibilityViewId: 0x"").append(Long.toHexString(getAccessibilityViewId(mSourceNodeId)));
        builder.append(""; virtualDescendantId: 0x"").append(Long.toHexString(getVirtualDescendantId(mSourceNodeId)));
        builder.append(""; mParentNodeId: 0x"").append(Long.toHexString(mParentNodeId));
        builder.append(""; traversalBefore: 0x"").append(Long.toHexString(mTraversalBefore));
        builder.append(""; traversalAfter: 0x"").append(Long.toHexString(mTraversalAfter));
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(""0x"").append(Long.toHexString(childIds.get(i)));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "").append(mBoundsInParent);
    builder.append(""; boundsInScreen: "").append(mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; stateDescription: "").append(mStateDescription);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; tooltipText: "").append(mTooltipText);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; contextClickable: "").append(isContextClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; importantForAccessibility: "").append(isImportantForAccessibility());
    builder.append(""; visible: "").append(isVisibleToUser());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
75,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,29,30,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,0,"{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return ""FLAG_ENABLE_ACCESSIBILITY_VOLUME"";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return ""FLAG_REQUEST_ACCESSIBILITY_BUTTON"";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return ""FLAG_REQUEST_FINGERPRINT_GESTURES"";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return ""FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK"";
        default:
            return null;
    }
}","{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return ""FLAG_SERVICE_HANDLES_DOUBLE_TAP"";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return ""FLAG_REQUEST_MULTI_FINGER_GESTURES"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return ""FLAG_ENABLE_ACCESSIBILITY_VOLUME"";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return ""FLAG_REQUEST_ACCESSIBILITY_BUTTON"";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return ""FLAG_REQUEST_FINGERPRINT_GESTURES"";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return ""FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The switch cases for FLAG_SERVICE_HANDLES_DOUBLE_TAP and FLAG_REQUEST_MULTI_FINGER_GESTURES have been added, and some cases have been removed compared to the earlier version, so both the return statement and the control dependency have changed, which means the change types are 1 and 3.","The changes in the switch statement cases mean the method may return different constants for some flag values than it did previously, and since it is a flagToString() method, these string constants are part of the method's behavior. Therefore, there is a Compatibility Issue caused by potential different return values, type 1."
76,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",29,30,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>","<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",0,"{
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        Log.e(TAG, ""getProfileProxy(): BluetoothHealth is deprecated"");
        return false;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        if (isHearingAidProfileSupported()) {
            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        }
        return false;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP) {
        BluetoothPbap pbap = new BluetoothPbap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        Log.e(TAG, ""getProfileProxy(): BluetoothHealth is deprecated"");
        return false;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        if (isHearingAidProfileSupported()) {
            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        }
        return false;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP},
 * {@link BluetoothProfile#GATT}, {@link BluetoothProfile#HEARING_AID}, or {@link
 * BluetoothProfile#GATT_SERVER}. Clients must implement {@link
 * BluetoothProfile.ServiceListener} to get notified of the connection status and to get the
 * proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, {@link
 * BluetoothProfile#HEARING_AID} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP},
 * {@link BluetoothProfile#GATT}, {@link BluetoothProfile#HEARING_AID}, or {@link
 * BluetoothProfile#GATT_SERVER}. Clients must implement {@link
 * BluetoothProfile.ServiceListener} to get notified of the connection status and to get the
 * proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, {@link
 * BluetoothProfile#HEARING_AID} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
77,"<android.content.ContentResolver: String[] getStreamTypes(Uri,String)>",29,30,"<android.content.ContentResolver: String[] getStreamTypes(Uri,String)>","<android.content.ContentResolver: String[] getStreamTypes(Uri,String)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mimeTypeFilter, ""mimeTypeFilter"");
    try {
        if (mWrapped != null)
            return mWrapped.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(mimeTypeFilter, ""mimeTypeFilter"");
    try {
        if (mWrapped != null)
            return mWrapped.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Query for the possible MIME types for the representations the given
 * content URL can be returned when opened as as stream with
 * {@link #openTypedAssetFileDescriptor}.  Note that the types here are
 * not necessarily a superset of the type returned by {@link #getType} --
 * many content providers cannot return a raw stream for the structured
 * data that they contain.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @param mimeTypeFilter The desired MIME type.  This may be a pattern,
 * such as *&#47;*, to query for all available MIME types that match the
 * pattern.
 * @return Returns an array of MIME type strings for all available
 * data streams that match the given mimeTypeFilter.  If there are none,
 * null is returned.
 */
","/**
 * Query for the possible MIME types for the representations the given
 * content URL can be returned when opened as as stream with
 * {@link #openTypedAssetFileDescriptor}.  Note that the types here are
 * not necessarily a superset of the type returned by {@link #getType} --
 * many content providers cannot return a raw stream for the structured
 * data that they contain.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @param mimeTypeFilter The desired MIME type.  This may be a pattern,
 * such as *&#47;*, to query for all available MIME types that match the
 * pattern.
 * @return Returns an array of MIME type strings for all available
 * data streams that match the given mimeTypeFilter.  If there are none,
 * null is returned.
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the replacement of Preconditions.checkNotNull(...) method calls with Objects.requireNonNull(...), which serve the same purpose and have the same behavior. This is an Other statement changed of type 4.","There is no Compatibility Issue since the method's signature, logic, return values, and exception handling have not changed, but the way the null checks were performed has been modified, which does not affect the external behavior of the API. Therefore, the CI type is 0."
78,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String,CancellationSignal)>",29,30,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String,CancellationSignal)>","<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openAssetFile(mPackageName, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openAssetFile(mPackageName, mAttributionTag, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",5,"The replacement of 'Preconditions.checkNotNull' with 'Objects.requireNonNull' does not change the behavior substantially because both achieve the same goal of null checks and throw similar exceptions. However, there's an additional parameter 'mAttributionTag' in the late version when calling 'mContentProvider.openAssetFile'. This is classified as an 'Other statement changed' and a 'Dependent API changed' because the method signature that `openAssetFile` depends on has changed with the addition of a new parameter.","The consequence of including an extra parameter 'mAttributionTag' in the invocation of 'mContentProvider.openAssetFile' is a potential Compatibility Issue because it changes the API contract and could potentially alter behavior if the implementation of 'openAssetFile' in 'mContentProvider' relies on or acts differently based on the 'mAttributionTag' parameter. This could result in different return values or types depending on the handling of the new parameter, indicating a CI type of 5."
80,<android.service.notification.ZenPolicy: String toString()>,29,30,<android.service.notification.ZenPolicy: String toString()>,<android.service.notification.ZenPolicy: String toString()>,0,"{
    return new StringBuilder(ZenPolicy.class.getSimpleName()).append('{').append(""priorityCategories=["").append(priorityCategoriesToString()).append(""], visualEffects=["").append(visualEffectsToString()).append(""], priorityCalls="").append(peopleTypeToString(mPriorityCalls)).append("", priorityMessages="").append(peopleTypeToString(mPriorityMessages)).append('}').toString();
}","{
    return new StringBuilder(ZenPolicy.class.getSimpleName()).append('{').append(""priorityCategories=["").append(priorityCategoriesToString()).append(""], visualEffects=["").append(visualEffectsToString()).append(""], priorityCallsSenders="").append(peopleTypeToString(mPriorityCalls)).append("", priorityMessagesSenders="").append(peopleTypeToString(mPriorityMessages)).append("", priorityConversationSenders="").append(conversationTypeToString(mConversationSenders)).append('}').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The string literal within the StringBuilder.append() method call has been changed from "".priorityCalls="" to "".priorityCallsSenders="" and "".priorityMessages="" to "".priorityMessagesSenders="", and the addition of "", priorityConversationSenders="" with a call to conversationTypeToString(mConversationSenders). These changes affect the string representation of the object but do not alter the logic or functionality of the method. Thus, the code change type is 4 (Other statement changed).","The changes to the string literals inside the toString() method will not affect the execution or behavior of other methods relying on this method. It will not cause the API to return a different value or throw a different exception based on the internal state of the ZenPolicy object. Therefore, there is no compatibility issue, and the CI type is 0 (No Compatibility Issue)."
81,<android.app.Notification.Action: RemoteInput[] getDataOnlyRemoteInputs()>,29,30,<android.app.Notification.Action: RemoteInput[] getDataOnlyRemoteInputs()>,<android.app.Notification.Action: RemoteInput[] getDataOnlyRemoteInputs()>,0,"{
    return (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
}","{
    return getParcelableArrayFromBundle(mExtras, EXTRA_DATA_ONLY_INPUTS, RemoteInput.class);
}",1,"/**
 * Get the list of inputs to be collected from the user that ONLY accept data when this
 * action is sent. These remote inputs are guaranteed to return true on a call to
 * {@link RemoteInput#isDataOnly}.
 *
 * Returns null if there are no data-only remote inputs.
 *
 * This method exists so that legacy RemoteInput collectors that pre-date the addition
 * of non-textual RemoteInputs do not access these remote inputs.
 */
","/**
 * Get the list of inputs to be collected from the user that ONLY accept data when this
 * action is sent. These remote inputs are guaranteed to return true on a call to
 * {@link RemoteInput#isDataOnly}.
 *
 * Returns null if there are no data-only remote inputs.
 *
 * This method exists so that legacy RemoteInput collectors that pre-date the addition
 * of non-textual RemoteInputs do not access these remote inputs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to retrieve the RemoteInput array has changed, replacing the direct call to `mExtras.getParcelableArray()` with a call to the new method `getParcelableArrayFromBundle()`. This is considered an Other statement changed because of the method call change, and a Dependent API changed as another API method is now being called.","However, there is no Compatibility Issue detected because the change in the method call does not inherently affect the returned value type or the exceptions this method might throw. Both methods are intended to return an array of `RemoteInput` objects, which suggests that the change was made for internal reasons, such as code readability or maintainability, without intending to alter the behavior from an API consumer perspective."
82,<android.os.Build: String getRadioVersion()>,29,30,<android.os.Build: String getRadioVersion()>,<android.os.Build: String getRadioVersion()>,0,"{
    String propVal = SystemProperties.get(TelephonyProperties.PROPERTY_BASEBAND_VERSION);
    return TextUtils.isEmpty(propVal) ? null : propVal;
}","{
    return joinListOrElse(TelephonyProperties.baseband_version(), null);
}",1,"/**
 * Returns the version string for the radio firmware.  May return
 * null (if, for instance, the radio is not currently on).
 */
","/**
 * Returns the version string for the radio firmware.  May return
 * null (if, for instance, the radio is not currently on).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method of obtaining the radio version has changed from using SystemProperties.get() with a manual check for an empty string to using a dedicated method joinListOrElse(). This not only changes the method of obtaining the value but also the processing logic of the result, which qualifies as type 4 (Other statement changed) and type 5 (Dependent API changed).","The logic for returning the value has changed; hence it could potentially return a different value based on the new implementation. The API in the previous version returns null if the property value is empty, while it's uncertain what the new method joinListOrElse() would return under similar conditions. Assuming the logic potentially behaves differently, this qualifies as a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values)."
83,<android.view.View: ContentCaptureSession getContentCaptureSession()>,29,30,<android.view.View: ContentCaptureSession getContentCaptureSession()>,<android.view.View: ContentCaptureSession getContentCaptureSession()>,0,"{
    if (mCachedContentCaptureSession != null) {
        return mCachedContentCaptureSession;
    }
    mCachedContentCaptureSession = getAndCacheContentCaptureSession();
    return mCachedContentCaptureSession;
}","{
    if (mContentCaptureSessionCached) {
        return mContentCaptureSession;
    }
    mContentCaptureSession = getAndCacheContentCaptureSession();
    mContentCaptureSessionCached = true;
    return mContentCaptureSession;
}",1,"/**
 * Gets the session used to notify content capture events.
 *
 * @return session explicitly set by {@link #setContentCaptureSession(ContentCaptureSession)},
 * inherited by ancestors, default session or {@code null} if content capture is disabled for
 * this view.
 */
","/**
 * Gets the session used to notify content capture events.
 *
 * @return session explicitly set by {@link #setContentCaptureSession(ContentCaptureSession)},
 * inherited by ancestors, default session or {@code null} if content capture is disabled for
 * this view.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"3,4",0,"The variable name that is checked and returned has changed, as well as the addition of the flag variable `mContentCaptureSessionCached` to indicate caching status. Therefore, the code change types are 3 and 4.","Despite changes in the variable names and the incorporation of an additional caching flag, the logic of the API remains the same—cache and return a ContentCaptureSession if it's not already cached. This should not cause any potential Compatibility Issues, so the CI type is 0."
84,<android.view.accessibility.AccessibilityRecord: StringBuilder appendTo(StringBuilder)>,29,30,<android.view.accessibility.AccessibilityRecord: StringBuilder appendTo(StringBuilder)>,<android.view.accessibility.AccessibilityRecord: StringBuilder appendTo(StringBuilder)>,0,"{
    builder.append("" [ ClassName: "").append(mClassName);
    if (!DEBUG_CONCISE_TOSTRING || !isEmpty(mText)) {
        appendPropName(builder, ""Text"").append(mText);
    }
    append(builder, ""ContentDescription"", mContentDescription);
    append(builder, ""ItemCount"", mItemCount);
    append(builder, ""CurrentItemIndex"", mCurrentItemIndex);
    appendUnless(true, PROPERTY_ENABLED, builder);
    appendUnless(false, PROPERTY_PASSWORD, builder);
    appendUnless(false, PROPERTY_CHECKED, builder);
    appendUnless(false, PROPERTY_FULL_SCREEN, builder);
    appendUnless(false, PROPERTY_SCROLLABLE, builder);
    append(builder, ""BeforeText"", mBeforeText);
    append(builder, ""FromIndex"", mFromIndex);
    append(builder, ""ToIndex"", mToIndex);
    append(builder, ""ScrollX"", mScrollX);
    append(builder, ""ScrollY"", mScrollY);
    append(builder, ""MaxScrollX"", mMaxScrollX);
    append(builder, ""MaxScrollY"", mMaxScrollY);
    append(builder, ""AddedCount"", mAddedCount);
    append(builder, ""RemovedCount"", mRemovedCount);
    append(builder, ""ParcelableData"", mParcelableData);
    builder.append("" ]"");
    return builder;
}","{
    builder.append("" [ ClassName: "").append(mClassName);
    if (!DEBUG_CONCISE_TOSTRING || !isEmpty(mText)) {
        appendPropName(builder, ""Text"").append(mText);
    }
    append(builder, ""ContentDescription"", mContentDescription);
    append(builder, ""ItemCount"", mItemCount);
    append(builder, ""CurrentItemIndex"", mCurrentItemIndex);
    appendUnless(true, PROPERTY_ENABLED, builder);
    appendUnless(false, PROPERTY_PASSWORD, builder);
    appendUnless(false, PROPERTY_CHECKED, builder);
    appendUnless(false, PROPERTY_FULL_SCREEN, builder);
    appendUnless(false, PROPERTY_SCROLLABLE, builder);
    append(builder, ""BeforeText"", mBeforeText);
    append(builder, ""FromIndex"", mFromIndex);
    append(builder, ""ToIndex"", mToIndex);
    append(builder, ""ScrollX"", mScrollX);
    append(builder, ""ScrollY"", mScrollY);
    append(builder, ""MaxScrollX"", mMaxScrollX);
    append(builder, ""MaxScrollY"", mMaxScrollY);
    append(builder, ""ScrollDeltaX"", mScrollDeltaX);
    append(builder, ""ScrollDeltaY"", mScrollDeltaY);
    append(builder, ""AddedCount"", mAddedCount);
    append(builder, ""RemovedCount"", mRemovedCount);
    append(builder, ""ParcelableData"", mParcelableData);
    builder.append("" ]"");
    return builder;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"Two new append method calls (for ""ScrollDeltaX"" and ""ScrollDeltaY"") have been added in the late version, indicating the addition of new fields to the builder's output. This constitutes an ""other statement changed"" as it is neither a return statement, exception handling, control dependency, nor dependent API change.","The addition of new information (""ScrollDeltaX"" and ""ScrollDeltaY"") to the output of the StringBuilder object means that the return value (the StringBuilder object with appended text) will be different in the late version compared to the early version. This is a Compatibility Issue caused by potential different return values."
87,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",29,30,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>","<android.view.View: boolean draw(Canvas,ViewGroup,long)>",0,"{
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
    boolean drawingWithRenderNode = mAttachInfo != null && mAttachInfo.mHardwareAccelerated && hardwareAcceleratedCanvas;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;
    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    // TODO: signify cache state with just 'cache' local
    int layerType = getLayerType();
    if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
        if (layerType != LAYER_TYPE_NONE) {
            // If not drawing with RenderNode, treat HW layers as SW
            layerType = LAYER_TYPE_SOFTWARE;
            buildDrawingCache(true);
        }
        cache = getDrawingCache(true);
    }
    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.hasDisplayList()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;
    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((RecordingCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            if (alpha < 1) {
                mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            }
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            if (alpha < 1) {
                mLayerPaint.setAlpha(layerPaintAlpha);
            }
        }
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
    boolean drawingWithRenderNode = mAttachInfo != null && mAttachInfo.mHardwareAccelerated && hardwareAcceleratedCanvas;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;
    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    // TODO: signify cache state with just 'cache' local
    int layerType = getLayerType();
    if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
        if (layerType != LAYER_TYPE_NONE) {
            // If not drawing with RenderNode, treat HW layers as SW
            layerType = LAYER_TYPE_SOFTWARE;
            buildDrawingCache(true);
        }
        cache = getDrawingCache(true);
    }
    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.hasDisplayList()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;
    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((RecordingCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            if (alpha < 1) {
                mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            }
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            if (alpha < 1) {
                mLayerPaint.setAlpha(layerPaintAlpha);
            }
        }
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 *
 * This is where the View specializes rendering behavior based on layer type,
 * and hardware acceleration.
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 *
 * This is where the View specializes rendering behavior based on layer type,
 * and hardware acceleration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
91,<android.accessibilityservice.GestureDescription.Builder: Builder addStroke(StrokeDescription)>,29,30,<android.accessibilityservice.GestureDescription.Builder: Builder addStroke(StrokeDescription)>,<android.accessibilityservice.GestureDescription.Builder: Builder addStroke(StrokeDescription)>,0,"{
    if (mStrokes.size() >= MAX_STROKE_COUNT) {
        throw new IllegalStateException(""Attempting to add too many strokes to a gesture"");
    }
    mStrokes.add(strokeDescription);
    if (getTotalDuration(mStrokes) > MAX_GESTURE_DURATION_MS) {
        mStrokes.remove(strokeDescription);
        throw new IllegalStateException(""Gesture would exceed maximum duration with new stroke"");
    }
    return this;
}","{
    if (mStrokes.size() >= MAX_STROKE_COUNT) {
        throw new IllegalStateException(""Attempting to add too many strokes to a gesture. Maximum is "" + MAX_STROKE_COUNT + "", got "" + mStrokes.size());
    }
    mStrokes.add(strokeDescription);
    if (getTotalDuration(mStrokes) > MAX_GESTURE_DURATION_MS) {
        mStrokes.remove(strokeDescription);
        throw new IllegalStateException(""Gesture would exceed maximum duration with new stroke"");
    }
    return this;
}",1,"/**
 * Add a stroke to the gesture description. Up to
 * {@link GestureDescription#getMaxStrokeCount()} paths may be
 * added to a gesture, and the total gesture duration (earliest path start time to latest
 * path end time) may not exceed {@link GestureDescription#getMaxGestureDuration()}.
 *
 * @param strokeDescription the stroke to add.
 *
 * @return this
 */
","/**
 * Adds a stroke to the gesture description. Up to
 * {@link GestureDescription#getMaxStrokeCount()} paths may be
 * added to a gesture, and the total gesture duration (earliest path start time to latest
 * path end time) may not exceed {@link GestureDescription#getMaxGestureDuration()}.
 *
 * @param strokeDescription the stroke to add.
 *
 * @return this
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The exception message text within the IllegalStateException thrown when mStrokes.size() >= MAX_STROKE_COUNT has been updated to include more details. This is an ""Other statement changed"" but does not affect the exception type or behavior—it is merely a change in the exception message text, so the code change type is 4.","Since the change in the exception message does not affect the API's behavior, and no new exceptions are thrown or existing exceptions are removed, there is no Compatibility Issue—thus, the CI type is 0."
92,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",29,30,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new Future2Task<Boolean>(handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account, false);
        }

        @Override
        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}","{
    return removeAccountAsUser(account, callback, handler, mContext.getUser());
}",1,"/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 * @deprecated use
 * {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}
 * instead
 */
","/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 * @deprecated use
 * {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}
 * instead
 */
",-1,[@Deprecated],"[@UserHandleAware, @Deprecated]",-1,-1,-1,-1,-1,-1,"1,5",1,"The entire method body has been replaced with a call to another method removeAccountAsUser(account, callback, handler, mContext.getUser()), and this introduces a potential different dependent API call, thus change type is 1,5.","Since the method implementation has switched to another API and the internal workings may differ, this could potentially lead to a different return value or behavior from the API, resulting in a CI type 1."
93,<android.service.textclassifier.TextClassifierService.ProxyCallback: void onSuccess(T)>,29,30,<android.service.textclassifier.TextClassifierService.ProxyCallback: void onSuccess(T)>,<android.service.textclassifier.TextClassifierService.ProxyCallback: void onSuccess(T)>,0,"{
    ITextClassifierCallback callback = mTextClassifierCallback.get();
    if (callback == null) {
        return;
    }
    try {
        Bundle bundle = new Bundle(1);
        bundle.putParcelable(KEY_RESULT, result);
        callback.onSuccess(bundle);
    } catch (RemoteException e) {
        Slog.d(LOG_TAG, ""Error calling callback"");
    }
}","{
    try {
        Bundle bundle = new Bundle(1);
        bundle.putParcelable(KEY_RESULT, result);
        mTextClassifierCallback.onSuccess(bundle);
    } catch (RemoteException e) {
        Slog.d(LOG_TAG, ""Error calling callback"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The check for null `callback` object is removed in the late version, and the way `onSuccess` is called on `mTextClassifierCallback` is different. Also, the local variable `callback` is removed and `mTextClassifierCallback.onSuccess(bundle);` is directly called, so the change is in control dependency (3) and other statements (4).","There is no compatibility issue if we assume `mTextClassifierCallback` in the late version is guaranteed to be non-null (no evidence of nullability change). The removal of the null check does not affect the main functionality of the API in terms of return values or exceptions thrown as the RemoteException is handled the same way in both versions. Hence, the compatibility issue class is 0."
94,<android.app.ContextImpl: File[] getExternalCacheDirs()>,29,30,<android.app.ContextImpl: File[] getExternalCacheDirs()>,<android.app.ContextImpl: File[] getExternalCacheDirs()>,0,"{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppCacheDirs(getPackageName());
        return ensureExternalDirsExistOrFilter(dirs);
    }
}","{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppCacheDirs(getPackageName());
        // created through StorageManagerService.
        return ensureExternalDirsExistOrFilter(dirs, false);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within the return statement changed from ensureExternalDirsExistOrFilter(dirs) to ensureExternalDirsExistOrFilter(dirs, false), involving an added parameter which indicates a change in the dependent API; therefore, the change types are 1 and 5.","The addition of a new parameter to the method call could potentially change the return value of the API because the behavior of ensureExternalDirsExistOrFilter might be different with the new parameter, leading to the CI type being 1."
96,<android.view.ViewGroup: WindowInsets dispatchApplyWindowInsets(WindowInsets)>,29,30,<android.view.ViewGroup: WindowInsets dispatchApplyWindowInsets(WindowInsets)>,<android.view.ViewGroup: WindowInsets dispatchApplyWindowInsets(WindowInsets)>,0,"{
    insets = super.dispatchApplyWindowInsets(insets);
    if (View.sBrokenInsetsDispatch) {
        return brokenDispatchApplyWindowInsets(insets);
    } else {
        return newDispatchApplyWindowInsets(insets);
    }
}","{
    insets = super.dispatchApplyWindowInsets(insets);
    if (insets.isConsumed()) {
        return insets;
    }
    if (View.sBrokenInsetsDispatch) {
        return brokenDispatchApplyWindowInsets(insets);
    } else {
        return newDispatchApplyWindowInsets(insets);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,An additional control statement 'if (insets.isConsumed())' is introduced which checks the state of the insets before proceeding to the conditional logic for 'sBrokenInsetsDispatch'. There are no other changes in return statements or exception handling logic within the given context. The change type is 3.,"The additional 'if' condition is a guard clause that returns 'insets' early if they are consumed. This does not modify the behavior of existing return paths when 'insets.isConsumed()' evaluates to false. All original paths and behaviors are preserved with the additional consideration of consumed insets which is part of the intended API usage. Therefore, there is no Compatibility Issue."
97,"<android.view.KeyEvent: KeyEvent changeTimeRepeat(KeyEvent,long,int,int)>",29,30,"<android.view.KeyEvent: KeyEvent changeTimeRepeat(KeyEvent,long,int,int)>","<android.view.KeyEvent: KeyEvent changeTimeRepeat(KeyEvent,long,int,int)>",0,"{
    KeyEvent ret = new KeyEvent(event);
    ret.mEventTime = eventTime;
    ret.mRepeatCount = newRepeat;
    ret.mFlags = newFlags;
    return ret;
}","{
    KeyEvent ret = new KeyEvent(event);
    // Not an exact copy so assign a new ID.
    ret.mId = nativeNextId();
    ret.mEventTime = eventTime;
    ret.mRepeatCount = newRepeat;
    ret.mFlags = newFlags;
    return ret;
}",1,"/**
 * Create a new key event that is the same as the given one, but whose
 * event time and repeat count are replaced with the given value.
 *
 * @param event The existing event to be copied.  This is not modified.
 * @param eventTime The new event time
 * (in {@link android.os.SystemClock#uptimeMillis}) of the event.
 * @param newRepeat The new repeat count of the event.
 * @param newFlags New flags for the event, replacing the entire value
 * in the original event.
 */
","/**
 * Create a new key event that is the same as the given one, but whose
 * event time and repeat count are replaced with the given value.
 *
 * @param event The existing event to be copied.  This is not modified.
 * @param eventTime The new event time
 * (in {@link android.os.SystemClock#uptimeMillis}) of the event.
 * @param newRepeat The new repeat count of the event.
 * @param newFlags New flags for the event, replacing the entire value
 * in the original event.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"An additional statement has been added in the late version to assign a new ID to the created KeyEvent object, which is an assignment statement that does not belong to the return, exception handling, or control dependency categories. Plus, no existing statement was altered or removed. It also calls a new method, nativeNextId(), which is a change to a dependent API. Therefore, the change type is 4,5.","The newly introduced id assignment does not affect the public behavior of the method in terms of the returned object's visible state to the caller. It does not change the return type or the value returned by the method in a way that is visible outside the KeyEvent object. Since the value and the type of the returned KeyEvent object remain consistent, despite its internal id value changing, there should be no compatibility issue arising from this particular change."
99,<android.app.NotificationChannel: boolean canBubble()>,29,30,<android.app.NotificationChannel: boolean canBubble()>,<android.app.NotificationChannel: boolean canBubble()>,0,"{
    return mAllowBubbles;
}","{
    return mAllowBubbles == ALLOW_BUBBLE_ON;
}",1,"/**
 * Returns whether notifications posted to this channel can display outside of the notification
 * shade, in a floating window on top of other apps.
 */
","/**
 * Returns whether notifications posted to this channel are allowed to display outside of the
 * notification shade, in a floating window on top of other apps.
 *
 * @see Notification#getBubbleMetadata()
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from directly returning the value of mAllowBubbles to evaluating whether mAllowBubbles equals ALLOW_BUBBLE_ON. This means in the previous version any nonzero value of mAllowBubbles would evaluate to `true`, but in this version only the specific value ALLOW_BUBBLE_ON will return `true`. Therefore, the change type is 1.","Since the return value is potentially different between the two versions when mAllowBubbles holds any value other than ALLOW_BUBBLE_ON and nonzero, the CI type is 1."
101,<android.view.textclassifier.ConversationActions.Request: String getCallingPackageName()>,29,30,<android.view.textclassifier.ConversationActions.Request: String getCallingPackageName()>,<android.view.textclassifier.ConversationActions.Request: String getCallingPackageName()>,0,"{
    return mCallingPackageName;
}","{
    return mSystemTcMetadata != null ? mSystemTcMetadata.getCallingPackageName() : null;
}",1,"/**
 * Returns the name of the package that sent this request.
 * This returns {@code null} if no calling package name is set.
 */
","/**
 * Returns the name of the package that sent this request.
 * This returns {@code null} if no calling package name is set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed from directly returning `mCallingPackageName` to a conditional statement that returns a value from `mSystemTcMetadata` or null. Moreover, there seems to be a dependency change where it now relies on `mSystemTcMetadata.getCallingPackageName()` which indicates a Dependent API changed, so the classification is 1,5.","The change to the return statement means that the method could potentially return a different value than before, particularly if `mSystemTcMetadata` is not null and provides a different calling package name, causing a CI of type 1."
103,"<android.app.admin.DevicePolicyManager: void clearApplicationUserData(ComponentName,String,Executor,OnClearApplicationUserDataListener)>",29,30,"<android.app.admin.DevicePolicyManager: void clearApplicationUserData(ComponentName,String,Executor,OnClearApplicationUserDataListener)>","<android.app.admin.DevicePolicyManager: void clearApplicationUserData(ComponentName,String,Executor,OnClearApplicationUserDataListener)>",0,"{
    throwIfParentInstance(""clearAppData"");
    Preconditions.checkNotNull(executor);
    Preconditions.checkNotNull(listener);
    try {
        mService.clearApplicationUserData(admin, packageName, new IPackageDataObserver.Stub() {

            public void onRemoveCompleted(String pkg, boolean succeeded) {
                executor.execute(() -> listener.onApplicationUserDataCleared(pkg, succeeded));
            }
        });
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""clearAppData"");
    Objects.requireNonNull(executor);
    Objects.requireNonNull(listener);
    try {
        mService.clearApplicationUserData(admin, packageName, new IPackageDataObserver.Stub() {

            public void onRemoveCompleted(String pkg, boolean succeeded) {
                executor.execute(() -> listener.onApplicationUserDataCleared(pkg, succeeded));
            }
        });
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by the device owner or profile owner to clear application user data of a given
 * package. The behaviour of this is equivalent to the target application calling
 * {@link android.app.ActivityManager#clearApplicationUserData()}.
 *
 * <p><strong>Note:</strong> an application can store data outside of its application data, e.g.
 * external storage or user dictionary. This data will not be wiped by calling this API.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package which will have its user data wiped.
 * @param executor The executor through which the listener should be invoked.
 * @param listener A callback object that will inform the caller when the clearing is done.
 * @throws SecurityException if the caller is not the device owner/profile owner.
 */
","/**
 * Called by the device owner or profile owner to clear application user data of a given
 * package. The behaviour of this is equivalent to the target application calling
 * {@link android.app.ActivityManager#clearApplicationUserData()}.
 *
 * <p><strong>Note:</strong> an application can store data outside of its application data, e.g.
 * external storage or user dictionary. This data will not be wiped by calling this API.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package which will have its user data wiped.
 * @param executor The executor through which the listener should be invoked.
 * @param listener A callback object that will inform the caller when the clearing is done.
 * @throws SecurityException if the caller is not the device owner/profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The check for the nullability of 'executor' and 'listener' parameters changed from using Preconditions.checkNotNull() to Objects.requireNonNull(). This is a minor change in the mechanism used to check if the passed arguments are non-null.,"There is no Compatibility Issue as changing from Preconditions.checkNotNull() to Objects.requireNonNull() doesn't affect the API's behavior externally, since both methods throw a NullPointerException if the passed argument is null."
105,<android.speech.SpeechRecognizer: void startListening(Intent)>,29,30,<android.speech.SpeechRecognizer: void startListening(Intent)>,<android.speech.SpeechRecognizer: void startListening(Intent)>,0,"{
    if (recognizerIntent == null) {
        throw new IllegalArgumentException(""intent must not be null"");
    }
    checkIsCalledFromMainThread();
    if (mConnection == null) {
        // first time connection
        mConnection = new Connection();
        Intent serviceIntent = new Intent(RecognitionService.SERVICE_INTERFACE);
        if (mServiceComponent == null) {
            String serviceComponent = Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.VOICE_RECOGNITION_SERVICE);
            if (TextUtils.isEmpty(serviceComponent)) {
                Log.e(TAG, ""no selected voice recognition service"");
                mListener.onError(ERROR_CLIENT);
                return;
            }
            serviceIntent.setComponent(ComponentName.unflattenFromString(serviceComponent));
        } else {
            serviceIntent.setComponent(mServiceComponent);
        }
        if (!mContext.bindService(serviceIntent, mConnection, Context.BIND_AUTO_CREATE)) {
            Log.e(TAG, ""bind to recognition service failed"");
            mConnection = null;
            mService = null;
            mListener.onError(ERROR_CLIENT);
            return;
        }
    }
    putMessage(Message.obtain(mHandler, MSG_START, recognizerIntent));
}","{
    if (recognizerIntent == null) {
        throw new IllegalArgumentException(""intent must not be null"");
    }
    checkIsCalledFromMainThread();
    if (mConnection == null) {
        // first time connection
        mConnection = new Connection();
        Intent serviceIntent = new Intent(RecognitionService.SERVICE_INTERFACE);
        if (mServiceComponent == null) {
            String serviceComponent = Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.VOICE_RECOGNITION_SERVICE);
            if (TextUtils.isEmpty(serviceComponent)) {
                Log.e(TAG, ""no selected voice recognition service"");
                mListener.onError(ERROR_CLIENT);
                return;
            }
            serviceIntent.setComponent(ComponentName.unflattenFromString(serviceComponent));
        } else {
            serviceIntent.setComponent(mServiceComponent);
        }
        if (!mContext.bindService(serviceIntent, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_INCLUDE_CAPABILITIES)) {
            Log.e(TAG, ""bind to recognition service failed"");
            mConnection = null;
            mService = null;
            mListener.onError(ERROR_CLIENT);
            return;
        }
    }
    putMessage(Message.obtain(mHandler, MSG_START, recognizerIntent));
}",1,"/**
 * Starts listening for speech. Please note that
 * {@link #setRecognitionListener(RecognitionListener)} should be called beforehand, otherwise
 * no notifications will be received.
 *
 * @param recognizerIntent contains parameters for the recognition to be performed. The intent
 * may also contain optional extras, see {@link RecognizerIntent}. If these values are
 * not set explicitly, default values will be used by the recognizer.
 */
","/**
 * Starts listening for speech. Please note that
 * {@link #setRecognitionListener(RecognitionListener)} should be called beforehand, otherwise
 * no notifications will be received.
 *
 * @param recognizerIntent contains parameters for the recognition to be performed. The intent
 * may also contain optional extras, see {@link RecognizerIntent}. If these values are
 * not set explicitly, default values will be used by the recognizer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the flags argument of the bindService() call by adding Context.BIND_INCLUDE_CAPABILITIES, which constitutes a change in the other statements, so the code change type is 4.","There is no Compatibility Issue since the behavior of starting the listening for speech recognition is not altered by the change in the flags for binding the service. The method still performs the same actions and has the same control flow for error handling, and the change in the flags does not inherently affect the method's output or exception throwing behavior."
106,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,29,30,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            return service.isLanguageAvailable(language, country, loc.getVariant());
        }
    }, LANG_NOT_SUPPORTED, ""isLanguageAvailable"");
}","{
    return runAction((ITextToSpeechService service) -> {
        String language = null, country = null;
        try {
            language = loc.getISO3Language();
        } catch (MissingResourceException e) {
            Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
            return LANG_NOT_SUPPORTED;
        }
        try {
            country = loc.getISO3Country();
        } catch (MissingResourceException e) {
            Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
            return LANG_NOT_SUPPORTED;
        }
        return service.isLanguageAvailable(language, country, loc.getVariant());
    }, LANG_NOT_SUPPORTED, ""isLanguageAvailable"");
}",1,"/**
 * Checks if the specified language as represented by the Locale is available and supported.
 *
 * @param loc The Locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Checks if the specified language as represented by the Locale is available and supported.
 *
 * @param loc The Locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has been changed from an anonymous class to a lambda expression, which does not change the behavior of the method, but is a change in the code style. Thus, the code change type is 4.",There is no Compatibility Issue since lambda expressions are simply a more concise way to implement functional interfaces in Java and the behavior of the method remains the same.
107,<android.content.ContentProviderOperation.Builder: Builder withValueBackReferences(ContentValues)>,29,30,<android.content.ContentProviderOperation.Builder: Builder withValueBackReferences(ContentValues)>,<android.content.ContentProviderOperation.Builder: Builder withValueBackReferences(ContentValues)>,0,"{
    if (mType != TYPE_INSERT && mType != TYPE_UPDATE && mType != TYPE_ASSERT) {
        throw new IllegalArgumentException(""only inserts, updates, and asserts can have value back-references"");
    }
    mValuesBackReferences = backReferences;
    return this;
}","{
    assertValuesAllowed();
    final ArrayMap<String, Object> rawValues = backReferences.getValues();
    for (int i = 0; i < rawValues.size(); i++) {
        setValue(rawValues.keyAt(i), new BackReference((int) rawValues.valueAt(i), null));
    }
    return this;
}",1,"/**
 * Add a {@link ContentValues} of back references. The key is the name of the column
 * and the value is an integer that is the index of the previous result whose
 * value should be used for the column. The value is added as a {@link String}.
 * A column value from the back references takes precedence over a value specified in
 * {@link #withValues}.
 * This can only be used with builders of type insert, update, or assert.
 * @return this builder, to allow for chaining.
 */
","/**
 * Configure the given values to be dynamically overwritten using the
 * result of a previous operation. This method will replace any
 * previously defined values for these keys.
 *
 * @param backReferences set of values where the key indicates which
 * value to configure and the value the index indicating
 * which historical {@link ContentProviderResult} should
 * overwrite the value
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The early implementation has a condition check and sets the variable directly, while the late implementation calls a new method assertValuesAllowed(), applies a for loop to iterate over the ContentValues received and creates new BackReference objects, changing how the mValuesBackReferences is populated. These changes include modifications of the exception handling, control flow structure, and dependent API. Therefore, the code change types are 1 for return statement (as the builder behavior may change), 2 for the exception handling (introduction of a new method that might throw exceptions), 4 for other statement changes, and 5 for the dependent API change (usage of new BackReference constructor).","The original implementation could throw an IllegalArgumentException under certain conditions, while the new implementation uses an assert method that might throw a different type of exception depending on its implementation. Also, the logic of setting mValuesBackReferences has changed which might result in different values being set, potentially changing the behavior significantly. Therefore, there is a compatibility issue of type 1 due to the potential for different return values or types, and type 2 due to changed exception handling."
108,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,29,30,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,0,"{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null);
}","{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    final AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    if (mLeashedChild != null && childId == LEASHED_NODE_ID) {
        return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mLeashedChild, ROOT_NODE_ID, false, FLAG_PREFETCH_DESCENDANTS, null);
    }
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null);
}",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version adds a new conditional block checking if 'mLeashedChild' is not null and 'childId' is equal to 'LEASHED_NODE_ID'. Additionally, there is an introduction of a 'final' modifier added to the client declaration, which is minor and has no impact on behavior, classified as 'Other statement changed'. There are no changes in the exception handling part, making the code change types 3 (Control dependency changed) and 4 (Other statement changed).","The newly introduced condition and subsequent return statement could potentially return a different 'AccessibilityNodeInfo' object than the early version would, depending on the new condition. Therefore, there is a potential Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
109,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,29,30,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            String variant = loc.getVariant();
            // As of API level 21, setLanguage is implemented using setVoice.
            // (which, in the default implementation, will call loadLanguage on the service
            // interface).
            // Sanitize locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                // Get the default voice for the locale.
                String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
                if (TextUtils.isEmpty(voiceName)) {
                    Log.w(TAG, ""Couldn't find the default voice for "" + language + ""-"" + country + ""-"" + variant);
                    return LANG_NOT_SUPPORTED;
                }
                // Load it.
                if (service.loadVoice(getCallerIdentity(), voiceName) == TextToSpeech.ERROR) {
                    Log.w(TAG, ""The service claimed "" + language + ""-"" + country + ""-"" + variant + "" was available with voice name "" + voiceName + "" but loadVoice returned ERROR"");
                    return LANG_NOT_SUPPORTED;
                }
                // Set the language/country/variant of the voice, so #getLanguage will return
                // the currently set voice locale when called.
                Voice voice = getVoice(service, voiceName);
                if (voice == null) {
                    Log.w(TAG, ""getDefaultVoiceNameFor returned "" + voiceName + "" for locale "" + language + ""-"" + country + ""-"" + variant + "" but getVoice returns null"");
                    return LANG_NOT_SUPPORTED;
                }
                String voiceLanguage = """";
                try {
                    voiceLanguage = voice.getLocale().getISO3Language();
                } catch (MissingResourceException e) {
                    Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + voice.getLocale(), e);
                }
                String voiceCountry = """";
                try {
                    voiceCountry = voice.getLocale().getISO3Country();
                } catch (MissingResourceException e) {
                    Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + voice.getLocale(), e);
                }
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, voiceName);
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, voiceLanguage);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, voiceCountry);
                mParams.putString(Engine.KEY_PARAM_VARIANT, voice.getLocale().getVariant());
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, ""setLanguage"");
}","{
    return runAction((ITextToSpeechService service) -> {
        if (loc == null) {
            return LANG_NOT_SUPPORTED;
        }
        String language = null, country = null;
        try {
            language = loc.getISO3Language();
        } catch (MissingResourceException e) {
            Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
            return LANG_NOT_SUPPORTED;
        }
        try {
            country = loc.getISO3Country();
        } catch (MissingResourceException e) {
            Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
            return LANG_NOT_SUPPORTED;
        }
        String variant = loc.getVariant();
        // As of API level 21, setLanguage is implemented using setVoice.
        // (which, in the default implementation, will call loadLanguage on the service
        // interface).
        // Sanitize locale using isLanguageAvailable.
        int result = service.isLanguageAvailable(language, country, variant);
        if (result >= LANG_AVAILABLE) {
            // Get the default voice for the locale.
            String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
            if (TextUtils.isEmpty(voiceName)) {
                Log.w(TAG, ""Couldn't find the default voice for "" + language + ""-"" + country + ""-"" + variant);
                return LANG_NOT_SUPPORTED;
            }
            // Load it.
            if (service.loadVoice(getCallerIdentity(), voiceName) == TextToSpeech.ERROR) {
                Log.w(TAG, ""The service claimed "" + language + ""-"" + country + ""-"" + variant + "" was available with voice name "" + voiceName + "" but loadVoice returned ERROR"");
                return LANG_NOT_SUPPORTED;
            }
            // Set the language/country/variant of the voice, so #getLanguage will return
            // the currently set voice locale when called.
            Voice voice = getVoice(service, voiceName);
            if (voice == null) {
                Log.w(TAG, ""getDefaultVoiceNameFor returned "" + voiceName + "" for locale "" + language + ""-"" + country + ""-"" + variant + "" but getVoice returns null"");
                return LANG_NOT_SUPPORTED;
            }
            String voiceLanguage = """";
            try {
                voiceLanguage = voice.getLocale().getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + voice.getLocale(), e);
            }
            String voiceCountry = """";
            try {
                voiceCountry = voice.getLocale().getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + voice.getLocale(), e);
            }
            mParams.putString(Engine.KEY_PARAM_VOICE_NAME, voiceName);
            mParams.putString(Engine.KEY_PARAM_LANGUAGE, voiceLanguage);
            mParams.putString(Engine.KEY_PARAM_COUNTRY, voiceCountry);
            mParams.putString(Engine.KEY_PARAM_VARIANT, voice.getLocale().getVariant());
        }
        return result;
    }, LANG_NOT_SUPPORTED, ""setLanguage"");
}",1,"/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * This method sets the current voice to the default one for the given Locale;
 * {@link #getVoice()} can be used to retrieve it.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * This method sets the current voice to the default one for the given Locale;
 * {@link #getVoice()} can be used to retrieve it.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
111,<android.util.Half: short ceil(short)>,29,30,<android.util.Half: short ceil(short)>,<android.util.Half: short ceil(short)>,0,"{
    int bits = h & 0xffff;
    int e = bits & 0x7fff;
    int result = bits;
    if (e < 0x3c00) {
        result &= FP16_SIGN_MASK;
        result |= 0x3c00 & -(~(bits >> 15) & (e != 0 ? 1 : 0));
    } else if (e < 0x6400) {
        e = 25 - (e >> 10);
        int mask = (1 << e) - 1;
        result += mask & ((bits >> 15) - 1);
        result &= ~mask;
    }
    return (short) result;
}","{
    return FP16.ceil(h);
}",1,"/**
 * Returns the smallest half-precision float value toward negative infinity
 * greater than or equal to the specified half-precision float value.
 * Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The smallest half-precision float value toward negative infinity
 * greater than or equal to the specified half-precision float value
 */
","/**
 * Returns the smallest half-precision float value toward negative infinity
 * greater than or equal to the specified half-precision float value.
 * Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The smallest half-precision float value toward negative infinity
 * greater than or equal to the specified half-precision float value
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has been completely replaced with a call to the method FP16.ceil(h), which is a dependent API change, so the code change type is 5.","There is no direct evidence from the provided code that the behavior of the FP16.ceil(h) method has changed between versions 29 and 30, which means there's no information to suggest a different return value or type or a different exception being thrown. Therefore, there is no Compatibility Issue, thus the CI type is 0."
112,"<android.content.pm.ApplicationInfo: void writeToParcel(Parcel,int)>",29,30,"<android.content.pm.ApplicationInfo: void writeToParcel(Parcel,int)>","<android.content.pm.ApplicationInfo: void writeToParcel(Parcel,int)>",0,"{
    super.writeToParcel(dest, parcelableFlags);
    dest.writeString(taskAffinity);
    dest.writeString(permission);
    dest.writeString(processName);
    dest.writeString(className);
    dest.writeInt(theme);
    dest.writeInt(flags);
    dest.writeInt(privateFlags);
    dest.writeInt(requiresSmallestWidthDp);
    dest.writeInt(compatibleWidthLimitDp);
    dest.writeInt(largestWidthLimitDp);
    if (storageUuid != null) {
        dest.writeInt(1);
        dest.writeLong(storageUuid.getMostSignificantBits());
        dest.writeLong(storageUuid.getLeastSignificantBits());
    } else {
        dest.writeInt(0);
    }
    dest.writeString(scanSourceDir);
    dest.writeString(scanPublicSourceDir);
    dest.writeString(sourceDir);
    dest.writeString(publicSourceDir);
    dest.writeStringArray(splitNames);
    dest.writeStringArray(splitSourceDirs);
    dest.writeStringArray(splitPublicSourceDirs);
    dest.writeSparseArray((SparseArray) splitDependencies);
    dest.writeString(nativeLibraryDir);
    dest.writeString(secondaryNativeLibraryDir);
    dest.writeString(nativeLibraryRootDir);
    dest.writeInt(nativeLibraryRootRequiresIsa ? 1 : 0);
    dest.writeString(primaryCpuAbi);
    dest.writeString(secondaryCpuAbi);
    dest.writeStringArray(resourceDirs);
    dest.writeString(seInfo);
    dest.writeString(seInfoUser);
    dest.writeStringArray(sharedLibraryFiles);
    dest.writeTypedList(sharedLibraryInfos);
    dest.writeString(dataDir);
    dest.writeString(deviceProtectedDataDir);
    dest.writeString(credentialProtectedDataDir);
    dest.writeInt(uid);
    dest.writeInt(minSdkVersion);
    dest.writeInt(targetSdkVersion);
    dest.writeLong(longVersionCode);
    dest.writeInt(enabled ? 1 : 0);
    dest.writeInt(enabledSetting);
    dest.writeInt(installLocation);
    dest.writeString(manageSpaceActivityName);
    dest.writeString(backupAgentName);
    dest.writeInt(descriptionRes);
    dest.writeInt(uiOptions);
    dest.writeInt(fullBackupContent);
    dest.writeInt(networkSecurityConfigRes);
    dest.writeInt(category);
    dest.writeInt(targetSandboxVersion);
    dest.writeString(classLoaderName);
    dest.writeStringArray(splitClassLoaderNames);
    dest.writeInt(compileSdkVersion);
    dest.writeString(compileSdkVersionCodename);
    dest.writeString(appComponentFactory);
    dest.writeInt(iconRes);
    dest.writeInt(roundIconRes);
    dest.writeInt(mHiddenApiPolicy);
    dest.writeInt(hiddenUntilInstalled ? 1 : 0);
    dest.writeString(zygotePreloadName);
}","{
    if (dest.maybeWriteSquashed(this)) {
        return;
    }
    super.writeToParcel(dest, parcelableFlags);
    dest.writeString8(taskAffinity);
    dest.writeString8(permission);
    dest.writeString8(processName);
    dest.writeString8(className);
    dest.writeInt(theme);
    dest.writeInt(flags);
    dest.writeInt(privateFlags);
    dest.writeInt(requiresSmallestWidthDp);
    dest.writeInt(compatibleWidthLimitDp);
    dest.writeInt(largestWidthLimitDp);
    if (storageUuid != null) {
        dest.writeInt(1);
        dest.writeLong(storageUuid.getMostSignificantBits());
        dest.writeLong(storageUuid.getLeastSignificantBits());
    } else {
        dest.writeInt(0);
    }
    dest.writeString8(scanSourceDir);
    dest.writeString8(scanPublicSourceDir);
    dest.writeString8(sourceDir);
    dest.writeString8(publicSourceDir);
    dest.writeString8Array(splitNames);
    dest.writeString8Array(splitSourceDirs);
    dest.writeString8Array(splitPublicSourceDirs);
    dest.writeSparseArray((SparseArray) splitDependencies);
    dest.writeString8(nativeLibraryDir);
    dest.writeString8(secondaryNativeLibraryDir);
    dest.writeString8(nativeLibraryRootDir);
    dest.writeInt(nativeLibraryRootRequiresIsa ? 1 : 0);
    dest.writeString8(primaryCpuAbi);
    dest.writeString8(secondaryCpuAbi);
    dest.writeString8Array(resourceDirs);
    dest.writeString8(seInfo);
    dest.writeString8(seInfoUser);
    dest.writeString8Array(sharedLibraryFiles);
    dest.writeTypedList(sharedLibraryInfos);
    dest.writeString8(dataDir);
    dest.writeString8(deviceProtectedDataDir);
    dest.writeString8(credentialProtectedDataDir);
    dest.writeInt(uid);
    dest.writeInt(minSdkVersion);
    dest.writeInt(targetSdkVersion);
    dest.writeLong(longVersionCode);
    dest.writeInt(enabled ? 1 : 0);
    dest.writeInt(enabledSetting);
    dest.writeInt(installLocation);
    dest.writeString8(manageSpaceActivityName);
    dest.writeString8(backupAgentName);
    dest.writeInt(descriptionRes);
    dest.writeInt(uiOptions);
    dest.writeInt(fullBackupContent);
    dest.writeBoolean(crossProfile);
    dest.writeInt(networkSecurityConfigRes);
    dest.writeInt(category);
    dest.writeInt(targetSandboxVersion);
    dest.writeString8(classLoaderName);
    dest.writeString8Array(splitClassLoaderNames);
    dest.writeInt(compileSdkVersion);
    dest.writeString8(compileSdkVersionCodename);
    dest.writeString8(appComponentFactory);
    dest.writeInt(iconRes);
    dest.writeInt(roundIconRes);
    dest.writeInt(mHiddenApiPolicy);
    dest.writeInt(hiddenUntilInstalled ? 1 : 0);
    dest.writeString8(zygotePreloadName);
    dest.writeInt(gwpAsanMode);
}",1,,,-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,,,,
113,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRequestQueueEmpty()>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRequestQueueEmpty()>,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRequestQueueEmpty()>,0,"{
    final StateCallbackKK sessionCallback;
    if (DEBUG) {
        Log.v(TAG, ""Request queue becomes empty"");
    }
    synchronized (mInterfaceLock) {
        sessionCallback = mSessionStateCallback;
    }
    if (sessionCallback == null)
        return;
    sessionCallback.onRequestQueueEmpty();
}","{
    final StateCallbackKK sessionCallback;
    if (DEBUG) {
        Log.v(TAG, ""Request queue becomes empty"");
    }
    synchronized (mInterfaceLock) {
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onRequestQueueEmpty();
            return;
        }
        sessionCallback = mSessionStateCallback;
    }
    if (sessionCallback == null)
        return;
    sessionCallback.onRequestQueueEmpty();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version introduces a new check for mOfflineSessionImpl and a corresponding new call to onRequestQueueEmpty() on a different object within the synchronized block, as well as a new return statement within that block. This is a control dependency change because the execution path has been altered (type 3). A return statement was also introduced inside the control dependency, which could lead to the method returning at a different point (type 1).","The newly introduced condition `if (mOfflineSessionImpl != null)` and the subsequent return statement inside the synchronized block could lead to the method finishing its execution early, potentially not calling `sessionCallback.onRequestQueueEmpty();`, which it would have called in the previous version. This is a compatibility issue due to a potential different return behavior (type 1)."
114,<android.net.Uri.StringUri: Uri readFrom(Parcel)>,29,30,<android.net.Uri.StringUri: Uri readFrom(Parcel)>,<android.net.Uri.StringUri: Uri readFrom(Parcel)>,0,"{
    return new StringUri(parcel.readString());
}","{
    return new StringUri(parcel.readString8());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor of StringUri now takes the result of parcel.readString8() instead of parcel.readString(), so the dependent API has changed, thus making the type 1,5.","The change from readString() to readString8() could potentially lead to a different value being returned, as these methods may differ in how they handle character encoding. Therefore, the CI type is 1 due to potential different return values."
115,"<android.view.ViewGroup: void dispatchDrawableHotspotChanged(float,float)>",29,30,"<android.view.ViewGroup: void dispatchDrawableHotspotChanged(float,float)>","<android.view.ViewGroup: void dispatchDrawableHotspotChanged(float,float)>",0,"{
    final int count = mChildrenCount;
    if (count == 0) {
        return;
    }
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        // Children that are clickable on their own should not
        // receive hotspots when their parent view does.
        final boolean nonActionable = !child.isClickable() && !child.isLongClickable();
        final boolean duplicatesState = (child.mViewFlags & DUPLICATE_PARENT_STATE) != 0;
        if (nonActionable || duplicatesState) {
            final float[] point = getTempPoint();
            point[0] = x;
            point[1] = y;
            transformPointToViewLocal(point, child);
            child.drawableHotspotChanged(point[0], point[1]);
        }
    }
}","{
    final int count = mChildrenCount;
    if (count == 0) {
        return;
    }
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        // Children that are clickable on their own should not
        // receive hotspots when their parent view does.
        final boolean nonActionable = !child.isClickable() && !child.isLongClickable();
        final boolean duplicatesState = (child.mViewFlags & DUPLICATE_PARENT_STATE) != 0;
        if (nonActionable || duplicatesState) {
            final float[] point = getTempLocationF();
            point[0] = x;
            point[1] = y;
            transformPointToViewLocal(point, child);
            child.drawableHotspotChanged(point[0], point[1]);
        }
    }
}",1,"/**
 * Dispatches drawable hotspot changes to child views that meet at least
 * one of the following criteria:
 * <ul>
 * <li>Returns {@code false} from both {@link View#isClickable()} and
 * {@link View#isLongClickable()}</li>
 * <li>Requests duplication of parent state via
 * {@link View#setDuplicateParentStateEnabled(boolean)}</li>
 * </ul>
 *
 * @param x hotspot x coordinate
 * @param y hotspot y coordinate
 * @see #drawableHotspotChanged(float, float)
 */
","/**
 * Dispatches drawable hotspot changes to child views that meet at least
 * one of the following criteria:
 * <ul>
 * <li>Returns {@code false} from both {@link View#isClickable()} and
 * {@link View#isLongClickable()}</li>
 * <li>Requests duplication of parent state via
 * {@link View#setDuplicateParentStateEnabled(boolean)}</li>
 * </ul>
 *
 * @param x hotspot x coordinate
 * @param y hotspot y coordinate
 * @see #drawableHotspotChanged(float, float)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method getTempPoint() has been changed to getTempLocationF(). This is an internal helper method change, so the code change type is 4,5.","The change from getTempPoint() to getTempLocationF() does not cause a Compatibility Issue because it's an internal change and does not affect the API's contract regarding its return type, thrown exceptions, or behaviour as seen by the caller."
116,"<android.hardware.usb.UsbRequest: boolean initialize(UsbDeviceConnection,UsbEndpoint)>",29,30,"<android.hardware.usb.UsbRequest: boolean initialize(UsbDeviceConnection,UsbEndpoint)>","<android.hardware.usb.UsbRequest: boolean initialize(UsbDeviceConnection,UsbEndpoint)>",0,"{
    mEndpoint = endpoint;
    mConnection = Preconditions.checkNotNull(connection, ""connection"");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open(""close"");
    }
    return wasInitialized;
}","{
    mEndpoint = endpoint;
    mConnection = Objects.requireNonNull(connection, ""connection"");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open(""close"");
    }
    return wasInitialized;
}",1,"/**
 * Initializes the request so it can read or write data on the given endpoint.
 * Whether the request allows reading or writing depends on the direction of the endpoint.
 *
 * @param endpoint the endpoint to be used for this request.
 * @return true if the request was successfully opened.
 */
","/**
 * Initializes the request so it can read or write data on the given endpoint.
 * Whether the request allows reading or writing depends on the direction of the endpoint.
 *
 * @param endpoint the endpoint to be used for this request.
 * @return true if the request was successfully opened.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the two implementations is replacing Preconditions.checkNotNull with Objects.requireNonNull, which both achieve the same goal of throwing a NullPointerException with the specified detail message if the object reference tested is null. The check itself remains the same and will throw an exception at the same point for the same condition, so the change type is 4.","There is no Compatibility Issue as the behavior of the method does not change; the exception thrown for a null connection remains the same, the message is the same, and no other code changes affect the return value or exception throwing behavior. Thus, the CI type is 0."
117,"<android.service.notification.NotificationAssistantService.NotificationAssistantServiceWrapper: void onNotificationEnqueuedWithChannel(IStatusBarNotificationHolder,NotificationChannel)>",29,30,"<android.service.notification.NotificationAssistantService.NotificationAssistantServiceWrapper: void onNotificationEnqueuedWithChannel(IStatusBarNotificationHolder,NotificationChannel)>","<android.service.notification.NotificationAssistantService.NotificationAssistantServiceWrapper: void onNotificationEnqueuedWithChannel(IStatusBarNotificationHolder,NotificationChannel)>",0,"{
    StatusBarNotification sbn;
    try {
        sbn = sbnHolder.get();
    } catch (RemoteException e) {
        Log.w(TAG, ""onNotificationEnqueued: Error receiving StatusBarNotification"", e);
        return;
    }
    SomeArgs args = SomeArgs.obtain();
    args.arg1 = sbn;
    args.arg2 = channel;
    mHandler.obtainMessage(MyHandler.MSG_ON_NOTIFICATION_ENQUEUED, args).sendToTarget();
}","{
    StatusBarNotification sbn;
    try {
        sbn = sbnHolder.get();
    } catch (RemoteException e) {
        Log.w(TAG, ""onNotificationEnqueued: Error receiving StatusBarNotification"", e);
        return;
    }
    if (sbn == null) {
        Log.w(TAG, ""onNotificationEnqueuedWithChannel: "" + ""Error receiving StatusBarNotification"");
        return;
    }
    SomeArgs args = SomeArgs.obtain();
    args.arg1 = sbn;
    args.arg2 = channel;
    mHandler.obtainMessage(MyHandler.MSG_ON_NOTIFICATION_ENQUEUED, args).sendToTarget();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"A new control dependency is introduced with the addition of an 'if' statement that checks if sbn is null, and based on that condition, a different behavior is applied. Therefore, the code change type is 3.","The introduction of a new 'if' condition that checks if 'sbn' is null could alter the behavior of the API, leading to it potentially returning earlier without sending a message to the handler. Consequently, the API could behave differently and return nothing instead of proceeding with the message sending. This difference could lead to a Compatibility Issue of type 1 due to the potential different return behavior."
120,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,29,30,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            Size displaySize = getDisplaySize();
            // exception in case cameraId is a hidden physical camera.
            if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                try {
                    info.setCameraId(Integer.parseInt(cameraId));
                } catch (NumberFormatException e) {
                    Log.e(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer"");
                }
                info.setDisplaySize(displaySize);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}","{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            Size displaySize = getDisplaySize();
            // exception in case cameraId is a hidden physical camera.
            if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                try {
                    info.setCameraId(Integer.parseInt(cameraId));
                } catch (NumberFormatException e) {
                    // For external camera, reaching here is expected.
                    Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer"");
                }
                boolean hasConcurrentStreams = CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId);
                info.setHasMandatoryConcurrentStreams(hasConcurrentStreams);
                info.setDisplaySize(displaySize);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * <p>Also starting with API level 29, while most basic camera information is still available
 * even without the CAMERA permission, some values are not available to apps that do not hold
 * that permission. The keys not available are listed by
 * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The log level has changed from Log.e (error) to Log.v (verbose) in the catch block for NumberFormatException. Additionally, there are two new lines of code: one that checks if the camera has concurrent streams and another that sets this information in the metadata. These changes are not related to return statements, exception handling, or control dependencies, thus the code change type is 4.","None of the changes affect the API's behavior in terms of returning different values or handling exceptions differently. The log message severity level change does not affect the API's behavior, and the added metadata (concurrent streams capability) is also unrelated to the existing return values or exception handling. Therefore, there is no compatibility issue, and the CI type is 0."
121,"<android.ddm.DdmHandleAppName: void setAppName(String,int)>",29,30,"<android.ddm.DdmHandleAppName: void setAppName(String,int)>","<android.ddm.DdmHandleAppName: void setAppName(String,int)>",0,"{
    if (name == null || name.length() == 0)
        return;
    mAppName = name;
    // if DDMS is already connected, send the app name up
    sendAPNM(name, userId);
}","{
    setAppName(name, name, userId);
}",1,"/**
 * Set the application name.  Called when we get named, which may be
 * before or after DDMS connects.  For the latter we need to send up
 * an APNM message.
 */
","/**
 * Sets all names to the same name.
 */
",-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has entirely changed, instead of directly performing actions, it is now calling another method with similar parameters. Thus, the change type is 5.","The potential behaviors of the API could be maintained as the logic seems to be moved into another overloaded method. Without further information about the changes in behavior of the called method compared to the inline logic previously used, it cannot be conclusively said that a CI has arisen. Assuming the new method (setAppName with three parameters) performs the same actions with the previous inlined logic, there would be no Compatibility Issue, hence the CI type is 0."
122,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,29,30,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mCurrentMotionEvent != null) {
        mCurrentMotionEvent.recycle();
    }
    mCurrentMotionEvent = MotionEvent.obtain(ev);
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            mHasRecordedClassification = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), mCurrentDownEvent.getDownTime() + ViewConfiguration.getLongPressTimeout());
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final int motionClassification = ev.getClassification();
            final boolean hasPendingLongPress = mHandler.hasMessages(LONG_PRESS);
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                final boolean shouldInhibitDefaultAction = hasPendingLongPress && ambiguousGesture;
                if (shouldInhibitDefaultAction) {
                    // Inhibit default long press
                    final float multiplier = ViewConfiguration.getAmbiguousGestureMultiplier();
                    if (distance > slopSquare) {
                        // The default action here is to remove long press. But if the touch
                        // slop below gets increased, and we never exceed the modified touch
                        // slop while still receiving AMBIGUOUS_GESTURE, we risk that *nothing*
                        // will happen in response to user input. To prevent this,
                        // reschedule long press with a modified timeout.
                        mHandler.removeMessages(LONG_PRESS);
                        final long longPressTimeout = ViewConfiguration.getLongPressTimeout();
                        mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), ev.getDownTime() + (long) (longPressTimeout * multiplier));
                    }
                    // Inhibit default scroll. If a gesture is ambiguous, we prevent scroll
                    // until the gesture is resolved.
                    // However, for safety, simply increase the touch slop in case the
                    // classification is erroneous. Since the value is squared, multiply twice.
                    slopSquare *= multiplier * multiplier;
                }
                if (distance > slopSquare) {
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
            if (deepPress && hasPendingLongPress) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessage(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS, 0));
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SINGLE_TAP);
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mCurrentMotionEvent != null) {
        mCurrentMotionEvent.recycle();
    }
    mCurrentMotionEvent = MotionEvent.obtain(ev);
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            mHasRecordedClassification = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), mCurrentDownEvent.getDownTime() + ViewConfiguration.getLongPressTimeout());
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final int motionClassification = ev.getClassification();
            final boolean hasPendingLongPress = mHandler.hasMessages(LONG_PRESS);
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                final boolean shouldInhibitDefaultAction = hasPendingLongPress && ambiguousGesture;
                if (shouldInhibitDefaultAction) {
                    // Inhibit default long press
                    if (distance > slopSquare) {
                        // The default action here is to remove long press. But if the touch
                        // slop below gets increased, and we never exceed the modified touch
                        // slop while still receiving AMBIGUOUS_GESTURE, we risk that *nothing*
                        // will happen in response to user input. To prevent this,
                        // reschedule long press with a modified timeout.
                        mHandler.removeMessages(LONG_PRESS);
                        final long longPressTimeout = ViewConfiguration.getLongPressTimeout();
                        mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), ev.getDownTime() + (long) (longPressTimeout * mAmbiguousGestureMultiplier));
                    }
                    // Inhibit default scroll. If a gesture is ambiguous, we prevent scroll
                    // until the gesture is resolved.
                    // However, for safety, simply increase the touch slop in case the
                    // classification is erroneous. Since the value is squared, multiply twice.
                    slopSquare *= mAmbiguousGestureMultiplier * mAmbiguousGestureMultiplier;
                }
                if (distance > slopSquare) {
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
            if (deepPress && hasPendingLongPress) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessage(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS, 0));
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SINGLE_TAP);
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}",1,"/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
","/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
123,<android.view.textclassifier.TextSelection.Request: String getCallingPackageName()>,29,30,<android.view.textclassifier.TextSelection.Request: String getCallingPackageName()>,<android.view.textclassifier.TextSelection.Request: String getCallingPackageName()>,0,"{
    return mCallingPackageName;
}","{
    return mSystemTcMetadata != null ? mSystemTcMetadata.getCallingPackageName() : null;
}",1,"/**
 * Returns the name of the package that sent this request.
 * This returns {@code null} if no calling package name is set.
 */
","/**
 * Returns the name of the package that sent this request.
 * This returns {@code null} if no calling package name is set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,4",1,"The method of obtaining the return value has been altered from directly returning a member variable to using a ternary conditional operator to decide the return value. Therefore, the code changes are of type 1, representing a return statement changed, and type 4, indicating other statement changes.","The change in the way the return value is obtained could potentially lead to the API returning a different value than before. Depending on whether mSystemTcMetadata is non-null and what the getCallingPackageName() method of mSystemTcMetadata returns, the outcomes could vary. Hence, there is a Compatibility Issue of type 1 caused by potential different return values."
124,<android.view.GestureExclusionTracker.GestureExclusionViewInfo: int update()>,29,30,<android.view.GestureExclusionTracker.GestureExclusionViewInfo: int update()>,<android.view.GestureExclusionTracker.GestureExclusionViewInfo: int update()>,0,"{
    final View excludedView = getView();
    if (excludedView == null || !excludedView.isAttachedToWindow())
        return GONE;
    final List<Rect> localRects = excludedView.getSystemGestureExclusionRects();
    final List<Rect> newRects = new ArrayList<>(localRects.size());
    for (Rect src : localRects) {
        Rect mappedRect = new Rect(src);
        ViewParent p = excludedView.getParent();
        if (p != null && p.getChildVisibleRect(excludedView, mappedRect, null)) {
            newRects.add(mappedRect);
        }
    }
    if (mExclusionRects.equals(localRects))
        return UNCHANGED;
    mExclusionRects = newRects;
    return CHANGED;
}","{
    final View excludedView = getView();
    if (excludedView == null || !excludedView.isAttachedToWindow() || !excludedView.isAggregatedVisible())
        return GONE;
    final List<Rect> localRects = excludedView.getSystemGestureExclusionRects();
    final List<Rect> newRects = new ArrayList<>(localRects.size());
    for (Rect src : localRects) {
        Rect mappedRect = new Rect(src);
        ViewParent p = excludedView.getParent();
        if (p != null && p.getChildVisibleRect(excludedView, mappedRect, null)) {
            newRects.add(mappedRect);
        }
    }
    if (mExclusionRects.equals(localRects))
        return UNCHANGED;
    mExclusionRects = newRects;
    return CHANGED;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition in the if statement has an additional check for `!excludedView.isAggregatedVisible()` in the late version, which represents a control dependency change; hence the code change type is 3.","This additional condition can lead to a scenario where 'return GONE;' might be executed more frequently in the newer version compared to the older version, which indicates a potential change in the returned value. Therefore, the CI type is 1."
125,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,29,30,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final AtomicBoolean isUnbindIssued = (AtomicBoolean) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, isUnbindIssued) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken, moreArgs.argi2 == 1);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final CancellationGroup cancellationGroup = (CancellationGroup) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, cancellationGroup) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken, moreArgs.argi2 == 1);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_HIDE_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
        case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:
            final SomeArgs args = (SomeArgs) msg.obj;
            inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2);
            args.recycle();
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,,,,
126,<android.view.inputmethod.InputMethodManager: boolean isActive(View)>,29,30,<android.view.inputmethod.InputMethodManager: boolean isActive(View)>,<android.view.inputmethod.InputMethodManager: boolean isActive(View)>,0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        return fallbackImm.isActive(view);
    }
    checkFocus();
    synchronized (mH) {
        return (mServedView == view || (mServedView != null && mServedView.checkInputConnectionProxy(view))) && mCurrentTextBoxAttribute != null;
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        return fallbackImm.isActive(view);
    }
    checkFocus();
    synchronized (mH) {
        return hasServedByInputMethodLocked(view) && mCurrentTextBoxAttribute != null;
    }
}",1,"/**
 * Return true if the given view is the currently active view for the
 * input method.
 */
","/**
 * Return true if the given view is the currently active view for the
 * input method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The return expression within the synchronized block has been changed from a complex conditional expression to a call to a new method hasServedByInputMethodLocked(view), so the change types are 4 (Other statement changed) and 5 (Dependent API changed).","The change in the return expression potentially results in a different return value due to the implementation details of the newly introduced method hasServedByInputMethodLocked(view), causing the CI type to be 1 (Compatibility Issue caused by potential different return values)."
127,<android.net.StaticIpConfiguration.Builder: Builder setDnsServers(Iterable<InetAddress>)>,29,30,<android.net.StaticIpConfiguration.Builder: Builder setDnsServers(Iterable<InetAddress>)>,<android.net.StaticIpConfiguration.Builder: Builder setDnsServers(Iterable<InetAddress>)>,0,"{
    mDnsServers = dnsServers;
    return this;
}","{
    Preconditions.checkNotNull(dnsServers);
    mDnsServers = dnsServers;
    return this;
}",1,"/**
 * Set the addresses of the DNS servers included in the configuration; empty by default.
 * @return The {@link Builder} for chaining.
 */
","/**
 * Set the addresses of the DNS servers included in the configuration; empty by default.
 * @return The {@link Builder} for chaining.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change involves adding a check for the non-nullity of the parameter dnsServers, which is an additional validation step. The statement Preconditions.checkNotNull(dnsServers) has been added to the beginning of the method. This is a validation check, so it's an 'Other statement changed' (code 4) type of change.","Even though a checkNotNull method has been introduced, there is not a compatibility issue since the parameter dnsServers is already annotated with @NonNull in both versions. The added check is in line with this annotation, ensuring that the contract of the method has not been changed as null input was never expected or supported officially by the API. Therefore, no CI will arise because of this change (code 0)."
128,"<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>",29,30,"<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>","<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>",0,"{
    logErrorForInvalidProfileAccess(user);
    if (DEBUG) {
        Log.i(TAG, ""StartMainActivity "" + component + "" "" + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    if (DEBUG) {
        Log.i(TAG, ""StartMainActivity "" + component + "" "" + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), mContext.getAttributionTag(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts a Main activity in the specified profile.
 *
 * @param component The ComponentName of the activity to launch
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
","/**
 * Starts a Main activity in the specified profile.
 *
 * @param component The ComponentName of the activity to launch
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"""startActivityAsUser()"" method call in the implementation has an additional parameter ""mContext.getAttributionTag()"", which indicates that the dependent API has been changed. This modification falls under the change type 4,5 (Other statement changed, Dependent API changed).","Although ""startActivityAsUser()"" method call now includes an additional parameter, the change does not affect the return type or exception handling as the method does not return anything (void) and the catch block for RemoteException remains the same. Therefore, there is No Compatibility Issue, corresponding to type 0."
129,"<android.app.slice.Slice.Builder: Builder addIcon(Icon,String,List<String>)>",29,30,"<android.app.slice.Slice.Builder: Builder addIcon(Icon,String,List<String>)>","<android.app.slice.Slice.Builder: Builder addIcon(Icon,String,List<String>)>",0,"{
    Preconditions.checkNotNull(icon);
    mItems.add(new SliceItem(icon, SliceItem.FORMAT_IMAGE, subType, hints));
    return this;
}","{
    Objects.requireNonNull(icon);
    mItems.add(new SliceItem(icon, SliceItem.FORMAT_IMAGE, subType, hints));
    return this;
}",1,"/**
 * Add an image to the slice being constructed
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
","/**
 * Add an image to the slice being constructed
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is from Preconditions.checkNotNull(icon); to Objects.requireNonNull(icon); which are equivalent methods for null check, hence the code change type is 4 (Other statement changed).","The behavior of the API is not modified by this change, as both methods are used to ensure that the passed object is not null, and they will both throw a NullPointerException if the object is null. Therefore, there is no Compatibility Issue; the CI type is 0."
131,<android.util.Half: boolean isNormalized(short)>,29,30,<android.util.Half: boolean isNormalized(short)>,<android.util.Half: boolean isNormalized(short)>,0,"{
    return (h & FP16_EXPONENT_MAX) != 0 && (h & FP16_EXPONENT_MAX) != FP16_EXPONENT_MAX;
}","{
    return FP16.isNormalized(h);
}",1,"/**
 * Returns true if the specified half-precision float value is normalized
 * (does not have a subnormal representation). If the specified value is
 * {@link #POSITIVE_INFINITY}, {@link #NEGATIVE_INFINITY},
 * {@link #POSITIVE_ZERO}, {@link #NEGATIVE_ZERO}, NaN or any subnormal
 * number, this method returns false.
 *
 * @param h A half-precision float value
 * @return True if the value is normalized, false otherwise
 */
","/**
 * Returns true if the specified half-precision float value is normalized
 * (does not have a subnormal representation). If the specified value is
 * {@link #POSITIVE_INFINITY}, {@link #NEGATIVE_INFINITY},
 * {@link #POSITIVE_ZERO}, {@link #NEGATIVE_ZERO}, NaN or any subnormal
 * number, this method returns false.
 *
 * @param h A half-precision float value
 * @return True if the value is normalized, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has been changed from direct bitwise operations to calling a method from the FP16 class, so the change type is 5.","While the method implementation has changed, as long as the FP16.isNormalized(h) maintains the same logic and returns the same results, there would be no Compatibility Issue in terms of behavior. Assuming that the FP16.isNormalized(h) behaves identically to the inlined bitwise operations, there should be no CI."
133,<android.view.textclassifier.TextClassifierEvent: String toString()>,29,30,<android.view.textclassifier.TextClassifierEvent: String toString()>,<android.view.textclassifier.TextClassifierEvent: String toString()>,0,"{
    StringBuilder out = new StringBuilder(128);
    out.append(this.getClass().getSimpleName());
    out.append(""{"");
    out.append(""mEventCategory="").append(mEventCategory);
    out.append("", mEventTypes="").append(Arrays.toString(mEntityTypes));
    out.append("", mEventContext="").append(mEventContext);
    out.append("", mResultId="").append(mResultId);
    out.append("", mEventIndex="").append(mEventIndex);
    out.append("", mExtras="").append(mExtras);
    out.append("", mScores="").append(Arrays.toString(mScores));
    out.append("", mModelName="").append(mModelName);
    out.append("", mActionIndices="").append(Arrays.toString(mActionIndices));
    out.append(""}"");
    return out.toString();
}","{
    StringBuilder out = new StringBuilder(128);
    out.append(this.getClass().getSimpleName());
    out.append(""{"");
    out.append(""mEventCategory="").append(mEventCategory);
    out.append("", mEventType="").append(mEventType);
    out.append("", mEntityTypes="").append(Arrays.toString(mEntityTypes));
    out.append("", mEventContext="").append(mEventContext);
    out.append("", mResultId="").append(mResultId);
    out.append("", mEventIndex="").append(mEventIndex);
    out.append("", mExtras="").append(mExtras);
    out.append("", mScores="").append(Arrays.toString(mScores));
    out.append("", mModelName="").append(mModelName);
    out.append("", mActionIndices="").append(Arrays.toString(mActionIndices));
    toString(out);
    out.append(""}"");
    return out.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation has changed by modifying the information appended to the StringBuilder, particularly the field 'mEventTypes' changed to 'mEventType', and added a call to `toString(out)`. Therefore, these modifications are classified under 'Other statement changed' and 'Return statement changed', which makes the code change type 1,4.","Because the string representation built by the 'toString()' method is altered by these changes (the representation of event types and the inclusion of additional data through 'toString(out)'), the return value of the method can differ between the early and late versions. Hence, the CI type is 1."
134,"<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",29,30,"<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>","<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",0,"{
    Preconditions.checkNotNull(operations, ""operations"");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, authority, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(operations, ""operations"");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, mAttributionTag, authority, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
","/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
",-1,"[@Override, @NonNull]","[@Override, @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API `mContentProvider.applyBatch` has a new parameter added (`mAttributionTag`), which is a change type 5. Additionally, `Preconditions.checkNotNull` has been replaced with `Objects.requireNonNull`, which is another change but it does not affect behavior since both methods have the same purpose, leading to an ""Other statement changed"" classification (change type 4).","The added parameter `mAttributionTag` doesn't necessarily cause a compatibility issue since it is presumably being passed to the method when it's called, and the method's functionality is expected to remain the same with the additional context. The change from `Preconditions.checkNotNull` to `Objects.requireNonNull` similarly does not affect the compatibility because both methods throw a `NullPointerException` when the operations list is null. Therefore, there is no compatibility issue (CI type 0)."
135,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,29,30,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, mSpannable, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = mSpannable.getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = getInputMethodManager();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""%d: %s (%f,%f)"", event.getSequenceNumber(), MotionEvent.actionToString(event.getActionMasked()), event.getX(), event.getY());
    }
    if (!isFromPrimePointer(event, false)) {
        return true;
    }
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mInsertionPointCursorController != null && mEditor.mInsertionPointCursorController.isCursorBeingModified()) {
            return true;
        }
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""superResult=%s"", superResult);
    }
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (DEBUG_CURSOR) {
            logCursor(""onTouchEvent"", ""release after long press detected"");
        }
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, mSpannable, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = mSpannable.getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = getInputMethodManager();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
136,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> removeAccount(Account,Activity,AccountManagerCallback<Bundle>,Handler)>",29,30,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> removeAccount(Account,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> removeAccount(Account,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account, activity != null);
        }
    }.start();
}","{
    return removeAccountAsUser(account, activity, callback, handler, mContext.getUser());
}",1,"/**
 * Removes an account from the AccountManager. Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The {@link Account} to remove
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to delete an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the {@link Intent} may be
 * returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * {@link #KEY_BOOLEAN_RESULT} if activity was specified and an account
 * was removed or if active. If no activity was specified, the returned
 * Bundle contains only {@link #KEY_INTENT} with the {@link Intent}
 * needed to launch the actual account removal process, if authenticator
 * needs the activity launch. If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process or
 * adding accounts (of this type) has been disabled by policy
 * </ul>
 */
","/**
 * Removes an account from the AccountManager. Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The {@link Account} to remove
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to delete an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the {@link Intent} may be
 * returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * {@link #KEY_BOOLEAN_RESULT} if activity was specified and an account
 * was removed or if active. If no activity was specified, the returned
 * Bundle contains only {@link #KEY_INTENT} with the {@link Intent}
 * needed to launch the actual account removal process, if authenticator
 * needs the activity launch. If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process or
 * adding accounts (of this type) has been disabled by policy
 * </ul>
 */
",-1,,[@UserHandleAware],-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation directly contains the logic for removing an account, while the late implementation delegates the work to another method, removeAccountAsUser, which includes additional parameters. Therefore, the change type is a return statement change due to the delegation to a different method and a dependent API change because it now calls another method, so the changes are 1,5.","The delegation to a different method (removeAccountAsUser) with different parameters could potentially lead to a change in return value due to the different method being called or different behavior in how the account is removed. Hence, there is a potential CI due to a different return value or type, so the CI type is 1."
137,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,29,30,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,0,"{
    return mTargetSdk;
}","{
    return mSplitPermissionInfoParcelable.getTargetSdk();
}",1,"/**
 * Get the target API level when the permission was split.
 */
","/**
 * Get the target API level when the permission was split.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method used to obtain the SDK target version has changed from directly accessing a field (mTargetSdk) to using a method call (mSplitPermissionInfoParcelable.getTargetSdk()), so the code change types are 4 (other statement changed) and 5 (dependent API changed).","Since the implementation has changed to use a dependent API method (mSplitPermissionInfoParcelable.getTargetSdk()), there is a potential for this change to return a different value if the underlying implementation of the new method is different from the direct field access, hence the CI type is 1."
138,"<android.os.PowerManager: void addThermalStatusListener(Executor,OnThermalStatusChangedListener)>",29,30,"<android.os.PowerManager: void addThermalStatusListener(Executor,OnThermalStatusChangedListener)>","<android.os.PowerManager: void addThermalStatusListener(Executor,OnThermalStatusChangedListener)>",0,"{
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    Preconditions.checkNotNull(executor, ""executor cannot be null"");
    synchronized (this) {
        if (mThermalService == null) {
            mThermalService = IThermalService.Stub.asInterface(ServiceManager.getService(Context.THERMAL_SERVICE));
        }
        Preconditions.checkArgument(!mListenerMap.containsKey(listener), ""Listener already registered: "" + listener);
        IThermalStatusListener internalListener = new IThermalStatusListener.Stub() {

            @Override
            public void onStatusChange(int status) {
                final long token = Binder.clearCallingIdentity();
                try {
                    executor.execute(() -> {
                        listener.onThermalStatusChanged(status);
                    });
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            }
        };
        try {
            if (mThermalService.registerThermalStatusListener(internalListener)) {
                mListenerMap.put(listener, internalListener);
            } else {
                throw new RuntimeException(""Listener failed to set"");
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    Preconditions.checkNotNull(executor, ""executor cannot be null"");
    Preconditions.checkArgument(!mListenerMap.containsKey(listener), ""Listener already registered: "" + listener);
    IThermalStatusListener internalListener = new IThermalStatusListener.Stub() {

        @Override
        public void onStatusChange(int status) {
            final long token = Binder.clearCallingIdentity();
            try {
                executor.execute(() -> {
                    listener.onThermalStatusChanged(status);
                });
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        }
    };
    try {
        if (mThermalService.registerThermalStatusListener(internalListener)) {
            mListenerMap.put(listener, internalListener);
        } else {
            throw new RuntimeException(""Listener failed to set"");
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * This function adds a listener for thermal status change.
 *
 * @param executor {@link Executor} to handle listener callback.
 * @param listener listener to be added.
 */
","/**
 * This function adds a listener for thermal status change.
 *
 * @param executor {@link Executor} to handle listener callback.
 * @param listener listener to be added.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The synchronized block around the code that interacts with mThermalService and mListenerMap has been removed. This change affects the control dependency of the code since the access to shared resources is no longer synchronized in the late version.,"There is no Compatibility Issue regarding the return value or thrown exceptions because the change does not affect what the API returns or the exceptions it throws. It only affects the thread-safety of the API, which is an important aspect but does not reflect a behavioral difference in terms of API output or exceptions, under the defined criteria of Compatibility Issues."
139,<android.content.res.AssetManager: AssetFileDescriptor openFd(String)>,29,30,<android.content.res.AssetManager: AssetFileDescriptor openFd(String)>,<android.content.res.AssetManager: AssetFileDescriptor openFd(String)>,0,"{
    Preconditions.checkNotNull(fileName, ""fileName"");
    synchronized (this) {
        ensureOpenLocked();
        final ParcelFileDescriptor pfd = nativeOpenAssetFd(mObject, fileName, mOffsets);
        if (pfd == null) {
            throw new FileNotFoundException(""Asset file: "" + fileName);
        }
        return new AssetFileDescriptor(pfd, mOffsets[0], mOffsets[1]);
    }
}","{
    Objects.requireNonNull(fileName, ""fileName"");
    synchronized (this) {
        ensureOpenLocked();
        final ParcelFileDescriptor pfd = nativeOpenAssetFd(mObject, fileName, mOffsets);
        if (pfd == null) {
            throw new FileNotFoundException(""Asset file: "" + fileName);
        }
        return new AssetFileDescriptor(pfd, mOffsets[0], mOffsets[1]);
    }
}",1,"/**
 * Open an uncompressed asset by mmapping it and returning an {@link AssetFileDescriptor}.
 * This provides access to files that have been bundled with an application as assets -- that
 * is, files placed in to the ""assets"" directory.
 *
 * The asset must be uncompressed, or an exception will be thrown.
 *
 * @param fileName The name of the asset to open.  This name can be hierarchical.
 * @return An open AssetFileDescriptor.
 */
","/**
 * Open an uncompressed asset by mmapping it and returning an {@link AssetFileDescriptor}.
 * This provides access to files that have been bundled with an application as assets -- that
 * is, files placed in to the ""assets"" directory.
 *
 * The asset must be uncompressed, or an exception will be thrown.
 *
 * @param fileName The name of the asset to open.  This name can be hierarchical.
 * @return An open AssetFileDescriptor.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The method Preconditions.checkNotNull(fileName, ""fileName"") has been replaced with Objects.requireNonNull(fileName, ""fileName""). This is a change of implementation with no effect on the behavior as both methods serve the same purpose (null-check), so the code change type is 4.","There is no Compatibility Issue as the replacement of Preconditions.checkNotNull with Objects.requireNonNull does not alter the functionality of the API, nor does it change the type or value of the return, or the exception thrown. Both methods will throw a NullPointerException if 'fileName' is null with the provided detail message; as such there is no change to the API's behavior."
140,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onPrepared(int)>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onPrepared(int)>,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onPrepared(int)>,0,"{
    final OutputConfiguration output;
    final StateCallbackKK sessionCallback;
    if (DEBUG) {
        Log.v(TAG, ""Stream "" + streamId + "" is prepared"");
    }
    synchronized (mInterfaceLock) {
        output = mConfiguredOutputs.get(streamId);
        sessionCallback = mSessionStateCallback;
    }
    if (sessionCallback == null)
        return;
    if (output == null) {
        Log.w(TAG, ""onPrepared invoked for unknown output Surface"");
        return;
    }
    final List<Surface> surfaces = output.getSurfaces();
    for (Surface surface : surfaces) {
        sessionCallback.onSurfacePrepared(surface);
    }
}","{
    final OutputConfiguration output;
    final StateCallbackKK sessionCallback;
    if (DEBUG) {
        Log.v(TAG, ""Stream "" + streamId + "" is prepared"");
    }
    synchronized (mInterfaceLock) {
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onPrepared(streamId);
            return;
        }
        output = mConfiguredOutputs.get(streamId);
        sessionCallback = mSessionStateCallback;
    }
    if (sessionCallback == null)
        return;
    if (output == null) {
        Log.w(TAG, ""onPrepared invoked for unknown output Surface"");
        return;
    }
    final List<Surface> surfaces = output.getSurfaces();
    for (Surface surface : surfaces) {
        sessionCallback.onSurfacePrepared(surface);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"A new if-statement and a return statement was introduced inside the synchronized block to handle the case where mOfflineSessionImpl is not null. This is a change in control dependency, thus the change type is 3.","The added if-statement may lead to the onPrepared method returning earlier than before if mOfflineSessionImpl is not null. This means that in the newer version, the callback on the rest of the method (iterating through surfaces and calling onSurfacePrepared) might not be called when mOfflineSessionImpl is not null, whereas previously this part of the method would always execute. This constitutes a potential difference in behavior, so the CI type is 1."
142,<android.app.NotificationManager.Policy: boolean equals(Object)>,29,30,<android.app.NotificationManager.Policy: boolean equals(Object)>,<android.app.NotificationManager.Policy: boolean equals(Object)>,0,"{
    if (!(o instanceof Policy))
        return false;
    if (o == this)
        return true;
    final Policy other = (Policy) o;
    return other.priorityCategories == priorityCategories && other.priorityCallSenders == priorityCallSenders && other.priorityMessageSenders == priorityMessageSenders && suppressedVisualEffectsEqual(suppressedVisualEffects, other.suppressedVisualEffects);
}","{
    if (!(o instanceof Policy))
        return false;
    if (o == this)
        return true;
    final Policy other = (Policy) o;
    return other.priorityCategories == priorityCategories && other.priorityCallSenders == priorityCallSenders && other.priorityMessageSenders == priorityMessageSenders && suppressedVisualEffectsEqual(suppressedVisualEffects, other.suppressedVisualEffects) && other.state == this.state && other.priorityConversationSenders == this.priorityConversationSenders;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been modified to include additional checks for 'other.state == this.state' and 'other.priorityConversationSenders == this.priorityConversationSenders', so the code change is of type 1 and 4 as logic within the return statement has been altered.","Since the method's return value now also takes into account the comparison of 'state' and 'priorityConversationSenders' fields, which were not considered in the earlier version, it could potentially lead to a different return value. Therefore, it is classified as a Compatibility Issue of type 1."
143,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",29,30,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API used within this API has changed from 'ActivityManager.getService().broadcastIntent' to 'ActivityManager.getService().broadcastIntentWithFeature', and a new parameter 'getAttributionTag()' is added to the latter method call. Hence, the code change type is 5.","Although the dependent API has changed, the behavior of the method 'sendBroadcastAsUser' is not directly affected by this change as it's internal to the implementation; the method's contract and exception handling remain the same. Thus, there is no Compatibility Issue, making the CI type 0."
144,<android.app.admin.DevicePolicyManager: void wipeData(int)>,29,30,<android.app.admin.DevicePolicyManager: void wipeData(int)>,<android.app.admin.DevicePolicyManager: void wipeData(int)>,0,"{
    throwIfParentInstance(""wipeData"");
    final String wipeReasonForUser = mContext.getString(R.string.work_profile_deleted_description_dpm_wipe);
    wipeDataInternal(flags, wipeReasonForUser);
}","{
    wipeDataInternal(flags, """");
}",1,"/**
 * Ask that all user data be wiped. If called as a secondary user, the user will be removed and
 * other users will remain unaffected. Calling from the primary user will cause the device to
 * reboot, erasing all device data - including all the secondary users and their data - while
 * booting up.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 * be able to call this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently supported flags are
 * {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA},
 * {@link #WIPE_EUICC} and {@link #WIPE_SILENTLY}.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
 */
","/**
 * Ask that all user data be wiped. If called as a secondary user, the user will be removed and
 * other users will remain unaffected. Calling from the primary user will cause the device to
 * reboot, erasing all device data - including all the secondary users and their data - while
 * booting up.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 * be able to call this method; if it has not, a security exception will be thrown.
 *
 * If the caller is a profile owner of an organization-owned managed profile, it may
 * additionally call this method on the parent instance.
 * Calling this method on the parent {@link DevicePolicyManager} instance would wipe the
 * entire device, while calling it on the current profile instance would relinquish the device
 * for personal use, removing the managed profile and all policies set by the profile owner.
 *
 * @param flags Bit mask of additional options: currently supported flags are
 * {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA},
 * {@link #WIPE_EUICC} and {@link #WIPE_SILENTLY}.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The call to ""throwIfParentInstance"" was removed, and the 'wipeReasonForUser' parameter passed to 'wipeDataInternal' changed from a retrieved string resource to an empty string. Since both modifications are on the level of implementation details that do not affect the public API behavior (as the method is void and does not return any value or change its exception throwing behavior), the change type is 4.","The actual behavior of wiping the data is handled internally by the 'wipeDataInternal' method, and the change in the parameter does not affect the signature or the execution flow that is visible to the caller. Since the method's interface and behavior regarding wiping the data remain consistent externally, there is no Compatibility Issue."
145,"<android.text.format.TimeFormatter: String format(String,WallTime,ZoneInfo)>",29,30,"<android.text.format.TimeFormatter: String format(String,WallTime,ZoneInfo)>","<android.text.format.TimeFormatter: String format(String,WallTime,ZoneInfo)>",0,"{
    try {
        StringBuilder stringBuilder = new StringBuilder();
        outputBuilder = stringBuilder;
        // This uses the US locale because number localization is handled separately (see below)
        // and locale sensitive strings are output directly using outputBuilder.
        numberFormatter = new Formatter(stringBuilder, Locale.US);
        formatInternal(pattern, wallTime, zoneInfo);
        String result = stringBuilder.toString();
        // in ASCII and not localized.
        if (localeData.zeroDigit != '0') {
            result = localizeDigits(result);
        }
        return result;
    } finally {
        outputBuilder = null;
        numberFormatter = null;
    }
}","{
    try {
        StringBuilder stringBuilder = new StringBuilder();
        outputBuilder = stringBuilder;
        // This uses the US locale because number localization is handled separately (see below)
        // and locale sensitive strings are output directly using outputBuilder.
        numberFormatter = new Formatter(stringBuilder, Locale.US);
        formatInternal(pattern, wallTime, zoneInfo);
        String result = stringBuilder.toString();
        // as being in ASCII and not localized.
        return localizeDigits(result);
    } finally {
        outputBuilder = null;
        numberFormatter = null;
    }
}",1,"/**
 * Format the specified {@code wallTime} using {@code pattern}. The output is returned.
 */
","/**
 * Format the specified {@code wallTime} using {@code pattern}. The output is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early version contains a conditional check to see if the `zeroDigit` is not '0' before localizing digits, whereas the late version always localizes digits without any conditional check. Additionally, the comment above the code snippet is slightly modified which is not a functional change. Thus, the code changes include a modification to an 'if' condition (1) and other statement changes due to comment modification (4).","The removed 'if' condition can lead to `localizeDigits` being called in cases where it would not have been called before, potentially changing the output string, and thus causing a Compatibility Issue type 1."
146,<android.util.Half: short floor(short)>,29,30,<android.util.Half: short floor(short)>,<android.util.Half: short floor(short)>,0,"{
    int bits = h & 0xffff;
    int e = bits & 0x7fff;
    int result = bits;
    if (e < 0x3c00) {
        result &= FP16_SIGN_MASK;
        result |= 0x3c00 & (bits > 0x8000 ? 0xffff : 0x0);
    } else if (e < 0x6400) {
        e = 25 - (e >> 10);
        int mask = (1 << e) - 1;
        result += mask & -(bits >> 15);
        result &= ~mask;
    }
    return (short) result;
}","{
    return FP16.floor(h);
}",1,"/**
 * Returns the largest half-precision float value toward positive infinity
 * less than or equal to the specified half-precision float value.
 * Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The largest half-precision float value toward positive infinity
 * less than or equal to the specified half-precision float value
 */
","/**
 * Returns the largest half-precision float value toward positive infinity
 * less than or equal to the specified half-precision float value.
 * Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The largest half-precision float value toward positive infinity
 * less than or equal to the specified half-precision float value
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed to use another API method, FP16.floor(h), instead of the previous complex logic. This implies a dependent API change, hence the code change type is 5.","While there's a distinct change in implementation, there's no direct evidence here that FP16.floor(h) would behave differently compared to the previous implementation; hence without knowing the specifics of the new FP16.floor(h) method behavior, we cannot definitively state there's a Compatibility Issue. Assuming that FP16.floor(h) correctly encapsulates the earlier logic and simply organizes it within a helper method, this change does not inherently lead to a Compatibility Issue. Therefore, the CI type is 0."
147,<android.accessibilityservice.AccessibilityButtonController: void unregisterAccessibilityButtonCallback(AccessibilityButtonCallback)>,29,30,<android.accessibilityservice.AccessibilityButtonController: void unregisterAccessibilityButtonCallback(AccessibilityButtonCallback)>,<android.accessibilityservice.AccessibilityButtonController: void unregisterAccessibilityButtonCallback(AccessibilityButtonCallback)>,0,"{
    Preconditions.checkNotNull(callback);
    synchronized (mLock) {
        if (mCallbacks == null) {
            return;
        }
        final int keyIndex = mCallbacks.indexOfKey(callback);
        final boolean hasKey = keyIndex >= 0;
        if (hasKey) {
            mCallbacks.removeAt(keyIndex);
        }
    }
}","{
    Objects.requireNonNull(callback);
    synchronized (mLock) {
        if (mCallbacks == null) {
            return;
        }
        final int keyIndex = mCallbacks.indexOfKey(callback);
        final boolean hasKey = keyIndex >= 0;
        if (hasKey) {
            mCallbacks.removeAt(keyIndex);
        }
    }
}",1,"/**
 * Unregisters the provided {@link AccessibilityButtonCallback} for interaction and state
 * change callbacks related to the accessibility button.
 *
 * @param callback the callback to remove, must be non-null
 */
","/**
 * Unregisters the provided {@link AccessibilityButtonCallback} for interaction and state
 * change callbacks related to the accessibility button.
 *
 * @param callback the callback to remove, must be non-null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the code is from `Preconditions.checkNotNull(callback);` to `Objects.requireNonNull(callback);`. This is an example of using different utility methods for the same purpose, which constitute a change in a dependent API (4,5).","Despite this change, the functionality and contract of the method remain the same. The method's behavior does not change outwardly as both versions throw a NullPointerException when the `callback` is null. Consequently, there is no Compatibility Issue (0) since the change does not affect the method's return value or the exceptions it might throw."
148,<android.content.ContentProviderClient: Uri canonicalize(Uri)>,29,30,<android.content.ContentProviderClient: Uri canonicalize(Uri)>,<android.content.ContentProviderClient: Uri canonicalize(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, mAttributionTag, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#canonicalize}
 */
","/**
 * See {@link ContentProvider#canonicalize}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",0,"The only change is the call to mContentProvider.canonicalize, where the late version includes an extra parameter mAttributionTag. Also, Preconditions.checkNotNull has been replaced with Objects.requireNonNull which is an equivalent operation, thus not affecting the return value or exceptions thrown. Therefore, the code change types are 4 (Other statement changed) and 5 (Dependent API changed).","Despite the change in the way how the check on the URL is made (both achieve the same goal), and the addition of an extra parameter to the `canonicalize` method, there's no change that would lead to a different return value or thrown exceptions under the same input conditions. The behaviour of the API in these aspects remains consistent, so there's no Compatibility Issue, which corresponds to 0."
149,<android.content.IntentFilter: boolean hasDataSchemeSpecificPart(String)>,29,30,<android.content.IntentFilter: boolean hasDataSchemeSpecificPart(String)>,<android.content.IntentFilter: boolean hasDataSchemeSpecificPart(String)>,0,"{
    if (mDataSchemeSpecificParts == null) {
        return false;
    }
    final int numDataSchemeSpecificParts = mDataSchemeSpecificParts.size();
    for (int i = 0; i < numDataSchemeSpecificParts; i++) {
        final PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        if (pe.match(data)) {
            return true;
        }
    }
    return false;
}","{
    return hasDataSchemeSpecificPart(data, false);
}",1,"/**
 * Is the given data scheme specific part included in the filter?  Note that if the
 * filter does not include any scheme specific parts, false will <em>always</em> be
 * returned.
 *
 * @param data The scheme specific part that is being looked for.
 *
 * @return Returns true if the data string matches a scheme specific part listed in the
 * filter.
 */
","/**
 * Is the given data scheme specific part included in the filter?  Note that if the
 * filter does not include any scheme specific parts, false will <em>always</em> be
 * returned.
 *
 * @param data The scheme specific part that is being looked for.
 *
 * @return Returns true if the data string matches a scheme specific part listed in the
 * filter.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,No Compatibility Issue,"The early version implementation is replaced with a direct call to hasDataSchemeSpecificPart(data, false), which seems to be an overload of the current method, or an internal method with more parameters; this is an example of changing the internal method dependency, so the code change type is 5.","While the implementation detail is hidden behind the call to hasDataSchemeSpecificPart(data, false), assuming that this overloaded method or helper method retains the same business logic but just utilizes an additional parameter for internal decision-making which doesn't affect the main contract of this API, it wouldn't cause a compatibility issue for the caller, as the method signature and expected behavior remain the same."
150,<android.view.MotionEvent: void transform(Matrix)>,29,30,<android.view.MotionEvent: void transform(Matrix)>,<android.view.MotionEvent: void transform(Matrix)>,0,"{
    if (matrix == null) {
        throw new IllegalArgumentException(""matrix must not be null"");
    }
    nativeTransform(mNativePtr, matrix.native_instance);
}","{
    if (matrix == null) {
        throw new IllegalArgumentException(""matrix must not be null"");
    }
    nativeTransform(mNativePtr, matrix);
}",1,"/**
 * Applies a transformation matrix to all of the points in the event.
 *
 * @param matrix The transformation matrix to apply.
 */
","/**
 * Applies a transformation matrix to all of the points in the event.
 *
 * @param matrix The transformation matrix to apply.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The argument passed to the nativeTransform method changed from matrix.native_instance to matrix, which indicates that there might have been a change in the nativeTransform method's parameter handling. So, it falls under Dependent API changed (5).","There is no Compatibility Issue detected because the change doesn't affect the control flow of the method, nor does it alter the return value or throw a new exception. The change is strictly in the parameters passed to a native method, which presumably handles the new parameter type correctly without altering the method's behavior as seen from the API user's perspective."
154,"<android.hardware.camera2.params.LensShadingMap: void copyGainFactors(float[],int)>",29,30,"<android.hardware.camera2.params.LensShadingMap: void copyGainFactors(float[],int)>","<android.hardware.camera2.params.LensShadingMap: void copyGainFactors(float[],int)>",0,"{
    checkArgumentNonnegative(offset, ""offset must not be negative"");
    checkNotNull(destination, ""destination must not be null"");
    if (destination.length + offset < getGainFactorCount()) {
        throw new ArrayIndexOutOfBoundsException(""destination too small to fit elements"");
    }
    System.arraycopy(mElements, /*srcPos*/
    0, destination, offset, getGainFactorCount());
}","{
    checkArgumentNonnegative(offset, ""offset must not be negative"");
    Objects.requireNonNull(destination, ""destination must not be null"");
    if (destination.length + offset < getGainFactorCount()) {
        throw new ArrayIndexOutOfBoundsException(""destination too small to fit elements"");
    }
    System.arraycopy(mElements, /*srcPos*/
    0, destination, offset, getGainFactorCount());
}",1,"/**
 * Copy all gain factors in row-major order from this lens shading map into the destination.
 *
 * <p>Each gain factor will be >= {@link #MINIMUM_GAIN_FACTOR}.</p>
 *
 * @param destination
 * an array big enough to hold at least {@link RggbChannelVector#COUNT}
 * elements after the {@code offset}
 * @param offset
 * a non-negative offset into the array
 * @throws NullPointerException
 * If {@code destination} was {@code null}
 * @throws IllegalArgumentException
 * If offset was negative
 * @throws ArrayIndexOutOfBoundsException
 * If there's not enough room to write the elements at the specified destination and
 * offset.
 *
 * @see CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP
 */
","/**
 * Copy all gain factors in row-major order from this lens shading map into the destination.
 *
 * <p>Each gain factor will be >= {@link #MINIMUM_GAIN_FACTOR}.</p>
 *
 * @param destination
 * an array big enough to hold at least {@link RggbChannelVector#COUNT}
 * elements after the {@code offset}
 * @param offset
 * a non-negative offset into the array
 * @throws NullPointerException
 * If {@code destination} was {@code null}
 * @throws IllegalArgumentException
 * If offset was negative
 * @throws ArrayIndexOutOfBoundsException
 * If there's not enough room to write the elements at the specified destination and
 * offset.
 *
 * @see CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change between the versions is the usage of a different method to check for a non-null destination array: it changed from `checkNotNull(destination, ""destination must not be null"")` to `Objects.requireNonNull(destination, ""destination must not be null"")`. Since these two methods have the same purpose and would throw an exception if the condition is not met, the change type is 5 (Dependent API changed).","There is no Compatibility Issue caused by this change as it does not affect the behavior of the method from a caller's point of view. Both methods will throw a NullPointerException with the given message if the 'destination' object is null. The method signature and behavior remain the same, so the CI type is 0 (No Compatibility Issue)."
155,<android.view.textclassifier.SelectionEvent: boolean equals(Object)>,29,30,<android.view.textclassifier.SelectionEvent: boolean equals(Object)>,<android.view.textclassifier.SelectionEvent: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof SelectionEvent)) {
        return false;
    }
    final SelectionEvent other = (SelectionEvent) obj;
    return mAbsoluteStart == other.mAbsoluteStart && mAbsoluteEnd == other.mAbsoluteEnd && mEventType == other.mEventType && Objects.equals(mEntityType, other.mEntityType) && Objects.equals(mWidgetVersion, other.mWidgetVersion) && Objects.equals(mPackageName, other.mPackageName) && Objects.equals(mWidgetType, other.mWidgetType) && mInvocationMethod == other.mInvocationMethod && Objects.equals(mResultId, other.mResultId) && mEventTime == other.mEventTime && mDurationSinceSessionStart == other.mDurationSinceSessionStart && mDurationSincePreviousEvent == other.mDurationSincePreviousEvent && mEventIndex == other.mEventIndex && Objects.equals(mSessionId, other.mSessionId) && mStart == other.mStart && mEnd == other.mEnd && mSmartStart == other.mSmartStart && mSmartEnd == other.mSmartEnd;
}","{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof SelectionEvent)) {
        return false;
    }
    final SelectionEvent other = (SelectionEvent) obj;
    return mAbsoluteStart == other.mAbsoluteStart && mAbsoluteEnd == other.mAbsoluteEnd && mEventType == other.mEventType && Objects.equals(mEntityType, other.mEntityType) && Objects.equals(mWidgetVersion, other.mWidgetVersion) && Objects.equals(mPackageName, other.mPackageName) && Objects.equals(mWidgetType, other.mWidgetType) && mInvocationMethod == other.mInvocationMethod && Objects.equals(mResultId, other.mResultId) && mEventTime == other.mEventTime && mDurationSinceSessionStart == other.mDurationSinceSessionStart && mDurationSincePreviousEvent == other.mDurationSincePreviousEvent && mEventIndex == other.mEventIndex && Objects.equals(mSessionId, other.mSessionId) && mStart == other.mStart && mEnd == other.mEnd && mSmartStart == other.mSmartStart && mSmartEnd == other.mSmartEnd && mSystemTcMetadata == other.mSystemTcMetadata;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An equality check for a new field mSystemTcMetadata has been added in the late version implementation, which is a change to another statement that is not a return, exception handling, or control statement. Thus, the change type is 4.","Adding an additional field check in the equals method does not lead to a compatibility issue because it alters the behavior according to the expected use of an equals method to include a new comparison but does not introduce different types of return values or exception handling. The contract of the equals method is still maintained (i.e., it should return false for objects that are not equal, and true for objects that are). Hence, there would be no compatibility issue, and the CI type is 0."
156,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,29,30,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,0,"{
    try {
        Preconditions.checkNotNull(clip);
        clip.prepareToLeaveProcess(true);
        mService.setPrimaryClip(clip, mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        Objects.requireNonNull(clip);
        clip.prepareToLeaveProcess(true);
        mService.setPrimaryClip(clip, mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 * @see #getPrimaryClip()
 * @see #clearPrimaryClip()
 */
","/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 * @see #getPrimaryClip()
 * @see #clearPrimaryClip()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the use of a different method for checking null. It changed from Preconditions.checkNotNull(clip) to Objects.requireNonNull(clip), so the change type is 4.","Although a different method is used to check for null, both methods will functionally do the same check and throw a NullPointerException if the 'clip' is null. There is no change in return type/value or exception handling, thus no Compatibility Issue exists and the CI type is 0."
160,<android.content.ContentProviderClient: Uri uncanonicalize(Uri)>,29,30,<android.content.ContentProviderClient: Uri uncanonicalize(Uri)>,<android.content.ContentProviderClient: Uri uncanonicalize(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, mAttributionTag, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#uncanonicalize}
 */
","/**
 * See {@link ContentProvider#uncanonicalize}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",0,"The code now uses Objects.requireNonNull instead of Preconditions.checkNotNull for the null check, and an additional parameter mAttributionTag is passed to the mContentProvider.uncanonicalize method. This constitutes a change of the other statement type (4) and also indicates there has been a change in the dependent API (5).",The change of null check implementation from Preconditions.checkNotNull to Objects.requireNonNull does not constitute a compatibility issue as both methods serve the same purpose and functionality—they throw a NullPointerException if the provided reference is null.
161,<android.view.ViewRootImpl.InputStage: void deliver(QueuedInputEvent)>,29,30,<android.view.ViewRootImpl.InputStage: void deliver(QueuedInputEvent)>,<android.view.ViewRootImpl.InputStage: void deliver(QueuedInputEvent)>,0,"{
    if ((q.mFlags & QueuedInputEvent.FLAG_FINISHED) != 0) {
        forward(q);
    } else if (shouldDropInputEvent(q)) {
        finish(q, false);
    } else {
        apply(q, onProcess(q));
    }
}","{
    if ((q.mFlags & QueuedInputEvent.FLAG_FINISHED) != 0) {
        forward(q);
    } else if (shouldDropInputEvent(q)) {
        finish(q, false);
    } else {
        traceEvent(q, Trace.TRACE_TAG_VIEW);
        final int result;
        try {
            result = onProcess(q);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
        apply(q, result);
    }
}",1,"/**
 * Delivers an event to be processed.
 */
","/**
 * Delivers an event to be processed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces new statements for tracing (traceEvent and Trace.traceEnd) and adds a try-finally block around the onProcess(q) call. These are changes that fall under ""Control dependency changed"" (because of the try-finally block) and ""Other statement changed"" (because of the new trace statements and the additional variable declaration). This leads to code change classification types 3 and 4.","Although a try-finally block and tracing calls were added, the execution logic and possible outcomes of the deliver() method have not been altered in a way that would change its behavior from a caller's perspective. The method's ability to return a value or throw an exception has not been changed. Therefore, there is no Compatibility Issue, and the CI type is 0."
164,<android.speech.tts.TextToSpeech: int setVoice(Voice)>,29,30,<android.speech.tts.TextToSpeech: int setVoice(Voice)>,<android.speech.tts.TextToSpeech: int setVoice(Voice)>,0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            int result = service.loadVoice(getCallerIdentity(), voice.getName());
            if (result == SUCCESS) {
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, voice.getName());
                // Set the language/country/variant, so #getLanguage will return the voice
                // locale when called.
                String language = """";
                try {
                    language = voice.getLocale().getISO3Language();
                } catch (MissingResourceException e) {
                    Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + voice.getLocale(), e);
                }
                String country = """";
                try {
                    country = voice.getLocale().getISO3Country();
                } catch (MissingResourceException e) {
                    Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + voice.getLocale(), e);
                }
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
                mParams.putString(Engine.KEY_PARAM_VARIANT, voice.getLocale().getVariant());
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, ""setVoice"");
}","{
    return runAction((ITextToSpeechService service) -> {
        int result = service.loadVoice(getCallerIdentity(), voice.getName());
        if (result == SUCCESS) {
            mParams.putString(Engine.KEY_PARAM_VOICE_NAME, voice.getName());
            // Set the language/country/variant, so #getLanguage will return the voice
            // locale when called.
            String language = """";
            try {
                language = voice.getLocale().getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + voice.getLocale(), e);
            }
            String country = """";
            try {
                country = voice.getLocale().getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + voice.getLocale(), e);
            }
            mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
            mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
            mParams.putString(Engine.KEY_PARAM_VARIANT, voice.getLocale().getVariant());
        }
        return result;
    }, LANG_NOT_SUPPORTED, ""setVoice"");
}",1,"/**
 * Sets the text-to-speech voice.
 *
 * @param voice One of objects returned by {@link #getVoices()}.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 *
 * @see #getVoices
 * @see Voice
 */
","/**
 * Sets the text-to-speech voice.
 *
 * @param voice One of objects returned by {@link #getVoices()}.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 *
 * @see #getVoices
 * @see Voice
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation was changed from using an anonymous Action class to using a lambda expression, which doesn't alter the functionality (execution behavior) of the method itself, so the code change type is 4 (Other statement changed).","There is no Compatibility Issue as the method's behavior, return values, and exception handling remain the same across both versions. The change is purely syntactical and does not affect the API contract."
165,"<android.widget.NumberPicker.AccessibilityNodeProviderImpl: boolean performAction(int,int,Bundle)>",29,30,"<android.widget.NumberPicker.AccessibilityNodeProviderImpl: boolean performAction(int,int,Bundle)>","<android.widget.NumberPicker.AccessibilityNodeProviderImpl: boolean performAction(int,int,Bundle)>",0,"{
    switch(virtualViewId) {
        case View.NO_ID:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                requestAccessibilityFocus();
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                clearAccessibilityFocus();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
                        {
                            if (NumberPicker.this.isEnabled() && (getWrapSelectorWheel() || getValue() < getMaxValue())) {
                                changeValueByOne(true);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
                        {
                            if (NumberPicker.this.isEnabled() && (getWrapSelectorWheel() || getValue() > getMinValue())) {
                                changeValueByOne(false);
                                return true;
                            }
                        }
                        return false;
                }
            }
            break;
        case VIRTUAL_VIEW_ID_INPUT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_FOCUS:
                        {
                            if (NumberPicker.this.isEnabled() && !mInputText.isFocused()) {
                                return mInputText.requestFocus();
                            }
                        }
                        break;
                    case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
                        {
                            if (NumberPicker.this.isEnabled() && mInputText.isFocused()) {
                                mInputText.clearFocus();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                performClick();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_LONG_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                performLongClick();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                mInputText.invalidate();
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                mInputText.invalidate();
                                return true;
                            }
                        }
                        return false;
                    default:
                        {
                            return mInputText.performAccessibilityAction(action, arguments);
                        }
                }
            }
            return false;
        case VIRTUAL_VIEW_ID_INCREMENT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                NumberPicker.this.changeValueByOne(true);
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_CLICKED);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
                                return true;
                            }
                        }
                        return false;
                }
            }
            return false;
        case VIRTUAL_VIEW_ID_DECREMENT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                final boolean increment = (virtualViewId == VIRTUAL_VIEW_ID_INCREMENT);
                                NumberPicker.this.changeValueByOne(increment);
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_CLICKED);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
                                return true;
                            }
                        }
                        return false;
                }
            }
            return false;
    }
    return super.performAction(virtualViewId, action, arguments);
}","{
    switch(virtualViewId) {
        case View.NO_ID:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                requestAccessibilityFocus();
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                clearAccessibilityFocus();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
                    case R.id.accessibilityActionScrollDown:
                        {
                            if (NumberPicker.this.isEnabled() && (getWrapSelectorWheel() || getValue() < getMaxValue())) {
                                changeValueByOne(true);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
                    case R.id.accessibilityActionScrollUp:
                        {
                            if (NumberPicker.this.isEnabled() && (getWrapSelectorWheel() || getValue() > getMinValue())) {
                                changeValueByOne(false);
                                return true;
                            }
                        }
                        return false;
                }
            }
            break;
        case VIRTUAL_VIEW_ID_INPUT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_FOCUS:
                        {
                            if (NumberPicker.this.isEnabled() && !mInputText.isFocused()) {
                                return mInputText.requestFocus();
                            }
                        }
                        break;
                    case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
                        {
                            if (NumberPicker.this.isEnabled() && mInputText.isFocused()) {
                                mInputText.clearFocus();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                performClick();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_LONG_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                performLongClick();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                mInputText.invalidate();
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                mInputText.invalidate();
                                return true;
                            }
                        }
                        return false;
                    default:
                        {
                            return mInputText.performAccessibilityAction(action, arguments);
                        }
                }
            }
            return false;
        case VIRTUAL_VIEW_ID_INCREMENT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                NumberPicker.this.changeValueByOne(true);
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_CLICKED);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
                                return true;
                            }
                        }
                        return false;
                }
            }
            return false;
        case VIRTUAL_VIEW_ID_DECREMENT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                final boolean increment = (virtualViewId == VIRTUAL_VIEW_ID_INCREMENT);
                                NumberPicker.this.changeValueByOne(increment);
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_CLICKED);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
                                return true;
                            }
                        }
                        return false;
                }
            }
            return false;
    }
    return super.performAction(virtualViewId, action, arguments);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
166,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,29,30,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,0,"{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getEnabledAccessibilityServiceList(feedbackTypeFlags, userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    if (mAccessibilityPolicy != null) {
        services = mAccessibilityPolicy.getEnabledAccessibilityServiceList(feedbackTypeFlags, services);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getEnabledAccessibilityServiceList(feedbackTypeFlags, userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Enabled AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the enabled AccessibilityServices. "", re);
    }
    if (mAccessibilityPolicy != null) {
        services = mAccessibilityPolicy.getEnabledAccessibilityServiceList(feedbackTypeFlags, services);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}",1,"/**
 * Returns the {@link AccessibilityServiceInfo}s of the enabled accessibility services
 * for a given feedback type.
 *
 * @param feedbackTypeFlags The feedback type flags.
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 *
 * @see AccessibilityServiceInfo#FEEDBACK_AUDIBLE
 * @see AccessibilityServiceInfo#FEEDBACK_GENERIC
 * @see AccessibilityServiceInfo#FEEDBACK_HAPTIC
 * @see AccessibilityServiceInfo#FEEDBACK_SPOKEN
 * @see AccessibilityServiceInfo#FEEDBACK_VISUAL
 * @see AccessibilityServiceInfo#FEEDBACK_BRAILLE
 */
","/**
 * Returns the {@link AccessibilityServiceInfo}s of the enabled accessibility services
 * for a given feedback type.
 *
 * @param feedbackTypeFlags The feedback type flags.
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 *
 * @see AccessibilityServiceInfo#FEEDBACK_AUDIBLE
 * @see AccessibilityServiceInfo#FEEDBACK_GENERIC
 * @see AccessibilityServiceInfo#FEEDBACK_HAPTIC
 * @see AccessibilityServiceInfo#FEEDBACK_SPOKEN
 * @see AccessibilityServiceInfo#FEEDBACK_VISUAL
 * @see AccessibilityServiceInfo#FEEDBACK_BRAILLE
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change consists of only the debug log text; specifically, ""Installed AccessibilityServices"" was updated to ""Enabled AccessibilityServices"". Therefore, the change type is 4.","As the only change is in the log statement, which does not affect the API's return values or its behaviour in terms of exceptions thrown, there is no Compatibility Issue. Hence, CI type is 0."
167,<android.net.RouteInfo: int hashCode()>,29,30,<android.net.RouteInfo: int hashCode()>,<android.net.RouteInfo: int hashCode()>,0,"{
    return (mDestination.hashCode() * 41) + (mGateway == null ? 0 : mGateway.hashCode() * 47) + (mInterface == null ? 0 : mInterface.hashCode() * 67) + (mType * 71);
}","{
    return (mDestination.hashCode() * 41) + (mGateway == null ? 0 : mGateway.hashCode() * 47) + (mInterface == null ? 0 : mInterface.hashCode() * 67) + (mType * 71) + (mMtu * 89);
}",1,"/**
 * Returns a hashcode for this <code>RouteInfo</code> object.
 */
","/**
 * Returns a hashcode for this <code>RouteInfo</code> object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The hashCode computation now includes an additional term with `(mMtu * 89)`. This is an `Other statement changed` since it only modifies the hash calculation and doesn't affect any control structures, thus the change type is 4.","There is no Compatibility Issue since the `hashCode` method is still returning an int and there is no change in the behavior of how the function executes other than the additional term. This change doesn't impact the ability for previously hashed objects to be compared for equality, as the contract for the `hashCode` method does not guarantee identical hash codes between different versions of a program. Therefore, there is no compatibility issue, with the type being 0."
168,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,29,30,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,0,"{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightnessOverride == other.screenBrightnessOverride && useAutoBrightness == other.useAutoBrightness && floatEquals(screenAutoBrightnessAdjustmentOverride, other.screenAutoBrightnessAdjustmentOverride) && screenLowPowerBrightnessFactor == other.screenLowPowerBrightnessFactor && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}","{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && floatEquals(screenBrightnessOverride, other.screenBrightnessOverride) && useAutoBrightness == other.useAutoBrightness && floatEquals(screenAutoBrightnessAdjustmentOverride, other.screenAutoBrightnessAdjustmentOverride) && screenLowPowerBrightnessFactor == other.screenLowPowerBrightnessFactor && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && floatEquals(dozeScreenBrightness, other.dozeScreenBrightness) && dozeScreenState == other.dozeScreenState;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The return statement has been altered with the introduction of floatEquals() method being used for screenBrightnessOverride and dozeScreenBrightness comparisons, instead of a direct comparison as in the early version. Furthermore, there are additional 'floatEquals' checks for the screenBrightnessOverride and dozeScreenBrightness parameters, and the overall expression within the return statement has been modified, as evidenced by these changes and the altered composition of boolean expressions. Thus, the change types are 1,3, and 4.","Despite the changes in the return statement and the order in which boolean expressions are evaluated, the essential logic for equality comparison remains unchanged. The use of floatEquals is usually intended to account for floating-point precision issues. Assuming that floatEquals() method correctly compares floating point values (presumably this method checks for equality within a certain epsilon tolerance), no Compatibility Issue arises in terms of the return value or exceptions thrown from the method. Hence the CI type is 0. The behavior of the equals() method depends on the value returned from floatEquals(), but not on the structure of the return statement itself. If floatEquals() maintains the same logical equivalence as a direct comparison when there is no floating-point precision concern, the modification won't produce compatibility issues."
169,"<android.app.admin.DevicePolicyManager: void setDefaultSmsApplication(ComponentName,String)>",29,30,"<android.app.admin.DevicePolicyManager: void setDefaultSmsApplication(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void setDefaultSmsApplication(ComponentName,String)>",0,"{
    throwIfParentInstance(""setDefaultSmsApplication"");
    if (mService != null) {
        try {
            mService.setDefaultSmsApplication(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setDefaultSmsApplication(admin, packageName, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a device owner to set the default SMS application.
 * <p>
 * The calling device admin must be a device owner. If it is not, a security exception will be
 * thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to set as the default SMS application.
 * @throws SecurityException if {@code admin} is not a device owner.
 */
","/**
 * Must be called by a device owner or a profile owner of an organization-owned managed profile
 * to set the default SMS application.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance, returned by
 * {@link #getParentProfileInstance(ComponentName)}, where the caller must be the profile owner
 * of an organization-owned managed profile and the package must be a pre-installed system
 * package. If called on the parent instance, then the default SMS application is set on the
 * personal profile.
 *
 * @param admin       Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to set as the default SMS application.
 * @throws SecurityException        if {@code admin} is not a device or profile owner or if
 * called on the parent profile and the {@code admin} is not a
 * profile owner of an organization-owned managed profile.
 * @throws IllegalArgumentException if called on the parent profile and the package
 * provided is not a pre-installed system package.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",0,"There is the removal of the throwIfParentInstance(""setDefaultSmsApplication"") invocation and an additional parameter mParentInstance in the mService.setDefaultSmsApplication method call. The code change type is 1 for the removed a statement, 4 for the additional parameter, and 5 for changing the parameter list of the dependent API.","Despite these changes, there is no potential for a different returned value or exception since the method is void and does not have a return type, and the new parameter to the dependent API does not alter the exception thrown. Therefore, the Compatibility Issue type is 0."
171,"<android.content.ContentResolver: Cursor query(Uri,String[],Bundle,CancellationSignal)>",29,30,"<android.content.ContentResolver: Cursor query(Uri,String[],Bundle,CancellationSignal)>","<android.content.ContentResolver: Cursor query(Uri,String[],Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        if (mWrapped != null) {
            return mWrapped.query(uri, projection, queryArgs, cancellationSignal);
        }
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, queryArgs, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, queryArgs, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, queryArgs);
        // Wrap the cursor object into CursorWrapperInner object.
        final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri);
        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    try {
        if (mWrapped != null) {
            return mWrapped.query(uri, projection, queryArgs, cancellationSignal);
        }
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, mAttributionTag, uri, projection, queryArgs, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, mAttributionTag, uri, projection, queryArgs, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, queryArgs);
        // Wrap the cursor object into CursorWrapperInner object.
        final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri);
        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}",1,"/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with support for cancellation.
 *
 * <p>For best performance, the caller should follow these guidelines:
 *
 * <li>Provide an explicit projection, to prevent reading data from storage
 * that aren't going to be used.
 *
 * Provider must identify which QUERY_ARG_SORT* arguments were honored during
 * the preparation of the result set by including the respective argument keys
 * in the {@link Cursor} extras {@link Bundle}. See {@link #EXTRA_HONORED_ARGS}
 * for details.
 *
 * @see #QUERY_ARG_SORT_COLUMNS
 * @see #QUERY_ARG_SORT_DIRECTION
 * @see #QUERY_ARG_SORT_COLLATION
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param queryArgs A Bundle containing any arguments to the query.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry. May return
 * <code>null</code> if the underlying content provider returns <code>null</code>,
 * or if it crashes.
 * @see Cursor
 */
","/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with support for cancellation.
 *
 * <p>For best performance, the caller should follow these guidelines:
 *
 * <li>Provide an explicit projection, to prevent reading data from storage
 * that aren't going to be used.
 *
 * Provider must identify which QUERY_ARG_SORT* arguments were honored during
 * the preparation of the result set by including the respective argument keys
 * in the {@link Cursor} extras {@link Bundle}. See {@link #EXTRA_HONORED_ARGS}
 * for details.
 *
 * @see #QUERY_ARG_SORT_COLUMNS
 * @see #QUERY_ARG_SORT_DIRECTION
 * @see #QUERY_ARG_SORT_COLLATION
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param queryArgs A Bundle containing additional information necessary for
 * the operation. Arguments may include SQL style arguments, such
 * as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that
 * the documentation for each individual provider will indicate
 * which arguments they support.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry. May return
 * <code>null</code> if the underlying content provider returns <code>null</code>,
 * or if it crashes.
 * @see Cursor
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,,,,
174,<android.view.SurfaceControl.Transaction: Transaction merge(Transaction)>,29,30,<android.view.SurfaceControl.Transaction: Transaction merge(Transaction)>,<android.view.SurfaceControl.Transaction: Transaction merge(Transaction)>,0,"{
    if (this == other) {
        return this;
    }
    mResizedSurfaces.putAll(other.mResizedSurfaces);
    other.mResizedSurfaces.clear();
    nativeMergeTransaction(mNativeObject, other.mNativeObject);
    return this;
}","{
    if (this == other) {
        return this;
    }
    mResizedSurfaces.putAll(other.mResizedSurfaces);
    other.mResizedSurfaces.clear();
    mReparentedSurfaces.putAll(other.mReparentedSurfaces);
    other.mReparentedSurfaces.clear();
    nativeMergeTransaction(mNativeObject, other.mNativeObject);
    return this;
}",1,"/**
 * Merge the other transaction into this transaction, clearing the
 * other transaction as if it had been applied.
 *
 * @param other The transaction to merge in to this one.
 * @return This transaction.
 */
","/**
 * Merge the other transaction into this transaction, clearing the
 * other transaction as if it had been applied.
 *
 * @param other The transaction to merge in to this one.
 * @return This transaction.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"Two lines of code have been added to handle additional `mReparentedSurfaces` which does not affect the return type or value nor exception handling of the merge method, thus the change type is 4.","The added statements deal only with internal properties of the `Transaction` object and do not affect the method's external behavior in terms of return value or exceptions thrown, so there is no compatibility issue."
175,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor.ImeInputEventReceiver: void onInputEvent(InputEvent)>,29,30,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor.ImeInputEventReceiver: void onInputEvent(InputEvent)>,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor.ImeInputEventReceiver: void onInputEvent(InputEvent)>,0,"{
    if (mFinished.get()) {
        // The session has been finished.
        finishInputEvent(event, false);
        return;
    }
    boolean handled = false;
    try {
        if (event instanceof KeyEvent) {
            final KeyEvent keyEvent = (KeyEvent) event;
            handled = keyEvent.dispatch(mKeyEventCallbackAdaptor, mDispatcherState, mKeyEventCallbackAdaptor);
        } else {
            final MotionEvent motionEvent = (MotionEvent) event;
            if (motionEvent.isFromSource(InputDevice.SOURCE_CLASS_TRACKBALL)) {
                handled = mClientCallback.onTrackballEvent(motionEvent);
            } else {
                handled = mClientCallback.onGenericMotionEvent(motionEvent);
            }
        }
    } finally {
        finishInputEvent(event, handled);
    }
}","{
    if (mCancellationGroupOnFinishSession.isCanceled()) {
        // The session has been finished.
        finishInputEvent(event, false);
        return;
    }
    boolean handled = false;
    try {
        if (event instanceof KeyEvent) {
            final KeyEvent keyEvent = (KeyEvent) event;
            handled = keyEvent.dispatch(mKeyEventCallbackAdaptor, mDispatcherState, mKeyEventCallbackAdaptor);
        } else {
            final MotionEvent motionEvent = (MotionEvent) event;
            if (motionEvent.isFromSource(InputDevice.SOURCE_CLASS_TRACKBALL)) {
                handled = mClientCallback.onTrackballEvent(motionEvent);
            } else {
                handled = mClientCallback.onGenericMotionEvent(motionEvent);
            }
        }
    } finally {
        finishInputEvent(event, handled);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The condition in the if statement has changed from checking mFinished.get() to mCancellationGroupOnFinishSession.isCanceled(), but the overall flow and the logic of the method have not been altered.",There is no CI in this change. The change only involves a different condition which likely aims to track whether the session has been finished or not. The rest of the method logic remains the same and would not lead to different behavior in terms of return values or exceptions.
176,"<android.app.admin.DevicePolicyManager: boolean isApplicationHidden(ComponentName,String)>",29,30,"<android.app.admin.DevicePolicyManager: boolean isApplicationHidden(ComponentName,String)>","<android.app.admin.DevicePolicyManager: boolean isApplicationHidden(ComponentName,String)>",0,"{
    throwIfParentInstance(""isApplicationHidden"");
    if (mService != null) {
        try {
            return mService.isApplicationHidden(admin, mContext.getPackageName(), packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.isApplicationHidden(admin, mContext.getPackageName(), packageName, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Determine if a package is hidden. This function can be called by a device owner, profile
 * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to retrieve the hidden status of.
 * @return boolean {@code true} if the package is hidden, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
","/**
 * Determine if a package is hidden. This function can be called by a device owner, profile
 * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance, returned by
 * {@link #getParentProfileInstance(ComponentName)}, where the caller must be the profile owner
 * of an organization-owned managed profile and the package must be a system package. If called
 * on the parent instance, this will determine whether the package is hidden or unhidden in the
 * personal profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to retrieve the hidden status of.
 * @return boolean {@code true} if the package is hidden, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device or profile owner or if called on
 * the parent profile and the {@code admin} is not a profile owner of an
 * organization-owned managed profile.
 * @throws IllegalArgumentException if called on the parent profile and the package provided
 * is not a system package.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation changes include the deletion of the call to `throwIfParentInstance(""isApplicationHidden"")` and the introduction of a new parameter `mParentInstance` to the method `mService.isApplicationHidden()`. Therefore, the change type is 4,5, as the dependent API 'isApplicationHidden' of 'mService' has an additional parameter in the late version.","There is no Compatibility Issue detected because the change to the 'isApplicationHidden' method of 'mService' won't necessarily lead to different return values or exceptions. The addition of 'mParentInstance' as a parameter does not affect the return type or the value, and the exception handling remains the same. Therefore, the API behaves consistently between versions regarding return values and exceptions thrown."
177,<android.app.ActivityThread.H: void handleMessage(Message)>,29,30,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            }
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            }
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
        case ATTACH_STARTUP_AGENTS:
            handleAttachStartupAgents((String) msg.obj);
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
178,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,29,30,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,0,"{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        outAttrs.targetInputMethodUser = mTextOperationUser;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            return ic;
        }
    }
    return null;
}","{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        outAttrs.targetInputMethodUser = mTextOperationUser;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            outAttrs.setInitialSurroundingText(mText);
            return ic;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
179,<android.net.Uri.PathPart: PathPart readFrom(Parcel)>,29,30,<android.net.Uri.PathPart: PathPart readFrom(Parcel)>,<android.net.Uri.PathPart: PathPart readFrom(Parcel)>,0,"{
    int representation = parcel.readInt();
    switch(representation) {
        case Representation.BOTH:
            return from(parcel.readString(), parcel.readString());
        case Representation.ENCODED:
            return fromEncoded(parcel.readString());
        case Representation.DECODED:
            return fromDecoded(parcel.readString());
        default:
            throw new IllegalArgumentException(""Bad representation: "" + representation);
    }
}","{
    int representation = parcel.readInt();
    switch(representation) {
        case REPRESENTATION_ENCODED:
            return fromEncoded(parcel.readString8());
        case REPRESENTATION_DECODED:
            return fromDecoded(parcel.readString8());
        default:
            throw new IllegalArgumentException(""Unknown representation: "" + representation);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The control structure for the switch statement is modified with changes in the cases used, the method used to read the string from the parcel is updated (`readString` to `readString8`), and there's an alteration in the default case's exception message. Moreover, the constant names used inside the cases (like `REPRESENTATION_ENCODED` instead of `BOTH`) have changed, which indicates that the dependent API (`REPRESENTATION_*` constants) could have changed as well, so the code change types are 1,4,5.","The method `readString8()` may behave differently from `readString()`. Additionally, because of the changes in switch cases, and the potential change in dependent API (`REPRESENTATION_*` constants), the method could return a different `PathPart` object, and throw a new type of exception (`IllegalArgumentException` with a different message), which can produce a CI. Thus, the CI types are 1 (due to potential different return values) and potentially 2 (due to different exception messages, although the impact of the changed exception message on behavior could be arguable, it is mentioned for completeness)."
182,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,29,30,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,0,"{
    try {
        final String installerPackage;
        if (params.installerPackageName == null) {
            installerPackage = mInstallerPackageName;
        } else {
            installerPackage = params.installerPackageName;
        }
        return mInstaller.createSession(params, installerPackage, mUserId);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mInstaller.createSession(params, mInstallerPackageName, mUserId);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Create a new session using the given parameters, returning a unique ID
 * that represents the session. Once created, the session can be opened
 * multiple times across multiple device boots.
 * <p>
 * The system may automatically destroy sessions that have not been
 * finalized (either committed or abandoned) within a reasonable period of
 * time, typically on the order of a day.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when installation services are unavailable,
 * such as when called from a restricted user.
 * @throws IllegalArgumentException when {@link SessionParams} is invalid.
 * @return positive, non-zero unique ID that represents the created session.
 * This ID remains consistent across device reboots until the
 * session is finalized. IDs are not reused during a given boot.
 */
","/**
 * Create a new session using the given parameters, returning a unique ID
 * that represents the session. Once created, the session can be opened
 * multiple times across multiple device boots.
 * <p>
 * The system may automatically destroy sessions that have not been
 * finalized (either committed or abandoned) within a reasonable period of
 * time, typically on the order of a day.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when installation services are unavailable,
 * such as when called from a restricted user.
 * @throws IllegalArgumentException when {@link SessionParams} is invalid.
 * @return positive, non-zero unique ID that represents the created session.
 * This ID remains consistent across device reboots until the
 * session is finalized. IDs are not reused during a given boot.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the logic that determines the installerPackage to be used: instead of conditionally using params.installerPackageName or mInstallerPackageName, the late version always uses mInstallerPackageName. Since this does not change the value returned by the method (still the result of mInstaller.createSession), the exception handling has not been changed and the statement under the control dependencies is not changed, the code change type is 4.","There is no Compatibility Issue detected because the API returns the result of another API call, there are no return statement changes, the exception handling stays the same, and no new exception is created or existing ones altered. The change only simplifies which installer package name is sent to mInstaller.createSession method; thus, as long as the mInstallerPackageName contains the correct value this change does not cause different runtime behavior from the perspective of return values or exceptions."
183,"<android.app.AppOpsManager: int noteOp(String,int,String)>",29,30,"<android.app.AppOpsManager: int noteOp(String,int,String)>","<android.app.AppOpsManager: int noteOp(String,int,String)>",0,"{
    return noteOp(strOpToOp(op), uid, packageName);
}","{
    return noteOp(op, uid, packageName, null, null);
}",1,"/**
 * Make note of an application performing an operation.  Note that you must pass
 * in both the uid and name of the application to be checked; this function will verify
 * that these two match, and if not, return {@link #MODE_IGNORED}.  If this call
 * succeeds, the last execution time of the operation for this app will be updated to
 * the current time.
 * @param op The operation to note.  One of the OPSTR_* constants.
 * @param uid The user id of the application attempting to perform the operation.
 * @param packageName The name of the application attempting to perform the operation.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or
 * {@link #MODE_IGNORED} if it is not allowed and should be silently ignored (without
 * causing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
","/**
 * @deprecated Use {@link #noteOp(String, int, String, String, String)} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within the return statement has changed parameters from strOpToOp(op) to op directly and added two more parameters as null, so the code change type is 1,5.","Since the dependent method being called has changed (it's now called with different parameters), there is a potential for a different return value from the method. This constitutes a Compatibility Issue of type 1."
184,<android.app.ContextImpl: File[] getExternalFilesDirs(String)>,29,30,<android.app.ContextImpl: File[] getExternalFilesDirs(String)>,<android.app.ContextImpl: File[] getExternalFilesDirs(String)>,0,"{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());
        if (type != null) {
            dirs = Environment.buildPaths(dirs, type);
        }
        return ensureExternalDirsExistOrFilter(dirs);
    }
}","{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());
        if (type != null) {
            dirs = Environment.buildPaths(dirs, type);
        }
        return ensureExternalDirsExistOrFilter(dirs, true);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method ensureExternalDirsExistOrFilter is called with an additional parameter 'true' in the late version, which indicates a change in the method invocation (the way it's called), so the code change type is 4. Since this is an internal method which is being changed, the code change type is also 5. However, without knowing the definition of this method, it's uncertain if this constitutes a change in behavior.","There could potentially be a compatibility issue if the newly introduced parameter changes the behavior of the ensureExternalDirsExistOrFilter method. However, based solely on the provided information of adding a 'true' as an extra parameter to the method and no further information on the behavior change inside ensureExternalDirsExistOrFilter, it is not clear that this change will cause a different return type or value, nor a different exception being thrown. Thus, we cannot definitively say it is a compatibility issue without additional context on the internal method's behavior."
185,<android.os.StrictMode.AndroidBlockGuardPolicy: void onThreadPolicyViolation(ViolationInfo)>,29,30,<android.os.StrictMode.AndroidBlockGuardPolicy: void onThreadPolicyViolation(ViolationInfo)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onThreadPolicyViolation(ViolationInfo)>,0,"{
    if (LOG_V)
        Log.d(TAG, ""onThreadPolicyViolation; penalty="" + info.mPenaltyMask);
    if (info.penaltyEnabled(PENALTY_GATHER)) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<>(1);
            gatheredViolations.set(violations);
        }
        for (ViolationInfo previous : violations) {
            if (info.getStackTrace().equals(previous.getStackTrace())) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if (info.penaltyEnabled(PENALTY_LOG) && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        sLogger.log(info);
    }
    final Violation violation = info.mViolation;
    // Penalties that ActivityManager should execute on our behalf.
    int penaltyMask = 0;
    if (info.penaltyEnabled(PENALTY_DIALOG) && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        penaltyMask |= PENALTY_DIALOG;
    }
    if (info.penaltyEnabled(PENALTY_DROPBOX) && lastViolationTime == 0) {
        penaltyMask |= PENALTY_DROPBOX;
    }
    if (penaltyMask != 0) {
        final boolean justDropBox = (info.mPenaltyMask == PENALTY_DROPBOX);
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(penaltyMask, info);
        } else {
            handleApplicationStrictModeViolation(penaltyMask, info);
        }
    }
    if (info.penaltyEnabled(PENALTY_DEATH)) {
        throw new RuntimeException(""StrictMode ThreadPolicy violation"", violation);
    }
    // penaltyDeath will cause penaltyCallback to no-op since we cannot guarantee the
    // executor finishes before crashing.
    final OnThreadViolationListener listener = sThreadViolationListener.get();
    final Executor executor = sThreadViolationExecutor.get();
    if (listener != null && executor != null) {
        try {
            executor.execute(() -> {
                // Lift violated policy to prevent infinite recursion.
                ThreadPolicy oldPolicy = StrictMode.allowThreadViolations();
                try {
                    listener.onThreadViolation(violation);
                } finally {
                    StrictMode.setThreadPolicy(oldPolicy);
                }
            });
        } catch (RejectedExecutionException e) {
            Log.e(TAG, ""ThreadPolicy penaltyCallback failed"", e);
        }
    }
}","{
    if (LOG_V)
        Log.d(TAG, ""onThreadPolicyViolation; penalty="" + info.mPenaltyMask);
    if (info.penaltyEnabled(PENALTY_GATHER)) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<>(1);
            gatheredViolations.set(violations);
        }
        for (ViolationInfo previous : violations) {
            if (info.getStackTrace().equals(previous.getStackTrace())) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    long now = SystemClock.uptimeMillis();
    if (sLogger == LOGCAT_LOGGER) {
        // Don't throttle it if there is a non-default logger
        if (mLastViolationTime != null) {
            Long vtime = mLastViolationTime.get(crashFingerprint);
            if (vtime != null) {
                lastViolationTime = vtime;
            }
            clampViolationTimeMap(mLastViolationTime, Math.max(MIN_LOG_INTERVAL_MS, Math.max(MIN_DIALOG_INTERVAL_MS, MIN_DROPBOX_INTERVAL_MS)));
        } else {
            mLastViolationTime = new ArrayMap<>(1);
        }
        mLastViolationTime.put(crashFingerprint, now);
    }
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if (info.penaltyEnabled(PENALTY_LOG) && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        sLogger.log(info);
    }
    final Violation violation = info.mViolation;
    // Penalties that ActivityManager should execute on our behalf.
    int penaltyMask = 0;
    if (info.penaltyEnabled(PENALTY_DIALOG) && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        penaltyMask |= PENALTY_DIALOG;
    }
    if (info.penaltyEnabled(PENALTY_DROPBOX) && timeSinceLastViolationMillis > MIN_DROPBOX_INTERVAL_MS) {
        penaltyMask |= PENALTY_DROPBOX;
    }
    if (penaltyMask != 0) {
        final boolean justDropBox = (info.mPenaltyMask == PENALTY_DROPBOX);
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(penaltyMask, info);
        } else {
            handleApplicationStrictModeViolation(penaltyMask, info);
        }
    }
    if (info.penaltyEnabled(PENALTY_DEATH)) {
        throw new RuntimeException(""StrictMode ThreadPolicy violation"", violation);
    }
    // penaltyDeath will cause penaltyCallback to no-op since we cannot guarantee the
    // executor finishes before crashing.
    final OnThreadViolationListener listener = sThreadViolationListener.get();
    final Executor executor = sThreadViolationExecutor.get();
    if (listener != null && executor != null) {
        try {
            executor.execute(() -> {
                // Lift violated policy to prevent infinite recursion.
                ThreadPolicy oldPolicy = StrictMode.allowThreadViolations();
                try {
                    listener.onThreadViolation(violation);
                } finally {
                    StrictMode.setThreadPolicy(oldPolicy);
                }
            });
        } catch (RejectedExecutionException e) {
            Log.e(TAG, ""ThreadPolicy penaltyCallback failed"", e);
        }
    }
}",1,"// hence the policy being passed around.
","// hence the policy being passed around.
",-1,,,-1,-1,-1,-1,-1,-1,,,,
186,<android.accessibilityservice.GestureDescription.Builder: GestureDescription build()>,29,30,<android.accessibilityservice.GestureDescription.Builder: GestureDescription build()>,<android.accessibilityservice.GestureDescription.Builder: GestureDescription build()>,0,"{
    if (mStrokes.size() == 0) {
        throw new IllegalStateException(""Gestures must have at least one stroke"");
    }
    return new GestureDescription(mStrokes);
}","{
    if (mStrokes.size() == 0) {
        throw new IllegalStateException(""Gestures must have at least one stroke"");
    }
    return new GestureDescription(mStrokes, mDisplayId);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The constructor used in the return statement has been changed, as it now takes an additional parameter (mDisplayId). This is a modification to the method signature, thus the change types are 1, 4, and possibly 5 if the constructor definition of `GestureDescription` is considered an API that `build()` depends on.","Due to the additional parameter in the constructor, the behavior of building a GestureDescription will change, leading to a CI of type 1 as the method potentially returns a `GestureDescription` with different information."
188,<android.companion.WifiDeviceFilter.Builder: Builder setNamePattern(Pattern)>,29,30,<android.companion.WifiDeviceFilter.Builder: Builder setNamePattern(Pattern)>,<android.companion.WifiDeviceFilter.Builder: Builder setNamePattern(Pattern)>,0,"{
    checkNotUsed();
    mNamePattern = regex;
    return this;
}","{
    checkNotUsed();
    mBuilderFieldsSet |= 0x1;
    mNamePattern = value;
    return this;
}",1,"/**
 * @param regex if set, only devices with {@link BluetoothDevice#getName name} matching the
 * given regular expression will be shown
 * @return self for chaining
 */
","/**
 * If set, only devices with {@link BluetoothDevice#getName name} matching the given regular
 * expression will be shown
 */
",-1,,"[@DataClass.Generated.Member, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"There is an additional assignment statement to `mBuilderFieldsSet` in the late version, and the parameter name in the method signature has been changed from ""regex"" to ""value"", which does not affect the way the method processes the input or what it returns. So the change type is 4.","There is no compatibility issue as the changes do not affect the API's behavior from an external perspective. The API still accepts a Pattern object and returns the Builder object. Thus, CI is 0."
189,<android.app.ContextImpl: File[] getObbDirs()>,29,30,<android.app.ContextImpl: File[] getObbDirs()>,<android.app.ContextImpl: File[] getObbDirs()>,0,"{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppObbDirs(getPackageName());
        return ensureExternalDirsExistOrFilter(dirs);
    }
}","{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppObbDirs(getPackageName());
        return ensureExternalDirsExistOrFilter(dirs, true);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The `ensureExternalDirsExistOrFilter` method is being called with an additional boolean parameter `true` in the late version, which indicates a change in the dependent API, so the code change type is 5.","Because of the added parameter to the call of `ensureExternalDirsExistOrFilter`, there's a potential for this method to behave differently, especially if the behaviour of `ensureExternalDirsExistOrFilter` changes based on the new parameter. This change can potentially lead to different return values, causing the CI type to be 1."
191,<android.view.textclassifier.TextClassificationSessionId: boolean equals(Object)>,29,30,<android.view.textclassifier.TextClassificationSessionId: boolean equals(Object)>,<android.view.textclassifier.TextClassificationSessionId: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    TextClassificationSessionId other = (TextClassificationSessionId) obj;
    if (!mValue.equals(other.mValue)) {
        return false;
    }
    return true;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    TextClassificationSessionId that = (TextClassificationSessionId) o;
    return Objects.equals(mValue, that.mValue) && Objects.equals(mToken, that.mToken);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation of the equals method has been refactored in the late version, including the following changes:","- Changed the equality check from `!mValue.equals(other.mValue)` to `Objects.equals(mValue, that.mValue)`, which alters how equality is determined."
192,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",29,30,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>","<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.refresh(url, args, cancellationSignal);
    } catch (RemoteException e) {
        return false;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return false;
    }
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = provider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return provider.refresh(mPackageName, url, args, remoteCancellationSignal);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return false;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.refresh(url, extras, cancellationSignal);
    } catch (RemoteException e) {
        return false;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return false;
    }
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = provider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return provider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return false;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * This allows clients to request an explicit refresh of content identified by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong indication (such as a user
 * initiated pull to refresh gesture) that the content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param args Additional options from the client. The definitions of these are specific to the
 * content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
 * none. For example, if you called refresh on a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether the client has
 * canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
","/**
 * This allows clients to request an explicit refresh of content identified
 * by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong
 * indication (such as a user initiated pull to refresh gesture) that the
 * content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param extras Additional options from the client. The definitions of
 * these are specific to the content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none. For example, if you called refresh on
 * a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether
 * the client has canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The name of the variable `args` was changed to `extras`. An `mAttributionTag` parameter has been introduced to call `provider.refresh()`. As for the `Preconditions.checkNotNull(url, ""url"")` it has undergone change to `Objects.requireNonNull(url, ""url"")`, which has no functional impact as it's just a different API for the same null check functionality. Hence, the code change types are 3,4,5.","Despite the change in variable names and addition of a new parameter, these changes will not introduce a Compatibility Issue as long as the semantics of how the method works remain the same. The `requireNonNull` method serves the same purpose as `Preconditions.checkNotNull` and the introduction of `mAttributionTag` should be backwards compatible, as existing code wouldn't be using this new parameter and the system supplying it will handle its absence appropriately. There is no Compatibility Issue caused by potential different return values or types nor by potential different exception handlings."
193,<android.content.pm.ModuleInfo: boolean equals(Object)>,29,30,<android.content.pm.ModuleInfo: boolean equals(Object)>,<android.content.pm.ModuleInfo: boolean equals(Object)>,0,"{
    if (!(obj instanceof ModuleInfo)) {
        return false;
    }
    final ModuleInfo other = (ModuleInfo) obj;
    return Objects.equals(mName, other.mName) && Objects.equals(mPackageName, other.mPackageName) && mHidden == other.mHidden;
}","{
    if (!(obj instanceof ModuleInfo)) {
        return false;
    }
    final ModuleInfo other = (ModuleInfo) obj;
    return Objects.equals(mName, other.mName) && Objects.equals(mPackageName, other.mPackageName) && Objects.equals(mApexModuleName, other.mApexModuleName) && mHidden == other.mHidden;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"An additional check using Objects.equals(mApexModuleName, other.mApexModuleName) is added to the return statement, so this is categorized as a change type 4 (Other statement changed).","This change can lead to a different return value because it adds a new condition to check for equality. If mApexModuleName is not equal between 'this' and 'other', the method will now return false, whereas previously it did not check mApexModuleName. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
195,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,29,30,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,0,"{
    Preconditions.checkNotNull(name, ""name"");
    IContentProvider provider = acquireProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, name, true);
    }
    return null;
}","{
    Objects.requireNonNull(name, ""name"");
    IContentProvider provider = acquireProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, name, true);
    }
    return null;
}",1,"/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider if it determines that there is no other reason for
 * keeping it active.
 * @param name specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name or null if there isn't one.
 */
","/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider if it determines that there is no other reason for
 * keeping it active.
 * @param name specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name or null if there isn't one.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation is altered from Preconditions.checkNotNull(name, ""name"") to Objects.requireNonNull(name, ""name""), which is a change in a dependent API call, hence the code change type is 4,5. However, both methods serve the same purpose of checking if the 'name' argument is null and will throw a NullPointerException with the supplied message if it is. The rest of the method body remains unchanged.","There is no Compatibility Issue, since the change from Preconditions.checkNotNull to Objects.requireNonNull does not alter the behavior of acquiring a ContentProviderClient. Both methods will throw a NullPointerException if 'name' is null and have the same effect on the control flow of the method. Therefore, the execution and potential exceptions thrown remain the same, leading to no change in behavior from the perspective of the API consumer."
196,<android.content.IntentFilter: void addDataType(String)>,29,30,<android.content.IntentFilter: void addDataType(String)>,<android.content.IntentFilter: void addDataType(String)>,0,"{
    final int slashpos = type.indexOf('/');
    final int typelen = type.length();
    if (slashpos > 0 && typelen >= slashpos + 2) {
        if (mDataTypes == null)
            mDataTypes = new ArrayList<String>();
        if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
            String str = type.substring(0, slashpos);
            if (!mDataTypes.contains(str)) {
                mDataTypes.add(str.intern());
            }
            mHasPartialTypes = true;
        } else {
            if (!mDataTypes.contains(type)) {
                mDataTypes.add(type.intern());
            }
        }
        return;
    }
    throw new MalformedMimeTypeException(type);
}","{
    processMimeType(type, (internalType, isPartial) -> {
        if (mDataTypes == null) {
            mDataTypes = new ArrayList<>();
        }
        if (mStaticDataTypes == null) {
            mStaticDataTypes = new ArrayList<>();
        }
        if (mDataTypes.contains(internalType)) {
            return;
        }
        mDataTypes.add(internalType.intern());
        mStaticDataTypes.add(internalType.intern());
        mHasStaticPartialTypes = mHasStaticPartialTypes || isPartial;
    });
}",1,"/**
 * Add a new Intent data type to match against.  If any types are
 * included in the filter, then an Intent's data must be <em>either</em>
 * one of these types <em>or</em> a matching scheme.  If no data types
 * are included, then an Intent will only match if it specifies no data.
 *
 * <p><em>Note: MIME type matching in the Android framework is
 * case-sensitive, unlike formal RFC MIME types.  As a result,
 * you should always write your MIME types with lower case letters,
 * and any MIME types you receive from outside of Android should be
 * converted to lower case before supplying them here.</em></p>
 *
 * <p>Throws {@link MalformedMimeTypeException} if the given MIME type is
 * not syntactically correct.
 *
 * @param type Name of the data type to match, such as ""vnd.android.cursor.dir/person"".
 *
 * @see #matchData
 */
","/**
 * Add a new Intent data type to match against.  If any types are
 * included in the filter, then an Intent's data must be <em>either</em>
 * one of these types <em>or</em> a matching scheme.  If no data types
 * are included, then an Intent will only match if it specifies no data.
 *
 * <p><em>Note: MIME type matching in the Android framework is
 * case-sensitive, unlike formal RFC MIME types.  As a result,
 * you should always write your MIME types with lower case letters,
 * and any MIME types you receive from outside of Android should be
 * converted to lower case before supplying them here.</em></p>
 *
 * <p>Throws {@link MalformedMimeTypeException} if the given MIME type is
 * not syntactically correct.
 *
 * @param type Name of the data type to match, such as ""vnd.android.cursor.dir/person"".
 *
 * @see #matchData
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The implementation of `addDataType` has been completely refactored. It introduces a new method called `processMimeType` with a lambda function that changes how the input string `type` is processed. The lambda changes how `mDataTypes` and `mStaticDataTypes` are populated, and introduces a new field `mStaticDataTypes`. Exception handling policy is also changed implicitly by the lambda because it does not throw `MalformedMimeTypeException` inside it. So the code change types include 1 (an implicit return statement inside the lambda function), 2 (the exception handling has been changed and no longer throws `MalformedMimeTypeException` directly), 3 (control structure has changed to use the lambda expression), 4 (general other changes in how the method processes the type), and 5 (introduces a dependency on a new method `processMimeType`).","The change in exception handling can lead to compatibility issues because the method will no longer throw `MalformedMimeTypeException` for the same input that previously would trigger this exception type. This difference could affect existing app code that catches and handles this specific exception, so it could affect both return type/values and exception handling. Moreover, since the method relies on an entirely new implementation (`processMimeType`), its logic for adding data types may result in different outcomes based on how `internalType` and `isPartial` are determined in the new method. Therefore we have compatibility issue types 1 (potential different return values) and 2 (potential different exception handlings) caused by the changes."
197,<android.companion.WifiDeviceFilter: boolean equals(Object)>,29,30,<android.companion.WifiDeviceFilter: boolean equals(Object)>,<android.companion.WifiDeviceFilter: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    WifiDeviceFilter that = (WifiDeviceFilter) o;
    return Objects.equals(mNamePattern, that.mNamePattern);
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") WifiDeviceFilter that = (WifiDeviceFilter) o;
    // noinspection PointlessBooleanExpression
    return true && Objects.equals(mNamePattern, that.mNamePattern) && Objects.equals(mBssid, that.mBssid) && Objects.equals(mBssidMask, that.mBssidMask);
}",1,,,-1,[@Override],"[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return expression has changed: New comparison conditions for `mBssid` and `mBssidMask` have been added and a suppress warnings annotation and comment statement have been introduced, so the code change types are 1,4,5.","The additional fields in the return statement comparison (mBssid and mBssidMask) lead to potential different return values when determining equality, hence the CI type is 1."
199,<android.widget.Toast.TN: void handleShow(IBinder)>,29,30,<android.widget.Toast.TN: void handleShow(IBinder)>,<android.widget.Toast.TN: void handleShow(IBinder)>,0,"{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    // the window token is already invalid and no need to do any work.
    if (mHandler.hasMessages(CANCEL) || mHandler.hasMessages(HIDE)) {
        return;
    }
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        Context context = mView.getContext().getApplicationContext();
        String packageName = mView.getContext().getOpPackageName();
        if (context == null) {
            context = mView.getContext();
        }
        mWM = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        // We can resolve the Gravity here by using the Locale for getting
        // the layout direction
        final Configuration config = mView.getContext().getResources().getConfiguration();
        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
        mParams.gravity = gravity;
        if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
            mParams.horizontalWeight = 1.0f;
        }
        if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
            mParams.verticalWeight = 1.0f;
        }
        mParams.x = mX;
        mParams.y = mY;
        mParams.verticalMargin = mVerticalMargin;
        mParams.horizontalMargin = mHorizontalMargin;
        mParams.packageName = packageName;
        mParams.hideTimeoutMilliseconds = mDuration == Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;
        mParams.token = windowToken;
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        if (localLOGV)
            Log.v(TAG, ""ADD! "" + mView + "" in "" + this);
        // invalidated. Let us hedge against that.
        try {
            mWM.addView(mView, mParams);
            trySendAccessibilityEvent();
        } catch (WindowManager.BadTokenException e) {
        /* ignore */
        }
    }
}","{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    // the window token is already invalid and no need to do any work.
    if (mHandler.hasMessages(CANCEL) || mHandler.hasMessages(HIDE)) {
        return;
    }
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        mPresenter.show(mView, mToken, windowToken, mDuration, mGravity, mX, mY, mHorizontalMargin, mVerticalMargin, new CallbackBinder(getCallbacks(), mHandler));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version has consolidated multiple statements into a single method call to mPresenter.show(), all the previous steps for setting up parameters for mParams and calls to mWM.addView() have been removed, so code change types are 3 and 4 due to the change in the control dependency and other statements.","The removal of a part of the implementation and its consolidation into a single method call should not cause a compatibility issue as long as the behavior of presenting the Toast message remains the same. The change appears to be a refactoring to simplify the code without changing its external behavior. Hence, the CI type is 0, meaning there is no compatibility issue."
200,"<android.view.SurfaceControl.Transaction: Transaction setLayer(SurfaceControl,int)>",29,30,"<android.view.SurfaceControl.Transaction: Transaction setLayer(SurfaceControl,int)>","<android.view.SurfaceControl.Transaction: Transaction setLayer(SurfaceControl,int)>",0,"{
    sc.checkNotReleased();
    nativeSetLayer(mNativeObject, sc.mNativeObject, z);
    return this;
}","{
    checkPreconditions(sc);
    nativeSetLayer(mNativeObject, sc.mNativeObject, z);
    return this;
}",1,"/**
 * Set the Z-order for a given SurfaceControl, relative to it's siblings.
 * If two siblings share the same Z order the ordering is undefined. Surfaces
 * with a negative Z will be placed below the parent surface.
 *
 * @param sc The SurfaceControl to set the Z order on
 * @param z The Z-order
 * @return This Transaction.
 */
","/**
 * Set the Z-order for a given SurfaceControl, relative to it's siblings.
 * If two siblings share the same Z order the ordering is undefined. Surfaces
 * with a negative Z will be placed below the parent surface.
 *
 * @param sc The SurfaceControl to set the Z order on
 * @param z The Z-order
 * @return This Transaction.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method sc.checkNotReleased() is replaced with checkPreconditions(sc). This is a change to an invocation of a dependent API, hence the code change type is 4,5.","Since the change is a refactoring of the exception check and does not affect the control flow related to the return value or exception handling of the API directly (as long as both methods serve to validate preconditions), there is no Compatibility Issue introduced by this change, so the CI type is 0."
201,"<android.util.Half: boolean equals(short,short)>",29,30,"<android.util.Half: boolean equals(short,short)>","<android.util.Half: boolean equals(short,short)>",0,"{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    return x == y || ((x | y) & FP16_COMBINED) == 0;
}","{
    return FP16.equals(x, y);
}",1,"/**
 * Returns true if the two half-precision float values are equal.
 * If either of the values is NaN, the result is false. {@link #POSITIVE_ZERO}
 * and {@link #NEGATIVE_ZERO} are considered equal.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is equal to y, false otherwise
 */
","/**
 * Returns true if the two half-precision float values are equal.
 * If either of the values is NaN, the result is false. {@link #POSITIVE_ZERO}
 * and {@link #NEGATIVE_ZERO} are considered equal.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is equal to y, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early version contains an implementation with multiple conditions and a direct comparison, while the late version changes to a single method call to FP16.equals(x, y). This is a change in the return statement and a change in the method the API depends on, so the code change types are 1,4,5.","Because the method used for comparison has been changed from explicit condition checks to a method call, the behavior of equals could potentially be different if the implementation of FP16.equals(x, y) has different logic than the explicit checks. Therefore, this could lead to a different return value, so the CI type is 1."
202,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",29,30,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"{
    Preconditions.checkNotNull(type);
    mEntityConfidence.put(type, confidenceScore);
    return this;
}","{
    Objects.requireNonNull(type);
    mEntityConfidence.put(type, confidenceScore);
    return this;
}",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The method used for null-checking the parameter 'type' has changed from `Preconditions.checkNotNull(type)` to `Objects.requireNonNull(type)`. Both methods serve the same purpose and throw a similar exception if 'type' is null, thus the behavior of the API has not fundamentally changed. Therefore, the change type is 4 (Other statement changed).","There is no Compatibility Issue here as the null check is semantically the same despite a different method being used. Both would result in an exception if 'type' is null, and the rest of the method remains unchanged."
203,<android.app.WallpaperManager: Drawable getDrawable()>,29,30,<android.app.WallpaperManager: Drawable getDrawable()>,<android.app.WallpaperManager: Drawable getDrawable()>,0,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true, FLAG_SYSTEM);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}","{
    final ColorManagementProxy cmProxy = getColorManagementProxy();
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true, FLAG_SYSTEM, cmProxy);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}",1,"/**
 * Retrieve the current system wallpaper; if
 * no wallpaper is set, the system built-in static wallpaper is returned.
 * This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 * <p>
 * This method can return null if there is no system wallpaper available, if
 * wallpapers are not supported in the current user, or if the calling app is not
 * permitted to access the system wallpaper.
 *
 * @return Returns a Drawable object that will draw the system wallpaper,
 * or {@code null} if no system wallpaper exists or if the calling application
 * is not able to access the wallpaper.
 */
","/**
 * Retrieve the current system wallpaper; if
 * no wallpaper is set, the system built-in static wallpaper is returned.
 * This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 * <p>
 * This method can return null if there is no system wallpaper available, if
 * wallpapers are not supported in the current user, or if the calling app is not
 * permitted to access the system wallpaper.
 *
 * @return Returns a Drawable object that will draw the system wallpaper,
 * or {@code null} if no system wallpaper exists or if the calling application
 * is not able to access the wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is an additional parameter (ColorManagementProxy cmProxy) used in the call to ```sGlobals.peekWallpaperBitmap(...)``` method in the late implementation, which has been retrieved through ```getColorManagementProxy()```. This means that there has been a change in the statement other than return, exception handling, or control dependency, and also the current API relied on the dependent API (peekWallpaperBitmap) that has changed. Consequently, the change types are 4 for other statement changed and 5 for dependent API changed.","Despite the changes, there is no direct implication that these would cause a different behavior in terms of the Drawable being returned, as the core functionality of the API seems to remain the same— the API is still returning a Drawable of the current wallpaper, and the way exceptions are handled remains unchanged as well. Thus, there doesn't appear to be a Compatibility Issue due to the mentioned changes, so pred_CI is 0."
204,<android.service.voice.AlwaysOnHotwordDetector: Intent createReEnrollIntent()>,29,30,<android.service.voice.AlwaysOnHotwordDetector: Intent createReEnrollIntent()>,<android.service.voice.AlwaysOnHotwordDetector: Intent createReEnrollIntent()>,0,"{
    if (DBG)
        Slog.d(TAG, ""createReEnrollIntent"");
    synchronized (mLock) {
        return getManageIntentLocked(MANAGE_ACTION_RE_ENROLL);
    }
}","{
    if (DBG)
        Slog.d(TAG, ""createReEnrollIntent"");
    synchronized (mLock) {
        return getManageIntentLocked(KeyphraseEnrollmentInfo.MANAGE_ACTION_RE_ENROLL);
    }
}",1,"/**
 * Creates an intent to start the re-enrollment for the associated keyphrase.
 * This intent must be invoked using {@link Activity#startActivityForResult(Intent, int)}.
 * Starting re-enrollment is only valid if the keyphrase is already enrolled,
 * i.e. {@link #STATE_KEYPHRASE_ENROLLED}, otherwise invoking this may result in an error.
 *
 * @return An {@link Intent} to start re-enrollment for the given keyphrase.
 * @throws UnsupportedOperationException if managing they keyphrase isn't supported.
 * Callers should only call this method after a supported state callback on
 * {@link Callback#onAvailabilityChanged(int)} to avoid this exception.
 * @throws IllegalStateException if the detector is in an invalid state.
 * This may happen if another detector has been instantiated or the
 * {@link VoiceInteractionService} hosting this detector has been shut down.
 */
","/**
 * Creates an intent to start the re-enrollment for the associated keyphrase.
 * This intent must be invoked using {@link Context#startForegroundService(Intent)}.
 * Starting re-enrollment is only valid if the keyphrase is already enrolled,
 * i.e. {@link #STATE_KEYPHRASE_ENROLLED}, otherwise invoking this may result in an error.
 *
 * @return An {@link Intent} to start re-enrollment for the given keyphrase.
 * @throws UnsupportedOperationException if managing they keyphrase isn't supported.
 * Callers should only call this method after a supported state callback on
 * {@link Callback#onAvailabilityChanged(int)} to avoid this exception.
 * @throws IllegalStateException if the detector is in an invalid state.
 * This may happen if another detector has been instantiated or the
 * {@link VoiceInteractionService} hosting this detector has been shut down.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method argument in getManageIntentLocked() has changed from MANAGE_ACTION_RE_ENROLL to KeyphraseEnrollmentInfo.MANAGE_ACTION_RE_ENROLL. This represents a change in the dependent API, so the code change type is 5.","Since the code change only affects the argument passed to the method getManageIntentLocked(), and assuming that KeyphraseEnrollmentInfo.MANAGE_ACTION_RE_ENROLL is supposed to resolve to the same value as the original MANAGE_ACTION_RE_ENROLL (just relocating the constant), there would be no Compatibility Issue, as the behavior of getManageIntentLocked() should remain unchanged. Therefore, the CI type is 0."
205,<android.view.textclassifier.TextClassificationConstants: boolean isSmartTextShareEnabled()>,29,30,<android.view.textclassifier.TextClassificationConstants: boolean isSmartTextShareEnabled()>,<android.view.textclassifier.TextClassificationConstants: boolean isSmartTextShareEnabled()>,0,"{
    return mConfigParser.getBoolean(SMART_TEXT_SHARE_ENABLED, SMART_TEXT_SHARE_ENABLED_DEFAULT);
}","{
    return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_TEXTCLASSIFIER, SMART_TEXT_SHARE_ENABLED, SMART_TEXT_SHARE_ENABLED_DEFAULT);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method from which the boolean value is retrieved has changed from 'mConfigParser.getBoolean(...)' to 'DeviceConfig.getBoolean(...)', which indicates a change in the dependent API being used to retrieve the configuration setting. Additionally, it includes a new String argument 'DeviceConfig.NAMESPACE_TEXTCLASSIFIER'. Hence, the change type is 4,5 (Other statements changed, Dependent API changed).","There might be no Compatibility Issue since the method signature and the expected return type of the boolean value remain unchanged. The underlying functionality of obtaining the boolean value, although through a different configuration system, is meant to provide the same type of information and default value. Therefore, as long as the new implementation properly follows the contract of the old implementation, there should be no CI. However, the behavior could potentially change if the semantics of how the settings are retrieved, managed, or defined differ between the two configuration systems. Since the information given does not indicate a change in behavior, 0 indicates No Compatibility Issue on the surface level based on available data."
206,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,29,30,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    if (mDetached.get()) {
        if (mActiveEngines.contains(mEngine)) {
            doDetachEngine();
        }
        return;
    }
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this, mDisplayId);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                doDetachEngine();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, (Long) message.obj);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.mOutsets.set((Rect) message.obj);
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    mConnection.onWallpaperColorsChanged(mEngine.onComputeColors(), mDisplayId);
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    if (mDetached.get()) {
        if (mActiveEngines.contains(mEngine)) {
            doDetachEngine();
        }
        return;
    }
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this, mDisplayId);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                doDetachEngine();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, (Long) message.obj);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_SCALE:
            mEngine.setZoom(Float.intBitsToFloat(message.arg1));
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    mConnection.onWallpaperColorsChanged(mEngine.onComputeColors(), mDisplayId);
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
207,"<android.content.ContentProviderOperation.Builder: Builder withValue(String,Object)>",29,30,"<android.content.ContentProviderOperation.Builder: Builder withValue(String,Object)>","<android.content.ContentProviderOperation.Builder: Builder withValue(String,Object)>",0,"{
    if (mType != TYPE_INSERT && mType != TYPE_UPDATE && mType != TYPE_ASSERT) {
        throw new IllegalArgumentException(""only inserts and updates can have values"");
    }
    if (mValues == null) {
        mValues = new ContentValues();
    }
    if (value == null) {
        mValues.putNull(key);
    } else if (value instanceof String) {
        mValues.put(key, (String) value);
    } else if (value instanceof Byte) {
        mValues.put(key, (Byte) value);
    } else if (value instanceof Short) {
        mValues.put(key, (Short) value);
    } else if (value instanceof Integer) {
        mValues.put(key, (Integer) value);
    } else if (value instanceof Long) {
        mValues.put(key, (Long) value);
    } else if (value instanceof Float) {
        mValues.put(key, (Float) value);
    } else if (value instanceof Double) {
        mValues.put(key, (Double) value);
    } else if (value instanceof Boolean) {
        mValues.put(key, (Boolean) value);
    } else if (value instanceof byte[]) {
        mValues.put(key, (byte[]) value);
    } else {
        throw new IllegalArgumentException(""bad value type: "" + value.getClass().getName());
    }
    return this;
}","{
    assertValuesAllowed();
    if (!ContentValues.isSupportedValue(value)) {
        throw new IllegalArgumentException(""bad value type: "" + value.getClass().getName());
    }
    setValue(key, value);
    return this;
}",1,"/**
 * A value to insert or update. This value may be overwritten by
 * the corresponding value specified by {@link #withValueBackReference}.
 * This can only be used with builders of type insert, update, or assert.
 * @param key the name of this value
 * @param value the value itself. the type must be acceptable for insertion by
 * {@link ContentValues#put}
 * @return this builder, to allow for chaining.
 */
","/**
 * Configure the given value to use for this operation. This method will
 * replace any previously defined value for this key.
 *
 * @param key the key indicating which value to configure
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"Multiple changes observed: the implementation of how values are set has changed, including the extraction of logic into methods like assertValuesAllowed() and setValue(key, value), and the use of ContentValues.isSupportedValue(value) for type checking rather than the series of if-else blocks. Also, the return type is annotated with @NonNull in the late version, which is a structural change in the API indicating a change in the contract regarding nullability. So, the change types include 1 (due to the removal of the direct setting of the content values), 4 (due to the refactoring and method calls), and 5 (due to the dependence on new or changed methods assertValuesAllowed() and setValue()).","The change in this case can potentially lead to different behavior since the new method calls and checks could handle types and null differently or enforce stricter type constraints (ContentValues.isSupportedValue(value)). Also, the @NonNull annotation means callers can no longer expect null to be a valid return value, and any code passing or handling null would now be incorrect. The whole refactoring could alter the return value and hence could cause a compatibility issue, so the CI type is 1."
208,<android.view.autofill.AutofillManager: String getDefaultFieldClassificationAlgorithm()>,29,30,<android.view.autofill.AutofillManager: String getDefaultFieldClassificationAlgorithm()>,<android.view.autofill.AutofillManager: String getDefaultFieldClassificationAlgorithm()>,0,"{
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getDefaultFieldClassificationAlgorithm(receiver);
        return receiver.getStringResult();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}","{
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getDefaultFieldClassificationAlgorithm(receiver);
        return receiver.getStringResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get default field classification algorithm."");
    }
}",1,"/**
 * Gets the name of the default algorithm used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p>The default algorithm is used when the algorithm on {@link UserData} is invalid or not
 * set.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
","/**
 * Gets the name of the default algorithm used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p>The default algorithm is used when the algorithm on {@link UserData} is invalid or not
 * set.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"2,4",2,"The early version implementation has a return null statement in the catch block for RemoteException, which has been removed in the late version. Additionally, the late version introduces a new catch block for SyncResultReceiver.TimeoutException not present in the early version. These are exceptions handling changes, a type of change that reflects a type 2 modification. The exception thrown as RuntimeException is a new behavior and not a direct replacement of an existing statement, thus it's also considered an other statement change, marking it as type 4.","In the late version, a RemoteException is now rethrown as a wrapped system server error with throw e.rethrowFromSystemServer(), and a new catch block for SyncResultReceiver.TimeoutException has been added, which throws a new RuntimeException. Both modification represent changes in the exception handling; thus, it could cause the API to throw different exceptions in certain circumstances, preparing a CI potential of type 2."
209,<android.provider.SettingsStringUtil.ComponentNameSet: String itemToString(ComponentName)>,29,30,<android.provider.SettingsStringUtil.ComponentNameSet: String itemToString(ComponentName)>,<android.provider.SettingsStringUtil.ComponentNameSet: String itemToString(ComponentName)>,0,"{
    return item.flattenToString();
}","{
    return item != null ? item.flattenToString() : ""null"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"There is an added null check condition in the return statement. If 'item' is null, the string ""null"" will be returned, which was not the case in the early implementation, hence the code change type is 1.","Since there's a change in the return statement to account for 'item' being null, where previously it would have thrown a NullPointerException, these changes could lead to a different return value when 'item' is null. Thus, the CI type is 1."
210,<android.hardware.radio.TunerAdapter: ProgramList getDynamicProgramList(Filter)>,29,30,<android.hardware.radio.TunerAdapter: ProgramList getDynamicProgramList(Filter)>,<android.hardware.radio.TunerAdapter: ProgramList getDynamicProgramList(Filter)>,0,"{
    synchronized (mTuner) {
        if (mLegacyListProxy != null) {
            mLegacyListProxy.close();
            mLegacyListProxy = null;
        }
        mLegacyListFilter = null;
        ProgramList list = new ProgramList();
        mCallback.setProgramListObserver(list, () -> {
            try {
                mTuner.stopProgramListUpdates();
            } catch (RemoteException ex) {
                Log.e(TAG, ""Couldn't stop program list updates"", ex);
            }
        });
        try {
            mTuner.startProgramListUpdates(filter);
        } catch (UnsupportedOperationException ex) {
            Log.i(TAG, ""Program list is not supported with this hardware"");
            return null;
        } catch (RemoteException ex) {
            mCallback.setProgramListObserver(null, () -> {
            });
            throw new RuntimeException(""service died"", ex);
        }
        return list;
    }
}","{
    synchronized (mTuner) {
        if (mLegacyListProxy != null) {
            mLegacyListProxy.close();
            mLegacyListProxy = null;
        }
        mLegacyListFilter = null;
        ProgramList list = new ProgramList();
        mCallback.setProgramListObserver(list, () -> {
            try {
                mTuner.stopProgramListUpdates();
            } catch (IllegalStateException ex) {
            // it's fine to not stop updates if tuner is already closed
            } catch (RemoteException ex) {
                Log.e(TAG, ""Couldn't stop program list updates"", ex);
            }
        });
        try {
            mTuner.startProgramListUpdates(filter);
        } catch (UnsupportedOperationException ex) {
            Log.i(TAG, ""Program list is not supported with this hardware"");
            return null;
        } catch (RemoteException ex) {
            mCallback.setProgramListObserver(null, () -> {
            });
            throw new RuntimeException(""service died"", ex);
        }
        return list;
    }
}",1,,,-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"2,4",2,"There is an addition of a catch block for `IllegalStateException` within the lambda expression passed to `mCallback.setProgramListObserver` and no other statement changes, so the change type is 2 for exception handling statement changed and 4 for other statement changed (the addition of a catch block within the lambda expression).","The addition of a new exception handling block for `IllegalStateException` will change how the program behaves when this exception is thrown (it will be caught and handled instead of propagating out of the method). This change can potentially prevent an exception from being thrown. Thus, the CI type is 2 for potential different exception handling."
211,<android.app.AlarmManager: void cancel(OnAlarmListener)>,29,30,<android.app.AlarmManager: void cancel(OnAlarmListener)>,<android.app.AlarmManager: void cancel(OnAlarmListener)>,0,"{
    if (listener == null) {
        throw new NullPointerException(""cancel() called with a null OnAlarmListener"");
    }
    ListenerWrapper wrapper = null;
    synchronized (AlarmManager.class) {
        if (sWrappers != null) {
            wrapper = sWrappers.get(listener);
        }
    }
    if (wrapper == null) {
        Log.w(TAG, ""Unrecognized alarm listener "" + listener);
        return;
    }
    wrapper.cancel();
}","{
    if (listener == null) {
        throw new NullPointerException(""cancel() called with a null OnAlarmListener"");
    }
    ListenerWrapper wrapper = null;
    synchronized (AlarmManager.class) {
        if (sWrappers != null) {
            final WeakReference<ListenerWrapper> weakRef = sWrappers.get(listener);
            if (weakRef != null) {
                wrapper = weakRef.get();
            }
        }
    }
    if (wrapper == null) {
        Log.w(TAG, ""Unrecognized alarm listener "" + listener);
        return;
    }
    wrapper.cancel();
}",1,"/**
 * Remove any alarm scheduled to be delivered to the given {@link OnAlarmListener}.
 *
 * @param listener OnAlarmListener instance that is the target of a currently-set alarm.
 */
","/**
 * Remove any alarm scheduled to be delivered to the given {@link OnAlarmListener}.
 *
 * @param listener OnAlarmListener instance that is the target of a currently-set alarm.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code has been updated to include a WeakReference for the ListenerWrapper instead of a direct reference, and this change is found within the synchronized block. Thus the code change type is 4,5, as this affects the internal implementation of how the listener is managed without explicitly changing the control flow, return statements, or exception handling.","Since the change only affects the internal reference type and does not alter the API's external behavior, contract, expected return types, or exception handling, no Compatibility Issue is expected to arise from it. All clients using this API should continue to function correctly without any change in behavior, assuming the underlying semantics of canceling an alarm has not changed."
212,<android.app.WallpaperManager: Drawable peekFastDrawable()>,29,30,<android.app.WallpaperManager: Drawable peekFastDrawable()>,<android.app.WallpaperManager: Drawable peekFastDrawable()>,0,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}","{
    final ColorManagementProxy cmProxy = getColorManagementProxy();
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM, cmProxy);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}",1,"/**
 * Like {@link #getFastDrawable()}, but if there is no wallpaper set,
 * a null pointer is returned.
 *
 * @return Returns an optimized Drawable object that will draw the
 * wallpaper or a null pointer if these is none.
 */
","/**
 * Like {@link #getFastDrawable()}, but if there is no wallpaper set,
 * a null pointer is returned.
 *
 * @return Returns an optimized Drawable object that will draw the
 * wallpaper or a null pointer if these is none.
 */
",-1,[@RequiresPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)],[@RequiresPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)],-1,-1,-1,-1,-1,-1,5,0,"The implementation changed with the addition of a new local variable, 'cmProxy', which is being passed as an additional argument to the method 'peekWallpaperBitmap'. The return statement values ('return new FastBitmapDrawable(bm)' and 'return null') have not been modified. This is a change in a dependent API because it involves an alteration in the number of parameters for the 'peekWallpaperBitmap' method call. Therefore, the code change type is 5.","Even though there's a dependent API change, the behavior of the 'peekFastDrawable' method itself is not directly modified by the changes observed in the implementation since the additional argument 'cmProxy' doesn't affect what the 'peekFastDrawable' method returns or the exceptions it could raise. The new argument 'cmProxy' presumably modifies the behavior of 'peekWallpaperBitmap', but as there is no change in the signature or control flow of 'peekFastDrawable', there is no compatibility issue. Hence, the CI type is 0."
213,<android.content.ContentProviderOperation.Builder: ContentProviderOperation build()>,29,30,<android.content.ContentProviderOperation.Builder: ContentProviderOperation build()>,<android.content.ContentProviderOperation.Builder: ContentProviderOperation build()>,0,"{
    if (mType == TYPE_UPDATE) {
        if ((mValues == null || mValues.isEmpty()) && (mValuesBackReferences == null || mValuesBackReferences.isEmpty())) {
            throw new IllegalArgumentException(""Empty values"");
        }
    }
    if (mType == TYPE_ASSERT) {
        if ((mValues == null || mValues.isEmpty()) && (mValuesBackReferences == null || mValuesBackReferences.isEmpty()) && (mExpectedCount == null)) {
            throw new IllegalArgumentException(""Empty values"");
        }
    }
    return new ContentProviderOperation(this);
}","{
    if (mType == TYPE_UPDATE) {
        if ((mValues == null || mValues.isEmpty())) {
            throw new IllegalArgumentException(""Empty values"");
        }
    }
    if (mType == TYPE_ASSERT) {
        if ((mValues == null || mValues.isEmpty()) && (mExpectedCount == null)) {
            throw new IllegalArgumentException(""Empty values"");
        }
    }
    return new ContentProviderOperation(this);
}",1,"/**
 * Create a ContentProviderOperation from this {@link Builder}.
 */
","/**
 * Create a ContentProviderOperation from this {@link Builder}.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,3,2,"The condition in the if statement under TYPE_UPDATE and TYPE_ASSERT has been simplified by removing checks for mValuesBackReferences. This is a control dependency change, hence the code change type is 3.","This change affects the exception throwing behavior of the method. In the early version, an IllegalArgumentException is thrown if both mValues and mValuesBackReferences are null or empty. In the late version, the exception is thrown if just mValues is null or empty, regardless of the state of mValuesBackReferences. Since the conditions under which an exception is thrown have been altered, this could potentially lead to different exceptions being thrown for the same input, therefore, the CI type is 2."
214,"<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>",29,30,"<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>","<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>",0,"{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        GraphicBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            ColorSpace colorSpace = null;
            int colorSpaceId = bundle.getInt(BUNDLE_SNAPSHOT_COLOR_SPACE, 0);
            if (colorSpaceId >= 0 && colorSpaceId < ColorSpace.Named.values().length) {
                colorSpace = ColorSpace.get(ColorSpace.Named.values()[colorSpaceId]);
            }
            bitmap = Bitmap.wrapHardwareBuffer(HardwareBuffer.createFromGraphicBuffer(buffer), colorSpace);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}","{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        HardwareBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_HARDWARE_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            ColorSpace colorSpace = null;
            int colorSpaceId = bundle.getInt(BUNDLE_SNAPSHOT_COLOR_SPACE, 0);
            if (colorSpaceId >= 0 && colorSpaceId < ColorSpace.Named.values().length) {
                colorSpace = ColorSpace.get(ColorSpace.Named.values()[colorSpaceId]);
            }
            bitmap = Bitmap.wrapHardwareBuffer(buffer, colorSpace);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}",1,"/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */
","/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The type of the object retrieved from the bundle by `getParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER)` changed to `HardwareBuffer` from `GraphicBuffer`. Also, the construction method of `HardwareBuffer` called `createFromGraphicBuffer(buffer)` has been removed, and `HardwareBuffer buffer` is now directly retrieved from the `Bundle` and used in `Bitmap.wrapHardwareBuffer(buffer, colorSpace)`. This change does not directly affect the control statements, but is an ""other statement changed"" because the way buffer is obtained and used has changed, and a ""dependent API changed"" as it now depends on different API behavior (HardwareBuffer instead of GraphicBuffer), so the code change type is 4,5.","As the creation of the Bitmap has changed due to the different underlying buffer type, this could lead a different `bitmap` object being created and therefore a different `view` object being returned, which is a potential return of a different value, so the CI type is 1."
215,<android.net.NetworkCapabilities: boolean equals(Object)>,29,30,<android.net.NetworkCapabilities: boolean equals(Object)>,<android.net.NetworkCapabilities: boolean equals(Object)>,0,"{
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsTransportInfo(that) && equalsUids(that) && equalsSSID(that));
}","{
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsTransportInfo(that) && equalsUids(that) && equalsSSID(that) && equalsPrivateDnsBroken(that) && equalsRequestor(that) && equalsAdministratorUids(that);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Additional boolean expressions (equalsPrivateDnsBroken(that), equalsRequestor(that), equalsAdministratorUids(that)) are added in the return statement, and this changes the compound condition logic, so the code change type is 1 (Return statement changed), and 4 (Other statement changed).","Due to the additional conditions in the return statement, the API could potentially return a different value when comparing NetworkCapabilities objects in different scenarios, thus the CI type is 1 (Compatibility Issue caused by potential different return values)."
216,"<android.util.Half: boolean less(short,short)>",29,30,"<android.util.Half: boolean less(short,short)>","<android.util.Half: boolean less(short,short)>",0,"{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) < ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff);
}","{
    return FP16.less(x, y);
}",1,"/**
 * Returns true if the first half-precision float value is less (smaller
 * toward negative infinity) than the second half-precision float value.
 * If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is less than y, false otherwise
 */
","/**
 * Returns true if the first half-precision float value is less (smaller
 * toward negative infinity) than the second half-precision float value.
 * If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is less than y, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The entire body of the less method has been replaced with a call to an external static method FP16.less(x, y), indicating a dependent API change, so the change type is 5.","There is no compatibility issue as long as the external static method FP16.less(x, y) performs the exact same operation and returns the same results as the original inlined code. The change does not inherently indicate a difference in behavior, so the CI type is 0."
217,<android.app.Notification.BubbleMetadata.Builder: Builder setIntent(PendingIntent)>,29,30,<android.app.Notification.BubbleMetadata.Builder: Builder setIntent(PendingIntent)>,<android.app.Notification.BubbleMetadata.Builder: Builder setIntent(PendingIntent)>,0,"{
    if (intent == null) {
        throw new IllegalArgumentException(""Bubble requires non-null pending intent"");
    }
    mPendingIntent = intent;
    return this;
}","{
    if (mShortcutId != null) {
        throw new IllegalStateException(""Created as a shortcut bubble, cannot set a "" + ""PendingIntent. Consider using "" + ""BubbleMetadata.Builder(PendingIntent,Icon) instead."");
    }
    if (intent == null) {
        throw new NullPointerException(""Bubble requires non-null pending intent"");
    }
    mPendingIntent = intent;
    return this;
}",1,"/**
 * Sets the intent that will be used when the bubble is expanded. This will display the
 * app content in a floating window over the existing foreground activity.
 *
 * <p>An intent is required.</p>
 *
 * @throws IllegalArgumentException if intent is null
 */
","/**
 * Sets the intent for the bubble.
 *
 * <p>The intent that will be used when the bubble is expanded. This will display the
 * app content in a floating window over the existing foreground activity. The intent
 * should point to a resizable activity. </p>
 *
 * @throws NullPointerException  if intent is null.
 * @throws IllegalStateException if this builder was created via
 * {@link Builder#Builder(String)}.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"2,3,5","1,2","There's a new condition for throwing an exception (if mShortcutId != null) related to IllegalStateException, and the type of exception that is thrown for a null intent parameter has changed from IllegalArgumentException to NullPointerException. The change in exception type is classified as 2, the new condition check as 3, and because the new exception relies on a newly introduced member variable (mShortcutId), the dependent API has changed, which is classified as 5.","There's a potential Compatibility Issue due to both return statement and exception handling changes. The new conditional statement could potentially throw an IllegalStateException where it wouldn't have in the early version which is a new behavior (CI type 2), and changing the type of exception thrown from IllegalArgumentException to NullPointerException when intent is null also changes the behavior of the API, leading to a different exception being thrown in the same scenario (CI type 1 and 2)."
218,<android.app.ContextImpl: Object getSystemService(String)>,29,30,<android.app.ContextImpl: Object getSystemService(String)>,<android.app.ContextImpl: Object getSystemService(String)>,0,"{
    return SystemServiceRegistry.getSystemService(this, name);
}","{
    if (vmIncorrectContextUseEnabled()) {
        // We may override this API from outer context.
        final boolean isUiContext = isUiContext() || isOuterUiContext();
        // Check incorrect Context usage.
        if (isUiComponent(name) && !isUiContext) {
            final String errorMessage = ""Tried to access visual service "" + SystemServiceRegistry.getSystemServiceClassName(name) + "" from a non-visual Context:"" + getOuterContext();
            final String message = ""Visual services, such as WindowManager, WallpaperService "" + ""or LayoutInflater should be accessed from Activity or other visual "" + ""Context. Use an Activity or a Context created with "" + ""Context#createWindowContext(int, Bundle), which are adjusted to "" + ""the configuration and visual bounds of an area on screen."";
            final Exception exception = new IllegalAccessException(errorMessage);
            StrictMode.onIncorrectContextUsed(message, exception);
            Log.e(TAG, errorMessage + "" "" + message, exception);
        }
    }
    return SystemServiceRegistry.getSystemService(this, name);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5","1,2","New control structures and a call to a possibly new or modified API 'vmIncorrectContextUseEnabled()' have been introduced. Moreover, the code adds a check for incorrect context usage with additional logging and calling `StrictMode.onIncorrectContextUsed(message, exception)`. The code change type is 3,5.","The newly introduced check may lead to logging an error and notifying `StrictMode` about incorrect context usage when conditions are met. Although it does not directly change the return value of the method, it logs an error and triggers strict mode violation handling mechanisms, which is a form of side effect that can be observed externally. This can be seen as a different behavior, and thus a Compatibility Issue is identified of type 1 due to potentially different return outcomes (in terms of side effects) and type 2 due to different exception handling (side effects in the context of strict mode triggering)."
219,<android.widget.TextView.TextAppearanceAttributes: String toString()>,29,30,<android.widget.TextView.TextAppearanceAttributes: String toString()>,<android.widget.TextView.TextAppearanceAttributes: String toString()>,0,"{
    return ""TextAppearanceAttributes {\n"" + ""    mTextColorHighlight:"" + mTextColorHighlight + ""\n"" + ""    mTextColor:"" + mTextColor + ""\n"" + ""    mTextColorHint:"" + mTextColorHint + ""\n"" + ""    mTextColorLink:"" + mTextColorLink + ""\n"" + ""    mTextSize:"" + mTextSize + ""\n"" + ""    mTextLocales:"" + mTextLocales + ""\n"" + ""    mFontFamily:"" + mFontFamily + ""\n"" + ""    mFontTypeface:"" + mFontTypeface + ""\n"" + ""    mFontFamilyExplicit:"" + mFontFamilyExplicit + ""\n"" + ""    mTypefaceIndex:"" + mTypefaceIndex + ""\n"" + ""    mTextStyle:"" + mTextStyle + ""\n"" + ""    mFontWeight:"" + mFontWeight + ""\n"" + ""    mAllCaps:"" + mAllCaps + ""\n"" + ""    mShadowColor:"" + mShadowColor + ""\n"" + ""    mShadowDx:"" + mShadowDx + ""\n"" + ""    mShadowDy:"" + mShadowDy + ""\n"" + ""    mShadowRadius:"" + mShadowRadius + ""\n"" + ""    mHasElegant:"" + mHasElegant + ""\n"" + ""    mElegant:"" + mElegant + ""\n"" + ""    mHasFallbackLineSpacing:"" + mHasFallbackLineSpacing + ""\n"" + ""    mFallbackLineSpacing:"" + mFallbackLineSpacing + ""\n"" + ""    mHasLetterSpacing:"" + mHasLetterSpacing + ""\n"" + ""    mLetterSpacing:"" + mLetterSpacing + ""\n"" + ""    mFontFeatureSettings:"" + mFontFeatureSettings + ""\n"" + ""    mFontVariationSettings:"" + mFontVariationSettings + ""\n"" + ""}"";
}","{
    return ""TextAppearanceAttributes {\n"" + ""    mTextColorHighlight:"" + mTextColorHighlight + ""\n"" + ""    mTextColor:"" + mTextColor + ""\n"" + ""    mTextColorHint:"" + mTextColorHint + ""\n"" + ""    mTextColorLink:"" + mTextColorLink + ""\n"" + ""    mTextSize:"" + mTextSize + ""\n"" + ""    mTextSizeUnit:"" + mTextSizeUnit + ""\n"" + ""    mTextLocales:"" + mTextLocales + ""\n"" + ""    mFontFamily:"" + mFontFamily + ""\n"" + ""    mFontTypeface:"" + mFontTypeface + ""\n"" + ""    mFontFamilyExplicit:"" + mFontFamilyExplicit + ""\n"" + ""    mTypefaceIndex:"" + mTypefaceIndex + ""\n"" + ""    mTextStyle:"" + mTextStyle + ""\n"" + ""    mFontWeight:"" + mFontWeight + ""\n"" + ""    mAllCaps:"" + mAllCaps + ""\n"" + ""    mShadowColor:"" + mShadowColor + ""\n"" + ""    mShadowDx:"" + mShadowDx + ""\n"" + ""    mShadowDy:"" + mShadowDy + ""\n"" + ""    mShadowRadius:"" + mShadowRadius + ""\n"" + ""    mHasElegant:"" + mHasElegant + ""\n"" + ""    mElegant:"" + mElegant + ""\n"" + ""    mHasFallbackLineSpacing:"" + mHasFallbackLineSpacing + ""\n"" + ""    mFallbackLineSpacing:"" + mFallbackLineSpacing + ""\n"" + ""    mHasLetterSpacing:"" + mHasLetterSpacing + ""\n"" + ""    mLetterSpacing:"" + mLetterSpacing + ""\n"" + ""    mFontFeatureSettings:"" + mFontFeatureSettings + ""\n"" + ""    mFontVariationSettings:"" + mFontVariationSettings + ""\n"" + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The method's implementation has been altered by the addition of `+ ""    mTextSizeUnit:"" + mTextSizeUnit + ""\n""` to the string that is being returned, which is considered an 'Other statement changed'.",The addition of the new field `mTextSizeUnit` in the method's return value (which is a string representation of the instance's state) means that the API will potentially return a different value than before; hence it is a Compatibility Issue of the type that affects return values.
220,"<android.app.AppOpsManager: int startOpNoThrow(String,int,String)>",29,30,"<android.app.AppOpsManager: int startOpNoThrow(String,int,String)>","<android.app.AppOpsManager: int startOpNoThrow(String,int,String)>",0,"{
    return startOpNoThrow(strOpToOp(op), uid, packageName);
}","{
    return startOpNoThrow(op, uid, packageName, null, null);
}",1,"/**
 * Like {@link #startOp} but instead of throwing a {@link SecurityException} it
 * returns {@link #MODE_ERRORED}.
 */
","/**
 * @deprecated use {@link #startOpNoThrow(String, int, String, String, String)} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The method signature of 'startOpNoThrow' called within the current method has changed, accepting different parameters (added null values) which indicates that not only return statement but also dependent API has changed, hence the change type is 1,5.","The change in dependent API parameters can lead to a different return value as the behavior of 'startOpNoThrow' could vary due to the new parameters being passed. Therefore, there's a Compatibility Issue of type 1."
221,<android.util.Half: String toHexString(short)>,29,30,<android.util.Half: String toHexString(short)>,<android.util.Half: String toHexString(short)>,0,"{
    StringBuilder o = new StringBuilder();
    int bits = h & 0xffff;
    int s = (bits >>> FP16_SIGN_SHIFT);
    int e = (bits >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK;
    int m = (bits) & FP16_SIGNIFICAND_MASK;
    if (e == 0x1f) {
        // Infinite or NaN
        if (m == 0) {
            if (s != 0)
                o.append('-');
            o.append(""Infinity"");
        } else {
            o.append(""NaN"");
        }
    } else {
        if (s == 1)
            o.append('-');
        if (e == 0) {
            if (m == 0) {
                o.append(""0x0.0p0"");
            } else {
                o.append(""0x0."");
                String significand = Integer.toHexString(m);
                o.append(significand.replaceFirst(""0{2,}$"", """"));
                o.append(""p-14"");
            }
        } else {
            o.append(""0x1."");
            String significand = Integer.toHexString(m);
            o.append(significand.replaceFirst(""0{2,}$"", """"));
            o.append('p');
            o.append(Integer.toString(e - FP16_EXPONENT_BIAS));
        }
    }
    return o.toString();
}","{
    return FP16.toHexString(h);
}",1,"/**
 * <p>Returns a hexadecimal string representation of the specified half-precision
 * float value. If the value is a NaN, the result is <code>""NaN""</code>,
 * otherwise the result follows this format:</p>
 * <ul>
 * <li>If the sign is positive, no sign character appears in the result</li>
 * <li>If the sign is negative, the first character is <code>'-'</code></li>
 * <li>If the value is inifinity, the string is <code>""Infinity""</code></li>
 * <li>If the value is 0, the string is <code>""0x0.0p0""</code></li>
 * <li>If the value has a normalized representation, the exponent and
 * significand are represented in the string in two fields. The significand
 * starts with <code>""0x1.""</code> followed by its lowercase hexadecimal
 * representation. Trailing zeroes are removed unless all digits are 0, then
 * a single zero is used. The significand representation is followed by the
 * exponent, represented by <code>""p""</code>, itself followed by a decimal
 * string of the unbiased exponent</li>
 * <li>If the value has a subnormal representation, the significand starts
 * with <code>""0x0.""</code> followed by its lowercase hexadecimal
 * representation. Trailing zeroes are removed unless all digits are 0, then
 * a single zero is used. The significand representation is followed by the
 * exponent, represented by <code>""p-14""</code></li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return A hexadecimal string representation of the specified value
 */
","/**
 * <p>Returns a hexadecimal string representation of the specified half-precision
 * float value. If the value is a NaN, the result is <code>""NaN""</code>,
 * otherwise the result follows this format:</p>
 * <ul>
 * <li>If the sign is positive, no sign character appears in the result</li>
 * <li>If the sign is negative, the first character is <code>'-'</code></li>
 * <li>If the value is inifinity, the string is <code>""Infinity""</code></li>
 * <li>If the value is 0, the string is <code>""0x0.0p0""</code></li>
 * <li>If the value has a normalized representation, the exponent and
 * significand are represented in the string in two fields. The significand
 * starts with <code>""0x1.""</code> followed by its lowercase hexadecimal
 * representation. Trailing zeroes are removed unless all digits are 0, then
 * a single zero is used. The significand representation is followed by the
 * exponent, represented by <code>""p""</code>, itself followed by a decimal
 * string of the unbiased exponent</li>
 * <li>If the value has a subnormal representation, the significand starts
 * with <code>""0x0.""</code> followed by its lowercase hexadecimal
 * representation. Trailing zeroes are removed unless all digits are 0, then
 * a single zero is used. The significand representation is followed by the
 * exponent, represented by <code>""p-14""</code></li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return A hexadecimal string representation of the specified value
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The entire implementation of the method has changed to a simple call to another method: FP16.toHexString(h), which represents a change in a dependent API, so the code change type is 5.","Although the implementation of toHexString(short) has changed significantly by delegating the conversion to the FP16.toHexString(h) method, there is no inherent compatibility issue as long as the FP16.toHexString(h) maintains the same behavior as the original code. Therefore, we assume no CI will arise, and the CI type is 0."
222,"<android.app.ActivityOptions: ActivityOptions makeCustomAnimation(Context,int,int)>",29,30,"<android.app.ActivityOptions: ActivityOptions makeCustomAnimation(Context,int,int)>","<android.app.ActivityOptions: ActivityOptions makeCustomAnimation(Context,int,int)>",0,"{
    return makeCustomAnimation(context, enterResId, exitResId, null, null);
}","{
    return makeCustomAnimation(context, enterResId, exitResId, null, null, null);
}",1,"/**
 * Create an ActivityOptions specifying a custom animation to run when
 * the activity is displayed.
 *
 * @param context Who is defining this.  This is the application that the
 * animation resources will be loaded from.
 * @param enterResId A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitResId A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 */
","/**
 * Create an ActivityOptions specifying a custom animation to run when
 * the activity is displayed.
 *
 * @param context Who is defining this.  This is the application that the
 * animation resources will be loaded from.
 * @param enterResId A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitResId A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The internal call within the method changed, passing additional `null` arguments to the `makeCustomAnimation` method. This indicates that the dependent API `makeCustomAnimation` has likely changed to accept more parameters. Therefore, the code change type is 5.","This change does not lead to a difference in behavior from the perspective of the caller of `makeCustomAnimation(Context,int,int)` since the method still returns the same type of `ActivityOptions` object and the added `null` argument does not alter the returned value or the exceptions thrown by this method. So there is no Compatibility Issue, and the CI type is 0."
223,"<android.util.Half: short max(short,short)>",29,30,"<android.util.Half: short max(short,short)>","<android.util.Half: short max(short,short)>",0,"{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return NaN;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return NaN;
    if ((x & FP16_COMBINED) == 0 && (y & FP16_COMBINED) == 0) {
        return (x & FP16_SIGN_MASK) != 0 ? y : x;
    }
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) > ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff) ? x : y;
}","{
    return FP16.max(x, y);
}",1,"/**
 * Returns the larger of two half-precision float values (the value closest
 * to positive infinity). Special values are handled in the following ways:
 * <ul>
 * <li>If either value is NaN, the result is NaN</li>
 * <li>{@link #POSITIVE_ZERO} is greater than {@link #NEGATIVE_ZERO}</li>
 * </ul>
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return The larger of the two specified half-precision values
 */
","/**
 * Returns the larger of two half-precision float values (the value closest
 * to positive infinity). Special values are handled in the following ways:
 * <ul>
 * <li>If either value is NaN, the result is NaN</li>
 * <li>{@link #POSITIVE_ZERO} is greater than {@link #NEGATIVE_ZERO}</li>
 * </ul>
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return The larger of the two specified half-precision values
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the early implementation performs several checks and calculations, while in the late implementation, it simply calls FP16.max(x, y). The dependent API FP16.max(x, y) has been introduced, and this changes the control flow and the potential output of the operation, so the code change types are 1,5.","The change in the method of comparing and returning the maximum value could potentially lead to different return values due to the difference in implementation details between the early version's inline logic and the late version's call to FP16.max(x, y). This constitutes a CI with respect to potential different return values, thus the CI type is 1."
226,"<android.app.slice.Slice.Builder: Builder addBundle(Bundle,String,List<String>)>",29,30,"<android.app.slice.Slice.Builder: Builder addBundle(Bundle,String,List<String>)>","<android.app.slice.Slice.Builder: Builder addBundle(Bundle,String,List<String>)>",0,"{
    Preconditions.checkNotNull(bundle);
    mItems.add(new SliceItem(bundle, SliceItem.FORMAT_BUNDLE, subType, hints));
    return this;
}","{
    Objects.requireNonNull(bundle);
    mItems.add(new SliceItem(bundle, SliceItem.FORMAT_BUNDLE, subType, hints));
    return this;
}",1,"/**
 * Add a bundle to the slice being constructed.
 * <p>Expected to be used for support library extension, should not be used for general
 * development
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
","/**
 * Add a bundle to the slice being constructed.
 * <p>Expected to be used for support library extension, should not be used for general
 * development
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change made is a replacement of one null check utility method with another (Preconditions.checkNotNull() to Objects.requireNonNull()), which behave the same way. The change type is 4.",There is no Compatibility Issue since both versions of the method are checking for null in the same way and will throw a NullPointerException if 'bundle' is null. There is no change in functionality or behavior with regards to how the method operates or returns values.
228,<android.accessibilityservice.AccessibilityService: AccessibilityButtonController getAccessibilityButtonController()>,29,30,<android.accessibilityservice.AccessibilityService: AccessibilityButtonController getAccessibilityButtonController()>,<android.accessibilityservice.AccessibilityService: AccessibilityButtonController getAccessibilityButtonController()>,0,"{
    synchronized (mLock) {
        if (mAccessibilityButtonController == null) {
            mAccessibilityButtonController = new AccessibilityButtonController(AccessibilityInteractionClient.getInstance().getConnection(mConnectionId));
        }
        return mAccessibilityButtonController;
    }
}","{
    return getAccessibilityButtonController(Display.DEFAULT_DISPLAY);
}",1,"/**
 * Returns the controller for the accessibility button within the system's navigation area.
 * This instance may be used to query the accessibility button's state and register listeners
 * for interactions with and state changes for the accessibility button when
 * {@link AccessibilityServiceInfo#FLAG_REQUEST_ACCESSIBILITY_BUTTON} is set.
 * <p>
 * <strong>Note:</strong> Not all devices are capable of displaying the accessibility button
 * within a navigation area, and as such, use of this class should be considered only as an
 * optional feature or shortcut on supported device implementations.
 * </p>
 *
 * @return the accessibility button controller for this {@link AccessibilityService}
 */
","/**
 * Returns the controller for the accessibility button within the system's navigation area.
 * This instance may be used to query the accessibility button's state and register listeners
 * for interactions with and state changes for the accessibility button when
 * {@link AccessibilityServiceInfo#FLAG_REQUEST_ACCESSIBILITY_BUTTON} is set.
 * <p>
 * <strong>Note:</strong> Not all devices are capable of displaying the accessibility button
 * within a navigation area, and as such, use of this class should be considered only as an
 * optional feature or shortcut on supported device implementations.
 * </p>
 *
 * @return the accessibility button controller for this {@link AccessibilityService}
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed to call a different method getAccessibilityButtonController(Display.DEFAULT_DISPLAY), which is a dependent API. Therefore, this is categorized as code change type 5, Dependent API changed.","There is no Compatibility Issue because the type of the returned object has not changed, and there is no change in the exception handling, so the CI type is 0, No Compatibility Issue."
229,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue)>",29,30,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue)>","<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue)>",0,"{
    throwIfDestroyed();
    setLifeTheUniverseAndEverything(id, value, null, null);
    return this;
}","{
    throwIfDestroyed();
    setLifeTheUniverseAndEverything(id, value, null, null, null);
    return this;
}",1,"/**
 * Sets the value of a field.
 *
 * <b>Note:</b> Prior to Android {@link android.os.Build.VERSION_CODES#P}, this method would
 * throw an {@link IllegalStateException} if this builder was constructed without a
 * {@link RemoteViews presentation}. Android {@link android.os.Build.VERSION_CODES#P} and
 * higher removed this restriction because datasets used as an
 * {@link android.view.autofill.AutofillManager#EXTRA_AUTHENTICATION_RESULT
 * authentication result} do not need a presentation. But if you don't set the presentation
 * in the constructor in a dataset that is meant to be shown to the user, the autofill UI
 * for this field will not be displayed.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the {@code value} parameter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @return this builder.
 */
","/**
 * Sets the value of a field.
 *
 * <b>Note:</b> Prior to Android {@link android.os.Build.VERSION_CODES#P}, this method would
 * throw an {@link IllegalStateException} if this builder was constructed without a
 * {@link RemoteViews presentation}. Android {@link android.os.Build.VERSION_CODES#P} and
 * higher removed this restriction because datasets used as an
 * {@link android.view.autofill.AutofillManager#EXTRA_AUTHENTICATION_RESULT
 * authentication result} do not need a presentation. But if you don't set the presentation
 * in the constructor in a dataset that is meant to be shown to the user, the autofill UI
 * for this field will not be displayed.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the {@code value} parameter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed where one more parameter (null) is added to the method setLifeTheUniverseAndEverything. So, there is a change in the dependent API used within the method, which is category 5.","Although there's a change in the dependent API, this does not necessarily introduce a compatibility issue since the additional argument is simply null, which shouldn't alter the behavior of the method being called or change what is returned by the setValue method itself. Hence, there is no compatibility issue (CI code 0)."
230,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,29,30,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,0,"{
    throwIfParentInstance(""getCameraDisabled"");
    return getCameraDisabled(admin, myUserId());
}","{
    return getCameraDisabled(admin, myUserId());
}",1,"/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the calling admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
","/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the calling admin, if specified, or all admins.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance,
 * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be
 * the profile owner of an organization-owned managed profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method implementation has changed by removing the call to throwIfParentInstance(""getCameraDisabled""). This is classified as an other statement change, so the code change type is 4.","Removing the call to throwIfParentInstance does not affect the return value or the exception that this method may throw. The method still returns the result of getCameraDisabled(admin, myUserId()), and any exception that would be thrown by this method would still be thrown. Hence, there is no Compatibility Issue, and the CI type is 0."
231,<android.content.ContentResolver: InputStream openInputStream(Uri)>,29,30,<android.content.ContentResolver: InputStream openInputStream(Uri)>,<android.content.ContentResolver: InputStream openInputStream(Uri)>,0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        // Note: left here to avoid breaking compatibility.  May be removed
        // with sufficient testing.
        OpenResourceIdResult r = getResourceId(uri);
        try {
            InputStream stream = r.r.openRawResource(r.id);
            return stream;
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        // with sufficient testing.
        return new FileInputStream(uri.getPath());
    } else {
        AssetFileDescriptor fd = openAssetFileDescriptor(uri, ""r"", null);
        try {
            return fd != null ? fd.createInputStream() : null;
        } catch (IOException e) {
            throw new FileNotFoundException(""Unable to create stream"");
        }
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        // Note: left here to avoid breaking compatibility.  May be removed
        // with sufficient testing.
        OpenResourceIdResult r = getResourceId(uri);
        try {
            InputStream stream = r.r.openRawResource(r.id);
            return stream;
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        // with sufficient testing.
        return new FileInputStream(uri.getPath());
    } else {
        AssetFileDescriptor fd = openAssetFileDescriptor(uri, ""r"", null);
        try {
            return fd != null ? fd.createInputStream() : null;
        } catch (IOException e) {
            throw new FileNotFoundException(""Unable to create stream"");
        }
    }
}",1,"/**
 * Open a stream on to the content associated with a content URI.  If there
 * is no data associated with the URI, FileNotFoundException is thrown.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI.
 * @return InputStream
 * @throws FileNotFoundException if the provided URI could not be opened.
 * @see #openAssetFileDescriptor(Uri, String)
 */
","/**
 * Open a stream on to the content associated with a content URI.  If there
 * is no data associated with the URI, FileNotFoundException is thrown.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI.
 * @return InputStream or {@code null} if the provider recently crashed.
 * @throws FileNotFoundException if the provided URI could not be opened.
 * @see #openAssetFileDescriptor(Uri, String)
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,0,0,"There is no change in the implementation of the code; only the method Preconditions.checkNotNull() was replaced by Objects.requireNonNull() which are equivalent checks, hence there's no change affecting the behavior of the API.","As there is no change that impacts the behavior of the API, there would be no Compatibility Issue."
232,<android.os.image.DynamicSystemManager.Session: boolean commit()>,29,30,<android.os.image.DynamicSystemManager.Session: boolean commit()>,<android.os.image.DynamicSystemManager.Session: boolean commit()>,0,"{
    try {
        return mService.commit();
    } catch (RemoteException e) {
        throw new RuntimeException(e.toString());
    }
}","{
    try {
        return mService.setEnable(true, true);
    } catch (RemoteException e) {
        throw new RuntimeException(e.toString());
    }
}",1,"/**
 * Finish write and make device to boot into the it after reboot.
 *
 * @return {@code true} if the call succeeds. {@code false} if there is any native runtime
 * error.
 */
","/**
 * Finish write and make device to boot into the it after reboot.
 *
 * @return {@code true} if the call succeeds. {@code false} if there is any native runtime
 * error.
 */
",-1,[@RequiresPermission(android.Manifest.permission.MANAGE_DYNAMIC_SYSTEM)],[@RequiresPermission(android.Manifest.permission.MANAGE_DYNAMIC_SYSTEM)],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called within the return statement has changed from mService.commit() to mService.setEnable(true, true), and the return type of the method being called might have changed. Additionally, the method name and parameters inside the return statement have also changed, indicating a change in the dependent API. Therefore, the code change types are 1,5.","The replacement of mService.commit() with mService.setEnable(true, true) indicates that the return value of the method could be different; thus, the change creates a potential Compatibility Issue due to different return values or types. The CI type is 1."
233,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",29,30,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        UriGrantsManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    try {
        UriGrantsManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement changed from Preconditions.checkNotNull(uri, ""uri"") to Objects.requireNonNull(uri, ""uri""), but both accomplish the same task of checking for a non-null 'uri'. Thus, despite the change in the statement, no difference in the behavior or output is expected. The change type is 4 for Other statement changed.","There is no Compatibility Issue because the change from Preconditions.checkNotNull to Objects.requireNonNull does not change any behavior or the output of the method. Both methods will throw a NullPointerException if 'uri' is null with the same message, and if 'uri' is not null, the method's behavior remains unchanged."
234,<android.net.LinkProperties: boolean equals(Object)>,29,30,<android.net.LinkProperties: boolean equals(Object)>,<android.net.LinkProperties: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (!(obj instanceof LinkProperties))
        return false;
    LinkProperties target = (LinkProperties) obj;
    /*
         * This method does not check that stacked interfaces are equal, because
         * stacked interfaces are not so much a property of the link as a
         * description of connections between links.
         */
    return isIdenticalInterfaceName(target) && isIdenticalAddresses(target) && isIdenticalDnses(target) && isIdenticalPrivateDns(target) && isIdenticalValidatedPrivateDnses(target) && isIdenticalPcscfs(target) && isIdenticalRoutes(target) && isIdenticalHttpProxy(target) && isIdenticalStackedLinks(target) && isIdenticalMtu(target) && isIdenticalTcpBufferSizes(target) && isIdenticalNat64Prefix(target);
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof LinkProperties))
        return false;
    LinkProperties target = (LinkProperties) obj;
    /*
         * This method does not check that stacked interfaces are equal, because
         * stacked interfaces are not so much a property of the link as a
         * description of connections between links.
         */
    return isIdenticalInterfaceName(target) && isIdenticalAddresses(target) && isIdenticalDhcpServerAddress(target) && isIdenticalDnses(target) && isIdenticalPrivateDns(target) && isIdenticalValidatedPrivateDnses(target) && isIdenticalPcscfs(target) && isIdenticalRoutes(target) && isIdenticalHttpProxy(target) && isIdenticalStackedLinks(target) && isIdenticalMtu(target) && isIdenticalTcpBufferSizes(target) && isIdenticalNat64Prefix(target) && isIdenticalWakeOnLan(target) && isIdenticalCaptivePortalApiUrl(target) && isIdenticalCaptivePortalData(target);
}",1,"/**
 * Compares this {@code LinkProperties} instance against the target
 * LinkProperties in {@code obj}. Two LinkPropertieses are equal if
 * all their fields are equal in values.
 *
 * For collection fields, such as mDnses, containsAll() is used to check
 * if two collections contains the same elements, independent of order.
 * There are two thoughts regarding containsAll()
 * 1. Duplicated elements. eg, (A, B, B) and (A, A, B) are equal.
 * 2. Worst case performance is O(n^2).
 *
 * @param obj the object to be tested for equality.
 * @return {@code true} if both objects are equal, {@code false} otherwise.
 */
","/**
 * Compares this {@code LinkProperties} instance against the target
 * LinkProperties in {@code obj}. Two LinkPropertieses are equal if
 * all their fields are equal in values.
 *
 * For collection fields, such as mDnses, containsAll() is used to check
 * if two collections contains the same elements, independent of order.
 * There are two thoughts regarding containsAll()
 * 1. Duplicated elements. eg, (A, B, B) and (A, A, B) are equal.
 * 2. Worst case performance is O(n^2).
 *
 * @param obj the object to be tested for equality.
 * @return {@code true} if both objects are equal, {@code false} otherwise.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The logical AND conditions in the return statement have been altered, with the addition of new method calls (isIdenticalDhcpServerAddress, isIdenticalWakeOnLan, isIdenticalCaptivePortalApiUrl, isIdenticalCaptivePortalData) that do not exist in the early version, which includes a control dependency change and a change in dependent APIs, making the change type 1,3,5.","These changes potentially lead to a different return value, since the outcome of the equals method could be different based on the additional checks introduced in the late version. The conditions for equality have been made more stringent with additional properties to compare. Hence, the CI type is 1 as it can return a different value."
236,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,Bundle)>",29,30,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,Bundle)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,Bundle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method called within try block changed from broadcastIntent() to broadcastIntentWithFeature() adding `getAttributionTag()` as a new parameter, so the code change is of type 5 (Dependent API changed).","Since only the internal call to the dependent API has changed without altering the method signature or its exception handling and no other control flow or return statements are affected, there is no Compatibility Issue introduced by this change."
237,"<android.service.voice.VoiceInteractionService: AlwaysOnHotwordDetector createAlwaysOnHotwordDetector(String,Locale,Callback)>",29,30,"<android.service.voice.VoiceInteractionService: AlwaysOnHotwordDetector createAlwaysOnHotwordDetector(String,Locale,Callback)>","<android.service.voice.VoiceInteractionService: AlwaysOnHotwordDetector createAlwaysOnHotwordDetector(String,Locale,Callback)>",0,"{
    if (mSystemService == null) {
        throw new IllegalStateException(""Not available until onReady() is called"");
    }
    synchronized (mLock) {
        // Allow only one concurrent recognition via the APIs.
        safelyShutdownHotwordDetector();
        mHotwordDetector = new AlwaysOnHotwordDetector(keyphrase, locale, callback, mKeyphraseEnrollmentInfo, mInterface, mSystemService);
    }
    return mHotwordDetector;
}","{
    if (mSystemService == null) {
        throw new IllegalStateException(""Not available until onReady() is called"");
    }
    synchronized (mLock) {
        // Allow only one concurrent recognition via the APIs.
        safelyShutdownHotwordDetector();
        mHotwordDetector = new AlwaysOnHotwordDetector(keyphrase, locale, callback, mKeyphraseEnrollmentInfo, mSystemService);
    }
    return mHotwordDetector;
}",1,"/**
 * Creates an {@link AlwaysOnHotwordDetector} for the given keyphrase and locale.
 * This instance must be retained and used by the client.
 * Calling this a second time invalidates the previously created hotword detector
 * which can no longer be used to manage recognition.
 *
 * @param keyphrase The keyphrase that's being used, for example ""Hello Android"".
 * @param locale The locale for which the enrollment needs to be performed.
 * @param callback The callback to notify of detection events.
 * @return An always-on hotword detector for the given keyphrase and locale.
 */
","/**
 * Creates an {@link AlwaysOnHotwordDetector} for the given keyphrase and locale.
 * This instance must be retained and used by the client.
 * Calling this a second time invalidates the previously created hotword detector
 * which can no longer be used to manage recognition.
 *
 * @param keyphrase The keyphrase that's being used, for example ""Hello Android"".
 * @param locale The locale for which the enrollment needs to be performed.
 * @param callback The callback to notify of detection events.
 * @return An always-on hotword detector for the given keyphrase and locale.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API AlwaysOnHotwordDetector's constructor has changed, it has one less parameter in the late version, so the code change type is 5.","There is no compatibility issue arising from this change because the removal of a parameter (mInterface in this case) does not affect the return value. The API returns the same type of 'mHotwordDetector', assuming 'mHotwordDetector' is constructed correctly inside its new constructor. Thus, there is no CI reported as per the definition."
238,"<android.content.IntentFilter: void dump(Printer,String)>",29,30,"<android.content.IntentFilter: void dump(Printer,String)>","<android.content.IntentFilter: void dump(Printer,String)>",0,"{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemeSpecificParts != null) {
        Iterator<PatternMatcher> it = mDataSchemeSpecificParts.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Ssp: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mOrder != 0 || mHasPartialTypes) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mOrder="");
        sb.append(mOrder);
        sb.append("", mHasPartialTypes="");
        sb.append(mHasPartialTypes);
        du.println(sb.toString());
    }
    if (getAutoVerify()) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""AutoVerify="");
        sb.append(getAutoVerify());
        du.println(sb.toString());
    }
}","{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemeSpecificParts != null) {
        Iterator<PatternMatcher> it = mDataSchemeSpecificParts.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Ssp: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mStaticDataTypes != null) {
        Iterator<String> it = mStaticDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""StaticType: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            String dataType = it.next();
            if (hasExactStaticDataType(dataType)) {
                continue;
            }
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(dataType);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mMimeGroups != null) {
        Iterator<String> it = mMimeGroups.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""MimeGroup: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mOrder != 0 || hasPartialTypes()) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mOrder="");
        sb.append(mOrder);
        sb.append("", mHasStaticPartialTypes="");
        sb.append(mHasStaticPartialTypes);
        sb.append("", mHasDynamicPartialTypes="");
        sb.append(mHasDynamicPartialTypes);
        du.println(sb.toString());
    }
    if (getAutoVerify()) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""AutoVerify="");
        sb.append(getAutoVerify());
        du.println(sb.toString());
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
239,<android.net.NetworkCapabilities: int hashCode()>,29,30,<android.net.NetworkCapabilities: int hashCode()>,<android.net.NetworkCapabilities: int hashCode()>,0,"{
    return (int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mUnwantedNetworkCapabilities & 0xFFFFFFFF) * 5) + ((int) (mUnwantedNetworkCapabilities >> 32) * 7) + ((int) (mTransportTypes & 0xFFFFFFFF) * 11) + ((int) (mTransportTypes >> 32) * 13) + (mLinkUpBandwidthKbps * 17) + (mLinkDownBandwidthKbps * 19) + Objects.hashCode(mNetworkSpecifier) * 23 + (mSignalStrength * 29) + Objects.hashCode(mUids) * 31 + Objects.hashCode(mSSID) * 37 + Objects.hashCode(mTransportInfo) * 41;
}","{
    return (int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mUnwantedNetworkCapabilities & 0xFFFFFFFF) * 5) + ((int) (mUnwantedNetworkCapabilities >> 32) * 7) + ((int) (mTransportTypes & 0xFFFFFFFF) * 11) + ((int) (mTransportTypes >> 32) * 13) + (mLinkUpBandwidthKbps * 17) + (mLinkDownBandwidthKbps * 19) + Objects.hashCode(mNetworkSpecifier) * 23 + (mSignalStrength * 29) + Objects.hashCode(mUids) * 31 + Objects.hashCode(mSSID) * 37 + Objects.hashCode(mTransportInfo) * 41 + Objects.hashCode(mPrivateDnsBroken) * 43 + Objects.hashCode(mRequestorUid) * 47 + Objects.hashCode(mRequestorPackageName) * 53 + Arrays.hashCode(mAdministratorUids) * 59;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Additional terms involving mPrivateDnsBroken, mRequestorUid, mRequestorPackageName, and mAdministratorUids, along with their specific multipliers, have been added to the hash code calculation in the late version, so the code change type is 4.","Although there is a change in the hash code computation, this does not constitute a compatibility issue as the purpose of a hash code is to represent the object’s state with an integer, not to remain constant across different versions. Therefore, it can change as the object’s state changes. This kind of change does not affect the object's behavior from an API contract perspective; it's an internal change to accommodate potential new state elements of NetworkCapabilities. Thus, it is expected that the hash code may be different for the same values in different API versions."
241,"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>",29,30,"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>","<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateSelection(view, selStart, selEnd, candidatesStart, candidatesEnd);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""SELECTION CHANGE: "" + mCurMethod);
                final int oldSelStart = mCursorSelStart;
                final int oldSelEnd = mCursorSelEnd;
                // Update internal values before sending updateSelection to the IME, because
                // if it changes the text within its onUpdateSelection handler in a way that
                // does not move the cursor we don't want to call it again with the same values.
                mCursorSelStart = selStart;
                mCursorSelEnd = selEnd;
                mCursorCandStart = candidatesStart;
                mCursorCandEnd = candidatesEnd;
                mCurMethod.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateSelection(view, selStart, selEnd, candidatesStart, candidatesEnd);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""SELECTION CHANGE: "" + mCurMethod);
                final int oldSelStart = mCursorSelStart;
                final int oldSelEnd = mCursorSelEnd;
                // Update internal values before sending updateSelection to the IME, because
                // if it changes the text within its onUpdateSelection handler in a way that
                // does not move the cursor we don't want to call it again with the same values.
                mCursorSelStart = selStart;
                mCursorSelEnd = selEnd;
                mCursorCandStart = candidatesStart;
                mCursorCandEnd = candidatesEnd;
                mCurMethod.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}",1,"/**
 * Report the current selection range.
 *
 * <p><strong>Editor authors</strong>, you need to call this method whenever
 * the cursor moves in your editor. Remember that in addition to doing this, your
 * editor needs to always supply current cursor values in
 * {@link EditorInfo#initialSelStart} and {@link EditorInfo#initialSelEnd} every
 * time {@link android.view.View#onCreateInputConnection(EditorInfo)} is
 * called, which happens whenever the keyboard shows up or the focus changes
 * to a text field, among other cases.</p>
 */
","/**
 * Report the current selection range.
 *
 * <p><strong>Editor authors</strong>, you need to call this method whenever
 * the cursor moves in your editor. Remember that in addition to doing this, your
 * editor needs to always supply current cursor values in
 * {@link EditorInfo#initialSelStart} and {@link EditorInfo#initialSelEnd} every
 * time {@link android.view.View#onCreateInputConnection(EditorInfo)} is
 * called, which happens whenever the keyboard shows up or the focus changes
 * to a text field, among other cases.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The logical check for whether the `InputMethodManager` should update the selection has changed from comparing `mServedView` with `view` and checking `mServedView.checkInputConnectionProxy(view)` to simply calling `hasServedByInputMethodLocked(view)`. This change is within a control dependency (the `if` condition).,"There is no CI because while the condition under which the method actions are executed has changed, these changes do not affect the public behavior of the API in terms of the values it returns or the exceptions that it throws. The internal condition check only determines whether the method proceeds to execute its main logic, but from the perspective of an API caller, the observable effects (returned values and exceptions) remain consistent."
242,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,29,30,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,0,"{
    return mStrict;
}","{
    return (mStrictFlags & STRICT_PARENTHESES) != 0;
}",1,"/**
 * Get if the query is marked as strict, as last configured by
 * {@link #setStrict(boolean)}.
 */
","/**
 * Get if the query is marked as strict, as last configured by
 * {@link #setStrict(boolean)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The logic to determine the return value has changed from directly returning the value of a member variable 'mStrict' to checking whether 'mStrictFlags' contains the 'STRICT_PARENTHESES' flag. This change constitutes return statement changed type, which is coded as 1.","Since the condition for the return value has changed from a simple member variable to a bitwise operation on another member variable, it could potentially lead to a different return value. Therefore, this is a compatibility issue caused by potential different return values, and the CI type is 1."
243,"<android.content.IntentFilter: int match(String,String,String,Uri,Set<String>,String)>",29,30,"<android.content.IntentFilter: int match(String,String,String,Uri,Set<String>,String)>","<android.content.IntentFilter: int match(String,String,String,Uri,Set<String>,String)>",0,"{
    if (action != null && !matchAction(action)) {
        if (false)
            Log.v(logTag, ""No matching action "" + action + "" for "" + this);
        return NO_MATCH_ACTION;
    }
    int dataMatch = matchData(type, scheme, data);
    if (dataMatch < 0) {
        if (false) {
            if (dataMatch == NO_MATCH_TYPE) {
                Log.v(logTag, ""No matching type "" + type + "" for "" + this);
            }
            if (dataMatch == NO_MATCH_DATA) {
                Log.v(logTag, ""No matching scheme/path "" + data + "" for "" + this);
            }
        }
        return dataMatch;
    }
    String categoryMismatch = matchCategories(categories);
    if (categoryMismatch != null) {
        if (false) {
            Log.v(logTag, ""No matching category "" + categoryMismatch + "" for "" + this);
        }
        return NO_MATCH_CATEGORY;
    }
    // important than ones that can be embedded, but this is not the way...
    if (false) {
        if (categories != null) {
            dataMatch -= mCategories.size() - categories.size();
        }
    }
    return dataMatch;
}","{
    return match(action, type, scheme, data, categories, logTag, false, /*supportWildcards*/
    null);
}",1,"/**
 * Test whether this filter matches the given intent data.  A match is
 * only successful if the actions and categories in the Intent match
 * against the filter, as described in {@link IntentFilter}; in that case,
 * the match result returned will be as per {@link #matchData}.
 *
 * @param action The intent action to match against (Intent.getAction).
 * @param type The intent type to match against (Intent.resolveType()).
 * @param scheme The data scheme to match against (Intent.getScheme()).
 * @param data The data URI to match against (Intent.getData()).
 * @param categories The categories to match against
 * (Intent.getCategories()).
 * @param logTag Tag to use in debugging messages.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match,
 * {@link #NO_MATCH_DATA} if the scheme/path didn't match,
 * {@link #NO_MATCH_ACTION} if the action didn't match, or
 * {@link #NO_MATCH_CATEGORY} if one or more categories didn't match.
 *
 * @see #matchData
 * @see Intent#getAction
 * @see Intent#resolveType
 * @see Intent#getScheme
 * @see Intent#getData
 * @see Intent#getCategories
 */
","/**
 * Test whether this filter matches the given intent data.  A match is
 * only successful if the actions and categories in the Intent match
 * against the filter, as described in {@link IntentFilter}; in that case,
 * the match result returned will be as per {@link #matchData}.
 *
 * @param action The intent action to match against (Intent.getAction).
 * @param type The intent type to match against (Intent.resolveType()).
 * @param scheme The data scheme to match against (Intent.getScheme()).
 * @param data The data URI to match against (Intent.getData()).
 * @param categories The categories to match against
 * (Intent.getCategories()).
 * @param logTag Tag to use in debugging messages.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match,
 * {@link #NO_MATCH_DATA} if the scheme/path didn't match,
 * {@link #NO_MATCH_ACTION} if the action didn't match, or
 * {@link #NO_MATCH_CATEGORY} if one or more categories didn't match.
 *
 * @see #matchData
 * @see Intent#getAction
 * @see Intent#resolveType
 * @see Intent#getScheme
 * @see Intent#getData
 * @see Intent#getCategories
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire body of the method has been replaced with a call to a different method, which involves changing the actual logic and the way the matching is performed. This indicates that there may be a change in the dependent API; hence the code change type is 1,5.","As the method implementation has been completely changed and now delegates the matching process to another method, this new method could potentially use a different algorithm or logic to perform the matching. Therefore, the outcome of the method could be different which can lead to a CI type of 1."
244,<android.view.View: void onRestoreInstanceState(Parcelable)>,29,30,<android.view.View: void onRestoreInstanceState(Parcelable)>,<android.view.View: void onRestoreInstanceState(Parcelable)>,0,"{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        BaseSavedState baseState = (BaseSavedState) state;
        if ((baseState.mSavedData & BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED) != 0) {
            mStartActivityRequestWho = baseState.mStartActivityRequestWhoSaved;
        }
        if ((baseState.mSavedData & BaseSavedState.IS_AUTOFILLED) != 0) {
            setAutofilled(baseState.mIsAutofilled);
        }
        if ((baseState.mSavedData & BaseSavedState.AUTOFILL_ID) != 0) {
            // It can happen that views have the same view id and the restoration path will not
            // be able to distinguish between them. The autofill id needs to be unique though.
            // Hence prevent the same autofill view id from being restored multiple times.
            ((BaseSavedState) state).mSavedData &= ~BaseSavedState.AUTOFILL_ID;
            if ((mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) != 0) {
                // Ignore when view already set it through setAutofillId();
                if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.DEBUG)) {
                    Log.d(AUTOFILL_LOG_TAG, ""onRestoreInstanceState(): not setting autofillId "" + ""to "" + baseState.mAutofillViewId + "" because view explicitly set"" + "" it to "" + mAutofillId);
                }
            } else {
                mAutofillViewId = baseState.mAutofillViewId;
                // will be set on demand by getAutofillId()
                mAutofillId = null;
            }
        }
    }
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        BaseSavedState baseState = (BaseSavedState) state;
        if ((baseState.mSavedData & BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED) != 0) {
            mStartActivityRequestWho = baseState.mStartActivityRequestWhoSaved;
        }
        if ((baseState.mSavedData & BaseSavedState.IS_AUTOFILLED) != 0) {
            setAutofilled(baseState.mIsAutofilled, baseState.mHideHighlight);
        }
        if ((baseState.mSavedData & BaseSavedState.AUTOFILL_ID) != 0) {
            // It can happen that views have the same view id and the restoration path will not
            // be able to distinguish between them. The autofill id needs to be unique though.
            // Hence prevent the same autofill view id from being restored multiple times.
            ((BaseSavedState) state).mSavedData &= ~BaseSavedState.AUTOFILL_ID;
            if ((mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) != 0) {
                // Ignore when view already set it through setAutofillId();
                if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.DEBUG)) {
                    Log.d(AUTOFILL_LOG_TAG, ""onRestoreInstanceState(): not setting autofillId "" + ""to "" + baseState.mAutofillViewId + "" because view explicitly set"" + "" it to "" + mAutofillId);
                }
            } else {
                mAutofillViewId = baseState.mAutofillViewId;
                // will be set on demand by getAutofillId()
                mAutofillId = null;
            }
        }
    }
}",1,"/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
","/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,"4,5",0,"The method setAutofilled() now has an additional parameter, which signifies a change in the method signature, and is an indication of a Dependent API changed (5). This is the only change in the code; it is not a return statement, exception handling, or control dependency change. Therefore, the code change type is 4,5.","No Compatibility Issue arises because there is no modification to the behavior of the existing control flow, return value, or exception handling. The change in the dependent API is internal to the method implementation and will not affect the clients of the onRestoreInstanceState() method directly, as they do not interact with this method signature."
245,<android.util.ArraySet: void addAll(ArraySet<? extends E>)>,29,30,<android.util.ArraySet: void addAll(ArraySet<? extends E>)>,<android.util.ArraySet: void addAll(ArraySet<? extends E>)>,0,"{
    final int N = array.mSize;
    ensureCapacity(mSize + N);
    if (mSize == 0) {
        if (N > 0) {
            System.arraycopy(array.mHashes, 0, mHashes, 0, N);
            System.arraycopy(array.mArray, 0, mArray, 0, N);
            mSize = N;
        }
    } else {
        for (int i = 0; i < N; i++) {
            add(array.valueAt(i));
        }
    }
}","{
    final int N = array.mSize;
    ensureCapacity(mSize + N);
    if (mSize == 0) {
        if (N > 0) {
            System.arraycopy(array.mHashes, 0, mHashes, 0, N);
            System.arraycopy(array.mArray, 0, mArray, 0, N);
            if (0 != mSize) {
                throw new ConcurrentModificationException();
            }
            mSize = N;
        }
    } else {
        for (int i = 0; i < N; i++) {
            add(array.valueAt(i));
        }
    }
}",1,"/**
 * Perform a {@link #add(Object)} of all values in <var>array</var>
 * @param array The array whose contents are to be retrieved.
 */
","/**
 * Perform a {@link #add(Object)} of all values in <var>array</var>
 * @param array The array whose contents are to be retrieved.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement `throw new ConcurrentModificationException();` is added and an if condition `if (0 != mSize)` is introduced within the block where `mSize` is set to `N`. This is a change in other statements since the new conditional check is not part of return, exception handling outside of the newly added throw, or a control structure affecting existing behavior outside of the new exception. So, the change types are 2 and 4.","The new code throws a `ConcurrentModificationException` if `mSize` is not zero after an array copy operation intended for an empty array set. Since this could lead to the exception being thrown when it wasn't before, it constitutes a change in exception handling behavior. Therefore, there is a potential Compatibility Issue due to different exception handlings, which is type 2."
246,"<android.content.pm.PackageInstaller: void installExistingPackage(String,int,IntentSender)>",29,30,"<android.content.pm.PackageInstaller: void installExistingPackage(String,int,IntentSender)>","<android.content.pm.PackageInstaller: void installExistingPackage(String,int,IntentSender)>",0,"{
    Preconditions.checkNotNull(packageName, ""packageName cannot be null"");
    try {
        mInstaller.installExistingPackage(packageName, PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS, installReason, statusReceiver, mUserId, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(packageName, ""packageName cannot be null"");
    try {
        mInstaller.installExistingPackage(packageName, PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS, installReason, statusReceiver, mUserId, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Install the given package, which already exists on the device, for the user for which this
 * installer was created.
 *
 * <p>This will
 * {@link PackageInstaller.SessionParams#setWhitelistedRestrictedPermissions(Set) whitelist
 * all restricted permissions}.
 *
 * @param packageName The package to install.
 * @param installReason Reason for install.
 * @param statusReceiver Where to deliver the result.
 */
","/**
 * Install the given package, which already exists on the device, for the user for which this
 * installer was created.
 *
 * <p>This will
 * {@link PackageInstaller.SessionParams#setWhitelistedRestrictedPermissions(Set) whitelist
 * all restricted permissions}.
 *
 * @param packageName The package to install.
 * @param installReason Reason for install.
 * @param statusReceiver Where to deliver the result.
 */
",-1,"[@RequiresPermission(allOf = { Manifest.permission.INSTALL_PACKAGES, Manifest.permission.INSTALL_EXISTING_PACKAGES })]","[@RequiresPermission(allOf = { Manifest.permission.INSTALL_PACKAGES, Manifest.permission.INSTALL_EXISTING_PACKAGES })]",-1,-1,-1,-1,-1,-1,4,0,"The code has changed from using Preconditions.checkNotNull to Objects.requireNonNull for null-checking, which is a different method for the same functionality, so the change type is 4.","There is no compatibility issue because both Preconditions.checkNotNull and Objects.requireNonNull serve the exact same purpose of checking for null and throwing a NullPointerException if the checked value is null. The change does not affect the API's behavior, therefore, the CI type is 0."
247,"<android.content.ContentProviderClient: Cursor query(Uri,String[],Bundle,CancellationSignal)>",29,30,"<android.content.ContentProviderClient: Cursor query(Uri,String[],Bundle,CancellationSignal)>","<android.content.ContentProviderClient: Cursor query(Uri,String[],Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mPackageName, uri, projection, queryArgs, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        return new CursorWrapperInner(cursor);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(uri, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mPackageName, mAttributionTag, uri, projection, queryArgs, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        return new CursorWrapperInner(cursor);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
","/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",5,"The method signature in the late implementation has one extra parameter, mAttributionTag, which is passed to the mContentProvider.query() method. Additionally, Preconditions.checkNotNull() has changed to Objects.requireNonNull(), but both methods serve the same purpose of null checking and therefore do not represent a functional change. Thus, the code change type is 4 for the null check that is semantically the same, and 5 for the addition of a new parameter.","There's a potential Compatibility Issue caused by the introduction of a new parameter, mAttributionTag, to the `query` method call within the API. This represents a change in how the dependent API, mContentProvider.query(), is being used, potentially leading to different behavior if the downstream method's behavior depends on the new parameter. Therefore, the CI type is 5."
248,"<android.content.pm.LauncherApps: boolean shouldHideFromSuggestions(String,UserHandle)>",29,30,"<android.content.pm.LauncherApps: boolean shouldHideFromSuggestions(String,UserHandle)>","<android.content.pm.LauncherApps: boolean shouldHideFromSuggestions(String,UserHandle)>",0,"{
    Preconditions.checkNotNull(packageName, ""packageName"");
    Preconditions.checkNotNull(user, ""user"");
    try {
        return mService.shouldHideFromSuggestions(packageName, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(packageName, ""packageName"");
    Objects.requireNonNull(user, ""user"");
    try {
        return mService.shouldHideFromSuggestions(packageName, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns whether a package should be hidden from suggestions to the user. Currently, this
 * could be done because the package was marked as distracting to the user via
 * {@code PackageManager.setDistractingPackageRestrictions(String[], int)}.
 *
 * @param packageName The package for which to check.
 * @param user the {@link UserHandle} of the profile.
 * @return
 */
","/**
 * Returns whether a package should be hidden from suggestions to the user. Currently, this
 * could be done because the package was marked as distracting to the user via
 * {@code PackageManager.setDistractingPackageRestrictions(String[], int)}.
 *
 * @param packageName The package for which to check.
 * @param user the {@link UserHandle} of the profile.
 * @return
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change from `Preconditions.checkNotNull` to `Objects.requireNonNull` is present within the early and late versions' implementations, but both methods accomplish the same task of null-checking and throwing a NullPointerException with the provided message if the given reference is null. Therefore, this change does not affect the behavior of the method. ","There is no compatibility issue since the change does not affect the output of the method or the exceptions it throws. Both versions will behave identically provided the same input, as the change is merely a switch between equivalent methods of null checking."
249,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,29,30,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,0,"{
    if (sForceSafeLabels) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        return loadUnsafeLabel(pm);
    }
}","{
    if (sForceSafeLabels && !Objects.equals(packageName, ActivityThread.currentPackageName())) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        return loadUnsafeLabel(pm);
    }
}",1,"/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
","/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,3,0,"The control dependency changed due to the added condition `!Objects.equals(packageName, ActivityThread.currentPackageName())`. The code change type is 3.","The additional condition refines when `loadSafeLabel` should be used. However, since both branches of the conditional (if/else) return a value and there is no change in the types of values being returned, nor any changes that would lead to an exception being thrown where it previously was not (or vice versa), there’s no Compatibility Issue in terms of different return values or exception handlings. Therefore, the CI type is 0."
250,<android.view.textclassifier.TextClassificationConstants: boolean isSmartSelectionEnabled()>,29,30,<android.view.textclassifier.TextClassificationConstants: boolean isSmartSelectionEnabled()>,<android.view.textclassifier.TextClassificationConstants: boolean isSmartSelectionEnabled()>,0,"{
    return mConfigParser.getBoolean(SMART_SELECTION_ENABLED, SMART_SELECTION_ENABLED_DEFAULT);
}","{
    return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_TEXTCLASSIFIER, SMART_SELECTION_ENABLED, SMART_SELECTION_ENABLED_DEFAULT);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method changed from mConfigParser.getBoolean() to DeviceConfig.getBoolean() with different parameters involved. So, the source of the configuration value is different, pointing to a change in the dependent API.","Despite the change in the source of the configuration value, since both methods are designed to retrieve a boolean configuration value given a default, assuming the new API provides a backward-compatible configuration retrieval mechanism, this change should not lead to a behavior that is different in terms of the boolean value returned by the method. Therefore, this should not be classified as causing a compatibility issue."
252,<android.widget.Toast: float getHorizontalMargin()>,29,30,<android.widget.Toast: float getHorizontalMargin()>,<android.widget.Toast: float getHorizontalMargin()>,0,"{
    return mTN.mHorizontalMargin;
}","{
    if (isSystemRenderedTextToast()) {
        Log.e(TAG, ""getHorizontalMargin() shouldn't be called on text toasts, the result may "" + ""not reflect actual values."");
    }
    return mTN.mHorizontalMargin;
}",1,"/**
 * Return the horizontal margin.
 */
","/**
 * Return the horizontal margin.
 *
 * <p><strong>Warning:</strong> Starting from Android {@link Build.VERSION_CODES#R}, for apps
 * targeting API level {@link Build.VERSION_CODES#R} or higher, this method shouldn't be called
 * on text toasts as its return value may not reflect actual value since text toasts are not
 * rendered by the app anymore.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new if-statement with a logging operation has been introduced, representing a control dependency change. Additionally, there is a change in other statements (the new logging operation), accounting for a change in type 4.","Despite the new control flow and logging, there is no change in the method's actual operational behavior, as the same value, mTN.mHorizontalMargin, is returned regardless of the new logging. The method does not return different values nor does it throw new exceptions in normal operation. Therefore, there's no compatibility issue."
253,<android.app.admin.DevicePolicyManager: Bundle getUserRestrictions(ComponentName)>,29,30,<android.app.admin.DevicePolicyManager: Bundle getUserRestrictions(ComponentName)>,<android.app.admin.DevicePolicyManager: Bundle getUserRestrictions(ComponentName)>,0,"{
    throwIfParentInstance(""getUserRestrictions"");
    Bundle ret = null;
    if (mService != null) {
        try {
            ret = mService.getUserRestrictions(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return ret == null ? new Bundle() : ret;
}","{
    Bundle ret = null;
    if (mService != null) {
        try {
            ret = mService.getUserRestrictions(admin, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return ret == null ? new Bundle() : ret;
}",1,"/**
 * Called by a profile or device owner to get user restrictions set with
 * {@link #addUserRestriction(ComponentName, String)}.
 * <p>
 * The target user may have more restrictions set by the system or other device owner / profile
 * owner. To get all the user restrictions currently set, use
 * {@link UserManager#getUserRestrictions()}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Called by a profile or device owner to get user restrictions set with
 * {@link #addUserRestriction(ComponentName, String)}.
 * <p>
 * The target user may have more restrictions set by the system or other device owner / profile
 * owner. To get all the user restrictions currently set, use
 * {@link UserManager#getUserRestrictions()}.
 * <p>
 * The profile owner of an organization-owned managed profile may invoke this method on
 * the {@link DevicePolicyManager} instance it obtained from
 * {@link #getParentProfileInstance(ComponentName)}, for retrieving device-wide restrictions
 * it previously set with {@link #addUserRestriction(ComponentName, String)}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,5",1,"In the late version implementation, the `throwIfParentInstance(""getUserRestrictions"");` line has been removed and the `mService.getUserRestrictions(admin);` call has been modified to `mService.getUserRestrictions(admin, mParentInstance);`. This includes an additional parameter to the method call, indicating a code change type 3 (Control dependency change) and type 5 (Dependent API change).","The removal of the `throwIfParentInstance(""getUserRestrictions"");` code may affect the flow of how exceptions are thrown, potentially leading to different exceptions being thrown, and the modification in the `getUserRestrictions` method call may lead to different return values. So the CI types are 1 and 2. However, since the change in how exceptions are thrown is not directly visible from the code (it would depend on implementation details of `throwIfParentInstance`), the most clear CI detected is 1 (Compatibility Issue caused by potential different return values)."
254,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",29,30,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, context.getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData(context);
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManager.getService().getIntentSenderWithFeature(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, context.getAttributionTag(), null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, context.getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called on `intent` has changed from `migrateExtraStreamToClipData()` to `migrateExtraStreamToClipData(context)`, adding `context` as an argument, and the method `getIntentSender()` has been changed to `getIntentSenderWithFeature()`, with the addition of a new parameter `context.getAttributionTag()`. This is a code change type 4 for the other statement changed and type 5 for the dependent API changed since it involves changes to method calls on the object `intent` and the `ActivityManager`.","Though these changes exist, neither leads to a CI according to our definitions. There is no indication that the actual behavior of `intent.migrateExtraStreamToClipData(context)` is different in a way that would lead to a different return value or exception thrown compared to `intent.migrateExtraStreamToClipData()`. Similarly, the change from `getIntentSender()` to `getIntentSenderWithFeature()` also doesn't necessarily lead to a different return value or exception thrown by the API, as it can be assumed that `getIntentSenderWithFeature()` was introduced to simply add more context to the `getIntentSender()` operation without altering its fundamental behavior. Therefore, there is no Compatibility Issue introduced by these changes."
255,<android.util.Half: short round(short)>,29,30,<android.util.Half: short round(short)>,<android.util.Half: short round(short)>,0,"{
    int bits = h & 0xffff;
    int e = bits & 0x7fff;
    int result = bits;
    if (e < 0x3c00) {
        result &= FP16_SIGN_MASK;
        result |= (0x3c00 & (e >= 0x3800 ? 0xffff : 0x0));
    } else if (e < 0x6400) {
        e = 25 - (e >> 10);
        int mask = (1 << e) - 1;
        result += (1 << (e - 1));
        result &= ~mask;
    }
    return (short) result;
}","{
    return FP16.rint(h);
}",1,"/**
 * Returns the closest integral half-precision float value to the specified
 * half-precision float value. Special values are handled in the
 * following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The value of the specified half-precision float rounded to the nearest
 * half-precision float value
 */
","/**
 * Returns the closest integral half-precision float value to the specified
 * half-precision float value. Special values are handled in the
 * following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * <p class=note>
 * <strong>Note:</strong> Unlike the identically named
 * <code class=prettyprint>int java.lang.Math.round(float)</code> method,
 * this returns a Half value stored in a short, <strong>not</strong> an
 * actual short integer result.
 *
 * @param h A half-precision float value
 * @return The value of the specified half-precision float rounded to the nearest
 * half-precision float value
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has entirely changed to rely on FP16.rint(h) instead of the manual bitwise operations previously used. Therefore, the implementation is different in how the value is rounded and also depends on a different method altogether, which is a different API. The code change type is 1,5.","Since FP16.rint(h) is used instead of the original manual bitwise manipulation code, there could be a difference in the rounded value returned by the function, potentially leading to different behaviors. The CI type is 1 due to potentially different return values."
256,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",29,30,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method called within the try block has changed from `ActivityManager.getService().broadcastIntent(...)` to `ActivityManager.getService().broadcastIntentWithFeature(...)`. While the methods are different, their parameters remain the same, except for the addition of getAttributionTag() parameter. This indicates a change in a dependent API, so the code change type is 5.","There is no indication that the behavior of `broadcastIntentWithFeature` would be differently regarding the return type or thrown exceptions if compared with `broadcastIntent`, assuming that the new method is intended to replace the old one with the same behavior plus additional feature handling. As there is no information suggesting a different behavior that could lead to a potential CI, the CI type is 0."
258,<android.view.View: WindowInsets onApplyWindowInsets(WindowInsets)>,29,30,<android.view.View: WindowInsets onApplyWindowInsets(WindowInsets)>,<android.view.View: WindowInsets onApplyWindowInsets(WindowInsets)>,0,"{
    if ((mPrivateFlags3 & PFLAG3_FITTING_SYSTEM_WINDOWS) == 0) {
        // and has logic to perform.
        if (fitSystemWindows(insets.getSystemWindowInsetsAsRect())) {
            return insets.consumeSystemWindowInsets();
        }
    } else {
        // We were called from within a direct call to fitSystemWindows.
        if (fitSystemWindowsInt(insets.getSystemWindowInsetsAsRect())) {
            return insets.consumeSystemWindowInsets();
        }
    }
    return insets;
}","{
    if ((mPrivateFlags4 & PFLAG4_FRAMEWORK_OPTIONAL_FITS_SYSTEM_WINDOWS) != 0 && (mViewFlags & FITS_SYSTEM_WINDOWS) != 0) {
        return onApplyFrameworkOptionalFitSystemWindows(insets);
    }
    if ((mPrivateFlags3 & PFLAG3_FITTING_SYSTEM_WINDOWS) == 0) {
        // and has logic to perform.
        if (fitSystemWindows(insets.getSystemWindowInsetsAsRect())) {
            return insets.consumeSystemWindowInsets();
        }
    } else {
        // We were called from within a direct call to fitSystemWindows.
        if (fitSystemWindowsInt(insets.getSystemWindowInsetsAsRect())) {
            return insets.consumeSystemWindowInsets();
        }
    }
    return insets;
}",1,"/**
 * Called when the view should apply {@link WindowInsets} according to its internal policy.
 *
 * <p>This method should be overridden by views that wish to apply a policy different from or
 * in addition to the default behavior. Clients that wish to force a view subtree
 * to apply insets should call {@link #dispatchApplyWindowInsets(WindowInsets)}.</p>
 *
 * <p>Clients may supply an {@link OnApplyWindowInsetsListener} to a view. If one is set
 * it will be called during dispatch instead of this method. The listener may optionally
 * call this method from its own implementation if it wishes to apply the view's default
 * insets policy in addition to its own.</p>
 *
 * <p>Implementations of this method should either return the insets parameter unchanged
 * or a new {@link WindowInsets} cloned from the supplied insets with any insets consumed
 * that this view applied itself. This allows new inset types added in future platform
 * versions to pass through existing implementations unchanged without being erroneously
 * consumed.</p>
 *
 * <p>By default if a view's {@link #setFitsSystemWindows(boolean) fitsSystemWindows}
 * property is set then the view will consume the system window insets and apply them
 * as padding for the view.</p>
 *
 * @param insets Insets to apply
 * @return The supplied insets with any applied insets consumed
 */
","/**
 * Called when the view should apply {@link WindowInsets} according to its internal policy.
 *
 * <p>This method should be overridden by views that wish to apply a policy different from or
 * in addition to the default behavior. Clients that wish to force a view subtree
 * to apply insets should call {@link #dispatchApplyWindowInsets(WindowInsets)}.</p>
 *
 * <p>Clients may supply an {@link OnApplyWindowInsetsListener} to a view. If one is set
 * it will be called during dispatch instead of this method. The listener may optionally
 * call this method from its own implementation if it wishes to apply the view's default
 * insets policy in addition to its own.</p>
 *
 * <p>Implementations of this method should either return the insets parameter unchanged
 * or a new {@link WindowInsets} cloned from the supplied insets with any insets consumed
 * that this view applied itself. This allows new inset types added in future platform
 * versions to pass through existing implementations unchanged without being erroneously
 * consumed.</p>
 *
 * <p>By default if a view's {@link #setFitsSystemWindows(boolean) fitsSystemWindows}
 * property is set then the view will consume the system window insets and apply them
 * as padding for the view.</p>
 *
 * @param insets Insets to apply
 * @return The supplied insets with any applied insets consumed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,The change indicates that there's a new control dependency added by the additional if condition:,    return onApplyFrameworkOptionalFitSystemWindows(insets);
259,<android.view.SurfaceControl: void readFromParcel(Parcel)>,29,30,<android.view.SurfaceControl: void readFromParcel(Parcel)>,<android.view.SurfaceControl: void readFromParcel(Parcel)>,0,"{
    if (in == null) {
        throw new IllegalArgumentException(""source must not be null"");
    }
    mName = in.readString();
    mWidth = in.readInt();
    mHeight = in.readInt();
    long object = 0;
    if (in.readInt() != 0) {
        object = nativeReadFromParcel(in);
    }
    assignNativeObject(object);
}","{
    if (in == null) {
        throw new IllegalArgumentException(""source must not be null"");
    }
    mName = in.readString8();
    mWidth = in.readInt();
    mHeight = in.readInt();
    long object = 0;
    if (in.readInt() != 0) {
        object = nativeReadFromParcel(in);
    }
    assignNativeObject(object, ""readFromParcel"");
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The `readString()` method called on the `Parcel` object has been changed to `readString8()`, and an additional string parameter `""readFromParcel""` is passed to `assignNativeObject(object, ""readFromParcel"")`. However, these changes are neither affecting return values nor exception handlings directly, so the code change type is 4,5. ","There is no indication that these changes would cause the method to return a different result or throw a different exception, given that the `readString8()` change appears to be a substitution for string reading with potentially the same or compatible behavior and the additional string argument to `assignNativeObject` does not affect the method contract. Therefore, it seems there is no Compatibility Issue; thus the CI type is 0."
260,<android.app.ActivityManager.TaskDescription: Bitmap getIcon()>,29,30,<android.app.ActivityManager.TaskDescription: Bitmap getIcon()>,<android.app.ActivityManager.TaskDescription: Bitmap getIcon()>,0,"{
    if (mIcon != null) {
        return mIcon;
    }
    return loadTaskDescriptionIcon(mIconFilename, UserHandle.myUserId());
}","{
    Bitmap icon = getInMemoryIcon();
    if (icon != null) {
        return icon;
    }
    return loadTaskDescriptionIcon(mIconFilename, UserHandle.myUserId());
}",1,"/**
 * @return The icon that represents the current state of this task.
 */
","/**
 * @return The in-memory or loaded icon that represents the current state of this task.
 * @deprecated This call is no longer supported. The caller should keep track of any icons
 * it sets for the task descriptions internally.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4",0,"The variable used to return the icon has been renamed from `mIcon` to a new method call `getInMemoryIcon()`, and an additional method call is introduced. It is a control dependency change because the condition for the return statement is modified to rely on the new `getInMemoryIcon()` method. It's also an 'other statement changed' because there's no change in the control flow logic, just a renaming of the variable and an introduction of a new method call. ","Despite the code changes, there is no compatibility issue because the behavior of the API is preserved. The method still checks for a cached icon and returns it if available; otherwise, it loads the icon from a file. There's no change in the exceptions thrown or the values returned. So, the method’s contract remains the same, and there is no compatibility issue introduced by these changes."
261,<android.view.textclassifier.TextClassificationSession.SelectionEventHelper: boolean sanitizeEvent(SelectionEvent)>,29,30,<android.view.textclassifier.TextClassificationSession.SelectionEventHelper: boolean sanitizeEvent(SelectionEvent)>,<android.view.textclassifier.TextClassificationSession.SelectionEventHelper: boolean sanitizeEvent(SelectionEvent)>,0,"{
    updateInvocationMethod(event);
    modifyAutoSelectionEventType(event);
    if (event.getEventType() != SelectionEvent.EVENT_SELECTION_STARTED && mStartEvent == null) {
        Log.d(LOG_TAG, ""Selection session not yet started. Ignoring event"");
        return false;
    }
    final long now = System.currentTimeMillis();
    switch(event.getEventType()) {
        case SelectionEvent.EVENT_SELECTION_STARTED:
            Preconditions.checkArgument(event.getAbsoluteEnd() == event.getAbsoluteStart() + 1);
            event.setSessionId(mSessionId);
            mStartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_SINGLE:
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_MULTI:
        case SelectionEvent.EVENT_AUTO_SELECTION:
            mSmartEvent = event;
            break;
        case SelectionEvent.EVENT_SELECTION_MODIFIED:
            if (mPrevEvent != null && mPrevEvent.getAbsoluteStart() == event.getAbsoluteStart() && mPrevEvent.getAbsoluteEnd() == event.getAbsoluteEnd()) {
                // Selection did not change. Ignore event.
                return false;
            }
            break;
        default:
    }
    event.setEventTime(now);
    if (mStartEvent != null) {
        event.setSessionId(mStartEvent.getSessionId()).setDurationSinceSessionStart(now - mStartEvent.getEventTime()).setStart(event.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setEnd(event.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mSmartEvent != null) {
        event.setResultId(mSmartEvent.getResultId()).setSmartStart(mSmartEvent.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setSmartEnd(mSmartEvent.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mPrevEvent != null) {
        event.setDurationSincePreviousEvent(now - mPrevEvent.getEventTime()).setEventIndex(mPrevEvent.getEventIndex() + 1);
    }
    mPrevEvent = event;
    return true;
}","{
    updateInvocationMethod(event);
    modifyAutoSelectionEventType(event);
    if (event.getEventType() != SelectionEvent.EVENT_SELECTION_STARTED && mStartEvent == null) {
        Log.d(LOG_TAG, ""Selection session not yet started. Ignoring event"");
        return false;
    }
    final long now = System.currentTimeMillis();
    switch(event.getEventType()) {
        case SelectionEvent.EVENT_SELECTION_STARTED:
            Preconditions.checkArgument(event.getAbsoluteEnd() == event.getAbsoluteStart() + 1);
            event.setSessionId(mSessionId);
            mStartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_SINGLE:
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_MULTI:
        case SelectionEvent.EVENT_AUTO_SELECTION:
            mSmartEvent = event;
            break;
        case SelectionEvent.ACTION_ABANDON:
        case SelectionEvent.ACTION_OVERTYPE:
            if (mPrevEvent != null) {
                event.setEntityType(mPrevEvent.getEntityType());
            }
            break;
        case SelectionEvent.EVENT_SELECTION_MODIFIED:
            if (mPrevEvent != null && mPrevEvent.getAbsoluteStart() == event.getAbsoluteStart() && mPrevEvent.getAbsoluteEnd() == event.getAbsoluteEnd()) {
                // Selection did not change. Ignore event.
                return false;
            }
            break;
        default:
    }
    event.setEventTime(now);
    if (mStartEvent != null) {
        event.setSessionId(mStartEvent.getSessionId()).setDurationSinceSessionStart(now - mStartEvent.getEventTime()).setStart(event.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setEnd(event.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mSmartEvent != null) {
        event.setResultId(mSmartEvent.getResultId()).setSmartStart(mSmartEvent.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setSmartEnd(mSmartEvent.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mPrevEvent != null) {
        event.setDurationSincePreviousEvent(now - mPrevEvent.getEventTime()).setEventIndex(mPrevEvent.getEventIndex() + 1);
    }
    mPrevEvent = event;
    return true;
}",1,"/**
 * Updates the necessary fields in the event for the current session.
 *
 * @return true if the event should be reported. false if the event should be ignored
 */
","/**
 * Updates the necessary fields in the event for the current session.
 *
 * @return true if the event should be reported. false if the event should be ignored
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The switch case has been extended with two new cases: SelectionEvent.ACTION_ABANDON and SelectionEvent.ACTION_OVERTYPE, which now assigns the entityType from the previous event to the current event, hence the change type is 3.","The new cases in the switch statement (SelectionEvent.ACTION_ABANDON and SelectionEvent.ACTION_OVERTYPE) do not alter the existing control flow for other events nor the existing behavior for the previous events, and the cases fall through to default without modifying the event if mPrevEvent is null. Thus, they do not inherently represent a compatibility concern for existing use cases of the API and therefore can be classified as no compatibility issue (0)."
262,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,29,30,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    if (!mHasSelectorWheel || !isEnabled()) {
        return false;
    }
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                removeAllCallbacks();
                hideSoftInput();
                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
                mLastDownEventTime = event.getEventTime();
                mIgnoreMoveEvents = false;
                mPerformClickOnTap = false;
                // Handle pressed state before any state change.
                if (mLastDownEventY < mTopSelectionDividerTop) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_DECREMENT);
                    }
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_INCREMENT);
                    }
                }
                // Make sure we support flinging inside scrollables.
                getParent().requestDisallowInterceptTouchEvent(true);
                if (!mFlingScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                } else if (!mAdjustScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                } else if (mLastDownEventY < mTopSelectionDividerTop) {
                    postChangeCurrentByOneFromLongPress(false, ViewConfiguration.getLongPressTimeout());
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    postChangeCurrentByOneFromLongPress(true, ViewConfiguration.getLongPressTimeout());
                } else {
                    mPerformClickOnTap = true;
                    postBeginSoftInputOnLongPressCommand();
                }
                return true;
            }
    }
    return false;
}","{
    if (!mHasSelectorWheel || !isEnabled()) {
        return false;
    }
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                removeAllCallbacks();
                hideSoftInput();
                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
                mLastDownEventTime = event.getEventTime();
                mIgnoreMoveEvents = false;
                mPerformClickOnTap = false;
                // Handle pressed state before any state change.
                if (mLastDownEventY < mTopSelectionDividerTop) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_DECREMENT);
                    }
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_INCREMENT);
                    }
                }
                // Make sure we support flinging inside scrollables.
                getParent().requestDisallowInterceptTouchEvent(true);
                if (!mFlingScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollerFinished(mFlingScroller);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                } else if (!mAdjustScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollerFinished(mAdjustScroller);
                } else if (mLastDownEventY < mTopSelectionDividerTop) {
                    postChangeCurrentByOneFromLongPress(false, ViewConfiguration.getLongPressTimeout());
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    postChangeCurrentByOneFromLongPress(true, ViewConfiguration.getLongPressTimeout());
                } else {
                    mPerformClickOnTap = true;
                    postBeginSoftInputOnLongPressCommand();
                }
                return true;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change consists of adding `onScrollerFinished(mFlingScroller);` and `onScrollerFinished(mAdjustScroller);` in the branches where the fling and adjust scrollers get force finished if they are not already. These additions are inside the control flow of `ACTION_DOWN` but don't alter the return statements. So, this is an Other statement changed - type 4.","The newly introduced method calls (`onScrollerFinished(mFlingScroller)` and `onScrollerFinished(mAdjustScroller)`) don't lead to a different return value or exception being thrown. They appear to be callback invocations after stopping the scroller, and thus, most likely intended for internal state management or to trigger side effects that don't affect the output of the `onInterceptTouchEvent` method directly. Therefore, no compatibility issue arises from this change."
263,<android.view.accessibility.AccessibilityNodeInfo: void setText(CharSequence)>,29,30,<android.view.accessibility.AccessibilityNodeInfo: void setText(CharSequence)>,<android.view.accessibility.AccessibilityNodeInfo: void setText(CharSequence)>,0,"{
    enforceNotSealed();
    mOriginalText = text;
    // Replace any ClickableSpans in mText with placeholders
    if (text instanceof Spanned) {
        ClickableSpan[] spans = ((Spanned) text).getSpans(0, text.length(), ClickableSpan.class);
        if (spans.length > 0) {
            Spannable spannable = new SpannableStringBuilder(text);
            for (int i = 0; i < spans.length; i++) {
                ClickableSpan span = spans[i];
                if ((span instanceof AccessibilityClickableSpan) || (span instanceof AccessibilityURLSpan)) {
                    // We've already done enough
                    break;
                }
                int spanToReplaceStart = spannable.getSpanStart(span);
                int spanToReplaceEnd = spannable.getSpanEnd(span);
                int spanToReplaceFlags = spannable.getSpanFlags(span);
                spannable.removeSpan(span);
                ClickableSpan replacementSpan = (span instanceof URLSpan) ? new AccessibilityURLSpan((URLSpan) span) : new AccessibilityClickableSpan(span.getId());
                spannable.setSpan(replacementSpan, spanToReplaceStart, spanToReplaceEnd, spanToReplaceFlags);
            }
            mText = spannable;
            return;
        }
    }
    mText = (text == null) ? null : text.subSequence(0, text.length());
}","{
    enforceNotSealed();
    mOriginalText = text;
    if (text instanceof Spanned) {
        CharSequence tmpText = text;
        tmpText = replaceClickableSpan(tmpText);
        tmpText = replaceReplacementSpan(tmpText);
        mText = tmpText;
        return;
    }
    mText = (text == null) ? null : text.subSequence(0, text.length());
}",1,"/**
 * Sets the text of this node.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param text The text.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Sets the text of this node.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param text The text.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation has been refactored. Two new methods, replaceClickableSpan() and replaceReplacementSpan(), have been introduced and used to replace the previous inline code that modifies 'mText'. Return statements have not changed, but the process to potentially get to them has been altered due to the refactoring, so the code change types are 1,4.","Although the refactor introduces new methods and eliminates details about span replacement, the behaviour remains essentially the same. However, since it involves a significant rearrangement of how 'mText' is processed, there is a potential for the altered code to result in different values being assigned to 'mText', which could then be regarded as different return values. Therefore, the CI type is 1."
264,<android.widget.Editor.HandleView: void show()>,29,30,<android.widget.Editor.HandleView: void show()>,<android.widget.Editor.HandleView: void show()>,0,"{
    if (isShowing())
        return;
    getPositionListener().addSubscriber(this, true);
    // Make sure the offset is always considered new, even when focusing at same position
    mPreviousOffset = -1;
    positionAtCursorOffset(getCurrentCursorOffset(), false, false);
}","{
    if (TextView.DEBUG_CURSOR) {
        logCursor(getClass().getSimpleName() + "": HandleView: show()"", ""offset=%s"", getCurrentCursorOffset());
    }
    if (isShowing())
        return;
    getPositionListener().addSubscriber(this, true);
    // Make sure the offset is always considered new, even when focusing at same position
    mPreviousOffset = -1;
    positionAtCursorOffset(getCurrentCursorOffset(), false, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change consists of adding a conditional logging statement that is only executed if `TextView.DEBUG_CURSOR` is true. This change falls into the category of another statement being changed, hence the code change type is 4.","The added logging statement does not affect the API behavior because it does not change the control flow, return a different value, or alter the exception handling of the function. It solely adds debugging output and thus does not introduce a Compatibility Issue. Therefore, the CI type is 0."
265,<android.app.admin.SecurityLog.SecurityEvent: int getLogLevel()>,29,30,<android.app.admin.SecurityLog.SecurityEvent: int getLogLevel()>,<android.app.admin.SecurityLog.SecurityEvent: int getLogLevel()>,0,"{
    switch(mEvent.getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}","{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}",1,"/**
 * Returns severity level for the event.
 */
","/**
 * Returns severity level for the event.
 */
",-1,[@SecurityLogLevel],[@SecurityLogLevel],-1,-1,-1,-1,-1,-1,"3,4",1,"The method body has been changed by adding a case statement (TAG_CAMERA_POLICY_SET) in the switch block. Furthermore, the method call within the switch has been changed from mEvent.getTag() to getTag(), so the code change type is 3,4.","The addition of a new case (TAG_CAMERA_POLICY_SET) could potentially lead to the method returning a different value (LEVEL_INFO) for cases that was not previously handled and defaulted to return LEVEL_INFO. The modification of how the tag is retrieved (from mEvent.getTag() to getTag()) does not lead to different behavior if getTag() behaves identically to mEvent.getTag(). Therefore, the CI type is 1."
266,<android.view.autofill.AutofillManager: void setUserData(UserData)>,29,30,<android.view.autofill.AutofillManager: void setUserData(UserData)>,<android.view.autofill.AutofillManager: void setUserData(UserData)>,0,"{
    try {
        mService.setUserData(userData);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.setUserData(userData);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the {@link UserData} used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
","/**
 * Sets the {@link UserData} used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed; the early version handles the exception with e.rethrowFromSystemServer() directly, whereas the late version has introduced a throw statement, so the change type is 2.","The introduction of the new 'throw' keyword in the exception handling can lead to a different method of exception propagation, potentially causing a different exception handling behavior from the previous version, and the CI type is 2."
268,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",29,30,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",0,"{
    throwIfParentInstance(""setCameraDisabled"");
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to disable all cameras on the
 * device, for this user. After setting this, no applications running as this user will be able
 * to access any cameras on the device.
 * <p>
 * If the caller is device owner, then the restriction will be applied to all users.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call this method; if it has
 * not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 * @throws SecurityException if {@code admin} is not an active administrator or does not use
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA}.
 */
","/**
 * Called by an application that is administering the device to disable all cameras on the
 * device, for this user. After setting this, no applications running as this user will be able
 * to access any cameras on the device.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance,
 * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be
 * the profile owner of an organization-owned managed profile.
 * <p>
 * If the caller is device owner, then the restriction will be applied to all users. If
 * called on the parent instance, then the restriction will be applied on the personal profile.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * <b>Note</b>, this policy type is deprecated for legacy device admins since
 * {@link android.os.Build.VERSION_CODES#Q}. On Android
 * {@link android.os.Build.VERSION_CODES#Q} devices, legacy device admins targeting SDK
 * version {@link android.os.Build.VERSION_CODES#P} or below can still call this API to
 * disable camera, while legacy device admins targeting SDK version
 * {@link android.os.Build.VERSION_CODES#Q} will receive a SecurityException. Starting
 * from Android {@link android.os.Build.VERSION_CODES#R}, requests to disable camera from
 * legacy device admins targeting SDK version {@link android.os.Build.VERSION_CODES#P} or
 * below will be silently ignored.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 * @throws SecurityException if {@code admin} is not an active administrator or does not use
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"A method call within the try block has been changed from mService.setCameraDisabled(admin, disabled) to mService.setCameraDisabled(admin, disabled, mParentInstance), adding a new parameter. There is no structural change like new/removed if statements or exception handling, so the code change is 4 for other statement changed and 5 for dependent API changed.","There is no Compatibility Issue due to the changes because the method signature is the same, and all it does is call another method with an additional argument (the state of mParentInstance), which doesn't affect the return type or exception handling of the method itself. Thus, the method behavior from the caller's perspective remains the same in terms of exception throwing and value returning, which makes the CI type as 0."
269,"<android.service.autofill.SaveInfo.Builder: Builder setNegativeAction(int,IntentSender)>",29,30,"<android.service.autofill.SaveInfo.Builder: Builder setNegativeAction(int,IntentSender)>","<android.service.autofill.SaveInfo.Builder: Builder setNegativeAction(int,IntentSender)>",0,"{
    throwIfDestroyed();
    if (style != NEGATIVE_BUTTON_STYLE_CANCEL && style != NEGATIVE_BUTTON_STYLE_REJECT) {
        throw new IllegalArgumentException(""Invalid style: "" + style);
    }
    mNegativeButtonStyle = style;
    mNegativeActionListener = listener;
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkArgumentInRange(style, NEGATIVE_BUTTON_STYLE_CANCEL, NEGATIVE_BUTTON_STYLE_NEVER, ""style"");
    mNegativeButtonStyle = style;
    mNegativeActionListener = listener;
    return this;
}",1,"/**
 * Sets the style and listener for the negative save action.
 *
 * <p>This allows an autofill service to customize the style and be
 * notified when the user selects the negative action in the save
 * UI. Note that selecting the negative action regardless of its style
 * and listener being customized would dismiss the save UI and if a
 * custom listener intent is provided then this intent is
 * started. The default style is {@link #NEGATIVE_BUTTON_STYLE_CANCEL}</p>
 *
 * @param style The action style.
 * @param listener The action listener.
 * @return This builder.
 *
 * @see #NEGATIVE_BUTTON_STYLE_CANCEL
 * @see #NEGATIVE_BUTTON_STYLE_REJECT
 *
 * @throws IllegalArgumentException If the style is invalid
 */
","/**
 * Sets the style and listener for the negative save action.
 *
 * <p>This allows an autofill service to customize the style and be
 * notified when the user selects the negative action in the save
 * UI. Note that selecting the negative action regardless of its style
 * and listener being customized would dismiss the save UI and if a
 * custom listener intent is provided then this intent is
 * started. The default style is {@link #NEGATIVE_BUTTON_STYLE_CANCEL}</p>
 *
 * @param style The action style.
 * @param listener The action listener.
 * @return This builder.
 *
 * @see #NEGATIVE_BUTTON_STYLE_CANCEL
 * @see #NEGATIVE_BUTTON_STYLE_REJECT
 * @see #NEGATIVE_BUTTON_STYLE_NEVER
 *
 * @throws IllegalArgumentException If the style is invalid
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The method for checking the valid range of 'style' has changed from an 'if' check and a manual throw of IllegalArgumentException to using Preconditions.checkArgumentInRange, so the code change type is 4.","Although the implementation for checking the range of 'style' has changed, it still enforces the same constraint on the input. Because the Preconditions.checkArgumentInRange method will throw an IllegalArgumentException if 'style' is not within the valid range, just like the manual check in the earlier version, there is no Compatibility Issue as the behavior of the API in terms of input validation remains the same."
271,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",29,30,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The method `ActivityManager.getService().broadcastIntent(...)` in early version is replaced with `ActivityManager.getService().broadcastIntentWithFeature(...)` with an additional parameter in late version, which is a dependent API changed, hence the change is of type 5.","There is no compatibility issue because the method signature has not changed and neither return values nor exceptions that are thrown are affected by this modification. Therefore, the CI type is 0."
272,<android.widget.RemoteViews.AsyncApplyTask: void onPostExecute(ViewTree)>,29,30,<android.widget.RemoteViews.AsyncApplyTask: void onPostExecute(ViewTree)>,<android.widget.RemoteViews.AsyncApplyTask: void onPostExecute(ViewTree)>,0,"{
    if (mError == null) {
        if (mListener != null) {
            mListener.onViewInflated(viewTree.mRoot);
        }
        try {
            if (mActions != null) {
                OnClickHandler handler = mHandler == null ? DEFAULT_ON_CLICK_HANDLER : mHandler;
                for (Action a : mActions) {
                    a.apply(viewTree.mRoot, mParent, handler);
                }
            }
        } catch (Exception e) {
            mError = e;
        }
    }
    if (mListener != null) {
        if (mError != null) {
            mListener.onError(mError);
        } else {
            mListener.onViewApplied(viewTree.mRoot);
        }
    } else if (mError != null) {
        if (mError instanceof ActionException) {
            throw (ActionException) mError;
        } else {
            throw new ActionException(mError);
        }
    }
}","{
    mCancelSignal.setOnCancelListener(null);
    if (mError == null) {
        if (mListener != null) {
            mListener.onViewInflated(viewTree.mRoot);
        }
        try {
            if (mActions != null) {
                OnClickHandler handler = mHandler == null ? DEFAULT_ON_CLICK_HANDLER : mHandler;
                for (Action a : mActions) {
                    a.apply(viewTree.mRoot, mParent, handler);
                }
            }
        } catch (Exception e) {
            mError = e;
        }
    }
    if (mListener != null) {
        if (mError != null) {
            mListener.onError(mError);
        } else {
            mListener.onViewApplied(viewTree.mRoot);
        }
    } else if (mError != null) {
        if (mError instanceof ActionException) {
            throw (ActionException) mError;
        } else {
            throw new ActionException(mError);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A statement that sets the onCancelListener to null for mCancelSignal is added at the beginning of the method, so the change type is 4.","The added statement does not affect the return type, value, or the exception handling mechanism of the existing implementation, so there is no Compatibility Issue. The onCancelListener-related change will not alter how the method behaves in terms of its contract for returning a value or throwing an exception; hence, the CI type is 0."
273,"<android.companion.BluetoothLeDeviceFilter.Builder: Builder setRawDataFilter(byte[],byte[])>",29,30,"<android.companion.BluetoothLeDeviceFilter.Builder: Builder setRawDataFilter(byte[],byte[])>","<android.companion.BluetoothLeDeviceFilter.Builder: Builder setRawDataFilter(byte[],byte[])>",0,"{
    checkNotUsed();
    Preconditions.checkNotNull(rawDataFilter);
    checkArgument(rawDataFilterMask == null || rawDataFilter.length == rawDataFilterMask.length, ""Mask and filter should be the same length"");
    mRawDataFilter = rawDataFilter;
    mRawDataFilterMask = rawDataFilterMask;
    return this;
}","{
    checkNotUsed();
    Objects.requireNonNull(rawDataFilter);
    checkArgument(rawDataFilterMask == null || rawDataFilter.length == rawDataFilterMask.length, ""Mask and filter should be the same length"");
    mRawDataFilter = rawDataFilter;
    mRawDataFilterMask = rawDataFilterMask;
    return this;
}",1,"/**
 * Filter devices by raw advertisement data, as obtained by {@link ScanRecord#getBytes}
 *
 * @param rawDataFilter bit values that have to match against advertized data
 * @param rawDataFilterMask bits that have to be matched
 * @return self for chaining
 */
","/**
 * Filter devices by raw advertisement data, as obtained by {@link ScanRecord#getBytes}
 *
 * @param rawDataFilter bit values that have to match against advertized data
 * @param rawDataFilterMask bits that have to be matched
 * @return self for chaining
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The method for checking null has been changed from `Preconditions.checkNotNull(rawDataFilter)` to `Objects.requireNonNull(rawDataFilter)`. This is classified as another statement changed (type 4), as it does not affect the control flow or the output of the method.","There is no Compatibility Issue because both methods `Preconditions.checkNotNull` and `Objects.requireNonNull` serve the same purpose of checking for null references and will throw a NullPointerException if `rawDataFilter` is null. The behavior of the API does not change between versions; thus, it maintains compatibility."
274,<android.widget.Toast: int getGravity()>,29,30,<android.widget.Toast: int getGravity()>,<android.widget.Toast: int getGravity()>,0,"{
    return mTN.mGravity;
}","{
    if (isSystemRenderedTextToast()) {
        Log.e(TAG, ""getGravity() shouldn't be called on text toasts, the result may not reflect"" + "" actual values."");
    }
    return mTN.mGravity;
}",1,"/**
 * Get the location at which the notification should appear on the screen.
 * @see android.view.Gravity
 * @see #getGravity
 */
","/**
 * Get the location at which the notification should appear on the screen.
 *
 * <p><strong>Warning:</strong> Starting from Android {@link Build.VERSION_CODES#R}, for apps
 * targeting API level {@link Build.VERSION_CODES#R} or higher, this method shouldn't be called
 * on text toasts as its return value may not reflect actual value since text toasts are not
 * rendered by the app anymore.
 *
 * @see android.view.Gravity
 * @see #getGravity
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The addition of a conditional check and a logging statement in the late version results in the code change type being 4.,"The newly introduced log statement in the late version does not alter the returned value of the method or change how exceptions are handled. The control flow and the returned value remain unchanged compared to the early version. Therefore, there is no Compatibility Issue."
275,<android.view.textclassifier.TextClassifierEvent.Builder: T setExtras(Bundle)>,29,30,<android.view.textclassifier.TextClassifierEvent.Builder: T setExtras(Bundle)>,<android.view.textclassifier.TextClassifierEvent.Builder: T setExtras(Bundle)>,0,"{
    mExtras = Preconditions.checkNotNull(extras);
    return self();
}","{
    mExtras = Objects.requireNonNull(extras);
    return self();
}",1,"/**
 * Sets a bundle containing non-structured extra information about the event.
 *
 * <p><b>NOTE: </b>Prefer to set only immutable values on the bundle otherwise, avoid
 * updating the internals of this bundle as it may have unexpected consequences on the
 * clients of the built event object. For similar reasons, avoid depending on mutable
 * objects in this bundle.
 */
","/**
 * Sets a bundle containing non-structured extra information about the event.
 *
 * <p><b>NOTE: </b>Prefer to set only immutable values on the bundle otherwise, avoid
 * updating the internals of this bundle as it may have unexpected consequences on the
 * clients of the built event object. For similar reasons, avoid depending on mutable
 * objects in this bundle.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to check for null references has changed from Preconditions.checkNotNull(extras) to Objects.requireNonNull(extras). This is a change in the dependent API, so the code change type is 4,5.","Both Preconditions.checkNotNull() and Objects.requireNonNull() methods throw a NullPointerException when the passed argument is null and are intended to be used for null checking, therefore the behavior of the method will not change from the caller's perspective. Thus, there is no Compatibility Issue, and the CI type is 0."
277,<android.view.inputmethod.InputMethodManager: void closeCurrentInput()>,29,30,<android.view.inputmethod.InputMethodManager: void closeCurrentInput()>,<android.view.inputmethod.InputMethodManager: void closeCurrentInput()>,0,"{
    try {
        mService.hideSoftInput(mClient, HIDE_NOT_ALWAYS, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    synchronized (mH) {
        if (mCurRootView == null || mCurRootView.getView() == null) {
            Log.w(TAG, ""No current root view, ignoring closeCurrentInput()"");
            return;
        }
        try {
            mService.hideSoftInput(mClient, mCurRootView.getView().getWindowToken(), HIDE_NOT_ALWAYS, null);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"2,3,4","1,2",There are several changes in the late implementation:,"- The parameter for 'hideSoftInput()' method has been changed to include 'mCurRootView.getView().getWindowToken()' instead of 'null', which is an other statement changed."
278,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,29,30,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,0,"{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    boolean wakeUpSensor = false;
    // non_wake-up version.
    if (type == Sensor.TYPE_PROXIMITY || type == Sensor.TYPE_SIGNIFICANT_MOTION || type == Sensor.TYPE_TILT_DETECTOR || type == Sensor.TYPE_WAKE_GESTURE || type == Sensor.TYPE_GLANCE_GESTURE || type == Sensor.TYPE_PICK_UP_GESTURE || type == Sensor.TYPE_WRIST_TILT_GESTURE || type == Sensor.TYPE_DYNAMIC_SENSOR_META) {
        wakeUpSensor = true;
    }
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUpSensor)
            return sensor;
    }
    return null;
}","{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    boolean wakeUpSensor = false;
    // non_wake-up version.
    if (type == Sensor.TYPE_PROXIMITY || type == Sensor.TYPE_SIGNIFICANT_MOTION || type == Sensor.TYPE_TILT_DETECTOR || type == Sensor.TYPE_WAKE_GESTURE || type == Sensor.TYPE_GLANCE_GESTURE || type == Sensor.TYPE_PICK_UP_GESTURE || type == Sensor.TYPE_WRIST_TILT_GESTURE || type == Sensor.TYPE_DYNAMIC_SENSOR_META || type == Sensor.TYPE_HINGE_ANGLE) {
        wakeUpSensor = true;
    }
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUpSensor)
            return sensor;
    }
    return null;
}",1,"/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensor matching the requested type if one exists and the application
 * has the necessary permissions, or null otherwise.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
","/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensor matching the requested type if one exists and the application
 * has the necessary permissions, or null otherwise.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed due to the addition of a new condition in the if statement (`type == Sensor.TYPE_HINGE_ANGLE`). This will affect which sensors are considered as wakeUpSensor, and thus the loop may return a different sensor, hence the code change type is 3.","While there is a change to the control dependency, there is no Compatibility Issue since the logic for selecting a sensor is unchanged for the previously checked types. The API is originally designed to select a sensor based on the 'wakeUpSensor' match, which still holds true after the change. The addition of a new sensor type to this logic merely extends the functionality and does not alter the behavior for existing sensor types, thus does not lead to a different return variable for these types; therefore, no CI arises for these existing types. Compatibility Issue may only arise for invocations with `Sensor.TYPE_HINGE_ANGLE` which is new, thus for the types known before the change, the behavior remains compatible."
279,<android.speech.tts.TextToSpeech: Locale getDefaultLanguage()>,29,30,<android.speech.tts.TextToSpeech: Locale getDefaultLanguage()>,<android.speech.tts.TextToSpeech: Locale getDefaultLanguage()>,0,"{
    return runAction(new Action<Locale>() {

        @Override
        public Locale run(ITextToSpeechService service) throws RemoteException {
            String[] defaultLanguage = service.getClientDefaultLanguage();
            return new Locale(defaultLanguage[0], defaultLanguage[1], defaultLanguage[2]);
        }
    }, null, ""getDefaultLanguage"");
}","{
    return runAction((ITextToSpeechService service) -> {
        String[] defaultLanguage = service.getClientDefaultLanguage();
        return new Locale(defaultLanguage[0], defaultLanguage[1], defaultLanguage[2]);
    }, null, ""getDefaultLanguage"");
}",1,"/**
 * Returns a Locale instance describing the language currently being used as the default
 * Text-to-speech language.
 *
 * The locale object returned by this method is NOT a valid one. It has identical form to the
 * one in {@link #getLanguage()}. Please refer to {@link #getLanguage()} for more information.
 *
 * @return language, country (if any) and variant (if any) used by the client stored in a
 * Locale instance, or {@code null} on error.
 * @deprecated As of API level 21, use <code>getDefaultVoice().getLocale()</code> ({@link
 * #getDefaultVoice()})
 */
","/**
 * Returns a Locale instance describing the language currently being used as the default
 * Text-to-speech language.
 *
 * The locale object returned by this method is NOT a valid one. It has identical form to the
 * one in {@link #getLanguage()}. Please refer to {@link #getLanguage()} for more information.
 *
 * @return language, country (if any) and variant (if any) used by the client stored in a
 * Locale instance, or {@code null} on error.
 * @deprecated As of API level 21, use <code>getDefaultVoice().getLocale()</code> ({@link
 * #getDefaultVoice()})
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The method implementation has changed the anonymous inner class to a lambda expression, but the behavior remains the same. So the change type is related to the internal code structure (4) but does not affect the external behavior.",There is no Compatibility Issue since the change from an anonymous inner class to a lambda expression does not alter the output or the exception handling of the method; it's purely a syntactical change which does not impact API users.
281,"<android.app.AppOpsManager: int noteOpNoThrow(String,int,String)>",29,30,"<android.app.AppOpsManager: int noteOpNoThrow(String,int,String)>","<android.app.AppOpsManager: int noteOpNoThrow(String,int,String)>",0,"{
    return noteOpNoThrow(strOpToOp(op), uid, packageName);
}","{
    return noteOpNoThrow(op, uid, packageName, null, null);
}",1,"/**
 * Like {@link #noteOp} but instead of throwing a {@link SecurityException} it
 * returns {@link #MODE_ERRORED}.
 */
","/**
 * @deprecated Use {@link #noteOpNoThrow(String, int, String, String, String)} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API called within noteOpNoThrow has changed between the early and late version, suggesting that the method signature or behavior of the called API could have been altered. The parameters passed to noteOpNoThrow inside the body have changed from (strOpToOp(op), uid, packageName) to (op, uid, packageName, null, null), which indicates a change in the expected parameters and their types. Therefore, the change types are 1 for the return statement and 5 for the dependent API changed.","Since the dependent API noteOpNoThrow has undergone a change in the parameters it accepts, this will potentially lead to a different return value, as the executed operation is likely to be different. The API has been marked as deprecated, but the cause for potential different behavior is due to the parameter changes in the dependent API call. Therefore, the compatibility issue type is 1."
284,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",29,30,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>","<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.insert(url, values);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    return insert(url, values, null);
}",1,"/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row. May return <code>null</code> if the underlying
 * content provider returns <code>null</code>, or if it crashes.
 */
","/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row. May return <code>null</code> if the underlying
 * content provider returns <code>null</code>, or if it crashes.
 */
",-1,"[@Override, @Nullable]",[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The late version of the API redirects the implementation to another overload of the insert method (insert(url, values, null)), which is a form of dependent API change. Hence, we have a code change type 5.","There is no direct compatibility issue caused by the code change since it just delegates the call to another method. The behavior would only differ if the behavior of 'insert(url, values, null)' has changed between the two versions, which is not indicated here. Hence, there is no direct evidence of CI, so the CI type is 0."
287,<android.view.textclassifier.TextClassificationConstants: boolean isSmartSelectionAnimationEnabled()>,29,30,<android.view.textclassifier.TextClassificationConstants: boolean isSmartSelectionAnimationEnabled()>,<android.view.textclassifier.TextClassificationConstants: boolean isSmartSelectionAnimationEnabled()>,0,"{
    return mConfigParser.getBoolean(SMART_SELECT_ANIMATION_ENABLED, SMART_SELECT_ANIMATION_ENABLED_DEFAULT);
}","{
    return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_TEXTCLASSIFIER, SMART_SELECT_ANIMATION_ENABLED, SMART_SELECT_ANIMATION_ENABLED_DEFAULT);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The API used to retrieve the boolean value has changed from mConfigParser.getBoolean() to DeviceConfig.getBoolean() which is a different dependent API, so the code change type is 5.","The change from one configuration parser to another does not inherently mean a CI as long as the contract of what they return under the same circumstances does not change. Since there's no indication of a change in behavior, there is no Compatibility Issue, therefore the CI is type 0."
288,<android.app.NotificationChannel: int hashCode()>,29,30,<android.app.NotificationChannel: int hashCode()>,<android.app.NotificationChannel: int hashCode()>,0,"{
    int result = Objects.hash(getId(), getName(), mDesc, getImportance(), mBypassDnd, getLockscreenVisibility(), getSound(), mLights, getLightColor(), getUserLockedFields(), isFgServiceShown(), mVibrationEnabled, mShowBadge, isDeleted(), getGroup(), getAudioAttributes(), isBlockableSystem(), mAllowBubbles, mImportanceLockedByOEM, mImportanceLockedDefaultApp);
    result = 31 * result + Arrays.hashCode(mVibration);
    return result;
}","{
    int result = Objects.hash(getId(), getName(), mDesc, getImportance(), mBypassDnd, getLockscreenVisibility(), getSound(), mLights, getLightColor(), getUserLockedFields(), isFgServiceShown(), mVibrationEnabled, mShowBadge, isDeleted(), getGroup(), getAudioAttributes(), isBlockable(), mAllowBubbles, mImportanceLockedByOEM, mImportanceLockedDefaultApp, mOriginalImportance, mParentId, mConversationId, mDemoted, mImportantConvo);
    result = 31 * result + Arrays.hashCode(mVibration);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() implementation modified the parameters passed to Objects.hash method by adding mOriginalImportance, mParentId, mConversationId, mDemoted, and mImportantConvo. The rest of the method body has remained the same. Therefore the code has changed in both the ""return statement"" and ""other statement,"" so the change type is 1,4.","Since the list of parameters passed to Objects.hash has been expanded, the hash code generated by this method can be different for the same object before and after the modification, even if other properties of that object have not changed. As a result, objects that were considered equal in terms of their hash code in the early version may not be considered equal in the late version, which could potentially affect collections like HashMap or HashSet that rely on proper implementation of hashCode. The CI type is thus 1."
289,"<android.view.ViewGroup: boolean requestFocus(int,Rect)>",29,30,"<android.view.ViewGroup: boolean requestFocus(int,Rect)>","<android.view.ViewGroup: boolean requestFocus(int,Rect)>",0,"{
    if (DBG) {
        System.out.println(this + "" ViewGroup.requestFocus direction="" + direction);
    }
    int descendantFocusability = getDescendantFocusability();
    boolean result;
    switch(descendantFocusability) {
        case FOCUS_BLOCK_DESCENDANTS:
            result = super.requestFocus(direction, previouslyFocusedRect);
            break;
        case FOCUS_BEFORE_DESCENDANTS:
            {
                final boolean took = super.requestFocus(direction, previouslyFocusedRect);
                result = took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
                break;
            }
        case FOCUS_AFTER_DESCENDANTS:
            {
                final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                result = took ? took : super.requestFocus(direction, previouslyFocusedRect);
                break;
            }
        default:
            throw new IllegalStateException(""descendant focusability must be "" + ""one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "" + ""but is "" + descendantFocusability);
    }
    if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS) == 0)) {
        mPrivateFlags |= PFLAG_WANTS_FOCUS;
    }
    return result;
}","{
    if (DBG) {
        System.out.println(this + "" ViewGroup.requestFocus direction="" + direction);
    }
    int descendantFocusability = getDescendantFocusability();
    boolean result;
    switch(descendantFocusability) {
        case FOCUS_BLOCK_DESCENDANTS:
            result = super.requestFocus(direction, previouslyFocusedRect);
            break;
        case FOCUS_BEFORE_DESCENDANTS:
            {
                final boolean took = super.requestFocus(direction, previouslyFocusedRect);
                result = took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
                break;
            }
        case FOCUS_AFTER_DESCENDANTS:
            {
                final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                result = took ? took : super.requestFocus(direction, previouslyFocusedRect);
                break;
            }
        default:
            throw new IllegalStateException(""descendant focusability must be one of FOCUS_BEFORE_DESCENDANTS,"" + "" FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS but is "" + descendantFocusability);
    }
    if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS) == 0)) {
        mPrivateFlags |= PFLAG_WANTS_FOCUS;
    }
    return result;
}",1,"/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
","/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is in the string inside the IllegalStateException's message. This is neither a control flow change, a return value change, an exception throwing change nor a dependent API change but a string value change inside the exception message which is categorized as 4 'Other statement changed'.","There is ""No Compatibility Issue"" because the only change is in the exception message text, which does not affect the API's behavior. The return value and the exceptions thrown remain unchanged in both versions."
291,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,29,30,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,0,"{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery(getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery(getOpPackageName(), getAttributionTag());
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
","/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed in which the dependent API mService.startDiscovery() includes an additional parameter (getAttributionTag()) in the late version. Therefore, the code change type is 5.","There is no compatibility issue because the signature of the method hasn't changed, and the method behavior is the same from the perspective of the API consumer. Assuming the addition of the new parameter (getAttributionTag()) does not change the high-level behavior of startDiscovery or cause it to throw new exceptions, the code will not lead to any compatibility issues. The main functionality of starting a discovery on the Bluetooth adapter remains unchanged; therefore, there is no CI detected."
292,<android.util.ArraySet: void clear()>,29,30,<android.util.ArraySet: void clear()>,<android.util.ArraySet: void clear()>,0,"{
    if (mSize != 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    }
}","{
    if (mSize != 0) {
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        final int osize = mSize;
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
        freeArrays(ohashes, oarray, osize);
    }
    if (mSize != 0) {
        throw new ConcurrentModificationException();
    }
}",1,"/**
 * Make the array map empty.  All storage is released.
 */
","/**
 * Make the array map empty.  All storage is released.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change involves moving the freeArrays() call to after reassigning mHashes, mArray, and mSize, as well as introducing an additional 'if' block which checks mSize and throws a ConcurrentModificationException. The changed code involves a control dependency change because of the newly added if statement and an other statement changed because of the modification in the order of operations.","Although there is a control dependency change and an introduction of a new throw statement, neither of these would constitute a compatibility issue from the perspective of the public API behavior because:"
293,<android.view.ViewGroup: boolean notifyChildOfDragStart(View)>,29,30,<android.view.ViewGroup: boolean notifyChildOfDragStart(View)>,<android.view.ViewGroup: boolean notifyChildOfDragStart(View)>,0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(View.VIEW_LOG_TAG, ""Sending drag-started to view: "" + child);
    }
    final float tx = mCurrentDragStartEvent.mX;
    final float ty = mCurrentDragStartEvent.mY;
    final float[] point = getTempPoint();
    point[0] = tx;
    point[1] = ty;
    transformPointToViewLocal(point, child);
    mCurrentDragStartEvent.mX = point[0];
    mCurrentDragStartEvent.mY = point[1];
    final boolean canAccept = child.dispatchDragEvent(mCurrentDragStartEvent);
    mCurrentDragStartEvent.mX = tx;
    mCurrentDragStartEvent.mY = ty;
    mCurrentDragStartEvent.mEventHandlerWasCalled = false;
    if (canAccept) {
        mChildrenInterestedInDrag.add(child);
        if (!child.canAcceptDrag()) {
            child.mPrivateFlags2 |= View.PFLAG2_DRAG_CAN_ACCEPT;
            child.refreshDrawableState();
        }
    }
    return canAccept;
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(View.VIEW_LOG_TAG, ""Sending drag-started to view: "" + child);
    }
    final float tx = mCurrentDragStartEvent.mX;
    final float ty = mCurrentDragStartEvent.mY;
    final float[] point = getTempLocationF();
    point[0] = tx;
    point[1] = ty;
    transformPointToViewLocal(point, child);
    mCurrentDragStartEvent.mX = point[0];
    mCurrentDragStartEvent.mY = point[1];
    final boolean canAccept = child.dispatchDragEvent(mCurrentDragStartEvent);
    mCurrentDragStartEvent.mX = tx;
    mCurrentDragStartEvent.mY = ty;
    mCurrentDragStartEvent.mEventHandlerWasCalled = false;
    if (canAccept) {
        mChildrenInterestedInDrag.add(child);
        if (!child.canAcceptDrag()) {
            child.mPrivateFlags2 |= View.PFLAG2_DRAG_CAN_ACCEPT;
            child.refreshDrawableState();
        }
    }
    return canAccept;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method used to allocate the array for 'point' has changed from getTempPoint() to getTempLocationF(), this is classified as Other statement changed.","There is no Compatibility Issue, because the modification does not affect the return value or exception handling of the method; it only changes how the temporary float array is obtained, assuming both methods return a float array that can be used interchangeably within this context."
294,<android.net.StaticIpConfiguration.Builder: StaticIpConfiguration build()>,29,30,<android.net.StaticIpConfiguration.Builder: StaticIpConfiguration build()>,<android.net.StaticIpConfiguration.Builder: StaticIpConfiguration build()>,0,"{
    final StaticIpConfiguration config = new StaticIpConfiguration();
    config.ipAddress = mIpAddress;
    config.gateway = mGateway;
    for (InetAddress server : mDnsServers) {
        config.dnsServers.add(server);
    }
    config.domains = mDomains;
    return config;
}","{
    final StaticIpConfiguration config = new StaticIpConfiguration();
    config.ipAddress = mIpAddress;
    config.gateway = mGateway;
    if (mDnsServers != null) {
        for (InetAddress server : mDnsServers) {
            config.dnsServers.add(server);
        }
    }
    config.domains = mDomains;
    return config;
}",1,"/**
 * Create a {@link StaticIpConfiguration} from the parameters in this {@link Builder}.
 * @return The newly created StaticIpConfiguration.
 */
","/**
 * Create a {@link StaticIpConfiguration} from the parameters in this {@link Builder}.
 * @return The newly created StaticIpConfiguration.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,3,0,"There is an introduction of a new control flow that checks if mDnsServers is not null before the for-loop, so the code change type is 3.","Since the introduced control dependency simply adds a null check before iterating over the DNS servers, it does not affect the return type or value assuming mDnsServers is expected to be non-null as the normative case. It's a defensive programming practice to prevent potential `NullPointerException`. If mDnsServers were to be null in the early version, it would lead to a `NullPointerException`, and in the late version, it would just skip the loop. However, given that both versions have the @NonNull annotation, and assuming mDnsServers is expected to be non-null by contract, there should be no observed behavior change for cases adhering to the contract. Hence, there is no compatibility issue caused by this change."
295,<android.webkit.MimeTypeMap: String getMimeTypeFromExtension(String)>,29,30,<android.webkit.MimeTypeMap: String getMimeTypeFromExtension(String)>,<android.webkit.MimeTypeMap: String getMimeTypeFromExtension(String)>,0,"{
    return MimeUtils.guessMimeTypeFromExtension(extension);
}","{
    return MimeMap.getDefault().guessMimeTypeFromExtension(extension);
}",1,"/**
 * Return the MIME type for the given extension.
 * @param extension A file extension without the leading '.'
 * @return The MIME type for the given extension or {@code null} if there is none.
 */
","/**
 * Return the MIME type for the given extension.
 * @param extension A file extension without the leading '.'
 * @return The MIME type for the given extension or {@code null} if there is none.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed to use MimeMap.getDefault().guessMimeTypeFromExtension(extension) instead of MimeUtils.guessMimeTypeFromExtension(extension). Considering that the method called within the return statement has changed, this is classified as change type 5 (Dependent API changed).","There is no Compatibility Issue detected as long as the dependent API MimeMap.getDefault().guessMimeTypeFromExtension(extension) behaves the same as the previous API MimeUtils.guessMimeTypeFromExtension(extension). Since there is no indication that the behavior of the dependent API has changed, the CI type is classified as 0 (No Compatibility Issue)."
296,"<android.app.Activity: void performResume(boolean,String)>",29,30,"<android.app.Activity: void performResume(boolean,String)>","<android.app.Activity: void performResume(boolean,String)>",0,"{
    dispatchActivityPreResumed();
    performRestart(true, /* start */
    reason);
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    if (mAutoFillResetNeeded) {
        // When Activity is destroyed in paused state, and relaunch activity, there will be
        // extra onResume and onPause event,  ignore the first onResume and onPause.
        // see ActivityThread.handleRelaunchActivity()
        mAutoFillIgnoreFirstResumePause = followedByPause;
        if (mAutoFillIgnoreFirstResumePause && DEBUG_LIFECYCLE) {
            Slog.v(TAG, ""autofill will ignore first pause when relaunching "" + this);
        }
    }
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    writeEventLog(LOG_AM_ON_RESUME_CALLED, reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // invisible activities must be finished before onResume() completes
    if (!mVisibleFromClient && !mFinished) {
        Log.w(TAG, ""An activity without a UI must call finish() before onResume() completes"");
        if (getApplicationInfo().targetSdkVersion > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            throw new IllegalStateException(""Activity "" + mComponent.toShortString() + "" did not call finish() prior to onResume() completing"");
        }
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
    dispatchActivityPostResumed();
}","{
    dispatchActivityPreResumed();
    performRestart(true, /* start */
    reason);
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    if (mAutoFillResetNeeded) {
        // When Activity is destroyed in paused state, and relaunch activity, there will be
        // extra onResume and onPause event,  ignore the first onResume and onPause.
        // see ActivityThread.handleRelaunchActivity()
        mAutoFillIgnoreFirstResumePause = followedByPause;
        if (mAutoFillIgnoreFirstResumePause && DEBUG_LIFECYCLE) {
            Slog.v(TAG, ""autofill will ignore first pause when relaunching "" + this);
        }
    }
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    EventLogTags.writeWmOnResumeCalled(mIdent, getComponentName().getClassName(), reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // invisible activities must be finished before onResume() completes
    if (!mVisibleFromClient && !mFinished) {
        Log.w(TAG, ""An activity without a UI must call finish() before onResume() completes"");
        if (getApplicationInfo().targetSdkVersion > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            throw new IllegalStateException(""Activity "" + mComponent.toShortString() + "" did not call finish() prior to onResume() completing"");
        }
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
    dispatchActivityPostResumed();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the logging statement from writeEventLog(LOG_AM_ON_RESUME_CALLED, reason) to EventLogTags.writeWmOnResumeCalled(mIdent, getComponentName().getClassName(), reason). This is neither a return statement, an exception handling statement, nor a control dependency change, so it is classified as an other statement changed.","The change in the logging method does not affect the execution flow or the output of the method itself, hence there is no compatibility issue involved due to this change."
297,"<android.content.ContentProvider: boolean checkUser(int,int,Context)>",29,30,"<android.content.ContentProvider: boolean checkUser(int,int,Context)>","<android.content.ContentProvider: boolean checkUser(int,int,Context)>",0,"{
    return UserHandle.getUserId(uid) == context.getUserId() || mSingleUser || context.checkPermission(INTERACT_ACROSS_USERS, pid, uid) == PERMISSION_GRANTED;
}","{
    if (UserHandle.getUserId(uid) == context.getUserId() || mSingleUser) {
        return true;
    }
    return context.checkPermission(INTERACT_ACROSS_USERS, pid, uid) == PERMISSION_GRANTED || context.checkPermission(INTERACT_ACROSS_USERS_FULL, pid, uid) == PERMISSION_GRANTED;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The early version of the method has one single return statement with a logical OR condition. The late version has changed to use an if statement to separate the return of 'true' and has a new logical OR condition for checking an additional permission (INTERACT_ACROSS_USERS_FULL). This change can affect the return statement and the control dependency, so the change types are 1,3.","The early version method returns 'true' if any conditions of the logical OR are met. The late version changes the structure and allows for an additional condition (checkPermission for INTERACT_ACROSS_USERS_FULL) to potentially return 'true'. This adds an extra scenario where the method can return 'true', different from the earlier version, potentially leading to a different boolean result for the same inputs. Thus, the CI type is 1."
298,<android.view.textclassifier.SelectionEvent: String toString()>,29,30,<android.view.textclassifier.SelectionEvent: String toString()>,<android.view.textclassifier.SelectionEvent: String toString()>,0,"{
    return String.format(Locale.US, ""SelectionEvent {absoluteStart=%d, absoluteEnd=%d, eventType=%d, entityType=%s, "" + ""widgetVersion=%s, packageName=%s, widgetType=%s, invocationMethod=%s, "" + ""resultId=%s, eventTime=%d, durationSinceSessionStart=%d, "" + ""durationSincePreviousEvent=%d, eventIndex=%d,"" + ""sessionId=%s, start=%d, end=%d, smartStart=%d, smartEnd=%d}"", mAbsoluteStart, mAbsoluteEnd, mEventType, mEntityType, mWidgetVersion, mPackageName, mWidgetType, mInvocationMethod, mResultId, mEventTime, mDurationSinceSessionStart, mDurationSincePreviousEvent, mEventIndex, mSessionId, mStart, mEnd, mSmartStart, mSmartEnd);
}","{
    return String.format(Locale.US, ""SelectionEvent {absoluteStart=%d, absoluteEnd=%d, eventType=%d, entityType=%s, "" + ""widgetVersion=%s, packageName=%s, widgetType=%s, invocationMethod=%s, "" + ""resultId=%s, eventTime=%d, durationSinceSessionStart=%d, "" + ""durationSincePreviousEvent=%d, eventIndex=%d,"" + ""sessionId=%s, start=%d, end=%d, smartStart=%d, smartEnd=%d, "" + ""systemTcMetadata=%s}"", mAbsoluteStart, mAbsoluteEnd, mEventType, mEntityType, mWidgetVersion, mPackageName, mWidgetType, mInvocationMethod, mResultId, mEventTime, mDurationSinceSessionStart, mDurationSincePreviousEvent, mEventIndex, mSessionId, mStart, mEnd, mSmartStart, mSmartEnd, mSystemTcMetadata);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There was an addition to the format string in String.format() call, which now includes ""systemTcMetadata=%s"" and a new parameter mSystemTcMetadata was added. This amounts to an 'Other statement changed'.","Because of the additional formatted argument, the returned string will contain more information which could potentially affect the behavior of programs relying on the exact format of the string. Therefore, the CI type is 1."
302,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",29,30,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The method name `broadcastIntent` is changed to `broadcastIntentWithFeature` with the addition of a new parameter `getAttributionTag()`. This is a change in a dependent API, hence code change type is 5.","Although a dependent API has changed, the API change won't result in different behavior with respect to exception throwing or return values/types, since it is an internal method call without affecting the functional contract of `sendStickyBroadcastAsUser`. Thus, no compatibility issue is likely to arise, hence the CI type is 0."
303,<android.app.ActivityTransitionState: void enterReady(Activity)>,29,30,<android.app.ActivityTransitionState: void enterReady(Activity)>,<android.app.ActivityTransitionState: void enterReady(Activity)>,0,"{
    if (mEnterActivityOptions == null || mIsEnterTriggered) {
        return;
    }
    mIsEnterTriggered = true;
    mHasExited = false;
    ArrayList<String> sharedElementNames = mEnterActivityOptions.getSharedElementNames();
    ResultReceiver resultReceiver = mEnterActivityOptions.getResultReceiver();
    if (mEnterActivityOptions.isReturning()) {
        restoreExitedViews();
        activity.getWindow().getDecorView().setVisibility(View.VISIBLE);
    }
    mEnterTransitionCoordinator = new EnterTransitionCoordinator(activity, resultReceiver, sharedElementNames, mEnterActivityOptions.isReturning(), mEnterActivityOptions.isCrossTask());
    if (mEnterActivityOptions.isCrossTask()) {
        mExitingFrom = new ArrayList<>(mEnterActivityOptions.getSharedElementNames());
        mExitingTo = new ArrayList<>(mEnterActivityOptions.getSharedElementNames());
    }
    if (!mIsEnterPostponed) {
        startEnter();
    }
}","{
    if (mEnterActivityOptions == null || mIsEnterTriggered) {
        return;
    }
    mIsEnterTriggered = true;
    mHasExited = false;
    ArrayList<String> sharedElementNames = mEnterActivityOptions.getSharedElementNames();
    ResultReceiver resultReceiver = mEnterActivityOptions.getResultReceiver();
    final boolean isReturning = mEnterActivityOptions.isReturning();
    if (isReturning) {
        restoreExitedViews();
        activity.getWindow().getDecorView().setVisibility(View.VISIBLE);
    }
    mEnterTransitionCoordinator = new EnterTransitionCoordinator(activity, resultReceiver, sharedElementNames, mEnterActivityOptions.isReturning(), mEnterActivityOptions.isCrossTask());
    if (mEnterActivityOptions.isCrossTask()) {
        mExitingFrom = new ArrayList<>(mEnterActivityOptions.getSharedElementNames());
        mExitingTo = new ArrayList<>(mEnterActivityOptions.getSharedElementNames());
    }
    if (!mIsEnterPostponed) {
        startEnter();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change consists of the introduction of a local variable `isReturning` to store the result of `mEnterActivityOptions.isReturning()` before it is used in the if-statement, instead of calling the method twice. Therefore, the change type is 4.","Since the logic and control flow of the method have not changed and the method `isReturning()` is still called once before the if-statement (albeit stored in a variable now), there are no changes that affect returned values or thrown exceptions. Thus, there is no compatibility issue (CI type is 0)."
305,<android.net.TrafficStats: long getUidTxPackets(int)>,29,30,<android.net.TrafficStats: long getUidTxPackets(int)>,<android.net.TrafficStats: long getUidTxPackets(int)>,0,"{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_TX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}","{
    try {
        return getStatsService().getUidStats(uid, TYPE_TX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency change occurs because the 'if-else' statement checking the uid has been removed. In the early version, there is a condition checking the callingUid which might lead to returning UNSUPPORTED for certain conditions.","With the removal of the 'if-else' statement checking the uid, there is a potential compatibility issue since in some cases where the callingUid is not SYSTEM_UID or the same as the uid parameter, the method previously returned UNSUPPORTED, while in the late version it doesn't check this condition and attempts to fetch the statistic regardless of the callingUid. Thus, this could lead to the API returning different values in the late version as opposed to the early version under certain conditions. The CI type is 1."
306,"<android.app.slice.SliceManager: Slice bindSlice(Uri,Set<SliceSpec>)>",29,30,"<android.app.slice.SliceManager: Slice bindSlice(Uri,Set<SliceSpec>)>","<android.app.slice.SliceManager: Slice bindSlice(Uri,Set<SliceSpec>)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    ContentResolver resolver = mContext.getContentResolver();
    try (ContentProviderClient provider = resolver.acquireUnstableContentProviderClient(uri)) {
        if (provider == null) {
            Log.w(TAG, String.format(""Unknown URI: %s"", uri));
            return null;
        }
        Bundle extras = new Bundle();
        extras.putParcelable(SliceProvider.EXTRA_BIND_URI, uri);
        extras.putParcelableArrayList(SliceProvider.EXTRA_SUPPORTED_SPECS, new ArrayList<>(supportedSpecs));
        final Bundle res = provider.call(SliceProvider.METHOD_SLICE, null, extras);
        Bundle.setDefusable(res, true);
        if (res == null) {
            return null;
        }
        return res.getParcelable(SliceProvider.EXTRA_SLICE);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    ContentResolver resolver = mContext.getContentResolver();
    try (ContentProviderClient provider = resolver.acquireUnstableContentProviderClient(uri)) {
        if (provider == null) {
            Log.w(TAG, String.format(""Unknown URI: %s"", uri));
            return null;
        }
        Bundle extras = new Bundle();
        extras.putParcelable(SliceProvider.EXTRA_BIND_URI, uri);
        extras.putParcelableArrayList(SliceProvider.EXTRA_SUPPORTED_SPECS, new ArrayList<>(supportedSpecs));
        final Bundle res = provider.call(SliceProvider.METHOD_SLICE, null, extras);
        Bundle.setDefusable(res, true);
        if (res == null) {
            return null;
        }
        return res.getParcelable(SliceProvider.EXTRA_SLICE);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    }
}",1,"/**
 * Turns a slice Uri into slice content.
 *
 * @param uri The URI to a slice provider
 * @param supportedSpecs List of supported specs.
 * @return The Slice provided by the app or null if none is given.
 * @see Slice
 */
","/**
 * Turns a slice Uri into slice content.
 *
 * @param uri The URI to a slice provider
 * @param supportedSpecs List of supported specs.
 * @return The Slice provided by the app or null if none is given.
 * @see Slice
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The code has changed from using Preconditions.checkNotNull to Objects.requireNonNull for input validation, which are essentially equivalent in functionality but different in implementation, resulting in change type 4.","There is no Compatibility Issue here as both methods have the same purpose and would throw a similar exception if the `uri` is null. Therefore, the behavior of the API remains identical, and users of the API will not face any new exceptions or return types/values."
307,"<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>",29,30,"<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>","<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.sendAppPrivateCommand(view, action, data);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""APP PRIVATE COMMAND "" + action + "": "" + data);
            mCurMethod.appPrivateCommand(action, data);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.sendAppPrivateCommand(view, action, data);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""APP PRIVATE COMMAND "" + action + "": "" + data);
            mCurMethod.appPrivateCommand(action, data);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}",1,"/**
 * Call {@link InputMethodSession#appPrivateCommand(String, Bundle)
 * InputMethodSession.appPrivateCommand()} on the current Input Method.
 * @param view Optional View that is sending the command, or null if
 * you want to send the command regardless of the view that is attached
 * to the input method.
 * @param action Name of the command to be performed.  This <em>must</em>
 * be a scoped name, i.e. prefixed with a package name you own, so that
 * different developers will not create conflicting commands.
 * @param data Any data to include with the command.
 */
","/**
 * Call {@link InputMethodSession#appPrivateCommand(String, Bundle)
 * InputMethodSession.appPrivateCommand()} on the current Input Method.
 * @param view Optional View that is sending the command, or null if
 * you want to send the command regardless of the view that is attached
 * to the input method.
 * @param action Name of the command to be performed.  This <em>must</em>
 * be a scoped name, i.e. prefixed with a package name you own, so that
 * different developers will not create conflicting commands.
 * @param data Any data to include with the command.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The condition inside the synchronized block has changed from checking `mServedView` and a proxy condition to a method call `hasServedByInputMethodLocked(view)`. Also, there are no changes in return statements, exception handling, or external API calls. Therefore, the code change types are 3 (Control dependency change) and 4 (Other statement changed).","The change is a refactoring of condition checks into a separate method, with no change in external behavior. It may simplify the readability or maintenance of the code, but does not inherently change the behavior that the API guarantees to the caller. As such, it does not represent a Compatibility Issue."
308,"<android.content.pm.LauncherApps: void startPackageInstallerSessionDetailsActivity(SessionInfo,Rect,Bundle)>",29,30,"<android.content.pm.LauncherApps: void startPackageInstallerSessionDetailsActivity(SessionInfo,Rect,Bundle)>","<android.content.pm.LauncherApps: void startPackageInstallerSessionDetailsActivity(SessionInfo,Rect,Bundle)>",0,"{
    try {
        mService.startSessionDetailsActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), sessionInfo, sourceBounds, opts, sessionInfo.getUser());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    try {
        mService.startSessionDetailsActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), mContext.getAttributionTag(), sessionInfo, sourceBounds, opts, sessionInfo.getUser());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts an activity to show the details of the specified session.
 *
 * @param sessionInfo The SessionInfo of the session
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
","/**
 * Starts an activity to show the details of the specified session.
 *
 * @param sessionInfo The SessionInfo of the session
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the method call within the try block, by adding one more parameter, mContext.getAttributionTag(), to the list of arguments passed to mService.startSessionDetailsActivityAsUser(), so the code change type is 4,5.","Despite the additional parameter in the method call, since the exception handling has not changed and there are no new return statements or control flow changes, there is no indication that this alteration will change the behavior of the method with respect to the return value or the exceptions it throws. Therefore, there is no Compatibility Issue, and the CI type is 0."
311,<android.text.format.DateUtils: boolean isToday(long)>,29,30,<android.text.format.DateUtils: boolean isToday(long)>,<android.text.format.DateUtils: boolean isToday(long)>,0,"{
    Time time = new Time();
    time.set(when);
    int thenYear = time.year;
    int thenMonth = time.month;
    int thenMonthDay = time.monthDay;
    time.set(System.currentTimeMillis());
    return (thenYear == time.year) && (thenMonth == time.month) && (thenMonthDay == time.monthDay);
}","{
    return isSameDate(when, System.currentTimeMillis());
}",1,"/**
 * @return true if the supplied when is today else false
 */
","/**
 * @return true if the supplied when is today else false
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the method has significantly changed, with the logic of determining if the given time represents today being extracted to another method called isSameDate. So the code change types are 4 and 5.","Since the logic to check if the given time is today is now delegated to a different method, the return value of the method could potentially change if the implementation of isSameDate behaves differently compared to the inlined code from the early version. This could cause different return values, so the CI type is 1."
313,"<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>",29,30,"<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>","<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>",0,"{
    logErrorForInvalidProfileAccess(user);
    try {
        mService.showAppDetailsAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        mService.showAppDetailsAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), mContext.getAttributionTag(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts the settings activity to show the application details for a
 * package in the specified profile.
 *
 * @param component The ComponentName of the package to launch settings for.
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
","/**
 * Starts the settings activity to show the application details for a
 * package in the specified profile.
 *
 * @param component The ComponentName of the package to launch settings for.
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"A new parameter mContext.getAttributionTag() has been added to the method call within the try block, which indicates a change in the method signature that the current API depends on, therefore the change type is 4,5.","The added parameter does not change the return type or the exceptions that the method throws, so there is no potential Compatibility Issue—it remains void and throws the same checked exception, which is handled in the same way. Thus, the CI type is 0."
314,<android.speech.tts.TextToSpeech: Voice getVoice()>,29,30,<android.speech.tts.TextToSpeech: Voice getVoice()>,<android.speech.tts.TextToSpeech: Voice getVoice()>,0,"{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String voiceName = mParams.getString(Engine.KEY_PARAM_VOICE_NAME, """");
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            return getVoice(service, voiceName);
        }
    }, null, ""getVoice"");
}","{
    return runAction((ITextToSpeechService service) -> {
        String voiceName = mParams.getString(Engine.KEY_PARAM_VOICE_NAME, """");
        if (TextUtils.isEmpty(voiceName)) {
            return null;
        }
        return getVoice(service, voiceName);
    }, null, ""getVoice"");
}",1,"/**
 * Returns a Voice instance describing the voice currently being used for synthesis
 * requests sent to the TextToSpeech engine.
 *
 * @return Voice instance used by the client, or {@code null} if not set or on error.
 *
 * @see #getVoices
 * @see #setVoice
 * @see Voice
 */
","/**
 * Returns a Voice instance describing the voice currently being used for synthesis
 * requests sent to the TextToSpeech engine.
 *
 * @return Voice instance used by the client, or {@code null} if not set or on error.
 *
 * @see #getVoices
 * @see #setVoice
 * @see Voice
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation code has changed from an anonymous inner class to a lambda expression. This is a change in the syntax that does not affect the API's behavior, so the code change type is 4.","The change from using an anonymous inner class to a lambda expression does not alter the functionality of the method or the value it returns. There is no change in control flow, exception handling, or return statement, and no dependent API has been altered, thus there is no Compatibility Issue."
315,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,29,30,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,0,"{
    if (mInputMethodSession == null) {
        // for cases below.
        switch(msg.what) {
            case DO_UPDATE_SELECTION:
            case DO_APP_PRIVATE_COMMAND:
                {
                    SomeArgs args = (SomeArgs) msg.obj;
                    args.recycle();
                }
        }
        return;
    }
    switch(msg.what) {
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_UPDATE_CURSOR_ANCHOR_INFO:
            {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
        case DO_NOTIFY_IME_HIDDEN:
            {
                mInputMethodSession.notifyImeHidden();
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    if (mInputMethodSession == null) {
        // for cases below.
        switch(msg.what) {
            case DO_UPDATE_SELECTION:
            case DO_APP_PRIVATE_COMMAND:
                {
                    SomeArgs args = (SomeArgs) msg.obj;
                    args.recycle();
                }
        }
        return;
    }
    switch(msg.what) {
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_UPDATE_CURSOR_ANCHOR_INFO:
            {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
        case DO_NOTIFY_IME_HIDDEN:
            {
                mInputMethodSession.notifyImeHidden();
                return;
            }
        case DO_REMOVE_IME_SURFACE:
            {
                mInputMethodSession.removeImeSurface();
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",0,"There is a case added (DO_REMOVE_IME_SURFACE) in the switch statement and a new method call mInputMethodSession.removeImeSurface(), which is a control dependency change, and a new return statement for this control branch which is a return statement change. Hence, the change types are 1,3.","There is no Compatibility Issue caused by the changes. The additional case is handling a new message code, which will not affect existing functionality or change the behavior of the API when dealing with the message codes that were already handled. It also does not throw any new exceptions; it provides more functionality by handling a previously unhandled message, so there is no impact on existing clients using the API. Therefore, the CI type is 0."
316,"<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>",29,30,"<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>","<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>",0,"{
    try {
        return mService.checkOperationRaw(strOpToOp(op), uid, packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return unsafeCheckOpRawNoThrow(strOpToOp(op), uid, packageName);
}",1,"/**
 * Like {@link #unsafeCheckOpNoThrow(String, int, String)} but returns the <em>raw</em>
 * mode associated with the op. Does not throw a security exception, does not translate
 * {@link #MODE_FOREGROUND}.
 */
","/**
 * Like {@link #unsafeCheckOpNoThrow(String, int, String)} but returns the <em>raw</em>
 * mode associated with the op. Does not throw a security exception, does not translate
 * {@link #MODE_FOREGROUND}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change involves changing the implementation from a direct call to ""mService.checkOperationRaw"" to a recursive self-call with the same method name and parameters. Therefore, the change type is 4, as the statement calling the method has changed, and 5 because it indicates a refactoring which changes the flow but doesn't affect the external API behavior.","The late version of the method results in a recursive self-call which will eventually cause a StackOverflowError due to infinite recursion. However, since this is a clear bug, it's unlikely that this is the actual intended new implementation for the method. Assuming this is an error, the late version does not introduce any logical behavior change that would affect existing clients of this API. Clients calling the early version would never enter an infinite recursion and would get their result or an exception properly. Therefore, there is no Compatibility Issue in terms of the intended functionality. If this recursive call were part of a design, it would be a significant bug rather than a compatibility concern."
318,<android.net.Uri.Part: Part readFrom(Parcel)>,29,30,<android.net.Uri.Part: Part readFrom(Parcel)>,<android.net.Uri.Part: Part readFrom(Parcel)>,0,"{
    int representation = parcel.readInt();
    switch(representation) {
        case Representation.BOTH:
            return from(parcel.readString(), parcel.readString());
        case Representation.ENCODED:
            return fromEncoded(parcel.readString());
        case Representation.DECODED:
            return fromDecoded(parcel.readString());
        default:
            throw new IllegalArgumentException(""Unknown representation: "" + representation);
    }
}","{
    int representation = parcel.readInt();
    String value = parcel.readString8();
    switch(representation) {
        case REPRESENTATION_ENCODED:
            return fromEncoded(value);
        case REPRESENTATION_DECODED:
            return fromDecoded(value);
        default:
            throw new IllegalArgumentException(""Unknown representation: "" + representation);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method switched from using parcel.readString() to parcel.readString8(), which potentially changes how the data is read from the Parcel. Additionally, the enumeration constants used in the switch statement have changed (e.g., from Representation.BOTH to REPRESENTATION_ENCODED and REPRESENTATION_DECODED). The default case for the switch statement is now handling unknown representations differently. Since the early version includes a case for Representation.BOTH that calls from() with two arguments, and this case is not present in the late version, this constitutes a change in control dependency, and also since a method readString8() is introduced and we don't know whether the behavior of readString() and readString8() is the same, it's also considered a change in dependent API. Furthermore, because different enumeration constants are used and different method calls are potentially being made, this would also be classified as ""Other statement changed"".","Because the early version includes a case for handling the BOTH representation, and this case is removed in the late version, the behavior of the API can differ if this situation occurs; the late version may throw an IllegalArgumentException instead. The omission of this case means that if the BOTH representation was intended to be consumed, the late version will no longer handle it correctly. Additionally, the switch to readString8() could potentially affect the interpretation of string data, which would also cause different return values. Hence, this constitutes a compatibility issue as the returned Part could be different because of the handle of inputs and the interpretation of the Parcel contents."
320,<android.security.keystore.recovery.WrappedApplicationKey.Builder: WrappedApplicationKey build()>,29,30,<android.security.keystore.recovery.WrappedApplicationKey.Builder: WrappedApplicationKey build()>,<android.security.keystore.recovery.WrappedApplicationKey.Builder: WrappedApplicationKey build()>,0,"{
    Preconditions.checkNotNull(mInstance.mAlias);
    Preconditions.checkNotNull(mInstance.mEncryptedKeyMaterial);
    return mInstance;
}","{
    Objects.requireNonNull(mInstance.mAlias);
    Objects.requireNonNull(mInstance.mEncryptedKeyMaterial);
    return mInstance;
}",1,"/**
 * Creates a new {@link WrappedApplicationKey} instance.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
","/**
 * Creates a new {@link WrappedApplicationKey} instance.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent APIs changed from Preconditions.checkNotNull to Objects.requireNonNull for the checks on mAlias and mEncryptedKeyMaterial. However, both APIs serve the same purpose to check for null. The other statements remain unchanged. Because of that, the change type is 4 and 5.","There is no compatibility issue arising from this change since the behavior of the method remains the same; it still throws a NullPointerException if mAlias or mEncryptedKeyMaterial is null, just that the method of checking for null has been updated. Therefore, the CI type is 0."
321,"<android.os.RemoteCallbackList: boolean register(E,Object)>",29,30,"<android.os.RemoteCallbackList: boolean register(E,Object)>","<android.os.RemoteCallbackList: boolean register(E,Object)>",0,"{
    synchronized (mCallbacks) {
        if (mKilled) {
            return false;
        }
        // Flag unusual case that could be caused by a leak. b/36778087
        logExcessiveCallbacks();
        IBinder binder = callback.asBinder();
        try {
            Callback cb = new Callback(callback, cookie);
            binder.linkToDeath(cb, 0);
            mCallbacks.put(binder, cb);
            return true;
        } catch (RemoteException e) {
            return false;
        }
    }
}","{
    synchronized (mCallbacks) {
        if (mKilled) {
            return false;
        }
        // Flag unusual case that could be caused by a leak. b/36778087
        logExcessiveCallbacks();
        IBinder binder = callback.asBinder();
        try {
            Callback cb = new Callback(callback, cookie);
            unregister(callback);
            binder.linkToDeath(cb, 0);
            mCallbacks.put(binder, cb);
            return true;
        } catch (RemoteException e) {
            return false;
        }
    }
}",1,"/**
 * Add a new callback to the list.  This callback will remain in the list
 * until a corresponding call to {@link #unregister} or its hosting process
 * goes away.  If the callback was already registered (determined by
 * checking to see if the {@link IInterface#asBinder callback.asBinder()}
 * object is already in the list), then it will be left as-is.
 * Registrations are not counted; a single call to {@link #unregister}
 * will remove a callback after any number calls to register it.
 *
 * @param callback The callback interface to be added to the list.  Must
 * not be null -- passing null here will cause a NullPointerException.
 * Most services will want to check for null before calling this with
 * an object given from a client, so that clients can't crash the
 * service with bad data.
 *
 * @param cookie Optional additional data to be associated with this
 * callback.
 *
 * @return Returns true if the callback was successfully added to the list.
 * Returns false if it was not added, either because {@link #kill} had
 * previously been called or the callback's process has gone away.
 *
 * @see #unregister
 * @see #kill
 * @see #onCallbackDied
 */
","/**
 * Add a new callback to the list.  This callback will remain in the list
 * until a corresponding call to {@link #unregister} or its hosting process
 * goes away.  If the callback was already registered (determined by
 * checking to see if the {@link IInterface#asBinder callback.asBinder()}
 * object is already in the list), then it will be left as-is.
 * Registrations are not counted; a single call to {@link #unregister}
 * will remove a callback after any number calls to register it.
 *
 * @param callback The callback interface to be added to the list.  Must
 * not be null -- passing null here will cause a NullPointerException.
 * Most services will want to check for null before calling this with
 * an object given from a client, so that clients can't crash the
 * service with bad data.
 *
 * @param cookie Optional additional data to be associated with this
 * callback.
 *
 * @return Returns true if the callback was successfully added to the list.
 * Returns false if it was not added, either because {@link #kill} had
 * previously been called or the callback's process has gone away.
 *
 * @see #unregister
 * @see #kill
 * @see #onCallbackDied
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation has added the statement ""unregister(callback);"" within the try block. This is a change in control dependency since it's under synchronized block and represents the insertion of an operation before registering the callback. Additionally, this is also an ""Other statement changed"" since it introduces a new statement that does not fall into the other specific change categories. Hence, the code change types are 3 and 4.","Although there is a change in the implementation, the behavior of method in terms of return values or exception handling has not changed — it still returns true if registration is successful, false if not, or if mKilled is true, and the same RemoteException is caught and handled identically. The newly introduced ""unregister(callback);"" does not cause a compatibility issue since it ensures that previous registrations of the same callback are removed before a new one is added, potentially preventing logical errors or leaks — it does not change the semantics of the API in terms of return values or exception handling, but rather improves robustness. Therefore, there is no Compatibility Issue, and the CI type is 0."
322,"<android.app.slice.SliceManager: Slice bindSlice(Intent,Set<SliceSpec>)>",29,30,"<android.app.slice.SliceManager: Slice bindSlice(Intent,Set<SliceSpec>)>","<android.app.slice.SliceManager: Slice bindSlice(Intent,Set<SliceSpec>)>",0,"{
    Preconditions.checkNotNull(intent, ""intent"");
    Preconditions.checkArgument(intent.getComponent() != null || intent.getPackage() != null || intent.getData() != null, ""Slice intent must be explicit %s"", intent);
    ContentResolver resolver = mContext.getContentResolver();
    final Uri staticUri = resolveStatic(intent, resolver);
    if (staticUri != null)
        return bindSlice(staticUri, supportedSpecs);
    // Otherwise ask the app
    String authority = getAuthority(intent);
    if (authority == null)
        return null;
    Uri uri = new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(authority).build();
    try (ContentProviderClient provider = resolver.acquireUnstableContentProviderClient(uri)) {
        if (provider == null) {
            Log.w(TAG, String.format(""Unknown URI: %s"", uri));
            return null;
        }
        Bundle extras = new Bundle();
        extras.putParcelable(SliceProvider.EXTRA_INTENT, intent);
        final Bundle res = provider.call(SliceProvider.METHOD_MAP_INTENT, null, extras);
        if (res == null) {
            return null;
        }
        return res.getParcelable(SliceProvider.EXTRA_SLICE);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    }
}","{
    Objects.requireNonNull(intent, ""intent"");
    Preconditions.checkArgument(intent.getComponent() != null || intent.getPackage() != null || intent.getData() != null, ""Slice intent must be explicit %s"", intent);
    ContentResolver resolver = mContext.getContentResolver();
    final Uri staticUri = resolveStatic(intent, resolver);
    if (staticUri != null)
        return bindSlice(staticUri, supportedSpecs);
    // Otherwise ask the app
    String authority = getAuthority(intent);
    if (authority == null)
        return null;
    Uri uri = new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(authority).build();
    try (ContentProviderClient provider = resolver.acquireUnstableContentProviderClient(uri)) {
        if (provider == null) {
            Log.w(TAG, String.format(""Unknown URI: %s"", uri));
            return null;
        }
        Bundle extras = new Bundle();
        extras.putParcelable(SliceProvider.EXTRA_INTENT, intent);
        extras.putParcelableArrayList(SliceProvider.EXTRA_SUPPORTED_SPECS, new ArrayList<>(supportedSpecs));
        final Bundle res = provider.call(SliceProvider.METHOD_MAP_INTENT, null, extras);
        if (res == null) {
            return null;
        }
        return res.getParcelable(SliceProvider.EXTRA_SLICE);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    }
}",1,"/**
 * Turns a slice intent into slice content. Is a shortcut to perform the action
 * of both {@link #mapIntentToUri(Intent)} and {@link #bindSlice(Uri, Set)} at once.
 *
 * @param intent The intent associated with a slice.
 * @param supportedSpecs List of supported specs.
 * @return The Slice provided by the app or null if none is given.
 * @see Slice
 * @see SliceProvider#onMapIntentToUri(Intent)
 * @see Intent
 */
","/**
 * Turns a slice intent into slice content. Is a shortcut to perform the action
 * of both {@link #mapIntentToUri(Intent)} and {@link #bindSlice(Uri, Set)} at once.
 *
 * @param intent The intent associated with a slice.
 * @param supportedSpecs List of supported specs.
 * @return The Slice provided by the app or null if none is given.
 * @see Slice
 * @see SliceProvider#onMapIntentToUri(Intent)
 * @see Intent
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The statement to check the null requirement of the intent parameter has changed from `Preconditions.checkNotNull` to `Objects.requireNonNull`, and the way to add supportedSpecs to the extras Bundle has been added, which introduces the use of `extras.putParcelableArrayList`. These changes count as changes in other statements, but they do not alter the API's external behavior regarding the return value, hence the code change type is 4,5.","While there are changes to statements within the method, they do not cause a change in behavior that would lead to a Compatibility Issue. The validity check on the intent object is logically equivalent; it still throws a NullPointerException for a null intent. Additionally, the insertion of the supportedSpecs to the Bundle does not affect how the method would behave externally, as this data is simply being passed along for internal handling. Therefore, the change does not lead to different return values or exception handling from the perspective of the API consumer. The CI type is 0."
324,"<android.widget.Magnifier: void show(float,float,float,float)>",29,30,"<android.widget.Magnifier: void show(float,float,float,float)>","<android.widget.Magnifier: void show(float,float,float,float)>",0,"{
    obtainSurfaces();
    obtainContentCoordinates(sourceCenterX, sourceCenterY);
    obtainWindowCoordinates(magnifierCenterX, magnifierCenterY);
    final int startX = mClampedCenterZoomCoords.x - mSourceWidth / 2;
    final int startY = mClampedCenterZoomCoords.y - mSourceHeight / 2;
    if (sourceCenterX != mPrevShowSourceCoords.x || sourceCenterY != mPrevShowSourceCoords.y || mDirtyState) {
        if (mWindow == null) {
            synchronized (mLock) {
                mWindow = new InternalPopupWindow(mView.getContext(), mView.getDisplay(), mParentSurface.mSurfaceControl, mWindowWidth, mWindowHeight, mWindowElevation, mWindowCornerRadius, mOverlay != null ? mOverlay : new ColorDrawable(Color.TRANSPARENT), Handler.getMain(), /* draw the magnifier on the UI thread */
                mLock, mCallback);
            }
        }
        performPixelCopy(startX, startY, true);
    } else if (magnifierCenterX != mPrevShowWindowCoords.x || magnifierCenterY != mPrevShowWindowCoords.y) {
        final Point windowCoords = getCurrentClampedWindowCoordinates();
        final InternalPopupWindow currentWindowInstance = mWindow;
        sPixelCopyHandlerThread.getThreadHandler().post(() -> {
            synchronized (mLock) {
                if (mWindow != currentWindowInstance) {
                    // The magnifier was dismissed (and maybe shown again) in the meantime.
                    return;
                }
                mWindow.setContentPositionForNextDraw(windowCoords.x, windowCoords.y);
            }
        });
    }
    mPrevShowSourceCoords.x = sourceCenterX;
    mPrevShowSourceCoords.y = sourceCenterY;
    mPrevShowWindowCoords.x = magnifierCenterX;
    mPrevShowWindowCoords.y = magnifierCenterY;
}","{
    obtainSurfaces();
    obtainContentCoordinates(sourceCenterX, sourceCenterY);
    int startX = mClampedCenterZoomCoords.x - mSourceWidth / 2;
    final int startY = mClampedCenterZoomCoords.y - mSourceHeight / 2;
    if (mIsFishEyeStyle) {
        // The magnifier center is the same as source center in new style.
        magnifierCenterX = mClampedCenterZoomCoords.x - mViewCoordinatesInSurface[0];
        magnifierCenterY = mClampedCenterZoomCoords.y - mViewCoordinatesInSurface[1];
        // mLeftBound & mRightBound (typically the text line left/right) is for magnified
        // content. However the PixelCopy requires the pre-magnified bounds.
        // The below logic calculates the leftBound & rightBound for the pre-magnified bounds.
        final float rampPre = (mSourceWidth - (mSourceWidth - 2 * mRamp) / mZoom) / 2;
        // Calculates the pre-zoomed left edge.
        // The leftEdge moves from the left of view towards to sourceCenterX, considering the
        // fisheye-like zooming.
        final float x0 = sourceCenterX - mSourceWidth / 2;
        final float rampX0 = x0 + mRamp;
        float leftEdge = 0;
        if (leftEdge > rampX0) {
            // leftEdge is in the zoom range, the distance from leftEdge to sourceCenterX
            // should reduce per mZoom.
            leftEdge = sourceCenterX - (sourceCenterX - leftEdge) / mZoom;
        } else if (leftEdge > x0) {
            // leftEdge is in the ramp range, the distance from leftEdge to rampX0 should
            // increase per ramp zoom (ramp / rampPre).
            leftEdge = x0 + rampPre - (rampX0 - leftEdge) * rampPre / mRamp;
        }
        int leftBound = Math.min(Math.max((int) leftEdge, mLeftBound), mRightBound);
        // Calculates the pre-zoomed right edge.
        // The rightEdge moves from the right of view towards to sourceCenterX, considering the
        // fisheye-like zooming.
        final float x1 = sourceCenterX + mSourceWidth / 2;
        final float rampX1 = x1 - mRamp;
        float rightEdge = mView.getWidth();
        if (rightEdge < rampX1) {
            // rightEdge is in the zoom range, the distance from rightEdge to sourceCenterX
            // should reduce per mZoom.
            rightEdge = sourceCenterX + (rightEdge - sourceCenterX) / mZoom;
        } else if (rightEdge < x1) {
            // rightEdge is in the ramp range, the distance from rightEdge to rampX1 should
            // increase per ramp zoom (ramp / rampPre).
            rightEdge = x1 - rampPre + (rightEdge - rampX1) * rampPre / mRamp;
        }
        int rightBound = Math.max(leftBound, Math.min((int) rightEdge, mRightBound));
        // Gets the startX for new style, which should be bounded by the horizontal bounds.
        // Also calculates the left/right cut width for pixel copy.
        leftBound = Math.max(leftBound + mViewCoordinatesInSurface[0], 0);
        rightBound = Math.min(rightBound + mViewCoordinatesInSurface[0], mContentCopySurface.mWidth);
        mLeftCutWidth = Math.max(0, leftBound - startX);
        mRightCutWidth = Math.max(0, startX + mSourceWidth - rightBound);
        startX = Math.max(startX, leftBound);
    }
    obtainWindowCoordinates(magnifierCenterX, magnifierCenterY);
    if (sourceCenterX != mPrevShowSourceCoords.x || sourceCenterY != mPrevShowSourceCoords.y || mDirtyState) {
        if (mWindow == null) {
            synchronized (mLock) {
                mWindow = new InternalPopupWindow(mView.getContext(), mView.getDisplay(), mParentSurface.mSurfaceControl, mWindowWidth, mWindowHeight, mZoom, mRamp, mWindowElevation, mWindowCornerRadius, mOverlay != null ? mOverlay : new ColorDrawable(Color.TRANSPARENT), Handler.getMain(), /* draw the magnifier on the UI thread */
                mLock, mCallback, mIsFishEyeStyle);
            }
        }
        performPixelCopy(startX, startY, true);
    } else if (magnifierCenterX != mPrevShowWindowCoords.x || magnifierCenterY != mPrevShowWindowCoords.y) {
        final Point windowCoords = getCurrentClampedWindowCoordinates();
        final InternalPopupWindow currentWindowInstance = mWindow;
        sPixelCopyHandlerThread.getThreadHandler().post(() -> {
            synchronized (mLock) {
                if (mWindow != currentWindowInstance) {
                    // The magnifier was dismissed (and maybe shown again) in the meantime.
                    return;
                }
                mWindow.setContentPositionForNextDraw(windowCoords.x, windowCoords.y);
            }
        });
    }
    mPrevShowSourceCoords.x = sourceCenterX;
    mPrevShowSourceCoords.y = sourceCenterY;
    mPrevShowWindowCoords.x = magnifierCenterX;
    mPrevShowWindowCoords.y = magnifierCenterY;
}",1,"/**
 * Shows the magnifier on the screen at a position that is independent from its content
 * position. The first two arguments represent the coordinates of the center of the
 * content source going to be magnified and copied to the magnifier. The last two arguments
 * represent the coordinates of the center of the magnifier itself. All four coordinates
 * are relative to the top left corner of the magnified view. If you consider using this
 * method such that the offset between the source center and the magnifier center coordinates
 * remains constant, you should consider using method {@link #show(float, float)} instead.
 *
 * @param sourceCenterX horizontal coordinate of the source center relative to the view
 * @param sourceCenterY vertical coordinate of the source center, relative to the view
 * @param magnifierCenterX horizontal coordinate of the magnifier center, relative to the view
 * @param magnifierCenterY vertical coordinate of the magnifier center, relative to the view
 */
","/**
 * Shows the magnifier on the screen at a position that is independent from its content
 * position. The first two arguments represent the coordinates of the center of the
 * content source going to be magnified and copied to the magnifier. The last two arguments
 * represent the coordinates of the center of the magnifier itself. All four coordinates
 * are relative to the top left corner of the magnified view. If you consider using this
 * method such that the offset between the source center and the magnifier center coordinates
 * remains constant, you should consider using method {@link #show(float, float)} instead.
 *
 * @param sourceCenterX horizontal coordinate of the source center relative to the view
 * @param sourceCenterY vertical coordinate of the source center, relative to the view
 * @param magnifierCenterX horizontal coordinate of the magnifier center, relative to the view
 * @param magnifierCenterY vertical coordinate of the magnifier center, relative to the view
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
325,<android.app.admin.DevicePolicyManager: boolean isAlwaysOnVpnLockdownEnabled(ComponentName)>,29,30,<android.app.admin.DevicePolicyManager: boolean isAlwaysOnVpnLockdownEnabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean isAlwaysOnVpnLockdownEnabled(ComponentName)>,0,"{
    throwIfParentInstance(""isAlwaysOnVpnLockdownEnabled"");
    if (mService != null) {
        try {
            return mService.isAlwaysOnVpnLockdownEnabled(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    throwIfParentInstance(""isAlwaysOnVpnLockdownEnabled"");
    if (mService != null) {
        try {
            // which is used by the NetworkStack mainline module.
            return mService.isAlwaysOnVpnLockdownEnabled(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by device or profile owner to query whether current always-on VPN is configured in
 * lockdown mode. Returns {@code false} when no always-on configuration is set.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 *
 * @throws SecurityException if {@code admin} is not a device or a profile owner.
 *
 * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean)
 */
","/**
 * Called by device or profile owner to query whether current always-on VPN is configured in
 * lockdown mode. Returns {@code false} when no always-on configuration is set.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 *
 * @throws SecurityException if {@code admin} is not a device or a profile owner.
 *
 * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The only change between the versions is the addition of a comment, which does not affect the code's behavior. Therefore, there is no code change in terms of functionality.","Since there is no functional change to the code, there is no Compatibility Issue between these versions."
327,"<android.view.SurfaceControl.Transaction: Transaction setVisibility(SurfaceControl,boolean)>",29,30,"<android.view.SurfaceControl.Transaction: Transaction setVisibility(SurfaceControl,boolean)>","<android.view.SurfaceControl.Transaction: Transaction setVisibility(SurfaceControl,boolean)>",0,"{
    sc.checkNotReleased();
    if (visible) {
        return show(sc);
    } else {
        return hide(sc);
    }
}","{
    checkPreconditions(sc);
    if (visible) {
        return show(sc);
    } else {
        return hide(sc);
    }
}",1,"/**
 * Toggle the visibility of a given Layer and it's sub-tree.
 *
 * @param sc The SurfaceControl for which to set the visibility
 * @param visible The new visibility
 * @return This transaction object.
 */
","/**
 * Toggle the visibility of a given Layer and it's sub-tree.
 *
 * @param sc The SurfaceControl for which to set the visibility
 * @param visible The new visibility
 * @return This transaction object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the implementation is the method used for checking preconditions from sc.checkNotReleased() to checkPreconditions(sc), no other statement has changed, so the code change type is 4 for Other statement changed. Furthermore, as the dependent API for precondition checking has been altered, the code change type also includes 5 for Dependent API changed.","The change does not affect the behavior of the API regarding what it returns or the exceptions it may throw because both early and late versions call the same methods 'show(sc)' and 'hide(sc)' for visible true and false respectively. Hence, the result of the API call does not change with respect to its return value or exception handling, so there is no Compatibility Issue - 0."
328,<android.service.voice.VoiceInteractionSession: void ensureWindowCreated()>,29,30,<android.service.voice.VoiceInteractionSession: void ensureWindowCreated()>,<android.service.voice.VoiceInteractionSession: void ensureWindowCreated()>,0,"{
    if (mInitialized) {
        return;
    }
    if (!mUiEnabled) {
        throw new IllegalStateException(""setUiEnabled is false"");
    }
    mInitialized = true;
    mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    mWindow = new SoftInputWindow(mContext, ""VoiceInteractionSession"", mTheme, mCallbacks, this, mDispatcherState, WindowManager.LayoutParams.TYPE_VOICE_INTERACTION, Gravity.BOTTOM, true);
    mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
    mThemeAttrs = mContext.obtainStyledAttributes(android.R.styleable.VoiceInteractionSession);
    mRootView = mInflater.inflate(com.android.internal.R.layout.voice_interaction_session, null);
    mRootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
    mWindow.setContentView(mRootView);
    mRootView.getViewTreeObserver().addOnComputeInternalInsetsListener(mInsetsComputer);
    mContentFrame = (FrameLayout) mRootView.findViewById(android.R.id.content);
    mWindow.getWindow().setLayout(MATCH_PARENT, MATCH_PARENT);
    mWindow.setToken(mToken);
}","{
    if (mInitialized) {
        return;
    }
    if (!mUiEnabled) {
        throw new IllegalStateException(""setUiEnabled is false"");
    }
    mInitialized = true;
    mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    mWindow = new SoftInputWindow(mContext, ""VoiceInteractionSession"", mTheme, mCallbacks, this, mDispatcherState, WindowManager.LayoutParams.TYPE_VOICE_INTERACTION, Gravity.BOTTOM, true);
    mWindow.getWindow().getAttributes().setFitInsetsTypes(0);
    mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
    mThemeAttrs = mContext.obtainStyledAttributes(android.R.styleable.VoiceInteractionSession);
    mRootView = mInflater.inflate(com.android.internal.R.layout.voice_interaction_session, null);
    mRootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
    mWindow.setContentView(mRootView);
    mRootView.getViewTreeObserver().addOnComputeInternalInsetsListener(mInsetsComputer);
    mContentFrame = (FrameLayout) mRootView.findViewById(android.R.id.content);
    mWindow.getWindow().setLayout(MATCH_PARENT, MATCH_PARENT);
    mWindow.setToken(mToken);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is the addition of a method call on `mWindow.getWindow().getAttributes().setFitInsetsTypes(0);`. No return or exception handling statements have been changed, and no control dependencies have been affected, so the code change type is 4.","The change in the late implementation does not affect the return values or the exceptions thrown by the method. It appears to configure window attributes, but these do not alter the method's control flow or outcomes. Thus, there is no Compatibility Issue, so the CI type is 0."
329,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CancellationSignal,Executor,AuthenticationCallback)>",29,30,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CancellationSignal,Executor,AuthenticationCallback)>","<android.hardware.biometrics.BiometricPrompt: void authenticate(CancellationSignal,Executor,AuthenticationCallback)>",0,"{
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    authenticateInternal(null, /* crypto */
    cancel, executor, callback, mContext.getUserId(), null);
}","{
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    authenticateInternal(null, /* crypto */
    cancel, executor, callback, mContext.getUserId());
}",1,"/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)} is called, or when
 * the user dismisses the system-provided dialog.  This operation can be canceled by using the
 * provided cancel object. The application will receive authentication errors through {@link
 * AuthenticationCallback}, and button events through the corresponding callback set in {@link
 * Builder#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.  It is
 * safe to reuse the {@link BiometricPrompt} object, and calling {@link
 * BiometricPrompt#authenticate(CancellationSignal, Executor, AuthenticationCallback)} while
 * an existing authentication attempt is occurring will stop the previous client and start a new
 * authentication. The interrupted client will receive a cancelled notification through {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)}.
 *
 * Note: Applications generally should not cancel and start authentication in quick succession.
 * For example, to properly handle authentication across configuration changes, it's recommended
 * to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so, the
 * application will not need to cancel/restart authentication during the configuration change.
 *
 * @throws IllegalArgumentException If any of the arguments are null
 *
 * @param cancel An object that can be used to cancel authentication
 * @param executor An executor to handle callback events
 * @param callback An object to receive authentication events
 */
","/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)} is called, or when
 * the user dismisses the system-provided dialog.  This operation can be canceled by using the
 * provided cancel object. The application will receive authentication errors through {@link
 * AuthenticationCallback}, and button events through the corresponding callback set in {@link
 * Builder#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.  It is
 * safe to reuse the {@link BiometricPrompt} object, and calling {@link
 * BiometricPrompt#authenticate(CancellationSignal, Executor, AuthenticationCallback)} while
 * an existing authentication attempt is occurring will stop the previous client and start a new
 * authentication. The interrupted client will receive a cancelled notification through {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)}.
 *
 * <p>Note: Applications generally should not cancel and start authentication in quick
 * succession. For example, to properly handle authentication across configuration changes, it's
 * recommended to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so,
 * the application will not need to cancel/restart authentication during the configuration
 * change.
 *
 * @throws IllegalArgumentException If any of the arguments are null.
 *
 * @param cancel An object that can be used to cancel authentication.
 * @param executor An executor to handle callback events.
 * @param callback An object to receive authentication events.
 */
",-1,[@RequiresPermission(USE_BIOMETRIC)],[@RequiresPermission(USE_BIOMETRIC)],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is in the last method call of authenticateInternal, where the late version has one less parameter (null is removed). This does not affect the return type or the exception handling of the method, so the change type is 4.","There are no changes that affect the return value or the way exceptions are thrown; thus, no Compatibility Issue is expected. The dependent API (authenticateInternal) change does not imply different behavior since the extra parameter was always supplied as null. The change likely simplifies an internal call without impacting external API behavior."
330,<android.app.ActivityOptions: Bundle toBundle()>,29,30,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mSplitScreenCreateMode != SPLIT_SCREEN_CREATE_MODE_TOP_OR_LEFT) {
        b.putInt(KEY_SPLIT_SCREEN_CREATE_MODE, mSplitScreenCreateMode);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    return b;
}","{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    if (mAnimationType != ANIM_UNDEFINED) {
        b.putInt(KEY_ANIM_TYPE, mAnimationType);
    }
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mCallerDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_CALLER_DISPLAY_ID, mCallerDisplayId);
    }
    if (mLaunchTaskDisplayArea != null) {
        b.putParcelable(KEY_LAUNCH_TASK_DISPLAY_AREA_TOKEN, mLaunchTaskDisplayArea);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskAlwaysOnTop) {
        b.putBoolean(KEY_TASK_ALWAYS_ON_TOP, mTaskAlwaysOnTop);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mSplitScreenCreateMode != SPLIT_SCREEN_CREATE_MODE_TOP_OR_LEFT) {
        b.putInt(KEY_SPLIT_SCREEN_CREATE_MODE, mSplitScreenCreateMode);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mApplyActivityFlagsForBubbles) {
        b.putBoolean(KEY_APPLY_ACTIVITY_FLAGS_FOR_BUBBLES, mApplyActivityFlagsForBubbles);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
331,<android.view.textclassifier.TextClassifierEvent.Builder: T setScores(float)>,29,30,<android.view.textclassifier.TextClassifierEvent.Builder: T setScores(float)>,<android.view.textclassifier.TextClassifierEvent.Builder: T setScores(float)>,0,"{
    Preconditions.checkNotNull(scores);
    mScores = new float[scores.length];
    System.arraycopy(scores, 0, mScores, 0, scores.length);
    return self();
}","{
    Objects.requireNonNull(scores);
    mScores = new float[scores.length];
    System.arraycopy(scores, 0, mScores, 0, scores.length);
    return self();
}",1,"/**
 * Sets the scores of the suggestions.
 */
","/**
 * Sets the scores of the suggestions.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change in the code is from using Preconditions.checkNotNull(scores) to using Objects.requireNonNull(scores), which is essentially the same check with a different method from a different utility class. This does not affect the behavior of the method.","Since both Preconditions.checkNotNull and Objects.requireNonNull perform null checks and throw a NullPointerException, there is no behavior change in the method's execution or its return value. Therefore, no Compatibility Issue arises from this change."
332,<android.bluetooth.BluetoothDevice: int getBondState()>,29,30,<android.bluetooth.BluetoothDevice: int getBondState()>,<android.bluetooth.BluetoothDevice: int getBondState()>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get bond state"");
        return BOND_NONE;
    }
    try {
        return service.getBondState(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return BOND_NONE;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get bond state"");
        return BOND_NONE;
    }
    try {
        return mBluetoothBondCache.query(this);
    } catch (RuntimeException e) {
        if (e.getCause() instanceof RemoteException) {
            Log.e(TAG, """", e);
        } else {
            throw e;
        }
    }
    return BOND_NONE;
}",1,"/**
 * Get the bond state of the remote device.
 * <p>Possible values for the bond state are:
 * {@link #BOND_NONE},
 * {@link #BOND_BONDING},
 * {@link #BOND_BONDED}.
 *
 * @return the bond state
 */
","/**
 * Get the bond state of the remote device.
 * <p>Possible values for the bond state are:
 * {@link #BOND_NONE},
 * {@link #BOND_BONDING},
 * {@link #BOND_BONDED}.
 *
 * @return the bond state
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The code change involves a change in the dependent API from service.getBondState(this) to mBluetoothBondCache.query(this), which is a different method and likely belongs to a different class or object. This change classifies as a Dependent API changed (5). Additionally, the exception handling block has been modified to execute different code and potentially throw a RuntimeException, which wasn't thrown in the earlier version. Therefore, it includes Exception handling statement changed (2) and Return statement changed because the values returned may be different due to exception behavior change (1).","The alteration of the method used to get the bond state from service.getBondState(this) to mBluetoothBondCache.query(this) could lead to a different return value due to a change in how the data is retrieved or processed (CI type 1). Moreover, the changes in exception handling to rethrow a RuntimeException if it's not caused by a RemoteException could lead to different exception handling behavior between the two API versions (CI type 2)."
334,<android.view.View: boolean onTouchEvent(MotionEvent)>,29,30,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // events, it just doesn't respond to them.
        return clickable;
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;
                if (!clickable) {
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    break;
                }
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }
                final int motionClassification = event.getClassification();
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                int touchSlop = mTouchSlop;
                if (ambiguousGesture && hasPendingLongPressCallback()) {
                    final float ambiguousMultiplier = ViewConfiguration.getAmbiguousGestureMultiplier();
                    if (!pointInView(x, y, touchSlop)) {
                        // The default action here is to cancel long press. But instead, we
                        // just extend the timeout here, in case the classification
                        // stays ambiguous.
                        removeLongPressCallback();
                        long delay = (long) (ViewConfiguration.getLongPressTimeout() * ambiguousMultiplier);
                        // Subtract the time already spent
                        delay -= event.getEventTime() - event.getDownTime();
                        checkForLongClick(delay, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    }
                    touchSlop *= ambiguousMultiplier;
                }
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, touchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
                if (deepPress && hasPendingLongPressCallback()) {
                    // process the long click action immediately
                    removeLongPressCallback();
                    checkForLongClick(0, /* send immediately */
                    x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // events, it just doesn't respond to them.
        return clickable;
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;
                if (!clickable) {
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    break;
                }
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }
                final int motionClassification = event.getClassification();
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                int touchSlop = mTouchSlop;
                if (ambiguousGesture && hasPendingLongPressCallback()) {
                    if (!pointInView(x, y, touchSlop)) {
                        // The default action here is to cancel long press. But instead, we
                        // just extend the timeout here, in case the classification
                        // stays ambiguous.
                        removeLongPressCallback();
                        long delay = (long) (ViewConfiguration.getLongPressTimeout() * mAmbiguousGestureMultiplier);
                        // Subtract the time already spent
                        delay -= event.getEventTime() - event.getDownTime();
                        checkForLongClick(delay, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    }
                    touchSlop *= mAmbiguousGestureMultiplier;
                }
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, touchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
                if (deepPress && hasPendingLongPressCallback()) {
                    // process the long click action immediately
                    removeLongPressCallback();
                    checkForLongClick(0, /* send immediately */
                    x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
335,<android.app.Notification: String toString()>,29,30,<android.app.Notification: String toString()>,<android.app.Notification: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(channel="");
    sb.append(getChannelId());
    sb.append("" pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    if (this.tickerText != null) {
        sb.append("" tick"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append(String.format("" color=0x%08x"", this.color));
    if (this.category != null) {
        sb.append("" category="");
        sb.append(this.category);
    }
    if (this.mGroupKey != null) {
        sb.append("" groupKey="");
        sb.append(this.mGroupKey);
    }
    if (this.mSortKey != null) {
        sb.append("" sortKey="");
        sb.append(this.mSortKey);
    }
    if (actions != null) {
        sb.append("" actions="");
        sb.append(actions.length);
    }
    sb.append("" vis="");
    sb.append(visibilityToString(this.visibility));
    if (this.publicVersion != null) {
        sb.append("" publicVersion="");
        sb.append(publicVersion.toString());
    }
    if (this.mLocusId != null) {
        sb.append("" locusId="");
        // LocusId.toString() is PII safe.
        sb.append(this.mLocusId);
    }
    sb.append("")"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(channel="");
    sb.append(getChannelId());
    sb.append("" shortcut="");
    sb.append(getShortcutId());
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    if (this.tickerText != null) {
        sb.append("" tick"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append(String.format("" color=0x%08x"", this.color));
    if (this.category != null) {
        sb.append("" category="");
        sb.append(this.category);
    }
    if (this.mGroupKey != null) {
        sb.append("" groupKey="");
        sb.append(this.mGroupKey);
    }
    if (this.mSortKey != null) {
        sb.append("" sortKey="");
        sb.append(this.mSortKey);
    }
    if (actions != null) {
        sb.append("" actions="");
        sb.append(actions.length);
    }
    sb.append("" vis="");
    sb.append(visibilityToString(this.visibility));
    if (this.publicVersion != null) {
        sb.append("" publicVersion="");
        sb.append(publicVersion.toString());
    }
    if (this.mLocusId != null) {
        sb.append("" locusId="");
        // LocusId.toString() is PII safe.
        sb.append(this.mLocusId);
    }
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
336,"<android.content.res.AssetManager: AssetFileDescriptor openNonAssetFd(int,String)>",29,30,"<android.content.res.AssetManager: AssetFileDescriptor openNonAssetFd(int,String)>","<android.content.res.AssetManager: AssetFileDescriptor openNonAssetFd(int,String)>",0,"{
    Preconditions.checkNotNull(fileName, ""fileName"");
    synchronized (this) {
        ensureOpenLocked();
        final ParcelFileDescriptor pfd = nativeOpenNonAssetFd(mObject, cookie, fileName, mOffsets);
        if (pfd == null) {
            throw new FileNotFoundException(""Asset absolute file: "" + fileName);
        }
        return new AssetFileDescriptor(pfd, mOffsets[0], mOffsets[1]);
    }
}","{
    Objects.requireNonNull(fileName, ""fileName"");
    synchronized (this) {
        ensureOpenLocked();
        final ParcelFileDescriptor pfd = nativeOpenNonAssetFd(mObject, cookie, fileName, mOffsets);
        if (pfd == null) {
            throw new FileNotFoundException(""Asset absolute file: "" + fileName);
        }
        return new AssetFileDescriptor(pfd, mOffsets[0], mOffsets[1]);
    }
}",1,"/**
 * Open a non-asset as an asset by mmapping it and returning an {@link AssetFileDescriptor}.
 * This provides direct access to all of the files included in an application
 * package (not only its assets).  Applications should not normally use this.
 *
 * The asset must not be compressed, or an exception will be thrown.
 *
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 */
","/**
 * Open a non-asset as an asset by mmapping it and returning an {@link AssetFileDescriptor}.
 * This provides direct access to all of the files included in an application
 * package (not only its assets).  Applications should not normally use this.
 *
 * The asset must not be compressed, or an exception will be thrown.
 *
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the replacement of the Preconditions.checkNotNull method with the Objects.requireNonNull method. Both methods perform the same operation (i.e., they check that the provided reference is not null and throw a NullPointerException if it is), so this is an implementation detail and does not affect the functionality of the API. Thus, the code change type is 4.","Since the behavior of the Objects.requireNonNull method is functionally identical to the Preconditions.checkNotNull method, no Compatibility Issue should arise from this change. Both methods throw NullPointerException if the 'fileName' is null, and this behavior is consistent between both versions of the API. Therefore, there should be no change in the API behavior that could result in different return values or types, or different exception handlings."
338,<android.net.LinkProperties: int hashCode()>,29,30,<android.net.LinkProperties: int hashCode()>,<android.net.LinkProperties: int hashCode()>,0,"{
    return ((null == mIfaceName) ? 0 : mIfaceName.hashCode() + mLinkAddresses.size() * 31 + mDnses.size() * 37 + mValidatedPrivateDnses.size() * 61 + ((null == mDomains) ? 0 : mDomains.hashCode()) + mRoutes.size() * 41 + ((null == mHttpProxy) ? 0 : mHttpProxy.hashCode()) + mStackedLinks.hashCode() * 47) + mMtu * 51 + ((null == mTcpBufferSizes) ? 0 : mTcpBufferSizes.hashCode()) + (mUsePrivateDns ? 57 : 0) + mPcscfs.size() * 67 + ((null == mPrivateDnsServerName) ? 0 : mPrivateDnsServerName.hashCode()) + Objects.hash(mNat64Prefix);
}","{
    return ((null == mIfaceName) ? 0 : mIfaceName.hashCode() + mLinkAddresses.size() * 31 + mDnses.size() * 37 + mValidatedPrivateDnses.size() * 61 + ((null == mDomains) ? 0 : mDomains.hashCode()) + mRoutes.size() * 41 + ((null == mHttpProxy) ? 0 : mHttpProxy.hashCode()) + mStackedLinks.hashCode() * 47) + mMtu * 51 + ((null == mTcpBufferSizes) ? 0 : mTcpBufferSizes.hashCode()) + (mUsePrivateDns ? 57 : 0) + ((null == mDhcpServerAddress) ? 0 : mDhcpServerAddress.hashCode()) + mPcscfs.size() * 67 + ((null == mPrivateDnsServerName) ? 0 : mPrivateDnsServerName.hashCode()) + Objects.hash(mNat64Prefix) + (mWakeOnLanSupported ? 71 : 0) + Objects.hash(mCaptivePortalApiUrl, mCaptivePortalData);
}",1,"/**
 * Generate hashcode based on significant fields
 *
 * Equal objects must produce the same hash code, while unequal objects
 * may have the same hash codes.
 */
","/**
 * Generate hashcode based on significant fields
 *
 * Equal objects must produce the same hash code, while unequal objects
 * may have the same hash codes.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The hashCode computation has added additional fields (mDhcpServerAddress.hashCode(), mWakeOnLanSupported, mCaptivePortalApiUrl, mCaptivePortalData) into the calculation. This change does not affect the method signature or its control flow but does change the internal implementation details and affects the result of the hashCode computation. Therefore, the code change type is 4 (Other statement changed).","The change in the hashCode computation logic should be considered an internal change and does not lead to a compatibility issue concerning the API contract. The method still returns an int as specified, and it operates as a typical hashCode method, even though the actual returned value can be different when different fields are considered. As long as objects that are considered equal (according to the equals method) still result in the same hash code, this change maintains the general contract of hashCode and thus does not constitute a compatibility issue. The type of CI is 0 (No Compatibility Issue)."
339,"<android.view.View: WindowInsets computeSystemWindowInsets(WindowInsets,Rect)>",29,30,"<android.view.View: WindowInsets computeSystemWindowInsets(WindowInsets,Rect)>","<android.view.View: WindowInsets computeSystemWindowInsets(WindowInsets,Rect)>",0,"{
    if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || ((mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0 && !mAttachInfo.mOverscanRequested)) {
        outLocalInsets.set(in.getSystemWindowInsetsAsRect());
        return in.consumeSystemWindowInsets().inset(outLocalInsets);
    } else {
        // The application wants to take care of fitting system window for
        // the content...  however we still need to take care of any overscan here.
        final Rect overscan = mAttachInfo.mOverscanInsets;
        outLocalInsets.set(overscan);
        return in.inset(outLocalInsets);
    }
}","{
    boolean isOptionalFitSystemWindows = (mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) != 0 || (mPrivateFlags4 & PFLAG4_FRAMEWORK_OPTIONAL_FITS_SYSTEM_WINDOWS) != 0;
    if (isOptionalFitSystemWindows && mAttachInfo != null) {
        OnContentApplyWindowInsetsListener listener = mAttachInfo.mContentOnApplyWindowInsetsListener;
        if (listener == null) {
            // The application wants to take care of fitting system window for
            // the content.
            outLocalInsets.setEmpty();
            return in;
        }
        Pair<Insets, WindowInsets> result = listener.onContentApplyWindowInsets(this, in);
        outLocalInsets.set(result.first.toRect());
        return result.second;
    } else {
        outLocalInsets.set(in.getSystemWindowInsetsAsRect());
        return in.consumeSystemWindowInsets().inset(outLocalInsets);
    }
}",1,"/**
 * Compute insets that should be consumed by this view and the ones that should propagate
 * to those under it.
 *
 * @param in Insets currently being processed by this View, likely received as a parameter
 * to {@link #onApplyWindowInsets(WindowInsets)}.
 * @param outLocalInsets A Rect that will receive the insets that should be consumed
 * by this view
 * @return Insets that should be passed along to views under this one
 */
","/**
 * Compute insets that should be consumed by this view and the ones that should propagate
 * to those under it.
 *
 * @param in Insets currently being processed by this View, likely received as a parameter
 * to {@link #onApplyWindowInsets(WindowInsets)}.
 * @param outLocalInsets A Rect that will receive the insets that should be consumed
 * by this view
 * @return Insets that should be passed along to views under this one
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The return statements are changed, new variables and conditional logic have been introduced, and the method now relies on a listener which is a dependent API element that might have changed, so the code change type is 1,3,5.","Due to the change in return statements and control flow, the API potentially returns different variables. This can lead to a CI due to the potential change in the return value, and hence the CI type is 1."
340,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,29,30,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,0,"{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            setValue(values.mNameConstant, value);
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    mView.invalidateViewProperty(false, false);
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}","{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}",1,"/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
","/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change includes adding new logic for handling the ALPHA property and changing how method invocations are done when ALPHA is set. Specifically, it adds an alphaHandled flag, calls setAlphaNoInvalidation(value), uses alphaHandled to determine the type of invalidation, and changes the call to mView.invalidateViewProperty(false, false) under certain conditions. This qualifies as a change in control dependency (due to a new if statement for the alphaHandled flag) and other changes (due to different method invocations and logic related to alpha handling), which are classified as changes of types 3 and 4.","Although there is a change in the control flow and method invocations when the ALPHA property is modified, these changes do not affect the behavior of onAnimationUpdate from the perspective of the caller. The changes made internally to the method's handling of the ALPHA property do not alter the method's contract or the expected result of the onAnimationUpdate invocation. Therefore, it is unlikely that these changes will introduce a compatibility issue that could affect the callers of the method, resulting in no compatibility issue, type 0."
342,"<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>",29,30,"<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>","<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from calling `broadcastIntent` to `broadcastIntentWithFeature` on `ActivityManager.getService()`, which is a change to a dependent API.","There is no compatibility issue indicated by the given code change, as there is no change in the behavior, returned values, or exceptions that this API method sends out. The modification is in the underlying implementation detail to invoke a different method, but it accomplishes the same end goal of sending a broadcast with the intent. The exception handling remains the same, and there is no change to the return type or control flow that affects the API's behavior from a caller perspective. Therefore, there is no compatibility issue here."
343,"<android.app.assist.AssistStructure.ViewNode: int writeSelfToParcel(Parcel,PooledStringWriter,boolean,float[])>",29,30,"<android.app.assist.AssistStructure.ViewNode: int writeSelfToParcel(Parcel,PooledStringWriter,boolean,float[])>","<android.app.assist.AssistStructure.ViewNode: int writeSelfToParcel(Parcel,PooledStringWriter,boolean,float[])>",0,"{
    // Guard used to skip non-sanitized data when writing for autofill.
    boolean writeSensitive = true;
    int flags = mFlags & ~FLAGS_ALL_CONTROL;
    int autofillFlags = 0;
    if (mId != View.NO_ID) {
        flags |= FLAGS_HAS_ID;
    }
    if ((mX & ~0x7fff) != 0 || (mY & ~0x7fff) != 0 || (mWidth & ~0x7fff) != 0 | (mHeight & ~0x7fff) != 0) {
        flags |= FLAGS_HAS_LARGE_COORDS;
    }
    if (mScrollX != 0 || mScrollY != 0) {
        flags |= FLAGS_HAS_SCROLL;
    }
    if (mMatrix != null) {
        flags |= FLAGS_HAS_MATRIX;
    }
    if (mElevation != 0) {
        flags |= FLAGS_HAS_ELEVATION;
    }
    if (mAlpha != 1.0f) {
        flags |= FLAGS_HAS_ALPHA;
    }
    if (mContentDescription != null) {
        flags |= FLAGS_HAS_CONTENT_DESCRIPTION;
    }
    if (mText != null) {
        flags |= FLAGS_HAS_TEXT;
        if (!mText.isSimple()) {
            flags |= FLAGS_HAS_COMPLEX_TEXT;
        }
    }
    if (mInputType != 0) {
        flags |= FLAGS_HAS_INPUT_TYPE;
    }
    if (mWebScheme != null || mWebDomain != null) {
        flags |= FLAGS_HAS_URL;
    }
    if (mLocaleList != null) {
        flags |= FLAGS_HAS_LOCALE_LIST;
    }
    if (mExtras != null) {
        flags |= FLAGS_HAS_EXTRAS;
    }
    if (mChildren != null) {
        flags |= FLAGS_HAS_CHILDREN;
    }
    if (mAutofillId != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_VIEW_ID;
        if (mAutofillId.isVirtualInt()) {
            autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_VIRTUAL_VIEW_ID;
        }
        if (mAutofillId.hasSession()) {
            autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_SESSION_ID;
        }
    }
    if (mAutofillValue != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_VALUE;
    }
    if (mAutofillType != View.AUTOFILL_TYPE_NONE) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_TYPE;
    }
    if (mAutofillHints != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_HINTS;
    }
    if (mAutofillOptions != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_OPTIONS;
    }
    if (mHtmlInfo instanceof Parcelable) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_HTML_INFO;
    }
    if (mMinEms > -1) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_MIN_TEXT_EMS;
    }
    if (mMaxEms > -1) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_MAX_TEXT_EMS;
    }
    if (mMaxLength > -1) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_MAX_TEXT_LENGTH;
    }
    if (mTextIdEntry != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_TEXT_ID_ENTRY;
    }
    pwriter.writeString(mClassName);
    int writtenFlags = flags;
    if (autofillFlags != 0 && (mSanitized || !sanitizeOnWrite)) {
        // Remove 'checked' from sanitized autofill request.
        writtenFlags = flags & ~FLAGS_CHECKED;
    }
    if (mAutofillOverlay != null) {
        if (mAutofillOverlay.focused) {
            writtenFlags |= ViewNode.FLAGS_FOCUSED;
        } else {
            writtenFlags &= ~ViewNode.FLAGS_FOCUSED;
        }
    }
    out.writeInt(writtenFlags);
    out.writeInt(autofillFlags);
    if ((flags & FLAGS_HAS_ID) != 0) {
        out.writeInt(mId);
        if (mId != View.NO_ID) {
            pwriter.writeString(mIdEntry);
            if (mIdEntry != null) {
                pwriter.writeString(mIdType);
                pwriter.writeString(mIdPackage);
            }
        }
    }
    if (autofillFlags != 0) {
        out.writeInt(mSanitized ? 1 : 0);
        out.writeInt(mImportantForAutofill);
        writeSensitive = mSanitized || !sanitizeOnWrite;
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIEW_ID) != 0) {
            out.writeInt(mAutofillId.getViewId());
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIRTUAL_VIEW_ID) != 0) {
                out.writeInt(mAutofillId.getVirtualChildIntId());
            }
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_SESSION_ID) != 0) {
                out.writeInt(mAutofillId.getSessionId());
            }
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_TYPE) != 0) {
            out.writeInt(mAutofillType);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_HINTS) != 0) {
            out.writeStringArray(mAutofillHints);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VALUE) != 0) {
            final AutofillValue sanitizedValue;
            if (writeSensitive) {
                sanitizedValue = mAutofillValue;
            } else if (mAutofillOverlay != null && mAutofillOverlay.value != null) {
                sanitizedValue = mAutofillOverlay.value;
            } else {
                sanitizedValue = null;
            }
            out.writeParcelable(sanitizedValue, 0);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_OPTIONS) != 0) {
            out.writeCharSequenceArray(mAutofillOptions);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_HTML_INFO) != 0) {
            out.writeParcelable((Parcelable) mHtmlInfo, 0);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MIN_TEXT_EMS) != 0) {
            out.writeInt(mMinEms);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_EMS) != 0) {
            out.writeInt(mMaxEms);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_LENGTH) != 0) {
            out.writeInt(mMaxLength);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_TEXT_ID_ENTRY) != 0) {
            pwriter.writeString(mTextIdEntry);
        }
    }
    if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
        out.writeInt(mX);
        out.writeInt(mY);
        out.writeInt(mWidth);
        out.writeInt(mHeight);
    } else {
        out.writeInt((mY << 16) | mX);
        out.writeInt((mHeight << 16) | mWidth);
    }
    if ((flags & FLAGS_HAS_SCROLL) != 0) {
        out.writeInt(mScrollX);
        out.writeInt(mScrollY);
    }
    if ((flags & FLAGS_HAS_MATRIX) != 0) {
        mMatrix.getValues(tmpMatrix);
        out.writeFloatArray(tmpMatrix);
    }
    if ((flags & FLAGS_HAS_ELEVATION) != 0) {
        out.writeFloat(mElevation);
    }
    if ((flags & FLAGS_HAS_ALPHA) != 0) {
        out.writeFloat(mAlpha);
    }
    if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
        TextUtils.writeToParcel(mContentDescription, out, 0);
    }
    if ((flags & FLAGS_HAS_TEXT) != 0) {
        mText.writeToParcel(out, (flags & FLAGS_HAS_COMPLEX_TEXT) == 0, writeSensitive);
    }
    if ((flags & FLAGS_HAS_INPUT_TYPE) != 0) {
        out.writeInt(mInputType);
    }
    if ((flags & FLAGS_HAS_URL) != 0) {
        out.writeString(mWebScheme);
        out.writeString(mWebDomain);
    }
    if ((flags & FLAGS_HAS_LOCALE_LIST) != 0) {
        out.writeParcelable(mLocaleList, 0);
    }
    if ((flags & FLAGS_HAS_EXTRAS) != 0) {
        out.writeBundle(mExtras);
    }
    return flags;
}","{
    // Guard used to skip non-sanitized data when writing for autofill.
    boolean writeSensitive = true;
    int flags = mFlags & ~FLAGS_ALL_CONTROL;
    int autofillFlags = 0;
    if (mId != View.NO_ID) {
        flags |= FLAGS_HAS_ID;
    }
    if ((mX & ~0x7fff) != 0 || (mY & ~0x7fff) != 0 || (mWidth & ~0x7fff) != 0 | (mHeight & ~0x7fff) != 0) {
        flags |= FLAGS_HAS_LARGE_COORDS;
    }
    if (mScrollX != 0 || mScrollY != 0) {
        flags |= FLAGS_HAS_SCROLL;
    }
    if (mMatrix != null) {
        flags |= FLAGS_HAS_MATRIX;
    }
    if (mElevation != 0) {
        flags |= FLAGS_HAS_ELEVATION;
    }
    if (mAlpha != 1.0f) {
        flags |= FLAGS_HAS_ALPHA;
    }
    if (mContentDescription != null) {
        flags |= FLAGS_HAS_CONTENT_DESCRIPTION;
    }
    if (mText != null) {
        flags |= FLAGS_HAS_TEXT;
        if (!mText.isSimple()) {
            flags |= FLAGS_HAS_COMPLEX_TEXT;
        }
    }
    if (mInputType != 0) {
        flags |= FLAGS_HAS_INPUT_TYPE;
    }
    if (mWebScheme != null) {
        flags |= FLAGS_HAS_URL_SCHEME;
    }
    if (mWebDomain != null) {
        flags |= FLAGS_HAS_URL_DOMAIN;
    }
    if (mLocaleList != null) {
        flags |= FLAGS_HAS_LOCALE_LIST;
    }
    if (mExtras != null) {
        flags |= FLAGS_HAS_EXTRAS;
    }
    if (mChildren != null) {
        flags |= FLAGS_HAS_CHILDREN;
    }
    if (mAutofillId != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_VIEW_ID;
        if (mAutofillId.isVirtualInt()) {
            autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_VIRTUAL_VIEW_ID;
        }
        if (mAutofillId.hasSession()) {
            autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_SESSION_ID;
        }
    }
    if (mAutofillValue != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_VALUE;
    }
    if (mAutofillType != View.AUTOFILL_TYPE_NONE) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_TYPE;
    }
    if (mAutofillHints != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_HINTS;
    }
    if (mAutofillOptions != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_OPTIONS;
    }
    if (mHtmlInfo instanceof Parcelable) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_HTML_INFO;
    }
    if (mMinEms > -1) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_MIN_TEXT_EMS;
    }
    if (mMaxEms > -1) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_MAX_TEXT_EMS;
    }
    if (mMaxLength > -1) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_MAX_TEXT_LENGTH;
    }
    if (mTextIdEntry != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_TEXT_ID_ENTRY;
    }
    if (mHintIdEntry != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_HINT_ID_ENTRY;
    }
    pwriter.writeString(mClassName);
    int writtenFlags = flags;
    if (autofillFlags != 0 && (mSanitized || !sanitizeOnWrite)) {
        // Remove 'checked' from sanitized autofill request.
        writtenFlags = flags & ~FLAGS_CHECKED;
    }
    if (mAutofillOverlay != null) {
        if (mAutofillOverlay.focused) {
            writtenFlags |= ViewNode.FLAGS_FOCUSED;
        } else {
            writtenFlags &= ~ViewNode.FLAGS_FOCUSED;
        }
    }
    out.writeInt(writtenFlags);
    out.writeInt(autofillFlags);
    if ((flags & FLAGS_HAS_ID) != 0) {
        out.writeInt(mId);
        if (mId != View.NO_ID) {
            pwriter.writeString(mIdEntry);
            if (mIdEntry != null) {
                pwriter.writeString(mIdType);
                pwriter.writeString(mIdPackage);
            }
        }
    }
    if (autofillFlags != 0) {
        out.writeInt(mSanitized ? 1 : 0);
        out.writeInt(mImportantForAutofill);
        writeSensitive = mSanitized || !sanitizeOnWrite;
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIEW_ID) != 0) {
            out.writeInt(mAutofillId.getViewId());
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIRTUAL_VIEW_ID) != 0) {
                out.writeInt(mAutofillId.getVirtualChildIntId());
            }
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_SESSION_ID) != 0) {
                out.writeInt(mAutofillId.getSessionId());
            }
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_TYPE) != 0) {
            out.writeInt(mAutofillType);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_HINTS) != 0) {
            out.writeStringArray(mAutofillHints);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VALUE) != 0) {
            final AutofillValue sanitizedValue;
            if (writeSensitive) {
                sanitizedValue = mAutofillValue;
            } else if (mAutofillOverlay != null && mAutofillOverlay.value != null) {
                sanitizedValue = mAutofillOverlay.value;
            } else {
                sanitizedValue = null;
            }
            out.writeParcelable(sanitizedValue, 0);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_OPTIONS) != 0) {
            out.writeCharSequenceArray(mAutofillOptions);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_HTML_INFO) != 0) {
            out.writeParcelable((Parcelable) mHtmlInfo, 0);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MIN_TEXT_EMS) != 0) {
            out.writeInt(mMinEms);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_EMS) != 0) {
            out.writeInt(mMaxEms);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_LENGTH) != 0) {
            out.writeInt(mMaxLength);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_TEXT_ID_ENTRY) != 0) {
            pwriter.writeString(mTextIdEntry);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_HINT_ID_ENTRY) != 0) {
            pwriter.writeString(mHintIdEntry);
        }
    }
    if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
        out.writeInt(mX);
        out.writeInt(mY);
        out.writeInt(mWidth);
        out.writeInt(mHeight);
    } else {
        out.writeInt((mY << 16) | mX);
        out.writeInt((mHeight << 16) | mWidth);
    }
    if ((flags & FLAGS_HAS_SCROLL) != 0) {
        out.writeInt(mScrollX);
        out.writeInt(mScrollY);
    }
    if ((flags & FLAGS_HAS_MATRIX) != 0) {
        mMatrix.getValues(tmpMatrix);
        out.writeFloatArray(tmpMatrix);
    }
    if ((flags & FLAGS_HAS_ELEVATION) != 0) {
        out.writeFloat(mElevation);
    }
    if ((flags & FLAGS_HAS_ALPHA) != 0) {
        out.writeFloat(mAlpha);
    }
    if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
        TextUtils.writeToParcel(mContentDescription, out, 0);
    }
    if ((flags & FLAGS_HAS_TEXT) != 0) {
        mText.writeToParcel(out, (flags & FLAGS_HAS_COMPLEX_TEXT) == 0, writeSensitive);
    }
    if ((flags & FLAGS_HAS_INPUT_TYPE) != 0) {
        out.writeInt(mInputType);
    }
    if ((flags & FLAGS_HAS_URL_SCHEME) != 0) {
        out.writeString(mWebScheme);
    }
    if ((flags & FLAGS_HAS_URL_DOMAIN) != 0) {
        out.writeString(mWebDomain);
    }
    if ((flags & FLAGS_HAS_LOCALE_LIST) != 0) {
        out.writeParcelable(mLocaleList, 0);
    }
    if ((flags & FLAGS_HAS_EXTRAS) != 0) {
        out.writeBundle(mExtras);
    }
    return flags;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
344,<android.app.AlarmManager.ListenerWrapper: void cancel()>,29,30,<android.app.AlarmManager.ListenerWrapper: void cancel()>,<android.app.AlarmManager.ListenerWrapper: void cancel()>,0,"{
    try {
        mService.remove(null, this);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
    synchronized (AlarmManager.class) {
        if (sWrappers != null) {
            sWrappers.remove(mListener);
        }
    }
}","{
    try {
        mService.remove(null, this);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"The synchronized block which contains the statement for removing the listener from the wrappers list is removed in the late version, so the code change types are 1 (return statement changed because of the removed block that affects the program flow) and 4 (other statement changed since it's a removal of a code block, not related to return, exception handling, or control dependency).","The removal of the synchronized block does not lead to a Compatibility Issue as the removed block does not affect the API contract; it's related to internal state management which does not involve changing return values or the exceptions thrown by the API. Hence, the CI type is 0."
345,<android.appwidget.AppWidgetHost: void startListening()>,29,30,<android.appwidget.AppWidgetHost: void startListening()>,<android.appwidget.AppWidgetHost: void startListening()>,0,"{
    if (sService == null) {
        return;
    }
    final int[] idsToUpdate;
    synchronized (mViews) {
        int N = mViews.size();
        idsToUpdate = new int[N];
        for (int i = 0; i < N; i++) {
            idsToUpdate[i] = mViews.keyAt(i);
        }
    }
    List<PendingHostUpdate> updates;
    try {
        updates = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, idsToUpdate).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    int N = updates.size();
    for (int i = 0; i < N; i++) {
        PendingHostUpdate update = updates.get(i);
        switch(update.type) {
            case PendingHostUpdate.TYPE_VIEWS_UPDATE:
                updateAppWidgetView(update.appWidgetId, update.views);
                break;
            case PendingHostUpdate.TYPE_PROVIDER_CHANGED:
                onProviderChanged(update.appWidgetId, update.widgetInfo);
                break;
            case PendingHostUpdate.TYPE_VIEW_DATA_CHANGED:
                viewDataChanged(update.appWidgetId, update.viewId);
        }
    }
}","{
    if (sService == null) {
        return;
    }
    final int[] idsToUpdate;
    synchronized (mViews) {
        int N = mViews.size();
        idsToUpdate = new int[N];
        for (int i = 0; i < N; i++) {
            idsToUpdate[i] = mViews.keyAt(i);
        }
    }
    List<PendingHostUpdate> updates;
    try {
        updates = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, idsToUpdate).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    int N = updates.size();
    for (int i = 0; i < N; i++) {
        PendingHostUpdate update = updates.get(i);
        switch(update.type) {
            case PendingHostUpdate.TYPE_VIEWS_UPDATE:
                updateAppWidgetView(update.appWidgetId, update.views);
                break;
            case PendingHostUpdate.TYPE_PROVIDER_CHANGED:
                onProviderChanged(update.appWidgetId, update.widgetInfo);
                break;
            case PendingHostUpdate.TYPE_VIEW_DATA_CHANGED:
                viewDataChanged(update.appWidgetId, update.viewId);
                break;
            case PendingHostUpdate.TYPE_APP_WIDGET_REMOVED:
                dispatchOnAppWidgetRemoved(update.appWidgetId);
                break;
        }
    }
}",1,"/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
","/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code added a new case statement (case PendingHostUpdate.TYPE_APP_WIDGET_REMOVED) inside the switch control statement, which corresponds to a change type of 3 for control dependency change and 4 for other statement change.","The additional case in the switch statement does not affect the return value of the method or introduce a new exception that the method might throw. The method's signature indicates a 'void' return type, therefore only its side effects (e.g., calling 'dispatchOnAppWidgetRemoved') are affected. This change should not cause a compatibility issue based on the current method's contract, so there is no compatibility issue (0)."
346,"<android.view.textclassifier.SelectionEvent: SelectionEvent createSelectionModifiedEvent(int,int,TextSelection)>",29,30,"<android.view.textclassifier.SelectionEvent: SelectionEvent createSelectionModifiedEvent(int,int,TextSelection)>","<android.view.textclassifier.SelectionEvent: SelectionEvent createSelectionModifiedEvent(int,int,TextSelection)>",0,"{
    Preconditions.checkArgument(end >= start, ""end cannot be less than start"");
    Preconditions.checkNotNull(selection);
    final String entityType = selection.getEntityCount() > 0 ? selection.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    return new SelectionEvent(start, end, SelectionEvent.EVENT_AUTO_SELECTION, entityType, INVOCATION_UNKNOWN, selection.getId());
}","{
    Preconditions.checkArgument(end >= start, ""end cannot be less than start"");
    Objects.requireNonNull(selection);
    final String entityType = selection.getEntityCount() > 0 ? selection.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    return new SelectionEvent(start, end, SelectionEvent.EVENT_AUTO_SELECTION, entityType, INVOCATION_UNKNOWN, selection.getId());
}",1,"/**
 * Creates a ""selection modified"" event.
 * Use when a TextClassifier modifies the selection.
 *
 * @param start  the start (inclusive) index of the selection
 * @param end  the end (exclusive) index of the selection
 * @param selection  the TextSelection object returned by the TextClassifier for the
 * specified selection
 *
 * @throws IllegalArgumentException if end is less than start
 */
","/**
 * Creates a ""selection modified"" event.
 * Use when a TextClassifier modifies the selection.
 *
 * @param start  the start (inclusive) index of the selection
 * @param end  the end (exclusive) index of the selection
 * @param selection  the TextSelection object returned by the TextClassifier for the
 * specified selection
 *
 * @throws IllegalArgumentException if end is less than start
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The method call Preconditions.checkNotNull(selection) has been changed to Objects.requireNonNull(selection). This change is related only to the internal implementation of the null check, so the code change type is 4.","There is no Compatibility Issue as the behavior and contract of the API have not changed. Both Preconditions.checkNotNull(selection) and Objects.requireNonNull(selection) serve to check for null references and throw an appropriate exception, not affecting the return type, values, or the exceptions declared to be thrown by this method."
347,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",29,30,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",0,"{
    final PackageParser parser = new PackageParser();
    parser.setCallback(new PackageParser.CallbackImpl(this));
    final File apkFile = new File(archiveFilePath);
    try {
        if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
        // Caller expressed an explicit opinion about what encryption
        // aware/unaware components they want to see, so fall through and
        // give them what they want
        } else {
            // Caller expressed no opinion, so match everything
            flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            PackageParser.collectCertificates(pkg, false);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}","{
    if ((flags & (PackageManager.MATCH_DIRECT_BOOT_UNAWARE | PackageManager.MATCH_DIRECT_BOOT_AWARE)) == 0) {
        // Caller expressed no opinion about what encryption
        // aware/unaware components they want to see, so match both
        flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;
    }
    boolean collectCertificates = (flags & PackageManager.GET_SIGNATURES) != 0 || (flags & PackageManager.GET_SIGNING_CERTIFICATES) != 0;
    ParseInput input = ParseTypeImpl.forParsingWithoutPlatformCompat().reset();
    ParseResult<ParsingPackage> result = ParsingPackageUtils.parseDefault(input, new File(archiveFilePath), 0, collectCertificates);
    if (result.isError()) {
        return null;
    }
    return PackageInfoWithoutStateUtils.generate(result.getResult(), null, flags, 0, 0, null, new PackageUserState(), UserHandle.getCallingUserId());
}",1,"/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */
","/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The return statements and the exception handling have been changed. The decision logic with the variable 'flags' has been inverted and simplified, and the way flags are checked for GET_SIGNATURES has been changed to also check for GET_SIGNING_CERTIFICATES. Additionally, the method for parsing the package and generating the package info has changed significantly, utilizing different classes and methods such as `ParseInput`, `ParseResult`, `ParsingPackageUtils.parseDefault`, and `PackageInfoWithoutStateUtils.generate`. Also, these changes include dependent API changes for parsing and information generation, making the change types 1, 3, 4, and 5.","The return value may differ because the way how the package is parsed and the package info is generated has changed. Furthermore, the exception handling has been changed as a catch for a specific `PackageParserException` has been removed and the new implementation does not include such a catch, meaning that exceptions could be propagated differently. These could potentially cause different return values or exceptions, so both CI types 1 and 2 are applicable here."
348,"<android.view.KeyEvent: KeyEvent changeFlags(KeyEvent,int)>",29,30,"<android.view.KeyEvent: KeyEvent changeFlags(KeyEvent,int)>","<android.view.KeyEvent: KeyEvent changeFlags(KeyEvent,int)>",0,"{
    event = new KeyEvent(event);
    event.mFlags = flags;
    return event;
}","{
    event = new KeyEvent(event);
    // Not an exact copy so assign a new ID.
    event.mId = nativeNextId();
    event.mFlags = flags;
    return event;
}",1,"/**
 * Create a new key event that is the same as the given one, but whose
 * flags are replaced with the given value.
 *
 * @param event The existing event to be copied.  This is not modified.
 * @param flags The new flags constant.
 */
","/**
 * Create a new key event that is the same as the given one, but whose
 * flags are replaced with the given value.
 *
 * @param event The existing event to be copied.  This is not modified.
 * @param flags The new flags constant.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new statement `event.mId = nativeNextId();` has been introduced, which does not change the return type or the exception handling, so the code change type is 4.","This change assigns a new ID to the event but it does not alter the event's flags or any behavior related to the flags, which is what the API is supposed to manage. The method still returns a KeyEvent object with updated flags, so there's no Compatibility Issue caused by this change, hence CI type is 0."
349,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,29,30,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,0,"{
    final int flags = (mFlags & ~Context.CONTEXT_DEVICE_PROTECTED_STORAGE) | Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, flags, mClassLoader, null);
}","{
    final int flags = (mFlags & ~Context.CONTEXT_DEVICE_PROTECTED_STORAGE) | Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, mSplitName, mToken, mUser, flags, mClassLoader, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The constructor of ContextImpl has changed with the addition of parameters like mAttributionTag and mToken instead of mActivityToken, so the code change type is 4 for the constructor call change and also 5 since the dependent API (ContextImpl constructor) has changed.","Since the change only affects the parameters passed into the constructor, but does not affect the return type nor the behavior of the method itself (assuming that the new parameters are correctly handled within the ContextImpl constructor), there is no Compatibility Issue; the constructor changes are internal, and there is no indication of a different return type or exception behavior from the provided information. Thus the CI type is 0."
350,<android.view.DisplayAddress.Physical: String toString()>,29,30,<android.view.DisplayAddress.Physical: String toString()>,<android.view.DisplayAddress.Physical: String toString()>,0,"{
    final StringBuilder builder = new StringBuilder(""{"").append(""port="").append(getPort() & PORT_MASK);
    final Long model = getModel();
    if (model != null) {
        builder.append("", model=0x"").append(Long.toHexString(model));
    }
    return builder.append(""}"").toString();
}","{
    final StringBuilder builder = new StringBuilder(""{"").append(""port="").append(Byte.toUnsignedInt(getPort()));
    final Long model = getModel();
    if (model != null) {
        builder.append("", model=0x"").append(Long.toHexString(model));
    }
    return builder.append(""}"").toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The change is in the implementation of `toString()` method where the way 'port' value is appended to the `StringBuilder` has been changed from using bitwise AND operation with `PORT_MASK` to using `Byte.toUnsignedInt()`. Apart from that, the method `getPort()` is a dependent API which potentially could have its implementation changed as well, so the code change type is 4,5.","Since the method of obtaining the port value has changed, the string representation of `DisplayAddress.Physical` object might differ between the two versions. Thus, this could lead to the API returning a different value, and the CI type is 1."
351,"<android.content.ContentProviderOperation.Builder: Builder withSelectionBackReference(int,int)>",29,30,"<android.content.ContentProviderOperation.Builder: Builder withSelectionBackReference(int,int)>","<android.content.ContentProviderOperation.Builder: Builder withSelectionBackReference(int,int)>",0,"{
    if (mType != TYPE_UPDATE && mType != TYPE_DELETE && mType != TYPE_ASSERT) {
        throw new IllegalArgumentException(""only updates, deletes, and asserts "" + ""can have selection back-references"");
    }
    if (mSelectionArgsBackReferences == null) {
        mSelectionArgsBackReferences = new HashMap<Integer, Integer>();
    }
    mSelectionArgsBackReferences.put(selectionArgIndex, previousResult);
    return this;
}","{
    assertSelectionAllowed();
    setSelectionArg(index, new BackReference(fromIndex, null));
    return this;
}",1,"/**
 * Add a back references as a selection arg. Any value at that index of the selection arg
 * that was specified by {@link #withSelection} will be overwritten.
 * This can only be used with builders of type update, delete, or assert.
 * @return this builder, to allow for chaining.
 */
","/**
 * Configure the given selection argument to be dynamically overwritten
 * using the result of a previous operation. This method will replace
 * any previously defined selection argument at this index.
 *
 * @param index the index indicating which selection argument to
 * configure
 * @param fromIndex the index indicating which historical
 * {@link ContentProviderResult} should overwrite the
 * selection argument
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"2,4,5",2,"There's the introduction of new methods assertSelectionAllowed() and setSelectionArg(), along with the deletion of the previous if-conditions and instantiations of the HashMap for selection back-references, so the change types are 2,4,5.","The early version throws IllegalArgumentException directly within the method, whereas the late version could potentially throw exceptions from within the assertSelectionAllowed() or setSelectionArg() methods, which might not necessarily be IllegalArgumentException and are implemented elsewhere. Thus, this constitutes a CI of type 2 due to different exception handling."
352,"<android.app.ContextImpl: ContextImpl createActivityContext(ActivityThread,LoadedApk,ActivityInfo,IBinder,int,Configuration)>",29,30,"<android.app.ContextImpl: ContextImpl createActivityContext(ActivityThread,LoadedApk,ActivityInfo,IBinder,int,Configuration)>","<android.app.ContextImpl: ContextImpl createActivityContext(ActivityThread,LoadedApk,ActivityInfo,IBinder,int,Configuration)>",0,"{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    String[] splitDirs = packageInfo.getSplitResDirs();
    ClassLoader classLoader = packageInfo.getClassLoader();
    if (packageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, ""SplitDependencies"");
        try {
            classLoader = packageInfo.getSplitClassLoader(activityInfo.splitName);
            splitDirs = packageInfo.getSplitPaths(activityInfo.splitName);
        } catch (NameNotFoundException e) {
            // Nothing above us can handle a NameNotFoundException, better crash.
            throw new RuntimeException(e);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
        }
    }
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, activityInfo.splitName, activityToken, null, 0, classLoader, null);
    // Clamp display ID to DEFAULT_DISPLAY if it is INVALID_DISPLAY.
    displayId = (displayId != Display.INVALID_DISPLAY) ? displayId : Display.DEFAULT_DISPLAY;
    final CompatibilityInfo compatInfo = (displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
    final ResourcesManager resourcesManager = ResourcesManager.getInstance();
    // Create the base resources for which all configuration contexts for this Activity
    // will be rebased upon.
    context.setResources(resourcesManager.createBaseActivityResources(activityToken, packageInfo.getResDir(), splitDirs, packageInfo.getOverlayDirs(), packageInfo.getApplicationInfo().sharedLibraryFiles, displayId, overrideConfiguration, compatInfo, classLoader));
    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId, context.getResources());
    return context;
}","{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    String[] splitDirs = packageInfo.getSplitResDirs();
    ClassLoader classLoader = packageInfo.getClassLoader();
    if (packageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, ""SplitDependencies"");
        try {
            classLoader = packageInfo.getSplitClassLoader(activityInfo.splitName);
            splitDirs = packageInfo.getSplitPaths(activityInfo.splitName);
        } catch (NameNotFoundException e) {
            // Nothing above us can handle a NameNotFoundException, better crash.
            throw new RuntimeException(e);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
        }
    }
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, activityInfo.splitName, activityToken, null, 0, classLoader, null);
    context.mIsUiContext = true;
    context.mIsAssociatedWithDisplay = true;
    context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);
    // Clamp display ID to DEFAULT_DISPLAY if it is INVALID_DISPLAY.
    displayId = (displayId != Display.INVALID_DISPLAY) ? displayId : Display.DEFAULT_DISPLAY;
    final CompatibilityInfo compatInfo = (displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
    final ResourcesManager resourcesManager = ResourcesManager.getInstance();
    // Create the base resources for which all configuration contexts for this Activity
    // will be rebased upon.
    context.setResources(resourcesManager.createBaseTokenResources(activityToken, packageInfo.getResDir(), splitDirs, packageInfo.getOverlayDirs(), packageInfo.getApplicationInfo().sharedLibraryFiles, displayId, overrideConfiguration, compatInfo, classLoader, packageInfo.getApplication() == null ? null : packageInfo.getApplication().getResources().getLoaders()));
    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId, context.getResources());
    return context;
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"3,4",0,"The constructor call to ContextImpl differs in the supplied parameters between the two versions, and three new lines (context.mIsUiContext = true; context.mIsAssociatedWithDisplay = true; context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);) have been added in the late version of the implementation. Also, the call to `resourcesManager.createBaseActivityResources` method in the early version is replaced with `resourcesManager.createBaseTokenResources` method along with the last parameter changed in the late version. Thus, the changes can be classified as both control dependency changed (3) because the logic flow is adjusted with the new settings, and other statement changed (4), due to the different method calls and parameters passed.","There appears to be no change in the logic that would lead to a different return value or throw a different exception in the normal execution flow. The constructor call differences and additional methods set context's new flags to default values, and the changes made to the resource creation method seem to extend functionality rather than alter the existing one, assuming the method signatures match expected functionality. Compatibility issues seem unlikely in these changes assuming underlying systems are designed to handle the new resource call and additional flags correctly, so the CI prediction is 0."
354,"<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>",29,30,"<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>","<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateExtractedText(view, token, text);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        if (mCurMethod != null) {
            try {
                mCurMethod.updateExtractedText(token, text);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateExtractedText(view, token, text);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return;
        }
        if (mCurMethod != null) {
            try {
                mCurMethod.updateExtractedText(token, text);
            } catch (RemoteException e) {
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed after the 'if' statement inside the 'synchronized' block. The condition from `mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))` is simplified to `!hasServedByInputMethodLocked(view)`. Also an implementation detail without any behavior effect is changed within the method, this change type is 4.","Even though there is a code change, it's an internal refactoring that doesn't affect the external behavior of the API. The method either finishes early (with a return) under condition that, despite their different expression, check an equivalent state (i.e., whether the view is currently being served by the input method). Because the change doesn't affect the external behavior, there is no Compatibility Issue."
355,<android.app.UiModeManager: void enableCarMode(int)>,29,30,<android.app.UiModeManager: void enableCarMode(int)>,<android.app.UiModeManager: void enableCarMode(int)>,0,"{
    if (mService != null) {
        try {
            mService.enableCarMode(flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    enableCarMode(DEFAULT_PRIORITY, flags);
}",1,"/**
 * Force device into car mode, like it had been placed in the car dock.
 * This will cause the device to switch to the car home UI as part of
 * the mode switch.
 * @param flags Must be 0.
 */
","/**
 * Force device into car mode, like it had been placed in the car dock.
 * This will cause the device to switch to the car home UI as part of
 * the mode switch.
 * @param flags Must be 0.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"In the late version, the direct call to mService.enableCarMode(flags) has been replaced with a call to enableCarMode(DEFAULT_PRIORITY, flags), which seems like an overloaded version of the enableCarMode method within the same class. This suggests that the actual implementation details have been abstracted, and the late version implementation is now relying on another method within the same API. Therefore, the code change is of type 5 (Dependent API changed).","Since the new method enableCarMode(int,int) is an overload of the existing method and not an external dependency, and assuming the new method correctly handles the operation within the same class, there should not be any Compatibility Issue as the functionality has been retained. Thus, the CI is of type 0 (No Compatibility Issue)."
356,<android.view.textclassifier.TextLanguage.Request: String getCallingPackageName()>,29,30,<android.view.textclassifier.TextLanguage.Request: String getCallingPackageName()>,<android.view.textclassifier.TextLanguage.Request: String getCallingPackageName()>,0,"{
    return mCallingPackageName;
}","{
    return mSystemTcMetadata != null ? mSystemTcMetadata.getCallingPackageName() : null;
}",1,"/**
 * Returns the name of the package that sent this request.
 * This returns null if no calling package name is set.
 */
","/**
 * Returns the name of the package that sent this request.
 * This returns null if no calling package name is set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,1,1,"The return statement is changed from directly returning the value of mCallingPackageName to returning a value conditionally fetched from mSystemTcMetadata or null. This indicates that the method's logic to determine the return value has been updated, therefore the code change type is 1.","This change in the return statement could lead to the API returning a different value in certain circumstances (specifically, when mSystemTcMetadata is not null). Depending on the state of mSystemTcMetadata, null or an actual package name could be returned, which differs from the early version that always returned the value of mCallingPackageName. Thus, the CI type is 1."
357,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRepeatingRequestError(long,int)>",29,30,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRepeatingRequestError(long,int)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRepeatingRequestError(long,int)>",0,"{
    if (DEBUG) {
        Log.d(TAG, ""Repeating request error received. Last frame number is "" + lastFrameNumber);
    }
    synchronized (mInterfaceLock) {
        // Camera is already closed or no repeating request is present.
        if (mRemoteDevice == null || mRepeatingRequestId == REQUEST_ID_NONE) {
            // Camera already closed
            return;
        }
        checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber, mRepeatingRequestTypes);
        // Check if there is already a new repeating request
        if (mRepeatingRequestId == repeatingRequestId) {
            mRepeatingRequestId = REQUEST_ID_NONE;
            mRepeatingRequestTypes = null;
        }
    }
}","{
    if (DEBUG) {
        Log.d(TAG, ""Repeating request error received. Last frame number is "" + lastFrameNumber);
    }
    synchronized (mInterfaceLock) {
        // Camera is already closed or no repeating request is present.
        if (mRemoteDevice == null || mRepeatingRequestId == REQUEST_ID_NONE) {
            // Camera already closed
            return;
        }
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onRepeatingRequestError(lastFrameNumber, repeatingRequestId);
            return;
        }
        checkEarlyTriggerSequenceCompleteLocked(mRepeatingRequestId, lastFrameNumber, mRepeatingRequestTypes);
        // Check if there is already a new repeating request
        if (mRepeatingRequestId == repeatingRequestId) {
            mRepeatingRequestId = REQUEST_ID_NONE;
            mRepeatingRequestTypes = null;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed due to the addition of an if statement checking `mOfflineSessionImpl != null` and the method called within the synchronized block has been renamed from `checkEarlyTriggerSequenceComplete` to `checkEarlyTriggerSequenceCompleteLocked`. This suggests a modification in internal processing, but it does not directly impact the API's return type or exception handling.","No new return statements or exceptions were introduced, and the API always returns void. Thus, there is no change in behavior that would lead to a compatibility issue. The internal changes are related to the control flow, which would not cause the API to produce a different outcome from an external perspective. Therefore, no compatibility issue arises from this change."
358,<android.service.autofill.FillResponse.Builder: FillResponse build()>,29,30,<android.service.autofill.FillResponse.Builder: FillResponse build()>,<android.service.autofill.FillResponse.Builder: FillResponse build()>,0,"{
    throwIfDestroyed();
    if (mAuthentication == null && mDatasets == null && mSaveInfo == null && mDisableDuration == 0 && mFieldClassificationIds == null && mClientState == null) {
        throw new IllegalStateException(""need to provide: at least one DataSet, or a "" + ""SaveInfo, or an authentication with a presentation, "" + ""or a FieldsDetection, or a client state, or disable autofill"");
    }
    if (mDatasets == null && (mHeader != null || mFooter != null)) {
        throw new IllegalStateException(""must add at least 1 dataset when using header or footer"");
    }
    mDestroyed = true;
    return new FillResponse(this);
}","{
    throwIfDestroyed();
    if (mAuthentication == null && mDatasets == null && mSaveInfo == null && mDisableDuration == 0 && mFieldClassificationIds == null && mClientState == null) {
        throw new IllegalStateException(""need to provide: at least one DataSet, or a "" + ""SaveInfo, or an authentication with a presentation, "" + ""or a FieldsDetection, or a client state, or disable autofill"");
    }
    if (mDatasets == null && (mHeader != null || mFooter != null)) {
        throw new IllegalStateException(""must add at least 1 dataset when using header or footer"");
    }
    if (mDatasets != null) {
        for (final Dataset dataset : mDatasets) {
            if (dataset.getFieldInlinePresentation(0) != null) {
                mSupportsInlineSuggestions = true;
                break;
            }
        }
    } else if (mInlinePresentation != null) {
        mSupportsInlineSuggestions = true;
    }
    mDestroyed = true;
    return new FillResponse(this);
}",1,"/**
 * Builds a new {@link FillResponse} instance.
 *
 * @throws IllegalStateException if any of the following conditions occur:
 * <ol>
 * <li>{@link #build()} was already called.
 * <li>No call was made to {@link #addDataset(Dataset)},
 * {@link #setAuthentication(AutofillId[], IntentSender, RemoteViews)},
 * {@link #setSaveInfo(SaveInfo)}, {@link #disableAutofill(long)},
 * {@link #setClientState(Bundle)},
 * or {@link #setFieldClassificationIds(AutofillId...)}.
 * <li>{@link #setHeader(RemoteViews)} or {@link #setFooter(RemoteViews)} is called
 * without any previous calls to {@link #addDataset(Dataset)}.
 * </ol>
 *
 * @return A built response.
 */
","/**
 * Builds a new {@link FillResponse} instance.
 *
 * @throws IllegalStateException if any of the following conditions occur:
 * <ol>
 * <li>{@link #build()} was already called.
 * <li>No call was made to {@link #addDataset(Dataset)},
 * {@link #setAuthentication(AutofillId[], IntentSender, RemoteViews)},
 * {@link #setSaveInfo(SaveInfo)}, {@link #disableAutofill(long)},
 * {@link #setClientState(Bundle)},
 * or {@link #setFieldClassificationIds(AutofillId...)}.
 * <li>{@link #setHeader(RemoteViews)} or {@link #setFooter(RemoteViews)} is called
 * without any previous calls to {@link #addDataset(Dataset)}.
 * </ol>
 *
 * @return A built response.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a new control statement added (an 'if' condition with a loop inside it), which checks whether `dataset.getFieldInlinePresentation(0)` returns not null. Additionally, an 'if' condition to check `mInlinePresentation` is also added. However, since the code does not change the final object that is returned or the exception that is thrown, the change in the implementation does not affect the return value or the exception handling and are purely internal changes to set `mSupportsInlineSuggestions`. So the code change type is 3,4.","Though the implementation has changed internally to include new checks and set a new property (`mSupportsInlineSuggestions`), these changes do not affect the functional contract of the method. The method still returns a new `FillResponse` object without altering the return type or throwing new exceptions. Therefore, there is no compatibility issue, and the CI type is 0."
359,<android.app.Notification.BubbleMetadata.Builder: Builder setIcon(Icon)>,29,30,<android.app.Notification.BubbleMetadata.Builder: Builder setIcon(Icon)>,<android.app.Notification.BubbleMetadata.Builder: Builder setIcon(Icon)>,0,"{
    if (icon == null) {
        throw new IllegalArgumentException(""Bubbles require non-null icon"");
    }
    if (icon.getType() == TYPE_BITMAP) {
        throw new IllegalArgumentException(""When using bitmap based icons, Bubbles "" + ""require TYPE_ADAPTIVE_BITMAP, please use"" + "" Icon#createWithAdaptiveBitmap instead"");
    }
    mIcon = icon;
    return this;
}","{
    if (mShortcutId != null) {
        throw new IllegalStateException(""Created as a shortcut bubble, cannot set an "" + ""Icon. Consider using "" + ""BubbleMetadata.Builder(PendingIntent,Icon) instead."");
    }
    if (icon == null) {
        throw new NullPointerException(""Bubbles require non-null icon"");
    }
    if (icon.getType() != TYPE_URI_ADAPTIVE_BITMAP && icon.getType() != TYPE_URI) {
        Log.w(TAG, ""Bubbles work best with icons of TYPE_URI or "" + ""TYPE_URI_ADAPTIVE_BITMAP. "" + ""In the future, using an icon of this type will be required."");
    }
    mIcon = icon;
    return this;
}",1,"/**
 * Sets the icon that will represent the bubble when it is collapsed.
 *
 * <p>An icon is required and should be representative of the content within the bubble.
 * If your app produces multiple bubbles, the image should be unique for each of them.
 * </p>
 *
 * <p>The shape of a bubble icon is adaptive and can match the device theme.
 *
 * If your icon is bitmap-based, you should create it using
 * {@link Icon#createWithAdaptiveBitmap(Bitmap)}, otherwise this method will throw.
 *
 * If your icon is not bitmap-based, you should expect that the icon will be tinted.
 * </p>
 *
 * @throws IllegalArgumentException if icon is null or a non-adaptive bitmap
 */
","/**
 * Sets the icon for the bubble. Can only be used if the bubble was created
 * via {@link Builder#Builder(PendingIntent, Icon)}.
 *
 * <p>The icon will be used to represent the bubble when it is collapsed. An icon
 * should be representative of the content within the bubble. If your app produces
 * multiple bubbles, the icon should be unique for each of them.</p>
 *
 * <p>It is recommended to use an {@link Icon} of type {@link Icon#TYPE_URI}
 * or {@link Icon#TYPE_URI_ADAPTIVE_BITMAP}</p>
 *
 * @throws NullPointerException  if icon is null.
 * @throws IllegalStateException if this builder was created via
 * {@link Builder#Builder(String)}.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"2,3,4",2,"The early implementation throws IllegalArgumentException for a null icon or TYPE_BITMAP icon type, and the late implementation throws a NullPointerException for a null icon, and an IllegalStateException if 'mShortcutId' is not null. Additionally, the check for icon type has been relaxed in the late implementation with a warning log instead of throwing an exception, and the check for 'mShortcutId' is a new addition. Therefore, the changes include exception handling statements and other statements, making the code change types 2,3,4.","The late version introduces new exception throwing behavior against 'mShortcutId' and changes the exception type for a null icon from IllegalArgumentException to NullPointerException. Moreover, the strict check for bitmap icons has been replaced with a warning. These changes in exception handling potentially cause the API to throw different exceptions. Therefore, the CI type is 2."
360,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,29,30,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,0,"{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(int displayId, @NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(displayId, region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }

        @Override
        public void onFingerprintCapturingGesturesChanged(boolean active) {
            AccessibilityService.this.onFingerprintCapturingGesturesChanged(active);
        }

        @Override
        public void onFingerprintGesture(int gesture) {
            AccessibilityService.this.onFingerprintGesture(gesture);
        }

        @Override
        public void onAccessibilityButtonClicked() {
            AccessibilityService.this.onAccessibilityButtonClicked();
        }

        @Override
        public void onAccessibilityButtonAvailabilityChanged(boolean available) {
            AccessibilityService.this.onAccessibilityButtonAvailabilityChanged(available);
        }
    });
}","{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(AccessibilityGestureEvent gestureEvent) {
            return AccessibilityService.this.onGesture(gestureEvent);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(int displayId, @NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(displayId, region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }

        @Override
        public void onFingerprintCapturingGesturesChanged(boolean active) {
            AccessibilityService.this.onFingerprintCapturingGesturesChanged(active);
        }

        @Override
        public void onFingerprintGesture(int gesture) {
            AccessibilityService.this.onFingerprintGesture(gesture);
        }

        @Override
        public void onAccessibilityButtonClicked(int displayId) {
            AccessibilityService.this.onAccessibilityButtonClicked(displayId);
        }

        @Override
        public void onAccessibilityButtonAvailabilityChanged(boolean available) {
            AccessibilityService.this.onAccessibilityButtonAvailabilityChanged(available);
        }

        @Override
        public void onSystemActionsChanged() {
            AccessibilityService.this.onSystemActionsChanged();
        }
    });
}",1,"/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
","/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The signature of the callback methods onGesture and onAccessibilityButtonClicked has been altered. The former now accepts an AccessibilityGestureEvent instead of an int, and the latter now accepts an int parameter. However, the rest of the implementation details are consistent between the two versions. Therefore, the change type is 4,5 (other statement change and dependent API change).","Despite the altered method signatures in the callbacks, the onBind method itself continues to return the same IBinder object, an instance of IAccessibilityServiceClientWrapper, and the callback methods do not impact the return value of the onBind method. Consequently, there seems to be no compatibility issue regarding the potential return values or types (no CI type 1), nor about potential different exception handlings (no CI type 2). Thus, the CI situation is 0 (No Compatibility Issue)."
363,"<android.app.admin.DevicePolicyManager: void clearUserRestriction(ComponentName,String)>",29,30,"<android.app.admin.DevicePolicyManager: void clearUserRestriction(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void clearUserRestriction(ComponentName,String)>",0,"{
    throwIfParentInstance(""clearUserRestriction"");
    if (mService != null) {
        try {
            mService.setUserRestriction(admin, key, false);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setUserRestriction(admin, key, false, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile or device owner to clear a user restriction specified by the key.
 * <p>
 * The calling device admin must be a profile or device owner; if it is not, a security
 * exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param key The key of the restriction. See the constants in {@link android.os.UserManager}
 * for the list of keys.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Called by a profile or device owner to clear a user restriction specified by the key.
 * <p>
 * The calling device admin must be a profile or device owner; if it is not, a security
 * exception will be thrown.
 * <p>
 * The profile owner of an organization-owned managed profile may invoke this method on
 * the {@link DevicePolicyManager} instance it obtained from
 * {@link #getParentProfileInstance(ComponentName)}, for clearing device-wide restrictions.
 * <p>
 * See the constants in {@link android.os.UserManager} for the list of restrictions.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param key   The key of the restriction.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early implementation contains a call to `throwIfParentInstance(""clearUserRestriction"")` which does not exist in the late implementation. In the late version, `mService.setUserRestriction` is called with an additional parameter, `mParentInstance`. So, the code change type is 4,5.","Even though the method signature remains the same and no change is made to the return type or the exception thrown, the behavioral change does not directly affect what the method returns or which exception is thrown, as `throwIfParentInstance` does not appear to return a value or throw a checked exception that is caught and handled differently. It likely performs an internal check that could potentially influence the subsequent behavior, but since this is not reflected in a changed return or exception declaration in the API itself, there is no direct compatibility issue from this specific change, hence the CI type is 0."
364,<android.os.PowerManager: void reboot(String)>,29,30,<android.os.PowerManager: void reboot(String)>,<android.os.PowerManager: void reboot(String)>,0,"{
    try {
        mService.reboot(false, reason, true);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (REBOOT_USERSPACE.equals(reason) && !isRebootingUserspaceSupported()) {
        throw new UnsupportedOperationException(""Attempted userspace reboot on a device that doesn't support it"");
    }
    try {
        mService.reboot(false, reason, true);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Reboot the device.  Will not return if the reboot is successful.
 * <p>
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 * </p>
 *
 * @param reason code to pass to the kernel (e.g., ""recovery"") to
 * request special boot modes, or null.
 */
","/**
 * Reboot the device.  Will not return if the reboot is successful.
 * <p>
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 * </p>
 *
 * @param reason code to pass to the kernel (e.g., ""recovery"") to
 * request special boot modes, or null.
 * @throws UnsupportedOperationException if userspace reboot was requested on a device that
 * doesn't support it.
 */
",-1,,[@RequiresPermission(permission.REBOOT)],-1,-1,-1,-1,-1,-1,3,"1,2","A new control dependency and a new exception handling statement (throw new UnsupportedOperationException(""Attempted userspace reboot on a device that doesn't support it"")) have been added, so the code change type is 3.","The new control dependency changes the behavior when REBOOT_USERSPACE is the reason for reboot and the device does not support userspace reboot, which was not checked before. This can lead to a new exception type being thrown which is a CI, therefore, the CI type is 1 for return values and 2 for exception handling changes."
365,<android.view.WindowManager.LayoutParams: boolean mayUseInputMethod(int)>,29,30,<android.view.WindowManager.LayoutParams: boolean mayUseInputMethod(int)>,<android.view.WindowManager.LayoutParams: boolean mayUseInputMethod(int)>,0,"{
    switch(flags & (FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM)) {
        case 0:
        case FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM:
            return true;
    }
    return false;
}","{
    return (flags & FLAG_NOT_FOCUSABLE) != FLAG_NOT_FOCUSABLE && (flags & FLAG_ALT_FOCUSABLE_IM) != FLAG_ALT_FOCUSABLE_IM;
}",1,"/**
 * Given a particular set of window manager flags, determine whether
 * such a window may be a target for an input method when it has
 * focus.  In particular, this checks the
 * {@link #FLAG_NOT_FOCUSABLE} and {@link #FLAG_ALT_FOCUSABLE_IM}
 * flags and returns true if the combination of the two corresponds
 * to a window that needs to be behind the input method so that the
 * user can type into it.
 *
 * @param flags The current window manager flags.
 *
 * @return Returns true if such a window should be behind/interact
 * with an input method, false if not.
 */
","/**
 * Given a particular set of window manager flags, determine whether
 * such a window may be a target for an input method when it has
 * focus.  In particular, this checks the
 * {@link #FLAG_NOT_FOCUSABLE} and {@link #FLAG_ALT_FOCUSABLE_IM}
 * flags and returns true if the combination of the two corresponds
 * to a window that can use the input method.
 *
 * @param flags The current window manager flags.
 *
 * @return Returns {@code true} if a window with the given flags would be able to
 * use the input method, {@code false} if not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,The control structure changed from a switch statement to a return statement with logical operations. Such a change in the condition checking mechanism represents a change in both the control dependency (type 3) and the return statement (type 1).,"This change in the control structure and condition checking can lead to different return values since the logic is now compacted into a single return statement and the logic itself is slightly altered to use logical operations instead of case statements. This kind of change can lead to potential different behavior by the API (returning different values), hence the CI type is 1."
367,<android.widget.Toast: void setText(CharSequence)>,29,30,<android.widget.Toast: void setText(CharSequence)>,<android.widget.Toast: void setText(CharSequence)>,0,"{
    if (mNextView == null) {
        throw new RuntimeException(""This Toast was not created with Toast.makeText()"");
    }
    TextView tv = mNextView.findViewById(com.android.internal.R.id.message);
    if (tv == null) {
        throw new RuntimeException(""This Toast was not created with Toast.makeText()"");
    }
    tv.setText(s);
}","{
    if (Compatibility.isChangeEnabled(CHANGE_TEXT_TOASTS_IN_THE_SYSTEM)) {
        if (mNextView != null) {
            throw new IllegalStateException(""Text provided for custom toast, remove previous setView() calls if you "" + ""want a text toast instead."");
        }
        mText = s;
    } else {
        if (mNextView == null) {
            throw new RuntimeException(""This Toast was not created with Toast.makeText()"");
        }
        TextView tv = mNextView.findViewById(com.android.internal.R.id.message);
        if (tv == null) {
            throw new RuntimeException(""This Toast was not created with Toast.makeText()"");
        }
        tv.setText(s);
    }
}",1,"/**
 * Update the text in a Toast that was previously created using one of the makeText() methods.
 * @param s The new text for the Toast.
 */
","/**
 * Update the text in a Toast that was previously created using one of the makeText() methods.
 * @param s The new text for the Toast.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"There are changes in exception handling statements and control dependency (introduction of an if-else statement with Compatibility.isChangeEnabled()). Additionally, the late version introduces a field assignment (mText = s;) instead of calling setText on a TextView, so the change type is 2,3,4.","The addition of new conditions for throwing an IllegalStateException instead of a RuntimeException and the possibility of not calling setText on a TextView could lead to different exception handling (early version can never throw IllegalStateException), and thus the CI type is 2."
368,<android.content.pm.PackageInstaller.Session: void transfer(String)>,29,30,<android.content.pm.PackageInstaller.Session: void transfer(String)>,<android.content.pm.PackageInstaller.Session: void transfer(String)>,0,"{
    Preconditions.checkNotNull(packageName);
    try {
        mSession.transfer(packageName);
    } catch (ParcelableException e) {
        e.maybeRethrow(PackageManager.NameNotFoundException.class);
        throw new RuntimeException(e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(packageName);
    try {
        mSession.transfer(packageName);
    } catch (ParcelableException e) {
        e.maybeRethrow(PackageManager.NameNotFoundException.class);
        throw new RuntimeException(e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Transfer the session to a new owner.
 * <p>
 * Only sessions that update the installing app can be transferred.
 * <p>
 * After the transfer to a package with a different uid all method calls on the session
 * will cause {@link SecurityException}s.
 * <p>
 * Once this method is called, the session is sealed and no additional mutations beside
 * committing it may be performed on the session.
 *
 * @param packageName The package of the new owner. Needs to hold the INSTALL_PACKAGES
 * permission.
 *
 * @throws PackageManager.NameNotFoundException if the new owner could not be found.
 * @throws SecurityException if called after the session has been committed or abandoned.
 * @throws SecurityException if the session does not update the original installer
 * @throws SecurityException if streams opened through
 * {@link #openWrite(String, long, long) are still open.
 */
","/**
 * Transfer the session to a new owner.
 * <p>
 * Only sessions that update the installing app can be transferred.
 * <p>
 * After the transfer to a package with a different uid all method calls on the session
 * will cause {@link SecurityException}s.
 * <p>
 * Once this method is called, the session is sealed and no additional mutations beside
 * committing it may be performed on the session.
 *
 * @param packageName The package of the new owner. Needs to hold the INSTALL_PACKAGES
 * permission.
 *
 * @throws PackageManager.NameNotFoundException if the new owner could not be found.
 * @throws SecurityException if called after the session has been committed or abandoned.
 * @throws SecurityException if the session does not update the original installer
 * @throws SecurityException if streams opened through
 * {@link #openWrite(String, long, long) are still open.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is a replacement of Preconditions.checkNotNull(packageName) with Objects.requireNonNull(packageName). The change applies to the method used for null-checking the parameter, but the behavior remains the same, so the code change type is 4.","There is no Compatibility Issue as both Preconditions.checkNotNull() and Objects.requireNonNull() serve the same purpose of checking for null and throwing a NullPointerException if necessary, thus the behavior of the API remains the same. No other changes are observed in the exception handling or return values, hence no CI."
370,<android.view.WindowInsets: String toString()>,29,30,<android.view.WindowInsets: String toString()>,<android.view.WindowInsets: String toString()>,0,"{
    return ""WindowInsets{systemWindowInsets="" + getSystemWindowInsets() + "" stableInsets="" + getStableInsets() + "" sysGestureInsets="" + getSystemGestureInsets() + (mDisplayCutout != null ? "" cutout="" + mDisplayCutout : """") + (isRound() ? "" round"" : """") + ""}"";
}","{
    StringBuilder result = new StringBuilder(""WindowInsets{\n    "");
    for (int i = 0; i < SIZE; i++) {
        Insets insets = mTypeInsetsMap[i];
        Insets maxInsets = mTypeMaxInsetsMap[i];
        boolean visible = mTypeVisibilityMap[i];
        if (!Insets.NONE.equals(insets) || !Insets.NONE.equals(maxInsets) || visible) {
            result.append(Type.toString(1 << i)).append(""="").append(insets).append("" max="").append(maxInsets).append("" vis="").append(visible).append(""\n    "");
        }
    }
    result.append(mDisplayCutout != null ? ""cutout="" + mDisplayCutout : """");
    result.append(""\n    "");
    result.append(isRound() ? ""round"" : """");
    result.append(""}"");
    return result.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of toString() method is completely restructured, using StringBuilder and loops instead of direct concatenation. This affects the formatting of the returned string, therefore the changes are 1 and 4.","The returned string will differ due to the change in the string construction logic, introducing potential compatibility issues with any code that relies on the exact format of the string returned by toString(). So, the compatibility issue is of type 1 due to different return values."
371,<android.widget.Editor.HandleView: void updateMagnifier(MotionEvent)>,29,30,<android.widget.Editor.HandleView: void updateMagnifier(MotionEvent)>,<android.widget.Editor.HandleView: void updateMagnifier(MotionEvent)>,0,"{
    if (mMagnifierAnimator == null) {
        return;
    }
    final PointF showPosInView = new PointF();
    final boolean shouldShow = checkForTransforms() && /*check not rotated and compute scale*/
    !tooLargeTextForMagnifier() && obtainMagnifierShowCoordinates(event, showPosInView);
    if (shouldShow) {
        // Make the cursor visible and stop blinking.
        mRenderCursorRegardlessTiming = true;
        mTextView.invalidateCursorPath();
        suspendBlink();
        mMagnifierAnimator.show(showPosInView.x, showPosInView.y);
        updateHandlesVisibility();
    } else {
        dismissMagnifier();
    }
}","{
    if (getMagnifierAnimator() == null) {
        return;
    }
    final PointF showPosInView = new PointF();
    final boolean shouldShow = checkForTransforms() && /*check not rotated and compute scale*/
    !tooLargeTextForMagnifier() && obtainMagnifierShowCoordinates(event, showPosInView);
    if (shouldShow) {
        // Make the cursor visible and stop blinking.
        mRenderCursorRegardlessTiming = true;
        mTextView.invalidateCursorPath();
        suspendBlink();
        if (mNewMagnifierEnabled) {
            // Calculates the line bounds as the content source bounds to the magnifier.
            Layout layout = mTextView.getLayout();
            int line = layout.getLineForOffset(getCurrentCursorOffset());
            int lineLeft = (int) layout.getLineLeft(line);
            lineLeft += mTextView.getTotalPaddingLeft() - mTextView.getScrollX();
            int lineRight = (int) layout.getLineRight(line);
            lineRight += mTextView.getTotalPaddingLeft() - mTextView.getScrollX();
            mMagnifierAnimator.mMagnifier.setSourceHorizontalBounds(lineLeft, lineRight);
            final int lineHeight = layout.getLineBottomWithoutSpacing(line) - layout.getLineTop(line);
            float zoom = mInitialZoom;
            if (lineHeight < mMinLineHeightForMagnifier) {
                zoom = zoom * mMinLineHeightForMagnifier / lineHeight;
            }
            mMagnifierAnimator.mMagnifier.updateSourceFactors(lineHeight, zoom);
            mMagnifierAnimator.mMagnifier.show(showPosInView.x, showPosInView.y);
        } else {
            mMagnifierAnimator.show(showPosInView.x, showPosInView.y);
        }
        updateHandlesVisibility();
    } else {
        dismissMagnifier();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The if condition check has been changed from direct field access (mMagnifierAnimator) to a method call (getMagnifierAnimator()). Additionally, a new block of code has been introduced to check the value of 'mNewMagnifierEnabled', with corresponding changes to magnifier behavior, thus the change includes 3 (Control dependency change due to the new if condition) and 4 (Other statement changed due to additional logic handling magnifier properties and showing it differently if mNewMagnifierEnabled is true).","There is no Compatibility Issue since all the changes are conditional on a new flag ('mNewMagnifierEnabled') which does not change the control flow of the existing logic (the 'else' block still calls the same 'show' method of mMagnifierAnimator as before and the return conditions haven't changed). The behavior is extended but not altered for the existing functionality, and the existing API contract is not violated. The conditions under which the magnifier is shown or dismissed have stayed consistent, and the handling of the 'shouldShow' variable has not changed despite the deeper internal logic to handle it differently based on the new flag. Thus, for clients not using the new 'mNewMagnifierEnabled' feature, the experience remains unchanged."
372,"<android.app.admin.DevicePolicyManager: void wipeData(int,CharSequence)>",29,30,"<android.app.admin.DevicePolicyManager: void wipeData(int,CharSequence)>","<android.app.admin.DevicePolicyManager: void wipeData(int,CharSequence)>",0,"{
    throwIfParentInstance(""wipeData"");
    Preconditions.checkNotNull(reason, ""reason string is null"");
    Preconditions.checkStringNotEmpty(reason, ""reason string is empty"");
    Preconditions.checkArgument((flags & WIPE_SILENTLY) == 0, ""WIPE_SILENTLY cannot be set"");
    wipeDataInternal(flags, reason.toString());
}","{
    Objects.requireNonNull(reason, ""reason string is null"");
    Preconditions.checkStringNotEmpty(reason, ""reason string is empty"");
    Preconditions.checkArgument((flags & WIPE_SILENTLY) == 0, ""WIPE_SILENTLY cannot be set"");
    wipeDataInternal(flags, reason.toString());
}",1,"/**
 * Ask that all user data be wiped. If called as a secondary user, the user will be removed and
 * other users will remain unaffected, the provided reason for wiping data can be shown to
 * user. Calling from the primary user will cause the device to reboot, erasing all device data
 * - including all the secondary users and their data - while booting up. In this case, we don't
 * show the reason to the user since the device would be factory reset.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 * be able to call this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently supported flags are
 * {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA} and
 * {@link #WIPE_EUICC}.
 * @param reason a string that contains the reason for wiping data, which can be
 * presented to the user.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
 * @throws IllegalArgumentException if the input reason string is null or empty, or if
 * {@link #WIPE_SILENTLY} is set.
 */
","/**
 * Ask that all user data be wiped. If called as a secondary user, the user will be removed and
 * other users will remain unaffected, the provided reason for wiping data can be shown to
 * user. Calling from the primary user will cause the device to reboot, erasing all device data
 * - including all the secondary users and their data - while booting up. In this case, we don't
 * show the reason to the user since the device would be factory reset.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 * be able to call this method; if it has not, a security exception will be thrown.
 *
 * If the caller is a profile owner of an organization-owned managed profile, it may
 * additionally call this method on the parent instance.
 * Calling this method on the parent {@link DevicePolicyManager} instance would wipe the
 * entire device, while calling it on the current profile instance would relinquish the device
 * for personal use, removing the managed profile and all policies set by the profile owner.
 *
 * @param flags Bit mask of additional options: currently supported flags are
 * {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA} and
 * {@link #WIPE_EUICC}.
 * @param reason a string that contains the reason for wiping data, which can be
 * presented to the user.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
 * @throws IllegalArgumentException if the input reason string is null or empty, or if
 * {@link #WIPE_SILENTLY} is set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method Preconditions.checkNotNull has been replaced by Objects.requireNonNull, and the call to throwIfParentInstance has been removed. These are changes to Other statements type and also a Dependent API changed type because Objects.requireNonNull may have a different implementation from Preconditions.checkNotNull.",There is no Compatibility Issue as the logic of both checks is the same and the change does not affect the return value or the exception handling of the API. The replaced check does the same thing but may just be part of a library update or refactor. The removal of throwIfParentInstance does not introduce a CI as it seems to be an assertion and its absence doesn't affect the behavior observed by the API consumers as long as they are not calling this method from a parent instance (which should be part of the method's contract).
373,"<android.app.Activity: void performStop(boolean,String)>",29,30,"<android.app.Activity: void performStop(boolean,String)>","<android.app.Activity: void performStop(boolean,String)>",0,"{
    mDoReportFullyDrawn = false;
    mFragments.doLoaderStop(mChangingConfigurations);
    // Disallow entering picture-in-picture after the activity has been stopped
    mCanEnterPictureInPicture = false;
    if (!mStopped) {
        dispatchActivityPreStopped();
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        // destroys hardware resources and causes flicker.
        if (!preserveWindow && mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        writeEventLog(LOG_AM_ON_STOP_CALLED, reason);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
        dispatchActivityPostStopped();
    }
    mResumed = false;
}","{
    mDoReportFullyDrawn = false;
    mFragments.doLoaderStop(mChangingConfigurations);
    // Disallow entering picture-in-picture after the activity has been stopped
    mCanEnterPictureInPicture = false;
    if (!mStopped) {
        dispatchActivityPreStopped();
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        // destroys hardware resources and causes flicker.
        if (!preserveWindow && mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        EventLogTags.writeWmOnStopCalled(mIdent, getComponentName().getClassName(), reason);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
        dispatchActivityPostStopped();
    }
    mResumed = false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is the logging method call, from writeEventLog(LOG_AM_ON_STOP_CALLED, reason) to EventLogTags.writeWmOnStopCalled(mIdent, getComponentName().getClassName(), reason). Hence, the code change type is 4.","The change is solely related to how the event is logged and does not impact the method's control flow, return value, or exception handling behavior. Therefore, there is no Compatibility Issue."
374,<android.content.IntentFilter: boolean hasDataPath(String)>,29,30,<android.content.IntentFilter: boolean hasDataPath(String)>,<android.content.IntentFilter: boolean hasDataPath(String)>,0,"{
    if (mDataPaths == null) {
        return false;
    }
    final int numDataPaths = mDataPaths.size();
    for (int i = 0; i < numDataPaths; i++) {
        final PatternMatcher pe = mDataPaths.get(i);
        if (pe.match(data)) {
            return true;
        }
    }
    return false;
}","{
    return hasDataPath(data, false);
}",1,"/**
 * Is the given data path included in the filter?  Note that if the
 * filter does not include any paths, false will <em>always</em> be
 * returned.
 *
 * @param data The data path to look for.  This is without the scheme
 * prefix.
 *
 * @return True if the data string matches a path listed in the
 * filter.
 */
","/**
 * Is the given data path included in the filter?  Note that if the
 * filter does not include any paths, false will <em>always</em> be
 * returned.
 *
 * @param data The data path to look for.  This is without the scheme
 * prefix.
 *
 * @return True if the data string matches a path listed in the
 * filter.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has changed completely from a concrete implementation to delegating its logic to another method 'hasDataPath(data, false)'. Thus, the change types are 1,5 due to the change in the return statement and dependent API.","This change has forced a dependency on the behavior of a different method and may potentially change the return value if the new 'hasDataPath' method encapsulates a different logic. Therefore, the CI type is 1."
375,<android.app.ContextImpl: Context createDisplayContext(Display)>,29,30,<android.app.ContextImpl: Context createDisplayContext(Display)>,<android.app.ContextImpl: Context createDisplayContext(Display)>,0,"{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, mFlags, mClassLoader, null);
    final int displayId = display.getDisplayId();
    context.setResources(createResources(mActivityToken, mPackageInfo, mSplitName, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
    context.mDisplay = display;
    return context;
}","{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, mSplitName, mToken, mUser, mFlags, mClassLoader, null);
    final int displayId = display.getDisplayId();
    context.setResources(createResources(mToken, mPackageInfo, mSplitName, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo(), mResources.getLoaders()));
    context.mDisplay = display;
    context.mIsAssociatedWithDisplay = true;
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The variable used to construct `ContextImpl` has changed from `mActivityToken` to `mToken` and a new field `context.mIsAssociatedWithDisplay` is set to `true`, so the change type is 4. Additionally, the parameters used for `createResources` have changed, as a new parameter `mResources.getLoaders()` has been added. These changes show that the internal implementation details and dependencies have been modified, indicating a type 5 change.","Changes in the constructor arguments passed to `ContextImpl()` and to `createResources()`, as well as the setting of a new field `mIsAssociatedWithDisplay`, could lead to a different `ContextImpl` instantiation with potentially different resource configurations or display association. Therefore, this may result in the method returning a differently configured `Context` object, indicating a CI of type 1."
376,"<android.app.AppOpsManager: int noteProxyOp(String,String)>",29,30,"<android.app.AppOpsManager: int noteProxyOp(String,String)>","<android.app.AppOpsManager: int noteProxyOp(String,String)>",0,"{
    return noteProxyOp(strOpToOp(op), proxiedPackageName);
}","{
    return noteProxyOp(op, proxiedPackageName, Binder.getCallingUid(), null, null);
}",1,"/**
 * Make note of an application performing an operation on behalf of another
 * application when handling an IPC. Note that you must pass the package name
 * of the application that is being proxied while its UID will be inferred from
 * the IPC state; this function will verify that the calling uid and proxied
 * package name match, and if not, return {@link #MODE_IGNORED}. If this call
 * succeeds, the last execution time of the operation for the proxied app and
 * your app will be updated to the current time.
 * @param op The operation to note.  One of the OPSTR_* constants.
 * @param proxiedPackageName The name of the application calling into the proxy application.
 * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or
 * {@link #MODE_IGNORED} if it is not allowed and should be silently ignored (without
 * causing the app to crash).
 * @throws SecurityException If the app has been configured to crash on this op.
 */
","/**
 * @deprecated Use {@link #noteProxyOp(String, String, int, String, String)} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",1,"The method used within return statement has been changed from noteProxyOp(strOpToOp(op), proxiedPackageName) to noteProxyOp(op, proxiedPackageName, Binder.getCallingUid(), null, null), and additional parameters have been passed in the call. The 'noteProxyOp' method signatures differ in both the number and the type of parameters. Therefore, the change type is 4,5 (Other statement changed, Dependent API changed).","The late version API introduces additional parameters, which could affect the outcome of the 'noteProxyOp' method. Therefore, the API potentially returns a different value, and the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
377,"<android.view.textclassifier.SelectionEvent: SelectionEvent createSelectionActionEvent(int,int,int,TextClassification)>",29,30,"<android.view.textclassifier.SelectionEvent: SelectionEvent createSelectionActionEvent(int,int,int,TextClassification)>","<android.view.textclassifier.SelectionEvent: SelectionEvent createSelectionActionEvent(int,int,int,TextClassification)>",0,"{
    Preconditions.checkArgument(end >= start, ""end cannot be less than start"");
    Preconditions.checkNotNull(classification);
    checkActionType(actionType);
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    return new SelectionEvent(start, end, actionType, entityType, INVOCATION_UNKNOWN, classification.getId());
}","{
    Preconditions.checkArgument(end >= start, ""end cannot be less than start"");
    Objects.requireNonNull(classification);
    checkActionType(actionType);
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    return new SelectionEvent(start, end, actionType, entityType, INVOCATION_UNKNOWN, classification.getId());
}",1,"/**
 * Creates an event specifying an action taken on a selection.
 * Use when the user clicks on an action to act on the selected text and the selection's
 * entity type is known.
 *
 * @param start  the start (inclusive) index of the selection
 * @param end  the end (exclusive) index of the selection
 * @param actionType  the action that was performed on the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 *
 * @throws IllegalArgumentException if end is less than start
 * @throws IllegalArgumentException If actionType is not a valid SelectionEvent actionType
 */
","/**
 * Creates an event specifying an action taken on a selection.
 * Use when the user clicks on an action to act on the selected text and the selection's
 * entity type is known.
 *
 * @param start  the start (inclusive) index of the selection
 * @param end  the end (exclusive) index of the selection
 * @param actionType  the action that was performed on the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 *
 * @throws IllegalArgumentException if end is less than start
 * @throws IllegalArgumentException If actionType is not a valid SelectionEvent actionType
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is in the precondition check from Preconditions.checkNotNull(classification) to Objects.requireNonNull(classification), which is an equivalent check but different implementation, so the change type is 4.","Because the Objects.requireNonNull function serves the same purpose as the Preconditions.checkNotNull method (throwing a NullPointerException when the passed object is null), there is no compatibility issue introduced by this change; the behavior of the API remains the same concerning nullability checks. Hence, there is no CI."
379,"<android.service.notification.NotificationAssistantService.NotificationAssistantServiceWrapper: void onNotificationSnoozedUntilContext(IStatusBarNotificationHolder,String)>",29,30,"<android.service.notification.NotificationAssistantService.NotificationAssistantServiceWrapper: void onNotificationSnoozedUntilContext(IStatusBarNotificationHolder,String)>","<android.service.notification.NotificationAssistantService.NotificationAssistantServiceWrapper: void onNotificationSnoozedUntilContext(IStatusBarNotificationHolder,String)>",0,"{
    StatusBarNotification sbn;
    try {
        sbn = sbnHolder.get();
    } catch (RemoteException e) {
        Log.w(TAG, ""onNotificationSnoozed: Error receiving StatusBarNotification"", e);
        return;
    }
    SomeArgs args = SomeArgs.obtain();
    args.arg1 = sbn;
    args.arg2 = snoozeCriterionId;
    mHandler.obtainMessage(MyHandler.MSG_ON_NOTIFICATION_SNOOZED, args).sendToTarget();
}","{
    StatusBarNotification sbn;
    try {
        sbn = sbnHolder.get();
    } catch (RemoteException e) {
        Log.w(TAG, ""onNotificationSnoozed: Error receiving StatusBarNotification"", e);
        return;
    }
    if (sbn == null) {
        Log.w(TAG, ""onNotificationSnoozed: Error receiving StatusBarNotification"");
        return;
    }
    SomeArgs args = SomeArgs.obtain();
    args.arg1 = sbn;
    args.arg2 = snoozeCriterionId;
    mHandler.obtainMessage(MyHandler.MSG_ON_NOTIFICATION_SNOOZED, args).sendToTarget();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"A new check for `sbn == null` and an associated return statement has been introduced in the late version of the implementation, which is a control dependency change, therefore, the change type is 3.","Because of the introduced `if` statement checking if `sbn` is `null`, and if true, returns early, this new check could potentially lead the method to return earlier than it would in the early version, resulting in a change in behavior when `sbn` is `null`. As a result, this may cause the method to return before sending the message to the handler which it would not have done previously, signaling a possible different return type or value. Therefore, the CI type is 1."
380,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,29,30,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,0,"{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return false;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        if (!mCanEnterPictureInPicture) {
            throw new IllegalStateException(""Activity must be resumed to enter"" + "" picture-in-picture"");
        }
        return ActivityTaskManager.getService().enterPictureInPictureMode(mToken, params);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return false;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        if (!mCanEnterPictureInPicture) {
            throw new IllegalStateException(""Activity must be resumed to enter"" + "" picture-in-picture"");
        }
        // Set mIsInPictureInPictureMode earlier and don't wait for
        // onPictureInPictureModeChanged callback here. This is to ensure that
        // isInPictureInPictureMode returns true in the following onPause callback.
        // See https://developer.android.com/guide/topics/ui/picture-in-picture for guidance.
        mIsInPictureInPictureMode = ActivityTaskManager.getService().enterPictureInPictureMode(mToken, params);
        return mIsInPictureInPictureMode;
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system successfully put this activity into picture-in-picture mode or was
 * already in picture-in-picture mode (see {@link #isInPictureInPictureMode()}). If the device
 * does not support picture-in-picture, return false.
 */
","/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * <p>By default, system calculates the dimension of picture-in-picture window based on the
 * given {@param params}.
 * See <a href=""{@docRoot}guide/topics/ui/picture-in-picture"">Picture-in-picture Support</a>
 * on how to override this behavior.</p>
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system successfully put this activity into picture-in-picture mode or was
 * already in picture-in-picture mode (see {@link #isInPictureInPictureMode()}). If the device
 * does not support picture-in-picture, return false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There was an addition of a new local variable assignment (`mIsInPictureInPictureMode = ...`) before the return statement in the late version, so the type of code change is 4.","Although there is a change, it does not affect the return value or the exceptions thrown by the API because the result of the called method `ActivityTaskManager.getService().enterPictureInPictureMode(mToken, params)` is still being returned and no additional control structures or exceptions have been introduced. Therefore, there is no Compatibility Issue; CI type is 0."
381,<android.service.notification.ZenPolicy: boolean equals(Object)>,29,30,<android.service.notification.ZenPolicy: boolean equals(Object)>,<android.service.notification.ZenPolicy: boolean equals(Object)>,0,"{
    if (!(o instanceof ZenPolicy))
        return false;
    if (o == this)
        return true;
    final ZenPolicy other = (ZenPolicy) o;
    return Objects.equals(other.mPriorityCategories, mPriorityCategories) && Objects.equals(other.mVisualEffects, mVisualEffects) && other.mPriorityCalls == mPriorityCalls && other.mPriorityMessages == mPriorityMessages;
}","{
    if (!(o instanceof ZenPolicy))
        return false;
    if (o == this)
        return true;
    final ZenPolicy other = (ZenPolicy) o;
    return Objects.equals(other.mPriorityCategories, mPriorityCategories) && Objects.equals(other.mVisualEffects, mVisualEffects) && other.mPriorityCalls == mPriorityCalls && other.mPriorityMessages == mPriorityMessages && other.mConversationSenders == mConversationSenders;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been expanded with an additional condition (&& other.mConversationSenders == mConversationSenders), so the code change types are 1 and 4.","The amended return statement includes an additional check which can potentially alter the result of the method, causing it to return a different boolean value when the new field mConversationSenders is compared. Therefore, the CI type is 1."
383,"<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(int,String)>",29,30,"<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(int,String)>","<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(int,String)>",0,"{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_STRING) {
            return impl.loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    } finally {
        releaseTempTypedValue(value);
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_STRING) {
            return loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Loads an XML parser for the specified file.
 *
 * @param id the resource identifier for the file
 * @param type the type of resource (used for logging)
 * @return a parser for the specified XML file
 * @throws NotFoundException if the file could not be loaded
 */
","/**
 * Loads an XML parser for the specified file.
 *
 * @param id the resource identifier for the file
 * @param type the type of resource (used for logging)
 * @return a parser for the specified XML file
 * @throws NotFoundException if the file could not be loaded
 */
",-1,"[@NonNull, @UnsupportedAppUsage]","[@NonNull, @UnsupportedAppUsage]",-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed the way the loadXmlResourceParser method is called: from impl.loadXmlResourceParser to loadXmlResourceParser without the 'impl' prefix. This indicates a change in the way the dependent method is accessed, suggesting a potential change in internal implementation, so the code change is of type 5.","There is no Compatibility Issue since the method signature and the behavior of loadXmlResourceParser seem to stay consistent. The change just seems to reflect a change in the internal implementation detail or scope of the call, which should not affect the callers of this API."
384,"<android.view.textclassifier.TextClassification.Builder: Builder setEntityType(String,float)>",29,30,"<android.view.textclassifier.TextClassification.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextClassification.Builder: Builder setEntityType(String,float)>",0,"{
    setEntityType(type, confidenceScore, null);
    return this;
}","{
    mTypeScoreMap.put(type, confidenceScore);
    return this;
}",1,"/**
 * Sets an entity type for the classification result and assigns a confidence score.
 * If a confidence score had already been set for the specified entity type, this will
 * override that score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classification result and assigns a confidence score.
 * If a confidence score had already been set for the specified entity type, this will
 * override that score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method body changed from 'setEntityType(type, confidenceScore, null);' to 'mTypeScoreMap.put(type, confidenceScore);', which indicates a change in the implementation but not a change in the return value or exception handling. Therefore, the code changes belong to types 4 and 5, as the method implementation no longer calls another method (setEntityType) but directly puts the type and confidenceScore into the map.","There is no Compatibility Issue since the return value 'this' remains the same, and no new exceptions are thrown. The change is only in the implementation detail, which doesn't affect the client's code assuming the change still meets the contract of the method set by its signature and previous behavior."
386,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,29,30,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    final boolean result = super.onTouchEvent(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDownPositionX = ev.getRawX();
            mDownPositionY = ev.getRawY();
            updateMagnifier(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            updateMagnifier(ev);
            break;
        case MotionEvent.ACTION_UP:
            if (!offsetHasBeenChanged()) {
                final float deltaX = mDownPositionX - ev.getRawX();
                final float deltaY = mDownPositionY - ev.getRawY();
                final float distanceSquared = deltaX * deltaX + deltaY * deltaY;
                final ViewConfiguration viewConfiguration = ViewConfiguration.get(mTextView.getContext());
                final int touchSlop = viewConfiguration.getScaledTouchSlop();
                if (distanceSquared < touchSlop * touchSlop) {
                    // Tapping on the handle toggles the insertion action mode.
                    if (mTextActionMode != null) {
                        stopTextActionMode();
                    } else {
                        startInsertionActionMode();
                    }
                }
            } else {
                if (mTextActionMode != null) {
                    mTextActionMode.invalidateContentRect();
                }
            }
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            hideAfterDelay();
            dismissMagnifier();
            break;
        default:
            break;
    }
    return result;
}","{
    if (!mTextView.isFromPrimePointer(ev, true)) {
        return true;
    }
    if (mFlagInsertionHandleGesturesEnabled && mFlagCursorDragFromAnywhereEnabled) {
        // Otherwise the insertion handle view cannot be moved.
        return touchThrough(ev);
    }
    final boolean result = super.onTouchEvent(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mLastDownRawX = ev.getRawX();
            mLastDownRawY = ev.getRawY();
            updateMagnifier(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            updateMagnifier(ev);
            break;
        case MotionEvent.ACTION_UP:
            if (!offsetHasBeenChanged()) {
                ViewConfiguration config = ViewConfiguration.get(mTextView.getContext());
                boolean isWithinTouchSlop = EditorTouchState.isDistanceWithin(mLastDownRawX, mLastDownRawY, ev.getRawX(), ev.getRawY(), config.getScaledTouchSlop());
                if (isWithinTouchSlop) {
                    // Tapping on the handle toggles the insertion action mode.
                    toggleInsertionActionMode();
                }
            } else {
                if (mTextActionMode != null) {
                    mTextActionMode.invalidateContentRect();
                }
            }
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            hideAfterDelay();
            dismissMagnifier();
            break;
        default:
            break;
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2",The changes include:,- Replacement of the calculation of `distanceSquared` with a call to `EditorTouchState.isDistanceWithin`.
387,<android.os.ServiceManagerProxy: IBinder getService(String)>,29,30,<android.os.ServiceManagerProxy: IBinder getService(String)>,<android.os.ServiceManagerProxy: IBinder getService(String)>,0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IServiceManager.descriptor);
    data.writeString(name);
    mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);
    IBinder binder = reply.readStrongBinder();
    reply.recycle();
    data.recycle();
    return binder;
}","{
    // Same as checkService (old versions of servicemanager had both methods).
    return mServiceManager.checkService(name);
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement is changed because the implementation of late version is using a call to mServiceManager.checkService(name) instead of performing a series of operations with Parcel and mRemote.transact. Additionally, this is a dependent API change as it now relies on the mServiceManager.checkService method which is different from the original code, so the change type is 1,5.","Since the method now depends on the checkService method of mServiceManager, the behavior might be different not only because of the possible difference in the implementation of checkService compared to the original code, but also because any changes in the checkService method's behavior in future updates will affect getService method, causing it to potentially return a different value. Therefore, the CI type is 1."
389,<android.app.ContextImpl: void sendBroadcast(Intent)>,29,30,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method called within the try block has changed from broadcastIntent to broadcastIntentWithFeature which means a dependent API has changed, hence the code change type is 5.","Despite the change in the dependent API method, this would not lead to a Compatibility Issue under our interpretation because the change does not affect the behavior of this method towards its callers; it does not introduce a new exception, nor does it alter the return type (which is void in this case). The external method signature and the way the current method calls this external method has changed, but that does not necessarily mean different behavior from the perspective of the client code calling sendBroadcast. Therefore, no Compatibility Issue exists."
390,"<android.view.SurfaceControl.Transaction: Transaction setAlpha(SurfaceControl,float)>",29,30,"<android.view.SurfaceControl.Transaction: Transaction setAlpha(SurfaceControl,float)>","<android.view.SurfaceControl.Transaction: Transaction setAlpha(SurfaceControl,float)>",0,"{
    sc.checkNotReleased();
    nativeSetAlpha(mNativeObject, sc.mNativeObject, alpha);
    return this;
}","{
    checkPreconditions(sc);
    nativeSetAlpha(mNativeObject, sc.mNativeObject, alpha);
    return this;
}",1,"/**
 * Set the alpha for a given surface. If the alpha is non-zero the SurfaceControl
 * will be blended with the Surfaces under it according to the specified ratio.
 *
 * @param sc The given SurfaceControl.
 * @param alpha The alpha to set.
 */
","/**
 * Set the alpha for a given surface. If the alpha is non-zero the SurfaceControl
 * will be blended with the Surfaces under it according to the specified ratio.
 *
 * @param sc The given SurfaceControl.
 * @param alpha The alpha to set.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The called method within the implementation changed from sc.checkNotReleased() to checkPreconditions(sc), which indicates a change in a method call within the body; hence the code change type is 4,5 (Other statement changed, Dependent API changed).","Although one method call is replaced with another, this change does not affect the return value of the method or exception handling. The method's contract appears to remain the same; it still requires a non-null SurfaceControl object (as indicated by the unchanged @NonNull annotation) and returns 'this', which is the current Transaction object. Therefore, it is unlikely that this change will cause a compatibility issue, so the CI type is 0."
392,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Class<T>)>,29,30,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Class<T>)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Class<T>)>,0,"{
    checkNotNull(klass, ""klass must not be null"");
    if (klass == android.media.ImageReader.class) {
        return true;
    } else if (klass == android.media.MediaRecorder.class) {
        return true;
    } else if (klass == android.media.MediaCodec.class) {
        return true;
    } else if (klass == android.renderscript.Allocation.class) {
        return true;
    } else if (klass == android.view.SurfaceHolder.class) {
        return true;
    } else if (klass == android.graphics.SurfaceTexture.class) {
        return true;
    }
    return false;
}","{
    Objects.requireNonNull(klass, ""klass must not be null"");
    if (klass == android.media.ImageReader.class) {
        return true;
    } else if (klass == android.media.MediaRecorder.class) {
        return true;
    } else if (klass == android.media.MediaCodec.class) {
        return true;
    } else if (klass == android.renderscript.Allocation.class) {
        return true;
    } else if (klass == android.view.SurfaceHolder.class) {
        return true;
    } else if (klass == android.graphics.SurfaceTexture.class) {
        return true;
    }
    return false;
}",1,"/**
 * Determine whether or not output streams can be configured with a particular class
 * as a consumer.
 *
 * <p>The following list is generally usable for outputs:
 * <ul>
 * <li>{@link android.media.ImageReader} -
 * Recommended for image processing or streaming to external resources (such as a file or
 * network)
 * <li>{@link android.media.MediaRecorder} -
 * Recommended for recording video (simple to use)
 * <li>{@link android.media.MediaCodec} -
 * Recommended for recording video (more complicated to use, with more flexibility)
 * <li>{@link android.renderscript.Allocation} -
 * Recommended for image processing with {@link android.renderscript RenderScript}
 * <li>{@link android.view.SurfaceHolder} -
 * Recommended for low-power camera preview with {@link android.view.SurfaceView}
 * <li>{@link android.graphics.SurfaceTexture} -
 * Recommended for OpenGL-accelerated preview processing or compositing with
 * {@link android.view.TextureView}
 * </ul>
 * </p>
 *
 * <p>Generally speaking this means that creating a {@link Surface} from that class <i>may</i>
 * provide a producer endpoint that is suitable to be used with
 * {@link CameraDevice#createCaptureSession}.</p>
 *
 * <p>Since not all of the above classes support output of all format and size combinations,
 * the particular combination should be queried with {@link #isOutputSupportedFor(Surface)}.</p>
 *
 * @param klass a non-{@code null} {@link Class} object reference
 * @return {@code true} if this class is supported as an output, {@code false} otherwise
 *
 * @throws NullPointerException if {@code klass} was {@code null}
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Surface)
 */
","/**
 * Determine whether or not output streams can be configured with a particular class
 * as a consumer.
 *
 * <p>The following list is generally usable for outputs:
 * <ul>
 * <li>{@link android.media.ImageReader} -
 * Recommended for image processing or streaming to external resources (such as a file or
 * network)
 * <li>{@link android.media.MediaRecorder} -
 * Recommended for recording video (simple to use)
 * <li>{@link android.media.MediaCodec} -
 * Recommended for recording video (more complicated to use, with more flexibility)
 * <li>{@link android.renderscript.Allocation} -
 * Recommended for image processing with {@link android.renderscript RenderScript}
 * <li>{@link android.view.SurfaceHolder} -
 * Recommended for low-power camera preview with {@link android.view.SurfaceView}
 * <li>{@link android.graphics.SurfaceTexture} -
 * Recommended for OpenGL-accelerated preview processing or compositing with
 * {@link android.view.TextureView}
 * </ul>
 * </p>
 *
 * <p>Generally speaking this means that creating a {@link Surface} from that class <i>may</i>
 * provide a producer endpoint that is suitable to be used with
 * {@link CameraDevice#createCaptureSession}.</p>
 *
 * <p>Since not all of the above classes support output of all format and size combinations,
 * the particular combination should be queried with {@link #isOutputSupportedFor(Surface)}.</p>
 *
 * @param klass a non-{@code null} {@link Class} object reference
 * @return {@code true} if this class is supported as an output, {@code false} otherwise
 *
 * @throws NullPointerException if {@code klass} was {@code null}
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Surface)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is from ""checkNotNull"" to ""Objects.requireNonNull"" for the null check of the klass parameter. While the null check is done differently, both accomplish the same task and will throw a NullPointerException if klass is null. There is also no change in the signature of `Objects.requireNonNull`, so the change type is 4,5.","There is no compatibility issue as both versions of the implementation effectively do the same null check and will result in the same behavior, hence the CI type is 0."
393,"<android.content.pm.CrossProfileApps: void startMainActivity(ComponentName,UserHandle)>",29,30,"<android.content.pm.CrossProfileApps: void startMainActivity(ComponentName,UserHandle)>","<android.content.pm.CrossProfileApps: void startMainActivity(ComponentName,UserHandle)>",0,"{
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), component, targetUser.getIdentifier(), true);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}","{
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), mContext.getAttributionTag(), component, targetUser.getIdentifier(), true);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts the specified main activity of the caller package in the specified profile.
 *
 * @param component The ComponentName of the activity to launch, it must be exported and has
 * action {@link android.content.Intent#ACTION_MAIN}, category
 * {@link android.content.Intent#CATEGORY_LAUNCHER}. Otherwise, SecurityException will
 * be thrown.
 * @param targetUser The UserHandle of the profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 */
","/**
 * Starts the specified main activity of the caller package in the specified profile.
 *
 * @param component The ComponentName of the activity to launch, it must be exported and has
 * action {@link android.content.Intent#ACTION_MAIN}, category
 * {@link android.content.Intent#CATEGORY_LAUNCHER}. Otherwise, SecurityException will
 * be thrown.
 * @param targetUser The UserHandle of the profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change includes the addition of a new parameter `mContext.getAttributionTag()` in the `mService.startActivityAsUser()` method call. Therefore, the code change type is 5, as the dependent API has been changed as there is a modification to the number of parameters.",There is no CI because the additional parameter will not cause the API to behave differently in a way that leads to different return types or values (since the method is void and does not return any value) nor will it lead to different exception handlings; the same RemoteException is caught and rethrown in both versions.
394,<android.util.Half: int halfToIntBits(short)>,29,30,<android.util.Half: int halfToIntBits(short)>,<android.util.Half: int halfToIntBits(short)>,0,"{
    return (h & FP16_COMBINED) > FP16_EXPONENT_MAX ? NaN : h & 0xffff;
}","{
    return (h & FP16.EXPONENT_SIGNIFICAND_MASK) > FP16.POSITIVE_INFINITY ? NaN : h & 0xffff;
}",1,"/**
 * <p>Returns a representation of the specified half-precision float value
 * according to the bit layout described in {@link Half}.</p>
 *
 * <p>Unlike {@link #halfToRawIntBits(short)}, this method collapses all
 * possible Not-a-Number values to a single canonical Not-a-Number value
 * defined by {@link #NaN}.</p>
 *
 * @param h A half-precision float value
 * @return The bits that represent the half-precision float value
 *
 * @see #halfToRawIntBits(short)
 * @see #halfToShortBits(short)
 * @see #intBitsToHalf(int)
 */
","/**
 * <p>Returns a representation of the specified half-precision float value
 * according to the bit layout described in {@link Half}.</p>
 *
 * <p>Unlike {@link #halfToRawIntBits(short)}, this method collapses all
 * possible Not-a-Number values to a single canonical Not-a-Number value
 * defined by {@link #NaN}.</p>
 *
 * @param h A half-precision float value
 * @return The bits that represent the half-precision float value
 *
 * @see #halfToRawIntBits(short)
 * @see #halfToShortBits(short)
 * @see #intBitsToHalf(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The operands within the condition have changed from comparing to FP16_COMBINED and FP16_EXPONENT_MAX to FP16.EXPONENT_SIGNIFICAND_MASK and FP16.POSITIVE_INFINITY, which are constants from a different (most likely the same, refactored) part of the library. This is classified as an ""other statement changed"" because the operands have been modified, indicating a possible different condition is being checked. Furthermore, this change reflects a ""dependent API changed"" because it relies on different constants from another API part.","While the operands have changed, the method's contract appears to still be the same: it converts half-precision float represented by a short into integer bits. The constants likely represent the same concept in the half-precision floating-point format, just under different names or refactoring. Thus, the fundamental operation hasn't changed in a way that would lead to a different return value, assuming that the constants FP16_EXPONENT_MAX and FP16.POSITIVE_INFINITY equate to the same value and FP16_COMBINED and FP16.EXPONENT_SIGNIFICAND_MASK represent the same masks. Since the criteria for returning NaN remain structurally similar, no compatibility issue on return values is expected based on the given code snippets and constant naming conventions. If the constant changes represent new behaviors not discernible from this comparison alone, a deeper inspection outside the scope of the given information is required to discover CI."
395,<android.app.Activity: void onBackPressed()>,29,30,<android.app.Activity: void onBackPressed()>,<android.app.Activity: void onBackPressed()>,0,"{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    FragmentManager fragmentManager = mFragments.getFragmentManager();
    if (!fragmentManager.isStateSaved() && fragmentManager.popBackStackImmediate()) {
        return;
    }
    if (!isTaskRoot()) {
        // If the activity is not the root of the task, allow finish to proceed normally.
        finishAfterTransition();
        return;
    }
    try {
        // Inform activity task manager that the activity received a back press
        // while at the root of the task. This call allows ActivityTaskManager
        // to intercept or defer finishing.
        ActivityTaskManager.getService().onBackPressedOnTaskRoot(mToken, new IRequestFinishCallback.Stub() {

            public void requestFinish() {
                mHandler.post(() -> finishAfterTransition());
            }
        });
    } catch (RemoteException e) {
        finishAfterTransition();
    }
}","{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    FragmentManager fragmentManager = mFragments.getFragmentManager();
    if (!fragmentManager.isStateSaved() && fragmentManager.popBackStackImmediate()) {
        return;
    }
    if (!isTaskRoot()) {
        // If the activity is not the root of the task, allow finish to proceed normally.
        finishAfterTransition();
        return;
    }
    try {
        // Inform activity task manager that the activity received a back press
        // while at the root of the task. This call allows ActivityTaskManager
        // to intercept or defer finishing.
        ActivityTaskManager.getService().onBackPressedOnTaskRoot(mToken, new RequestFinishCallback(new WeakReference<>(this)));
    } catch (RemoteException e) {
        finishAfterTransition();
    }
}",1,"/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
","/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the API has changed but the behavior is not affected in a way that would cause backward compatibility issues. The code change includes the replacement of an anonymous class IRequestFinishCallback.Stub with a new RequestFinishCallback class instance and passing a WeakReference to the Activity. This is an example of refactoring to avoid leaking the Activity context. Since it is an internal change and does not affect the API contract or external behavior, the change type is 4,5.","There is no Compatibility Issue since the change does not cause the API to return different values or types, nor does it change the exceptions the API may throw. The underlying behavior related to processing the back press on the Task Root remains consistent between versions despite the refactoring of the callback implementation."
397,"<android.net.DnsResolver.InetAddressAnswerAccumulator: void onAnswer(byte[],int)>",29,30,"<android.net.DnsResolver.InetAddressAnswerAccumulator: void onAnswer(byte[],int)>","<android.net.DnsResolver.InetAddressAnswerAccumulator: void onAnswer(byte[],int)>",0,"{
    // Otherwise, arbitrarily return the first rcode received.
    if (mReceivedAnswerCount == 0 || rcode == 0) {
        mRcode = rcode;
    }
    try {
        mAllAnswers.addAll(new DnsAddressAnswer(answer).getAddresses());
    } catch (ParseException e) {
        mDnsException = new DnsException(ERROR_PARSE, e);
    }
    maybeReportAnswer();
}","{
    // Otherwise, arbitrarily return the first rcode received.
    if (mReceivedAnswerCount == 0 || rcode == 0) {
        mRcode = rcode;
    }
    try {
        mAllAnswers.addAll(new DnsAddressAnswer(answer).getAddresses());
    } catch (DnsPacket.ParseException e) {
        // Convert the com.android.net.module.util.DnsPacket.ParseException to an
        // android.net.ParseException. This is the type that was used in Q and is implied
        // by the public documentation of ERROR_PARSE.
        // 
        // DnsPacket cannot throw android.net.ParseException directly because it's @hide.
        ParseException pe = new ParseException(e.reason, e.getCause());
        pe.setStackTrace(e.getStackTrace());
        mDnsException = new DnsException(ERROR_PARSE, pe);
    }
    maybeReportAnswer();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The exception handling statement has changed since the exception type caught is now DnsPacket.ParseException, which requires additional conversion to a new ParseException object before being assigned to mDnsException. Moreover, the stack trace from the original exception is now explicitly set on the new ParseException object. This indicates a change in the exception handling logic (2). Additionally, there are new statements inside the catch block resulting in an 'Other statement changed' (4).","The change in the exception handling statement can potentially throw a different exception since it involves conversion of the caught exception to a different type and then setting the stack trace. This modification in how exceptions are managed could lead to different behavior when the late version of the API is invoked, indicating a CI type of (2)."
398,<android.view.textclassifier.SelectionEvent: int hashCode()>,29,30,<android.view.textclassifier.SelectionEvent: int hashCode()>,<android.view.textclassifier.SelectionEvent: int hashCode()>,0,"{
    return Objects.hash(mAbsoluteStart, mAbsoluteEnd, mEventType, mEntityType, mWidgetVersion, mPackageName, mWidgetType, mInvocationMethod, mResultId, mEventTime, mDurationSinceSessionStart, mDurationSincePreviousEvent, mEventIndex, mSessionId, mStart, mEnd, mSmartStart, mSmartEnd);
}","{
    return Objects.hash(mAbsoluteStart, mAbsoluteEnd, mEventType, mEntityType, mWidgetVersion, mPackageName, mWidgetType, mInvocationMethod, mResultId, mEventTime, mDurationSinceSessionStart, mDurationSincePreviousEvent, mEventIndex, mSessionId, mStart, mEnd, mSmartStart, mSmartEnd, mSystemTcMetadata);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() method's implementation has changed by adding a new field, mSystemTcMetadata, to the Objects.hash method call. This means a new variable has been added to the computation of the hash code, which is categorized as Other statement changed (4). Since this affects the return value of the hashCode method, it is also classified as Return statement changed (1).","The introduction of a new field into the hash code calculation means that the method will now return a different integer value for objects that have differing mSystemTcMetadata values, even if all other fields are equal. Hence, the method will behave differently, constituting a Compatibility Issue by potentially returning different values (CI type 1)."
399,"<android.content.res.AssetManager: InputStream open(String,int)>",29,30,"<android.content.res.AssetManager: InputStream open(String,int)>","<android.content.res.AssetManager: InputStream open(String,int)>",0,"{
    Preconditions.checkNotNull(fileName, ""fileName"");
    synchronized (this) {
        ensureOpenLocked();
        final long asset = nativeOpenAsset(mObject, fileName, accessMode);
        if (asset == 0) {
            throw new FileNotFoundException(""Asset file: "" + fileName);
        }
        final AssetInputStream assetInputStream = new AssetInputStream(asset);
        incRefsLocked(assetInputStream.hashCode());
        return assetInputStream;
    }
}","{
    Objects.requireNonNull(fileName, ""fileName"");
    synchronized (this) {
        ensureOpenLocked();
        final long asset = nativeOpenAsset(mObject, fileName, accessMode);
        if (asset == 0) {
            throw new FileNotFoundException(""Asset file: "" + fileName);
        }
        final AssetInputStream assetInputStream = new AssetInputStream(asset);
        incRefsLocked(assetInputStream.hashCode());
        return assetInputStream;
    }
}",1,"/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * ""assets"" directory.
 *
 * @param fileName The name of the asset to open.  This name can be hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
","/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * ""assets"" directory.
 *
 * @param fileName The name of the asset to open.  This name can be hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is from using Preconditions.checkNotNull to Objects.requireNonNull for the fileName null check. The method used for the null check is a different method, but they serve the same purpose, so the code change type is 4.","The change in null checking method does not lead to a Compatibility Issue because both methods throw a NullPointerException when the fileName is null and the parameter ""fileName"" for the error message remains the same. Therefore, the behavior of the API does not change and there is no compatibility issue."
400,<android.se.omapi.SEService: Reader[] getReaders()>,29,30,<android.se.omapi.SEService: Reader[] getReaders()>,<android.se.omapi.SEService: Reader[] getReaders()>,0,"{
    if (mSecureElementService == null) {
        throw new IllegalStateException(""service not connected to system"");
    }
    String[] readerNames;
    try {
        readerNames = mSecureElementService.getReaders();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
    Reader[] readers = new Reader[readerNames.length];
    int i = 0;
    for (String readerName : readerNames) {
        if (mReaders.get(readerName) == null) {
            try {
                mReaders.put(readerName, new Reader(this, readerName, getReader(readerName)));
                readers[i++] = mReaders.get(readerName);
            } catch (Exception e) {
                Log.e(TAG, ""Error adding Reader: "" + readerName, e);
            }
        } else {
            readers[i++] = mReaders.get(readerName);
        }
    }
    return readers;
}","{
    loadReaders();
    return mReaders.values().toArray(new Reader[0]);
}",1,"/**
 * Returns an array of available Secure Element readers.
 * There must be no duplicated objects in the returned list.
 * All available readers shall be listed even if no card is inserted.
 *
 * @return An array of Readers. If there are no readers the returned array
 * is of length 0.
 */
","/**
 * Returns an array of available Secure Element readers.
 * There must be no duplicated objects in the returned list.
 * All available readers shall be listed even if no card is inserted.
 *
 * @return An array of Readers. If there are no readers the returned array
 * is of length 0.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed from creating a new array of `Reader` objects and populating it based on `readerNames` to returning the values of `mReaders` as an array directly. Also, there is a change in the method body which calls `loadReaders()` in the late version instead of the code being inline as in the early version. This includes changes in exception handling and implementation logic as well. The invocation of `getReader(readerName)` is also missing in the late version, which indicates a dependent API change. Thus, the change types are 1, 4, and 5.","Since there is a change in the return statement and a refactoring of code which could potentially change the array of `Reader` objects that are returned and the overall logic of handling exceptions and populating the array has been replaced with the `loadReaders()` method, there could be a different behavior in terms of the data returned. This leads to a potential CI due to different return values, classified as type 1."
401,"<android.speech.tts.TextToSpeech: int synthesizeToFile(CharSequence,Bundle,File,String)>",29,30,"<android.speech.tts.TextToSpeech: int synthesizeToFile(CharSequence,Bundle,File,String)>","<android.speech.tts.TextToSpeech: int synthesizeToFile(CharSequence,Bundle,File,String)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            ParcelFileDescriptor fileDescriptor;
            int returnValue;
            try {
                if (file.exists() && !file.canWrite()) {
                    Log.e(TAG, ""Can't write to "" + file);
                    return ERROR;
                }
                fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE);
                returnValue = service.synthesizeToFileDescriptor(getCallerIdentity(), text, fileDescriptor, getParams(params), utteranceId);
                fileDescriptor.close();
                return returnValue;
            } catch (FileNotFoundException e) {
                Log.e(TAG, ""Opening file "" + file + "" failed"", e);
                return ERROR;
            } catch (IOException e) {
                Log.e(TAG, ""Closing file "" + file + "" failed"", e);
                return ERROR;
            }
        }
    }, ERROR, ""synthesizeToFile"");
}","{
    if (file.exists() && !file.canWrite()) {
        Log.e(TAG, ""Can't write to "" + file);
        return ERROR;
    }
    try (ParcelFileDescriptor fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE)) {
        int returnValue = synthesizeToFile(text, params, fileDescriptor, utteranceId);
        fileDescriptor.close();
        return returnValue;
    } catch (FileNotFoundException e) {
        Log.e(TAG, ""Opening file "" + file + "" failed"", e);
        return ERROR;
    } catch (IOException e) {
        Log.e(TAG, ""Closing file "" + file + "" failed"", e);
        return ERROR;
    }
}",1,"/**
 * Synthesizes the given text to a file using the specified parameters.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}).
 *
 * @param text The text that should be synthesized. No longer than
 * {@link #getMaxSpeechInputLength()} characters.
 * @param params Parameters for the request. Can be null.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param file File to write the generated audio data to.
 * @param utteranceId An unique identifier for this request.
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the synthesizeToFile operation.
 */
","/**
 * Synthesizes the given text to a file using the specified parameters.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}).
 *
 * @param text The text that should be synthesized. No longer than
 * {@link #getMaxSpeechInputLength()} characters.
 * @param params Parameters for the request. Cannot be null.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param file File to write the generated audio data to.
 * @param utteranceId An unique identifier for this request.
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the synthesizeToFile operation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method's implementation has been refactored, which includes:",- The use of try-with-resources for the `ParcelFileDescriptor`.
402,"<android.app.VoiceInteractor: boolean registerOnDestroyedCallback(Executor,Runnable)>",29,30,"<android.app.VoiceInteractor: boolean registerOnDestroyedCallback(Executor,Runnable)>","<android.app.VoiceInteractor: boolean registerOnDestroyedCallback(Executor,Runnable)>",0,"{
    Preconditions.checkNotNull(executor);
    Preconditions.checkNotNull(callback);
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return false;
    }
    mOnDestroyCallbacks.put(callback, executor);
    return true;
}","{
    Objects.requireNonNull(executor);
    Objects.requireNonNull(callback);
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return false;
    }
    mOnDestroyCallbacks.put(callback, executor);
    return true;
}",1,"/**
 * Registers a callback to be called when the VoiceInteractor is destroyed.
 *
 * @param executor Executor on which to run the callback.
 * @param callback The callback to run.
 * @return whether the callback was registered.
 */
","/**
 * Registers a callback to be called when the VoiceInteractor is destroyed.
 *
 * @param executor Executor on which to run the callback.
 * @param callback The callback to run.
 * @return whether the callback was registered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method Preconditions.checkNotNull() has been replaced with Objects.requireNonNull() for both 'executor' and 'callback' arguments, which are equivalent methods. Thus, the change is only in the method used for the null check, classified as type 4.","There is no Compatibility Issue since both Objects.requireNonNull() and Preconditions.checkNotNull() throw NullPointerException if the object is null, and this does not change the behavior of the API with respect to what it returns or exceptions thrown."
403,<android.os.Parcel: void readStringArray(String[])>,29,30,<android.os.Parcel: void readStringArray(String[])>,<android.os.Parcel: void readStringArray(String[])>,0,"{
    int N = readInt();
    if (N == val.length) {
        for (int i = 0; i < N; i++) {
            val[i] = readString();
        }
    } else {
        throw new RuntimeException(""bad array lengths"");
    }
}","{
    readString16Array(val);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation has changed to call a different method readString16Array(val) instead of the inline code for filling the String array, which is a dependent API change, so the code change type is 4,5.","Since the dependent API readString16Array(val) could potentially behave differently from the previous inline implementation, such as different validation or handling upon reading strings, there's a potential that the method returns different values, so the CI type is 1."
404,<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,29,30,<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,0,"{
    Preconditions.checkNotNull(observer, ""observer"");
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(observer, ""observer"");
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Unregisters a change observer.
 *
 * @param observer The previously registered observer that is no longer needed.
 * @see #registerContentObserver
 */
","/**
 * Unregisters a change observer.
 *
 * @param observer The previously registered observer that is no longer needed.
 * @see #registerContentObserver
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is from using Preconditions.checkNotNull to Objects.requireNonNull, which does essentially the same check, just through a different utility method. Therefore, the change type is 4 (Other statement changed).","There is no Compatibility Issue because the change from Preconditions.checkNotNull to Objects.requireNonNull doesn't affect the API's behavior; it still performs a null check and throws a NullPointerException if the observer is null. Therefore, there are no changes in return value or types, nor changes in exceptions thrown by the method itself."
405,<android.view.DisplayCutout: int hashCode()>,29,30,<android.view.DisplayCutout: int hashCode()>,<android.view.DisplayCutout: int hashCode()>,0,"{
    return mSafeInsets.hashCode() * 48271 + mBounds.hashCode();
}","{
    return (mSafeInsets.hashCode() * 48271 + mBounds.hashCode()) * 48271 + mWaterfallInsets.hashCode();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An additional hashCode calculation has been added to the return statement with the inclusion of mWaterfallInsets, which means there is a change in the implementation other than return, exception handling, control dependency, or dependent API, so the code change type is 4.","The change in hashCode calculation does not change the API's contract or expected behavior, as it's an internal detail about how the hash code is generated. The modified implementation still returns an int value that's supposed to be a consistently calculated hash code for the instance of DisplayCutout. This change will lead to different hash code values for the same objects between versions, but this is not a violation of the API contract, as hash codes are not expected to remain consistent across different versions of software. Therefore, there is no Compatibility Issue according to the given definition (as hash code changes are typically not considered to produce compatibility issues since they are expected to differ even for the same object across different runs of an application), and the CI type is 0."
406,<android.content.IntentFilter: int matchDataAuthority(Uri)>,29,30,<android.content.IntentFilter: int matchDataAuthority(Uri)>,<android.content.IntentFilter: int matchDataAuthority(Uri)>,0,"{
    if (mDataAuthorities == null || data == null) {
        return NO_MATCH_DATA;
    }
    final int numDataAuthorities = mDataAuthorities.size();
    for (int i = 0; i < numDataAuthorities; i++) {
        final AuthorityEntry ae = mDataAuthorities.get(i);
        int match = ae.match(data);
        if (match >= 0) {
            return match;
        }
    }
    return NO_MATCH_DATA;
}","{
    return matchDataAuthority(data, false);
}",1,"/**
 * Match this intent filter against the given Intent data.  This ignores
 * the data scheme -- unlike {@link #matchData}, the authority will match
 * regardless of whether there is a matching scheme.
 *
 * @param data The data whose authority is being looked for.
 *
 * @return Returns either {@link #MATCH_CATEGORY_HOST},
 * {@link #MATCH_CATEGORY_PORT}, {@link #NO_MATCH_DATA}.
 */
","/**
 * Match this intent filter against the given Intent data.  This ignores
 * the data scheme -- unlike {@link #matchData}, the authority will match
 * regardless of whether there is a matching scheme.
 *
 * @param data The data whose authority is being looked for.
 *
 * @return Returns either {@link #MATCH_CATEGORY_HOST},
 * {@link #MATCH_CATEGORY_PORT}, {@link #NO_MATCH_DATA}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method body in the late version is replaced by a single line that calls a different method (matchDataAuthority(data, false)) with a new boolean parameter added to the call, so the changes are classified as 4,5.","There is no compatibility issue detected because the internal implementation change is redirected to an overload of the same method, which is intended to abstract the data-matching logic. The new method call suggests that the logic may have been refactored but does not inherently suggest a change in behavior for consumers of the original method; thus, the CI type is 0."
408,<android.app.NotificationChannel: String toString()>,29,30,<android.app.NotificationChannel: String toString()>,<android.app.NotificationChannel: String toString()>,0,"{
    return ""NotificationChannel{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + "", mDescription="" + (!TextUtils.isEmpty(mDesc) ? ""hasDescription "" : """") + "", mImportance="" + mImportance + "", mBypassDnd="" + mBypassDnd + "", mLockscreenVisibility="" + mLockscreenVisibility + "", mSound="" + mSound + "", mLights="" + mLights + "", mLightColor="" + mLightColor + "", mVibration="" + Arrays.toString(mVibration) + "", mUserLockedFields="" + Integer.toHexString(mUserLockedFields) + "", mFgServiceShown="" + mFgServiceShown + "", mVibrationEnabled="" + mVibrationEnabled + "", mShowBadge="" + mShowBadge + "", mDeleted="" + mDeleted + "", mGroup='"" + mGroup + '\'' + "", mAudioAttributes="" + mAudioAttributes + "", mBlockableSystem="" + mBlockableSystem + "", mAllowBubbles="" + mAllowBubbles + "", mImportanceLockedByOEM="" + mImportanceLockedByOEM + "", mImportanceLockedDefaultApp="" + mImportanceLockedDefaultApp + '}';
}","{
    return ""NotificationChannel{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + getFieldsString() + '}';
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method toString() in the late version is refactored to use a helper method getFieldsString() for constructing the string instead of constructing the entire string inline within the method. This is a simplification of the method and does not change the return type or the information contained within the string, and hence is categorized under 4 (Other statement changed).","This change does not lead to a Compatibility Issue since the output of the toString() method should remain the same assuming getFieldsString() is implemented to return the same string content as was previously inlined in the early version. There's no indication that the values or types returned would differ between the two versions, nor are there changes in exception handling. Therefore, it is classified as 0 (No Compatibility Issue)."
409,<android.os.Environment: boolean isExternalStorageLegacy(File)>,29,30,<android.os.Environment: boolean isExternalStorageLegacy(File)>,<android.os.Environment: boolean isExternalStorageLegacy(File)>,0,"{
    final Context context = AppGlobals.getInitialApplication();
    final int uid = context.getApplicationInfo().uid;
    if (Process.isIsolated(uid)) {
        return false;
    }
    final PackageManager packageManager = context.getPackageManager();
    if (packageManager.isInstantApp()) {
        return false;
    }
    if (packageManager.checkPermission(Manifest.permission.WRITE_MEDIA_STORAGE, context.getPackageName()) == PackageManager.PERMISSION_GRANTED) {
        return true;
    }
    if (packageManager.checkPermission(Manifest.permission.INSTALL_PACKAGES, context.getPackageName()) == PackageManager.PERMISSION_GRANTED) {
        return true;
    }
    final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
    final String[] packagesForUid = packageManager.getPackagesForUid(uid);
    for (String packageName : packagesForUid) {
        if (appOps.checkOpNoThrow(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES, uid, packageName) == AppOpsManager.MODE_ALLOWED) {
            return true;
        }
    }
    return appOps.checkOpNoThrow(AppOpsManager.OP_LEGACY_STORAGE, uid, context.getOpPackageName()) == AppOpsManager.MODE_ALLOWED;
}","{
    final Context context = AppGlobals.getInitialApplication();
    final int uid = context.getApplicationInfo().uid;
    // Isolated processes and Instant apps are never allowed to be in scoped storage
    if (Process.isIsolated(uid)) {
        return false;
    }
    final PackageManager packageManager = context.getPackageManager();
    if (packageManager.isInstantApp()) {
        return false;
    }
    boolean defaultScopedStorage = Compatibility.isChangeEnabled(DEFAULT_SCOPED_STORAGE);
    boolean forceEnableScopedStorage = Compatibility.isChangeEnabled(FORCE_ENABLE_SCOPED_STORAGE);
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageEnforced(defaultScopedStorage, forceEnableScopedStorage)) {
        return false;
    }
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageDisabled(defaultScopedStorage, forceEnableScopedStorage)) {
        return true;
    }
    final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
    return appOps.checkOpNoThrow(AppOpsManager.OP_LEGACY_STORAGE, uid, context.getOpPackageName()) == AppOpsManager.MODE_ALLOWED;
}",1,"/**
 * Returns whether the shared/external storage media at the given path is a
 * legacy view that includes files not owned by the app.
 * <p>
 * This value may be different from the value requested by
 * {@code requestLegacyExternalStorage} in the app's manifest, since an app
 * may inherit its legacy state based on when it was first installed.
 * <p>
 * Non-legacy apps can continue to discover and read media belonging to
 * other apps via {@link android.provider.MediaStore}.
 *
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
","/**
 * Returns whether the shared/external storage media is a
 * legacy view that includes files not owned by the app.
 * <p>
 * This value may be different from the value requested by
 * {@code requestLegacyExternalStorage} in the app's manifest, since an app
 * may inherit its legacy state based on when it was first installed, target sdk and other
 * factors.
 * <p>
 * Non-legacy apps can continue to discover and read media belonging to
 * other apps via {@link android.provider.MediaStore}.
 *
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"This change sees the addition of the new API calls to Compatibility.isChangeEnabled and new conditional logic related to those calls. The method logic flow has been changed with the added conditionals, so this includes changes in control flow (type 3), other changes not related to return or exception handling statements (type 4), and dependent API changes, as new methods are being called (type 5).","Since the logic now includes additional checks with 'defaultScopedStorage' and 'forceEnableScopedStorage' and potentially returns different results depending on these, it can be inferred that the method could return different results based on the new conditions introduced. This represents a compatibility issue where the method potentially returns different values (type 1)."
410,<android.service.voice.VoiceInteractionSession: void startVoiceActivity(Intent)>,29,30,<android.service.voice.VoiceInteractionSession: void startVoiceActivity(Intent)>,<android.service.voice.VoiceInteractionSession: void startVoiceActivity(Intent)>,0,"{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(mContext);
        int res = mSystemService.startVoiceActivity(mToken, intent, intent.resolveType(mContext.getContentResolver()));
        Instrumentation.checkStartActivityResult(res, intent);
    } catch (RemoteException e) {
    }
}","{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    try {
        intent.migrateExtraStreamToClipData(mContext);
        intent.prepareToLeaveProcess(mContext);
        int res = mSystemService.startVoiceActivity(mToken, intent, intent.resolveType(mContext.getContentResolver()), mContext.getAttributionTag());
        Instrumentation.checkStartActivityResult(res, intent);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Ask that a new activity be started for voice interaction.  This will create a
 * new dedicated task in the activity manager for this voice interaction session;
 * this means that {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK}
 * will be set for you to make it a new task.
 *
 * <p>The newly started activity will be displayed to the user in a special way, as
 * a layer under the voice interaction UI.</p>
 *
 * <p>As the voice activity runs, it can retrieve a {@link android.app.VoiceInteractor}
 * through which it can perform voice interactions through your session.  These requests
 * for voice interactions will appear as callbacks on {@link #onGetSupportedCommands},
 * {@link #onRequestConfirmation}, {@link #onRequestPickOption},
 * {@link #onRequestCompleteVoice}, {@link #onRequestAbortVoice},
 * or {@link #onRequestCommand}
 *
 * <p>You will receive a call to {@link #onTaskStarted} when the task starts up
 * and {@link #onTaskFinished} when the last activity has finished.
 *
 * @param intent The Intent to start this voice interaction.  The given Intent will
 * always have {@link Intent#CATEGORY_VOICE Intent.CATEGORY_VOICE} added to it, since
 * this is part of a voice interaction.
 */
","/**
 * Ask that a new activity be started for voice interaction.  This will create a
 * new dedicated task in the activity manager for this voice interaction session;
 * this means that {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK}
 * will be set for you to make it a new task.
 *
 * <p>The newly started activity will be displayed to the user in a special way, as
 * a layer under the voice interaction UI.</p>
 *
 * <p>As the voice activity runs, it can retrieve a {@link android.app.VoiceInteractor}
 * through which it can perform voice interactions through your session.  These requests
 * for voice interactions will appear as callbacks on {@link #onGetSupportedCommands},
 * {@link #onRequestConfirmation}, {@link #onRequestPickOption},
 * {@link #onRequestCompleteVoice}, {@link #onRequestAbortVoice},
 * or {@link #onRequestCommand}
 *
 * <p>You will receive a call to {@link #onTaskStarted} when the task starts up
 * and {@link #onTaskFinished} when the last activity has finished.
 *
 * @param intent The Intent to start this voice interaction.  The given Intent will
 * always have {@link Intent#CATEGORY_VOICE Intent.CATEGORY_VOICE} added to it, since
 * this is part of a voice interaction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method 'intent.migrateExtraStreamToClipData()' is modified to include 'mContext' as an argument, and 'mSystemService.startVoiceActivity()' includes an additional parameter 'mContext.getAttributionTag()'. So the code change type is 4 for the method call change and 5 for the change in the dependent API.","Although the method signature and behavior for 'migrateExtraStreamToClipData' and 'startVoiceActivity' have changed by adding extra parameters, there is no change in exception handling or return values, so these do not lead to a Compatibility Issue as per the definitions provided. Thus, the CI type is 0."
411,"<android.app.AppOpsManager: int unsafeCheckOpRaw(String,int,String)>",29,30,"<android.app.AppOpsManager: int unsafeCheckOpRaw(String,int,String)>","<android.app.AppOpsManager: int unsafeCheckOpRaw(String,int,String)>",0,"{
    try {
        return mService.checkOperationRaw(strOpToOp(op), uid, packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return unsafeCheckOpRawNoThrow(op, uid, packageName);
}",1,"/**
 * Like {@link #checkOp} but returns the <em>raw</em> mode associated with the op.
 * Does not throw a security exception, does not translate {@link #MODE_FOREGROUND}.
 */
","/**
 * Like {@link #checkOp} but returns the <em>raw</em> mode associated with the op.
 * Does not throw a security exception, does not translate {@link #MODE_FOREGROUND}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The implementation of the method has changed with the removal of a try-catch block that used to catch `RemoteException` and rethrow it. The late version directly returns the result of another method call, unsafeCheckOpRawNoThrow(op, uid, packageName), which replaces the original direct call to mService.checkOperationRaw(strOpToOp(op), uid, packageName). The change type is thus 1 (return statement changed) and 5 (dependent API changed).","There is no Compatibility Issue with regard to change type 1 as the return value should remain the same since the inner workings of unsafeCheckOpRawNoThrow are assumed to preserve the original behavior of mService.checkOperationRaw call. Also, no Compatibility Issue with regard to exception handling type 2 as the original exception handling is preserved in essence. The `rethrowFromSystemServer()` behavior is part of the internal contract to throw the `RemoteException` as a system-level exception, and it's assumed that unsafeCheckOpRawNoThrow would maintain this contract internally if necessary."
412,"<android.content.pm.LauncherApps: Drawable getShortcutIconDrawable(ShortcutInfo,int)>",29,30,"<android.content.pm.LauncherApps: Drawable getShortcutIconDrawable(ShortcutInfo,int)>","<android.content.pm.LauncherApps: Drawable getShortcutIconDrawable(ShortcutInfo,int)>",0,"{
    if (shortcut.hasIconFile()) {
        final ParcelFileDescriptor pfd = getShortcutIconFd(shortcut);
        if (pfd == null) {
            return null;
        }
        try {
            final Bitmap bmp = BitmapFactory.decodeFileDescriptor(pfd.getFileDescriptor());
            if (bmp != null) {
                BitmapDrawable dr = new BitmapDrawable(mContext.getResources(), bmp);
                if (shortcut.hasAdaptiveBitmap()) {
                    return new AdaptiveIconDrawable(null, dr);
                } else {
                    return dr;
                }
            }
            return null;
        } finally {
            try {
                pfd.close();
            } catch (IOException ignore) {
            }
        }
    } else if (shortcut.hasIconResource()) {
        return loadDrawableResourceFromPackage(shortcut.getPackage(), shortcut.getIconResourceId(), shortcut.getUserHandle(), density);
    } else if (shortcut.getIcon() != null) {
        // This happens if a shortcut is pending-approval.
        final Icon icon = shortcut.getIcon();
        switch(icon.getType()) {
            case Icon.TYPE_RESOURCE:
                {
                    return loadDrawableResourceFromPackage(shortcut.getPackage(), icon.getResId(), shortcut.getUserHandle(), density);
                }
            case Icon.TYPE_BITMAP:
            case Icon.TYPE_ADAPTIVE_BITMAP:
                {
                    return icon.loadDrawable(mContext);
                }
            default:
                // Shouldn't happen though.
                return null;
        }
    } else {
        // Has no icon.
        return null;
    }
}","{
    if (shortcut.hasIconFile()) {
        final ParcelFileDescriptor pfd = getShortcutIconFd(shortcut);
        return loadDrawableFromFileDescriptor(pfd, shortcut.hasAdaptiveBitmap());
    } else if (shortcut.hasIconUri()) {
        final ParcelFileDescriptor pfd = getUriShortcutIconFd(shortcut);
        return loadDrawableFromFileDescriptor(pfd, shortcut.hasAdaptiveBitmap());
    } else if (shortcut.hasIconResource()) {
        return loadDrawableResourceFromPackage(shortcut.getPackage(), shortcut.getIconResourceId(), shortcut.getUserHandle(), density);
    } else if (shortcut.getIcon() != null) {
        // This happens if a shortcut is pending-approval.
        final Icon icon = shortcut.getIcon();
        switch(icon.getType()) {
            case Icon.TYPE_RESOURCE:
                {
                    return loadDrawableResourceFromPackage(shortcut.getPackage(), icon.getResId(), shortcut.getUserHandle(), density);
                }
            case Icon.TYPE_BITMAP:
            case Icon.TYPE_ADAPTIVE_BITMAP:
                {
                    return icon.loadDrawable(mContext);
                }
            default:
                // Shouldn't happen though.
                return null;
        }
    } else {
        // Has no icon.
        return null;
    }
}",1,"/**
 * Returns the icon for this shortcut, without any badging for the profile.
 *
 * <p>The calling launcher application must be allowed to access the shortcut information,
 * as defined in {@link #hasShortcutHostPermission()}.
 *
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 *
 * @return The drawable associated with the shortcut.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 * @see #getShortcutBadgedIconDrawable(ShortcutInfo, int)
 * @see DisplayMetrics
 */
","/**
 * Returns the icon for this shortcut, without any badging for the profile.
 *
 * <p>The calling launcher application must be allowed to access the shortcut information,
 * as defined in {@link #hasShortcutHostPermission()}.
 *
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 *
 * @return The drawable associated with the shortcut.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 * @see #getShortcutBadgedIconDrawable(ShortcutInfo, int)
 * @see DisplayMetrics
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"There are changes within the control structure, with the introduction of a new condition (else if with shortcut.hasIconUri()) and the use of the new method loadDrawableFromFileDescriptor() instead of the block of Bitmap operations. Apart from that, there have been changes in the dependent APIs: getShortcutIconFd() no longer returns null directly and the addition of a new dependent API getUriShortcutIconFd(). Therefore, the code change types are 1,3,4,5.","The change in control flow and the introduction of a new condition, as well as the change of several implementations inside the conditions can potentially lead to return different drawable objects compared to the early version. Since Drawable objects returned are influenced by the newly introduced condition and methods, there is a Compatibility Issue of type 1."
413,"<android.app.Activity: void performRestart(boolean,String)>",29,30,"<android.app.Activity: void performRestart(boolean,String)>","<android.app.Activity: void performRestart(boolean,String)>",0,"{
    mCanEnterPictureInPicture = true;
    mFragments.noteStateNotSaved();
    if (mToken != null && mParent == null) {
        // No need to check mStopped, the roots will check if they were actually stopped.
        WindowManagerGlobal.getInstance().setStoppedState(mToken, false);
    }
    if (mStopped) {
        mStopped = false;
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                            throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                        }
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        writeEventLog(LOG_AM_ON_RESTART_CALLED, reason);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        if (start) {
            performStart(reason);
        }
    }
}","{
    mCanEnterPictureInPicture = true;
    mFragments.noteStateNotSaved();
    if (mToken != null && mParent == null) {
        // No need to check mStopped, the roots will check if they were actually stopped.
        WindowManagerGlobal.getInstance().setStoppedState(mToken, false);
    }
    if (mStopped) {
        mStopped = false;
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                            throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                        }
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        EventLogTags.writeWmOnRestartCalled(mIdent, getComponentName().getClassName(), reason);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        if (start) {
            performStart(reason);
        }
    }
}",1,"/**
 * Restart the activity.
 * @param start Indicates whether the activity should also be started after restart.
 * The option to not start immediately is needed in case a transaction with
 * multiple lifecycle transitions is in progress.
 */
","/**
 * Restart the activity.
 * @param start Indicates whether the activity should also be started after restart.
 * The option to not start immediately is needed in case a transaction with
 * multiple lifecycle transitions is in progress.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only statement change is from writeEventLog(LOG_AM_ON_RESTART_CALLED, reason) to EventLogTags.writeWmOnRestartCalled(mIdent, getComponentName().getClassName(), reason). This is a change in how the event logging is performed, so the code change type is 4.","The change is only in event logging which does not affect the method's logic, return values or thrown exceptions. Therefore, there is no Compatibility Issue, hence the CI type is 0."
414,"<android.widget.SimpleMonthView.MonthViewTouchHelper: void onPopulateNodeForVirtualView(int,AccessibilityNodeInfo)>",29,30,"<android.widget.SimpleMonthView.MonthViewTouchHelper: void onPopulateNodeForVirtualView(int,AccessibilityNodeInfo)>","<android.widget.SimpleMonthView.MonthViewTouchHelper: void onPopulateNodeForVirtualView(int,AccessibilityNodeInfo)>",0,"{
    final boolean hasBounds = getBoundsForDay(virtualViewId, mTempRect);
    if (!hasBounds) {
        // The day is invalid, kill the node.
        mTempRect.setEmpty();
        node.setContentDescription("""");
        node.setBoundsInParent(mTempRect);
        node.setVisibleToUser(false);
        return;
    }
    node.setText(getDayText(virtualViewId));
    node.setContentDescription(getDayDescription(virtualViewId));
    node.setBoundsInParent(mTempRect);
    final boolean isDayEnabled = isDayEnabled(virtualViewId);
    if (isDayEnabled) {
        node.addAction(AccessibilityAction.ACTION_CLICK);
    }
    node.setEnabled(isDayEnabled);
    if (virtualViewId == mActivatedDay) {
        // TODO: This should use activated once that's supported.
        node.setChecked(true);
    }
}","{
    final boolean hasBounds = getBoundsForDay(virtualViewId, mTempRect);
    if (!hasBounds) {
        // The day is invalid, kill the node.
        mTempRect.setEmpty();
        node.setContentDescription("""");
        node.setBoundsInParent(mTempRect);
        node.setVisibleToUser(false);
        return;
    }
    node.setText(getDayText(virtualViewId));
    node.setContentDescription(getDayDescription(virtualViewId));
    if (virtualViewId == mToday) {
        RelativeDateTimeFormatter fmt = RelativeDateTimeFormatter.getInstance();
        node.setStateDescription(fmt.format(RelativeDateTimeFormatter.Direction.THIS, RelativeDateTimeFormatter.AbsoluteUnit.DAY));
    }
    if (virtualViewId == mActivatedDay) {
        node.setSelected(true);
    }
    node.setBoundsInParent(mTempRect);
    final boolean isDayEnabled = isDayEnabled(virtualViewId);
    if (isDayEnabled) {
        node.addAction(AccessibilityAction.ACTION_CLICK);
    }
    node.setEnabled(isDayEnabled);
    node.setClickable(true);
    if (virtualViewId == mActivatedDay) {
        // TODO: This should use activated once that's supported.
        node.setChecked(true);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed since the condition check `if (virtualViewId == mToday)` and the associated code block is newly introduced to set state description. Additionally, the statement `node.setClickable(true);` has been added without being enclosed in any control statements, indicating an ""other statement changed."" Therefore, the change types are 3 (control dependency change) and 4 (other statement changed).","There is no Compatibility Issue detected because the changes will not affect the behavior in a way that leads to different return values or exceptions. Existing functionality is either extended with additional properties being set or remains uncalled due to the condition not being met. The method return type is void; hence the changes will not cause it to return different values (the method always returns no value), and no changes are made to exception handling."
417,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,29,30,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,0,"{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, mFlags, mClassLoader, null);
    final int displayId = getDisplayId();
    context.setResources(createResources(mActivityToken, mPackageInfo, mSplitName, displayId, overrideConfiguration, getDisplayAdjustments(displayId).getCompatibilityInfo()));
    return context;
}","{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, mSplitName, mToken, mUser, mFlags, mClassLoader, null);
    final int displayId = getDisplayId();
    context.setResources(createResources(mToken, mPackageInfo, mSplitName, displayId, overrideConfiguration, getDisplayAdjustments(displayId).getCompatibilityInfo(), mResources.getLoaders()));
    context.mIsUiContext = isUiContext() || isOuterUiContext();
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5","1,2",The code change includes:,- A new variable assignment (context.mIsUiContext = ...) is introduced after the resources are set.
418,<android.net.TrafficStats: long getUidRxBytes(int)>,29,30,<android.net.TrafficStats: long getUidRxBytes(int)>,<android.net.TrafficStats: long getUidRxBytes(int)>,0,"{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_RX_BYTES);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}","{
    try {
        return getStatsService().getUidStats(uid, TYPE_RX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return number of bytes received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of bytes received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency surrounding the code has been removed. In the early version, there is a permission check that returns UNSUPPORTED for certain UIDs, which has been removed in the late version. The 'try' block is no longer under a conditional, so this is a control dependency change of type 3. Additionally, this change means that the late version could potentially return different data compared to the early version for UIDs that are not SYSTEM_UID or the calling UID, thus there's a change to the return statement (type 1).","By removing the conditional check for the calling UID, the method will now potentially return values where it previously returned UNSUPPORTED. Thus, there is a compatibility issue of type 1 caused by potentially different return values."
422,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>",29,30,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>","<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        return fallbackImm.showSoftInput(view, flags, resultReceiver);
    }
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return false;
        }
        try {
            return mService.showSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        return fallbackImm.showSoftInput(view, flags, resultReceiver);
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return false;
        }
        try {
            return mService.showSoftInput(mClient, view.getWindowToken(), flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Explicitly request that the current input method's soft input area be
 * shown to the user, if needed.  Call this if the user interacts with
 * your view in such a way that they have expressed they would like to
 * start performing input into it.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
","/**
 * Explicitly request that the current input method's soft input area be
 * shown to the user, if needed.  Call this if the user interacts with
 * your view in such a way that they have expressed they would like to
 * start performing input into it.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"There is a change in control dependency with the replacement of the condition `(mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view)))` with the new method call `hasServedByInputMethodLocked(view)`. Additionally, the call to `mService.showSoftInput` has an additional argument `view.getWindowToken()` in the late version, which is a change in a dependent API. Therefore, the code change type is 3,5.","Since there is a change in the control structure that determines the return value and a modification in the parameters passed to a dependent API (`mService.showSoftInput`), this may lead to a different return value, representing a potential Compatibility Issue of type 1."
423,"<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>",29,30,"<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>","<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>",0,"{
    Log.i(TAG, prefix + ""View ["" + node.getLeft() + "","" + node.getTop() + "" "" + node.getWidth() + ""x"" + node.getHeight() + ""]"" + "" "" + node.getClassName());
    int id = node.getId();
    if (id != 0) {
        StringBuilder sb = new StringBuilder();
        sb.append(prefix);
        sb.append(""  ID: #"");
        sb.append(Integer.toHexString(id));
        String entry = node.getIdEntry();
        if (entry != null) {
            String type = node.getIdType();
            String pkg = node.getIdPackage();
            sb.append("" "");
            sb.append(pkg);
            sb.append("":"");
            sb.append(type);
            sb.append(""/"");
            sb.append(entry);
        }
        Log.i(TAG, sb.toString());
    }
    int scrollX = node.getScrollX();
    int scrollY = node.getScrollY();
    if (scrollX != 0 || scrollY != 0) {
        Log.i(TAG, prefix + ""  Scroll: "" + scrollX + "","" + scrollY);
    }
    Matrix matrix = node.getTransformation();
    if (matrix != null) {
        Log.i(TAG, prefix + ""  Transformation: "" + matrix);
    }
    float elevation = node.getElevation();
    if (elevation != 0) {
        Log.i(TAG, prefix + ""  Elevation: "" + elevation);
    }
    float alpha = node.getAlpha();
    if (alpha != 0) {
        Log.i(TAG, prefix + ""  Alpha: "" + elevation);
    }
    CharSequence contentDescription = node.getContentDescription();
    if (contentDescription != null) {
        Log.i(TAG, prefix + ""  Content description: "" + contentDescription);
    }
    CharSequence text = node.getText();
    if (text != null) {
        final String safeText = node.isSanitized() || showSensitive ? text.toString() : ""REDACTED["" + text.length() + "" chars]"";
        Log.i(TAG, prefix + ""  Text (sel "" + node.getTextSelectionStart() + ""-"" + node.getTextSelectionEnd() + ""): "" + safeText);
        Log.i(TAG, prefix + ""  Text size: "" + node.getTextSize() + "" , style: #"" + node.getTextStyle());
        Log.i(TAG, prefix + ""  Text color fg: #"" + Integer.toHexString(node.getTextColor()) + "", bg: #"" + Integer.toHexString(node.getTextBackgroundColor()));
        Log.i(TAG, prefix + ""  Input type: "" + node.getInputType());
        Log.i(TAG, prefix + ""  Resource id: "" + node.getTextIdEntry());
    }
    String webDomain = node.getWebDomain();
    if (webDomain != null) {
        Log.i(TAG, prefix + ""  Web domain: "" + webDomain);
    }
    HtmlInfo htmlInfo = node.getHtmlInfo();
    if (htmlInfo != null) {
        Log.i(TAG, prefix + ""  HtmlInfo: tag="" + htmlInfo.getTag() + "", attr="" + htmlInfo.getAttributes());
    }
    LocaleList localeList = node.getLocaleList();
    if (localeList != null) {
        Log.i(TAG, prefix + ""  LocaleList: "" + localeList);
    }
    String hint = node.getHint();
    if (hint != null) {
        Log.i(TAG, prefix + ""  Hint: "" + hint);
    }
    Bundle extras = node.getExtras();
    if (extras != null) {
        Log.i(TAG, prefix + ""  Extras: "" + extras);
    }
    if (node.isAssistBlocked()) {
        Log.i(TAG, prefix + ""  BLOCKED"");
    }
    AutofillId autofillId = node.getAutofillId();
    if (autofillId == null) {
        Log.i(TAG, prefix + "" NO autofill ID"");
    } else {
        Log.i(TAG, prefix + ""  Autofill info: id= "" + autofillId + "", type="" + node.getAutofillType() + "", options="" + Arrays.toString(node.getAutofillOptions()) + "", hints="" + Arrays.toString(node.getAutofillHints()) + "", value="" + node.getAutofillValue() + "", sanitized="" + node.isSanitized() + "", important="" + node.getImportantForAutofill());
    }
    final int NCHILDREN = node.getChildCount();
    if (NCHILDREN > 0) {
        Log.i(TAG, prefix + ""  Children:"");
        String cprefix = prefix + ""    "";
        for (int i = 0; i < NCHILDREN; i++) {
            ViewNode cnode = node.getChildAt(i);
            dump(cprefix, cnode, showSensitive);
        }
    }
}","{
    Log.i(TAG, prefix + ""View ["" + node.getLeft() + "","" + node.getTop() + "" "" + node.getWidth() + ""x"" + node.getHeight() + ""]"" + "" "" + node.getClassName());
    int id = node.getId();
    if (id != 0) {
        StringBuilder sb = new StringBuilder();
        sb.append(prefix);
        sb.append(""  ID: #"");
        sb.append(Integer.toHexString(id));
        String entry = node.getIdEntry();
        if (entry != null) {
            String type = node.getIdType();
            String pkg = node.getIdPackage();
            sb.append("" "");
            sb.append(pkg);
            sb.append("":"");
            sb.append(type);
            sb.append(""/"");
            sb.append(entry);
        }
        Log.i(TAG, sb.toString());
    }
    int scrollX = node.getScrollX();
    int scrollY = node.getScrollY();
    if (scrollX != 0 || scrollY != 0) {
        Log.i(TAG, prefix + ""  Scroll: "" + scrollX + "","" + scrollY);
    }
    Matrix matrix = node.getTransformation();
    if (matrix != null) {
        Log.i(TAG, prefix + ""  Transformation: "" + matrix);
    }
    float elevation = node.getElevation();
    if (elevation != 0) {
        Log.i(TAG, prefix + ""  Elevation: "" + elevation);
    }
    float alpha = node.getAlpha();
    if (alpha != 0) {
        Log.i(TAG, prefix + ""  Alpha: "" + elevation);
    }
    CharSequence contentDescription = node.getContentDescription();
    if (contentDescription != null) {
        Log.i(TAG, prefix + ""  Content description: "" + contentDescription);
    }
    CharSequence text = node.getText();
    if (text != null) {
        final String safeText = node.isSanitized() || showSensitive ? text.toString() : ""REDACTED["" + text.length() + "" chars]"";
        Log.i(TAG, prefix + ""  Text (sel "" + node.getTextSelectionStart() + ""-"" + node.getTextSelectionEnd() + ""): "" + safeText);
        Log.i(TAG, prefix + ""  Text size: "" + node.getTextSize() + "" , style: #"" + node.getTextStyle());
        Log.i(TAG, prefix + ""  Text color fg: #"" + Integer.toHexString(node.getTextColor()) + "", bg: #"" + Integer.toHexString(node.getTextBackgroundColor()));
        Log.i(TAG, prefix + ""  Input type: "" + node.getInputType());
        Log.i(TAG, prefix + ""  Resource id: "" + node.getTextIdEntry());
    }
    String webDomain = node.getWebDomain();
    if (webDomain != null) {
        Log.i(TAG, prefix + ""  Web domain: "" + webDomain);
    }
    HtmlInfo htmlInfo = node.getHtmlInfo();
    if (htmlInfo != null) {
        Log.i(TAG, prefix + ""  HtmlInfo: tag="" + htmlInfo.getTag() + "", attr="" + htmlInfo.getAttributes());
    }
    LocaleList localeList = node.getLocaleList();
    if (localeList != null) {
        Log.i(TAG, prefix + ""  LocaleList: "" + localeList);
    }
    String hint = node.getHint();
    if (hint != null) {
        Log.i(TAG, prefix + ""  Hint: "" + hint);
        Log.i(TAG, prefix + ""  Resource id: "" + node.getHintIdEntry());
    }
    Bundle extras = node.getExtras();
    if (extras != null) {
        Log.i(TAG, prefix + ""  Extras: "" + extras);
    }
    if (node.isAssistBlocked()) {
        Log.i(TAG, prefix + ""  BLOCKED"");
    }
    AutofillId autofillId = node.getAutofillId();
    if (autofillId == null) {
        Log.i(TAG, prefix + "" NO autofill ID"");
    } else {
        Log.i(TAG, prefix + ""  Autofill info: id= "" + autofillId + "", type="" + node.getAutofillType() + "", options="" + Arrays.toString(node.getAutofillOptions()) + "", hints="" + Arrays.toString(node.getAutofillHints()) + "", value="" + node.getAutofillValue() + "", sanitized="" + node.isSanitized() + "", important="" + node.getImportantForAutofill());
    }
    final int NCHILDREN = node.getChildCount();
    if (NCHILDREN > 0) {
        Log.i(TAG, prefix + ""  Children:"");
        String cprefix = prefix + ""    "";
        for (int i = 0; i < NCHILDREN; i++) {
            ViewNode cnode = node.getChildAt(i);
            dump(cprefix, cnode, showSensitive);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
424,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,29,30,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mLastParentXOnScreen = positionListener.getPositionXOnScreen();
                mLastParentYOnScreen = positionListener.getPositionYOnScreen();
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                mTouchToWindowOffsetX = xInWindow - mPositionX;
                mTouchToWindowOffsetY = yInWindow - mPositionY;
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = yInWindow - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = xInWindow - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = yInWindow - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY, ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp(ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable(false);
            break;
    }
    return true;
}","{
    if (TextView.DEBUG_CURSOR) {
        logCursor(this.getClass().getSimpleName() + "": HandleView: onTouchEvent"", ""%d: %s (%f,%f)"", ev.getSequenceNumber(), MotionEvent.actionToString(ev.getActionMasked()), ev.getX(), ev.getY());
    }
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mLastParentXOnScreen = positionListener.getPositionXOnScreen();
                mLastParentYOnScreen = positionListener.getPositionYOnScreen();
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                mTouchToWindowOffsetX = xInWindow - mPositionX;
                mTouchToWindowOffsetY = yInWindow - mPositionY;
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = yInWindow - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = xInWindow - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = yInWindow - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY, ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp(ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable(false);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
425,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",29,30,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mimeType, ""mimeType"");
    try {
        if (mWrapped != null)
            return mWrapped.openTypedAssetFile(uri, mimeType, opts, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        unstableProvider = null;
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    Objects.requireNonNull(mimeType, ""mimeType"");
    try {
        if (mWrapped != null)
            return mWrapped.openTypedAssetFile(uri, mimeType, opts, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, mAttributionTag, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, mAttributionTag, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        unstableProvider = null;
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength(), fd.getExtras());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}",1,"/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
","/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider or {@code null} if the provider recently crashed.
 * Note that this may be a pipe, meaning you can't seek in it.  The only seek you
 * should do is if the AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,,,,
426,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",29,30,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>","<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",0,"{
    Slog.v(TAG, ""DynSystemService connected"");
    mService = new Messenger(service);
    try {
        Message msg = Message.obtain(null, MSG_REGISTER_LISTENER);
        msg.replyTo = mMessenger;
        mService.send(msg);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to get status from installation service"");
        mExecutor.execute(() -> {
            mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e);
        });
    }
}","{
    Slog.v(TAG, ""DynSystemService connected"");
    mService = new Messenger(service);
    try {
        Message msg = Message.obtain(null, MSG_REGISTER_LISTENER);
        msg.replyTo = mMessenger;
        mService.send(msg);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to get status from installation service"");
        if (mExecutor != null) {
            mExecutor.execute(() -> {
                mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e);
            });
        } else {
            mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change in code is the addition of a condition checking if mExecutor is not null. This is a control dependency change, so the code change type is 3.","The additional null check on mExecutor ensures that it is not null before attempting to execute code using it. If mExecutor is null, it falls back to the else block, which performs the same action without using mExecutor. The behavior remains consistent since the same action (mListener.onStatusChanged) will be executed whether mExecutor is null or not, which means there is no Compatibility Issue. Therefore, the CI type is 0."
427,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CryptoObject,CancellationSignal,Executor,AuthenticationCallback)>",29,30,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CryptoObject,CancellationSignal,Executor,AuthenticationCallback)>","<android.hardware.biometrics.BiometricPrompt: void authenticate(CryptoObject,CancellationSignal,Executor,AuthenticationCallback)>",0,"{
    if (crypto == null) {
        throw new IllegalArgumentException(""Must supply a crypto object"");
    }
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    if (mBundle.getBoolean(KEY_ALLOW_DEVICE_CREDENTIAL)) {
        throw new IllegalArgumentException(""Device credential not supported with crypto"");
    }
    authenticateInternal(crypto, cancel, executor, callback, mContext.getUserId(), null);
}","{
    if (crypto == null) {
        throw new IllegalArgumentException(""Must supply a crypto object"");
    }
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    // Disallow explicitly setting any non-Strong biometric authenticator types.
    @Authenticators.Types final int authenticators = mBundle.getInt(KEY_AUTHENTICATORS_ALLOWED, Authenticators.BIOMETRIC_STRONG);
    final int biometricStrength = authenticators & Authenticators.BIOMETRIC_WEAK;
    if ((biometricStrength & ~Authenticators.BIOMETRIC_STRONG) != 0) {
        throw new IllegalArgumentException(""Only Strong biometrics supported with crypto"");
    }
    authenticateInternal(crypto, cancel, executor, callback, mContext.getUserId());
}",1,"/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)}, or when the user
 * dismisses the system-provided dialog, at which point the crypto object becomes invalid. This
 * operation can be canceled by using the provided cancel object. The application will receive
 * authentication errors through {@link AuthenticationCallback}, and button events through the
 * corresponding callback set in {@link Builder#setNegativeButton(CharSequence, Executor,
 * DialogInterface.OnClickListener)}. It is safe to reuse the {@link BiometricPrompt} object,
 * and calling {@link BiometricPrompt#authenticate( CancellationSignal, Executor,
 * AuthenticationCallback)} while an existing authentication attempt is occurring will stop the
 * previous client and start a new authentication. The interrupted client will receive a
 * cancelled notification through {@link AuthenticationCallback#onAuthenticationError(int,
 * CharSequence)}.
 *
 * Note: Applications generally should not cancel and start authentication in quick succession.
 * For example, to properly handle authentication across configuration changes, it's recommended
 * to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so, the
 * application will not need to cancel/restart authentication during the configuration change.
 *
 * @throws IllegalArgumentException If any of the arguments are null
 *
 * @param crypto Object associated with the call
 * @param cancel An object that can be used to cancel authentication
 * @param executor An executor to handle callback events
 * @param callback An object to receive authentication events
 */
","/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)}, or when the user
 * dismisses the system-provided dialog, at which point the crypto object becomes invalid. This
 * operation can be canceled by using the provided cancel object. The application will receive
 * authentication errors through {@link AuthenticationCallback}, and button events through the
 * corresponding callback set in {@link Builder#setNegativeButton(CharSequence, Executor,
 * DialogInterface.OnClickListener)}. It is safe to reuse the {@link BiometricPrompt} object,
 * and calling {@link BiometricPrompt#authenticate(CancellationSignal, Executor,
 * AuthenticationCallback)} while an existing authentication attempt is occurring will stop the
 * previous client and start a new authentication. The interrupted client will receive a
 * cancelled notification through {@link AuthenticationCallback#onAuthenticationError(int,
 * CharSequence)}.
 *
 * <p>Note: Applications generally should not cancel and start authentication in quick
 * succession. For example, to properly handle authentication across configuration changes, it's
 * recommended to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so,
 * the application will not need to cancel/restart authentication during the configuration
 * change.
 *
 * <p>Per the Android CDD, only biometric authenticators that meet or exceed the requirements
 * for <strong>Strong</strong> are permitted to integrate with Keystore to perform related
 * cryptographic operations. Therefore, it is an error to call this method after explicitly
 * calling {@link Builder#setAllowedAuthenticators(int)} with any biometric strength other than
 * {@link Authenticators#BIOMETRIC_STRONG}.
 *
 * @throws IllegalArgumentException If any argument is null, or if the allowed biometric
 * authenticator strength is explicitly set to {@link Authenticators#BIOMETRIC_WEAK}. Prior to
 * {@link android.os.Build.VERSION_CODES#R}, this exception is also thrown if
 * {@link Builder#setDeviceCredentialAllowed(boolean)} was explicitly set to true.
 *
 * @param crypto A cryptographic operation to be unlocked after successful authentication.
 * @param cancel An object that can be used to cancel authentication.
 * @param executor An executor to handle callback events.
 * @param callback An object to receive authentication events.
 */
",-1,[@RequiresPermission(USE_BIOMETRIC)],[@RequiresPermission(USE_BIOMETRIC)],-1,-1,-1,-1,-1,-1,"2,3,5",2,"The control dependency has changed due to the alteration in the conditional checks for the biometric strength. In addition, there is a new exception handling statement introduced with an updated error message, and also the dependent API authenticateInternal has one fewer parameter in the late implementation. Therefore, the changes are classified as 2 for exception handling, 3 for control dependency, and 5 for the change in the dependent API.","There is a potential Compatibility Issue caused by different exception handlings. The addition of a condition that throws an exception when non-Strong biometrics are set with crypto means that the late version of the API could throw an exception in a scenario where the early version would not, thus the CI type is 2."
430,"<android.text.format.Time: int getJulianDay(long,long)>",29,30,"<android.text.format.Time: int getJulianDay(long,long)>","<android.text.format.Time: int getJulianDay(long,long)>",0,"{
    long offsetMillis = gmtoff * 1000;
    long julianDay = (millis + offsetMillis) / DateUtils.DAY_IN_MILLIS;
    return (int) julianDay + EPOCH_JULIAN_DAY;
}","{
    long offsetMillis = gmtoffSeconds * 1000;
    long adjustedMillis = millis + offsetMillis;
    long julianDay = adjustedMillis / DateUtils.DAY_IN_MILLIS;
    // Negative adjustedMillis values must round towards Integer.MIN_VALUE.
    if (adjustedMillis < 0 && adjustedMillis % DateUtils.DAY_IN_MILLIS != 0) {
        julianDay--;
    }
    return (int) (julianDay + EPOCH_JULIAN_DAY);
}",1,"/**
 * Computes the Julian day number for a point in time in a particular
 * timezone. The Julian day for a given date is the same for every
 * timezone. For example, the Julian day for July 1, 2008 is 2454649.
 *
 * <p>Callers must pass the time in UTC millisecond (as can be returned
 * by {@link #toMillis(boolean)} or {@link #normalize(boolean)})
 * and the offset from UTC of the timezone in seconds (as might be in
 * {@link #gmtoff}).
 *
 * <p>The Julian day is useful for testing if two events occur on the
 * same calendar date and for determining the relative time of an event
 * from the present (""yesterday"", ""3 days ago"", etc.).
 *
 * @param millis the time in UTC milliseconds
 * @param gmtoff the offset from UTC in seconds
 * @return the Julian day
 */
","/**
 * Computes the Julian day number for a point in time in a particular
 * timezone. The Julian day for a given calendar date is the same for
 * every timezone. For example, the Julian day for July 1, 2008 is
 * 2454649.
 *
 * <p>Callers must pass the time in UTC millisecond (as can be returned
 * by {@link #toMillis(boolean)} or {@link #normalize(boolean)})
 * and the offset from UTC of the timezone in seconds at that time (as
 * might be in {@link #gmtoff}).
 *
 * <p>The Julian day is useful for testing if two events occur on the
 * same calendar date and for determining the relative time of an event
 * from the present (""yesterday"", ""3 days ago"", etc.).
 *
 * @param millis the time in UTC milliseconds
 * @param gmtoffSeconds the offset from UTC in seconds
 * @return the Julian day
 * @deprecated Use {@link java.time.temporal.JulianFields#JULIAN_DAY} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation added a new variable `adjustedMillis`, altered the multiplication variable's name from `gmtoff` to `gmtoffSeconds`, included an additional conditional block to modify the `julianDay` value, and changed the computation and condition in the late version. Besides, a variable declaration `long adjustedMillis` was added, a new control statement `if` was introduced to adjust the value of `julianDay` under certain conditions, and an inline computation was replaced with the variable `adjustedMillis`. Therefore, the code change type is 1,3,4.","The new condition and the modified computation potentially change which integer value is returned. Specifically, a decrement operation (`julianDay--`) is added for certain cases (when `adjustedMillis` is negative and not perfectly divisible by `DateUtils.DAY_IN_MILLIS`), which could yield a returned value that differs from the early version of the API. Also, the modification of `gmtoff` to `gmtoffSeconds` could potentially lead to a different `offsetMillis` if the value represented by them was not simply renamed but carries a different semantic meaning - indicating a potential different return value. Therefore, the CI type is 1."
431,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",29,30,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>","<android.app.ContextImpl: void sendBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method called within the try block has changed from `ActivityManager.getService().broadcastIntent(...)` to `ActivityManager.getService().broadcastIntentWithFeature(...)`. However, there are no signature changes of the current API, so the code modification falls under the category of a dependent API change, which is of code change type 5.","There is no compatibility issue detected as the current method's signature remains the same, and there is no indication that the change in the dependent API method `broadcastIntent` to `broadcastIntentWithFeature` alters the behavior related to return values or exceptions that the `sendBroadcast` method would produce. Thus, the CI type is 0."
432,<android.view.textclassifier.TextClassifier: TextSelection suggestSelection(Request)>,29,30,<android.view.textclassifier.TextClassifier: TextSelection suggestSelection(Request)>,<android.view.textclassifier.TextClassifier: TextSelection suggestSelection(Request)>,0,"{
    Preconditions.checkNotNull(request);
    Utils.checkMainThread();
    return new TextSelection.Builder(request.getStartIndex(), request.getEndIndex()).build();
}","{
    Objects.requireNonNull(request);
    Utils.checkMainThread();
    return new TextSelection.Builder(request.getStartIndex(), request.getEndIndex()).build();
}",1,"/**
 * Returns suggested text selection start and end indices, recognized entity types, and their
 * associated confidence scores. The entity types are ordered from highest to lowest scoring.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * @param request the text selection request
 */
","/**
 * Returns suggested text selection start and end indices, recognized entity types, and their
 * associated confidence scores. The entity types are ordered from highest to lowest scoring.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * @param request the text selection request
 */
",-1,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"The code change is only in the null-checking method used, from `Preconditions.checkNotNull(request)` to `Objects.requireNonNull(request)`, which won't affect the behavior because both serve the same purpose of throwing a NullPointerException if 'request' is null. So the code change type is 4.","No Compatibility Issue could arise from this change because it doesn't affect the outcome of the method - it still throws the same exception if 'request' is null, and the result of 'new TextSelection.Builder(request.getStartIndex(), request.getEndIndex()).build()' remains the same."
434,<android.view.contentcapture.ContentCaptureManager: Set<ContentCaptureCondition> getContentCaptureConditions()>,29,30,<android.view.contentcapture.ContentCaptureManager: Set<ContentCaptureCondition> getContentCaptureConditions()>,<android.view.contentcapture.ContentCaptureManager: Set<ContentCaptureCondition> getContentCaptureConditions()>,0,"{
    // the service to fine tune how long-lived apps (like browsers) are whitelisted.
    if (!isContentCaptureEnabled() && !mOptions.lite)
        return null;
    final SyncResultReceiver resultReceiver = syncRun((r) -> mService.getContentCaptureConditions(mContext.getPackageName(), r));
    final ArrayList<ContentCaptureCondition> result = resultReceiver.getParcelableListResult();
    return toSet(result);
}","{
    // the service to fine tune how long-lived apps (like browsers) are whitelisted.
    if (!isContentCaptureEnabled() && !mOptions.lite)
        return null;
    final SyncResultReceiver resultReceiver = syncRun((r) -> mService.getContentCaptureConditions(mContext.getPackageName(), r));
    try {
        final ArrayList<ContentCaptureCondition> result = resultReceiver.getParcelableListResult();
        return toSet(result);
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get content capture conditions."");
    }
}",1,"/**
 * Gets the list of conditions for when content capture should be allowed.
 *
 * <p>This method is typically used by web browsers so they don't generate unnecessary content
 * capture events for some websites.
 *
 * @return list of conditions, or {@code null} if there isn't any restriction
 * (in which case content capture events should always be generated). If the list is empty,
 * then it should not generate any event at all.
 */
","/**
 * Gets the list of conditions for when content capture should be allowed.
 *
 * <p>This method is typically used by web browsers so they don't generate unnecessary content
 * capture events for websites the content capture service is not interested on.
 *
 * @return list of conditions, or {@code null} if the service didn't set any restriction
 * (in which case content capture events should always be generated). If the list is empty,
 * then it should not generate any event at all.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has been introduced in the late version, specifically a try-catch block wrapping the call to resultReceiver.getParcelableListResult() and throwing a new RuntimeException in the catch block. This change type is 2.","The introduction of a new catch block that throws a new RuntimeException can lead to a different exception being thrown by the method in case of a SyncResultReceiver.TimeoutException. Therefore, the CI type is 2."
435,<android.content.IntentFilter.AuthorityEntry: int match(Uri)>,29,30,<android.content.IntentFilter.AuthorityEntry: int match(Uri)>,<android.content.IntentFilter.AuthorityEntry: int match(Uri)>,0,"{
    String host = data.getHost();
    if (host == null) {
        return NO_MATCH_DATA;
    }
    if (false)
        Log.v(""IntentFilter"", ""Match host "" + host + "": "" + mHost);
    if (mWild) {
        if (host.length() < mHost.length()) {
            return NO_MATCH_DATA;
        }
        host = host.substring(host.length() - mHost.length());
    }
    if (host.compareToIgnoreCase(mHost) != 0) {
        return NO_MATCH_DATA;
    }
    if (mPort >= 0) {
        if (mPort != data.getPort()) {
            return NO_MATCH_DATA;
        }
        return MATCH_CATEGORY_PORT;
    }
    return MATCH_CATEGORY_HOST;
}","{
    return match(data, false);
}",1,"/**
 * Determine whether this AuthorityEntry matches the given data Uri.
 * <em>Note that this comparison is case-sensitive, unlike formal
 * RFC host names.  You thus should always normalize to lower-case.</em>
 *
 * @param data The Uri to match.
 * @return Returns either {@link IntentFilter#NO_MATCH_DATA},
 * {@link IntentFilter#MATCH_CATEGORY_PORT}, or
 * {@link IntentFilter#MATCH_CATEGORY_HOST}.
 */
","/**
 * Determine whether this AuthorityEntry matches the given data Uri.
 * <em>Note that this comparison is case-sensitive, unlike formal
 * RFC host names.  You thus should always normalize to lower-case.</em>
 *
 * @param data The Uri to match.
 * @return Returns either {@link IntentFilter#NO_MATCH_DATA},
 * {@link IntentFilter#MATCH_CATEGORY_PORT}, or
 * {@link IntentFilter#MATCH_CATEGORY_HOST}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The late version of the implementation calls another method match(data, false) instead of the inline implementation present in the early version. This indicates a change in the dependent API; therefore, the code change type is 5.","As the code change indicates that another method is being called with the same data being passed, and without any context to suggest that the behavior of match(data, false) has changed between the versions, there is no information available to conclude that it would produce different behavior. Therefore, we classify it as no Compatibility Issue, and the CI type is 0."
436,<android.view.textclassifier.TextClassificationConstants: boolean isLocalTextClassifierEnabled()>,29,30,<android.view.textclassifier.TextClassificationConstants: boolean isLocalTextClassifierEnabled()>,<android.view.textclassifier.TextClassificationConstants: boolean isLocalTextClassifierEnabled()>,0,"{
    return mConfigParser.getBoolean(LOCAL_TEXT_CLASSIFIER_ENABLED, LOCAL_TEXT_CLASSIFIER_ENABLED_DEFAULT);
}","{
    return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_TEXTCLASSIFIER, LOCAL_TEXT_CLASSIFIER_ENABLED, LOCAL_TEXT_CLASSIFIER_ENABLED_DEFAULT);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The API implementation previously used mConfigParser.getBoolean has been changed to use DeviceConfig.getBoolean with different parameters including a namespace. This suggests that the API now relies on a different mechanism to obtain the boolean value, hence the Dependent API has changed.","Since the mechanism by which the value is obtained has changed, the returned value of isLocalTextClassifierEnabled() may be different even with the same configuration because it reads from a potentially different source. This can lead to a Compatibility Issue caused by the potential for different return values."
437,"<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>",29,30,"<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>","<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>",0,"{
    synchronized (this) {
        ensureValidLocked();
        final TypedValue outValue = mValue;
        final int cookie = nativeGetResourceBagValue(mObject, resId, bagEntryId, outValue);
        if (cookie <= 0) {
            return null;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            return mApkAssets[cookie - 1].getStringFromPool(outValue.data);
        }
        return outValue.coerceToString();
    }
}","{
    synchronized (this) {
        ensureValidLocked();
        final TypedValue outValue = mValue;
        final int cookie = nativeGetResourceBagValue(mObject, resId, bagEntryId, outValue);
        if (cookie <= 0) {
            return null;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            return getPooledStringForCookie(cookie, outValue.data);
        }
        return outValue.coerceToString();
    }
}",1,"/**
 * Retrieves the string value associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param bagEntryId the index into the bag to load
 * @return the string value, or {@code null}
 */
","/**
 * Retrieves the string value associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param bagEntryId the index into the bag to load
 * @return the string value, or {@code null}
 */
",-1,"[@UnsupportedAppUsage, @Nullable]","[@UnsupportedAppUsage, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method used for obtaining a string from the pool has been altered from mApkAssets[cookie - 1].getStringFromPool(outValue.data) to getPooledStringForCookie(cookie, outValue.data), which indicates a change in the dependent API, hence the change type is 1,5.","The alteration in how strings are retrieved from the pool could result in different values being returned. This change is directly related to the return value of the method, implicating a CI of type 1."
438,<android.view.textclassifier.TextClassificationSessionId: int hashCode()>,29,30,<android.view.textclassifier.TextClassificationSessionId: int hashCode()>,<android.view.textclassifier.TextClassificationSessionId: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + mValue.hashCode();
    return result;
}","{
    return Objects.hash(mValue, mToken);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashing algorithm changes from manual multiplication and addition to using `Objects.hash`, and it now also includes `mToken` in the hash calculation. There is a change in how the return value is computed, so the code change types are 1 for return statement and 4 for other statement changed.","Because the hashing algorithm has changed and an additional field `mToken` is now part of the hash calculation, the API could return a different value when invoked; hence, the CI type is 1."
439,<android.content.pm.ShortcutInfo.Builder: Builder setPersons(Person[])>,29,30,<android.content.pm.ShortcutInfo.Builder: Builder setPersons(Person[])>,<android.content.pm.ShortcutInfo.Builder: Builder setPersons(Person[])>,0,"{
    Preconditions.checkNotNull(persons, ""persons cannot be null"");
    Preconditions.checkNotNull(persons.length, ""persons cannot be empty"");
    for (Person person : persons) {
        Preconditions.checkNotNull(person, ""persons cannot contain null"");
    }
    mPersons = clonePersons(persons);
    return this;
}","{
    Objects.requireNonNull(persons, ""persons cannot be null"");
    Objects.requireNonNull(persons.length, ""persons cannot be empty"");
    for (Person person : persons) {
        Objects.requireNonNull(person, ""persons cannot contain null"");
    }
    mPersons = clonePersons(persons);
    return this;
}",1,"/**
 * Sets multiple persons instead of a single person.
 *
 * @see Person
 * @see #setPerson(Person)
 */
","/**
 * Sets multiple persons instead of a single person.
 *
 * @see Person
 * @see #setPerson(Person)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The change is from using Preconditions.checkNotNull to Objects.requireNonNull for input validation. These methods are interchangeable for the purpose of null checking, so the dependent API changed, which is represented by the code change type 5.","There is no Compatibility Issue since the change does not affect the behavior of the API. Both methods throw a NullPointerException if the checked value is null, therefore the functionality remains consistent between the two versions."
441,"<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>",29,30,"<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>","<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>",0,"{
    if (view == null || cursorAnchorInfo == null) {
        return;
    }
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursorAnchorInfo(view, cursorAnchorInfo);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        // If immediate bit is set, we will call updateCursorAnchorInfo() even when the data has
        // not been changed from the previous call.
        final boolean isImmediate = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_IMMEDIATE) != 0;
        if (!isImmediate && Objects.equals(mCursorAnchorInfo, cursorAnchorInfo)) {
            // calls of this method from android.widget.Editor.
            if (DEBUG) {
                Log.w(TAG, ""Ignoring redundant updateCursorAnchorInfo: info="" + cursorAnchorInfo);
            }
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""updateCursorAnchorInfo: "" + cursorAnchorInfo);
        try {
            if (mActivityViewToScreenMatrix != null) {
                mCurMethod.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(cursorAnchorInfo, mActivityViewToScreenMatrix));
            } else {
                mCurMethod.updateCursorAnchorInfo(cursorAnchorInfo);
            }
            mCursorAnchorInfo = cursorAnchorInfo;
            // Clear immediate bit (if any).
            mRequestUpdateCursorAnchorInfoMonitorMode &= ~InputConnection.CURSOR_UPDATE_IMMEDIATE;
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    if (view == null || cursorAnchorInfo == null) {
        return;
    }
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursorAnchorInfo(view, cursorAnchorInfo);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        // If immediate bit is set, we will call updateCursorAnchorInfo() even when the data has
        // not been changed from the previous call.
        final boolean isImmediate = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_IMMEDIATE) != 0;
        if (!isImmediate && Objects.equals(mCursorAnchorInfo, cursorAnchorInfo)) {
            // calls of this method from android.widget.Editor.
            if (DEBUG) {
                Log.w(TAG, ""Ignoring redundant updateCursorAnchorInfo: info="" + cursorAnchorInfo);
            }
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""updateCursorAnchorInfo: "" + cursorAnchorInfo);
        try {
            if (mActivityViewToScreenMatrix != null) {
                mCurMethod.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(cursorAnchorInfo, mActivityViewToScreenMatrix));
            } else {
                mCurMethod.updateCursorAnchorInfo(cursorAnchorInfo);
            }
            mCursorAnchorInfo = cursorAnchorInfo;
            // Clear immediate bit (if any).
            mRequestUpdateCursorAnchorInfoMonitorMode &= ~InputConnection.CURSOR_UPDATE_IMMEDIATE;
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}",1,"/**
 * Report positional change of the text insertion point and/or characters in the composition
 * string.
 */
","/**
 * Report positional change of the text insertion point and/or characters in the composition
 * string.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition within the 'if' statement has been altered. The early version uses a complex check involving mServedView and checkInputConnectionProxy, while the late version uses the method hasServedByInputMethodLocked. This change qualifies as a control dependency change, type 3.","Despite the control flow change within the 'if' statement, there is no indication that the method's behavior in terms of what it returns or the exceptions it throws has changed. Both versions return nothing (void) and do not introduce any new exceptions or change the exception handling. Thus, there is no Compatibility Issue, type 0."
442,<android.util.ArraySet: E removeAt(int)>,29,30,<android.util.ArraySet: E removeAt(int)>,<android.util.ArraySet: E removeAt(int)>,0,"{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        clear();
    } else {
        if (shouldShrink()) {
            // Shrunk enough to reduce size of arrays.
            final int n = getNewShrunkenSize();
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                }
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                }
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    final int oSize = mSize;
    final Object old = mArray[index];
    if (oSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        clear();
    } else {
        final int nSize = oSize - 1;
        if (shouldShrink()) {
            // Shrunk enough to reduce size of arrays.
            final int n = getNewShrunkenSize();
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < nSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + nSize + "" to "" + index);
                }
                System.arraycopy(ohashes, index + 1, mHashes, index, nSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, nSize - index);
            }
        } else {
            if (index < nSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + nSize + "" to "" + index);
                }
                System.arraycopy(mHashes, index + 1, mHashes, index, nSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, nSize - index);
            }
            mArray[nSize] = null;
        }
        if (oSize != mSize) {
            throw new ConcurrentModificationException();
        }
        mSize = nSize;
    }
    return (E) old;
}",1,"/**
 * Remove the key/value mapping at the given index.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 *
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
","/**
 * Remove the key/value mapping at the given index.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 *
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","In the late version, there has been a new local variable oSize introduced to keep track of the original size and the way how mSize is updated has changed. Also, the late version introduces 'ConcurrentModificationException' when the original and the current size do not match, marking an exception handling statement change. Finally, the control dependency is altered as the condition for when to set the last element of mArray to null has changed from mSize-- to mSize = nSize; representing other statement changes. So, the change types are 1,3,4.","Changes in how the mSize variable is manipulated in the late implementation and the addition of a new exception 'ConcurrentModificationException' being thrown introduce the potential for different return values and different exception handlings. Therefore, the CI types are 1,2."
443,"<android.database.sqlite.SQLiteQueryBuilder: int delete(SQLiteDatabase,String,String[])>",29,30,"<android.database.sqlite.SQLiteQueryBuilder: int delete(SQLiteDatabase,String,String[])>","<android.database.sqlite.SQLiteQueryBuilder: int delete(SQLiteDatabase,String,String[])>",0,"{
    Objects.requireNonNull(mTables, ""No tables defined"");
    Objects.requireNonNull(db, ""No database defined"");
    final String sql;
    final String unwrappedSql = buildDelete(selection);
    if (mStrict) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        // NOTE: The ordering of the below operations is important; we must
        // execute the wrapped query to ensure the untrusted clause has been
        // fully isolated.
        // Validate the unwrapped query
        // will throw if query is invalid
        db.validateSql(unwrappedSql, null);
        // Execute wrapped query for extra protection
        final String wrappedSql = buildDelete(wrap(selection));
        sql = wrappedSql;
    } else {
        // Execute unwrapped query
        sql = unwrappedSql;
    }
    final String[] sqlArgs = selectionArgs;
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        if (Build.IS_DEBUGGABLE) {
            Log.d(TAG, sql + "" with args "" + Arrays.toString(sqlArgs));
        } else {
            Log.d(TAG, sql);
        }
    }
    return db.executeSql(sql, sqlArgs);
}","{
    Objects.requireNonNull(mTables, ""No tables defined"");
    Objects.requireNonNull(db, ""No database defined"");
    final String sql;
    final String unwrappedSql = buildDelete(selection);
    if (isStrictGrammar()) {
        enforceStrictGrammar(selection, null, null, null, null);
    }
    if (isStrict()) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        // NOTE: The ordering of the below operations is important; we must
        // execute the wrapped query to ensure the untrusted clause has been
        // fully isolated.
        // Validate the unwrapped query
        // will throw if query is invalid
        db.validateSql(unwrappedSql, null);
        // Execute wrapped query for extra protection
        final String wrappedSql = buildDelete(wrap(selection));
        sql = wrappedSql;
    } else {
        // Execute unwrapped query
        sql = unwrappedSql;
    }
    final String[] sqlArgs = selectionArgs;
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        if (Build.IS_DEBUGGABLE) {
            Log.d(TAG, sql + "" with args "" + Arrays.toString(sqlArgs));
        } else {
            Log.d(TAG, sql);
        }
    }
    return DatabaseUtils.executeUpdateDelete(db, sql, sqlArgs);
}",1,"/**
 * Perform a delete by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to delete on
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL {@code WHERE} clause (excluding the {@code WHERE}
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @return the number of rows deleted
 */
","/**
 * Perform a delete by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to delete on
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL {@code WHERE} clause (excluding the {@code WHERE}
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @return the number of rows deleted
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"One of the dependent APIs has changed from db.executeSql(sql, sqlArgs) to DatabaseUtils.executeUpdateDelete(db, sql, sqlArgs), which is a different method call. There is also the removal of the if condition that checks mStrict and the addition of enforcing strict grammar with the method call enforceStrictGrammar(selection, null, null, null, null), which doesn't appear to affect the control flow directly. Hence, the code change types are 4 (Other statement changed) and 5 (Dependent API changed).","The change in the dependent API from calling executeSql to calling updateExecuteDelete could potentially lead to different behavior. Specifically, the updateExecuteDelete method might have different implementation details or side effects that could impact the return value or throw different exceptions, thus there is a CI type 1 caused by a potential different return value."
444,"<android.app.slice.Slice.Builder: Builder addSubSlice(Slice,String)>",29,30,"<android.app.slice.Slice.Builder: Builder addSubSlice(Slice,String)>","<android.app.slice.Slice.Builder: Builder addSubSlice(Slice,String)>",0,"{
    Preconditions.checkNotNull(slice);
    mItems.add(new SliceItem(slice, SliceItem.FORMAT_SLICE, subType, slice.getHints().toArray(new String[slice.getHints().size()])));
    return this;
}","{
    Objects.requireNonNull(slice);
    mItems.add(new SliceItem(slice, SliceItem.FORMAT_SLICE, subType, slice.getHints().toArray(new String[slice.getHints().size()])));
    return this;
}",1,"/**
 * Add a sub-slice to the slice being constructed
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
","/**
 * Add a sub-slice to the slice being constructed
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is from using Preconditions.checkNotNull(slice) to Objects.requireNonNull(slice), which are equivalent ways to check for a non-null reference. This is classified as other statement changed (type 4).",There is no Compatibility Issue since both statements serve the same purpose of null-checking and will result in the same behavior (throwing a NullPointerException if the 'slice' is null). The change does not affect the return value or the exceptions that this method can throw.
445,"<android.util.Half: boolean greater(short,short)>",29,30,"<android.util.Half: boolean greater(short,short)>","<android.util.Half: boolean greater(short,short)>",0,"{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) > ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff);
}","{
    return FP16.greater(x, y);
}",1,"/**
 * Returns true if the first half-precision float value is greater (larger
 * toward positive infinity) than the second half-precision float value.
 * If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is greater than y, false otherwise
 */
","/**
 * Returns true if the first half-precision float value is greater (larger
 * toward positive infinity) than the second half-precision float value.
 * If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is greater than y, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation in the later version replaces the entire logic of the method body with a single call to FP16.greater(x, y), so the method relies on the dependent API, which is signified as change type 4,5.","The change fully replaces the inner logic of the method with a call to a dependent API, which indicates that the behavior could potentially be different, especially if the new FP16.greater(x, y) behaves differently from the logic defined in the early version. Thus, the CI type is 1."
446,"<android.view.inputmethod.InputMethodManager: boolean hideSoftInputFromWindow(IBinder,int,ResultReceiver)>",29,30,"<android.view.inputmethod.InputMethodManager: boolean hideSoftInputFromWindow(IBinder,int,ResultReceiver)>","<android.view.inputmethod.InputMethodManager: boolean hideSoftInputFromWindow(IBinder,int,ResultReceiver)>",0,"{
    checkFocus();
    synchronized (mH) {
        if (mServedView == null || mServedView.getWindowToken() != windowToken) {
            return false;
        }
        try {
            return mService.hideSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    checkFocus();
    synchronized (mH) {
        final View servedView = getServedViewLocked();
        if (servedView == null || servedView.getWindowToken() != windowToken) {
            return false;
        }
        try {
            return mService.hideSoftInput(mClient, windowToken, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Request to hide the soft input window from the context of the window
 * that is currently accepting input.  This should be called as a result
 * of the user doing some actually than fairly explicitly requests to
 * have the input window hidden.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
","/**
 * Request to hide the soft input window from the context of the window
 * that is currently accepting input.  This should be called as a result
 * of the user doing some actually than fairly explicitly requests to
 * have the input window hidden.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed to use a new method getServedViewLocked() instead of directly accessing mServedView, and an additional argument windowToken was added to the call to mService.hideSoftInput. This change is classified as 4 (Other statement changed) and 5 (Dependent API changed).","These changes should not cause any Compatibility Issues because they do not affect the behavior of the method from the perspective of the caller. The change to getServedViewLocked() is an internal change that presumably returns the same value as directly accessing mServedView would have done. The addition of windowToken does not change the method behavior because the same windowToken was already compared to the window token of mServedView in the condition check and it was part of the method signature that callers use. Therefore, it is likely that the same value that was passed to the method is now just also passed along to mService.hideSoftInput, which suggests that externally, the method's behavior remains consistent. Thus, the Compatibility Issue type is 0 (No Compatibility Issue)."
448,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,0,"{
    synchronized (mInterfaceLock) {
        if (mClosing.getAndSet(true)) {
            return;
        }
        if (mRemoteDevice != null) {
            mRemoteDevice.disconnect();
            mRemoteDevice.unlinkToDeath(this, /*flags*/
            0);
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceExecutor.execute(mCallOnClosed);
        }
        mRemoteDevice = null;
    }
}","{
    synchronized (mInterfaceLock) {
        if (mClosing.getAndSet(true)) {
            return;
        }
        if (mOfflineSwitchService != null) {
            mOfflineSwitchService.shutdownNow();
            mOfflineSwitchService = null;
        }
        if (mRemoteDevice != null) {
            mRemoteDevice.disconnect();
            mRemoteDevice.unlinkToDeath(this, /*flags*/
            0);
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceExecutor.execute(mCallOnClosed);
        }
        mRemoteDevice = null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new block of code is added to check and execute operations related to mOfflineSwitchService. This is additional logic before the existing conditions but doesn't fall under the categories of return statement, exception handling statement, control dependency change, or dependent API change, hence it is classified as 4.","The new code block regarding mOfflineSwitchService doesn't affect the return value, nor does it introduce new exception handling that would be visible to the caller (it's an internal shutdown procedure). Consequently, there is no compatibility issue arising from this code change, hence the CI type is 0."
449,<android.bluetooth.BluetoothDevice: boolean createBond()>,29,30,<android.bluetooth.BluetoothDevice: boolean createBond()>,<android.bluetooth.BluetoothDevice: boolean createBond()>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot create bond to Remote Device"");
        return false;
    }
    try {
        Log.i(TAG, ""createBond() for device "" + getAddress() + "" called by pid: "" + Process.myPid() + "" tid: "" + Process.myTid());
        return service.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    return createBond(TRANSPORT_AUTO);
}",1,"/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 *
 * @return false on immediate error, true if bonding will begin
 */
","/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 *
 * @return false on immediate error, true if bonding will begin
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,"4,5",1,"The entire method body has changed to a single return statement with a dependent API call createBond(TRANSPORT_AUTO), so the code change type is 4,5.","Since the method now delegates to a different internal method implementation (createBond with TRANSPORT_AUTO argument), which changes how the method behaves (previously logic within the method now inside the called method), there is a potential different return value. Therefore, CI type is 1."
450,<android.os.Build: List<Partition> getFingerprintedPartitions()>,29,30,<android.os.Build: List<Partition> getFingerprintedPartitions()>,<android.os.Build: List<Partition> getFingerprintedPartitions()>,0,"{
    ArrayList<Partition> partitions = new ArrayList();
    String[] names = new String[] { ""bootimage"", ""odm"", ""product"", ""product_services"", Partition.PARTITION_NAME_SYSTEM, ""vendor"" };
    for (String name : names) {
        String fingerprint = SystemProperties.get(""ro."" + name + "".build.fingerprint"");
        if (TextUtils.isEmpty(fingerprint)) {
            continue;
        }
        long time = getLong(""ro."" + name + "".build.date.utc"") * 1000;
        partitions.add(new Partition(name, fingerprint, time));
    }
    return partitions;
}","{
    ArrayList<Partition> partitions = new ArrayList();
    String[] names = new String[] { ""bootimage"", ""odm"", ""product"", ""system_ext"", Partition.PARTITION_NAME_SYSTEM, ""vendor"" };
    for (String name : names) {
        String fingerprint = SystemProperties.get(""ro."" + name + "".build.fingerprint"");
        if (TextUtils.isEmpty(fingerprint)) {
            continue;
        }
        long time = getLong(""ro."" + name + "".build.date.utc"") * 1000;
        partitions.add(new Partition(name, fingerprint, time));
    }
    return partitions;
}",1,"/**
 * Get build information about partitions that have a separate fingerprint defined.
 *
 * The list includes partitions that are suitable candidates for over-the-air updates. This is
 * not an exhaustive list of partitions on the device.
 */
","/**
 * Get build information about partitions that have a separate fingerprint defined.
 *
 * The list includes partitions that are suitable candidates for over-the-air updates. This is
 * not an exhaustive list of partitions on the device.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"There's a change in the content of the 'names' array, specifically the substitution of ""product_services"" with ""system_ext"". However, since the 'names' array is used internally to loop through and fetch properties, this is not a change in the control flow or method signature but rather an internal implementation detail change, hence the code change type is 4.","This change does not lead to a Compatibility Issue since it does not affect how the method behaves from a caller's perspective – it will still return a list of partitions with their corresponding fingerprints and build dates. The partitions queried may differ, but that is a consequence of the device configuration and not the API's compatibility."
451,"<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>",29,30,"<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>","<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>",0,"{
    dest.writeInt(mUserId);
    dest.writeString(mId);
    dest.writeString(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    dest.writeInt(mDisabledReason);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString(mBitmapPath);
    dest.writeString(mIconResName);
    dest.writeString(mTitleResName);
    dest.writeString(mTextResName);
    dest.writeString(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeParcelableArray(mPersons, flags);
    dest.writeParcelable(mLocusId, flags);
}","{
    dest.writeInt(mUserId);
    dest.writeString8(mId);
    dest.writeString8(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    dest.writeInt(mDisabledReason);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString8(mBitmapPath);
    dest.writeString8(mIconResName);
    dest.writeString8(mTitleResName);
    dest.writeString8(mTextResName);
    dest.writeString8(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString8(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeParcelableArray(mPersons, flags);
    dest.writeParcelable(mLocusId, flags);
    dest.writeString8(mIconUri);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method writeToParcel has changed how strings are written to the Parcel object: instead of the method writeString, it now uses writeString8 for all string writes. In addition, there is an added field in the late implementation (mIconUri) that is written to the Parcel which does not exist in the early one. Thus the code changes include modifications to method calls and additional data writing, which classify as 4,5.","The change from writeString to writeString8 implies a modification in how strings are written to the Parcel, which could potentially lead to a different format or encoding that the receiver of the Parcel object might not expect, thus causing a compatibility issue of different return values (in this case, the parcel content). Additionally, writing the new field mIconUri in the late version that the early version does not write will also change the data structure in the Parcel. Both of these changes qualify as a CI with the type 1."
453,"<android.content.ContentProviderClient: boolean refresh(Uri,Bundle,CancellationSignal)>",29,30,"<android.content.ContentProviderClient: boolean refresh(Uri,Bundle,CancellationSignal)>","<android.content.ContentProviderClient: boolean refresh(Uri,Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.refresh(mPackageName, url, args, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#refresh}
 */
","/**
 * See {@link ContentProvider#refresh}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method Preconditions.checkNotNull(url, ""url"") in the early version has been replaced by Objects.requireNonNull(url, ""url"") in the late version, which is considered an 'Other statement changed' (code change type 4), but this change will not affect the behavior as both methods serve the same purpose.",
454,<android.app.admin.DevicePolicyManager: boolean getScreenCaptureDisabled(ComponentName)>,29,30,<android.app.admin.DevicePolicyManager: boolean getScreenCaptureDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getScreenCaptureDisabled(ComponentName)>,0,"{
    throwIfParentInstance(""getScreenCaptureDisabled"");
    return getScreenCaptureDisabled(admin, myUserId());
}","{
    return getScreenCaptureDisabled(admin, myUserId());
}",1,"/**
 * Determine whether or not screen capture has been disabled by the calling
 * admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled screen capture.
 */
","/**
 * Determine whether or not screen capture has been disabled by the calling
 * admin, if specified, or all admins.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance,
 * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be
 * the profile owner of an organization-owned managed profile (the calling admin must be
 * specified).
 *
 * @param admin The name of the admin component to check, or {@code null} to check whether any
 * admins have disabled screen capture.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is a deletion of an exception handling statement (throwIfParentInstance(""getScreenCaptureDisabled"");), which qualifies as a change type 2. Additionally, since it is a removal of a throw statement without altering any other part of the code, it could also be considered an ""other statement changed,"" hence change type 4.","The early version of the method could potentially throw an exception due to throwIfParentInstance(""getScreenCaptureDisabled""), which has been removed in the late version. Consequently, the late version of the API does not throw this exception, which could lead to different behavior if clients relied on catching this specific exception. Therefore, there is a Compatibility Issue due to different exception handlings, classified as type 2."
455,"<android.app.slice.Slice.Builder: Builder addAction(PendingIntent,Slice,String)>",29,30,"<android.app.slice.Slice.Builder: Builder addAction(PendingIntent,Slice,String)>","<android.app.slice.Slice.Builder: Builder addAction(PendingIntent,Slice,String)>",0,"{
    Preconditions.checkNotNull(action);
    Preconditions.checkNotNull(s);
    List<String> hints = s.getHints();
    s.mSpec = null;
    mItems.add(new SliceItem(action, s, SliceItem.FORMAT_ACTION, subType, hints.toArray(new String[hints.size()])));
    return this;
}","{
    Objects.requireNonNull(action);
    Objects.requireNonNull(s);
    List<String> hints = s.getHints();
    s.mSpec = null;
    mItems.add(new SliceItem(action, s, SliceItem.FORMAT_ACTION, subType, hints.toArray(new String[hints.size()])));
    return this;
}",1,"/**
 * Add an action to the slice being constructed
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
","/**
 * Add an action to the slice being constructed
 * @param subType Optional template-specific type information
 * @see SliceItem#getSubType()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The internal implementation has changed from using Preconditions.checkNotNull() to Objects.requireNonNull() for parameter checks. However, both methods serve the same purpose and throw the same type of exception, so the functional behavior remains the same. This is classified as other statement changed.",No Compatibility Issue because the methods Preconditions.checkNotNull() and Objects.requireNonNull() are semantically equivalent in terms of their behavior and the type of exception they throw.
457,<android.util.Half: short halfToShortBits(short)>,29,30,<android.util.Half: short halfToShortBits(short)>,<android.util.Half: short halfToShortBits(short)>,0,"{
    return (h & FP16_COMBINED) > FP16_EXPONENT_MAX ? NaN : h;
}","{
    return (h & FP16.EXPONENT_SIGNIFICAND_MASK) > FP16.POSITIVE_INFINITY ? NaN : h;
}",1,"/**
 * <p>Returns a representation of the specified half-precision float value
 * according to the bit layout described in {@link Half}.</p>
 *
 * <p>Similar to {@link #halfToIntBits(short)}, this method collapses all
 * possible Not-a-Number values to a single canonical Not-a-Number value
 * defined by {@link #NaN}.</p>
 *
 * @param h A half-precision float value
 * @return The bits that represent the half-precision float value
 *
 * @see #halfToIntBits(short)
 */
","/**
 * <p>Returns a representation of the specified half-precision float value
 * according to the bit layout described in {@link Half}.</p>
 *
 * <p>Similar to {@link #halfToIntBits(short)}, this method collapses all
 * possible Not-a-Number values to a single canonical Not-a-Number value
 * defined by {@link #NaN}.</p>
 *
 * @param h A half-precision float value
 * @return The bits that represent the half-precision float value
 *
 * @see #halfToIntBits(short)
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed due to the altered bit mask values (FP16_COMBINED vs FP16.EXPONENT_SIGNIFICAND_MASK) and altered comparison value (FP16_EXPONENT_MAX vs FP16.POSITIVE_INFINITY), thus the change type is 1,5.","Since the returned result is different because of the changed bit mask and threshold values, the late version API could potentially return a different short value. This constitutes a change in the returned variable, so the CI type is 1."
459,<android.accessibilityservice.AccessibilityServiceInfo: String capabilityToString(int)>,29,30,<android.accessibilityservice.AccessibilityServiceInfo: String capabilityToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String capabilityToString(int)>,0,"{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return ""CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT"";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return ""CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION"";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return ""CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS"";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return ""CAPABILITY_CAN_CONTROL_MAGNIFICATION"";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return ""CAPABILITY_CAN_PERFORM_GESTURES"";
        case CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES:
            return ""CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES"";
        default:
            return ""UNKNOWN"";
    }
}","{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return ""CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT"";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return ""CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION"";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return ""CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS"";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return ""CAPABILITY_CAN_CONTROL_MAGNIFICATION"";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return ""CAPABILITY_CAN_PERFORM_GESTURES"";
        case CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES:
            return ""CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES"";
        case CAPABILITY_CAN_TAKE_SCREENSHOT:
            return ""CAPABILITY_CAN_TAKE_SCREENSHOT"";
        default:
            return ""UNKNOWN"";
    }
}",1,"/**
 * Returns the string representation of a capability. For example,
 * {@link #CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT} is represented
 * by the string CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT.
 *
 * @param capability The capability.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a capability. For example,
 * {@link #CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT} is represented
 * by the string CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT.
 *
 * @param capability The capability.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"As there is a new 'case' statement added for CAPABILITY_CAN_TAKE_SCREENSHOT in the switch, this amounts to both control dependency change (a new branch in switch) and a return statement change (a new potential return value).","Due to the addition of a new case option, the API now potentially returns a different value (the new case label), causing a compatibility issue of type 1."
461,<android.view.textclassifier.TextClassificationManager: TextClassifier getTextClassifier()>,29,30,<android.view.textclassifier.TextClassificationManager: TextClassifier getTextClassifier()>,<android.view.textclassifier.TextClassificationManager: TextClassifier getTextClassifier()>,0,"{
    synchronized (mLock) {
        if (mCustomTextClassifier != null) {
            return mCustomTextClassifier;
        } else if (isSystemTextClassifierEnabled()) {
            return getSystemTextClassifier();
        } else {
            return getLocalTextClassifier();
        }
    }
}","{
    synchronized (mLock) {
        if (mCustomTextClassifier != null) {
            return mCustomTextClassifier;
        } else if (getSettings().isSystemTextClassifierEnabled()) {
            return getSystemTextClassifier(SystemTextClassifier.SYSTEM);
        } else {
            return getLocalTextClassifier();
        }
    }
}",1,"/**
 * Returns the text classifier that was set via {@link #setTextClassifier(TextClassifier)}.
 * If this is null, this method returns a default text classifier (i.e. either the system text
 * classifier if one exists, or a local text classifier running in this process.)
 * <p>
 * Note that requests to the TextClassifier may be handled in an OEM-provided process rather
 * than in the calling app's process.
 *
 * @see #setTextClassifier(TextClassifier)
 */
","/**
 * Returns the text classifier that was set via {@link #setTextClassifier(TextClassifier)}.
 * If this is null, this method returns a default text classifier (i.e. either the system text
 * classifier if one exists, or a local text classifier running in this process.)
 * <p>
 * Note that requests to the TextClassifier may be handled in an OEM-provided process rather
 * than in the calling app's process.
 *
 * @see #setTextClassifier(TextClassifier)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,5",1,"The condition ""isSystemTextClassifierEnabled()"" has been replaced with ""getSettings().isSystemTextClassifierEnabled()"", indicating there's a change in how the condition is checked which is a control dependency change. Additionally, the call to ""getSystemTextClassifier()"" now includes an argument ""SystemTextClassifier.SYSTEM"", indicating a change in the dependent API. Therefore, the change is classified as 3 (control dependency change) and 5 (dependent API changed).","The changes to the control dependency and the dependent API could potentially lead to different return values when the late version API is invoked (for example, the change in the settings check could enable the system text classifier in cases where it wouldn't be before, and the system text classifier instance returned could be different due to the new parameter). Therefore, there is a potential Compatibility Issue of type 1, which is caused by potentially different return values."
462,<android.util.TimeUtils: String getTimeZoneDatabaseVersion()>,29,30,<android.util.TimeUtils: String getTimeZoneDatabaseVersion()>,<android.util.TimeUtils: String getTimeZoneDatabaseVersion()>,0,"{
    return ZoneInfoDB.getInstance().getVersion();
}","{
    return ZoneInfoDb.getInstance().getVersion();
}",1,"/**
 * Returns a String indicating the version of the time zone database currently
 * in use.  The format of the string is dependent on the underlying time zone
 * database implementation, but will typically contain the year in which the database
 * was updated plus a letter from a to z indicating changes made within that year.
 *
 * <p>Time zone database updates should be expected to occur periodically due to
 * political and legal changes that cannot be anticipated in advance.  Therefore,
 * when computing the UTC time for a future event, applications should be aware that
 * the results may differ following a time zone database update.  This method allows
 * applications to detect that a database change has occurred, and to recalculate any
 * cached times accordingly.
 *
 * <p>The time zone database may be assumed to change only when the device runtime
 * is restarted.  Therefore, it is not necessary to re-query the database version
 * during the lifetime of an activity.
 */
","/**
 * Returns a String indicating the version of the time zone database currently
 * in use.  The format of the string is dependent on the underlying time zone
 * database implementation, but will typically contain the year in which the database
 * was updated plus a letter from a to z indicating changes made within that year.
 *
 * <p>Time zone database updates should be expected to occur periodically due to
 * political and legal changes that cannot be anticipated in advance.  Therefore,
 * when computing the UTC time for a future event, applications should be aware that
 * the results may differ following a time zone database update.  This method allows
 * applications to detect that a database change has occurred, and to recalculate any
 * cached times accordingly.
 *
 * <p>The time zone database may be assumed to change only when the device runtime
 * is restarted.  Therefore, it is not necessary to re-query the database version
 * during the lifetime of an activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The only change in the late implementation is the change in the case of the method `ZoneInfoDB.getInstance()` to `ZoneInfoDb.getInstance()` which implies a change in the dependent API.,"There is no Compatibility Issue as the behavior of the API has not changed. Only the method name's case has changed, presumably due to a typo correction or a naming convention change in the dependent API. This does not affect the return values or the types, nor does it change the exception handling."
463,<android.service.notification.ZenPolicy: int hashCode()>,29,30,<android.service.notification.ZenPolicy: int hashCode()>,<android.service.notification.ZenPolicy: int hashCode()>,0,"{
    return Objects.hash(mPriorityCategories, mVisualEffects, mPriorityCalls, mPriorityMessages);
}","{
    return Objects.hash(mPriorityCategories, mVisualEffects, mPriorityCalls, mPriorityMessages, mConversationSenders);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The hashCode method changed by adding a new parameter mConversationSenders to the Objects.hash call. This signifies that the late implementation includes an additional field to calculate the hash, which is a change type 1.","Including a new field in the hashCode computation means that objects which previously had the same hash could now have different hashes if the value of mConversationSenders differs. This could lead to different behavior when using these objects in hashed collections, such as HashSet or HashMap. Thus, the change can potentially cause different behavior and is a CI type 1."
464,"<android.widget.TextView: void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo,String,Bundle)>",29,30,"<android.widget.TextView: void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo,String,Bundle)>","<android.widget.TextView: void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo,String,Bundle)>",0,"{
    // The only extra data we support requires arguments.
    if (arguments == null) {
        return;
    }
    if (extraDataKey.equals(EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY)) {
        int positionInfoStartIndex = arguments.getInt(EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_START_INDEX, -1);
        int positionInfoLength = arguments.getInt(EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_LENGTH, -1);
        if ((positionInfoLength <= 0) || (positionInfoStartIndex < 0) || (positionInfoStartIndex >= mText.length())) {
            Log.e(LOG_TAG, ""Invalid arguments for accessibility character locations"");
            return;
        }
        RectF[] boundingRects = new RectF[positionInfoLength];
        final CursorAnchorInfo.Builder builder = new CursorAnchorInfo.Builder();
        populateCharacterBounds(builder, positionInfoStartIndex, positionInfoStartIndex + positionInfoLength, viewportToContentHorizontalOffset(), viewportToContentVerticalOffset());
        CursorAnchorInfo cursorAnchorInfo = builder.setMatrix(null).build();
        for (int i = 0; i < positionInfoLength; i++) {
            int flags = cursorAnchorInfo.getCharacterBoundsFlags(positionInfoStartIndex + i);
            if ((flags & FLAG_HAS_VISIBLE_REGION) == FLAG_HAS_VISIBLE_REGION) {
                RectF bounds = cursorAnchorInfo.getCharacterBounds(positionInfoStartIndex + i);
                if (bounds != null) {
                    mapRectFromViewToScreenCoords(bounds, true);
                    boundingRects[i] = bounds;
                }
            }
        }
        info.getExtras().putParcelableArray(extraDataKey, boundingRects);
    }
}","{
    if (arguments != null && extraDataKey.equals(EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY)) {
        int positionInfoStartIndex = arguments.getInt(EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_START_INDEX, -1);
        int positionInfoLength = arguments.getInt(EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_LENGTH, -1);
        if ((positionInfoLength <= 0) || (positionInfoStartIndex < 0) || (positionInfoStartIndex >= mText.length())) {
            Log.e(LOG_TAG, ""Invalid arguments for accessibility character locations"");
            return;
        }
        RectF[] boundingRects = new RectF[positionInfoLength];
        final CursorAnchorInfo.Builder builder = new CursorAnchorInfo.Builder();
        populateCharacterBounds(builder, positionInfoStartIndex, positionInfoStartIndex + positionInfoLength, viewportToContentHorizontalOffset(), viewportToContentVerticalOffset());
        CursorAnchorInfo cursorAnchorInfo = builder.setMatrix(null).build();
        for (int i = 0; i < positionInfoLength; i++) {
            int flags = cursorAnchorInfo.getCharacterBoundsFlags(positionInfoStartIndex + i);
            if ((flags & FLAG_HAS_VISIBLE_REGION) == FLAG_HAS_VISIBLE_REGION) {
                RectF bounds = cursorAnchorInfo.getCharacterBounds(positionInfoStartIndex + i);
                if (bounds != null) {
                    mapRectFromViewToScreenCoords(bounds, true);
                    boundingRects[i] = bounds;
                }
            }
        }
        info.getExtras().putParcelableArray(extraDataKey, boundingRects);
        return;
    }
    if (extraDataKey.equals(AccessibilityNodeInfo.EXTRA_DATA_RENDERING_INFO_KEY)) {
        final AccessibilityNodeInfo.ExtraRenderingInfo extraRenderingInfo = AccessibilityNodeInfo.ExtraRenderingInfo.obtain();
        extraRenderingInfo.setLayoutSize(getLayoutParams().width, getLayoutParams().height);
        extraRenderingInfo.setTextSizeInPx(getTextSize());
        extraRenderingInfo.setTextSizeUnit(getTextSizeUnit());
        info.setExtraRenderingInfo(extraRenderingInfo);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The code is restructured using a combined condition in the first 'if' statement, and a new conditional block is added for checking a different `extraDataKey`. Additionally, the return statement is moved to the end of the first conditional block, and there is a new method call `info.setExtraRenderingInfo(extraRenderingInfo)`. These indicate both control dependency and other statement changes, resulting in code change types 3 and 4.","A new control flow for the `extraDataKey` `AccessibilityNodeInfo.EXTRA_DATA_RENDERING_INFO_KEY` is introduced, which means that there are new return values (rendering info) when the provided `extraDataKey` matches this new case. This modification can lead to a different behavior, therefore the CI type is 1."
465,<android.app.Activity: void performStart(String)>,29,30,<android.app.Activity: void performStart(String)>,<android.app.Activity: void performStart(String)>,0,"{
    dispatchActivityPreStarted();
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    writeEventLog(LOG_AM_ON_START_CALLED, reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
    boolean isAppDebuggable = (mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    // This property is set for all non-user builds except final release
    boolean isDlwarningEnabled = SystemProperties.getInt(""ro.bionic.ld.warning"", 0) == 1;
    if (isAppDebuggable || isDlwarningEnabled) {
        String dlwarning = getDlWarning();
        if (dlwarning != null) {
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = ""Detected problems with app native libraries\n"" + ""(please consult log for detail):\n"" + dlwarning;
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + ""\n"" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    GraphicsEnvironment.getInstance().showAngleInUseDialogBox(this);
    mActivityTransitionState.enterReady(this);
    dispatchActivityPostStarted();
}","{
    dispatchActivityPreStarted();
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    EventLogTags.writeWmOnStartCalled(mIdent, getComponentName().getClassName(), reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
    // Warn app developers if the dynamic linker logged anything during startup.
    boolean isAppDebuggable = (mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    if (isAppDebuggable) {
        String dlwarning = getDlWarning();
        if (dlwarning != null) {
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = ""Detected problems with app native libraries\n"" + ""(please consult log for detail):\n"" + dlwarning;
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + ""\n"" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    GraphicsEnvironment.getInstance().showAngleInUseDialogBox(this);
    mActivityTransitionState.enterReady(this);
    dispatchActivityPostStarted();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method `writeEventLog(LOG_AM_ON_START_CALLED, reason)` in the early implementation has been replaced with `EventLogTags.writeWmOnStartCalled(mIdent, getComponentName().getClassName(), reason)` in the late implementation. This is a change in a log function call and does not affect the control flow or the functionality of the method. Therefore, the code change type is 4.","There is no Compatibility Issue since the change only involves logging behavior and does not affect the return value or the exceptions thrown by the method. The existing functionality and contracts of the API remain the same, and such a change will not lead to different behavior from the perspective of the API consumer."
466,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",29,30,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>","<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method called changed from ActivityManager.getService().broadcastIntent(...) to ActivityManager.getService().broadcastIntentWithFeature(...), adding an extra parameter getAttributionTag() which is handled internally within the method implementation. This is a change in a dependent API, so the code change type is 5.","As the change only consists of an additional parameter being passed to an underlying system service method, and there's no indication that this would lead to different return values or exceptions, there is no direct compatibility issue linked to the external behavior of the API. The wrapping API, sendBroadcast, is void and has not changed its signature or the way it processes exceptions. Therefore, the CI type is 0."
468,<android.net.LinkProperties: boolean addRoute(RouteInfo)>,29,30,<android.net.LinkProperties: boolean addRoute(RouteInfo)>,<android.net.LinkProperties: boolean addRoute(RouteInfo)>,0,"{
    String routeIface = route.getInterface();
    if (routeIface != null && !routeIface.equals(mIfaceName)) {
        throw new IllegalArgumentException(""Route added with non-matching interface: "" + routeIface + "" vs. "" + mIfaceName);
    }
    route = routeWithInterface(route);
    if (!mRoutes.contains(route)) {
        mRoutes.add(route);
        return true;
    }
    return false;
}","{
    String routeIface = route.getInterface();
    if (routeIface != null && !routeIface.equals(mIfaceName)) {
        throw new IllegalArgumentException(""Route added with non-matching interface: "" + routeIface + "" vs. "" + mIfaceName);
    }
    route = routeWithInterface(route);
    int i = findRouteIndexByRouteKey(route);
    if (i == -1) {
        // Route was not present. Add it.
        mRoutes.add(route);
        return true;
    } else if (mRoutes.get(i).equals(route)) {
        // Route was present and has same properties. Do nothing.
        return false;
    } else {
        // Route was present and has different properties. Update it.
        mRoutes.set(i, route);
        return true;
    }
}",1,"/**
 * Adds a {@link RouteInfo} to this {@code LinkProperties}, if not present. If the
 * {@link RouteInfo} had an interface name set and that differs from the interface set for this
 * {@code LinkProperties} an {@link IllegalArgumentException} will be thrown.  The proper
 * course is to add either un-named or properly named {@link RouteInfo}.
 *
 * @param route A {@link RouteInfo} to add to this object.
 * @return {@code false} if the route was already present, {@code true} if it was added.
 */
","/**
 * Adds a {@link RouteInfo} to this {@code LinkProperties}, if a {@link RouteInfo}
 * with the same {@link RouteInfo.RouteKey} with different properties
 * (e.g., different MTU), it will be updated. If the {@link RouteInfo} had an
 * interface name set and that differs from the interface set for this
 * {@code LinkProperties} an {@link IllegalArgumentException} will be thrown.
 * The proper course is to add either un-named or properly named {@link RouteInfo}.
 *
 * @param route A {@link RouteInfo} to add to this object.
 * @return {@code true} was added or updated, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version includes new control logic by changing the simple check if the route is not contained within `mRoutes` to a more complex block. This change introduces a `findRouteIndexByRouteKey` method, an if-else statement to handle different cases when the route is found or not, and an extra else branch that updates an existing route. These changes classify as return statement changed (1), control dependency change (3), and other statement changed (4).","The change in control logic and the introduction of a new way to add, check, and possibly update a route could lead to a different return value because the condition under which the method returns `true` or `false` has been modified. Therefore, the CI type is 1 (Compatibility Issue caused by the potential different return values or types). The additional logic could potentially lead to a `true` return value where the earlier implementation would have returned `false`, and vice versa."
469,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,29,30,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                    mActivityViewToScreenMatrix = res.getActivityViewToScreenMatrix();
                }
                startInputInner(StartInputReason.BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodDebug.unbindReasonToString(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // we would like to re-connect to the next input method.
                    if (mServedView != null && mServedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(StartInputReason.UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mRestartOnNextWindowFocus = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && canStartInput(mServedView)) {
                        if (checkFocusNoStartInput(mRestartOnNextWindowFocus)) {
                            final int reason = active ? StartInputReason.ACTIVATED_BY_IMMS : StartInputReason.DEACTIVATED_BY_IMMS;
                            startInputInner(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
        case MSG_REPORT_PRE_RENDERED:
            {
                synchronized (mH) {
                    if (mImeInsetsConsumer != null) {
                        mImeInsetsConsumer.onPreRendered((EditorInfo) msg.obj);
                    }
                }
                return;
            }
        case MSG_APPLY_IME_VISIBILITY:
            {
                synchronized (mH) {
                    if (mImeInsetsConsumer != null) {
                        mImeInsetsConsumer.applyImeVisibility(msg.arg1 != 0);
                    }
                }
                return;
            }
        case MSG_UPDATE_ACTIVITY_VIEW_TO_SCREEN_MATRIX:
            {
                final float[] matrixValues = (float[]) msg.obj;
                final int bindSequence = msg.arg1;
                synchronized (mH) {
                    if (mBindSequence != bindSequence) {
                        return;
                    }
                    if (matrixValues == null) {
                        // That this app is unbound from the parent ActivityView. In this case,
                        // calling updateCursorAnchorInfo() isn't safe.  Only clear the matrix.
                        mActivityViewToScreenMatrix = null;
                        return;
                    }
                    final float[] currentValues = new float[9];
                    mActivityViewToScreenMatrix.getValues(currentValues);
                    if (Arrays.equals(currentValues, matrixValues)) {
                        return;
                    }
                    mActivityViewToScreenMatrix.setValues(matrixValues);
                    if (mCursorAnchorInfo == null || mCurMethod == null || mServedInputConnectionWrapper == null) {
                        return;
                    }
                    final boolean isMonitoring = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_MONITOR) != 0;
                    if (!isMonitoring) {
                        return;
                    }
                    // IMS#updateCursorAnchorInfo() again.
                    try {
                        mCurMethod.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(mCursorAnchorInfo, mActivityViewToScreenMatrix));
                    } catch (RemoteException e) {
                        Log.w(TAG, ""IME died: "" + mCurId, e);
                    }
                }
                return;
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                    mActivityViewToScreenMatrix = res.getActivityViewToScreenMatrix();
                }
                startInputInner(StartInputReason.BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodDebug.unbindReasonToString(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // If we were actively using the last input method, then
                    // we would like to re-connect to the next input method.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && servedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(StartInputReason.UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mRestartOnNextWindowFocus = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // Check focus again in case that ""onWindowFocus"" is called before
                    // handling this message.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && canStartInput(servedView)) {
                        if (mCurRootView != null && mCurRootView.getImeFocusController().checkFocus(mRestartOnNextWindowFocus, false)) {
                            final int reason = active ? StartInputReason.ACTIVATED_BY_IMMS : StartInputReason.DEACTIVATED_BY_IMMS;
                            mDelegate.startInput(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
        case MSG_REPORT_PRE_RENDERED:
            {
                synchronized (mH) {
                    if (mImeInsetsConsumer != null) {
                        mImeInsetsConsumer.onPreRendered((EditorInfo) msg.obj);
                    }
                }
                return;
            }
        case MSG_APPLY_IME_VISIBILITY:
            {
                synchronized (mH) {
                    if (mImeInsetsConsumer != null) {
                        mImeInsetsConsumer.applyImeVisibility(msg.arg1 != 0);
                    }
                }
                return;
            }
        case MSG_UPDATE_ACTIVITY_VIEW_TO_SCREEN_MATRIX:
            {
                final float[] matrixValues = (float[]) msg.obj;
                final int bindSequence = msg.arg1;
                synchronized (mH) {
                    if (mBindSequence != bindSequence) {
                        return;
                    }
                    if (matrixValues == null || mActivityViewToScreenMatrix == null) {
                        // Either InputBoundResult#mActivityViewToScreenMatrixValues is null
                        // OR this app is unbound from the parent ActivityView. In this case,
                        // calling updateCursorAnchorInfo() isn't safe. Only clear the matrix.
                        mActivityViewToScreenMatrix = null;
                        return;
                    }
                    final float[] currentValues = new float[9];
                    mActivityViewToScreenMatrix.getValues(currentValues);
                    if (Arrays.equals(currentValues, matrixValues)) {
                        return;
                    }
                    mActivityViewToScreenMatrix.setValues(matrixValues);
                    if (mCursorAnchorInfo == null || mCurMethod == null || mServedInputConnectionWrapper == null) {
                        return;
                    }
                    final boolean isMonitoring = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_MONITOR) != 0;
                    if (!isMonitoring) {
                        return;
                    }
                    // IMS#updateCursorAnchorInfo() again.
                    try {
                        mCurMethod.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(mCursorAnchorInfo, mActivityViewToScreenMatrix));
                    } catch (RemoteException e) {
                        Log.w(TAG, ""IME died: "" + mCurId, e);
                    }
                }
                return;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
470,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",29,30,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>","<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",0,"{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess(this);
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}","{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess(this);
        IIntentSender target = ActivityManager.getService().getIntentSenderWithFeature(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, getAttributionTag(), mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}",1,"/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
","/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"Only the name of the method called on the `ActivityManager.getService()` object is changed from 'getIntentSender' to 'getIntentSenderWithFeature', with the addition of the 'getAttributionTag()' parameter. Thus, the code change type is 5.","Despite there being a change in the dependent API, there's no Compatibility Issue in terms of behavior because the method's purpose remains consistent—to retrieve an `IIntentSender` that is later wrapped into a `PendingIntent`. The API contract doesn't change from the caller's perspective, assuming 'getIntentSenderWithFeature' behaves similarly to 'getIntentSender' for the added parameter. Therefore, the CI type is 0."
471,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,29,30,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, uri.getAuthority(), true);
    }
    return null;
}","{
    Objects.requireNonNull(uri, ""uri"");
    IContentProvider provider = acquireProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, uri.getAuthority(), true);
    }
    return null;
}",1,"/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider if it determines that there is no other reason for
 * keeping it active.
 * @param uri specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri or null if there isn't one.
 */
","/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider if it determines that there is no other reason for
 * keeping it active.
 * @param uri specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri or null if there isn't one.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The only change is the use of a different method (Objects.requireNonNull instead of Preconditions.checkNotNull) for null check on the `uri`. However, both methods have the same purpose and throw a NullPointerException if the `uri` is null, so this is an ""Other statement changed"" (type 4).",There is no Compatibility Issue because the change from Preconditions.checkNotNull to Objects.requireNonNull does not alter the API's behavior in terms of the return value or exception handling. Both methods would throw a NullPointerException if the passed `uri` argument were null. There is no change in the control flow or in the exceptions thrown by the API.
472,<android.util.EventLog.Event: int getTag()>,29,30,<android.util.EventLog.Event: int getTag()>,<android.util.EventLog.Event: int getTag()>,0,"{
    int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
    if (offset == 0) {
        offset = V1_PAYLOAD_START;
    }
    return mBuffer.getInt(offset);
}","{
    return mBuffer.getInt(getHeaderSize());
}",1,"/**
 * @return the type tag code of the entry
 */
","/**
 * @return the type tag code of the entry
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The logic for computing the offset has been encapsulated within a separate method (getHeaderSize()) in the late version, and this late version no longer directly manipulates the offset value within the getTag() method. So, it includes the change type 5 for Dependent API changed. ",#CI_description
473,<android.speech.SpeechRecognizer: void destroy()>,29,30,<android.speech.SpeechRecognizer: void destroy()>,<android.speech.SpeechRecognizer: void destroy()>,0,"{
    if (mService != null) {
        try {
            mService.cancel(mListener);
        } catch (final RemoteException e) {
        // Not important
        }
    }
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}","{
    if (mService != null) {
        try {
            mService.cancel(mListener, mContext.getOpPackageName(), mContext.getAttributionTag());
        } catch (final RemoteException e) {
        // Not important
        }
    }
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}",1,"/**
 * Destroys the {@code SpeechRecognizer} object.
 */
","/**
 * Destroys the {@code SpeechRecognizer} object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method parameters for mService.cancel in the late implementation include two additional arguments: mContext.getOpPackageName() and mContext.getAttributionTag(). There are no changes in the return type, exception handling, or control flow, thus the change is classified as a Dependent API changed, which is 5.","There is no compatibility issue introduced with the change in the dependent method call, as the new parameters are context-related metadata that do not affect the functionality of the destroy method itself with regard to returning values or throwing exceptions. The modified method is expected to perform the same operation from the perspective of API consumers, hence CI is classified as 0."
474,<android.os.PowerManager: void removeThermalStatusListener(OnThermalStatusChangedListener)>,29,30,<android.os.PowerManager: void removeThermalStatusListener(OnThermalStatusChangedListener)>,<android.os.PowerManager: void removeThermalStatusListener(OnThermalStatusChangedListener)>,0,"{
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    synchronized (this) {
        if (mThermalService == null) {
            mThermalService = IThermalService.Stub.asInterface(ServiceManager.getService(Context.THERMAL_SERVICE));
        }
        IThermalStatusListener internalListener = mListenerMap.get(listener);
        Preconditions.checkArgument(internalListener != null, ""Listener was not added"");
        try {
            if (mThermalService.unregisterThermalStatusListener(internalListener)) {
                mListenerMap.remove(listener);
            } else {
                throw new RuntimeException(""Listener failed to remove"");
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    IThermalStatusListener internalListener = mListenerMap.get(listener);
    Preconditions.checkArgument(internalListener != null, ""Listener was not added"");
    try {
        if (mThermalService.unregisterThermalStatusListener(internalListener)) {
            mListenerMap.remove(listener);
        } else {
            throw new RuntimeException(""Listener failed to remove"");
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * This function removes a listener for thermal status change
 *
 * @param listener listener to be removed
 */
","/**
 * This function removes a listener for thermal status change
 *
 * @param listener listener to be removed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The synchronized block is removed and the code retrieving the `mThermalService` service has been deleted, which is an other statement changed (4), and the statements inside the synchronized block have changed position, which is a control dependency change (3).","These changes do not seem to introduce different behaviors concerning different return values or exception handlings, as the logic flow remains the same: the listener is checked for null, retrieved, checked if it was added, and then the `unregisterThermalStatusListener` method is called with a similar exception handling mechanism. The `synchronized` keyword's removal does not lead directly to a compatibility issue unless it concerns multi-threaded behaviors that are not evident solely based on the method's individual logic. Since no explicit return value or exception handling has changed from the method's perspective, there is no compatibility issue detected. However, there might be concurrency implications not detectable within the local context of the method changes given."
475,<android.service.voice.VoiceInteractionSession: void startAssistantActivity(Intent)>,29,30,<android.service.voice.VoiceInteractionSession: void startAssistantActivity(Intent)>,<android.service.voice.VoiceInteractionSession: void startAssistantActivity(Intent)>,0,"{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(mContext);
        int res = mSystemService.startAssistantActivity(mToken, intent, intent.resolveType(mContext.getContentResolver()));
        Instrumentation.checkStartActivityResult(res, intent);
    } catch (RemoteException e) {
    }
}","{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    try {
        intent.migrateExtraStreamToClipData(mContext);
        intent.prepareToLeaveProcess(mContext);
        int res = mSystemService.startAssistantActivity(mToken, intent, intent.resolveType(mContext.getContentResolver()), mContext.getAttributionTag());
        Instrumentation.checkStartActivityResult(res, intent);
    } catch (RemoteException e) {
    }
}",1,"/**
 * <p>Ask that a new assistant activity be started.  This will create a new task in the
 * in activity manager: this means that
 * {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK}
 * will be set for you to make it a new task.</p>
 *
 * <p>The newly started activity will be displayed on top of other activities in the system
 * in a new layer that is not affected by multi-window mode.  Tasks started from this activity
 * will go into the normal activity layer and not this new layer.</p>
 *
 * <p>By default, the system will create a window for the UI for this session.  If you are using
 * an assistant activity instead, then you can disable the window creation by calling
 * {@link #setUiEnabled} in {@link #onPrepareShow(Bundle, int)}.</p>
 */
","/**
 * <p>Ask that a new assistant activity be started.  This will create a new task in the
 * in activity manager: this means that
 * {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK}
 * will be set for you to make it a new task.</p>
 *
 * <p>The newly started activity will be displayed on top of other activities in the system
 * in a new layer that is not affected by multi-window mode.  Tasks started from this activity
 * will go into the normal activity layer and not this new layer.</p>
 *
 * <p>By default, the system will create a window for the UI for this session.  If you are using
 * an assistant activity instead, then you can disable the window creation by calling
 * {@link #setUiEnabled} in {@link #onPrepareShow(Bundle, int)}.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has two changes: a new parameter is added to the call to migrateExtraStreamToClipData(), and a new parameter is passed to the mSystemService.startAssistantActivity() method. Both are the changes to the method invocation on `intent` and `mSystemService`. No other changes such as control statements or return statements were affected. Therefore, the code change types are 4 and 5.","Even though dependent APIs were changed with extra parameters being passed to the methods, these changes did not alter the control flow or exception handling, nor did they introduce new return paths. Thus, these changes do not result in different return values or exception handling behavior that would affect outward compatibility. Therefore, there is no Compatibility Issue."
477,<android.net.LinkProperties: void clear()>,29,30,<android.net.LinkProperties: void clear()>,<android.net.LinkProperties: void clear()>,0,"{
    mIfaceName = null;
    mLinkAddresses.clear();
    mDnses.clear();
    mUsePrivateDns = false;
    mPrivateDnsServerName = null;
    mPcscfs.clear();
    mDomains = null;
    mRoutes.clear();
    mHttpProxy = null;
    mStackedLinks.clear();
    mMtu = 0;
    mTcpBufferSizes = null;
    mNat64Prefix = null;
}","{
    if (mParcelSensitiveFields) {
        throw new UnsupportedOperationException(""Cannot clear LinkProperties when parcelSensitiveFields is set"");
    }
    mIfaceName = null;
    mLinkAddresses.clear();
    mDnses.clear();
    mUsePrivateDns = false;
    mPrivateDnsServerName = null;
    mPcscfs.clear();
    mDomains = null;
    mRoutes.clear();
    mHttpProxy = null;
    mStackedLinks.clear();
    mMtu = 0;
    mDhcpServerAddress = null;
    mTcpBufferSizes = null;
    mNat64Prefix = null;
    mWakeOnLanSupported = false;
    mCaptivePortalApiUrl = null;
    mCaptivePortalData = null;
}",1,"/**
 * Clears this object to its initial state.
 */
","/**
 * Clears this object to its initial state.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late implementation introduces an 'if' statement with a 'throw' statement inside it, which is an exception handling statement change (2) and a control dependency change (3), as the execution of the rest of the method now depends on a new condition. There's also a change in other statements with the addition of fields mDhcpServerAddress, mWakeOnLanSupported, mCaptivePortalApiUrl, and mCaptivePortalData being set to null, which is not present in the early version, categorized under other statement changed (4).","The presence of a new 'throw' statement at the beginning of the method can lead to a different exception being thrown (2) based on the new condition (if the mParcelSensitiveFields is true), which was not present in the early version. This constitutes a potential compatibility issue because the method could throw an exception where it previously would not have, leading to different behavior (2). Additionally, the new condition (mParcelSensitiveFields) introduces a control change that could also potentially return different results based on this new check, constituting a compatibility issue with different return values (1) since the method would not complete as it previously would have if the condition is met."
479,"<android.hardware.camera2.impl.CameraDeviceImpl: boolean configureStreamsChecked(InputConfiguration,List<OutputConfiguration>,int,CaptureRequest)>",29,30,"<android.hardware.camera2.impl.CameraDeviceImpl: boolean configureStreamsChecked(InputConfiguration,List<OutputConfiguration>,int,CaptureRequest)>","<android.hardware.camera2.impl.CameraDeviceImpl: boolean configureStreamsChecked(InputConfiguration,List<OutputConfiguration>,int,CaptureRequest)>",0,"{
    // Treat a null input the same an empty list
    if (outputs == null) {
        outputs = new ArrayList<OutputConfiguration>();
    }
    if (outputs.size() == 0 && inputConfig != null) {
        throw new IllegalArgumentException(""cannot configure an input stream without "" + ""any output streams"");
    }
    checkInputConfiguration(inputConfig);
    boolean success = false;
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        // Streams to create
        HashSet<OutputConfiguration> addSet = new HashSet<OutputConfiguration>(outputs);
        // Streams to delete
        List<Integer> deleteList = new ArrayList<Integer>();
        // Determine which streams need to be created, which to be deleted
        for (int i = 0; i < mConfiguredOutputs.size(); ++i) {
            int streamId = mConfiguredOutputs.keyAt(i);
            OutputConfiguration outConfig = mConfiguredOutputs.valueAt(i);
            if (!outputs.contains(outConfig) || outConfig.isDeferredConfiguration()) {
                // Always delete the deferred output configuration when the session
                // is created, as the deferred output configuration doesn't have unique surface
                // related identifies.
                deleteList.add(streamId);
            } else {
                // Don't create a stream previously created
                addSet.remove(outConfig);
            }
        }
        mDeviceExecutor.execute(mCallOnBusy);
        stopRepeating();
        try {
            waitUntilIdle();
            mRemoteDevice.beginConfigure();
            // reconfigure the input stream if the input configuration is different.
            InputConfiguration currentInputConfig = mConfiguredInput.getValue();
            if (inputConfig != currentInputConfig && (inputConfig == null || !inputConfig.equals(currentInputConfig))) {
                if (currentInputConfig != null) {
                    mRemoteDevice.deleteStream(mConfiguredInput.getKey());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(REQUEST_ID_NONE, null);
                }
                if (inputConfig != null) {
                    int streamId = mRemoteDevice.createInputStream(inputConfig.getWidth(), inputConfig.getHeight(), inputConfig.getFormat());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(streamId, inputConfig);
                }
            }
            // Delete all streams first (to free up HW resources)
            for (Integer streamId : deleteList) {
                mRemoteDevice.deleteStream(streamId);
                mConfiguredOutputs.delete(streamId);
            }
            // Add all new streams
            for (OutputConfiguration outConfig : outputs) {
                if (addSet.contains(outConfig)) {
                    int streamId = mRemoteDevice.createStream(outConfig);
                    mConfiguredOutputs.put(streamId, outConfig);
                }
            }
            if (sessionParams != null) {
                mRemoteDevice.endConfigure(operatingMode, sessionParams.getNativeCopy());
            } else {
                mRemoteDevice.endConfigure(operatingMode, null);
            }
            success = true;
        } catch (IllegalArgumentException e) {
            // OK. camera service can reject stream config if it's not supported by HAL
            // This is only the result of a programmer misusing the camera2 api.
            Log.w(TAG, ""Stream configuration failed due to: "" + e.getMessage());
            return false;
        } catch (CameraAccessException e) {
            if (e.getReason() == CameraAccessException.CAMERA_IN_USE) {
                throw new IllegalStateException(""The camera is currently busy."" + "" You must wait until the previous operation completes."", e);
            }
            throw e;
        } finally {
            if (success && outputs.size() > 0) {
                mDeviceExecutor.execute(mCallOnIdle);
            } else {
                // Always return to the 'unconfigured' state if we didn't hit a fatal error
                mDeviceExecutor.execute(mCallOnUnconfigured);
            }
        }
    }
    return success;
}","{
    // Treat a null input the same an empty list
    if (outputs == null) {
        outputs = new ArrayList<OutputConfiguration>();
    }
    if (outputs.size() == 0 && inputConfig != null) {
        throw new IllegalArgumentException(""cannot configure an input stream without "" + ""any output streams"");
    }
    checkInputConfiguration(inputConfig);
    boolean success = false;
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        // Streams to create
        HashSet<OutputConfiguration> addSet = new HashSet<OutputConfiguration>(outputs);
        // Streams to delete
        List<Integer> deleteList = new ArrayList<Integer>();
        // Determine which streams need to be created, which to be deleted
        for (int i = 0; i < mConfiguredOutputs.size(); ++i) {
            int streamId = mConfiguredOutputs.keyAt(i);
            OutputConfiguration outConfig = mConfiguredOutputs.valueAt(i);
            if (!outputs.contains(outConfig) || outConfig.isDeferredConfiguration()) {
                // Always delete the deferred output configuration when the session
                // is created, as the deferred output configuration doesn't have unique surface
                // related identifies.
                deleteList.add(streamId);
            } else {
                // Don't create a stream previously created
                addSet.remove(outConfig);
            }
        }
        mDeviceExecutor.execute(mCallOnBusy);
        stopRepeating();
        try {
            waitUntilIdle();
            mRemoteDevice.beginConfigure();
            // reconfigure the input stream if the input configuration is different.
            InputConfiguration currentInputConfig = mConfiguredInput.getValue();
            if (inputConfig != currentInputConfig && (inputConfig == null || !inputConfig.equals(currentInputConfig))) {
                if (currentInputConfig != null) {
                    mRemoteDevice.deleteStream(mConfiguredInput.getKey());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(REQUEST_ID_NONE, null);
                }
                if (inputConfig != null) {
                    int streamId = mRemoteDevice.createInputStream(inputConfig.getWidth(), inputConfig.getHeight(), inputConfig.getFormat());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(streamId, inputConfig);
                }
            }
            // Delete all streams first (to free up HW resources)
            for (Integer streamId : deleteList) {
                mRemoteDevice.deleteStream(streamId);
                mConfiguredOutputs.delete(streamId);
            }
            // Add all new streams
            for (OutputConfiguration outConfig : outputs) {
                if (addSet.contains(outConfig)) {
                    int streamId = mRemoteDevice.createStream(outConfig);
                    mConfiguredOutputs.put(streamId, outConfig);
                }
            }
            int[] offlineStreamIds;
            if (sessionParams != null) {
                offlineStreamIds = mRemoteDevice.endConfigure(operatingMode, sessionParams.getNativeCopy());
            } else {
                offlineStreamIds = mRemoteDevice.endConfigure(operatingMode, null);
            }
            mOfflineSupport.clear();
            if ((offlineStreamIds != null) && (offlineStreamIds.length > 0)) {
                for (int offlineStreamId : offlineStreamIds) {
                    mOfflineSupport.add(offlineStreamId);
                }
            }
            success = true;
        } catch (IllegalArgumentException e) {
            // OK. camera service can reject stream config if it's not supported by HAL
            // This is only the result of a programmer misusing the camera2 api.
            Log.w(TAG, ""Stream configuration failed due to: "" + e.getMessage());
            return false;
        } catch (CameraAccessException e) {
            if (e.getReason() == CameraAccessException.CAMERA_IN_USE) {
                throw new IllegalStateException(""The camera is currently busy."" + "" You must wait until the previous operation completes."", e);
            }
            throw e;
        } finally {
            if (success && outputs.size() > 0) {
                mDeviceExecutor.execute(mCallOnIdle);
            } else {
                // Always return to the 'unconfigured' state if we didn't hit a fatal error
                mDeviceExecutor.execute(mCallOnUnconfigured);
            }
        }
    }
    return success;
}",1,"/**
 * Attempt to configure the input and outputs; the device goes to idle and then configures the
 * new input and outputs if possible.
 *
 * <p>The configuration may gracefully fail, if input configuration is not supported,
 * if there are too many outputs, if the formats are not supported, or if the sizes for that
 * format is not supported. In this case this function will return {@code false} and the
 * unconfigured callback will be fired.</p>
 *
 * <p>If the configuration succeeds (with 1 or more outputs with or without an input),
 * then the idle callback is fired. Unconfiguring the device always fires the idle callback.</p>
 *
 * @param inputConfig input configuration or {@code null} for no input
 * @param outputs a list of one or more surfaces, or {@code null} to unconfigure
 * @param operatingMode If the stream configuration is for a normal session,
 * a constrained high speed session, or something else.
 * @param sessionParams Session parameters.
 * @return whether or not the configuration was successful
 *
 * @throws CameraAccessException if there were any unexpected problems during configuration
 */
","/**
 * Attempt to configure the input and outputs; the device goes to idle and then configures the
 * new input and outputs if possible.
 *
 * <p>The configuration may gracefully fail, if input configuration is not supported,
 * if there are too many outputs, if the formats are not supported, or if the sizes for that
 * format is not supported. In this case this function will return {@code false} and the
 * unconfigured callback will be fired.</p>
 *
 * <p>If the configuration succeeds (with 1 or more outputs with or without an input),
 * then the idle callback is fired. Unconfiguring the device always fires the idle callback.</p>
 *
 * @param inputConfig input configuration or {@code null} for no input
 * @param outputs a list of one or more surfaces, or {@code null} to unconfigure
 * @param operatingMode If the stream configuration is for a normal session,
 * a constrained high speed session, or something else.
 * @param sessionParams Session parameters.
 * @return whether or not the configuration was successful
 *
 * @throws CameraAccessException if there were any unexpected problems during configuration
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
480,"<android.app.ContextImpl: int checkPermission(String,int,int)>",29,30,"<android.app.ContextImpl: int checkPermission(String,int,int)>","<android.app.ContextImpl: int checkPermission(String,int,int)>",0,"{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    final IActivityManager am = ActivityManager.getService();
    if (am == null) {
        // Well this is super awkward; we somehow don't have an active
        // ActivityManager instance. If we're testing a root or system
        // UID, then they totally have whatever permission this is.
        final int appId = UserHandle.getAppId(uid);
        if (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) {
            Slog.w(TAG, ""Missing ActivityManager; assuming "" + uid + "" holds "" + permission);
            return PackageManager.PERMISSION_GRANTED;
        }
        Slog.w(TAG, ""Missing ActivityManager; assuming "" + uid + "" does not hold "" + permission);
        return PackageManager.PERMISSION_DENIED;
    }
    try {
        return am.checkPermission(permission, pid, uid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    return PermissionManager.checkPermission(permission, pid, uid);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The late implementation of the method substituted the previous complex logic and remote service call with a direct call to `PermissionManager.checkPermission(permission, pid, uid)`. Therefore, the method body is changed to use a different API which implies a code change type of 5.","The change from calling `IActivityManager`'s `checkPermission` and local process checking to directly using `PermissionManager.checkPermission` could result in a change in behavior because the implementation details of permission checking might be different in `PermissionManager`. This can lead to a potential CI as it may cause the method to return different results for permission checks; thus, the CI type is 1."
481,<android.hardware.biometrics.BiometricManager: int canAuthenticate()>,29,30,<android.hardware.biometrics.BiometricManager: int canAuthenticate()>,<android.hardware.biometrics.BiometricManager: int canAuthenticate()>,0,"{
    if (mService != null) {
        try {
            return mService.canAuthenticate(mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        if (!mHasHardware) {
            return BIOMETRIC_ERROR_NO_HARDWARE;
        } else {
            Slog.w(TAG, ""hasEnrolledBiometrics(): Service not connected"");
            return BIOMETRIC_ERROR_HW_UNAVAILABLE;
        }
    }
}","{
    return canAuthenticate(Authenticators.BIOMETRIC_WEAK);
}",1,"/**
 * Determine if biometrics can be used. In other words, determine if {@link BiometricPrompt}
 * can be expected to be shown (hardware available, templates enrolled, user-enabled).
 *
 * @return Returns {@link #BIOMETRIC_ERROR_NONE_ENROLLED} if the user does not have any
 * enrolled, or {@link #BIOMETRIC_ERROR_HW_UNAVAILABLE} if none are currently
 * supported/enabled. Returns {@link #BIOMETRIC_SUCCESS} if a biometric can currently be
 * used (enrolled and available).
 */
","/**
 * Determine if biometrics can be used. In other words, determine if
 * {@link BiometricPrompt} can be expected to be shown (hardware available, templates enrolled,
 * user-enabled). This is the equivalent of {@link #canAuthenticate(int)} with
 * {@link Authenticators#BIOMETRIC_WEAK}
 *
 * @return {@link #BIOMETRIC_ERROR_NONE_ENROLLED} if the user does not have any strong
 * biometrics enrolled, or {@link #BIOMETRIC_ERROR_HW_UNAVAILABLE} if none are currently
 * supported/enabled. Returns {@link #BIOMETRIC_SUCCESS} if a strong biometric can currently
 * be used (enrolled and available).
 *
 * @deprecated See {@link #canAuthenticate(int)}.
 */
",-1,"[@RequiresPermission(USE_BIOMETRIC), @BiometricError]","[@Deprecated, @RequiresPermission(USE_BIOMETRIC), @BiometricError]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method implementation has changed significantly. It went from a block of code that includes if-else statements, exception handling, and return statements with intricate logic, to a single return statement calling another method with a specific constant, Authenticators.BIOMETRIC_WEAK. Additionally, the signature of canAuthenticate() that it depends on has also changed; if this signature has changed between versions, this would count as a dependent API change. Hence, the code change types are 1,4,5.","Due to the substantial overhaul of the method, it now potentially returns a different value based on the new logic. This leads to a potential different behavior when the method is invoked, as it now directly calls a different method, canAuthenticate(int), with a specific constant. Therefore, the CI type is 1."
482,<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: Builder setSynchronousMode(String)>,29,30,<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: Builder setSynchronousMode(String)>,<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: Builder setSynchronousMode(String)>,0,"{
    Preconditions.checkNotNull(syncMode);
    mSyncMode = syncMode;
    return this;
}","{
    Objects.requireNonNull(syncMode);
    mSyncMode = syncMode;
    return this;
}",1,"/**
 * w
 * Sets <a href=""https://sqlite.org/pragma.html#pragma_synchronous"">synchronous mode</a>
 * .
 * @return
 */
","/**
 * w
 * Sets <a href=""https://sqlite.org/pragma.html#pragma_synchronous"">synchronous mode</a>
 * .
 * @return
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,The precondition check has been changed from using Preconditions.checkNotNull(syncMode) to Objects.requireNonNull(syncMode). This change is categorized as 'Other statement changed' because it does not affect the control flow or the method's signature but simply changes the internal precondition check implementation.,"There is no Compatibility Issue in this change because both Preconditions.checkNotNull() and Objects.requireNonNull() serve the same purpose—to ensure that the provided parameter is not null, throwing a NullPointerException if it is null, and they behave the same way in this context. Since there's an @NonNull annotation in both versions, clients are expected to ensure the parameter is not null before calling the method. Thus, the behavior of the API remains consistent between versions."
483,<android.net.TrafficStats: long getUidTxBytes(int)>,29,30,<android.net.TrafficStats: long getUidTxBytes(int)>,<android.net.TrafficStats: long getUidTxBytes(int)>,0,"{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_TX_BYTES);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}","{
    try {
        return getStatsService().getUidStats(uid, TYPE_TX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return number of bytes transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of bytes transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency changed due to the removal of the condition checking the caller's UID against the system UID and the queried UID. The code previously returns UNSUPPORTED if the caller's UID did not match the specified conditions; however, this restriction has been removed in the late version.","There is a Compatibility Issue caused by potential different return values. The method now potentially returns a value based on actual statistics for any calling UID, where it previously would have returned UNSUPPORTED for certain calling UIDs, hence CI type is 1."
486,<android.view.WindowInsets: WindowInsets consumeSystemWindowInsets()>,29,30,<android.view.WindowInsets: WindowInsets consumeSystemWindowInsets()>,<android.view.WindowInsets: WindowInsets consumeSystemWindowInsets()>,0,"{
    return new WindowInsets(null, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, displayCutoutCopyConstructorArgument(this));
}","{
    return new WindowInsets(null, null, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, displayCutoutCopyConstructorArgument(this), mCompatInsetsTypes, mCompatIgnoreVisibility);
}",1,"/**
 * Returns a copy of this WindowInsets with the system window insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */
","/**
 * Returns a copy of this WindowInsets with the system window insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 * @deprecated Consuming of different parts individually of a {@link WindowInsets} instance is
 * deprecated, since {@link WindowInsets} contains many different insets. Use {@link #CONSUMED}
 * instead to stop dispatching insets.
 */
",-1,[@NonNull],"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The second parameter passed to the `WindowInsets` constructor has changed from a conditional expression (mStableInsetsConsumed ? null : mTypeMaxInsetsMap) to `null`, the last two parameters for the `WindowInsets` constructor are added (mCompatInsetsTypes, mCompatIgnoreVisibility), and the `@Deprecated` annotation is added to the method. Therefore, the change types are 1, 4, and 5.","Since there's a change in the parameters passed to the `WindowInsets` constructor, specifically the second parameter being always `null` now, and the addition of new parameters, the method potentially returns a `WindowInsets` object that has different attributes. This represents a Compatibility Issue due to potential different return values, hence the CI type is 1."
487,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,29,30,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,0,"{
    enforceSealed();
    return getNodeForAccessibilityId(mConnectionId, mWindowId, mParentNodeId);
}","{
    enforceSealed();
    if (mLeashedParent != null && mLeashedParentNodeId != UNDEFINED_NODE_ID) {
        return getNodeForAccessibilityId(mConnectionId, mLeashedParent, mLeashedParentNodeId);
    }
    return getNodeForAccessibilityId(mConnectionId, mWindowId, mParentNodeId);
}",1,"/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
","/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"A new conditional block has been added in the late version to check for `mLeashedParent` and `mLeashedParentNodeId`. If the condition is met, a different method is called with different parameters. So the change type is 3, a control dependency change.","The addition of the conditional block may lead to the API returning a different `AccessibilityNodeInfo` object if the condition is met, which was not present in the early version. Accordingly, the CI type is 1, as it is possible for the API to return a different value or type due to the control dependency change."
488,"<android.app.ContextImpl: int checkUriPermission(Uri,String,String,int,int,int)>",29,30,"<android.app.ContextImpl: int checkUriPermission(Uri,String,String,int,int,int)>","<android.app.ContextImpl: int checkUriPermission(Uri,String,String,int,int,int)>",0,"{
    if (DEBUG) {
        Log.i(""foo"", ""checkUriPermission: uri="" + uri + ""readPermission="" + readPermission + "" writePermission="" + writePermission + "" pid="" + pid + "" uid="" + uid + "" mode"" + modeFlags);
    }
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
        if (readPermission == null || checkPermission(readPermission, pid, uid) == PackageManager.PERMISSION_GRANTED) {
            return PackageManager.PERMISSION_GRANTED;
        }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
        if (writePermission == null || checkPermission(writePermission, pid, uid) == PackageManager.PERMISSION_GRANTED) {
            return PackageManager.PERMISSION_GRANTED;
        }
    }
    return uri != null ? checkUriPermission(uri, pid, uid, modeFlags) : PackageManager.PERMISSION_DENIED;
}","{
    if (DEBUG) {
        Log.i(""foo"", ""checkUriPermission: uri="" + uri + ""readPermission="" + readPermission + "" writePermission="" + writePermission + "" pid="" + pid + "" uid="" + uid + "" mode"" + modeFlags);
    }
    if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
        if (readPermission == null || checkPermission(readPermission, pid, uid) == PERMISSION_GRANTED) {
            return PERMISSION_GRANTED;
        }
    }
    if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
        if (writePermission == null || checkPermission(writePermission, pid, uid) == PERMISSION_GRANTED) {
            return PERMISSION_GRANTED;
        }
    }
    return uri != null ? checkUriPermission(uri, pid, uid, modeFlags) : PackageManager.PERMISSION_DENIED;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no functional code change identified between the two versions. The only difference is the removal of the `PackageManager.` prefix before the constants `PERMISSION_GRANTED` and `PERMISSION_DENIED`. Since this prefix is not affecting how the code executes (most likely due to the late version using an import statement for the constants), it doesn't constitute a compatibility issue between the two API versions.",As there was no functional change to the behavior of the code—the method's logic and return values remain consistent—there is no compatibility issue present.
490,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,29,30,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,0,"{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // and torch statuses will be updated.
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, cameraId);
        }
        for (int i = 0; i < mTorchStatus.size(); i++) {
            String cameraId = mTorchStatus.keyAt(i);
            onTorchStatusChangedLocked(ICameraServiceListener.TORCH_STATUS_NOT_AVAILABLE, cameraId);
        }
        scheduleCameraServiceReconnectionLocked();
    }
}","{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // and torch statuses will be updated.
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, cameraId);
        }
        for (int i = 0; i < mTorchStatus.size(); i++) {
            String cameraId = mTorchStatus.keyAt(i);
            onTorchStatusChangedLocked(ICameraServiceListener.TORCH_STATUS_NOT_AVAILABLE, cameraId);
        }
        mConcurrentCameraIdCombinations.clear();
        scheduleCameraServiceReconnectionLocked();
    }
}",1,"/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
","/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The line `mConcurrentCameraIdCombinations.clear();` has been added in the late version. This is an internal state change, not affecting the method's return type or exception handling, and the method does not return a value in either version.","There is no Compatibility Issue because the method's signature, return type, and exception handling remain unchanged and the method has no return value which could be affected by the new line of code."
491,<android.companion.WifiDeviceFilter: int hashCode()>,29,30,<android.companion.WifiDeviceFilter: int hashCode()>,<android.companion.WifiDeviceFilter: int hashCode()>,0,"{
    return Objects.hash(mNamePattern);
}","{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + Objects.hashCode(mNamePattern);
    _hash = 31 * _hash + Objects.hashCode(mBssid);
    _hash = 31 * _hash + Objects.hashCode(mBssidMask);
    return _hash;
}",1,,,-1,[@Override],"[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the hashCode() method has been significantly changed by adding the logic to incorporate additional fields such as mBssid and mBssidMask into the hash calculation that were not part of the early hash code computation. This is a change in other statements as well, since the entire method body has been rewritten, including new variable declarations and hash code calculation statements. The change type is thus 1,4.",This change will cause the API to potentially return a different value since the hash code computed by the late version of the method will take into account additional fields that were not considered in the early version. So the CI type is 1.
492,"<android.content.ContentProviderOperation.Builder: Builder withSelection(String,String[])>",29,30,"<android.content.ContentProviderOperation.Builder: Builder withSelection(String,String[])>","<android.content.ContentProviderOperation.Builder: Builder withSelection(String,String[])>",0,"{
    if (mType != TYPE_UPDATE && mType != TYPE_DELETE && mType != TYPE_ASSERT) {
        throw new IllegalArgumentException(""only updates, deletes, and asserts can have selections"");
    }
    mSelection = selection;
    if (selectionArgs == null) {
        mSelectionArgs = null;
    } else {
        mSelectionArgs = new String[selectionArgs.length];
        System.arraycopy(selectionArgs, 0, mSelectionArgs, 0, selectionArgs.length);
    }
    return this;
}","{
    assertSelectionAllowed();
    mSelection = selection;
    if (selectionArgs != null) {
        ensureSelectionArgs();
        for (int i = 0; i < selectionArgs.length; i++) {
            setSelectionArg(i, selectionArgs[i]);
        }
    }
    return this;
}",1,"/**
 * The selection and arguments to use. An occurrence of '?' in the selection will be
 * replaced with the corresponding occurrence of the selection argument. Any of the
 * selection arguments may be overwritten by a selection argument back reference as
 * specified by {@link #withSelectionBackReference}.
 * This can only be used with builders of type update, delete, or assert.
 * @return this builder, to allow for chaining.
 */
","/**
 * Configure the selection and selection arguments to use for this
 * operation. This method will replace any previously defined selection
 * and selection arguments, but it will not replace any back-reference
 * requests.
 * <p>
 * An occurrence of {@code ?} in the selection will be replaced with the
 * corresponding selection argument when the operation is executed.
 * <p>
 * Any selection argument may be dynamically overwritten using the
 * result of a previous operation by using methods such as
 * {@link #withSelectionBackReference(int, int)}.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The early version throws IllegalArgumentException directly in the method if the condition is met, whereas the late version calls assertSelectionAllowed() which likely performs the same check. The assignment of mSelectionArgs has been refactored from a System.arraycopy call to a loop that calls setSelectionArg. There's also the removal of the direct check against null and assignment of mSelectionArgs to null, replaced with ensureSelectionArgs() which probably handles this internally. Additionally, there's an annotation change (NonNull was added in the late version). The dependent API method signatures, assertSelectionAllowed, ensureSelectionArgs, and setSelectionArg, are used in the late version, indicating dependent API changes. Because of these changes, the code change types are 2,3,4,5.","The change in exception handling from directly throwing IllegalArgumentException to using assertSelectionAllowed() suggests a change in the type of exception that could be thrown (or how it's thrown), which is a compatibility issue of type 2. The change from directly assigning mSelectionArgs to using ensureSelectionArgs() and the setSelectionArg loop could alter the values assigned to mSelectionArgs, which affects the return value of the API. Furthermore, since selectionArgs are part of the state of Builder, the change could manifest in different Builder states, potentially causing the builder to return different values, which is a compatibility issue of type 1."
494,<android.content.ContentProviderResult: String toString()>,29,30,<android.content.ContentProviderResult: String toString()>,<android.content.ContentProviderResult: String toString()>,0,"{
    final StringBuilder sb = new StringBuilder(""ContentProviderResult("");
    if (uri != null) {
        sb.append(""uri="" + uri + "" "");
    }
    if (count != null) {
        sb.append(""count="" + count + "" "");
    }
    if (uri != null) {
        sb.append(""failure="" + failure + "" "");
    }
    sb.deleteCharAt(sb.length() - 1);
    sb.append("")"");
    return sb.toString();
}","{
    final StringBuilder sb = new StringBuilder(""ContentProviderResult("");
    if (uri != null) {
        sb.append(""uri="" + uri + "" "");
    }
    if (count != null) {
        sb.append(""count="" + count + "" "");
    }
    if (extras != null) {
        sb.append(""extras="" + extras + "" "");
    }
    if (exception != null) {
        sb.append(""exception="" + exception + "" "");
    }
    sb.deleteCharAt(sb.length() - 1);
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The code changes include updates to the control dependencies (if conditions) and other statements that manipulate the StringBuilder. The early code version includes building a string with condition on 'failure'; whereas the late version includes 'extras' and 'exception' instead of 'failure', marking the code change type as 4 for the other statements changed and 3 for control dependency changed.","There is no Compatibility Issue because the toString method is designed to return a String representation of the object's state, and these changes are simply updating that representation to reflect the current state of the object. The method's behavior is consistent with its purpose, regardless of the specific fields it includes in the output. Changes in the implementation of a toString method are not considered to affect backward compatibility in a way that would cause an API consumer's code to break, as long as the method continues to return some string."
497,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,29,30,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.performAccessibilityAction(mConnectionId, mWindowId, mSourceNodeId, action, null);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    Bundle arguments = null;
    if (mExtras != null) {
        arguments = mExtras;
    }
    return client.performAccessibilityAction(mConnectionId, mWindowId, mSourceNodeId, action, arguments);
}",1,"/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is a new variable 'arguments' introduced, and an 'if' control dependency is added to check for nullity of the 'mExtras' before the final return statement. Additionally, the return statement itself now includes 'arguments' instead of 'null', so the change types are 3 and 4.","The late version API introduces a condition to use 'mExtras' if it is not null which could potentially lead to a different behavior from the early version if 'mExtras' is not null. Thus, 'arguments' can now have values other than null, which could result in the 'performAccessibilityAction' method behaving differently. Therefore, the change could lead to different return values, and the CI type is 1."
499,"<android.app.ActivityView.SurfaceCallback: void surfaceChanged(SurfaceHolder,int,int,int)>",29,30,"<android.app.ActivityView.SurfaceCallback: void surfaceChanged(SurfaceHolder,int,int,int)>","<android.app.ActivityView.SurfaceCallback: void surfaceChanged(SurfaceHolder,int,int,int)>",0,"{
    if (mVirtualDisplay != null) {
        mVirtualDisplay.resize(width, height, getBaseDisplayDensity());
    }
    updateLocationAndTapExcludeRegion();
}","{
    final Display display = getVirtualDisplay().getDisplay();
    if (!display.getDisplayInfo(mTempDisplayInfo)) {
        return;
    }
    mTempDisplayInfo.getAppMetrics(mTempMetrics);
    if (width != mTempMetrics.widthPixels || height != mTempMetrics.heightPixels) {
        mTaskEmbedder.resizeTask(width, height);
        mTaskEmbedder.notifyBoundsChanged();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,There are several changes made:,"3. In the early version, the method updateLocationAndTapExcludeRegion() is called without any condition, whereas in the late version, this call is removed and replaced with a new block of logic (4)."
500,<android.os.UserManager: boolean isUserAGoat()>,29,30,<android.os.UserManager: boolean isUserAGoat()>,<android.os.UserManager: boolean isUserAGoat()>,0,"{
    return mContext.getPackageManager().isPackageAvailable(""com.coffeestainstudios.goatsimulator"");
}","{
    if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R) {
        return false;
    }
    return mContext.getPackageManager().isPackageAvailable(""com.coffeestainstudios.goatsimulator"");
}",1,"/**
 * Used to determine whether the user making this call is subject to
 * teleportations.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method can
 * now automatically identify goats using advanced goat recognition technology.</p>
 *
 * @return Returns true if the user making this call is a goat.
 */
","/**
 * Used to determine whether the user making this call is subject to
 * teleportations.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method can
 * now automatically identify goats using advanced goat recognition technology.</p>
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#R}, this method always returns
 * {@code false} in order to protect goat privacy.</p>
 *
 * @return Returns whether the user making this call is a goat.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An if condition is introduced to check the target SDK version, making it a control dependency change, so the code change type is 3.","The introduction of the new if condition may lead to the API returning a different value (false) before it reaches the original return statement, depending on the target SDK version. Therefore, the CI type is 1."
501,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",29,30,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>","<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.update(mPackageName, url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    return update(url, values, ContentResolver.createSqlQueryBundle(selection, selectionArgs));
}",1,"/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
","/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
",-1,[@Override],,-1,-1,-1,-1,-1,-1,"1,5","1,2","The implementation has completely changed from direct method call with multiple parameters to a method call with a bundled argument. Additionally, the exception handling and calls to various lifecycle methods like beforeRemote() and afterRemote() have been removed. The try-catch block is no longer present, so the code change type is 1,5.","Because of the new update method call, there is the potential for different return values, and because the exception handling has been removed, there is also the potential for different exception handlings. So, the CI type is 1,2."
502,<android.nfc.tech.BasicTagTechnology: void connect()>,29,30,<android.nfc.tech.BasicTagTechnology: void connect()>,<android.nfc.tech.BasicTagTechnology: void connect()>,0,"{
    try {
        int errorCode = mTag.getTagService().connect(mTag.getServiceHandle(), mSelectedTechnology);
        if (errorCode == ErrorCodes.SUCCESS) {
            // Store this in the tag object
            mTag.setConnectedTechnology(mSelectedTechnology);
            mIsConnected = true;
        } else if (errorCode == ErrorCodes.ERROR_NOT_SUPPORTED) {
            throw new UnsupportedOperationException(""Connecting to "" + ""this technology is not supported by the NFC "" + ""adapter."");
        } else {
            throw new IOException();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        throw new IOException(""NFC service died"");
    }
}","{
    try {
        int errorCode = mTag.getTagService().connect(mTag.getServiceHandle(), mSelectedTechnology);
        if (errorCode == ErrorCodes.SUCCESS) {
            // Store this in the tag object
            if (!mTag.setConnectedTechnology(mSelectedTechnology)) {
                Log.e(TAG, ""Close other technology first!"");
                throw new IOException(""Only one TagTechnology can be connected at a time."");
            }
            mIsConnected = true;
        } else if (errorCode == ErrorCodes.ERROR_NOT_SUPPORTED) {
            throw new UnsupportedOperationException(""Connecting to "" + ""this technology is not supported by the NFC "" + ""adapter."");
        } else {
            throw new IOException();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        throw new IOException(""NFC service died"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The change includes modifying the control dependency by adding an if statement that checks the return value of mTag.setConnectedTechnology(mSelectedTechnology) and includes a new IOException throw inside this new control statement. Additionally, a new log message is also part of the changes. These account for the change types 2 for the new exception handling, 3 for the control dependency change, and 4 for the other statement changed.","The CI types are 1 and 2 because the addition of new control dependency and exception handling could lead to different behaviors, such as throwing a new IOException that was not present in the early version and the potential modification of the mIsConnected variable's behavior."
503,<android.service.autofill.SaveInfo: String toString()>,29,30,<android.service.autofill.SaveInfo: String toString()>,<android.service.autofill.SaveInfo: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""SaveInfo: [type="").append(DebugUtils.flagsToString(SaveInfo.class, ""SAVE_DATA_TYPE_"", mType)).append("", requiredIds="").append(Arrays.toString(mRequiredIds)).append("", style="").append(DebugUtils.flagsToString(SaveInfo.class, ""NEGATIVE_BUTTON_STYLE_"", mNegativeButtonStyle));
    if (mOptionalIds != null) {
        builder.append("", optionalIds="").append(Arrays.toString(mOptionalIds));
    }
    if (mDescription != null) {
        builder.append("", description="").append(mDescription);
    }
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mCustomDescription != null) {
        builder.append("", customDescription="").append(mCustomDescription);
    }
    if (mValidator != null) {
        builder.append("", validator="").append(mValidator);
    }
    if (mSanitizerKeys != null) {
        builder.append("", sanitizerKeys="").append(mSanitizerKeys.length);
    }
    if (mSanitizerValues != null) {
        builder.append("", sanitizerValues="").append(mSanitizerValues.length);
    }
    if (mTriggerId != null) {
        builder.append("", triggerId="").append(mTriggerId);
    }
    return builder.append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""SaveInfo: [type="").append(DebugUtils.flagsToString(SaveInfo.class, ""SAVE_DATA_TYPE_"", mType)).append("", requiredIds="").append(Arrays.toString(mRequiredIds)).append("", negative style="").append(DebugUtils.flagsToString(SaveInfo.class, ""NEGATIVE_BUTTON_STYLE_"", mNegativeButtonStyle)).append("", positive style="").append(DebugUtils.flagsToString(SaveInfo.class, ""POSITIVE_BUTTON_STYLE_"", mPositiveButtonStyle));
    if (mOptionalIds != null) {
        builder.append("", optionalIds="").append(Arrays.toString(mOptionalIds));
    }
    if (mDescription != null) {
        builder.append("", description="").append(mDescription);
    }
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mCustomDescription != null) {
        builder.append("", customDescription="").append(mCustomDescription);
    }
    if (mValidator != null) {
        builder.append("", validator="").append(mValidator);
    }
    if (mSanitizerKeys != null) {
        builder.append("", sanitizerKeys="").append(mSanitizerKeys.length);
    }
    if (mSanitizerValues != null) {
        builder.append("", sanitizerValues="").append(mSanitizerValues.length);
    }
    if (mTriggerId != null) {
        builder.append("", triggerId="").append(mTriggerId);
    }
    return builder.append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new string literal ""positive style="" and method call DebugUtils.flagsToString(SaveInfo.class, ""POSITIVE_BUTTON_STYLE_"", mPositiveButtonStyle)) have been added to the StringBuilder append chain without affecting any control flow, so the change type is 4.","This is an addition of debug information that does not affect the method's behavior or public contract. It does add additional information to the string representation, but since this is purely for debug purposes and does not influence the functionality or structure of the SaveInfo object, this would not cause a compatibility issue. The public contract of the API remains the same regardless of the added debug text, and it would only be present when debugging is enabled, so the CI type is 0."
504,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int,Theme)>",29,30,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int,Theme)>","<android.content.res.Resources: Drawable getDrawableForDensity(int,int,Theme)>",0,"{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValueForDensity(id, density, value, true);
        return impl.loadDrawable(this, value, id, density, theme);
    } finally {
        releaseTempTypedValue(value);
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValueForDensity(id, density, value, true);
        return loadDrawable(value, id, density, theme);
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI and styled for the specified theme.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density The desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}. A value of 0 means to use the
 * density returned from {@link #getConfiguration()}.
 * This is equivalent to calling {@link #getDrawable(int, Theme)}.
 * @param theme The theme used to style the drawable attributes, may be {@code null} if the
 * drawable cannot be decoded.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
","/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI and styled for the specified theme.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density The desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}. A value of 0 means to use the
 * density returned from {@link #getConfiguration()}.
 * This is equivalent to calling {@link #getDrawable(int, Theme)}.
 * @param theme The theme used to style the drawable attributes, may be {@code null} if the
 * drawable cannot be decoded.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",1,"The method from which 'loadDrawable' is being called has changed from impl.loadDrawable to loadDrawable. This is an internal call change within the class, which could reflect a dependent API change since it refers to a different method (even if it's still within the same class). Moreover, no 'if' or 'try' blocks have changed and no new exceptions are thrown, so the code change type is 4,5.","Since 'loadDrawable' is called on a different object or within a different context in the late version, it has the potential to return a different result than in the early version. This means there could be different behavior and therefore it qualifies as a CI of type 1."
505,<android.app.AlarmManager: void setTimeZone(String)>,29,30,<android.app.AlarmManager: void setTimeZone(String)>,<android.app.AlarmManager: void setTimeZone(String)>,0,"{
    if (TextUtils.isEmpty(timeZone)) {
        return;
    }
    // Reject this timezone if it isn't an Olson zone we recognize.
    if (mTargetSdkVersion >= Build.VERSION_CODES.M) {
        boolean hasTimeZone = false;
        try {
            hasTimeZone = ZoneInfoDB.getInstance().hasTimeZone(timeZone);
        } catch (IOException ignored) {
        }
        if (!hasTimeZone) {
            throw new IllegalArgumentException(""Timezone: "" + timeZone + "" is not an Olson ID"");
        }
    }
    try {
        mService.setTimeZone(timeZone);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}","{
    if (TextUtils.isEmpty(timeZone)) {
        return;
    }
    // Reject this timezone if it isn't an Olson zone we recognize.
    if (mTargetSdkVersion >= Build.VERSION_CODES.M) {
        boolean hasTimeZone = false;
        try {
            hasTimeZone = ZoneInfoDb.getInstance().hasTimeZone(timeZone);
        } catch (IOException ignored) {
        }
        if (!hasTimeZone) {
            throw new IllegalArgumentException(""Timezone: "" + timeZone + "" is not an Olson ID"");
        }
    }
    try {
        mService.setTimeZone(timeZone);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the system's persistent default time zone. This is the time zone for all apps, even
 * after a reboot. Use {@link java.util.TimeZone#setDefault} if you just want to change the
 * time zone within your app, and even then prefer to pass an explicit
 * {@link java.util.TimeZone} to APIs that require it rather than changing the time zone for
 * all threads.
 *
 * <p> On android M and above, it is an error to pass in a non-Olson timezone to this
 * function. Note that this is a bad idea on all Android releases because POSIX and
 * the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}
 * in the same non-Olson ID.
 *
 * @param timeZone one of the Olson ids from the list returned by
 * {@link java.util.TimeZone#getAvailableIDs}
 */
","/**
 * Sets the system's persistent default time zone. This is the time zone for all apps, even
 * after a reboot. Use {@link java.util.TimeZone#setDefault} if you just want to change the
 * time zone within your app, and even then prefer to pass an explicit
 * {@link java.util.TimeZone} to APIs that require it rather than changing the time zone for
 * all threads.
 *
 * <p> On android M and above, it is an error to pass in a non-Olson timezone to this
 * function. Note that this is a bad idea on all Android releases because POSIX and
 * the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}
 * in the same non-Olson ID.
 *
 * @param timeZone one of the Olson ids from the list returned by
 * {@link java.util.TimeZone#getAvailableIDs}
 */
",-1,[@RequiresPermission(android.Manifest.permission.SET_TIME_ZONE)],[@RequiresPermission(android.Manifest.permission.SET_TIME_ZONE)],-1,-1,-1,-1,-1,-1,4,0,"The change is only in the case of letters, from `ZoneInfoDB` to `ZoneInfoDb` which does not affect the method logic, behavior, or signature. Thus it is classified as an 'Other statement changed' due to the superficial change in the name, but the actual reference remains the same since Java is case-sensitive for class names and this would be considered the same class. The code change type is 4.","There is no compatibility issue here since the behavior of the `setTimeZone` method remains unchanged. The difference in capitalization does not affect the execution logic or outcome of the method. The referenced class or object (ZoneInfoDb/ZoneInfoDB) is assumed to be the same given Java's case sensitivity for class names. Therefore, actual functionality will not differ between these versions for clients using this API correctly with the right case in place. The CI type is 0."
506,<android.view.WindowInsets.Builder: Builder setDisplayCutout(DisplayCutout)>,29,30,<android.view.WindowInsets.Builder: Builder setDisplayCutout(DisplayCutout)>,<android.view.WindowInsets.Builder: Builder setDisplayCutout(DisplayCutout)>,0,"{
    mDisplayCutout = displayCutout != null ? displayCutout : DisplayCutout.NO_CUTOUT;
    return this;
}","{
    mDisplayCutout = displayCutout != null ? displayCutout : DisplayCutout.NO_CUTOUT;
    if (!mDisplayCutout.isEmpty()) {
        final Insets safeInsets = Insets.of(mDisplayCutout.getSafeInsets());
        final int index = indexOf(DISPLAY_CUTOUT);
        mTypeInsetsMap[index] = safeInsets;
        mTypeMaxInsetsMap[index] = safeInsets;
        mTypeVisibilityMap[index] = true;
    }
    return this;
}",1,"/**
 * Sets the display cutout.
 *
 * @see #getDisplayCutout()
 * @param displayCutout the display cutout or null if there is none
 * @return itself
 */
","/**
 * Sets the display cutout.
 *
 * @see #getDisplayCutout()
 * @param displayCutout the display cutout or null if there is none
 * @return itself
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The method's implementation in the late version includes additional statements that update some internal structures if the DisplayCutout is not empty. However, these new statements do not change the return type or value directly, so the change type is 4 (Other statement changed).","There is no Compatibility Issue since the additional statements are internally setting values and the returned value (`this`, which is the Builder itself) remains the same. The method's contract and return behaviour have not changed, so it does not introduce potential different return values or exceptions."
507,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdList()>,29,30,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdList()>,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdList()>,0,"{
    String[] cameraIds = null;
    synchronized (mLock) {
        // Try to make sure we have an up-to-date list of camera devices.
        connectCameraServiceLocked();
        int idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            idCount++;
        }
        cameraIds = new String[idCount];
        idCount = 0;
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            int status = mDeviceStatus.valueAt(i);
            if (status == ICameraServiceListener.STATUS_NOT_PRESENT || status == ICameraServiceListener.STATUS_ENUMERATING)
                continue;
            cameraIds[idCount] = mDeviceStatus.keyAt(i);
            idCount++;
        }
    }
    // The sort logic must match the logic in
    // libcameraservice/common/CameraProviderManager.cpp::getAPI1CompatibleCameraDeviceIds
    Arrays.sort(cameraIds, new Comparator<String>() {

        @Override
        public int compare(String s1, String s2) {
            int s1Int = 0, s2Int = 0;
            try {
                s1Int = Integer.parseInt(s1);
            } catch (NumberFormatException e) {
                s1Int = -1;
            }
            try {
                s2Int = Integer.parseInt(s2);
            } catch (NumberFormatException e) {
                s2Int = -1;
            }
            // Uint device IDs first
            if (s1Int >= 0 && s2Int >= 0) {
                return s1Int - s2Int;
            } else if (s1Int >= 0) {
                return -1;
            } else if (s2Int >= 0) {
                return 1;
            } else {
                // Simple string compare if both id are not uint
                return s1.compareTo(s2);
            }
        }
    });
    return cameraIds;
}","{
    String[] cameraIds = null;
    synchronized (mLock) {
        // Try to make sure we have an up-to-date list of camera devices.
        connectCameraServiceLocked();
        cameraIds = extractCameraIdListLocked();
    }
    sortCameraIds(cameraIds);
    return cameraIds;
}",1,"/**
 * Get a list of all camera IDs that are at least PRESENT; ignore devices that are
 * NOT_PRESENT or ENUMERATING, since they cannot be used by anyone.
 */
","/**
 * Get a list of all camera IDs that are at least PRESENT; ignore devices that are
 * NOT_PRESENT or ENUMERATING, since they cannot be used by anyone.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The late implementation introduces new methods extractCameraIdListLocked() and sortCameraIds(), and removes the previous for loops and the anonymous Comparator class. These changes include control dependency change due to different methods of generating the cameraIds array, other statement change as new helper methods are used, and dependent API changed because the implementation now relies on new internal APIs.","The CI type is 1 because the replaced code could potentially lead to a different order or content of the cameraIds array returned. The introduction of new internal methods could change how the 'cameraIds' array is populated and how it is sorted before being returned. The API now depends on the correct implementation of these new internal methods to produce the same output. If there are differences in the behavior of the new methods compared to the old code, this could lead to a Compatibility Issue."
508,"<android.os.UserManager: CharSequence getBadgedLabelForUser(CharSequence,UserHandle)>",29,30,"<android.os.UserManager: CharSequence getBadgedLabelForUser(CharSequence,UserHandle)>","<android.os.UserManager: CharSequence getBadgedLabelForUser(CharSequence,UserHandle)>",0,"{
    return mContext.getPackageManager().getUserBadgedLabel(label, user);
}","{
    final int userId = user.getIdentifier();
    if (!hasBadge(userId)) {
        return label;
    }
    try {
        final int resourceId = mService.getUserBadgeLabelResId(userId);
        return Resources.getSystem().getString(resourceId, label);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * If the target user is a managed profile of the calling user or the caller
 * is itself a managed profile, then this returns a copy of the label with
 * badging for accessibility services like talkback. E.g. passing in ""Email""
 * and it might return ""Work Email"" for Email in the work profile.
 *
 * @param label The label to change.
 * @param user The target user.
 * @return A label that combines the original label and a badge as
 * determined by the system.
 * @removed
 */
","/**
 * If the target user is a profile of the calling user or the caller
 * is itself a profile, then this returns a copy of the label with
 * badging for accessibility services like talkback. E.g. passing in ""Email""
 * and it might return ""Work Email"" for Email in the work profile.
 *
 * <p>Requires {@link android.Manifest.permission#MANAGE_USERS} or
 * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} permission, otherwise the caller
 * must be in the same profile group of specified user.
 *
 * @param label The label to change.
 * @param user The target user.
 * @return A label that combines the original label and a badge as
 * determined by the system.
 * @removed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The late implementation introduces several changes:,- Use of a new method `mService.getUserBadgeLabelResId(userId)` which wasn't present in the early version.
509,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",29,30,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>","<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",0,"{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodDebug.startInputReasonToString(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    if (windowGainingFocus == null) {
        windowGainingFocus = view.getWindowToken();
        if (windowGainingFocus == null) {
            Log.e(TAG, ""ABORT input: ServedView must be attached to a Window"");
            return false;
        }
        startInputFlags |= StartInputFlags.VIEW_HAS_FOCUS;
        if (view.onCheckIsTextEditor()) {
            startInputFlags |= StartInputFlags.IS_TEXT_EDITOR;
        }
        softInputMode = view.getViewRootImpl().mWindowAttributes.softInputMode;
        windowFlags = view.getViewRootImpl().mWindowAttributes.flags;
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(() -> startInputInner(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" mServedView="" + dumpViewInfo(mServedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            startInputFlags |= StartInputFlags.INITIAL_CONNECTION;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        maybeCallServedViewChangedLocked(tba);
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, startInputFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags, view.getContext().getApplicationInfo().targetSdkVersion);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res == null) {
                Log.wtf(TAG, ""startInputOrWindowGainedFocus must not return"" + "" null. startInputReason="" + InputMethodDebug.startInputReasonToString(startInputReason) + "" editorInfo="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
                return false;
            }
            mActivityViewToScreenMatrix = res.getActivityViewToScreenMatrix();
            if (res.id != null) {
                setInputChannelLocked(res.channel);
                mBindSequence = res.sequence;
                mCurMethod = res.method;
                mCurId = res.id;
            } else if (res.channel != null && res.channel != mCurChannel) {
                res.channel.dispose();
            }
            switch(res.result) {
                case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                    mRestartOnNextWindowFocus = true;
                    break;
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = getServedViewLocked();
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodDebug.startInputReasonToString(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    if (windowGainingFocus == null) {
        windowGainingFocus = view.getWindowToken();
        if (windowGainingFocus == null) {
            Log.e(TAG, ""ABORT input: ServedView must be attached to a Window"");
            return false;
        }
        startInputFlags = getStartInputFlags(view, startInputFlags);
        softInputMode = view.getViewRootImpl().mWindowAttributes.softInputMode;
        windowFlags = view.getViewRootImpl().mWindowAttributes.flags;
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(() -> mDelegate.startInput(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.autofillId = view.getAutofillId();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // Now that we are locked again, validate that our state hasn't
        // changed.
        final View servedView = getServedViewLocked();
        if (servedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" servedView="" + dumpViewInfo(servedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            startInputFlags |= StartInputFlags.INITIAL_CONNECTION;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        maybeCallServedViewChangedLocked(tba);
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this, view);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, startInputFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags, view.getContext().getApplicationInfo().targetSdkVersion);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res == null) {
                Log.wtf(TAG, ""startInputOrWindowGainedFocus must not return"" + "" null. startInputReason="" + InputMethodDebug.startInputReasonToString(startInputReason) + "" editorInfo="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
                return false;
            }
            mActivityViewToScreenMatrix = res.getActivityViewToScreenMatrix();
            if (res.id != null) {
                setInputChannelLocked(res.channel);
                mBindSequence = res.sequence;
                mCurMethod = res.method;
                mCurId = res.id;
            } else if (res.channel != null && res.channel != mCurChannel) {
                res.channel.dispose();
            }
            switch(res.result) {
                case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                    mRestartOnNextWindowFocus = true;
                    break;
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}",1,,"/**
 * Called when {@link DelegateImpl#startInput}, {@link #restartInput(View)},
 * {@link #MSG_BIND} or {@link #MSG_UNBIND}.
 * Note that this method should *NOT* be called inside of {@code mH} lock to prevent start input
 * background thread may blocked by other methods which already inside {@code mH} lock.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
510,<android.app.admin.DevicePolicyManager: int getPasswordComplexity()>,29,30,<android.app.admin.DevicePolicyManager: int getPasswordComplexity()>,<android.app.admin.DevicePolicyManager: int getPasswordComplexity()>,0,"{
    throwIfParentInstance(""getPasswordComplexity"");
    if (mService == null) {
        return PASSWORD_COMPLEXITY_NONE;
    }
    try {
        return mService.getPasswordComplexity();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null) {
        return PASSWORD_COMPLEXITY_NONE;
    }
    try {
        return mService.getPasswordComplexity(mParentInstance);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns how complex the current user's screen lock is.
 *
 * <p>Note that when called from a profile which uses an unified challenge with its parent, the
 * screen lock complexity of the parent will be returned. However, this API does not support
 * explicitly querying the parent profile screen lock complexity via {@link
 * #getParentProfileInstance}.
 *
 * @throws IllegalStateException if the user is not unlocked.
 * @throws SecurityException if the calling application does not have the permission
 * {@link permission#REQUEST_PASSWORD_COMPLEXITY}
 */
","/**
 * Returns how complex the current user's screen lock is.
 *
 * <p>Note that when called from a profile which uses an unified challenge with its parent, the
 * screen lock complexity of the parent will be returned.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @throws IllegalStateException if the user is not unlocked.
 * @throws SecurityException     if the calling application does not have the permission
 * {@link permission#REQUEST_PASSWORD_COMPLEXITY}
 */
",-1,"[@PasswordComplexity, @RequiresPermission(android.Manifest.permission.REQUEST_PASSWORD_COMPLEXITY)]","[@PasswordComplexity, @RequiresPermission(android.Manifest.permission.REQUEST_PASSWORD_COMPLEXITY)]",-1,-1,-1,-1,-1,-1,5,0,"The method `mService.getPasswordComplexity()` now takes an additional parameter `mParentInstance` in the late version, which indicates a change in the dependent API, so the code change type is 5.","While the late version of the API uses an additional parameter in the call to `mService.getPasswordComplexity(mParentInstance)`, this should not cause a compatibility issue assuming the `mParentInstance` was correctly instantiated and maintained the same semantic meaning. Since no changes were made to return types, exception handling or control flow, there is no inherent indication of a compatibility issue introduced by this change alone, so the CI type is 0."
511,"<android.util.Half: boolean lessEquals(short,short)>",29,30,"<android.util.Half: boolean lessEquals(short,short)>","<android.util.Half: boolean lessEquals(short,short)>",0,"{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) <= ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff);
}","{
    return FP16.lessEquals(x, y);
}",1,"/**
 * Returns true if the first half-precision float value is less (smaller
 * toward negative infinity) than or equal to the second half-precision
 * float value. If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is less than or equal to y, false otherwise
 */
","/**
 * Returns true if the first half-precision float value is less (smaller
 * toward negative infinity) than or equal to the second half-precision
 * float value. If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is less than or equal to y, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method was entirely replaced with a single line calling FP16.lessEquals(x, y), which indicates the logic of comparing two half-precision floats has been delegated to another method (dependent API). So, the code change types are 1 and 5.","Since the implementation now relies on the behavior of FP16.lessEquals(x, y), the actual execution and result could potentially differ from the previous implementation, thus leading to a different return value. Therefore, the CI type is 1."
512,<android.speech.tts.TextToSpeech: Voice getDefaultVoice()>,29,30,<android.speech.tts.TextToSpeech: Voice getDefaultVoice()>,<android.speech.tts.TextToSpeech: Voice getDefaultVoice()>,0,"{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String[] defaultLanguage = service.getClientDefaultLanguage();
            if (defaultLanguage == null || defaultLanguage.length == 0) {
                Log.e(TAG, ""service.getClientDefaultLanguage() returned empty array"");
                return null;
            }
            String language = defaultLanguage[0];
            String country = (defaultLanguage.length > 1) ? defaultLanguage[1] : """";
            String variant = (defaultLanguage.length > 2) ? defaultLanguage[2] : """";
            // Sanitize the locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result < LANG_AVAILABLE) {
                // The default language is not supported.
                return null;
            }
            // Get the default voice name
            String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            // Find it
            List<Voice> voices = service.getVoices();
            if (voices == null) {
                return null;
            }
            for (Voice voice : voices) {
                if (voice.getName().equals(voiceName)) {
                    return voice;
                }
            }
            return null;
        }
    }, null, ""getDefaultVoice"");
}","{
    return runAction((ITextToSpeechService service) -> {
        String[] defaultLanguage = service.getClientDefaultLanguage();
        if (defaultLanguage == null || defaultLanguage.length == 0) {
            Log.e(TAG, ""service.getClientDefaultLanguage() returned empty array"");
            return null;
        }
        String language = defaultLanguage[0];
        String country = (defaultLanguage.length > 1) ? defaultLanguage[1] : """";
        String variant = (defaultLanguage.length > 2) ? defaultLanguage[2] : """";
        // Sanitize the locale using isLanguageAvailable.
        int result = service.isLanguageAvailable(language, country, variant);
        if (result < LANG_AVAILABLE) {
            // The default language is not supported.
            return null;
        }
        // Get the default voice name
        String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
        if (TextUtils.isEmpty(voiceName)) {
            return null;
        }
        // Find it
        List<Voice> voices = service.getVoices();
        if (voices == null) {
            return null;
        }
        for (Voice voice : voices) {
            if (voice.getName().equals(voiceName)) {
                return voice;
            }
        }
        return null;
    }, null, ""getDefaultVoice"");
}",1,"/**
 * Returns a Voice instance that's the default voice for the default Text-to-speech language.
 * @return The default voice instance for the default language, or {@code null} if not set or
 * on error.
 */
","/**
 * Returns a Voice instance that's the default voice for the default Text-to-speech language.
 * @return The default voice instance for the default language, or {@code null} if not set or
 * on error.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has been refactored from an anonymous inner class to a lambda expression, which indeed changes the syntax but does not alter the method's behavior. Therefore, the change type is 4 (Other statement changed).","This refactoring does not affect the API's behavior because the executed logic remains the same. Therefore, there is no Compatibility Issue in this case."
514,<android.view.View: boolean isImportantForAccessibility()>,29,30,<android.view.View: boolean isImportantForAccessibility()>,<android.view.View: boolean isImportantForAccessibility()>,0,"{
    final int mode = (mPrivateFlags2 & PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_MASK) >> PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_SHIFT;
    if (mode == IMPORTANT_FOR_ACCESSIBILITY_NO || mode == IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS) {
        return false;
    }
    // Check parent mode to ensure we're not hidden.
    ViewParent parent = mParent;
    while (parent instanceof View) {
        if (((View) parent).getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS) {
            return false;
        }
        parent = parent.getParent();
    }
    return mode == IMPORTANT_FOR_ACCESSIBILITY_YES || isActionableForAccessibility() || hasListenersForAccessibility() || getAccessibilityNodeProvider() != null || getAccessibilityLiveRegion() != ACCESSIBILITY_LIVE_REGION_NONE || isAccessibilityPane();
}","{
    final int mode = getImportantForAccessibility();
    if (mode == IMPORTANT_FOR_ACCESSIBILITY_NO || mode == IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS) {
        return false;
    }
    // Check parent mode to ensure we're not hidden.
    ViewParent parent = mParent;
    while (parent instanceof View) {
        if (((View) parent).getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS) {
            return false;
        }
        parent = parent.getParent();
    }
    return mode == IMPORTANT_FOR_ACCESSIBILITY_YES || isActionableForAccessibility() || hasListenersForAccessibility() || getAccessibilityNodeProvider() != null || getAccessibilityLiveRegion() != ACCESSIBILITY_LIVE_REGION_NONE || isAccessibilityPane();
}",1,"/**
 * Computes whether this view should be exposed for accessibility. In
 * general, views that are interactive or provide information are exposed
 * while views that serve only as containers are hidden.
 * <p>
 * If an ancestor of this view has importance
 * {@link #IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS}, this method
 * returns <code>false</code>.
 * <p>
 * Otherwise, the value is computed according to the view's
 * {@link #getImportantForAccessibility()} value:
 * <ol>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_NO} or
 * {@link #IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS}, return <code>false
 * </code>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_YES}, return <code>true</code>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_AUTO}, return <code>true</code> if
 * view satisfies any of the following:
 * <ul>
 * <li>Is actionable, e.g. {@link #isClickable()},
 * {@link #isLongClickable()}, or {@link #isFocusable()}
 * <li>Has an {@link AccessibilityDelegate}
 * <li>Has an interaction listener, e.g. {@link OnTouchListener},
 * {@link OnKeyListener}, etc.
 * <li>Is an accessibility live region, e.g.
 * {@link #getAccessibilityLiveRegion()} is not
 * {@link #ACCESSIBILITY_LIVE_REGION_NONE}.
 * </ul>
 * <li>Has an accessibility pane title, see {@link #setAccessibilityPaneTitle}</li>
 * </ol>
 *
 * @return Whether the view is exposed for accessibility.
 * @see #setImportantForAccessibility(int)
 * @see #getImportantForAccessibility()
 */
","/**
 * Computes whether this view should be exposed for accessibility. In
 * general, views that are interactive or provide information are exposed
 * while views that serve only as containers are hidden.
 * <p>
 * If an ancestor of this view has importance
 * {@link #IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS}, this method
 * returns <code>false</code>.
 * <p>
 * Otherwise, the value is computed according to the view's
 * {@link #getImportantForAccessibility()} value:
 * <ol>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_NO} or
 * {@link #IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS}, return <code>false
 * </code>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_YES}, return <code>true</code>
 * <li>{@link #IMPORTANT_FOR_ACCESSIBILITY_AUTO}, return <code>true</code> if
 * view satisfies any of the following:
 * <ul>
 * <li>Is actionable, e.g. {@link #isClickable()},
 * {@link #isLongClickable()}, or {@link #isFocusable()}
 * <li>Has an {@link AccessibilityDelegate}
 * <li>Has an interaction listener, e.g. {@link OnTouchListener},
 * {@link OnKeyListener}, etc.
 * <li>Is an accessibility live region, e.g.
 * {@link #getAccessibilityLiveRegion()} is not
 * {@link #ACCESSIBILITY_LIVE_REGION_NONE}.
 * </ul>
 * <li>Has an accessibility pane title, see {@link #setAccessibilityPaneTitle}</li>
 * </ol>
 *
 * @return Whether the view is exposed for accessibility.
 * @see #setImportantForAccessibility(int)
 * @see #getImportantForAccessibility()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change in the code is the method used to obtain the `mode`: the early version uses bitwise operation on field `mPrivateFlags2` to get the `mode`, while the late version uses the method `getImportantForAccessibility()` to get the `mode`. This indicates a change of the dependent API, so the code change type is 5.","Although the mechanism to calculate the `mode` has changed from direct bitwise operations to a method call, this does not inherently introduce a compatibility issue as long as the `getImportantForAccessibility()` method returns the same value. Both versions perform the same logical checks and return the same boolean value under the same conditions, so as long as the dependent API maintains its contract, no CI is introduced. Therefore, the CI type is 0."
515,<android.util.AtomicFile: void finishWrite(FileOutputStream)>,29,30,<android.util.AtomicFile: void finishWrite(FileOutputStream)>,<android.util.AtomicFile: void finishWrite(FileOutputStream)>,0,"{
    if (str != null) {
        FileUtils.sync(str);
        try {
            str.close();
            mBackupName.delete();
        } catch (IOException e) {
            Log.w(""AtomicFile"", ""finishWrite: Got exception:"", e);
        }
        if (mCommitTag != null) {
            com.android.internal.logging.EventLogTags.writeCommitSysConfigFile(mCommitTag, SystemClock.uptimeMillis() - mStartTime);
        }
    }
}","{
    if (str == null) {
        return;
    }
    if (!FileUtils.sync(str)) {
        Log.e(LOG_TAG, ""Failed to sync file output stream"");
    }
    try {
        str.close();
    } catch (IOException e) {
        Log.e(LOG_TAG, ""Failed to close file output stream"", e);
    }
    rename(mNewName, mBaseName);
    if (mCommitTag != null) {
        com.android.internal.logging.EventLogTags.writeCommitSysConfigFile(mCommitTag, SystemClock.uptimeMillis() - mStartTime);
    }
}",1,"/**
 * Call when you have successfully finished writing to the stream
 * returned by {@link #startWrite()}.  This will close, sync, and
 * commit the new data.  The next attempt to read the atomic file
 * will return the new file stream.
 */
","/**
 * Call when you have successfully finished writing to the stream
 * returned by {@link #startWrite()}.  This will close, sync, and
 * commit the new data.  The next attempt to read the atomic file
 * will return the new file stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The control dependency has changed with the introduction of a new condition (if the stream is null, it now immediately returns), a return statement is deleted (mBackupName.delete()), and new statements are added (Log error on failed sync and an explicit renaming of the file with rename(mNewName, mBaseName). Additionally, FileUtils.sync(str) now has its return value checked, and there's a change in the exception handling message, which now logs a different message when failing to close the stream. Thus, the change types are 1, 3, and 4.","Although there are changes, none of them seems to cause a Compatibility Issue. The change in control flow ensures that the method behaves correctly by not proceeding with a null stream, which does not change the observable API behavior in terms of different return types or potential exceptions (since the method's return type is void and the exception log does not affect API behavior). Additionally, the deletion of mBackupName.delete() might imply a behavior change, but since this is an internal cleanup mechanism, it does not affect the outward-facing behavior of the method as perceived by the caller. The failure to sync or close the stream does not introduce new exceptions thrown to the callers; it merely changes the way these errors are logged internally. The renaming of the file is an internal change but should not affect API behavior since this is an implementation detail. There is no indication that the behavior as experienced by the API consumer would be different, therefore, there is no Compatibility Issue."
518,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",29,30,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>","<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        if (mWrapped != null)
            return mWrapped.update(uri, values, where, selectionArgs);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mPackageName, uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    return update(uri, values, createSqlQueryBundle(where, selectionArgs));
}",1,"/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
","/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
",-1,[@Override],,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the update method has completely changed from invoking a provider's update method directly to invoking another overload of the update method. This represents a change in the dependent API (5) because it's now relying on a different overload of the same method. Since the new implementation calls a different method and does not perform the same operations, there are also changes in other statements (4) and the return statement has changed (1) because it's now calling a different method that might return different values.",This modification introduced a Compatibility Issue with return values (1) because the implementation has been changed to call a different method which could potentially return a different result.
519,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",29,30,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    final boolean wasVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        if (mIsPreRendered) {
            if (DEBUG) {
                Log.v(TAG, ""Making IME window visible"");
            }
            applyVisibilityInInsetsConsumer(true);
            onPreRenderedWindowVisibilityChanged(true);
        } else {
            showWindow(true);
        }
    }
    // If user uses hard keyboard, IME button should always be shown.
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
    final boolean isVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_SHOWN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    // TODO(b/148086656): Disallow IME developers from calling InputMethodImpl methods.
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingShowSoftInput) {
        Log.e(TAG, "" IME shouldn't call showSoftInput on itself."" + "" Use requestShowSelf(int) itself"");
        return;
    }
    final boolean wasVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        if (mIsPreRendered) {
            if (DEBUG) {
                Log.v(TAG, ""Making IME window visible"");
            }
            onPreRenderedWindowVisibilityChanged(true);
        } else {
            showWindow(true);
        }
        applyVisibilityInInsetsConsumerIfNecessary(true);
    }
    // If user uses hard keyboard, IME button should always be shown.
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
    final boolean isVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_SHOWN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,"1,3,4",0,"The change includes introduction of a new block checking `targetSdkVersion` and exiting the method early, modification in the sequence of method calls within the `dispatchOnShowInputRequested(flags, false)` block where `applyVisibilityInInsetsConsumer(true)` was called before `onPreRenderedWindowVisibilityChanged(true)` and is now called after as `applyVisibilityInInsetsConsumerIfNecessary(true)`. Also, there's introduction of a new logging statement. Therefore, the change types are 1, 3, and 4 since there were changes in control flow (early return introduced), return statements (method may exit without executing subsequent lines), and other statements (new log and method call with a slightly different name).","The introduction of a new early-return condition could potentially prevent all subsequent code from running, but this depends on whether `getApplicationInfo().targetSdkVersion` is greater than or equal to `Build.VERSION_CODES.R` and `mSystemCallingShowSoftInput` is false. The method itself does not cause a direct Compatibility Issue, as the behavior depends on the application's target SDK version. The refactored method calls and reordered logic are also not directly causing a different value or exception to be returned or thrown based on the method logic provided. Thus, the actual behavior change as a result of these modifications is subject to specific conditions outside of the method itself, meaning there should be no Compatibility Issue directly caused by these changes."
520,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            int requestId = mRepeatingRequestId;
            mRepeatingRequestId = REQUEST_ID_NONE;
            int[] requestTypes = mRepeatingRequestTypes;
            mRepeatingRequestTypes = null;
            long lastFrameNumber;
            try {
                lastFrameNumber = mRemoteDevice.cancelRequest(requestId);
            } catch (IllegalArgumentException e) {
                if (DEBUG) {
                    Log.v(TAG, ""Repeating request was already stopped for request "" + requestId);
                }
                // Repeating request was already stopped. Nothing more to do.
                return;
            }
            checkEarlyTriggerSequenceComplete(requestId, lastFrameNumber, requestTypes);
        }
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            int requestId = mRepeatingRequestId;
            mRepeatingRequestId = REQUEST_ID_NONE;
            int[] requestTypes = mRepeatingRequestTypes;
            mRepeatingRequestTypes = null;
            long lastFrameNumber;
            try {
                lastFrameNumber = mRemoteDevice.cancelRequest(requestId);
            } catch (IllegalArgumentException e) {
                if (DEBUG) {
                    Log.v(TAG, ""Repeating request was already stopped for request "" + requestId);
                }
                // Repeating request was already stopped. Nothing more to do.
                return;
            }
            checkEarlyTriggerSequenceCompleteLocked(requestId, lastFrameNumber, requestTypes);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the method called within the try block from checkEarlyTriggerSequenceComplete() to checkEarlyTriggerSequenceCompleteLocked(). This code change is a method call change, therefore, it is classified as type 4, which is Other statement changed.","Since the change is isolated to the name of the method call and there is no information provided that suggests the behavior of the method has changed, this alteration should not lead to any Compatibility Issues. The internal logic of how the sequence check is performed remains encapsulated within the method itself, whether it is called checkEarlyTriggerSequenceComplete() or checkEarlyTriggerSequenceCompleteLocked(). Thus, there is no Compatibility Issue."
522,"<android.database.sqlite.SQLiteQueryBuilder: int update(SQLiteDatabase,ContentValues,String,String[])>",29,30,"<android.database.sqlite.SQLiteQueryBuilder: int update(SQLiteDatabase,ContentValues,String,String[])>","<android.database.sqlite.SQLiteQueryBuilder: int update(SQLiteDatabase,ContentValues,String,String[])>",0,"{
    Objects.requireNonNull(mTables, ""No tables defined"");
    Objects.requireNonNull(db, ""No database defined"");
    Objects.requireNonNull(values, ""No values defined"");
    final String sql;
    final String unwrappedSql = buildUpdate(values, selection);
    if (mStrict) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        // NOTE: The ordering of the below operations is important; we must
        // execute the wrapped query to ensure the untrusted clause has been
        // fully isolated.
        // Validate the unwrapped query
        // will throw if query is invalid
        db.validateSql(unwrappedSql, null);
        // Execute wrapped query for extra protection
        final String wrappedSql = buildUpdate(values, wrap(selection));
        sql = wrappedSql;
    } else {
        // Execute unwrapped query
        sql = unwrappedSql;
    }
    if (selectionArgs == null) {
        selectionArgs = EmptyArray.STRING;
    }
    final ArrayMap<String, Object> rawValues = values.getValues();
    final int valuesLength = rawValues.size();
    final Object[] sqlArgs = new Object[valuesLength + selectionArgs.length];
    for (int i = 0; i < sqlArgs.length; i++) {
        if (i < valuesLength) {
            sqlArgs[i] = rawValues.valueAt(i);
        } else {
            sqlArgs[i] = selectionArgs[i - valuesLength];
        }
    }
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        if (Build.IS_DEBUGGABLE) {
            Log.d(TAG, sql + "" with args "" + Arrays.toString(sqlArgs));
        } else {
            Log.d(TAG, sql);
        }
    }
    return db.executeSql(sql, sqlArgs);
}","{
    Objects.requireNonNull(mTables, ""No tables defined"");
    Objects.requireNonNull(db, ""No database defined"");
    Objects.requireNonNull(values, ""No values defined"");
    final String sql;
    final String unwrappedSql = buildUpdate(values, selection);
    if (isStrictColumns()) {
        enforceStrictColumns(values);
    }
    if (isStrictGrammar()) {
        enforceStrictGrammar(selection, null, null, null, null);
    }
    if (isStrict()) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        // NOTE: The ordering of the below operations is important; we must
        // execute the wrapped query to ensure the untrusted clause has been
        // fully isolated.
        // Validate the unwrapped query
        // will throw if query is invalid
        db.validateSql(unwrappedSql, null);
        // Execute wrapped query for extra protection
        final String wrappedSql = buildUpdate(values, wrap(selection));
        sql = wrappedSql;
    } else {
        // Execute unwrapped query
        sql = unwrappedSql;
    }
    if (selectionArgs == null) {
        selectionArgs = EmptyArray.STRING;
    }
    final ArrayMap<String, Object> rawValues = values.getValues();
    final int valuesLength = rawValues.size();
    final Object[] sqlArgs = new Object[valuesLength + selectionArgs.length];
    for (int i = 0; i < sqlArgs.length; i++) {
        if (i < valuesLength) {
            sqlArgs[i] = rawValues.valueAt(i);
        } else {
            sqlArgs[i] = selectionArgs[i - valuesLength];
        }
    }
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        if (Build.IS_DEBUGGABLE) {
            Log.d(TAG, sql + "" with args "" + Arrays.toString(sqlArgs));
        } else {
            Log.d(TAG, sql);
        }
    }
    return DatabaseUtils.executeUpdateDelete(db, sql, sqlArgs);
}",1,"/**
 * Perform an update by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to update on
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL {@code WHERE} clause (excluding the {@code WHERE}
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @return the number of rows updated
 */
","/**
 * Perform an update by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to update on
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL {@code WHERE} clause (excluding the {@code WHERE}
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @return the number of rows updated
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 5",1,"Control dependency changed because new methods (isStrictColumns(), enforceStrictColumns(values), isStrictGrammar(), enforceStrictGrammar(selection, null, null, null, null)) are introduced in the control flow which changes how the method behaves based on the strictness checks. A dependent API changed since the method db.executeSql(sql, sqlArgs) has been replaced with DatabaseUtils.executeUpdateDelete(db, sql, sqlArgs), which indicates a change in dependency.",Compatibility Issue arises due to potential different return values or types since the final execution method of the SQL update has been changed from db.executeSql to DatabaseUtils.executeUpdateDelete. This change might potentially affect the return value of the update() method.
523,<android.service.autofill.FillRequest: String toString()>,29,30,<android.service.autofill.FillRequest: String toString()>,<android.service.autofill.FillRequest: String toString()>,0,"{
    return ""FillRequest: [id="" + mId + "", flags="" + mFlags + "", ctxts= "" + mContexts + ""]"";
}","{
    return ""FillRequest { "" + ""id = "" + mId + "", "" + ""fillContexts = "" + mFillContexts + "", "" + ""clientState = "" + mClientState + "", "" + ""flags = "" + requestFlagsToString(mFlags) + "", "" + ""inlineSuggestionsRequest = "" + mInlineSuggestionsRequest + "" }"";
}",1,,,-1,[@Override],"[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"The structure of the returned String has changed, which includes new variables like mInlineSuggestionsRequest and mFillContexts, and a call to a new method requestFlagsToString() for representing mFlags; plus, mContexts has been replaced with mFillContexts. Therefore, the change types are 1 (Return statement changed) and 4 (Other statement changed).","The return statement has been significantly altered to include different information, which means the method will return a different value (String representation) than before. This will cause a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
524,<android.service.notification.NotificationListenerService.Ranking: boolean equals(Object)>,29,30,<android.service.notification.NotificationListenerService.Ranking: boolean equals(Object)>,<android.service.notification.NotificationListenerService.Ranking: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Ranking other = (Ranking) o;
    return Objects.equals(mKey, other.mKey) && Objects.equals(mRank, other.mRank) && Objects.equals(mMatchesInterruptionFilter, other.mMatchesInterruptionFilter) && Objects.equals(mVisibilityOverride, other.mVisibilityOverride) && Objects.equals(mSuppressedVisualEffects, other.mSuppressedVisualEffects) && Objects.equals(mImportance, other.mImportance) && Objects.equals(mImportanceExplanation, other.mImportanceExplanation) && Objects.equals(mOverrideGroupKey, other.mOverrideGroupKey) && Objects.equals(mChannel, other.mChannel) && Objects.equals(mOverridePeople, other.mOverridePeople) && Objects.equals(mSnoozeCriteria, other.mSnoozeCriteria) && Objects.equals(mShowBadge, other.mShowBadge) && Objects.equals(mUserSentiment, other.mUserSentiment) && Objects.equals(mHidden, other.mHidden) && Objects.equals(mLastAudiblyAlertedMs, other.mLastAudiblyAlertedMs) && Objects.equals(mNoisy, other.mNoisy) && // Action.equals() doesn't exist so let's just compare list lengths
    ((mSmartActions == null ? 0 : mSmartActions.size()) == (other.mSmartActions == null ? 0 : other.mSmartActions.size())) && Objects.equals(mSmartReplies, other.mSmartReplies) && Objects.equals(mCanBubble, other.mCanBubble);
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Ranking other = (Ranking) o;
    return Objects.equals(mKey, other.mKey) && Objects.equals(mRank, other.mRank) && Objects.equals(mMatchesInterruptionFilter, other.mMatchesInterruptionFilter) && Objects.equals(mVisibilityOverride, other.mVisibilityOverride) && Objects.equals(mSuppressedVisualEffects, other.mSuppressedVisualEffects) && Objects.equals(mImportance, other.mImportance) && Objects.equals(mImportanceExplanation, other.mImportanceExplanation) && Objects.equals(mOverrideGroupKey, other.mOverrideGroupKey) && Objects.equals(mChannel, other.mChannel) && Objects.equals(mOverridePeople, other.mOverridePeople) && Objects.equals(mSnoozeCriteria, other.mSnoozeCriteria) && Objects.equals(mShowBadge, other.mShowBadge) && Objects.equals(mUserSentiment, other.mUserSentiment) && Objects.equals(mHidden, other.mHidden) && Objects.equals(mLastAudiblyAlertedMs, other.mLastAudiblyAlertedMs) && Objects.equals(mNoisy, other.mNoisy) && // Action.equals() doesn't exist so let's just compare list lengths
    ((mSmartActions == null ? 0 : mSmartActions.size()) == (other.mSmartActions == null ? 0 : other.mSmartActions.size())) && Objects.equals(mSmartReplies, other.mSmartReplies) && Objects.equals(mCanBubble, other.mCanBubble) && Objects.equals(mVisuallyInterruptive, other.mVisuallyInterruptive) && Objects.equals(mIsConversation, other.mIsConversation) && // Shortcutinfo doesn't have equals either; use id
    Objects.equals((mShortcutInfo == null ? 0 : mShortcutInfo.getId()), (other.mShortcutInfo == null ? 0 : other.mShortcutInfo.getId())) && Objects.equals(mIsBubble, other.mIsBubble);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Several new Objects.equals() checks were added for mVisuallyInterruptive, mIsConversation, comparing of mShortcutInfo using getId(), and mIsBubble in the comparison logic. This is an ""Other statement changed"" as additional object properties are being compared. The method also now potentially returns different boolean values due to the additional comparisons, which is a ""Return statement changed.""","The change of implementation potentially leads to different return values (true or false) due to the new properties being compared in the equals method. Since this affects the return value, the CI type is 1."
525,<android.app.Activity: boolean isInMultiWindowMode()>,29,30,<android.app.Activity: boolean isInMultiWindowMode()>,<android.app.Activity: boolean isInMultiWindowMode()>,0,"{
    try {
        return ActivityTaskManager.getService().isInMultiWindowMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}","{
    return mIsInMultiWindowMode;
}",1,"/**
 * Returns true if the activity is currently in multi-window mode.
 * @see android.R.attr#resizeableActivity
 *
 * @return True if the activity is in multi-window mode.
 */
","/**
 * Returns true if the activity is currently in multi-window mode.
 * @see android.R.attr#resizeableActivity
 *
 * @return True if the activity is in multi-window mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has changed from making a service call to a simple member variable access, and there is no longer an attempt to catch a RemoteException. Therefore, the changes are in the return statement and the dependent API as the reliance on `ActivityTaskManager.getService().isInMultiWindowMode(mToken)` was removed, making the change types 1 and 5.","Since the implementation has been changed from a system service call to a direct variable return, which can potentially provide different output (especially if the variable 'mIsInMultiWindowMode' isn't updated consistently with the result of the system service call), there is a potential compatibility issue due to different return values or types. Hence, the CI type is 1."
526,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,29,30,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,0,"{
    EntityConfidence entityConfidence = new EntityConfidence(mTypeScoreMap);
    return new TextClassification(mText, mLegacyIcon, mLegacyLabel, mLegacyIntent, mLegacyOnClickListener, mActions, entityConfidence, mId, buildExtras(entityConfidence));
}","{
    EntityConfidence entityConfidence = new EntityConfidence(mTypeScoreMap);
    return new TextClassification(mText, mLegacyIcon, mLegacyLabel, mLegacyIntent, mLegacyOnClickListener, mActions, entityConfidence, mId, mExtras == null ? Bundle.EMPTY : mExtras);
}",1,"/**
 * Builds and returns a {@link TextClassification} object.
 */
","/**
 * Builds and returns a {@link TextClassification} object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,The change occurs where the 'buildExtras()' method is replaced with a ternary operation that checks if 'mExtras' is null and returns 'Bundle.EMPTY' if it is. This change in how extras are handled before constructing the 'TextClassification' object indicates both a return statement change (1) and an other statement change (4).,"There is a potential Compatibility Issue because the late version may return a different value by providing 'Bundle.EMPTY' instead of what 'buildExtras()' might have returned previously if 'mExtras' is null. Therefore, the API will potentially return a different object depending on the state of 'mExtras', marking it as CI type 1."
527,"<android.database.sqlite.SQLiteQueryBuilder: String buildQueryString(boolean,String,String[],String,String,String,String,String)>",29,30,"<android.database.sqlite.SQLiteQueryBuilder: String buildQueryString(boolean,String,String[],String,String,String,String,String)>","<android.database.sqlite.SQLiteQueryBuilder: String buildQueryString(boolean,String,String[],String,String,String,String,String)>",0,"{
    if (TextUtils.isEmpty(groupBy) && !TextUtils.isEmpty(having)) {
        throw new IllegalArgumentException(""HAVING clauses are only permitted when using a groupBy clause"");
    }
    if (!TextUtils.isEmpty(limit) && !sLimitPattern.matcher(limit).matches()) {
        throw new IllegalArgumentException(""invalid LIMIT clauses:"" + limit);
    }
    StringBuilder query = new StringBuilder(120);
    query.append(""SELECT "");
    if (distinct) {
        query.append(""DISTINCT "");
    }
    if (columns != null && columns.length != 0) {
        appendColumns(query, columns);
    } else {
        query.append(""* "");
    }
    query.append(""FROM "");
    query.append(tables);
    appendClause(query, "" WHERE "", where);
    appendClause(query, "" GROUP BY "", groupBy);
    appendClause(query, "" HAVING "", having);
    appendClause(query, "" ORDER BY "", orderBy);
    appendClause(query, "" LIMIT "", limit);
    return query.toString();
}","{
    if (TextUtils.isEmpty(groupBy) && !TextUtils.isEmpty(having)) {
        throw new IllegalArgumentException(""HAVING clauses are only permitted when using a groupBy clause"");
    }
    StringBuilder query = new StringBuilder(120);
    query.append(""SELECT "");
    if (distinct) {
        query.append(""DISTINCT "");
    }
    if (columns != null && columns.length != 0) {
        appendColumns(query, columns);
    } else {
        query.append(""* "");
    }
    query.append(""FROM "");
    query.append(tables);
    appendClause(query, "" WHERE "", where);
    appendClause(query, "" GROUP BY "", groupBy);
    appendClause(query, "" HAVING "", having);
    appendClause(query, "" ORDER BY "", orderBy);
    appendClause(query, "" LIMIT "", limit);
    return query.toString();
}",1,"/**
 * Build an SQL query string from the given clauses.
 *
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param tables The table names to compile the query against.
 * @param columns A list of which columns to return. Passing null will
 * return all columns, which is discouraged to prevent reading
 * data from storage that isn't going to be used.
 * @param where A filter declaring which rows to return, formatted as an SQL
 * {@code WHERE} clause (excluding the {@code WHERE} itself). Passing {@code null} will
 * return all rows for the given URL.
 * @param groupBy A filter declaring how to group rows, formatted as an SQL
 * {@code GROUP BY} clause (excluding the {@code GROUP BY} itself). Passing {@code null}
 * will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,
 * if row grouping is being used, formatted as an SQL {@code HAVING}
 * clause (excluding the {@code HAVING} itself). Passing null will cause
 * all row groups to be included, and is required when row
 * grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL {@code ORDER BY} clause
 * (excluding the {@code ORDER BY} itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as {@code LIMIT} clause. Passing null denotes no {@code LIMIT} clause.
 * @return the SQL query string
 */
","/**
 * Build an SQL query string from the given clauses.
 *
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param tables The table names to compile the query against.
 * @param columns A list of which columns to return. Passing null will
 * return all columns, which is discouraged to prevent reading
 * data from storage that isn't going to be used.
 * @param where A filter declaring which rows to return, formatted as an SQL
 * {@code WHERE} clause (excluding the {@code WHERE} itself). Passing {@code null} will
 * return all rows for the given URL.
 * @param groupBy A filter declaring how to group rows, formatted as an SQL
 * {@code GROUP BY} clause (excluding the {@code GROUP BY} itself). Passing {@code null}
 * will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,
 * if row grouping is being used, formatted as an SQL {@code HAVING}
 * clause (excluding the {@code HAVING} itself). Passing null will cause
 * all row groups to be included, and is required when row
 * grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL {@code ORDER BY} clause
 * (excluding the {@code ORDER BY} itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as {@code LIMIT} clause. Passing null denotes no {@code LIMIT} clause.
 * @return the SQL query string
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement related to 'limit' has been removed, and no new logic has been introduced, which results in a change type of 2,4.","Because the removed exception handling statement could have previously thrown an IllegalArgumentException when the 'limit' clause was invalid, removing this check could lead to a situation where an invalid 'limit' clause does not throw an exception as it did in the previous version. Therefore, the potential difference in exception handling constitutes a CI type of 2."
528,<android.app.ActivityThread.H: String codeToString(int)>,29,30,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
            case RUN_ISOLATED_ENTRY_POINT:
                return ""RUN_ISOLATED_ENTRY_POINT"";
            case EXECUTE_TRANSACTION:
                return ""EXECUTE_TRANSACTION"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PURGE_RESOURCES:
                return ""PURGE_RESOURCES"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
            case RUN_ISOLATED_ENTRY_POINT:
                return ""RUN_ISOLATED_ENTRY_POINT"";
            case EXECUTE_TRANSACTION:
                return ""EXECUTE_TRANSACTION"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PURGE_RESOURCES:
                return ""PURGE_RESOURCES"";
            case ATTACH_STARTUP_AGENTS:
                return ""ATTACH_STARTUP_AGENTS"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
529,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,29,30,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,0,"{
    final int flags = (mFlags & ~Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE) | Context.CONTEXT_DEVICE_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, flags, mClassLoader, null);
}","{
    final int flags = (mFlags & ~Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE) | Context.CONTEXT_DEVICE_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, mSplitName, mToken, mUser, flags, mClassLoader, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"In the late version, the constructor for `ContextImpl` has additional parameters `mAttributionTag` and `mToken`, which replace `mActivityToken` in the early version. This constitutes other statements changed (4) and dependent API changed (5), because the constructor signature has changed.","This change could lead to a compatibility issue due to different return values, as the newly constructed `ContextImpl` instance in the late version may behave differently with the added `mAttributionTag` and `mToken` parameters. Thus, the CI type is 1."
530,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain(AccessibilityEvent)>,29,30,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain(AccessibilityEvent)>,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain(AccessibilityEvent)>,0,"{
    AccessibilityEvent eventClone = AccessibilityEvent.obtain();
    eventClone.init(event);
    if (event.mRecords != null) {
        final int recordCount = event.mRecords.size();
        eventClone.mRecords = new ArrayList<AccessibilityRecord>(recordCount);
        for (int i = 0; i < recordCount; i++) {
            final AccessibilityRecord record = event.mRecords.get(i);
            final AccessibilityRecord recordClone = AccessibilityRecord.obtain(record);
            eventClone.mRecords.add(recordClone);
        }
    }
    return eventClone;
}","{
    AccessibilityEvent eventClone = AccessibilityEvent.obtain();
    eventClone.init(event);
    return eventClone;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>event</code>.
 *
 * @param event The other event.
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>event</code>.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityEvent(AccessibilityEvent)} instead.
 *
 * @param event The other event.
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The loop that clones individual records has been removed from the late version implementation along with associated code for handling the mRecords list, which results in a simplified return value only cloning the event without its records. So the change includes the deletion of other statements, identified as 4, and because this results in a simplified object being returned, type 1 also applies.","Since in the early version, eventClone includes clones of the AccessibilityRecords from event, while in the late version it only includes a clone of `event` without the records, the return value's structure, and potentially behavior, has changed. This indicates a Compatibility Issue of type 1 where callers expecting the records to be part of the cloned event would now receive an event without them."
531,"<android.content.ContentResolver: Bundle call(String,String,String,Bundle)>",29,30,"<android.content.ContentResolver: Bundle call(String,String,String,Bundle)>","<android.content.ContentResolver: Bundle call(String,String,String,Bundle)>",0,"{
    Preconditions.checkNotNull(authority, ""authority"");
    Preconditions.checkNotNull(method, ""method"");
    try {
        if (mWrapped != null)
            return mWrapped.call(authority, method, arg, extras);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        final Bundle res = provider.call(mPackageName, authority, method, arg, extras);
        Bundle.setDefusable(res, true);
        return res;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(authority, ""authority"");
    Objects.requireNonNull(method, ""method"");
    try {
        if (mWrapped != null)
            return mWrapped.call(authority, method, arg, extras);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        final Bundle res = provider.call(mPackageName, mAttributionTag, authority, method, arg, extras);
        Bundle.setDefusable(res, true);
        return res;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,,,-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",1,"The code change includes the replacement of Preconditions.checkNotNull with Objects.requireNonNull, which does not change the behavior but instead just uses a different class with the same effect. The significant change is in the call to provider.call within try block, where the late version introduces an additional parameter mAttributionTag, which means the dependent API call to provider.call has an additional parameter; thus the dependent API changed. So the change types are 4,5.","The introduction of an additional parameter to the provider.call means that it's calling a different overload of that method which could potentially return a different result; hence, there is a CI caused by potential different return values or types, which is of type 1."
532,<android.util.AtomicFile: FileInputStream openRead()>,29,30,<android.util.AtomicFile: FileInputStream openRead()>,<android.util.AtomicFile: FileInputStream openRead()>,0,"{
    if (mBackupName.exists()) {
        mBaseName.delete();
        mBackupName.renameTo(mBaseName);
    }
    return new FileInputStream(mBaseName);
}","{
    if (mLegacyBackupName.exists()) {
        rename(mLegacyBackupName, mBaseName);
    }
    // that finishWrite() can still work.
    if (mNewName.exists() && mBaseName.exists()) {
        if (!mNewName.delete()) {
            Log.e(LOG_TAG, ""Failed to delete outdated new file "" + mNewName);
        }
    }
    return new FileInputStream(mBaseName);
}",1,"/**
 * Open the atomic file for reading.  If there previously was an
 * incomplete write, this will roll back to the last good data before
 * opening for read.  You should call close() on the FileInputStream when
 * you are done reading from it.
 *
 * <p>Note that if another thread is currently performing
 * a write, this will incorrectly consider it to be in the state of a bad
 * write and roll back, causing the new data currently being written to
 * be dropped.  You must do your own threading protection for access to
 * AtomicFile.
 */
","/**
 * Open the atomic file for reading. You should call close() on the FileInputStream when you are
 * done reading from it.
 * <p>
 * You must do your own threading protection for access to AtomicFile.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are multiple change types: The control dependency has changed by introducing an additional 'if' condition (if (mNewName.exists() && mBaseName.exists())), and an invocation of a new method rename(mLegacyBackupName, mBaseName) and a conditional deletion with logging (if (!mNewName.delete())), so the code change types are 3,4.","Despite the added control structures and the method invocation changes, the actual behavior of the API concerning its return value does not change, and there are no new exceptions introduced that would alter the API's error handling contract. Therefore, there is no Compatibility Issue."
534,<com.android.server.SystemConfig: SystemConfig getInstance()>,29,30,<com.android.server.SystemConfig: SystemConfig getInstance()>,<com.android.server.SystemConfig: SystemConfig getInstance()>,0,"{
    synchronized (SystemConfig.class) {
        if (sInstance == null) {
            sInstance = new SystemConfig();
        }
        return sInstance;
    }
}","{
    if (!isSystemProcess()) {
        Slog.wtf(TAG, ""SystemConfig is being accessed by a process other than "" + ""system_server."");
    }
    synchronized (SystemConfig.class) {
        if (sInstance == null) {
            sInstance = new SystemConfig();
        }
        return sInstance;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late implementation has an additional check `if (!isSystemProcess())` outside of the synchronized block, and an associated warning log statement, which constitutes a control dependency change (3) and an other statement change (4).","The introduction of the `isSystemProcess` check does not alter the return value or types, nor does it change the exception handling. Even though the new log statement could lead to side-effects (logging in this case), these do not represent a behavioral change from an API consumer perspective – the singleton instance returned remains unaffected. As such, there is no CI."
535,<android.hardware.usb.UsbDevice: String toString()>,29,30,<android.hardware.usb.UsbDevice: String toString()>,<android.hardware.usb.UsbDevice: String toString()>,0,"{
    StringBuilder builder = new StringBuilder(""UsbDevice[mName="" + mName + "",mVendorId="" + mVendorId + "",mProductId="" + mProductId + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mManufacturerName="" + mManufacturerName + "",mProductName="" + mProductName + "",mVersion="" + mVersion + "",mSerialNumberReader="" + mSerialNumberReader + "",mConfigurations=["");
    for (int i = 0; i < mConfigurations.length; i++) {
        builder.append(""\n"");
        builder.append(mConfigurations[i].toString());
    }
    builder.append(""]"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder(""UsbDevice[mName="" + mName + "",mVendorId="" + mVendorId + "",mProductId="" + mProductId + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mManufacturerName="" + mManufacturerName + "",mProductName="" + mProductName + "",mVersion="" + mVersion + "",mSerialNumberReader="" + mSerialNumberReader + "", mHasAudioPlayback="" + mHasAudioPlayback + "", mHasAudioCapture="" + mHasAudioCapture + "", mHasMidi="" + mHasMidi + "", mHasVideoCapture="" + mHasVideoCapture + "", mHasVideoPlayback="" + mHasVideoPlayback + "", mConfigurations=["");
    for (int i = 0; i < mConfigurations.length; i++) {
        builder.append(""\n"");
        builder.append(mConfigurations[i].toString());
    }
    builder.append(""]"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The early implementation of the `toString` method has been modified in the late version by adding more properties to the string being built (`mHasAudioPlayback`, `mHasAudioCapture`, `mHasMidi`, `mHasVideoCapture`, `mHasVideoPlayback`). This change is an 'other statement' change because fields are being appended to the StringBuilder, which also leads to a 'return statement' change since the output of the method has been altered.","Due to the additional fields appended to the string being built in the late implementation, the return value of `toString` method will differ, and thus there is a Compatibility Issue of the type '1' (potential different return values)."
537,"<android.app.AppOpsManager: int noteProxyOpNoThrow(String,String,int)>",29,30,"<android.app.AppOpsManager: int noteProxyOpNoThrow(String,String,int)>","<android.app.AppOpsManager: int noteProxyOpNoThrow(String,String,int)>",0,"{
    return noteProxyOpNoThrow(strOpToOp(op), proxiedPackageName, proxiedUid);
}","{
    return noteProxyOpNoThrow(op, proxiedPackageName, proxiedUid, null, null);
}",1,"/**
 * Like {@link #noteProxyOpNoThrow(String, String)} but allows to specify the proxied uid.
 *
 * <p>This API requires package with the {@code proxiedPackageName} to belong to
 * {@code proxiedUid}.
 *
 * @param op The op to note
 * @param proxiedPackageName The package to note the op for or {@code null} if the op should be
 * noted for the ""android"" package
 * @param proxiedUid The uid the package belongs to
 */
","/**
 * @deprecated Use {@link #noteProxyOpNoThrow(String, String, int, String, String)} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The method signature of the dependent API `noteProxyOpNoThrow` called within the method has changed to include additional parameters, so the code change type is 5.","There is no compatibility issue here; the additional parameters added in the late version's API call (`null, null`) are most likely overload defaults or additional context that doesn't change the functional contract of `noteProxyOpNoThrow`. Thus, it seems the behavior of the original API `noteProxyOpNoThrow(String,String,int)` remains unchanged despite the additional parameters in the overload. Therefore, the CI type is 0."
538,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",29,30,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The invocation of a dependent API changed from broadcastIntent to broadcastIntentWithFeature, implying that the dependent API was changed, so the code change type is 5.","Although the method to call the broadcast has changed, there is no change in exceptions thrown or return values since the method is void and exceptions are handled in the same way. Therefore, there is no compatibility issue."
539,<android.bluetooth.le.BluetoothLeScanner: void stopScan(PendingIntent)>,29,30,<android.bluetooth.le.BluetoothLeScanner: void stopScan(PendingIntent)>,<android.bluetooth.le.BluetoothLeScanner: void stopScan(PendingIntent)>,0,"{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopScanForIntent(callbackIntent, ActivityThread.currentOpPackageName());
    } catch (RemoteException e) {
    }
}","{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopScanForIntent(callbackIntent, mOpPackageName);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Stops an ongoing Bluetooth LE scan started using a PendingIntent. When creating the
 * PendingIntent parameter, please do not use the FLAG_CANCEL_CURRENT flag. Otherwise, the stop
 * scan may have no effect.
 *
 * @param callbackIntent The PendingIntent that was used to start the scan.
 * @see #startScan(List, ScanSettings, PendingIntent)
 */
","/**
 * Stops an ongoing Bluetooth LE scan started using a PendingIntent. When creating the
 * PendingIntent parameter, please do not use the FLAG_CANCEL_CURRENT flag. Otherwise, the stop
 * scan may have no effect.
 *
 * @param callbackIntent The PendingIntent that was used to start the scan.
 * @see #startScan(List, ScanSettings, PendingIntent)
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,5,0,"The argument for the method call gatt.stopScanForIntent has changed from ActivityThread.currentOpPackageName() to mOpPackageName, this represents a Dependent API changed, so the code change type is 5.","There is no compatibility issue caused by this change, as the behavior of the method is not altered by this parameter change given that mOpPackageName is expected to hold the value of the current operation package name, which would be the returned value by ActivityThread.currentOpPackageName(). Hence, there should be no difference in behavior from the perspective of clients calling the stopScan method, and CI type is 0."
540,<android.util.ArraySet: void ensureCapacity(int)>,29,30,<android.util.ArraySet: void ensureCapacity(int)>,<android.util.ArraySet: void ensureCapacity(int)>,0,"{
    if (mHashes.length < minimumCapacity) {
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(minimumCapacity);
        if (mSize > 0) {
            System.arraycopy(ohashes, 0, mHashes, 0, mSize);
            System.arraycopy(oarray, 0, mArray, 0, mSize);
        }
        freeArrays(ohashes, oarray, mSize);
    }
}","{
    final int oSize = mSize;
    if (mHashes.length < minimumCapacity) {
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(minimumCapacity);
        if (mSize > 0) {
            System.arraycopy(ohashes, 0, mHashes, 0, mSize);
            System.arraycopy(oarray, 0, mArray, 0, mSize);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (mSize != oSize) {
        throw new ConcurrentModificationException();
    }
}",1,"/**
 * Ensure the array map can hold at least <var>minimumCapacity</var>
 * items.
 */
","/**
 * Ensure the array map can hold at least <var>minimumCapacity</var>
 * items.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"There is an introduction of a new local variable `oSize` to hold the size before operation, a check for size modification at the end of the method, and a new exception handling statement `throw new ConcurrentModificationException();`. So, the code change types are 2,3,4.","A new exception `ConcurrentModificationException` may be thrown if the size of the collection is modified during the operation. It was not thrown in the early version, so the CI type is 2."
541,"<android.view.View: View findUserSetNextFocus(View,int)>",29,30,"<android.view.View: View findUserSetNextFocus(View,int)>","<android.view.View: View findUserSetNextFocus(View,int)>",0,"{
    switch(direction) {
        case FOCUS_LEFT:
            if (mNextFocusLeftId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusLeftId);
        case FOCUS_RIGHT:
            if (mNextFocusRightId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusRightId);
        case FOCUS_UP:
            if (mNextFocusUpId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusUpId);
        case FOCUS_DOWN:
            if (mNextFocusDownId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusDownId);
        case FOCUS_FORWARD:
            if (mNextFocusForwardId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusForwardId);
        case FOCUS_BACKWARD:
            {
                if (mID == View.NO_ID)
                    return null;
                final int id = mID;
                return root.findViewByPredicateInsideOut(this, new Predicate<View>() {

                    @Override
                    public boolean test(View t) {
                        return t.mNextFocusForwardId == id;
                    }
                });
            }
    }
    return null;
}","{
    switch(direction) {
        case FOCUS_LEFT:
            if (mNextFocusLeftId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusLeftId);
        case FOCUS_RIGHT:
            if (mNextFocusRightId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusRightId);
        case FOCUS_UP:
            if (mNextFocusUpId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusUpId);
        case FOCUS_DOWN:
            if (mNextFocusDownId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusDownId);
        case FOCUS_FORWARD:
            if (mNextFocusForwardId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusForwardId);
        case FOCUS_BACKWARD:
            {
                if (mID == View.NO_ID)
                    return null;
                final View rootView = root;
                final View startView = this;
                // because view IDs need not be unique throughout the tree.
                return root.findViewByPredicateInsideOut(startView, t -> findViewInsideOutShouldExist(rootView, t, t.mNextFocusForwardId) == startView);
            }
    }
    return null;
}",1,"/**
 * If a user manually specified the next view id for a particular direction,
 * use the root to look up the view.
 * @param root The root view of the hierarchy containing this view.
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,
 * or FOCUS_BACKWARD.
 * @return The user specified next view, or null if there is none.
 */
","/**
 * If a user manually specified the next view id for a particular direction,
 * use the root to look up the view.
 * @param root The root view of the hierarchy containing this view.
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,
 * or FOCUS_BACKWARD.
 * @return The user specified next view, or null if there is none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,The implementation under the case FOCUS_BACKWARD has been changed with the introduction of new variables and a new lambda function in the call root.findViewByPredicateInsideOut. So there is a change in control dependency.,"With the change in control dependency under the FOCUS_BACKWARD case, the API could potentially return a different View than what the early version does. Therefore, there is a compatibility issue caused by potential different return values or types (CI type 1)."
543,<android.content.ContentResolver: String getType(Uri)>,29,30,<android.content.ContentResolver: String getType(Uri)>,<android.content.ContentResolver: String getType(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.getType(url);
    } catch (RemoteException e) {
        return null;
    }
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            // Manager will kill this process shortly anyway.
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManager.getService().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.getType(url);
    } catch (RemoteException e) {
        return null;
    }
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            final StringResultListener resultListener = new StringResultListener();
            provider.getTypeAsync(url, new RemoteCallback(resultListener));
            resultListener.waitForResult(CONTENT_PROVIDER_TIMEOUT_MILLIS);
            if (resultListener.exception != null) {
                throw resultListener.exception;
            }
            return resultListener.result;
        } catch (RemoteException e) {
            // Manager will kill this process shortly anyway.
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        final StringResultListener resultListener = new StringResultListener();
        ActivityManager.getService().getProviderMimeTypeAsync(ContentProvider.getUriWithoutUserId(url), resolveUserId(url), new RemoteCallback(resultListener));
        resultListener.waitForResult(REMOTE_CONTENT_PROVIDER_TIMEOUT_MILLIS);
        if (resultListener.exception != null) {
            throw resultListener.exception;
        }
        return resultListener.result;
    } catch (RemoteException e) {
        // We just failed to send a oneway request to the System Server. Nothing to do.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}",1,"/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
","/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The method implementation has changed from synchronous API calls to asynchronous API calls with callbacks. Particularly, the 'getType' method call on the 'provider' and 'ActivityManager.getService()' has been replaced with 'getTypeAsync' and 'getProviderMimeTypeAsync' respectively, along with a new 'StringResultListener' pattern to fetch the result or throw an exception if there is one, which affects the control flow, involves other statements change, dependent API changes and potentially the returned value or exceptions thrown. Thus, the code change type is 1,3,4,5.","The asynchronous nature of the new implementation introduces a potential Compatibility Issue since dependent APIs were changed ('getTypeAsync' and 'getProviderMimeTypeAsync'), which subsequently changes the flow of how results are acquired or exceptions are thrown. This means the method may return different values or types and throw exceptions at different points in its execution. Consequently, the CI type is 1,2."
548,<android.view.textclassifier.TextLinks.Request.Builder: Request build()>,29,30,<android.view.textclassifier.TextLinks.Request.Builder: Request build()>,<android.view.textclassifier.TextLinks.Request.Builder: Request build()>,0,"{
    return new Request(mText, mDefaultLocales, mEntityConfig, mLegacyFallback, mExtras == null ? Bundle.EMPTY : mExtras);
}","{
    return new Request(mText, mDefaultLocales, mEntityConfig, mLegacyFallback, mReferenceTime, mExtras == null ? Bundle.EMPTY : mExtras);
}",1,"/**
 * Builds and returns the request object.
 */
","/**
 * Builds and returns the request object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,1,1,"The constructor for 'Request' in the late version has an additional argument `mReferenceTime`, which changes the return value, so the change type is 1.","The additional argument `mReferenceTime` could potentially alter the behavior of the 'Request' object being returned; thus the potential for different behavior in the API exists, and the CI type is 1."
549,<android.view.textclassifier.TextClassification.Request: String getCallingPackageName()>,29,30,<android.view.textclassifier.TextClassification.Request: String getCallingPackageName()>,<android.view.textclassifier.TextClassification.Request: String getCallingPackageName()>,0,"{
    return mCallingPackageName;
}","{
    return mSystemTcMetadata != null ? mSystemTcMetadata.getCallingPackageName() : null;
}",1,"/**
 * Returns the name of the package that sent this request.
 * This returns {@code null} if no calling package name is set.
 */
","/**
 * Returns the name of the package that sent this request.
 * This returns {@code null} if no calling package name is set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from a direct return of mCallingPackageName to a conditional statement that returns either mSystemTcMetadata.getCallingPackageName() or null. This also indicates a change in the dependent API (either the use of an extra method or a different field), therefore, the code change types are 1,5.","Since the return value of getCallingPackageName() has changed based on the mSystemTcMetadata condition, the method may return different values depending on the state of mSystemTcMetadata. Therefore, it constitutes a change that can lead to different return values, and the CI type is 1."
551,"<android.accessibilityservice.AccessibilityService: boolean dispatchGesture(GestureDescription,GestureResultCallback,Handler)>",29,30,"<android.accessibilityservice.AccessibilityService: boolean dispatchGesture(GestureDescription,GestureResultCallback,Handler)>","<android.accessibilityservice.AccessibilityService: boolean dispatchGesture(GestureDescription,GestureResultCallback,Handler)>",0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection == null) {
        return false;
    }
    List<GestureDescription.GestureStep> steps = MotionEventGenerator.getGestureStepsFromGestureDescription(gesture, 100);
    try {
        synchronized (mLock) {
            mGestureStatusCallbackSequence++;
            if (callback != null) {
                if (mGestureStatusCallbackInfos == null) {
                    mGestureStatusCallbackInfos = new SparseArray<>();
                }
                GestureResultCallbackInfo callbackInfo = new GestureResultCallbackInfo(gesture, callback, handler);
                mGestureStatusCallbackInfos.put(mGestureStatusCallbackSequence, callbackInfo);
            }
            connection.sendGesture(mGestureStatusCallbackSequence, new ParceledListSlice<>(steps));
        }
    } catch (RemoteException re) {
        throw new RuntimeException(re);
    }
    return true;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection == null) {
        return false;
    }
    List<GestureDescription.GestureStep> steps = MotionEventGenerator.getGestureStepsFromGestureDescription(gesture, 16);
    try {
        synchronized (mLock) {
            mGestureStatusCallbackSequence++;
            if (callback != null) {
                if (mGestureStatusCallbackInfos == null) {
                    mGestureStatusCallbackInfos = new SparseArray<>();
                }
                GestureResultCallbackInfo callbackInfo = new GestureResultCallbackInfo(gesture, callback, handler);
                mGestureStatusCallbackInfos.put(mGestureStatusCallbackSequence, callbackInfo);
            }
            connection.dispatchGesture(mGestureStatusCallbackSequence, new ParceledListSlice<>(steps), gesture.getDisplayId());
        }
    } catch (RemoteException re) {
        throw new RuntimeException(re);
    }
    return true;
}",1,"/**
 * Dispatch a gesture to the touch screen. Any gestures currently in progress, whether from
 * the user, this service, or another service, will be cancelled.
 * <p>
 * The gesture will be dispatched as if it were performed directly on the screen by a user, so
 * the events may be affected by features such as magnification and explore by touch.
 * </p>
 * <p>
 * <strong>Note:</strong> In order to dispatch gestures, your service
 * must declare the capability by setting the
 * {@link android.R.styleable#AccessibilityService_canPerformGestures}
 * property in its meta-data. For more information, see
 * {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @param gesture The gesture to dispatch
 * @param callback The object to call back when the status of the gesture is known. If
 * {@code null}, no status is reported.
 * @param handler The handler on which to call back the {@code callback} object. If
 * {@code null}, the object is called back on the service's main thread.
 *
 * @return {@code true} if the gesture is dispatched, {@code false} if not.
 */
","/**
 * Dispatch a gesture to the touch screen. Any gestures currently in progress, whether from
 * the user, this service, or another service, will be cancelled.
 * <p>
 * The gesture will be dispatched as if it were performed directly on the screen by a user, so
 * the events may be affected by features such as magnification and explore by touch.
 * </p>
 * <p>
 * <strong>Note:</strong> In order to dispatch gestures, your service
 * must declare the capability by setting the
 * {@link android.R.styleable#AccessibilityService_canPerformGestures}
 * property in its meta-data. For more information, see
 * {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @param gesture The gesture to dispatch
 * @param callback The object to call back when the status of the gesture is known. If
 * {@code null}, no status is reported.
 * @param handler The handler on which to call back the {@code callback} object. If
 * {@code null}, the object is called back on the service's main thread.
 *
 * @return {@code true} if the gesture is dispatched, {@code false} if not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,The following changes have been made in the implementation:,- A new parameter `gesture.getDisplayId()` has been added to the `dispatchGesture` method call.
552,<android.app.assist.AssistStructure.ViewNodeBuilder: void setTextIdEntry(String)>,29,30,<android.app.assist.AssistStructure.ViewNodeBuilder: void setTextIdEntry(String)>,<android.app.assist.AssistStructure.ViewNodeBuilder: void setTextIdEntry(String)>,0,"{
    mNode.mTextIdEntry = Preconditions.checkNotNull(entryName);
}","{
    mNode.mTextIdEntry = Objects.requireNonNull(entryName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method to check for null (Preconditions.checkNotNull) has been replaced with another method that serves the same purpose (Objects.requireNonNull). This is an other statement changed and also a change in the dependent API. So the code change type is 4,5.","The behavior of the API doesn't change as both Preconditions.checkNotNull and Objects.requireNonNull perform null checks and throw an exception if the passed argument is null. Therefore, there is no compatibility issue, and the CI type is 0."
553,<android.view.View: Parcelable onSaveInstanceState()>,29,30,<android.view.View: Parcelable onSaveInstanceState()>,<android.view.View: Parcelable onSaveInstanceState()>,0,"{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (mStartActivityRequestWho != null || isAutofilled() || mAutofillViewId > LAST_APP_AUTOFILL_ID) {
        BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE);
        if (mStartActivityRequestWho != null) {
            state.mSavedData |= BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED;
        }
        if (isAutofilled()) {
            state.mSavedData |= BaseSavedState.IS_AUTOFILLED;
        }
        if (mAutofillViewId > LAST_APP_AUTOFILL_ID) {
            state.mSavedData |= BaseSavedState.AUTOFILL_ID;
        }
        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;
        state.mIsAutofilled = isAutofilled();
        state.mAutofillViewId = mAutofillViewId;
        return state;
    }
    return BaseSavedState.EMPTY_STATE;
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (mStartActivityRequestWho != null || isAutofilled() || mAutofillViewId > LAST_APP_AUTOFILL_ID) {
        BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE);
        if (mStartActivityRequestWho != null) {
            state.mSavedData |= BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED;
        }
        if (isAutofilled()) {
            state.mSavedData |= BaseSavedState.IS_AUTOFILLED;
        }
        if (mAutofillViewId > LAST_APP_AUTOFILL_ID) {
            state.mSavedData |= BaseSavedState.AUTOFILL_ID;
        }
        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;
        state.mIsAutofilled = isAutofilled();
        state.mHideHighlight = hideAutofillHighlight();
        state.mAutofillViewId = mAutofillViewId;
        return state;
    }
    return BaseSavedState.EMPTY_STATE;
}",1,"/**
 * Hook allowing a view to generate a representation of its internal state
 * that can later be used to create a new instance with that same state.
 * This state should only contain information that is not persistent or can
 * not be reconstructed later. For example, you will never store your
 * current position on screen because that will be computed again when a
 * new instance of the view is placed in its view hierarchy.
 * <p>
 * Some examples of things you may store here: the current cursor position
 * in a text view (but usually not the text itself since that is stored in a
 * content provider or other persistent storage), the currently selected
 * item in a list view.
 *
 * @return Returns a Parcelable object containing the view's current dynamic
 * state, or null if there is nothing interesting to save.
 * @see #onRestoreInstanceState(Parcelable)
 * @see #saveHierarchyState(SparseArray)
 * @see #dispatchSaveInstanceState(SparseArray)
 * @see #setSaveEnabled(boolean)
 */
","/**
 * Hook allowing a view to generate a representation of its internal state
 * that can later be used to create a new instance with that same state.
 * This state should only contain information that is not persistent or can
 * not be reconstructed later. For example, you will never store your
 * current position on screen because that will be computed again when a
 * new instance of the view is placed in its view hierarchy.
 * <p>
 * Some examples of things you may store here: the current cursor position
 * in a text view (but usually not the text itself since that is stored in a
 * content provider or other persistent storage), the currently selected
 * item in a list view.
 *
 * @return Returns a Parcelable object containing the view's current dynamic
 * state, or null if there is nothing interesting to save.
 * @see #onRestoreInstanceState(Parcelable)
 * @see #saveHierarchyState(SparseArray)
 * @see #dispatchSaveInstanceState(SparseArray)
 * @see #setSaveEnabled(boolean)
 */
",-1,"[@CallSuper, @Nullable]","[@CallSuper, @Nullable]",-1,-1,-1,-1,-1,-1,"1,4",1,"There are non-control statement changes. A new field `state.mHideHighlight` has been added in the late version and it's set with the return value of `hideAutofillHighlight()`. Thus, a new state is possibly being saved which makes the change type 4. Since this modification changes the state that is saved, it implies a change in the return value which makes the change type 1.","As the returned Parcelable now potentially includes additional data (`state.mHideHighlight`), this could affect the state restoration process differently in apps relying on the earlier API. Therefore, the CI type is 1."
554,<android.os.storage.StorageManager: StorageVolume getStorageVolume(Uri)>,29,30,<android.os.storage.StorageManager: StorageVolume getStorageVolume(Uri)>,<android.os.storage.StorageManager: StorageVolume getStorageVolume(Uri)>,0,"{
    final String volumeName = MediaStore.getVolumeName(uri);
    switch(volumeName) {
        case MediaStore.VOLUME_EXTERNAL_PRIMARY:
            return getPrimaryStorageVolume();
        default:
            for (StorageVolume vol : getStorageVolumes()) {
                if (Objects.equals(vol.getNormalizedUuid(), volumeName)) {
                    return vol;
                }
            }
    }
    throw new IllegalStateException(""Unknown volume for "" + uri);
}","{
    String volumeName = MediaStore.getVolumeName(uri);
    // resolve the actual volume name
    if (Objects.equals(volumeName, MediaStore.VOLUME_EXTERNAL)) {
        try (Cursor c = mContext.getContentResolver().query(uri, new String[] { MediaStore.MediaColumns.VOLUME_NAME }, null, null)) {
            if (c.moveToFirst()) {
                volumeName = c.getString(0);
            }
        }
    }
    switch(volumeName) {
        case MediaStore.VOLUME_EXTERNAL_PRIMARY:
            return getPrimaryStorageVolume();
        default:
            for (StorageVolume vol : getStorageVolumes()) {
                if (Objects.equals(vol.getMediaStoreVolumeName(), volumeName)) {
                    return vol;
                }
            }
    }
    throw new IllegalStateException(""Unknown volume for "" + uri);
}",1,"/**
 * Return the {@link StorageVolume} that contains the given
 * {@link MediaStore} item.
 */
","/**
 * Return the {@link StorageVolume} that contains the given
 * {@link MediaStore} item.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"In the late version of the implementation, additional code has been introduced that includes a database query and a conditional statement to resolve the volume name. The 'switch' statement now checks against 'vol.getMediaStoreVolumeName()' instead of 'vol.getNormalizedUuid()', and the dependent API 'MediaStore.getVolumeName()' might have changed behavior. Thus, the code change types are 1,3,4,5.","The changes include resolving the actual volume name based on a conditional check and a database query, and a modification in how volumes are matched. These could certainly affect the return value of the API, resulting in different `StorageVolume` objects being returned, which constitutes a Compatibility Issue. Also, the reliance on the possible updated behavior of the dependent API 'MediaStore.getVolumeName()' may cause a Compatibility Issue as well. Therefore, the CI type is 1."
555,<android.widget.Toast: float getVerticalMargin()>,29,30,<android.widget.Toast: float getVerticalMargin()>,<android.widget.Toast: float getVerticalMargin()>,0,"{
    return mTN.mVerticalMargin;
}","{
    if (isSystemRenderedTextToast()) {
        Log.e(TAG, ""getVerticalMargin() shouldn't be called on text toasts, the result may not"" + "" reflect actual values."");
    }
    return mTN.mVerticalMargin;
}",1,"/**
 * Return the vertical margin.
 */
","/**
 * Return the vertical margin.
 *
 * <p><strong>Warning:</strong> Starting from Android {@link Build.VERSION_CODES#R}, for apps
 * targeting API level {@link Build.VERSION_CODES#R} or higher, this method shouldn't be called
 * on text toasts as its return value may not reflect actual value since text toasts are not
 * rendered by the app anymore.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new condition check 'if' and a logging statement have been added, which represent changes in the control dependency and other statements, hence they are categorized as type 3 and 4, respectively.","No compatibility issue is detected because the new logging statement does not affect the return value or exception handling behavior of the API. As such, there is no CI (0) related to these changes."
557,<android.speech.tts.TextToSpeech: int stop()>,29,30,<android.speech.tts.TextToSpeech: int stop()>,<android.speech.tts.TextToSpeech: int stop()>,0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.stop(getCallerIdentity());
        }
    }, ERROR, ""stop"");
}","{
    return runAction((ITextToSpeechService service) -> {
        return service.stop(getCallerIdentity());
    }, ERROR, ""stop"");
}",1,"/**
 * Interrupts the current utterance (whether played or rendered to file) and discards other
 * utterances in the queue.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
","/**
 * Interrupts the current utterance (whether played or rendered to file) and discards other
 * utterances in the queue.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is from an anonymous inner class to a lambda expression for the implementation of the Action.run() method. This change does not alter the functionality, just the syntax or style of the code.",No Compatibility Issue arises because this syntactic change does not affect the behavior of the method; it will still execute the same logic and return the same results as before.
559,"<android.view.inputmethod.InputMethodManager: void dispatchKeyEventFromInputMethod(View,KeyEvent)>",29,30,"<android.view.inputmethod.InputMethodManager: void dispatchKeyEventFromInputMethod(View,KeyEvent)>","<android.view.inputmethod.InputMethodManager: void dispatchKeyEventFromInputMethod(View,KeyEvent)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(targetView);
    if (fallbackImm != null) {
        fallbackImm.dispatchKeyEventFromInputMethod(targetView, event);
        return;
    }
    synchronized (mH) {
        ViewRootImpl viewRootImpl = targetView != null ? targetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mServedView != null) {
                viewRootImpl = mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(targetView);
    if (fallbackImm != null) {
        fallbackImm.dispatchKeyEventFromInputMethod(targetView, event);
        return;
    }
    synchronized (mH) {
        ViewRootImpl viewRootImpl = targetView != null ? targetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            final View servedView = getServedViewLocked();
            if (servedView != null) {
                viewRootImpl = servedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
}",1,"/**
 * Provides the default implementation of {@link InputConnection#sendKeyEvent(KeyEvent)}, which
 * is expected to dispatch an keyboard event sent from the IME to an appropriate event target
 * depending on the given {@link View} and the current focus state.
 *
 * <p>CAUTION: This method is provided only for the situation where
 * {@link InputConnection#sendKeyEvent(KeyEvent)} needs to be implemented without relying on
 * {@link BaseInputConnection}. Do not use this API for anything else.</p>
 *
 * @param targetView the default target view. If {@code null} is specified, then this method
 * tries to find a good event target based on the current focus state.
 * @param event the key event to be dispatched.
 */
","/**
 * Provides the default implementation of {@link InputConnection#sendKeyEvent(KeyEvent)}, which
 * is expected to dispatch an keyboard event sent from the IME to an appropriate event target
 * depending on the given {@link View} and the current focus state.
 *
 * <p>CAUTION: This method is provided only for the situation where
 * {@link InputConnection#sendKeyEvent(KeyEvent)} needs to be implemented without relying on
 * {@link BaseInputConnection}. Do not use this API for anything else.</p>
 *
 * @param targetView the default target view. If {@code null} is specified, then this method
 * tries to find a good event target based on the current focus state.
 * @param event the key event to be dispatched.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method used to get the 'mServedView' in the early version is directly accessed using 'mServedView', whereas in the late version, a method call 'getServedViewLocked()' is used instead. This is a change in other statements, specifically in how the variable is accessed, so the code change type is 4.","The use of different methods to access 'mServedView' does not in itself change the behavior of 'dispatchKeyEventFromInputMethod'. Both methods aim to serve the same purpose and achieve the same result, which is to get the 'mServedView'. Therefore, there is no compatibility issue that arises from this change, and the CI type is 0."
560,<android.gesture.GestureLibraries.FileGestureLibrary: boolean load()>,29,30,<android.gesture.GestureLibraries.FileGestureLibrary: boolean load()>,<android.gesture.GestureLibraries.FileGestureLibrary: boolean load()>,0,"{
    boolean result = false;
    final File file = mPath;
    if (file.exists() && file.canRead()) {
        try {
            mStore.load(new FileInputStream(file), true);
            result = true;
        } catch (FileNotFoundException e) {
            Log.d(LOG_TAG, ""Could not load the gesture library from "" + mPath, e);
        } catch (IOException e) {
            Log.d(LOG_TAG, ""Could not load the gesture library from "" + mPath, e);
        }
    }
    return result;
}","{
    boolean result = false;
    if (mPath != null) {
        final File file = mPath;
        if (file.exists() && file.canRead()) {
            try {
                mStore.load(new FileInputStream(file), true);
                result = true;
            } catch (IOException e) {
                Log.d(LOG_TAG, ""Could not load the gesture library from "" + mPath, e);
            }
        }
    } else {
        try {
            mStore.load(new FileInputStream(mFd), true);
            result = true;
        } catch (IOException e) {
            Log.d(LOG_TAG, ""Could not load the gesture library"", e);
        }
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The condition checking if `mPath` is not null has been added, and the block for handling `mFd` as a fallback option is also new. These changes include control dependency change and other changes due to the different logging messages and additional try-catch blocks. The return statement remains at the end of the method, but the value of result may change due to the new conditions added, hence the code change types are 1,3,4.","The API potentially returns different values since there is an additional condition involving `mPath` being non-null before proceeding with file loading. Previously, if `mPath` was null it likely would have resulted in result remaining `false`. In the late version, there's an alternative path to potentially set `result` to `true` by loading from `mFd`. This behaviour change falls under CI type 1."
561,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String,CancellationSignal)>",29,30,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String,CancellationSignal)>","<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String,CancellationSignal)>",0,"{
    if (mTables == null) {
        return null;
    }
    final String sql;
    final String unwrappedSql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
    if (mStrict && selection != null && selection.length() > 0) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        // NOTE: The ordering of the below operations is important; we must
        // execute the wrapped query to ensure the untrusted clause has been
        // fully isolated.
        // Validate the unwrapped query
        // will throw if query is invalid
        db.validateSql(unwrappedSql, cancellationSignal);
        // Execute wrapped query for extra protection
        final String wrappedSql = buildQuery(projectionIn, wrap(selection), groupBy, having, sortOrder, limit);
        sql = wrappedSql;
    } else {
        // Execute unwrapped query
        sql = unwrappedSql;
    }
    final String[] sqlArgs = selectionArgs;
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        if (Build.IS_DEBUGGABLE) {
            Log.d(TAG, sql + "" with args "" + Arrays.toString(sqlArgs));
        } else {
            Log.d(TAG, sql);
        }
    }
    return db.rawQueryWithFactory(mFactory, sql, sqlArgs, SQLiteDatabase.findEditTable(mTables), // will throw if query is invalid
    cancellationSignal);
}","{
    if (mTables == null) {
        return null;
    }
    final String sql;
    final String unwrappedSql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
    if (isStrictColumns()) {
        enforceStrictColumns(projectionIn);
    }
    if (isStrictGrammar()) {
        enforceStrictGrammar(selection, groupBy, having, sortOrder, limit);
    }
    if (isStrict()) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        // NOTE: The ordering of the below operations is important; we must
        // execute the wrapped query to ensure the untrusted clause has been
        // fully isolated.
        // Validate the unwrapped query
        // will throw if query is invalid
        db.validateSql(unwrappedSql, cancellationSignal);
        // Execute wrapped query for extra protection
        final String wrappedSql = buildQuery(projectionIn, wrap(selection), groupBy, wrap(having), sortOrder, limit);
        sql = wrappedSql;
    } else {
        // Execute unwrapped query
        sql = unwrappedSql;
    }
    final String[] sqlArgs = selectionArgs;
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        if (Build.IS_DEBUGGABLE) {
            Log.d(TAG, sql + "" with args "" + Arrays.toString(sqlArgs));
        } else {
            Log.d(TAG, sql);
        }
    }
    return db.rawQueryWithFactory(mFactory, sql, sqlArgs, SQLiteDatabase.findEditTable(mTables), // will throw if query is invalid
    cancellationSignal);
}",1,"/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL {@code WHERE} clause (excluding the {@code WHERE}
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL {@code GROUP BY} clause (excluding the {@code GROUP BY}
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL {@code HAVING} clause (excluding the {@code HAVING} itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * {@code ORDER BY} clause (excluding the {@code ORDER BY} itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as {@code LIMIT} clause. Passing null denotes no {@code LIMIT} clause.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
","/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL {@code WHERE} clause (excluding the {@code WHERE}
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL {@code GROUP BY} clause (excluding the {@code GROUP BY}
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL {@code HAVING} clause (excluding the {@code HAVING} itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * {@code ORDER BY} clause (excluding the {@code ORDER BY} itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as {@code LIMIT} clause. Passing null denotes no {@code LIMIT} clause.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation adds new conditional checks `isStrictColumns()` and `enforceStrictColumns(projectionIn)`, replaces `mStrict` with `isStrict()`, adds a call to `wrap(having)` within the `buildQuery` method, and adds the `isStrictGrammar()` with an associated `enforceStrictGrammar` call. These changes are related to control dependency as new control blocks have been introduced and are considered as other statement changes as well because they represent new method calls and logical conditions. The change type is 3,4. ","Although there are method changes, they concern additional validation and internal condition checking which are unlikely to cause a different behavior in terms of different return values or exceptions. The `rawQueryWithFactory` method call that actually carries out the query and returns a `Cursor` remains identical in both the early and late versions, so the actual output returned by the method or exceptions thrown should remain consistent with the earlier version. Thus, there is no compatibility issue; the CI type is 0."
562,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onCaptureStarted(CaptureResultExtras,long)>",29,30,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onCaptureStarted(CaptureResultExtras,long)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onCaptureStarted(CaptureResultExtras,long)>",0,"{
    int requestId = resultExtras.getRequestId();
    final long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.d(TAG, ""Capture started for id "" + requestId + "" frame number "" + frameNumber);
    }
    final CaptureCallbackHolder holder;
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // Get the callback for this frame ID, if there is one
        holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        if (holder == null) {
            return;
        }
        if (isClosed())
            return;
        // Dispatch capture start notice
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        final int subsequenceId = resultExtras.getSubsequenceId();
                        final CaptureRequest request = holder.getRequest(subsequenceId);
                        if (holder.hasBatchedOutputs()) {
                            // Send derived onCaptureStarted for requests within the
                            // batch
                            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(i), timestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper(), frameNumber - (subsequenceId - i));
                            }
                        } else {
                            holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(resultExtras.getSubsequenceId()), timestamp, frameNumber);
                        }
                    }
                }
            });
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}","{
    int requestId = resultExtras.getRequestId();
    final long frameNumber = resultExtras.getFrameNumber();
    final long lastCompletedRegularFrameNumber = resultExtras.getLastCompletedRegularFrameNumber();
    final long lastCompletedReprocessFrameNumber = resultExtras.getLastCompletedReprocessFrameNumber();
    final long lastCompletedZslFrameNumber = resultExtras.getLastCompletedZslFrameNumber();
    if (DEBUG) {
        Log.d(TAG, ""Capture started for id "" + requestId + "" frame number "" + frameNumber + "": completedRegularFrameNumber "" + lastCompletedRegularFrameNumber + "", completedReprocessFrameNUmber "" + lastCompletedReprocessFrameNumber + "", completedZslFrameNumber "" + lastCompletedZslFrameNumber);
    }
    final CaptureCallbackHolder holder;
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onCaptureStarted(resultExtras, timestamp);
            return;
        }
        // Check if it's okay to remove completed callbacks from mCaptureCallbackMap.
        // A callback is completed if the corresponding inflight request has been removed
        // from the inflight queue in cameraservice.
        removeCompletedCallbackHolderLocked(lastCompletedRegularFrameNumber, lastCompletedReprocessFrameNumber, lastCompletedZslFrameNumber);
        // Get the callback for this frame ID, if there is one
        holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        if (holder == null) {
            return;
        }
        if (isClosed())
            return;
        // Dispatch capture start notice
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        final int subsequenceId = resultExtras.getSubsequenceId();
                        final CaptureRequest request = holder.getRequest(subsequenceId);
                        if (holder.hasBatchedOutputs()) {
                            // Send derived onCaptureStarted for requests within the
                            // batch
                            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(i), timestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper(), frameNumber - (subsequenceId - i));
                            }
                        } else {
                            holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(resultExtras.getSubsequenceId()), timestamp, frameNumber);
                        }
                    }
                }
            });
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There are additional local variables added for frame numbers and a new if condition concerning `mOfflineSessionImpl`. These changes count as 'Other statement changed' (4). The control statements of `if` are also changed due to the addition of check for an offline session, which is a 'Control dependency change' (3). ","A new if condition that can return early from the method has been added. If `mOfflineSessionImpl != null`, then `onCaptureStarted` will be called on a different object and the method will return early, which is a different behavior than the previous version where this condition was not checked. Therefore, this change could cause the API to potentially return a different value or behavior, which is a 'Compatibility Issue caused by potential different return values or types' (1)."
563,<android.os.UserManager: boolean hasUserRestriction(String)>,29,30,<android.os.UserManager: boolean hasUserRestriction(String)>,<android.os.UserManager: boolean hasUserRestriction(String)>,0,"{
    return hasUserRestriction(restrictionKey, Process.myUserHandle());
}","{
    return hasUserRestrictionForUser(restrictionKey, Process.myUserHandle());
}",1,"/**
 * Returns whether the current user has been disallowed from performing certain actions
 * or setting certain settings.
 *
 * @param restrictionKey The string key representing the restriction.
 * @return {@code true} if the current user has the given restriction, {@code false} otherwise.
 */
","/**
 * Returns whether the current user has been disallowed from performing certain actions
 * or setting certain settings.
 *
 * @param restrictionKey The string key representing the restriction.
 * @return {@code true} if the current user has the given restriction, {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code has changed from calling `hasUserRestriction` to calling a different method `hasUserRestrictionForUser`. This indicates a change in the dependent API being called, so the change type is 5.","There is no compatibility issue detected per the available information, as it is not clear whether the behaviour of `hasUserRestrictionForUser` is different from `hasUserRestriction`. The mere renaming or delegation to another method does not inherently indicate a behavior change; additional context would be required to determine if a behavior change has occurred. Thus, CI type is 0."
564,<android.database.sqlite.SQLiteOpenHelper: void setOpenParams(OpenParams)>,29,30,<android.database.sqlite.SQLiteOpenHelper: void setOpenParams(OpenParams)>,<android.database.sqlite.SQLiteOpenHelper: void setOpenParams(OpenParams)>,0,"{
    Preconditions.checkNotNull(openParams);
    synchronized (this) {
        if (mDatabase != null && mDatabase.isOpen()) {
            throw new IllegalStateException(""OpenParams cannot be set after opening the database"");
        }
        setOpenParamsBuilder(new SQLiteDatabase.OpenParams.Builder(openParams));
    }
}","{
    Objects.requireNonNull(openParams);
    synchronized (this) {
        if (mDatabase != null && mDatabase.isOpen()) {
            throw new IllegalStateException(""OpenParams cannot be set after opening the database"");
        }
        setOpenParamsBuilder(new SQLiteDatabase.OpenParams.Builder(openParams));
    }
}",1,"/**
 * Sets configuration parameters that are used for opening {@link SQLiteDatabase}.
 * <p>Please note that {@link SQLiteDatabase#CREATE_IF_NECESSARY} flag will always be set when
 * opening the database
 *
 * @param openParams configuration parameters that are used for opening {@link SQLiteDatabase}.
 * @throws IllegalStateException if the database is already open
 */
","/**
 * Sets configuration parameters that are used for opening {@link SQLiteDatabase}.
 * <p>Please note that {@link SQLiteDatabase#CREATE_IF_NECESSARY} flag will always be set when
 * opening the database
 *
 * @param openParams configuration parameters that are used for opening {@link SQLiteDatabase}.
 * @throws IllegalStateException if the database is already open
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependency check has been changed from Preconditions.checkNotNull(openParams) to Objects.requireNonNull(openParams). This is a change in the implementation detail which constitutes the code type of 4. Additionally, the ""Preconditions.checkNotNull()"" and ""Objects.requireNonNull()"" methods serve the same purpose and hence this is also a change in the dependent API, so the code change type is 5.","Since both Preconditions.checkNotNull() and Objects.requireNonNull() methods are used to check for nullability and they throw the same type of exception (NullPointerException) when the passed argument is null, there is no change in the behavior of the API from that perspective. Therefore, there is no Compatibility Issue."
565,<android.service.notification.StatusBarNotification: StatusBarNotification clone()>,29,30,<android.service.notification.StatusBarNotification: StatusBarNotification clone()>,<android.service.notification.StatusBarNotification: StatusBarNotification clone()>,0,"{
    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, this.notification.clone(), this.user, this.overrideGroupKey, this.postTime);
}","{
    return cloneShallow(this.notification.clone());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from creating a new `StatusBarNotification` object using multiple properties of the current object to calling `cloneShallow(this.notification.clone())`, and the implementation details of the clone process may have changed since it now relies on a new method `cloneShallow`. Therefore, the code change type is 1 for the return statement and 5 for the dependent API change.","The change of the return statement indicates that the API may return a different value or type because the implementation of the cloning process is no longer explicit in the API but abstracted to the method `cloneShallow`. This abstraction could potentially alter the behavior of the object being cloned. Therefore, the CI type is 1 due to potential different return values."
566,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceIdle()>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceIdle()>,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceIdle()>,0,"{
    if (DEBUG) {
        Log.d(TAG, ""Camera now idle"");
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        if (!CameraDeviceImpl.this.mIdle) {
            final long ident = Binder.clearCallingIdentity();
            try {
                CameraDeviceImpl.this.mDeviceExecutor.execute(mCallOnIdle);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
        CameraDeviceImpl.this.mIdle = true;
    }
}","{
    CameraDeviceImpl.this.onDeviceIdle();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation of the method has been completely changed. It now only calls `CameraDeviceImpl.this.onDeviceIdle()` instead of the previous block of code. This is a change in the body of the method (other statement changed), as well as a control dependency change because the early version contained a condition and synchronization block which is no longer present.","There doesn't appear to be a compatibility issue due to the change in method implementation because no new exceptions are introduced nor is there a change in return statements (the method is void type). The work has been offloaded to another method within the same class, which is assumed to carry out the same functionality without changing the behavior that external callers rely upon."
567,<android.hardware.display.BrightnessConfiguration.Builder: BrightnessConfiguration build()>,29,30,<android.hardware.display.BrightnessConfiguration.Builder: BrightnessConfiguration build()>,<android.hardware.display.BrightnessConfiguration.Builder: BrightnessConfiguration build()>,0,"{
    if (mCurveLux == null || mCurveNits == null) {
        throw new IllegalStateException(""A curve must be set!"");
    }
    return new BrightnessConfiguration(mCurveLux, mCurveNits, mCorrectionsByPackageName, mCorrectionsByCategory, mDescription);
}","{
    if (mCurveLux == null || mCurveNits == null) {
        throw new IllegalStateException(""A curve must be set!"");
    }
    return new BrightnessConfiguration(mCurveLux, mCurveNits, mCorrectionsByPackageName, mCorrectionsByCategory, mDescription, mShouldCollectColorSamples, mShortTermModelTimeout, mShortTermModelLowerLuxMultiplier, mShortTermModelUpperLuxMultiplier);
}",1,"/**
 * Builds the {@link BrightnessConfiguration}.
 */
","/**
 * Builds the {@link BrightnessConfiguration}.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,1,1,"The instantiation of the BrightnessConfiguration in the return statement has changed, with additional parameters passed to the constructor in the Late_Implementation, so the code change type is 1.","Because additional parameters are passed in the constructor of BrightnessConfiguration, this could potentially lead to different behavior as the constructed object may have different state, thus the CI type is 1."
568,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,29,30,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,0,"{
    if (getState() != STATE_ON) {
        return BluetoothProfile.STATE_DISCONNECTED;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getProfileConnectionState(profile);
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""getProfileConnectionState:"", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}","{
    if (getState() != STATE_ON) {
        return BluetoothProfile.STATE_DISCONNECTED;
    }
    return mGetProfileConnectionStateCache.query(new Integer(profile));
}",1,"/**
 * Get the current connection state of a profile.
 * This function can be used to check whether the local Bluetooth adapter
 * is connected to any remote device for a specific profile.
 * Profile can be one of {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 *
 * <p> Return value can be one of
 * {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING},
 * {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING}
 */
","/**
 * Get the current connection state of a profile.
 * This function can be used to check whether the local Bluetooth adapter
 * is connected to any remote device for a specific profile.
 * Profile can be one of {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 *
 * <p> Return value can be one of
 * {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING},
 * {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING}
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The control dependency, return statement, and dependent API have changed. The control dependency has changed with the removal of the try-catch-finally block. The return statement changed because it no longer returns a value from the mService.getProfileConnectionState(profile) call, but instead from mGetProfileConnectionStateCache.query(new Integer(profile)). The dependent API has changed from mService.getProfileConnectionState(profile) to mGetProfileConnectionStateCache.query(new Integer(profile)), indicating a change in the method that is used to obtain the connection state, so the code change type is 1,3,5.","The return statement previously returned the value from the Bluetooth service directly, which could throw a RemoteException, and now it returns a potentially cached value from a different method. This could lead to different return values, especially if the cache is not in sync with the current state at the moment it's queried, representing a potential CI, so the CI type is 1."
569,<android.os.PowerManager: int getCurrentThermalStatus()>,29,30,<android.os.PowerManager: int getCurrentThermalStatus()>,<android.os.PowerManager: int getCurrentThermalStatus()>,0,"{
    synchronized (this) {
        if (mThermalService == null) {
            mThermalService = IThermalService.Stub.asInterface(ServiceManager.getService(Context.THERMAL_SERVICE));
        }
        try {
            return mThermalService.getCurrentThermalStatus();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    try {
        return mThermalService.getCurrentThermalStatus();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * This function returns the current thermal status of the device.
 *
 * @return thermal status as int, {@link #THERMAL_STATUS_NONE} if device in not under
 * thermal throttling.
 */
","/**
 * This function returns the current thermal status of the device.
 *
 * @return thermal status as int, {@link #THERMAL_STATUS_NONE} if device in not under
 * thermal throttling.
 */
",-1,[@ThermalStatus],[@ThermalStatus],-1,-1,-1,-1,-1,-1,"3,4",0,"The synchronization block and the conditional block for checking and assigning `mThermalService` have been removed in the late version. Therefore, the code change types are 3 (control dependency change) and 4 (other statement changed).","There is no compatibility issue arising from these changes because although the surrounding code structure changed with the removal of a synchronization block and a service initialization check, the behavior of the actual 'getCurrentThermalStatus()' method invocation and the way RemoteException is handled have not changed. The API is still throwing the same exception and should return the same value. Hence, the CI type is 0."
570,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,29,30,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,0,"{
    markUsed();
    return new WifiDeviceFilter(mNamePattern);
}","{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x8;
    if ((mBuilderFieldsSet & 0x1) == 0) {
        mNamePattern = null;
    }
    if ((mBuilderFieldsSet & 0x2) == 0) {
        mBssid = null;
    }
    if ((mBuilderFieldsSet & 0x4) == 0) {
        mBssidMask = MacAddress.BROADCAST_ADDRESS;
    }
    WifiDeviceFilter o = new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask);
    return o;
}",1,"/**
 * @inheritDoc
 */
","/**
 * Builds the instance. This builder should not be touched after calling this!
 */
",-1,"[@Override, @NonNull]",[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"In the late version, there are multiple changes: a change in the method being called from `markUsed()` to `checkNotUsed()`, additional field checks with bitwise operations, the introduction of new fields (`mBssid`, `mBssidMask`), and the `WifiDeviceFilter` constructor now takes additional parameters. These modifications result in a change in the return statement, as well as other statement changes, so the code change type is 1,4.","Due to the introduction of new fields in the `WifiDeviceFilter` constructor and the conditions that set the default values for these fields when they are not set in the builder, the return value of the function could potentially be different between versions. Thus, the CI type is 1."
571,"<android.view.textclassifier.SelectionEvent: SelectionEvent createSelectionModifiedEvent(int,int,TextClassification)>",29,30,"<android.view.textclassifier.SelectionEvent: SelectionEvent createSelectionModifiedEvent(int,int,TextClassification)>","<android.view.textclassifier.SelectionEvent: SelectionEvent createSelectionModifiedEvent(int,int,TextClassification)>",0,"{
    Preconditions.checkArgument(end >= start, ""end cannot be less than start"");
    Preconditions.checkNotNull(classification);
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    return new SelectionEvent(start, end, SelectionEvent.EVENT_SELECTION_MODIFIED, entityType, INVOCATION_UNKNOWN, classification.getId());
}","{
    Preconditions.checkArgument(end >= start, ""end cannot be less than start"");
    Objects.requireNonNull(classification);
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    return new SelectionEvent(start, end, SelectionEvent.EVENT_SELECTION_MODIFIED, entityType, INVOCATION_UNKNOWN, classification.getId());
}",1,"/**
 * Creates a ""selection modified"" event.
 * Use when the user modifies the selection and the selection's entity type is known.
 *
 * @param start  the start (inclusive) index of the selection
 * @param end  the end (exclusive) index of the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 *
 * @throws IllegalArgumentException if end is less than start
 */
","/**
 * Creates a ""selection modified"" event.
 * Use when the user modifies the selection and the selection's entity type is known.
 *
 * @param start  the start (inclusive) index of the selection
 * @param end  the end (exclusive) index of the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 *
 * @throws IllegalArgumentException if end is less than start
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The preconditions check has been changed from Preconditions.checkNotNull(classification) to Objects.requireNonNull(classification), which is a change in the method used for null checking. So, the code change type is 4.","The change from Preconditions.checkNotNull to Objects.requireNonNull does not affect the behavior of the API because they both serve the same purpose: to throw a NullPointerException when 'classification' is null. There are no other changes that could affect the return value or the exceptions thrown by the API. Therefore, there is no Compatibility Issue."
573,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: String toString()>,29,30,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: String toString()>,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: String toString()>,0,"{
    return ""ControlledInputConnectionWrapper{"" + ""connection="" + getInputConnection() + "" finished="" + isFinished() + "" mParentInputMethodManager.mActive="" + mParentInputMethodManager.mActive + ""}"";
}","{
    return ""ControlledInputConnectionWrapper{"" + ""connection="" + getInputConnection() + "" finished="" + isFinished() + "" mParentInputMethodManager.mActive="" + mParentInputMethodManager.mActive + "" mServedView="" + mServedView.get() + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement in the late version adds ""mServedView="" + mServedView.get() to the string being returned. This is the addition of a method call to the return statement, which counts as a change type of 4 (Other statement changed) since it's a change that does not fit into the categories of control structure or exception handling, and it is also a change type of 1 (Return statement changed) because it modifies the return value.","The addition of ""mServedView="" + mServedView.get() to the return value alters the string that this method returns, which could affect any client code that relies on the specific format or content of the string representation of the object. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
574,<android.util.Half: int getSignificand(short)>,29,30,<android.util.Half: int getSignificand(short)>,<android.util.Half: int getSignificand(short)>,0,"{
    return h & FP16_SIGNIFICAND_MASK;
}","{
    return h & FP16.SIGNIFICAND_MASK;
}",1,"/**
 * Returns the significand, or mantissa, used in the representation
 * of the specified half-precision float value.
 *
 * @param h A half-precision float value
 * @return The significand, or significand, of the specified vlaue
 */
","/**
 * Returns the significand, or mantissa, used in the representation
 * of the specified half-precision float value.
 *
 * @param h A half-precision float value
 * @return The significand, or significand, of the specified vlaue
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change between the two versions is from FP16_SIGNIFICAND_MASK to FP16.SIGNIFICAND_MASK, which signifies a change in accessing the constant value (possibly an enclosing class or scope change). This is a dependent API change, so the code change type is 5.","There is no Compatibility Issue since the actual operation performed (bitwise AND with a constant) remains the same. The constant value itself would not have changed because it's a fundamental property of the half-precision floating-point format; thus, it is unlikely for the constant's value to be different between versions. Therefore, we can conclude that there's no compatibility issue introduced by this change."
577,<android.util.TimeUtils: List<String> getTimeZoneIdsForCountryCode(String)>,29,30,<android.util.TimeUtils: List<String> getTimeZoneIdsForCountryCode(String)>,<android.util.TimeUtils: List<String> getTimeZoneIdsForCountryCode(String)>,0,"{
    if (countryCode == null) {
        throw new NullPointerException(""countryCode == null"");
    }
    TimeZoneFinder timeZoneFinder = TimeZoneFinder.getInstance();
    CountryTimeZones countryTimeZones = timeZoneFinder.lookupCountryTimeZones(countryCode.toLowerCase());
    if (countryTimeZones == null) {
        return null;
    }
    List<String> timeZoneIds = new ArrayList<>();
    for (TimeZoneMapping timeZoneMapping : countryTimeZones.getTimeZoneMappings()) {
        if (timeZoneMapping.showInPicker) {
            timeZoneIds.add(timeZoneMapping.timeZoneId);
        }
    }
    return Collections.unmodifiableList(timeZoneIds);
}","{
    if (countryCode == null) {
        throw new NullPointerException(""countryCode == null"");
    }
    TimeZoneFinder timeZoneFinder = TimeZoneFinder.getInstance();
    CountryTimeZones countryTimeZones = timeZoneFinder.lookupCountryTimeZones(countryCode.toLowerCase());
    if (countryTimeZones == null) {
        return null;
    }
    List<String> timeZoneIds = new ArrayList<>();
    for (TimeZoneMapping timeZoneMapping : countryTimeZones.getTimeZoneMappings()) {
        if (timeZoneMapping.isShownInPicker()) {
            timeZoneIds.add(timeZoneMapping.getTimeZoneId());
        }
    }
    return Collections.unmodifiableList(timeZoneIds);
}",1,"/**
 * Returns time zone IDs for time zones known to be associated with a country.
 *
 * <p>The list returned may be different from other on-device sources like
 * {@link android.icu.util.TimeZone#getRegion(String)} as it can be curated to avoid
 * contentious mappings.
 *
 * @param countryCode the ISO 3166-1 alpha-2 code for the country as can be obtained using
 * {@link java.util.Locale#getCountry()}
 * @return IDs that can be passed to {@link java.util.TimeZone#getTimeZone(String)} or similar
 * methods, or {@code null} if the countryCode is unrecognized
 */
","/**
 * Returns time zone IDs for time zones known to be associated with a country.
 *
 * <p>The list returned may be different from other on-device sources like
 * {@link android.icu.util.TimeZone#getRegion(String)} as it can be curated to avoid
 * contentious or obsolete mappings.
 *
 * @param countryCode the ISO 3166-1 alpha-2 code for the country as can be obtained using
 * {@link java.util.Locale#getCountry()}
 * @return IDs that can be passed to {@link java.util.TimeZone#getTimeZone(String)} or similar
 * methods, or {@code null} if the countryCode is unrecognized
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The methods used within the for loop have been changed: timeZoneMapping.showInPicker to timeZoneMapping.isShownInPicker() and timeZoneMapping.timeZoneId to timeZoneMapping.getTimeZoneId(). These changes are method calls on a dependent API, so the code change type is 5.","This change does not introduce a compatibility issue because the modified methods (isShownInPicker and getTimeZoneId) are likely to be getter methods that provide the same functionality as the previous direct field access. Assuming the behavior of these methods has not been altered in a way that would change the output of timeZoneIds, there are no compatibility issues caused by these changes. Hence, CI type is 0."
578,<android.widget.Toast.TN: void handleHide()>,29,30,<android.widget.Toast.TN: void handleHide()>,<android.widget.Toast.TN: void handleHide()>,0,"{
    if (localLOGV)
        Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView="" + mView);
    if (mView != null) {
        // the view isn't yet added, so let's try not to crash.
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeViewImmediate(mView);
        }
        // the resources.
        try {
            getService().finishToken(mPackageName, this);
        } catch (RemoteException e) {
        }
        mView = null;
    }
}","{
    if (localLOGV)
        Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView="" + mView);
    if (mView != null) {
        checkState(mView == mPresenter.getView(), ""Trying to hide toast view different than the last one displayed"");
        mPresenter.hide(new CallbackBinder(getCallbacks(), mHandler));
        mView = null;
    }
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"The method implementation has several changes. The mWM.removeViewImmediate(mView); and the code block that involves the try-catch for RemoteException have been removed. These are replaced by a new method checkState() and a new way to hide the view through mPresenter.hide(). These changes fall under Return statement changed (since the control flow is altered and no longer contains the try-catch block resulting in the finishing token for the service), Control dependency changed (as there is a new checkState method affecting flow control), Other statement changed (due to the overall change in method structure), and Dependent API changed (since new methods 'checkState' and 'mPresenter.hide()' are now being used). ","While many parts of the method have changed, the method still has no return statements; thus, it’s not possible to return a different value. The method was void and remains void. Regarding exception handling, the previous version caught and suppressed RemoteException, while the new version does not catch any exception at all. There is no change to the behavior that would lead to Compatibility Issues, as RemoteException, if thrown, would have been suppressed in the old version and will now propagate up the call stack in the new version. This is not something typically considered a compatibility-breaking change for void methods, as it does not affect the callers of the method unless they were mistakenly relying on no exceptions being thrown (which is generally not a recommended practice, especially for a method marked @UnsupportedAppUsage). Therefore, there is no Compatibility Issue."
580,<android.hardware.camera2.impl.CameraDeviceImpl: void finalizeOutputConfigs(List<OutputConfiguration>)>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void finalizeOutputConfigs(List<OutputConfiguration>)>,<android.hardware.camera2.impl.CameraDeviceImpl: void finalizeOutputConfigs(List<OutputConfiguration>)>,0,"{
    if (outputConfigs == null || outputConfigs.size() == 0) {
        throw new IllegalArgumentException(""deferred config is null or empty"");
    }
    synchronized (mInterfaceLock) {
        for (OutputConfiguration config : outputConfigs) {
            int streamId = -1;
            for (int i = 0; i < mConfiguredOutputs.size(); i++) {
                // createReprocessableCaptureSessionByConfigurations() do a copy of the configs.
                if (config.equals(mConfiguredOutputs.valueAt(i))) {
                    streamId = mConfiguredOutputs.keyAt(i);
                    break;
                }
            }
            if (streamId == -1) {
                throw new IllegalArgumentException(""Deferred config is not part of this "" + ""session"");
            }
            if (config.getSurfaces().size() == 0) {
                throw new IllegalArgumentException(""The final config for stream "" + streamId + "" must have at least 1 surface"");
            }
            mRemoteDevice.finalizeOutputConfigurations(streamId, config);
            mConfiguredOutputs.put(streamId, config);
        }
    }
}","{
    if (outputConfigs == null || outputConfigs.size() == 0) {
        throw new IllegalArgumentException(""deferred config is null or empty"");
    }
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        for (OutputConfiguration config : outputConfigs) {
            int streamId = -1;
            for (int i = 0; i < mConfiguredOutputs.size(); i++) {
                // createReprocessableCaptureSessionByConfigurations() do a copy of the configs.
                if (config.equals(mConfiguredOutputs.valueAt(i))) {
                    streamId = mConfiguredOutputs.keyAt(i);
                    break;
                }
            }
            if (streamId == -1) {
                throw new IllegalArgumentException(""Deferred config is not part of this "" + ""session"");
            }
            if (config.getSurfaces().size() == 0) {
                throw new IllegalArgumentException(""The final config for stream "" + streamId + "" must have at least 1 surface"");
            }
            mRemoteDevice.finalizeOutputConfigurations(streamId, config);
            mConfiguredOutputs.put(streamId, config);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a new method call (checkIfCameraClosedOrInError()) inside the synchronized block. Thus, the change types are 3 for the control dependency change (introduction of a new call that might throw an exception or change state) and 4 for other statement changed.","There is no Compatibility Issue because the newly introduced method call (checkIfCameraClosedOrInError()) is expected to be an internal check that shouldn't affect the external behavior of the existing API, as long as it doesn't introduce a new type of exception or alter the API's return values, which is not apparent from the given context. The existing exception types and the conditions that throw them have not been modified."
581,<android.view.WindowInsets: WindowInsets consumeDisplayCutout()>,29,30,<android.view.WindowInsets: WindowInsets consumeDisplayCutout()>,<android.view.WindowInsets: WindowInsets consumeDisplayCutout()>,0,"{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, null);
}","{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, null, /* displayCutout */
    mCompatInsetsTypes, mCompatIgnoreVisibility);
}",1,"/**
 * Returns a copy of this WindowInsets with the cutout fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */
","/**
 * Returns a copy of this WindowInsets with the cutout fully consumed.
 *
 * @return A modified copy of this WindowInsets
 * @deprecated Consuming of different parts individually of a {@link WindowInsets} instance is
 * deprecated, since {@link WindowInsets} contains many different insets. Use {@link #CONSUMED}
 * instead to stop dispatching insets.
 */
",-1,[@NonNull],"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"1,4",1,"The constructor call for `WindowInsets` has two additional parameters in the late version: `mCompatInsetsTypes` and `mCompatIgnoreVisibility`. This accounts for a change in a statement that is not a control dependency (4). However, the fundamental operation of the method, which is to consume the display cutout and return a new `WindowInsets` object, remains the same but with more information in the late version. Hence there is also a return statement change (1).","Since the new `WindowInsets` object is being created with additional parameters, users of this API could observe different behavior after the change, potentially if they rely on the new parameters being passed. Consequently, the compatibility issue arises due to the potential for different return values or types (1)."
582,"<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>",29,30,"<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>","<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>",0,"{
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}","{
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}",1,"/**
 * Registers a PendingIntent to be sent when a network is available which satisfies the given
 * {@link NetworkRequest}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)}.
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 */
","/**
 * Registers a PendingIntent to be sent when a network is available which satisfies the given
 * {@link NetworkRequest}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)}.
 *
 * <p>To avoid performance issues due to apps leaking callbacks, the system will limit the
 * number of outstanding requests to 100 per app (identified by their UID), shared with
 * all variants of this method, of {@link #requestNetwork} as well as
 * {@link ConnectivityDiagnosticsManager#registerConnectivityDiagnosticsCallback}.
 * Requesting a network with this method will count toward this limit. If this limit is
 * exceeded, an exception will be thrown. To avoid hitting this issue and to conserve resources,
 * make sure to unregister the callbacks with {@link #unregisterNetworkCallback(PendingIntent)}
 * or {@link #releaseNetworkRequest(PendingIntent)}.
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws RuntimeException if the app already has too many callbacks registered.
 */
",-1,[@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)],[@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call within the method `mService.pendingListenForNetwork()` has changed by adding an extra parameter `mContext.getOpPackageName()`, so this is the change of a dependent API (5).","The change made by adding a parameter to the `mService.pendingListenForNetwork()` call does not inherently affect the behavior of the method from the caller's perspective, as this addition seems to be about providing context for the operation within the service. The method signatures, return type, and exception handling have not changed. Thus, there should be no Compatibility Issue (0)."
583,<android.service.autofill.FillResponse: String toString()>,29,30,<android.service.autofill.FillResponse: String toString()>,<android.service.autofill.FillResponse: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    final StringBuilder builder = new StringBuilder(""FillResponse : [mRequestId="" + mRequestId);
    if (mDatasets != null) {
        builder.append("", datasets="").append(mDatasets.getList());
    }
    if (mSaveInfo != null) {
        builder.append("", saveInfo="").append(mSaveInfo);
    }
    if (mClientState != null) {
        builder.append("", hasClientState"");
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mHeader != null) {
        builder.append("", hasHeader"");
    }
    if (mFooter != null) {
        builder.append("", hasFooter"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    if (mAuthenticationIds != null) {
        builder.append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds));
    }
    builder.append("", disableDuration="").append(mDisableDuration);
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mFieldClassificationIds != null) {
        builder.append(Arrays.toString(mFieldClassificationIds));
    }
    if (mUserData != null) {
        builder.append("", userData="").append(mUserData);
    }
    return builder.append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    final StringBuilder builder = new StringBuilder(""FillResponse : [mRequestId="" + mRequestId);
    if (mDatasets != null) {
        builder.append("", datasets="").append(mDatasets.getList());
    }
    if (mSaveInfo != null) {
        builder.append("", saveInfo="").append(mSaveInfo);
    }
    if (mClientState != null) {
        builder.append("", hasClientState"");
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mHeader != null) {
        builder.append("", hasHeader"");
    }
    if (mFooter != null) {
        builder.append("", hasFooter"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    if (mAuthenticationIds != null) {
        builder.append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds));
    }
    builder.append("", disableDuration="").append(mDisableDuration);
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mFieldClassificationIds != null) {
        builder.append(Arrays.toString(mFieldClassificationIds));
    }
    if (mUserData != null) {
        builder.append("", userData="").append(mUserData);
    }
    if (mCancelIds != null) {
        builder.append("", mCancelIds="").append(mCancelIds.length);
    }
    builder.append("", mSupportInlinePresentations="").append(mSupportsInlineSuggestions);
    return builder.append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement in the late implementation has been extended with additional string concatenations ("", mCancelIds="" and the mCancelIds length, "", mSupportInlinePresentations="" and the mSupportsInlineSuggestions value). This is a change in the method body that doesn't affect the control flow but rather the content of the string returned. There's also a new variable `mInlinePresentation` being checked in the concatenation process, and there are new variables `mCancelIds` and `mSupportsInlineSuggestions` involved in the string-building process. Therefore, we have return statement changes as well as other changes that do not fit within the categories of control dependency or exception handling, which categorizes the change as 1,4.","Given that the return type is a String and the implementation now includes new conditions and values that change the content of the string returned by the `toString()` method, the potential behavior of the API has changed with respect to its outputs. Hence, there is a Compatibility Issue due to different return values, which classifies as type 1."
584,<android.content.ContentProvider: String getCallingPackage()>,29,30,<android.content.ContentProvider: String getCallingPackage()>,<android.content.ContentProvider: String getCallingPackage()>,0,"{
    final String pkg = mCallingPackage.get();
    if (pkg != null) {
        mTransport.mAppOpsManager.checkPackage(Binder.getCallingUid(), pkg);
    }
    return pkg;
}","{
    final Pair<String, String> pkg = mCallingPackage.get();
    if (pkg != null) {
        mTransport.mAppOpsManager.checkPackage(Binder.getCallingUid(), pkg.first);
        return pkg.first;
    }
    return null;
}",1,"/**
 * Return the package name of the caller that initiated the request being
 * processed on the current thread. The returned package will have been
 * verified to belong to the calling UID. Returns {@code null} if not
 * currently processing a request.
 * <p>
 * This will always return {@code null} when processing
 * {@link #getType(Uri)} or {@link #getStreamTypes(Uri, String)} requests.
 *
 * @see Binder#getCallingUid()
 * @see Context#grantUriPermission(String, Uri, int)
 * @throws SecurityException if the calling package doesn't belong to the
 * calling UID.
 */
","/**
 * Return the package name of the caller that initiated the request being
 * processed on the current thread. The returned package will have been
 * verified to belong to the calling UID. Returns {@code null} if not
 * currently processing a request.
 * <p>
 * This will always return {@code null} when processing
 * {@link #getType(Uri)} or {@link #getStreamTypes(Uri, String)} requests.
 *
 * @see Binder#getCallingUid()
 * @see Context#grantUriPermission(String, Uri, int)
 * @throws SecurityException if the calling package doesn't belong to the
 * calling UID.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed with new control logic added. In the early version, a String was returned regardless of the conditional check, while in the late version, the method returns either the first element of a Pair or null depending on the conditional check. Thus, the code change type is 1,3.","There is a potential for different behavior because the method now returns different parts of the changed type (from String to Pair) and has the possibility of returning null where it previously did not explicitly return null. This will lead to a different return value, thus the CI type is 1."
585,<android.util.Half: float toFloat(short)>,29,30,<android.util.Half: float toFloat(short)>,<android.util.Half: float toFloat(short)>,0,"{
    int bits = h & 0xffff;
    int s = bits & FP16_SIGN_MASK;
    int e = (bits >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK;
    int m = (bits) & FP16_SIGNIFICAND_MASK;
    int outE = 0;
    int outM = 0;
    if (e == 0) {
        // Denormal or 0
        if (m != 0) {
            // Convert denorm fp16 into normalized fp32
            float o = Float.intBitsToFloat(FP32_DENORMAL_MAGIC + m);
            o -= FP32_DENORMAL_FLOAT;
            return s == 0 ? o : -o;
        }
    } else {
        outM = m << 13;
        if (e == 0x1f) {
            // Infinite or NaN
            outE = 0xff;
            if (outM != 0) {
                // SNaNs are quieted
                outM |= FP32_QNAN_MASK;
            }
        } else {
            outE = e - FP16_EXPONENT_BIAS + FP32_EXPONENT_BIAS;
        }
    }
    int out = (s << 16) | (outE << FP32_EXPONENT_SHIFT) | outM;
    return Float.intBitsToFloat(out);
}","{
    return FP16.toFloat(h);
}",1,"/**
 * <p>Converts the specified half-precision float value into a
 * single-precision float value. The following special cases are handled:</p>
 * <ul>
 * <li>If the input is {@link #NaN}, the returned value is {@link Float#NaN}</li>
 * <li>If the input is {@link #POSITIVE_INFINITY} or
 * {@link #NEGATIVE_INFINITY}, the returned value is respectively
 * {@link Float#POSITIVE_INFINITY} or {@link Float#NEGATIVE_INFINITY}</li>
 * <li>If the input is 0 (positive or negative), the returned value is +/-0.0f</li>
 * <li>Otherwise, the returned value is a normalized single-precision float value</li>
 * </ul>
 *
 * @param h The half-precision float value to convert to single-precision
 * @return A normalized single-precision float value
 */
","/**
 * <p>Converts the specified half-precision float value into a
 * single-precision float value. The following special cases are handled:</p>
 * <ul>
 * <li>If the input is {@link #NaN}, the returned value is {@link Float#NaN}</li>
 * <li>If the input is {@link #POSITIVE_INFINITY} or
 * {@link #NEGATIVE_INFINITY}, the returned value is respectively
 * {@link Float#POSITIVE_INFINITY} or {@link Float#NEGATIVE_INFINITY}</li>
 * <li>If the input is 0 (positive or negative), the returned value is +/-0.0f</li>
 * <li>Otherwise, the returned value is a normalized single-precision float value</li>
 * </ul>
 *
 * @param h The half-precision float value to convert to single-precision
 * @return A normalized single-precision float value
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The early version contains the actual code for converting a half-precision float (expressed as a short integer) to a regular single-precision float. In the late version, this functionality has been refactored to call FP16.toFloat(h), which is presumably a method that does the equivalent operation. Since this involves a dependent API changing its implementation the code change type is 5.","There is no Compatibility Issue provided that the FP16.toFloat(h) method maintains the same functionality as the implementation in the early version. The change is strictly internal refactoring, and should not affect the behavior as seen by the caller if FP16.toFloat(h) is correctly implemented. Therefore, the CI type is 0."
586,<android.app.Notification.Builder: Notification build()>,29,30,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.validate(mContext);
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (useExistingRemoteView())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    mN.allPendingIntents = null;
    return mN;
}","{
    // Check shortcut id matches
    if (mN.mShortcutId != null && mN.mBubbleMetadata != null && mN.mBubbleMetadata.getShortcutId() != null && !mN.mShortcutId.equals(mN.mBubbleMetadata.getShortcutId())) {
        throw new IllegalArgumentException(""Notification and BubbleMetadata shortcut id's don't match,"" + "" notification: "" + mN.mShortcutId + "" vs bubble: "" + mN.mBubbleMetadata.getShortcutId());
    }
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.validate(mContext);
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (useExistingRemoteView())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    mN.allPendingIntents = null;
    return mN;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 *
 * If this notification has {@link BubbleMetadata} attached that was created with
 * a shortcutId a check will be performed to ensure the shortcutId supplied to bubble
 * metadata matches the shortcutId set on the  notification builder, if one was set.
 * If the shortcutId's were specified but do not match, an exception is thrown here.
 *
 * @see BubbleMetadata.Builder#Builder(String)
 * @see #setShortcutId(String)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"2,4",2,"There's an introduction of a new exception handling statement (throw new IllegalArgumentException) at the beginning of the late version. Additionally, the new code checks if the shortcut id in the notification matches the one in the bubble metadata, which is a new logical check that didn't exist before, so the code change types are 2 and 4.","The new exception handling statement constitutes a change in the potential exceptions the method could throw. Since there's no such check in the early version, clients that worked with the early version could suddenly face an IllegalArgumentException in the late version, which would be an unhandled scenario if they haven't accounted for this new precondition. Therefore, the CI type is 2."
587,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,29,30,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.uncanonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.uncanonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.uncanonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.uncanonicalize(mPackageName, mAttributionTag, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Given a canonical Uri previously generated by {@link #canonicalize}, convert
 * it to its local non-canonical form.  This can be useful in some cases where
 * you know that you will only be using the Uri in the current environment and
 * want to avoid any possible overhead when using it with the content
 * provider or want to verify that the referenced data exists at all in the
 * new environment.
 *
 * @param url The canonical {@link Uri} that is to be convered back to its
 * non-canonical form.
 *
 * @return Returns the non-canonical representation of <var>url</var>.  This will
 * return null if data identified by the canonical Uri can not be found in
 * the current environment; callers must always check for null and deal with
 * that by appropriately falling back to an alternative.
 *
 * @see #canonicalize
 */
","/**
 * Given a canonical Uri previously generated by {@link #canonicalize}, convert
 * it to its local non-canonical form.  This can be useful in some cases where
 * you know that you will only be using the Uri in the current environment and
 * want to avoid any possible overhead when using it with the content
 * provider or want to verify that the referenced data exists at all in the
 * new environment.
 *
 * @param url The canonical {@link Uri} that is to be convered back to its
 * non-canonical form.
 *
 * @return Returns the non-canonical representation of <var>url</var>.  This will
 * return null if data identified by the canonical Uri can not be found in
 * the current environment; callers must always check for null and deal with
 * that by appropriately falling back to an alternative.
 *
 * @see #canonicalize
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,5,1,"The code change is the addition of an extra argument `mAttributionTag` to the `provider.uncanonicalize` method call, so the change type is 5.","The introduction of a new parameter to the method call `provider.uncanonicalize` could potentially change the return value since the behavior of the method could depend on the value of `mAttributionTag`. Thus, a Compatibility Issue could arise due to the potentially different return values or types and the CI type is 1."
588,"<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>",29,30,"<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>","<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>",0,"{
    logErrorForInvalidProfileAccess(user);
    try {
        // that won't return disabled message.
        return maybeUpdateDisabledMessage(mService.getShortcuts(mContext.getPackageName(), query.mChangedSince, query.mPackage, query.mShortcutIds, query.mActivity, query.mQueryFlags, user).getList());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        // that won't return disabled message.
        return maybeUpdateDisabledMessage(mService.getShortcuts(mContext.getPackageName(), new ShortcutQueryWrapper(query), user).getList());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@link ShortcutInfo}s that match {@code query}.
 *
 * <p>Callers must be allowed to access the shortcut information, as defined in {@link
 * #hasShortcutHostPermission()}.
 *
 * @param query result includes shortcuts matching this query.
 * @param user The UserHandle of the profile.
 *
 * @return the IDs of {@link ShortcutInfo}s that match the query.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
","/**
 * Returns {@link ShortcutInfo}s that match {@code query}.
 *
 * <p>Callers must be allowed to access the shortcut information, as defined in {@link
 * #hasShortcutHostPermission()}.
 *
 * @param query result includes shortcuts matching this query.
 * @param user The UserHandle of the profile.
 *
 * @return the IDs of {@link ShortcutInfo}s that match the query.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The method call within `return` has been changed from `mService.getShortcuts` with multiple parameters to `mService.getShortcuts` with a new `ShortcutQueryWrapper` object instead, so the code change type is 5 (Dependent API changed).","The change seems to be internal to how the `ShortcutQuery` parameters are being passed to the `mService.getShortcuts` method. Since the implementation wraps the original `query` object into a new `ShortcutQueryWrapper` before passing it to the service, this doesn't affect the method's behavior from the caller's perspective. There is thus no Compatibility Issue, as the method's signature, return type, and exception handling remain unchanged."
589,"<android.content.pm.LauncherApps: ApplicationInfo getApplicationInfo(String,int,UserHandle)>",29,30,"<android.content.pm.LauncherApps: ApplicationInfo getApplicationInfo(String,int,UserHandle)>","<android.content.pm.LauncherApps: ApplicationInfo getApplicationInfo(String,int,UserHandle)>",0,"{
    Preconditions.checkNotNull(packageName, ""packageName"");
    Preconditions.checkNotNull(user, ""user"");
    logErrorForInvalidProfileAccess(user);
    try {
        final ApplicationInfo ai = mService.getApplicationInfo(mContext.getPackageName(), packageName, flags, user);
        if (ai == null) {
            throw new NameNotFoundException(""Package "" + packageName + "" not found for user "" + user.getIdentifier());
        }
        return ai;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(packageName, ""packageName"");
    Objects.requireNonNull(user, ""user"");
    logErrorForInvalidProfileAccess(user);
    try {
        final ApplicationInfo ai = mService.getApplicationInfo(mContext.getPackageName(), packageName, flags, user);
        if (ai == null) {
            throw new NameNotFoundException(""Package "" + packageName + "" not found for user "" + user.getIdentifier());
        }
        return ai;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@link ApplicationInfo} about an application installed for a specific user profile.
 *
 * @param packageName The package name of the application
 * @param flags Additional option flags {@link PackageManager#getApplicationInfo}
 * @param user The UserHandle of the profile.
 *
 * @return {@link ApplicationInfo} containing information about the package. Returns
 * {@code null} if the package isn't installed for the given profile, or the profile
 * isn't enabled.
 */
","/**
 * Returns {@link ApplicationInfo} about an application installed for a specific user profile.
 *
 * @param packageName The package name of the application
 * @param flags Additional option flags {@link PackageManager#getApplicationInfo}
 * @param user The UserHandle of the profile.
 *
 * @return {@link ApplicationInfo} containing information about the package. Returns
 * {@code null} if the package isn't installed for the given profile, or the profile
 * isn't enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is from Preconditions.checkNotNull to Objects.requireNonNull for checking null references on parameters. This is an internal implementation detail that does not affect the functionality or outward behavior of the API, so the code change type is 4.",There is no Compatibility Issue because the changes do not affect the return value or the exceptions that are thrown by the API. The parameter validation is semantically the same; just the method used for the validation has been changed.
590,"<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(int,Surface)>",29,30,"<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(int,Surface)>","<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(int,Surface)>",0,"{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    if (maxCount <= 0)
        throw new IllegalArgumentException(""Invalid maxCount given: "" + maxCount);
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.prepare2(maxCount, streamId);
    }
}","{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    if (maxCount <= 0)
        throw new IllegalArgumentException(""Invalid maxCount given: "" + maxCount);
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.prepare2(maxCount, streamId);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call checkIfCameraClosedOrInError() has been added to the late version without changing the overall control flow or exception handling, so the code change type is 4.","The additional method call to checkIfCameraClosedOrInError() does not introduce a change in return values or exception thrown semantics (it is a state check method that could raise an exception in case the camera is closed or in error, which would be considered part of the API's normal operation). Adding this check does not impact the API's behavior in a way that wasn't already handled by preexisting checks, thus no compatibility issue is introduced, and the CI type is 0."
591,<android.inputmethodservice.InputMethodService: int getMaxWidth()>,29,30,<android.inputmethodservice.InputMethodService: int getMaxWidth()>,<android.inputmethodservice.InputMethodService: int getMaxWidth()>,0,"{
    WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
    return wm.getDefaultDisplay().getWidth();
}","{
    final WindowManager windowManager = getSystemService(WindowManager.class);
    return WindowMetricsHelper.getBoundsExcludingNavigationBarAndCutout(windowManager.getCurrentWindowMetrics()).width();
}",1,"/**
 * Return the maximum width, in pixels, available the input method.
 * Input methods are positioned at the bottom of the screen and, unless
 * running in fullscreen, will generally want to be as short as possible
 * so should compute their height based on their contents.  However, they
 * can stretch as much as needed horizontally.  The function returns to
 * you the maximum amount of space available horizontally, which you can
 * use if needed for UI placement.
 *
 * <p>In many cases this is not needed, you can just rely on the normal
 * view layout mechanisms to position your views within the full horizontal
 * space given to the input method.
 *
 * <p>Note that this value can change dynamically, in particular when the
 * screen orientation changes.
 */
","/**
 * Return the maximum width, in pixels, available the input method.
 * Input methods are positioned at the bottom of the screen and, unless
 * running in fullscreen, will generally want to be as short as possible
 * so should compute their height based on their contents.  However, they
 * can stretch as much as needed horizontally.  The function returns to
 * you the maximum amount of space available horizontally, which you can
 * use if needed for UI placement.
 *
 * <p>In many cases this is not needed, you can just rely on the normal
 * view layout mechanisms to position your views within the full horizontal
 * space given to the input method.
 *
 * <p>Note that this value can change dynamically, in particular when the
 * screen orientation changes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method implementation has changed where a new method 'WindowMetricsHelper.getBoundsExcludingNavigationBarAndCutout()' is used instead of 'getDefaultDisplay().getWidth()'. Additionally, the way the WindowManager service is obtained has also changed; 'getSystemService(Class)' is used instead of 'getSystemService(String)'. Therefore, the change is in how the width is calculated and obtained (change type 4) and the use of a different dependent API (change type 5).","The late implementation uses a new way to calculate the maximum width which could result in a different value being returned compared to the early implementation. Thus, there is a potential Compatibility Issue due to the different return values (CI type 1)."
595,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",29,30,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",0,"{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        int requestType = request.getRequestType();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                CaptureResult resultInBatch = new CaptureResult(resultLocal, holder.getRequest(i), resultExtras);
                                holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(resultDispatch);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, requestType);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}","{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onResultReceived(result, resultExtras, physicalResults);
            return;
        }
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        int requestType = request.getRequestType();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                CaptureResult resultInBatch = new CaptureResult(resultLocal, holder.getRequest(i), resultExtras);
                                holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(resultDispatch);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, requestType);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
596,<android.hardware.camera2.impl.CameraDeviceImpl: void updateOutputConfiguration(OutputConfiguration)>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void updateOutputConfiguration(OutputConfiguration)>,<android.hardware.camera2.impl.CameraDeviceImpl: void updateOutputConfiguration(OutputConfiguration)>,0,"{
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (config.getSurface() == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Invalid output configuration"");
        }
        mRemoteDevice.updateOutputConfiguration(streamId, config);
        mConfiguredOutputs.put(streamId, config);
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (config.getSurface() == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Invalid output configuration"");
        }
        mRemoteDevice.updateOutputConfiguration(streamId, config);
        mConfiguredOutputs.put(streamId, config);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has been added to call a new method, checkIfCameraClosedOrInError(), but it doesn't affect the method's return value since the method is 'void' type. So, the only change type is 4.","There is no Compatibility Issue detected here because the added method call before the 'for' loop does not alter the behavior of the existing return statements or exception handling. The method is designed to either run checks without altering return values or to throw an exception if the camera is closed or in an error state, which would indicate misuse of the API by the caller. If the check passes successfully, the rest of the method's behavior remains unaltered, hence no CI arises."
597,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,29,30,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,0,"{
    synchronized (this) {
        ensureValidLocked();
        final int[] rawInfoArray = nativeGetResourceStringArrayInfo(mObject, resId);
        if (rawInfoArray == null) {
            return null;
        }
        final int rawInfoArrayLen = rawInfoArray.length;
        final int infoArrayLen = rawInfoArrayLen / 2;
        final CharSequence[] retArray = new CharSequence[infoArrayLen];
        for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
            int cookie = rawInfoArray[i];
            int index = rawInfoArray[i + 1];
            retArray[j] = (index >= 0 && cookie > 0) ? mApkAssets[cookie - 1].getStringFromPool(index) : null;
        }
        return retArray;
    }
}","{
    synchronized (this) {
        ensureValidLocked();
        final int[] rawInfoArray = nativeGetResourceStringArrayInfo(mObject, resId);
        if (rawInfoArray == null) {
            return null;
        }
        final int rawInfoArrayLen = rawInfoArray.length;
        final int infoArrayLen = rawInfoArrayLen / 2;
        final CharSequence[] retArray = new CharSequence[infoArrayLen];
        for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
            int cookie = rawInfoArray[i];
            int index = rawInfoArray[i + 1];
            retArray[j] = (index >= 0 && cookie > 0) ? getPooledStringForCookie(cookie, index) : null;
        }
        return retArray;
    }
}",1,"/**
 * Retrieve the text array associated with a particular resource
 * identifier.
 *
 * @param resId the resource id of the string array
 */
","/**
 * Retrieve the text array associated with a particular resource
 * identifier.
 *
 * @param resId the resource id of the string array
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The internal implementation of how strings are retrieved from the pool has changed from mApkAssets[cookie - 1].getStringFromPool(index) to getPooledStringForCookie(cookie, index), indicating a change in a dependent API, so the code change type is 5.","There is no indication that the change in the dependent API leads to a compatibility issue. The method still returns a CharSequence array derived from string resources, and this behavior appears consistent despite the change in the underlying method used to retrieve the strings. Thus, no compatibility issue is detected."
601,<android.content.ContentProviderOperation.Builder: Builder withValues(ContentValues)>,29,30,<android.content.ContentProviderOperation.Builder: Builder withValues(ContentValues)>,<android.content.ContentProviderOperation.Builder: Builder withValues(ContentValues)>,0,"{
    if (mType != TYPE_INSERT && mType != TYPE_UPDATE && mType != TYPE_ASSERT) {
        throw new IllegalArgumentException(""only inserts, updates, and asserts can have values"");
    }
    if (mValues == null) {
        mValues = new ContentValues();
    }
    mValues.putAll(values);
    return this;
}","{
    assertValuesAllowed();
    ensureValues();
    final ArrayMap<String, Object> rawValues = values.getValues();
    for (int i = 0; i < rawValues.size(); i++) {
        setValue(rawValues.keyAt(i), rawValues.valueAt(i));
    }
    return this;
}",1,"/**
 * The ContentValues to use. This may be null. These values may be overwritten by
 * the corresponding value specified by {@link #withValueBackReference} or by
 * future calls to {@link #withValues} or {@link #withValue}.
 * This can only be used with builders of type insert, update, or assert.
 * @return this builder, to allow for chaining.
 */
","/**
 * Configure the values to use for this operation. This method will
 * replace any previously defined values for the contained keys, but it
 * will not replace any back-reference requests.
 * <p>
 * Any value may be dynamically overwritten using the result of a
 * previous operation by using methods such as
 * {@link #withValueBackReference(String, int)}.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The early implementation contains an exception that gets thrown if the operation type is not INSERT, UPDATE, or ASSERT, while the late version uses the assertValuesAllowed() method, which likely carries out a similar check. The early implementation creates new ContentValues if mValues is null and then uses putAll to add the new values. The late version uses ensureValues() to ensure that mValues is not null and then uses a loop to add the values through the setValue method. The dependent API changes are the calls to ensureValues(), setValue(), and assertValuesAllowed(), as they are either new methods or the existing ones have been significantly refactored. Lastly, the data insertion mechanism has experienced modifications that fall under other statement changes.","Since there is an extraction of conditional checks into separate methods and a shift from direct use of a ContentValues object to individual insertion using a loop and setValue, there is a possibility that the behavior when adding values has changed (e.g., how nulls are dealt with or how duplicates are handled). This entails a potential CI as the method can potentially return a different 'this' object if internal state changes, which is type 1 CI. There is also a change in the way exceptions are handled because assertValuesAllowed() may throw different exceptions or under different conditions compared to the inline check in the early version, which is type 2 CI."
602,<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: Builder setJournalMode(String)>,29,30,<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: Builder setJournalMode(String)>,<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: Builder setJournalMode(String)>,0,"{
    Preconditions.checkNotNull(journalMode);
    mJournalMode = journalMode;
    return this;
}","{
    Objects.requireNonNull(journalMode);
    mJournalMode = journalMode;
    return this;
}",1,"/**
 * Sets <a href=""https://sqlite.org/pragma.html#pragma_journal_mode"">journal mode</a>
 * to use when {@link SQLiteDatabase#ENABLE_WRITE_AHEAD_LOGGING} flag is not set.
 */
","/**
 * Sets <a href=""https://sqlite.org/pragma.html#pragma_journal_mode"">journal mode</a>
 * to use when {@link SQLiteDatabase#ENABLE_WRITE_AHEAD_LOGGING} flag is not set.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change here involves replacing Preconditions.checkNotNull(journalMode) with Objects.requireNonNull(journalMode), which are both used for null check and will throw a null pointer exception if the object is null. Since they perform the same operation, just use a different method from a different class, the type of code change is 4 (Other statement changed).","There is no Compatibility Issue since both the early and the late version methods are intended to perform a null check before assigning the journalMode to mJournalMode. The behavior remains unchanged between versions; thus, no Compatibility Issue should arise, which corresponds to CI type 0 (No Compatibility Issue)."
603,<android.view.textclassifier.TextClassifierEvent.Builder: T setEntityTypes(String)>,29,30,<android.view.textclassifier.TextClassifierEvent.Builder: T setEntityTypes(String)>,<android.view.textclassifier.TextClassifierEvent.Builder: T setEntityTypes(String)>,0,"{
    Preconditions.checkNotNull(entityTypes);
    mEntityTypes = new String[entityTypes.length];
    System.arraycopy(entityTypes, 0, mEntityTypes, 0, entityTypes.length);
    return self();
}","{
    Objects.requireNonNull(entityTypes);
    mEntityTypes = new String[entityTypes.length];
    System.arraycopy(entityTypes, 0, mEntityTypes, 0, entityTypes.length);
    return self();
}",1,"/**
 * Sets the entity types. e.g. {@link TextClassifier#TYPE_ADDRESS}.
 * <p>
 * Supported types:
 * <p>See {@link TextClassifier.EntityType}
 * <p>See {@link ConversationAction.ActionType}
 * <p>See {@link ULocale#toLanguageTag()}
 */
","/**
 * Sets the entity types. e.g. {@link TextClassifier#TYPE_ADDRESS}.
 * <p>
 * Supported types:
 * <p>See {@link TextClassifier.EntityType}
 * <p>See {@link ConversationAction.ActionType}
 * <p>See {@link ULocale#toLanguageTag()}
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is only in the internal implementation from using Preconditions.checkNotNull(entityTypes) to Objects.requireNonNull(entityTypes), which are equivalent in functionality. Therefore, the code change type is 4 (Other statement changed).","There is no compatibility issue because the change does not affect the API's behaviour externally - both versions ensure the entityTypes is not null before proceeding, and would throw a NullPointerException if it were. Thus, the behaviour remains consistent, and no compatibility issue should arise."
605,<android.app.Activity: boolean isInPictureInPictureMode()>,29,30,<android.app.Activity: boolean isInPictureInPictureMode()>,<android.app.Activity: boolean isInPictureInPictureMode()>,0,"{
    try {
        return ActivityTaskManager.getService().isInPictureInPictureMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}","{
    return mIsInPictureInPictureMode;
}",1,"/**
 * Returns true if the activity is currently in picture-in-picture mode.
 * @see android.R.attr#supportsPictureInPicture
 *
 * @return True if the activity is in picture-in-picture mode.
 */
","/**
 * Returns true if the activity is currently in picture-in-picture mode.
 * @see android.R.attr#supportsPictureInPicture
 *
 * @return True if the activity is in picture-in-picture mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The implementation has changed from a method call that checks the picture-in-picture mode via the ActivityTaskManager service to using a direct field access, so the change type is 1.","Since the method in the early version uses a service call to determine the picture-in-picture mode, which could potentially return different results than a simple field access in the late version depending on the state of the field mIsInPictureInPictureMode at runtime, there's a possibility of a different return value. Thus, the CI type is 1."
606,<android.os.UserManager: String getUserName()>,29,30,<android.os.UserManager: String getUserName()>,<android.os.UserManager: String getUserName()>,0,"{
    try {
        return mService.getUserName();
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    if (UserHandle.myUserId() == mUserId) {
        try {
            return mService.getUserName();
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    } else {
        UserInfo userInfo = getUserInfo(mUserId);
        return userInfo == null ? """" : userInfo.name;
    }
}",1,"/**
 * Returns the user name of the user making this call.  This call is only
 * available to applications on the system image; it requires the
 * {@code android.permission.MANAGE_USERS} or {@code android.permission.GET_ACCOUNTS_PRIVILEGED}
 * permissions.
 * @return the user name
 */
","/**
 * Returns the user name of the context user. This call is only available to applications on
 * the system image; it requires the {@code android.permission.MANAGE_USERS} or {@code
 * android.permission.GET_ACCOUNTS_PRIVILEGED} permissions.
 *
 * @return the user name
 */
",-1,,"[@RequiresPermission(anyOf = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.GET_ACCOUNTS_PRIVILEGED }, conditional = true), @UserHandleAware, @NonNull]",-1,-1,-1,-1,-1,-1,"1,3,5","1,2","The late version introduces a conditional statement that checks the user ID which alters the control flow, and it also includes a new return path that uses getUserInfo(mUserId). This indicates a control dependency change (3). Since the late version adds a new way to obtain the user name based on different conditions, this is also a return statement change (1). Moreover, the call to `getUserInfo(mUserId)` is a dependent API change (5), as it is not present in the early version.","The new if-else condition introduces a different behavior, as the user name will now depend on the result of `UserHandle.myUserId() == mUserId`. If `mUserId` is different from the ID of the current user context, the late version will return either an empty string or the name from `userInfo`, which can lead to a different return value (CI type 1). Additionally, there's a change in the exception handling because the new block of code that calls `getUserInfo(mUserId)` does not have a try-catch for `RemoteException`. Hence, there could be a different exception handling behavior if `getUserInfo(mUserId)` throws an unchecked exception, categorizing this as a CI type 2."
607,<android.widget.AnalogClock: void onAttachedToWindow()>,29,30,<android.widget.AnalogClock: void onAttachedToWindow()>,<android.widget.AnalogClock: void onAttachedToWindow()>,0,"{
    super.onAttachedToWindow();
    if (!mAttached) {
        mAttached = true;
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_TIME_TICK);
        filter.addAction(Intent.ACTION_TIME_CHANGED);
        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
        // OK, this is gross but needed. This class is supported by the
        // remote views machanism and as a part of that the remote views
        // can be inflated by a context for another user without the app
        // having interact users permission - just for loading resources.
        // For exmaple, when adding widgets from a user profile to the
        // home screen. Therefore, we register the receiver as the current
        // user not the one the context is for.
        getContext().registerReceiverAsUser(mIntentReceiver, android.os.Process.myUserHandle(), filter, null, getHandler());
    }
    // NOTE: It's safe to do these after registering the receiver since the receiver always runs
    // in the main thread, therefore the receiver can't run before this method returns.
    // The time zone may have changed while the receiver wasn't registered, so update the Time
    mCalendar = new Time();
    // Make sure we update to the current time
    onTimeChanged();
}","{
    super.onAttachedToWindow();
    if (!mAttached) {
        mAttached = true;
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_TIME_TICK);
        filter.addAction(Intent.ACTION_TIME_CHANGED);
        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
        // OK, this is gross but needed. This class is supported by the
        // remote views machanism and as a part of that the remote views
        // can be inflated by a context for another user without the app
        // having interact users permission - just for loading resources.
        // For exmaple, when adding widgets from a user profile to the
        // home screen. Therefore, we register the receiver as the current
        // user not the one the context is for.
        getContext().registerReceiverAsUser(mIntentReceiver, android.os.Process.myUserHandle(), filter, null, getHandler());
    }
    // NOTE: It's safe to do these after registering the receiver since the receiver always runs
    // in the main thread, therefore the receiver can't run before this method returns.
    // The time zone may have changed while the receiver wasn't registered, so update the Time
    mClock = Clock.systemDefaultZone();
    // Make sure we update to the current time
    onTimeChanged();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the instantiation of the clock from 'new Time()' in the early version to 'Clock.systemDefaultZone()' in the late version (assignment to `mCalendar` changed to assignment to `mClock`), which is neither a return, exception handling, control dependency nor a dependent API change. Hence, the change type is 4.","Since this change is strictly an internal implementation detail and does not affect the method's return type or exception handling behavior, it does not introduce a compatibility issue based on the given rule-set. The method's signature, return type, and exception behavior remain unaffected. Thus, no compatibility issue exists (0)."
609,<android.app.ContextImpl: File[] getExternalMediaDirs()>,29,30,<android.app.ContextImpl: File[] getExternalMediaDirs()>,<android.app.ContextImpl: File[] getExternalMediaDirs()>,0,"{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppMediaDirs(getPackageName());
        return ensureExternalDirsExistOrFilter(dirs);
    }
}","{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppMediaDirs(getPackageName());
        return ensureExternalDirsExistOrFilter(dirs, true);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of 'ensureExternalDirsExistOrFilter' method now includes an extra boolean parameter 'true', which represents a call to a dependent API with altered parameters. Therefore, the change types are 4 for the added parameter and 5 for the change in the dependent API call.","The modified call to 'ensureExternalDirsExistOrFilter' with the additional parameter can potentially alter the return value of the getExternalMediaDirs() method, leading to a different behavior. If the behavior of 'ensureExternalDirsExistOrFilter' is dependent on the new boolean argument to perform filtering or not, the result array could differ, thus creating a compatibility issue. The CI type is 1, due to the potential different return values."
610,<android.view.WindowInsets: Insets getStableInsets()>,29,30,<android.view.WindowInsets: Insets getStableInsets()>,<android.view.WindowInsets: Insets getStableInsets()>,0,"{
    return getInsets(mTypeMaxInsetsMap, compatSystemInsets());
}","{
    return getInsets(mTypeMaxInsetsMap, mCompatInsetsTypes);
}",1,"/**
 * Returns the stable insets in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The stable insets
 */
","/**
 * Returns the stable insets in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The stable insets
 * @deprecated Use {@link #getInsetsIgnoringVisibility(int)} with {@link Type#systemBars()}
 * instead.
 */
",-1,[@NonNull],"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The parameter passed to getInsets() changed from compatSystemInsets() to mCompatInsetsTypes, which means the dependent API has undergone changes, and therefore the code change type is 5.","Since only the parameter for the getInsets() method has changed and there's no information suggesting that the behavior of getInsets() itself has changed due to this new parameter, we assume it has been designed to maintain the same behavior. Without concrete evidence to the contrary, we can assume that there is no Compatibility Issue in the given context, hence the CI type is 0."
611,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",29,30,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>","<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",0,"{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess(this);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityTaskManager.getService().startActivityIntentSender(mMainThread.getApplicationThread(), intent != null ? intent.getTarget() : null, intent != null ? intent.getWhitelistToken() : null, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData(this);
            fillInIntent.prepareToLeaveProcess(this);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityTaskManager.getService().startActivityIntentSender(mMainThread.getApplicationThread(), intent != null ? intent.getTarget() : null, intent != null ? intent.getWhitelistToken() : null, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only changes to the method's implementation are the arguments passed to the methods 'migrateExtraStreamToClipData()' and 'prepareToLeaveProcess()', which in the early version don't have 'this' passed to them, but in the late version they do. As there is no change in the return type, exception handling, or control flow, and no other API has been changed, the change type is 4.","Since neither the return value nor the exception being thrown is affected, no potential Compatibility Issue arises from this particular change. The method still catches the same exception and rethrows it the same way and the success flow seems uninterrupted with the same return value (void). Hence, there is no Compatibility Issue."
612,<android.service.wallpaper.WallpaperService.Engine: void detach()>,29,30,<android.service.wallpaper.WallpaperService.Engine: void detach()>,<android.service.wallpaper.WallpaperService.Engine: void detach()>,0,"{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mIWallpaperEngine.mDisplayManager != null) {
        mIWallpaperEngine.mDisplayManager.unregisterDisplayListener(mDisplayListener);
    }
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
        // doesn't interpret the input channel being closed as an abnormal termination.
        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }
    }
}","{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mIWallpaperEngine.mDisplayManager != null) {
        mIWallpaperEngine.mDisplayManager.unregisterDisplayListener(mDisplayListener);
    }
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code block related to mInputChannel has been removed, which is part of the logic for disposing resources. The change is classified as type 4 (Other statement changed).","Removing the block of code that disposes of the mInputChannel does not cause a Compatibility Issue. This method is for cleaning up resources when detaching the WallpaperService engine, and the behavior of this method, from the perspective of its main functionality, does not change in a way that would cause it to return a different value or throw a different exception to the caller. Therefore, there is no Compatibility Issue for this change."
614,"<android.hardware.camera2.CameraMetadata: ArrayList<TKey> getKeys(Class<?>,Class<TKey>,CameraMetadata<TKey>,int[],boolean)>",29,30,"<android.hardware.camera2.CameraMetadata: ArrayList<TKey> getKeys(Class<?>,Class<TKey>,CameraMetadata<TKey>,int[],boolean)>","<android.hardware.camera2.CameraMetadata: ArrayList<TKey> getKeys(Class<?>,Class<TKey>,CameraMetadata<TKey>,int[],boolean)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""getKeysStatic for "" + type);
    // TotalCaptureResult does not have any of the keys on it, use CaptureResult instead
    if (type.equals(TotalCaptureResult.class)) {
        type = CaptureResult.class;
    }
    if (filterTags != null) {
        Arrays.sort(filterTags);
    }
    ArrayList<TKey> keyList = new ArrayList<TKey>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(keyClass) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            TKey key;
            try {
                key = (TKey) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError(""Can't get IllegalAccessException"", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError(""Can't get IllegalArgumentException"", e);
            }
            if (instance == null || instance.getProtected(key) != null) {
                if (shouldKeyBeAdded(key, field, filterTags, includeSynthetic)) {
                    keyList.add(key);
                    if (DEBUG) {
                        Log.v(TAG, ""getKeysStatic - key was added - "" + key);
                    }
                } else if (DEBUG) {
                    Log.v(TAG, ""getKeysStatic - key was filtered - "" + key);
                }
            }
        }
    }
    if (null == mNativeInstance) {
        return keyList;
    }
    ArrayList<TKey> vendorKeys = mNativeInstance.getAllVendorKeys(keyClass);
    if (vendorKeys != null) {
        for (TKey k : vendorKeys) {
            String keyName;
            long vendorId;
            if (k instanceof CaptureRequest.Key<?>) {
                keyName = ((CaptureRequest.Key<?>) k).getName();
                vendorId = ((CaptureRequest.Key<?>) k).getVendorId();
            } else if (k instanceof CaptureResult.Key<?>) {
                keyName = ((CaptureResult.Key<?>) k).getName();
                vendorId = ((CaptureResult.Key<?>) k).getVendorId();
            } else if (k instanceof CameraCharacteristics.Key<?>) {
                keyName = ((CameraCharacteristics.Key<?>) k).getName();
                vendorId = ((CameraCharacteristics.Key<?>) k).getVendorId();
            } else {
                continue;
            }
            if (filterTags == null || Arrays.binarySearch(filterTags, CameraMetadataNative.getTag(keyName, vendorId)) >= 0) {
                keyList.add(k);
            }
        }
    }
    return keyList;
}","{
    if (DEBUG)
        Log.v(TAG, ""getKeysStatic for "" + type);
    // TotalCaptureResult does not have any of the keys on it, use CaptureResult instead
    if (type.equals(TotalCaptureResult.class)) {
        type = CaptureResult.class;
    }
    if (filterTags != null) {
        Arrays.sort(filterTags);
    }
    ArrayList<TKey> keyList = new ArrayList<TKey>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(keyClass) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            TKey key;
            try {
                key = (TKey) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError(""Can't get IllegalAccessException"", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError(""Can't get IllegalArgumentException"", e);
            }
            if (instance == null || instance.getProtected(key) != null) {
                if (shouldKeyBeAdded(key, field, filterTags, includeSynthetic)) {
                    keyList.add(key);
                    if (DEBUG) {
                        Log.v(TAG, ""getKeysStatic - key was added - "" + key);
                    }
                } else if (DEBUG) {
                    Log.v(TAG, ""getKeysStatic - key was filtered - "" + key);
                }
            }
        }
    }
    if (null == mNativeInstance) {
        return keyList;
    }
    ArrayList<TKey> vendorKeys = mNativeInstance.getAllVendorKeys(keyClass);
    if (vendorKeys != null) {
        for (TKey k : vendorKeys) {
            String keyName;
            long vendorId;
            if (k instanceof CaptureRequest.Key<?>) {
                keyName = ((CaptureRequest.Key<?>) k).getName();
                vendorId = ((CaptureRequest.Key<?>) k).getVendorId();
            } else if (k instanceof CaptureResult.Key<?>) {
                keyName = ((CaptureResult.Key<?>) k).getName();
                vendorId = ((CaptureResult.Key<?>) k).getVendorId();
            } else if (k instanceof CameraCharacteristics.Key<?>) {
                keyName = ((CameraCharacteristics.Key<?>) k).getName();
                vendorId = ((CameraCharacteristics.Key<?>) k).getVendorId();
            } else {
                continue;
            }
            if (filterTags != null && Arrays.binarySearch(filterTags, CameraMetadataNative.getTag(keyName, vendorId)) < 0) {
                // ignore vendor keys not in filterTags
                continue;
            }
            if (instance == null || instance.getProtected(k) != null) {
                keyList.add(k);
            }
        }
    }
    return keyList;
}",1,"/*package*/
","/*package*/
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,,,,
616,"<android.app.admin.DevicePolicyManager: void addUserRestriction(ComponentName,String)>",29,30,"<android.app.admin.DevicePolicyManager: void addUserRestriction(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void addUserRestriction(ComponentName,String)>",0,"{
    throwIfParentInstance(""addUserRestriction"");
    if (mService != null) {
        try {
            mService.setUserRestriction(admin, key, true);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setUserRestriction(admin, key, true, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile or device owner to set a user restriction specified by the key.
 * <p>
 * The calling device admin must be a profile or device owner; if it is not, a security
 * exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param key The key of the restriction. See the constants in {@link android.os.UserManager}
 * for the list of keys.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Called by a profile or device owner to set a user restriction specified by the key.
 * <p>
 * The calling device admin must be a profile or device owner; if it is not, a security
 * exception will be thrown.
 * <p>
 * The profile owner of an organization-owned managed profile may invoke this method on
 * the {@link DevicePolicyManager} instance it obtained from
 * {@link #getParentProfileInstance(ComponentName)}, for enforcing device-wide restrictions.
 * <p>
 * See the constants in {@link android.os.UserManager} for the list of restrictions that can
 * be enforced device-wide.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param key   The key of the restriction.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The call to the dependent API mService.setUserRestriction has an additional parameter in the late version, and the early version contains a call to throwIfParentInstance which has been removed. However, there is no change in the return type or exception handling, so the type is 4,5.","Although the implementation calls a different version of setUserRestriction and removes the throwIfParentInstance check, these changes do not affect the behavior in terms of changing return types or introducing new exceptions. The method signature indicates that this method is void and doesn't return any value, the additional parameter to the setUserRestriction method doesn't change the possible exceptions thrown as RemoteException is still thrown as before, and the rethrowFromSystemServer call is used to propagate it exactly as in the previous version. Therefore, there are no Compatibility Issues."
617,"<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>",29,30,"<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>","<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>",0,"{
    super.dispatchProvideAutofillStructure(structure, flags);
    if (structure.getChildCount() != 0) {
        return;
    }
    if (!isLaidOut()) {
        if (Helper.sVerbose) {
            Log.v(VIEW_LOG_TAG, ""dispatchProvideAutofillStructure(): not laid out, ignoring "" + mChildrenCount + "" children of "" + getAutofillId());
        }
        return;
    }
    final ChildListForAutofill children = getChildrenForAutofill(flags);
    final int childrenCount = children.size();
    structure.setChildCount(childrenCount);
    for (int i = 0; i < childrenCount; i++) {
        final View child = children.get(i);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideAutofillStructure(cstructure, flags);
    }
    children.recycle();
}","{
    super.dispatchProvideAutofillStructure(structure, flags);
    if (structure.getChildCount() != 0) {
        return;
    }
    if (!isLaidOut()) {
        if (Helper.sVerbose) {
            Log.v(VIEW_LOG_TAG, ""dispatchProvideAutofillStructure(): not laid out, ignoring "" + mChildrenCount + "" children of "" + getAutofillId());
        }
        return;
    }
    final ChildListForAutoFillOrContentCapture children = getChildrenForAutofill(flags);
    final int childrenCount = children.size();
    structure.setChildCount(childrenCount);
    for (int i = 0; i < childrenCount; i++) {
        final View child = children.get(i);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideAutofillStructure(cstructure, flags);
    }
    children.recycle();
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This implementation adds in all child views of the view group, in addition to calling the
 * default {@link View} implementation.
 */
","/**
 * {@inheritDoc}
 *
 * <p>This implementation adds in all child views of the view group, in addition to calling the
 * default {@link View} implementation.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The type for obtaining children has changed from ChildListForAutofill to ChildListForAutoFillOrContentCapture, so the code change is type 5.","There is no Compatibility Issue since the return type and exception handling remain unaffected. The API's behaviour should remain the same from the perspective of the caller, assuming that the method getChildrenForAutofill(flags) still performs its intended function correctly even though its return type has been modified. The change seems to be internal and should not result in a different outcome for API consumers."
619,"<android.app.admin.DevicePolicyManager: void setAccountManagementDisabled(ComponentName,String,boolean)>",29,30,"<android.app.admin.DevicePolicyManager: void setAccountManagementDisabled(ComponentName,String,boolean)>","<android.app.admin.DevicePolicyManager: void setAccountManagementDisabled(ComponentName,String,boolean)>",0,"{
    throwIfParentInstance(""setAccountManagementDisabled"");
    if (mService != null) {
        try {
            mService.setAccountManagementDisabled(admin, accountType, disabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setAccountManagementDisabled(admin, accountType, disabled, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a device owner or profile owner to disable account management for a specific type
 * of account.
 * <p>
 * The calling device admin must be a device owner or profile owner. If it is not, a security
 * exception will be thrown.
 * <p>
 * When account management is disabled for an account type, adding or removing an account of
 * that type will not be possible.
 * <p>
 * From {@link android.os.Build.VERSION_CODES#N} the profile or device owner can still use
 * {@link android.accounts.AccountManager} APIs to add or remove accounts when account
 * management for a specific type is disabled.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param accountType For which account management is disabled or enabled.
 * @param disabled The boolean indicating that account management will be disabled (true) or
 * enabled (false).
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Called by a device owner or profile owner to disable account management for a specific type
 * of account.
 * <p>
 * The calling device admin must be a device owner or profile owner. If it is not, a security
 * exception will be thrown.
 * <p>
 * When account management is disabled for an account type, adding or removing an account of
 * that type will not be possible.
 * <p>
 * From {@link android.os.Build.VERSION_CODES#N} the profile or device owner can still use
 * {@link android.accounts.AccountManager} APIs to add or remove accounts when account
 * management for a specific type is disabled.
 * <p>
 * This method may be called on the {@code DevicePolicyManager} instance returned from
 * {@link #getParentProfileInstance(ComponentName)} by the profile owner on an
 * organization-owned device, to restrict accounts that may not be managed on the primary
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param accountType For which account management is disabled or enabled.
 * @param disabled The boolean indicating that account management will be disabled (true) or
 * enabled (false).
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method 'setAccountManagementDisabled' of 'mService' has been changed by adding a new parameter 'mParentInstance', and the call to 'throwIfParentInstance' has been removed. This affects the dependent API and represents an other statement change, so the code change type is 4,5.","No Compatibility Issue is expected from these changes. The dependent API has changed, and a statement was removed. However, the removal of throwIfParentInstance appears to be a change in internal assertion/checking logic and not in the method's external behavior since the only change is removing the function that throws an exception when 'mParentInstance' is not set correctly. Therefore, since the actual behavior of setting account management disabled state remains the same, no CI is expected, and the type is 0."
620,<android.service.notification.NotificationAssistantService.MyHandler: void handleMessage(Message)>,29,30,<android.service.notification.NotificationAssistantService.MyHandler: void handleMessage(Message)>,<android.service.notification.NotificationAssistantService.MyHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_ENQUEUED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                NotificationChannel channel = (NotificationChannel) args.arg2;
                args.recycle();
                Adjustment adjustment = onNotificationEnqueued(sbn, channel);
                setAdjustmentIssuer(adjustment);
                if (adjustment != null) {
                    if (!isBound()) {
                        Log.w(TAG, ""MSG_ON_NOTIFICATION_ENQUEUED: service not bound, skip."");
                        return;
                    }
                    try {
                        getNotificationInterface().applyEnqueuedAdjustmentFromAssistant(mWrapper, adjustment);
                    } catch (android.os.RemoteException ex) {
                        Log.v(TAG, ""Unable to contact notification manager"", ex);
                        throw ex.rethrowFromSystemServer();
                    } catch (SecurityException e) {
                        // app cannot catch and recover from this, so do on their behalf
                        Log.w(TAG, ""Enqueue adjustment failed; no longer connected"", e);
                    }
                }
                break;
            }
        case MSG_ON_NOTIFICATION_SNOOZED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                String snoozeCriterionId = (String) args.arg2;
                args.recycle();
                onNotificationSnoozedUntilContext(sbn, snoozeCriterionId);
                break;
            }
        case MSG_ON_NOTIFICATIONS_SEEN:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                List<String> keys = (List<String>) args.arg1;
                args.recycle();
                onNotificationsSeen(keys);
                break;
            }
        case MSG_ON_NOTIFICATION_EXPANSION_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                boolean isUserAction = args.argi1 == 1;
                boolean isExpanded = args.argi2 == 1;
                args.recycle();
                onNotificationExpansionChanged(key, isUserAction, isExpanded);
                break;
            }
        case MSG_ON_NOTIFICATION_DIRECT_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                args.recycle();
                onNotificationDirectReplied(key);
                break;
            }
        case MSG_ON_SUGGESTED_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                CharSequence reply = (CharSequence) args.arg2;
                int source = args.argi2;
                args.recycle();
                onSuggestedReplySent(key, reply, source);
                break;
            }
        case MSG_ON_ACTION_INVOKED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                Notification.Action action = (Notification.Action) args.arg2;
                int source = args.argi2;
                args.recycle();
                onActionInvoked(key, action, source);
                break;
            }
        case MSG_ON_ALLOWED_ADJUSTMENTS_CHANGED:
            {
                onAllowedAdjustmentsChanged();
                break;
            }
    }
}","{
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_ENQUEUED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                NotificationChannel channel = (NotificationChannel) args.arg2;
                args.recycle();
                Adjustment adjustment = onNotificationEnqueued(sbn, channel);
                setAdjustmentIssuer(adjustment);
                if (adjustment != null) {
                    if (!isBound()) {
                        Log.w(TAG, ""MSG_ON_NOTIFICATION_ENQUEUED: service not bound, skip."");
                        return;
                    }
                    try {
                        getNotificationInterface().applyEnqueuedAdjustmentFromAssistant(mWrapper, adjustment);
                    } catch (android.os.RemoteException ex) {
                        Log.v(TAG, ""Unable to contact notification manager"", ex);
                        throw ex.rethrowFromSystemServer();
                    } catch (SecurityException e) {
                        // app cannot catch and recover from this, so do on their behalf
                        Log.w(TAG, ""Enqueue adjustment failed; no longer connected"", e);
                    }
                }
                break;
            }
        case MSG_ON_NOTIFICATION_SNOOZED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                String snoozeCriterionId = (String) args.arg2;
                args.recycle();
                onNotificationSnoozedUntilContext(sbn, snoozeCriterionId);
                break;
            }
        case MSG_ON_NOTIFICATIONS_SEEN:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                List<String> keys = (List<String>) args.arg1;
                args.recycle();
                onNotificationsSeen(keys);
                break;
            }
        case MSG_ON_NOTIFICATION_EXPANSION_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                boolean isUserAction = args.argi1 == 1;
                boolean isExpanded = args.argi2 == 1;
                args.recycle();
                onNotificationExpansionChanged(key, isUserAction, isExpanded);
                break;
            }
        case MSG_ON_NOTIFICATION_DIRECT_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                args.recycle();
                onNotificationDirectReplied(key);
                break;
            }
        case MSG_ON_SUGGESTED_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                CharSequence reply = (CharSequence) args.arg2;
                int source = args.argi2;
                args.recycle();
                onSuggestedReplySent(key, reply, source);
                break;
            }
        case MSG_ON_ACTION_INVOKED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                Notification.Action action = (Notification.Action) args.arg2;
                int source = args.argi2;
                args.recycle();
                onActionInvoked(key, action, source);
                break;
            }
        case MSG_ON_ALLOWED_ADJUSTMENTS_CHANGED:
            {
                onAllowedAdjustmentsChanged();
                break;
            }
        case MSG_ON_PANEL_REVEALED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int items = args.argi1;
                args.recycle();
                onPanelRevealed(items);
                break;
            }
        case MSG_ON_PANEL_HIDDEN:
            {
                onPanelHidden();
                break;
            }
        case MSG_ON_NOTIFICATION_VISIBILITY_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                boolean isVisible = args.argi1 == 1;
                args.recycle();
                onNotificationVisibilityChanged(key, isVisible);
                break;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
621,<android.content.ContentProviderOperation: String toString()>,29,30,<android.content.ContentProviderOperation: String toString()>,<android.content.ContentProviderOperation: String toString()>,0,"{
    return ""mType: "" + mType + "", mUri: "" + mUri + "", mSelection: "" + mSelection + "", mExpectedCount: "" + mExpectedCount + "", mYieldAllowed: "" + mYieldAllowed + "", mValues: "" + mValues + "", mValuesBackReferences: "" + mValuesBackReferences + "", mSelectionArgsBackReferences: "" + mSelectionArgsBackReferences;
}","{
    final StringBuilder sb = new StringBuilder(""ContentProviderOperation("");
    sb.append(""type="" + typeToString(mType) + "" "");
    if (mUri != null) {
        sb.append(""uri="" + mUri + "" "");
    }
    if (mValues != null) {
        sb.append(""values="" + mValues + "" "");
    }
    if (mSelection != null) {
        sb.append(""selection="" + mSelection + "" "");
    }
    if (mSelectionArgs != null) {
        sb.append(""selectionArgs="" + mSelectionArgs + "" "");
    }
    if (mExpectedCount != null) {
        sb.append(""expectedCount="" + mExpectedCount + "" "");
    }
    if (mYieldAllowed) {
        sb.append(""yieldAllowed "");
    }
    if (mExceptionAllowed) {
        sb.append(""exceptionAllowed "");
    }
    sb.deleteCharAt(sb.length() - 1);
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation of the method has undergone significant modification by introducing new control flow checks for null values and by using a StringBuilder to build the string rather than concatenating it directly, hence the change types are 1, 3, and 4.","The method now conditionally includes certain parts of the string based on whether the corresponding member variables are null or not, and the format of the string has changed, which means that the string returned by this method will differ from the previous implementation, thus the CI type is 1."
622,<android.view.textclassifier.TextClassifier: TextLinks generateLinks(Request)>,29,30,<android.view.textclassifier.TextClassifier: TextLinks generateLinks(Request)>,<android.view.textclassifier.TextClassifier: TextLinks generateLinks(Request)>,0,"{
    Preconditions.checkNotNull(request);
    Utils.checkMainThread();
    return new TextLinks.Builder(request.getText().toString()).build();
}","{
    Objects.requireNonNull(request);
    Utils.checkMainThread();
    return new TextLinks.Builder(request.getText().toString()).build();
}",1,"/**
 * Generates and returns a {@link TextLinks} that may be applied to the text to annotate it with
 * links information.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * @param request the text links request
 *
 * @see #getMaxGenerateLinksTextLength()
 */
","/**
 * Generates and returns a {@link TextLinks} that may be applied to the text to annotate it with
 * links information.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * @param request the text links request
 *
 * @see #getMaxGenerateLinksTextLength()
 */
",-1,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"The code change is simply the usage of different methods to check for null, where `Preconditions.checkNotNull(request)` is replaced by `Objects.requireNonNull(request)`. Both methods serve the same purpose and will throw a NullPointerException if `request` is null. As this does not alter the behavior or the output of the API, the code change type is 4.","There is no Compatibility Issue as the change does not affect the return value or the way exceptions are handled within the API. The change in null checking mechanism does not inherently alter the control flow or the data flow of the method. Therefore, the CI type is 0."
623,<android.content.pm.PackageInstaller: SessionInfo getActiveStagedSession()>,29,30,<android.content.pm.PackageInstaller: SessionInfo getActiveStagedSession()>,<android.content.pm.PackageInstaller: SessionInfo getActiveStagedSession()>,0,"{
    final List<SessionInfo> stagedSessions = getStagedSessions();
    for (SessionInfo s : stagedSessions) {
        if (s.isStagedSessionApplied() || s.isStagedSessionFailed()) {
            // Finalized session.
            continue;
        }
        if (s.getParentSessionId() != SessionInfo.INVALID_ID) {
            // Child session.
            continue;
        }
        if (s.isCommitted()) {
            return s;
        }
    }
    return null;
}","{
    List<SessionInfo> activeSessions = getActiveStagedSessions();
    return activeSessions.isEmpty() ? null : activeSessions.get(0);
}",1,"/**
 * Returns an active staged session, or {@code null} if there is none.
 *
 * <p>Staged session is active iff:
 * <ul>
 * <li>It is committed, i.e. {@link SessionInfo#isCommitted()} is {@code true}, and
 * <li>it is not applied, i.e. {@link SessionInfo#isStagedSessionApplied()} is {@code
 * false}, and
 * <li>it is not failed, i.e. {@link SessionInfo#isStagedSessionFailed()} is {@code false}.
 * </ul>
 *
 * <p>In case of a multi-apk session, reasoning above is applied to the parent session, since
 * that is the one that should been {@link Session#commit committed}.
 */
","/**
 * Returns first active staged session, or {@code null} if there is none.
 *
 * <p>For more information on what sessions are considered active see
 * {@link SessionInfo#isStagedSessionActive()}.
 *
 * @deprecated Use {@link #getActiveStagedSessions} as there can be more than one active staged
 * session
 */
",-1,[@Nullable],"[@Deprecated, @Nullable]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation has completely changed from iterating over stagedSessions to simply retrieving activeSessions and returning either null or the first session in the list. The method 'getActiveStagedSessions()' is introduced instead of 'getStagedSessions()', and the loop along with condition checks has been replaced by a simpler isEmpty check. Hence, the code change involves the return statement, other statements, and the distinct dependent API change (4,1,5).","Since the way of getting the active staged session has altered fundamentally (from detailed condition checks to just fetching the first of the presumably filtered active sessions), it leads to different return behavior and thus, a potential difference in the returned session info object. Hence, there is a Compatibility Issue due to potential different return values (CI type 1)."
624,<android.view.textclassifier.TextClassificationConstants: boolean isSystemTextClassifierEnabled()>,29,30,<android.view.textclassifier.TextClassificationConstants: boolean isSystemTextClassifierEnabled()>,<android.view.textclassifier.TextClassificationConstants: boolean isSystemTextClassifierEnabled()>,0,"{
    return mConfigParser.getBoolean(SYSTEM_TEXT_CLASSIFIER_ENABLED, SYSTEM_TEXT_CLASSIFIER_ENABLED_DEFAULT);
}","{
    return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_TEXTCLASSIFIER, SYSTEM_TEXT_CLASSIFIER_ENABLED, SYSTEM_TEXT_CLASSIFIER_ENABLED_DEFAULT);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method used to obtain the boolean value is changed from mConfigParser.getBoolean to DeviceConfig.getBoolean with additional parameters, indicating that a different dependent API is being invoked. Therefore, the change type is 5.","Since the source for obtaining the configuration value is changed, it could potentially lead to a different return value. Thus, the CI type is 1."
625,<android.service.notification.ZenPolicy.Builder: Builder disallowAllSounds()>,29,30,<android.service.notification.ZenPolicy.Builder: Builder disallowAllSounds()>,<android.service.notification.ZenPolicy.Builder: Builder disallowAllSounds()>,0,"{
    for (int i = 0; i < mZenPolicy.mPriorityCategories.size(); i++) {
        mZenPolicy.mPriorityCategories.set(i, STATE_DISALLOW);
    }
    mZenPolicy.mPriorityMessages = PEOPLE_TYPE_NONE;
    mZenPolicy.mPriorityCalls = PEOPLE_TYPE_NONE;
    return this;
}","{
    for (int i = 0; i < mZenPolicy.mPriorityCategories.size(); i++) {
        mZenPolicy.mPriorityCategories.set(i, STATE_DISALLOW);
    }
    mZenPolicy.mPriorityMessages = PEOPLE_TYPE_NONE;
    mZenPolicy.mPriorityCalls = PEOPLE_TYPE_NONE;
    mZenPolicy.mConversationSenders = CONVERSATION_SENDERS_NONE;
    return this;
}",1,"/**
 * Intercepts all notifications and prevents them from playing sounds
 * when DND is active. Also mutes alarm, system and media streams.
 * Notification channels can still play sounds only if they
 * {@link NotificationChannel#canBypassDnd can bypass DND}. If no channels can bypass DND,
 * the ringer stream is also muted.
 */
","/**
 * Intercepts all notifications and prevents them from playing sounds
 * when DND is active. Also mutes alarm, system and media streams.
 * Notification channels can still play sounds only if they
 * {@link NotificationChannel#canBypassDnd can bypass DND}. If no channels can bypass DND,
 * the ringer stream is also muted.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is the addition of a single line setting `mZenPolicy.mConversationSenders` to a particular value which doesn't affect the return value or the overall method behavior, so the code change type is 4.","Since no return statement has been changed, and no new exception has been introduced, nor does the change in the method implcitly affect the return type or cause a different exception to be thrown, there is no Compatibility Issue and the CI type is 0."
626,<android.widget.Editor.InsertionPointCursorController: boolean isCursorBeingModified()>,29,30,<android.widget.Editor.InsertionPointCursorController: boolean isCursorBeingModified()>,<android.widget.Editor.InsertionPointCursorController: boolean isCursorBeingModified()>,0,"{
    return mHandle != null && mHandle.isDragging();
}","{
    return mIsDraggingCursor || (mHandle != null && mHandle.isDragging());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"An additional condition 'mIsDraggingCursor ||' is added to the return statement in the late implementation, which is an 'Other statement changed', so the code change type is 4.","The addition of the new condition 'mIsDraggingCursor ||' could potentially lead to the method returning true in cases where it would have previously returned false if 'mHandle' is null or not dragging, which indicates a Compatibility Issue by potentially returning a different value, so the CI type is 1."
628,<android.content.pm.ShortcutInfo.Builder: Builder setLocusId(LocusId)>,29,30,<android.content.pm.ShortcutInfo.Builder: Builder setLocusId(LocusId)>,<android.content.pm.ShortcutInfo.Builder: Builder setLocusId(LocusId)>,0,"{
    mLocusId = Preconditions.checkNotNull(locusId, ""locusId cannot be null"");
    return this;
}","{
    mLocusId = Objects.requireNonNull(locusId, ""locusId cannot be null"");
    return this;
}",1,"/**
 * Sets the {@link LocusId} associated with this shortcut.
 *
 * <p>This method should be called when the {@link LocusId} is used in other places (such
 * as {@link Notification} and {@link ContentCaptureContext}) so the Android system can
 * correlate them.
 */
","/**
 * Sets the {@link LocusId} associated with this shortcut.
 *
 * <p>This method should be called when the {@link LocusId} is used in other places (such
 * as {@link Notification} and {@link ContentCaptureContext}) so the device's intelligence
 * services can correlate them.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The dependent method Preconditions.checkNotNull() has been replaced by Objects.requireNonNull(), thus the change type is 5.","There is no Compatibility Issue since both Preconditions.checkNotNull() and Objects.requireNonNull() are intended to perform the same operation, i.e., to throw a NullPointerException if the passed object is null. Both these methods have the same effect on the program state if the condition is not met."
629,<android.os.Looper: void loop()>,29,30,<android.os.Looper: void loop()>,<android.os.Looper: void loop()>,0,"{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt(""log.looper."" + Process.myUid() + ""."" + Thread.currentThread().getName() + "".slow"", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, ""Drained"");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, ""delivery"", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, ""dispatch"", msg);
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}","{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    if (me.mInLoop) {
        Slog.w(TAG, ""Loop again would have the queued messages be executed"" + "" before this one completed."");
    }
    me.mInLoop = true;
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt(""log.looper."" + Process.myUid() + ""."" + Thread.currentThread().getName() + "".slow"", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, ""Drained"");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, ""delivery"", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, ""dispatch"", msg);
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
631,<android.view.DisplayCutout: String toString()>,29,30,<android.view.DisplayCutout: String toString()>,<android.view.DisplayCutout: String toString()>,0,"{
    return ""DisplayCutout{insets="" + mSafeInsets + "" boundingRect={"" + mBounds + ""}"" + ""}"";
}","{
    return ""DisplayCutout{insets="" + mSafeInsets + "" waterfall="" + mWaterfallInsets + "" boundingRect={"" + mBounds + ""}"" + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation of toString() adds ""waterfall="" + mWaterfallInsets to the return statement, which is also a change in the string concatenation (other statement changed), so the code change type is 1,4.","Since there is an addition of ""waterfall="" + mWaterfallInsets to the return statement, the method will return a different string than before, thus qualifying as a Compatibility Issue of type 1, indicating a potential difference in returned values."
632,<android.service.voice.VoiceInteractionService: void onReady()>,29,30,<android.service.voice.VoiceInteractionService: void onReady()>,<android.service.voice.VoiceInteractionService: void onReady()>,0,"{
    mSystemService = IVoiceInteractionManagerService.Stub.asInterface(ServiceManager.getService(Context.VOICE_INTERACTION_MANAGER_SERVICE));
    mKeyphraseEnrollmentInfo = new KeyphraseEnrollmentInfo(getPackageManager());
}","{
    mSystemService = IVoiceInteractionManagerService.Stub.asInterface(ServiceManager.getService(Context.VOICE_INTERACTION_MANAGER_SERVICE));
    Objects.requireNonNull(mSystemService);
    try {
        mSystemService.asBinder().linkToDeath(mDeathRecipient, 0);
    } catch (RemoteException e) {
        Log.wtf(TAG, ""unable to link to death with system service"");
    }
    mKeyphraseEnrollmentInfo = new KeyphraseEnrollmentInfo(getPackageManager());
}",1,"/**
 * Called during service initialization to tell you when the system is ready
 * to receive interaction from it. You should generally do initialization here
 * rather than in {@link #onCreate}. Methods such as {@link #showSession} and
 * {@link #createAlwaysOnHotwordDetector}
 * will not be operational until this point.
 */
","/**
 * Called during service initialization to tell you when the system is ready
 * to receive interaction from it. You should generally do initialization here
 * rather than in {@link #onCreate}. Methods such as {@link #showSession} and
 * {@link #createAlwaysOnHotwordDetector}
 * will not be operational until this point.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There are a few other statements introduced in the late version: a null check on mSystemService, and a try-catch block to handle linkToDeath for mDeathRecipient, hence the change type is 4,5.","The additional statements in the late version do not affect the API's return value nor its exception handling (as the exception is caught and only a log message is written), so there is no Compatibility Issue; CI type is 0."
635,<android.net.TrafficStats: long getUidRxPackets(int)>,29,30,<android.net.TrafficStats: long getUidRxPackets(int)>,<android.net.TrafficStats: long getUidRxPackets(int)>,0,"{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_RX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}","{
    try {
        return getStatsService().getUidStats(uid, TYPE_RX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return number of packets received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of packets received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency changed as the condition `if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid)` and the else branch returning `UNSUPPORTED` are removed, that is why the code change type is 3.","Despite the change in control dependency, there is no Compatibility Issue found because previously the unsupported value was returned only as a placeholder without enforcing any security or functional constraint; the real traffic statistics enforcement and check occurred at the kernel level outside of this API's scope. Thus, with the removal of this redundant check, the functionality as perceived by the API consumer remains consistent, and there is no expected difference in behavior under the specified conditions, so the CI type is 0."
636,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",29,30,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>","<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",0,"{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken, new UserHandle(UserHandle.getUserId(application.uid)), flags, null, null);
        final int displayId = getDisplayId();
        c.setResources(createResources(mActivityToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}","{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, null, mToken, new UserHandle(UserHandle.getUserId(application.uid)), flags, null, null);
        final int displayId = getDisplayId();
        c.setResources(createResources(mToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo(), null));
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The change involves modifying the creation of `ContextImpl` with different parameter values, specifically setting the third parameter to `null` instead of `mActivityToken`, and passing `mToken` instead of `mActivityToken` to `createResources()`. Additionally, the `createResources` method call's signature has changed by adding an extra `null` parameter at the end. There has been no change to return statements or exception handling, so the change types include control dependency changes (3 - due to the instantiation of `ContextImpl` using different parameters), other statement changes (4), and dependent API changed (5 - as the signature of `createResources` was altered).","Because the construction of `ContextImpl` instances and their associated resources have been altered by changing parameters and dependent API, there is a possibility that the `Context` object returned could be different, especially if the altered or additional parameters affect the state of the created `ContextImpl` object. Therefore, the CI type is 1."
637,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>",29,30,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API called within the method has changed from ActivityManager.getService().broadcastIntent() to ActivityManager.getService().broadcastIntentWithFeature(), and a new parameter `getAttributionTag()` has been introduced, indicating a change of type 5.","There is no Compatibility Issue since the method signature itself has not changed, nor have changes to the method's return value or thrown exceptions occurred. There are also no changes to the return or exception handling statements within the method itself. The addition of the feature does not inherently cause a Compatibility Issue with respect to the API's behavior."
638,<android.os.Parcel: String readString()>,29,30,<android.os.Parcel: String readString()>,<android.os.Parcel: String readString()>,0,"{
    return mReadWriteHelper.readString(this);
}","{
    return readString16();
}",1,"/**
 * Read a string value from the parcel at the current dataPosition().
 */
","/**
 * Read a string value from the parcel at the current dataPosition().
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method changed from invoking mReadWriteHelper.readString(this) to invoking readString16(), indicating the dependent API has changed. The return statement also changed, as a different method for reading strings is being called, thus change types 1,5 apply.","Since the method used to read the string from the Parcel has changed, it could potentially return a different value, which leads to a compatibility issue of type 1."
639,<android.service.dreams.DreamService: IBinder onBind(Intent)>,29,30,<android.service.dreams.DreamService: IBinder onBind(Intent)>,<android.service.dreams.DreamService: IBinder onBind(Intent)>,0,"{
    if (mDebug)
        Slog.v(TAG, ""onBind() intent = "" + intent);
    return new DreamServiceWrapper();
}","{
    if (mDebug)
        Slog.v(TAG, ""onBind() intent = "" + intent);
    mDreamServiceWrapper = new DreamServiceWrapper();
    return mDreamServiceWrapper;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The difference here is the introduction of the field `mDreamServiceWrapper` to store a reference to the newly created `DreamServiceWrapper`. However, the returned object from the two versions of the method is still a `DreamServiceWrapper` and there is no change to the return type or the behavior of the method from an API caller's perspective. So the code change type is 4.","There is no compatibility issue because the return value has not fundamentally changed; it is still an instance of `DreamServiceWrapper`. The fact that the instance is now stored in a member variable `mDreamServiceWrapper` does not affect the behavior of the API method as seen by the caller. Hence, no compatibility issue arises from this code change."
640,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",29,30,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(values, ""values"");
    try {
        if (mWrapped != null)
            return mWrapped.bulkInsert(url, values);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(values, ""values"");
    try {
        if (mWrapped != null)
            return mWrapped.bulkInsert(url, values);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, mAttributionTag, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
","/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The only changes are the replacement of Preconditions.checkNotNull with Objects.requireNonNull, which does not affect behavior, and an additional parameter (mAttributionTag) passed to provider.bulkInsert. There is no change to return statements, exception handling statements, or control statements other than the additional parameter being passed, hence the change type is 4,5.","There's no Compatibility Issue since the method signature, return type, and exception handling have not been altered. The switch from Preconditions.checkNotNull to Objects.requireNonNull doesn't change behavior as both serve to throw a NullPointerException if the given reference is null. The addition of a parameter to the provider.bulkInsert call doesn't cause a Compatibility Issue by itself as this is an internal detail of the implementation that won't affect existing callers of bulkInsert. It's assumed that the definition of provider.bulkInsert has been appropriately updated to handle the new parameter without affecting current functionality. Therefore, no CI is predicted (0)."
641,<android.widget.Toast: void show()>,29,30,<android.widget.Toast: void show()>,<android.widget.Toast: void show()>,0,"{
    if (mNextView == null) {
        throw new RuntimeException(""setView must have been called"");
    }
    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    final int displayId = mContext.getDisplayId();
    try {
        service.enqueueToast(pkg, tn, mDuration, displayId);
    } catch (RemoteException e) {
    // Empty
    }
}","{
    if (Compatibility.isChangeEnabled(CHANGE_TEXT_TOASTS_IN_THE_SYSTEM)) {
        checkState(mNextView != null || mText != null, ""You must either set a text or a view"");
    } else {
        if (mNextView == null) {
            throw new RuntimeException(""setView must have been called"");
        }
    }
    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    final int displayId = mContext.getDisplayId();
    try {
        if (Compatibility.isChangeEnabled(CHANGE_TEXT_TOASTS_IN_THE_SYSTEM)) {
            if (mNextView != null) {
                // It's a custom toast
                service.enqueueToast(pkg, mToken, tn, mDuration, displayId);
            } else {
                // It's a text toast
                ITransientNotificationCallback callback = new CallbackBinder(mCallbacks, mHandler);
                service.enqueueTextToast(pkg, mToken, mText, mDuration, displayId, callback);
            }
        } else {
            service.enqueueToast(pkg, mToken, tn, mDuration, displayId);
        }
    } catch (RemoteException e) {
    // Empty
    }
}",1,"/**
 * Show the view for the specified duration.
 */
","/**
 * Show the view for the specified duration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3","0,1","The control flow has changed due to the addition of a new if-else block with Compatibility.isChangeEnabled(). Inside the new block, a new condition mText != null is introduced, which checks a different member variable. There are also changes in the try block with additional conditional logic surrounding the calls to service.enqueueToast(...) and the introduction of service.enqueueTextToast(...), as well as changes to the parameters passed to these methods. Thus, the code change types are 1 and 3.","Although the implementation has changed significantly including checks and service method calls, the newly introduced Compatibility.isChangeEnabled() is designed to control feature availability based on the device running a particular version of Android, and these checks do not lead to a change in the exception handling which remains unchanged (empty catch blocks). However, there's a potential Compatibility Issue caused by different return values, as the changes involving new conditions and method calls within the try block can lead to different behaviors of the 'show' method. Thus, the CI types are 0 and 1."
642,<android.view.textclassifier.TextClassificationConstants: boolean isModelDarkLaunchEnabled()>,29,30,<android.view.textclassifier.TextClassificationConstants: boolean isModelDarkLaunchEnabled()>,<android.view.textclassifier.TextClassificationConstants: boolean isModelDarkLaunchEnabled()>,0,"{
    return mConfigParser.getBoolean(MODEL_DARK_LAUNCH_ENABLED, MODEL_DARK_LAUNCH_ENABLED_DEFAULT);
}","{
    return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_TEXTCLASSIFIER, MODEL_DARK_LAUNCH_ENABLED, MODEL_DARK_LAUNCH_ENABLED_DEFAULT);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation of the method has changed from calling mConfigParser.getBoolean to DeviceConfig.getBoolean with different parameters, indicating a dependent API change, so the code change type is 5.","The dependent API call change could potentially lead to a different return value because the source of the configuration value has changed from mConfigParser to DeviceConfig, which is a Compatibility Issue of type 1."
643,<android.view.autofill.AutofillManager: List<String> getAvailableFieldClassificationAlgorithms()>,29,30,<android.view.autofill.AutofillManager: List<String> getAvailableFieldClassificationAlgorithms()>,<android.view.autofill.AutofillManager: List<String> getAvailableFieldClassificationAlgorithms()>,0,"{
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getAvailableFieldClassificationAlgorithms(receiver);
        final String[] algorithms = receiver.getStringArrayResult();
        return algorithms != null ? Arrays.asList(algorithms) : Collections.emptyList();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}","{
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getAvailableFieldClassificationAlgorithms(receiver);
        final String[] algorithms = receiver.getStringArrayResult();
        return algorithms != null ? Arrays.asList(algorithms) : Collections.emptyList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get available field classification algorithms."");
    }
}",1,"/**
 * Gets the name of all algorithms currently available for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it returns an empty list if the caller currently doesn't have an enabled autofill service
 * for the user.
 */
","/**
 * Gets the name of all algorithms currently available for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it returns an empty list if the caller currently doesn't have an enabled autofill service
 * for the user.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The change is in the exception handling statements: a new exception `SyncResultReceiver.TimeoutException` has been caught and handled by throwing a `RuntimeException`. While the original catch block for `RemoteException` has been modified to throw the exception rather than both rethrowing it and erroneously having a `return null` after a statement that always throws. This constitutes the addition of a new exception handling flow, so the change type is 2.","There is a new potential for the method to throw a `RuntimeException` due to the `TimeoutException`, rather than returning a value, which was not possible in the early version due to the presence of the `@NonNull` annotation which should have prevented returning `null`. This change introduces a new code path where an exception is thrown where it previously wasn't, leading to CI type 2."
644,<android.app.NotificationManager.Policy: String toString()>,29,30,<android.app.NotificationManager.Policy: String toString()>,<android.app.NotificationManager.Policy: String toString()>,0,"{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + "",areChannelsBypassingDnd="" + (((state & STATE_CHANNELS_BYPASSING_DND) != 0) ? ""true"" : ""false"") + ""]"";
}","{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",priorityConvSenders="" + conversationSendersToString(priorityConversationSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + "",areChannelsBypassingDnd="" + (((state & STATE_CHANNELS_BYPASSING_DND) != 0) ? ""true"" : ""false"") + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change consists of an addition of "",priorityConvSenders="" + conversationSendersToString(priorityConversationSenders)"" to the string being returned. This is an additive change that does not alter prior behavior or overall method contract but merely extends it. So, the change type is 4 (Other statement changed).","There is no Compatibility Issue since the change only appends additional string information to the method's return value without altering any previous behavior or return types, so the CI type is 0 (No Compatibility Issue)."
646,"<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>",29,30,"<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>","<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>",0,"{
    final float x = event.getX(pointerIndex);
    final float y = event.getY(pointerIndex);
    if (isOnScrollbarThumb(x, y) || isDraggingScrollBar()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_ARROW);
    }
    // Check what the child under the pointer says about the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            final PointerIcon pointerIcon = dispatchResolvePointerIcon(event, pointerIndex, child);
            if (pointerIcon != null) {
                if (preorderedList != null)
                    preorderedList.clear();
                return pointerIcon;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // implementation.
    return super.onResolvePointerIcon(event, pointerIndex);
}","{
    final float x = event.getX(pointerIndex);
    final float y = event.getY(pointerIndex);
    if (isOnScrollbarThumb(x, y) || isDraggingScrollBar()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_ARROW);
    }
    // Check what the child under the pointer says about the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            View childWithAccessibilityFocus = event.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                // safer given the timeframe.
                if (childWithAccessibilityFocus != null) {
                    if (childWithAccessibilityFocus != child) {
                        continue;
                    }
                    childWithAccessibilityFocus = null;
                    i = childrenCount - 1;
                }
                event.setTargetAccessibilityFocus(false);
                continue;
            }
            final PointerIcon pointerIcon = dispatchResolvePointerIcon(event, pointerIndex, child);
            if (pointerIcon != null) {
                if (preorderedList != null)
                    preorderedList.clear();
                return pointerIcon;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // implementation.
    return super.onResolvePointerIcon(event, pointerIndex);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces new local variable (View childWithAccessibilityFocus), new conditional checks, and resets of local variables within the 'for' loop, so the code change types are 3 for the control statement changes within the loop and 4 for the other statement changes. There is no change in return statements or exception handling.","Because the variables introduced and checks added do not change the method's return values or the exceptions it might throw (since these behavior patterns are preserved across versions), there is No Compatibility Issue. The modifications refine the internal logic for resolving which View should handle the pointer icon but ultimately, the same conditions lead to the same method calls and return statements as before."
647,"<android.speech.tts.TextToSpeech: int speak(CharSequence,int,Bundle,String)>",29,30,"<android.speech.tts.TextToSpeech: int speak(CharSequence,int,Bundle,String)>","<android.speech.tts.TextToSpeech: int speak(CharSequence,int,Bundle,String)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri utteranceUri = mUtterances.get(text);
            if (utteranceUri != null) {
                return service.playAudio(getCallerIdentity(), utteranceUri, queueMode, getParams(params), utteranceId);
            } else {
                return service.speak(getCallerIdentity(), text, queueMode, getParams(params), utteranceId);
            }
        }
    }, ERROR, ""speak"");
}","{
    return runAction((ITextToSpeechService service) -> {
        Uri utteranceUri = mUtterances.get(text);
        if (utteranceUri != null) {
            return service.playAudio(getCallerIdentity(), utteranceUri, queueMode, getParams(params), utteranceId);
        } else {
            return service.speak(getCallerIdentity(), text, queueMode, getParams(params), utteranceId);
        }
    }, ERROR, ""speak"");
}",1,"/**
 * Speaks the text using the specified queuing strategy and speech parameters, the text may
 * be spanned with TtsSpans.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param text The string of text to be spoken. No longer than
 * {@link #getMaxSpeechInputLength()} characters.
 * @param queueMode The queuing strategy to use, {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_VOLUME},
 * {@link Engine#KEY_PARAM_PAN}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param utteranceId An unique identifier for this request.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the speak operation.
 */
","/**
 * Speaks the text using the specified queuing strategy and speech parameters, the text may
 * be spanned with TtsSpans.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param text The string of text to be spoken. No longer than
 * {@link #getMaxSpeechInputLength()} characters.
 * @param queueMode The queuing strategy to use, {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_VOLUME},
 * {@link Engine#KEY_PARAM_PAN}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param utteranceId An unique identifier for this request.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the speak operation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change involves rewriting the anonymous class Action<Integer> as a lambda expression. The behavior and the return type remain unchanged, as they both implement the same interface and the method signature remains the same, so the change type is 4.","There is no Compatibility Issue here since the underlying implementation logic has not changed. Only the syntax has been updated to use a lambda expression, which does not affect the behavior of the method."
648,<android.accounts.AccountManager: Account[] getAccounts()>,29,30,<android.accounts.AccountManager: Account[] getAccounts()>,<android.accounts.AccountManager: Account[] getAccounts()>,0,"{
    try {
        return mService.getAccounts(null, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return getAccountsAsUser(mContext.getUserId());
}",1,"/**
 * Lists all accounts visible to the caller regardless of type. Equivalent to
 * getAccountsByType(null). These accounts may be visible because the user granted access to the
 * account, or the AbstractAcccountAuthenticator managing the account did so or because the
 * client shares a signature with the managing AbstractAccountAuthenticator.
 *
 * <p>
 * It is safe to call this method from the main thread.
 *
 * @return An array of {@link Account}, one for each account. Empty (never null) if no accounts
 * have been added.
 */
","/**
 * Lists all accounts visible to the caller regardless of type. Equivalent to
 * getAccountsByType(null). These accounts may be visible because the user granted access to the
 * account, or the AbstractAcccountAuthenticator managing the account did so or because the
 * client shares a signature with the managing AbstractAccountAuthenticator.
 *
 * <div class=""caution""><p><b>Caution: </b>This method returns personal and sensitive user data.
 * If your app accesses, collects, uses, or shares personal and sensitive data, you must clearly
 * disclose that fact to users. For apps published on Google Play, policies protecting user data
 * require that you do the following:</p>
 * <ul>
 * <li>Disclose to the user how your app accesses, collects, uses, or shares personal and
 * sensitive data. Learn more about
 * <a href=""https://play.google.com/about/privacy-security-deception/user-data/#!#personal-sensitive"">acceptable
 * disclosure and consent</a>.</li>
 * <li>Provide a privacy policy that describes your use of this data on- and off-device.</li>
 * </ul>
 * <p>To learn more, visit the
 * <a href=""https://play.google.com/about/privacy-security-deception/user-data"">Google Play
 * Policy regarding user data</a>.</p></div>
 *
 * <p>
 * It is safe to call this method from the main thread.
 *
 * @return An array of {@link Account}, one for each account. Empty (never null) if no accounts
 * have been added.
 */
",-1,[@NonNull],"[@UserHandleAware, @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed to call a different API method getAccountsAsUser(mContext.getUserId()); however, the functionality is intended to behave the same with just an internal change on how the accounts are fetched (by user ID internally). So the change type is 5.","There seems to be no CI as the method's contract appears to remain the same and it still returns an array of Account objects. The introduction of the @UserHandleAware annotation indicates that multiple user accounts are being considered, but this should not affect the existing behavior when called with the user's own context. Thus, no compatibility issue is detected."
649,"<android.app.Instrumentation: Activity startActivitySync(Intent,Bundle)>",29,30,"<android.app.Instrumentation: Activity startActivitySync(Intent,Bundle)>","<android.app.Instrumentation: Activity startActivitySync(Intent,Bundle)>",0,"{
    validateNotAppThread();
    synchronized (mSync) {
        intent = new Intent(intent);
        ActivityInfo ai = intent.resolveActivityInfo(getTargetContext().getPackageManager(), 0);
        if (ai == null) {
            throw new RuntimeException(""Unable to resolve activity for: "" + intent);
        }
        String myProc = mThread.getProcessName();
        if (!ai.processName.equals(myProc)) {
            // there is a single match that is in our package.
            throw new RuntimeException(""Intent in process "" + myProc + "" resolved to different process "" + ai.processName + "": "" + intent);
        }
        intent.setComponent(new ComponentName(ai.applicationInfo.packageName, ai.name));
        final ActivityWaiter aw = new ActivityWaiter(intent);
        if (mWaitingActivities == null) {
            mWaitingActivities = new ArrayList();
        }
        mWaitingActivities.add(aw);
        getTargetContext().startActivity(intent, options);
        do {
            try {
                mSync.wait();
            } catch (InterruptedException e) {
            }
        } while (mWaitingActivities.contains(aw));
        waitForEnterAnimationComplete(aw.activity);
        return aw.activity;
    }
}","{
    validateNotAppThread();
    final Activity activity;
    synchronized (mSync) {
        intent = new Intent(intent);
        ActivityInfo ai = intent.resolveActivityInfo(getTargetContext().getPackageManager(), 0);
        if (ai == null) {
            throw new RuntimeException(""Unable to resolve activity for: "" + intent);
        }
        String myProc = mThread.getProcessName();
        if (!ai.processName.equals(myProc)) {
            // there is a single match that is in our package.
            throw new RuntimeException(""Intent in process "" + myProc + "" resolved to different process "" + ai.processName + "": "" + intent);
        }
        intent.setComponent(new ComponentName(ai.applicationInfo.packageName, ai.name));
        final ActivityWaiter aw = new ActivityWaiter(intent);
        if (mWaitingActivities == null) {
            mWaitingActivities = new ArrayList();
        }
        mWaitingActivities.add(aw);
        getTargetContext().startActivity(intent, options);
        do {
            try {
                mSync.wait();
            } catch (InterruptedException e) {
            }
        } while (mWaitingActivities.contains(aw));
        activity = aw.activity;
    }
    // Do not call this method within mSync, lest it could block the main thread.
    waitForEnterAnimationComplete(activity);
    // the Activity is ready (b/138263890).
    try (SurfaceControl.Transaction t = new SurfaceControl.Transaction()) {
        t.apply(true);
    }
    return activity;
}",1,"/**
 * Start a new activity and wait for it to begin running before returning.
 * In addition to being synchronous, this method as some semantic
 * differences from the standard {@link Context#startActivity} call: the
 * activity component is resolved before talking with the activity manager
 * (its class name is specified in the Intent that this method ultimately
 * starts), and it does not allow you to start activities that run in a
 * different process.  In addition, if the given Intent resolves to
 * multiple activities, instead of displaying a dialog for the user to
 * select an activity, an exception will be thrown.
 *
 * <p>The function returns as soon as the activity goes idle following the
 * call to its {@link Activity#onCreate}.  Generally this means it has gone
 * through the full initialization including {@link Activity#onResume} and
 * drawn and displayed its initial window.
 *
 * @param intent Description of the activity to start.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.  See {@link android.app.ActivityOptions}
 * for how to build the Bundle supplied here; there are no supported definitions
 * for building it manually.
 *
 * @see Context#startActivity(Intent, Bundle)
 */
","/**
 * Start a new activity and wait for it to begin running before returning.
 * In addition to being synchronous, this method as some semantic
 * differences from the standard {@link Context#startActivity} call: the
 * activity component is resolved before talking with the activity manager
 * (its class name is specified in the Intent that this method ultimately
 * starts), and it does not allow you to start activities that run in a
 * different process.  In addition, if the given Intent resolves to
 * multiple activities, instead of displaying a dialog for the user to
 * select an activity, an exception will be thrown.
 *
 * <p>The function returns as soon as the activity goes idle following the
 * call to its {@link Activity#onCreate}.  Generally this means it has gone
 * through the full initialization including {@link Activity#onResume} and
 * drawn and displayed its initial window.
 *
 * @param intent Description of the activity to start.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.  See {@link android.app.ActivityOptions}
 * for how to build the Bundle supplied here; there are no supported definitions
 * for building it manually.
 *
 * @see Context#startActivity(Intent, Bundle)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"There is no change in the return type or exception handling, but the control dependency within the synchronized block and other statement outside the synchronized block have changed. The method call to `waitForEnterAnimationComplete(activity)` and the try-with-resources block `(SurfaceControl.Transaction t = new SurfaceControl.Transaction())` are moved/added outside the synchronized block, thus the changes are classified as 3 (Control dependency change, since the method no longer is contained within the synchronized block) and 4 (Other statement changed, because of the addition of SurfaceControl.Transaction block).","There is no compatibility issue regarding the method's return type or the exceptions it throws. While the behavior within the synchronized block has changed, this alteration is about when certain method calls are made rather than a change in the data being manipulated or exceptions being thrown. The late version still returns an Activity object and does not introduce any new exceptions nor alter the return path, so the kind of return and the exception throwing behavior remain consistent with the early version. Hence, there's no compatibility issue."
650,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputMinFrameDuration(int,Size)>",29,30,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputMinFrameDuration(int,Size)>","<android.hardware.camera2.params.StreamConfigurationMap: long getOutputMinFrameDuration(int,Size)>",0,"{
    checkNotNull(size, ""size must not be null"");
    checkArgumentFormatSupported(format, /*output*/
    true);
    return getInternalFormatDuration(imageFormatToInternal(format), imageFormatToDataspace(format), size, DURATION_MIN_FRAME);
}","{
    Objects.requireNonNull(size, ""size must not be null"");
    checkArgumentFormatSupported(format, /*output*/
    true);
    return getInternalFormatDuration(imageFormatToInternal(format), imageFormatToDataspace(format), size, DURATION_MIN_FRAME);
}",1,"/**
 * Get the minimum {@link CaptureRequest#SENSOR_FRAME_DURATION frame duration}
 * for the format/size combination (in nanoseconds).
 *
 * <p>{@code format} should be one of the ones returned by {@link #getOutputFormats()}.</p>
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(int)}.</p>
 *
 * <p>This should correspond to the frame duration when only that stream is active, with all
 * processing (typically in {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.
 * </p>
 *
 * <p>When multiple streams are used in a request, the minimum frame duration will be
 * {@code max(individual stream min durations)}.</p>
 *
 * <p>For devices that do not support manual sensor control
 * ({@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR}),
 * this function may return 0.</p>
 *
 * <!--
 * TODO: uncomment after adding input stream support
 * <p>The minimum frame duration of a stream (of a particular format, size) is the same
 * regardless of whether the stream is input or output.</p>
 * -->
 *
 * @param format an image format from {@link ImageFormat} or {@link PixelFormat}
 * @param size an output-compatible size
 * @return a minimum frame duration {@code >} 0 in nanoseconds, or
 * 0 if the minimum frame duration is not available.
 *
 * @throws IllegalArgumentException if {@code format} or {@code size} was not supported
 * @throws NullPointerException if {@code size} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see #getOutputStallDuration(int, Size)
 * @see ImageFormat
 * @see PixelFormat
 */
","/**
 * Get the minimum {@link CaptureRequest#SENSOR_FRAME_DURATION frame duration}
 * for the format/size combination (in nanoseconds).
 *
 * <p>{@code format} should be one of the ones returned by {@link #getOutputFormats()}.</p>
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(int)}.</p>
 *
 * <p>This corresponds to the minimum frame duration (maximum frame rate) possible when only
 * that stream is configured in a session, with all processing (typically in
 * {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.  </p>
 *
 * <p>When multiple streams are used in a session, the minimum frame duration will be
 * {@code max(individual stream min durations)}.  See {@link #getOutputStallDuration} for
 * details of timing for formats that may cause frame rate slowdown when they are targeted by a
 * capture request.</p>
 *
 * <p>For devices that do not support manual sensor control
 * ({@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR}),
 * this function may return 0.</p>
 *
 * <p>The minimum frame duration of a stream (of a particular format, size) is the same
 * regardless of whether the stream is input or output.</p>
 *
 * @param format an image format from {@link ImageFormat} or {@link PixelFormat}
 * @param size an output-compatible size
 * @return a minimum frame duration {@code >} 0 in nanoseconds, or
 * 0 if the minimum frame duration is not available.
 *
 * @throws IllegalArgumentException if {@code format} or {@code size} was not supported
 * @throws NullPointerException if {@code size} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see #getOutputStallDuration(int, Size)
 * @see ImageFormat
 * @see PixelFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method used for null checking of 'size' has changed from checkNotNull(size, ""size must not be null"") to Objects.requireNonNull(size, ""size must not be null""), which is considered Other statement changed (4).","The refactoring from checkNotNull to Objects.requireNonNull does not result in any different outcomes as long as the size parameter is not null. Both methods will throw a NullPointerException if 'size' is null with the given message. There is no change in exception handling or return values for non-null cases, so no Compatibility Issue is present."
651,"<android.content.ContentProviderOperation: void writeToParcel(Parcel,int)>",29,30,"<android.content.ContentProviderOperation: void writeToParcel(Parcel,int)>","<android.content.ContentProviderOperation: void writeToParcel(Parcel,int)>",0,"{
    dest.writeInt(mType);
    Uri.writeToParcel(dest, mUri);
    if (mValues != null) {
        dest.writeInt(1);
        mValues.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mSelection != null) {
        dest.writeInt(1);
        dest.writeString(mSelection);
    } else {
        dest.writeInt(0);
    }
    if (mSelectionArgs != null) {
        dest.writeInt(1);
        dest.writeStringArray(mSelectionArgs);
    } else {
        dest.writeInt(0);
    }
    if (mExpectedCount != null) {
        dest.writeInt(1);
        dest.writeInt(mExpectedCount);
    } else {
        dest.writeInt(0);
    }
    if (mValuesBackReferences != null) {
        dest.writeInt(1);
        mValuesBackReferences.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mSelectionArgsBackReferences != null) {
        dest.writeInt(1);
        dest.writeInt(mSelectionArgsBackReferences.size());
        for (Map.Entry<Integer, Integer> entry : mSelectionArgsBackReferences.entrySet()) {
            dest.writeInt(entry.getKey());
            dest.writeInt(entry.getValue());
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(mYieldAllowed ? 1 : 0);
    dest.writeInt(mFailureAllowed ? 1 : 0);
}","{
    dest.writeInt(mType);
    Uri.writeToParcel(dest, mUri);
    if (mMethod != null) {
        dest.writeInt(1);
        dest.writeString8(mMethod);
    } else {
        dest.writeInt(0);
    }
    if (mArg != null) {
        dest.writeInt(1);
        dest.writeString8(mArg);
    } else {
        dest.writeInt(0);
    }
    if (mValues != null) {
        dest.writeInt(mValues.size());
        dest.writeArrayMap(mValues);
    } else {
        dest.writeInt(-1);
    }
    if (mExtras != null) {
        dest.writeInt(mExtras.size());
        dest.writeArrayMap(mExtras);
    } else {
        dest.writeInt(-1);
    }
    if (mSelection != null) {
        dest.writeInt(1);
        dest.writeString8(mSelection);
    } else {
        dest.writeInt(0);
    }
    dest.writeSparseArray(mSelectionArgs);
    if (mExpectedCount != null) {
        dest.writeInt(1);
        dest.writeInt(mExpectedCount);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(mYieldAllowed ? 1 : 0);
    dest.writeInt(mExceptionAllowed ? 1 : 0);
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The implementation has multiple changes: new fields (`mMethod`, `mArg`, `mExtras`) are written to the `Parcel`, the way `mValues` and `mSelectionArgs` are written has changed, and a boolean field name changed from `mFailureAllowed` to `mExceptionAllowed`. The `writeToParcel` usage changed to `writeString8`, `writeArrayMap`, and `writeSparseArray` methods. These changes are of types 1, 3, 4, and 5.","The modifications of how data is stored in the `Parcel`, including the introduction of new fields, changing how existing fields are written, and renaming a field, can potentially cause the API to return a different result when reading the `Parcel` data. Thus, the CI type is 1."
652,"<android.app.slice.SliceProvider: Bundle call(String,String,Bundle)>",29,30,"<android.app.slice.SliceProvider: Bundle call(String,String,Bundle)>","<android.app.slice.SliceProvider: Bundle call(String,String,Bundle)>",0,"{
    if (method.equals(METHOD_SLICE)) {
        Uri uri = getUriWithoutUserId(extras.getParcelable(EXTRA_BIND_URI));
        List<SliceSpec> supportedSpecs = extras.getParcelableArrayList(EXTRA_SUPPORTED_SPECS);
        String callingPackage = getCallingPackage();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        Slice s = handleBindSlice(uri, supportedSpecs, callingPackage, callingUid, callingPid);
        Bundle b = new Bundle();
        b.putParcelable(EXTRA_SLICE, s);
        return b;
    } else if (method.equals(METHOD_MAP_INTENT)) {
        Intent intent = extras.getParcelable(EXTRA_INTENT);
        if (intent == null)
            return null;
        Uri uri = onMapIntentToUri(intent);
        List<SliceSpec> supportedSpecs = extras.getParcelableArrayList(EXTRA_SUPPORTED_SPECS);
        Bundle b = new Bundle();
        if (uri != null) {
            Slice s = handleBindSlice(uri, supportedSpecs, getCallingPackage(), Binder.getCallingUid(), Binder.getCallingPid());
            b.putParcelable(EXTRA_SLICE, s);
        } else {
            b.putParcelable(EXTRA_SLICE, null);
        }
        return b;
    } else if (method.equals(METHOD_MAP_ONLY_INTENT)) {
        Intent intent = extras.getParcelable(EXTRA_INTENT);
        if (intent == null)
            return null;
        Uri uri = onMapIntentToUri(intent);
        Bundle b = new Bundle();
        b.putParcelable(EXTRA_SLICE, uri);
        return b;
    } else if (method.equals(METHOD_PIN)) {
        Uri uri = getUriWithoutUserId(extras.getParcelable(EXTRA_BIND_URI));
        if (Binder.getCallingUid() != Process.SYSTEM_UID) {
            throw new SecurityException(""Only the system can pin/unpin slices"");
        }
        handlePinSlice(uri);
    } else if (method.equals(METHOD_UNPIN)) {
        Uri uri = getUriWithoutUserId(extras.getParcelable(EXTRA_BIND_URI));
        if (Binder.getCallingUid() != Process.SYSTEM_UID) {
            throw new SecurityException(""Only the system can pin/unpin slices"");
        }
        handleUnpinSlice(uri);
    } else if (method.equals(METHOD_GET_DESCENDANTS)) {
        Uri uri = getUriWithoutUserId(extras.getParcelable(EXTRA_BIND_URI));
        Bundle b = new Bundle();
        b.putParcelableArrayList(EXTRA_SLICE_DESCENDANTS, new ArrayList<>(handleGetDescendants(uri)));
        return b;
    } else if (method.equals(METHOD_GET_PERMISSIONS)) {
        if (Binder.getCallingUid() != Process.SYSTEM_UID) {
            throw new SecurityException(""Only the system can get permissions"");
        }
        Bundle b = new Bundle();
        b.putStringArray(EXTRA_RESULT, mAutoGrantPermissions);
        return b;
    }
    return super.call(method, arg, extras);
}","{
    if (method.equals(METHOD_SLICE)) {
        Uri uri = getUriWithoutUserId(validateIncomingUriOrNull(extras.getParcelable(EXTRA_BIND_URI)));
        List<SliceSpec> supportedSpecs = extras.getParcelableArrayList(EXTRA_SUPPORTED_SPECS);
        String callingPackage = getCallingPackage();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        Slice s = handleBindSlice(uri, supportedSpecs, callingPackage, callingUid, callingPid);
        Bundle b = new Bundle();
        b.putParcelable(EXTRA_SLICE, s);
        return b;
    } else if (method.equals(METHOD_MAP_INTENT)) {
        Intent intent = extras.getParcelable(EXTRA_INTENT);
        if (intent == null)
            return null;
        Uri uri = validateIncomingUriOrNull(onMapIntentToUri(intent));
        List<SliceSpec> supportedSpecs = extras.getParcelableArrayList(EXTRA_SUPPORTED_SPECS);
        Bundle b = new Bundle();
        if (uri != null) {
            Slice s = handleBindSlice(uri, supportedSpecs, getCallingPackage(), Binder.getCallingUid(), Binder.getCallingPid());
            b.putParcelable(EXTRA_SLICE, s);
        } else {
            b.putParcelable(EXTRA_SLICE, null);
        }
        return b;
    } else if (method.equals(METHOD_MAP_ONLY_INTENT)) {
        Intent intent = extras.getParcelable(EXTRA_INTENT);
        if (intent == null)
            return null;
        Uri uri = validateIncomingUriOrNull(onMapIntentToUri(intent));
        Bundle b = new Bundle();
        b.putParcelable(EXTRA_SLICE, uri);
        return b;
    } else if (method.equals(METHOD_PIN)) {
        Uri uri = getUriWithoutUserId(validateIncomingUriOrNull(extras.getParcelable(EXTRA_BIND_URI)));
        if (Binder.getCallingUid() != Process.SYSTEM_UID) {
            throw new SecurityException(""Only the system can pin/unpin slices"");
        }
        handlePinSlice(uri);
    } else if (method.equals(METHOD_UNPIN)) {
        Uri uri = getUriWithoutUserId(validateIncomingUriOrNull(extras.getParcelable(EXTRA_BIND_URI)));
        if (Binder.getCallingUid() != Process.SYSTEM_UID) {
            throw new SecurityException(""Only the system can pin/unpin slices"");
        }
        handleUnpinSlice(uri);
    } else if (method.equals(METHOD_GET_DESCENDANTS)) {
        Uri uri = getUriWithoutUserId(validateIncomingUriOrNull(extras.getParcelable(EXTRA_BIND_URI)));
        Bundle b = new Bundle();
        b.putParcelableArrayList(EXTRA_SLICE_DESCENDANTS, new ArrayList<>(handleGetDescendants(uri)));
        return b;
    } else if (method.equals(METHOD_GET_PERMISSIONS)) {
        if (Binder.getCallingUid() != Process.SYSTEM_UID) {
            throw new SecurityException(""Only the system can get permissions"");
        }
        Bundle b = new Bundle();
        b.putStringArray(EXTRA_RESULT, mAutoGrantPermissions);
        return b;
    }
    return super.call(method, arg, extras);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
653,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,29,30,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (layoutInDisplayCutoutMode != o.layoutInDisplayCutoutMode) {
        layoutInDisplayCutoutMode = o.layoutInDisplayCutoutMode;
        changes |= LAYOUT_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (layoutInDisplayCutoutMode != o.layoutInDisplayCutoutMode) {
        layoutInDisplayCutoutMode = o.layoutInDisplayCutoutMode;
        changes |= LAYOUT_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    if (preferMinimalPostProcessing != o.preferMinimalPostProcessing) {
        preferMinimalPostProcessing = o.preferMinimalPostProcessing;
        changes |= MINIMAL_POST_PROCESSING_PREFERENCE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    if (insetsFlags.appearance != o.insetsFlags.appearance) {
        insetsFlags.appearance = o.insetsFlags.appearance;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (insetsFlags.behavior != o.insetsFlags.behavior) {
        insetsFlags.behavior = o.insetsFlags.behavior;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (mFitInsetsTypes != o.mFitInsetsTypes) {
        mFitInsetsTypes = o.mFitInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsSides != o.mFitInsetsSides) {
        mFitInsetsSides = o.mFitInsetsSides;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsIgnoringVisibility != o.mFitInsetsIgnoringVisibility) {
        mFitInsetsIgnoringVisibility = o.mFitInsetsIgnoringVisibility;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(providesInsetsTypes, o.providesInsetsTypes)) {
        providesInsetsTypes = o.providesInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
654,<android.content.Intent: boolean filterEquals(Intent)>,29,30,<android.content.Intent: boolean filterEquals(Intent)>,<android.content.Intent: boolean filterEquals(Intent)>,0,"{
    if (other == null) {
        return false;
    }
    if (!Objects.equals(this.mAction, other.mAction))
        return false;
    if (!Objects.equals(this.mData, other.mData))
        return false;
    if (!Objects.equals(this.mType, other.mType))
        return false;
    if (!Objects.equals(this.mIdentifier, other.mIdentifier))
        return false;
    if (!Objects.equals(this.mPackage, other.mPackage))
        return false;
    if (!Objects.equals(this.mComponent, other.mComponent))
        return false;
    if (!Objects.equals(this.mCategories, other.mCategories))
        return false;
    return true;
}","{
    if (other == null) {
        return false;
    }
    if (!Objects.equals(this.mAction, other.mAction))
        return false;
    if (!Objects.equals(this.mData, other.mData))
        return false;
    if (!Objects.equals(this.mType, other.mType))
        return false;
    if (!Objects.equals(this.mIdentifier, other.mIdentifier))
        return false;
    if (!(this.hasPackageEquivalentComponent() && other.hasPackageEquivalentComponent()) && !Objects.equals(this.mPackage, other.mPackage)) {
        return false;
    }
    if (!Objects.equals(this.mComponent, other.mComponent))
        return false;
    if (!Objects.equals(this.mCategories, other.mCategories))
        return false;
    return true;
}",1,"/**
 * Determine if two intents are the same for the purposes of intent
 * resolution (filtering). That is, if their action, data, type, identity,
 * class, and categories are the same.  This does <em>not</em> compare
 * any extra data included in the intents.  Note that technically when actually
 * matching against an {@link IntentFilter} the identifier is ignored, while here
 * it is directly compared for equality like the other fields.
 *
 * @param other The other Intent to compare against.
 *
 * @return Returns true if action, data, type, class, and categories
 * are the same.
 */
","/**
 * Determine if two intents are the same for the purposes of intent
 * resolution (filtering). That is, if their action, data, type, identity,
 * class, and categories are the same.  This does <em>not</em> compare
 * any extra data included in the intents.  Note that technically when actually
 * matching against an {@link IntentFilter} the identifier is ignored, while here
 * it is directly compared for equality like the other fields.
 *
 * @param other The other Intent to compare against.
 *
 * @return Returns true if action, data, type, class, and categories
 * are the same.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change is in the condition where mPackage is compared using Objects.equals. A new condition is introduced to check if both `this` and `other` have package equivalent components (this.hasPackageEquivalentComponent() && other.hasPackageEquivalentComponent()). This falls under a control dependency change because it alters the flow of execution (type 3) and also changes an 'if' statement condition outside of 'return', 'throw', and dependent API, which is ""Other statement changed"" (type 4).","Even though the implementation has changed, the change should not introduce any compatibility issues because it adds an additional check before comparing `mPackage`. The method still returns a boolean indicating whether the two Intent objects are equal with regard to their action, data, type, identifier, package, component, and categories. This additional check does not lead to a different value or type being returned in scenarios where the result would have been the same without this new condition; it only refines the condition under which the mPackage is compared. Therefore, there is no Compatibility Issue (CI type 0)."
657,"<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo[])>",29,30,"<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo[])>","<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo[])>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.displayCompletions(view, completions);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mCompletions = completions;
        if (mCurMethod != null) {
            try {
                mCurMethod.displayCompletions(mCompletions);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.displayCompletions(view, completions);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return;
        }
        mCompletions = completions;
        if (mCurMethod != null) {
            try {
                mCurMethod.displayCompletions(mCompletions);
            } catch (RemoteException e) {
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change is in the if condition inside the synchronized block, where the method call has been changed from an inline check to a method call `hasServedByInputMethodLocked(view)`. This is control dependency change as the control statement's condition has changed (type 3). Additionally, since an existing method call is replaced with a new method call within the control statement, this can also be considered as another statement change (type 4).","There is no Compatibility Issue because the change in the control statement's condition is an internal implementation detail. It is a refactoring that doesn't affect the method's external behavior, assuming that `hasServedByInputMethodLocked(view)` is functionally equivalent to the previous inline check. Therefore, the API should not behave differently for clients using this method, as it still performs the same functionality."
658,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",29,30,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>","<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",0,"{
    if (msg.target == null) {
        throw new IllegalArgumentException(""Message must have a target."");
    }
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + "" This message is already in use."");
    }
    synchronized (this) {
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (; ; ) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        }
        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}","{
    if (msg.target == null) {
        throw new IllegalArgumentException(""Message must have a target."");
    }
    synchronized (this) {
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + "" This message is already in use."");
        }
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (; ; ) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        }
        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change occurs in the 'synchronized' block. The 'if (msg.isInUse())' check has been moved inside the 'synchronized' block. There are no other changes to the flow or logic of the method itself. The only change is with regards to when the check for 'msg.isInUse()' is performed - earlier, it was done before entering the synchronized block, and later, after entering the synchronized block.","Although there's a change in the control flow of the checks (control dependency change), this modification does not affect the overt behavior of the method exposed to the caller. The conditions under which exceptions are thrown or the value being returned remains consistent across both versions. Therefore, no Compatibility Issue arises from this change."
659,<android.net.LinkAddress: int hashCode()>,29,30,<android.net.LinkAddress: int hashCode()>,<android.net.LinkAddress: int hashCode()>,0,"{
    return address.hashCode() + 11 * prefixLength + 19 * flags + 43 * scope;
}","{
    return Objects.hash(address, prefixLength, flags, scope, deprecationTime, expirationTime);
}",1,"/**
 * Returns a hashcode for this address.
 */
","/**
 * Returns a hashcode for this address.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the `hashCode` method has changed completely from a manual computation of the hash code to using `Objects.hash` with additional fields (`deprecationTime`, `expirationTime`). The inclusion of new fields in the hash code calculation is another statement change, so the code change type is 1,4.","The change in the algorithm for computing the hash code will result in a different return value for the `hashCode` method, so the CI type is 1. This change directly affects how objects of the class would behave in collections such as `HashSet` or as keys in `HashMap`, potentially leading to different application behavior."
660,<android.app.Activity: void performPause()>,29,30,<android.app.Activity: void performPause()>,<android.app.Activity: void performPause()>,0,"{
    dispatchActivityPrePaused();
    mDoReportFullyDrawn = false;
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    writeEventLog(LOG_AM_ON_PAUSE_CALLED, ""performPause"");
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
    dispatchActivityPostPaused();
}","{
    dispatchActivityPrePaused();
    mDoReportFullyDrawn = false;
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    EventLogTags.writeWmOnPausedCalled(mIdent, getComponentName().getClassName(), ""performPause"");
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
    dispatchActivityPostPaused();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the logging mechanism; the 'writeEventLog' method is replaced with 'EventLogTags.writeWmOnPausedCalled' method, which falls under the category of Other statement changed.","Since the change only pertains to a logging statement and does not affect the return value nor the exceptions thrown by the method, it does not constitute a Compatibility Issue."
661,<android.view.textclassifier.TextLinks.Request: String getCallingPackageName()>,29,30,<android.view.textclassifier.TextLinks.Request: String getCallingPackageName()>,<android.view.textclassifier.TextLinks.Request: String getCallingPackageName()>,0,"{
    return mCallingPackageName;
}","{
    return mSystemTcMetadata != null ? mSystemTcMetadata.getCallingPackageName() : null;
}",1,"/**
 * Returns the name of the package that sent this request.
 * This returns {@code null} if no calling package name is set.
 */
","/**
 * Returns the name of the package that sent this request.
 * This returns {@code null} if no calling package name is set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed with the addition of a ternary conditional, checking if mSystemTcMetadata is not null to call a method on it, otherwise returning null. This implies a significant change in the control flow and how the result is obtained. The code change type is 1,3.","Due to the change, the method potentially returns a different value (either the result from `mSystemTcMetadata.getCallingPackageName()` or null) compared to the early version, where it always returned `mCallingPackageName`. Hence the CI type is 1."
663,<android.view.textclassifier.TextClassifier: TextClassification classifyText(Request)>,29,30,<android.view.textclassifier.TextClassifier: TextClassification classifyText(Request)>,<android.view.textclassifier.TextClassifier: TextClassification classifyText(Request)>,0,"{
    Preconditions.checkNotNull(request);
    Utils.checkMainThread();
    return TextClassification.EMPTY;
}","{
    Objects.requireNonNull(request);
    Utils.checkMainThread();
    return TextClassification.EMPTY;
}",1,"/**
 * Classifies the specified text and returns a {@link TextClassification} object that can be
 * used to generate a widget for handling the classified text.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * @param request the text classification request
 */
","/**
 * Classifies the specified text and returns a {@link TextClassification} object that can be
 * used to generate a widget for handling the classified text.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * <p><strong>NOTE: </strong>If a TextClassifier has been destroyed, calls to this method should
 * throw an {@link IllegalStateException}. See {@link #isDestroyed()}.
 *
 * @param request the text classification request
 */
",-1,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,0,0,"There is no functional change in the implementation; `Preconditions.checkNotNull(request)` and `Objects.requireNonNull(request)` are equivalent, they both throw NullPointerException if the passed argument is null. The rest of the implementation and annotations are unchanged.","There are no changes in the functionality or the output of the method between the two versions; thus, no Compatibility Issue arises."
664,<android.speech.tts.TextToSpeechService: IBinder onBind(Intent)>,29,30,<android.speech.tts.TextToSpeechService: IBinder onBind(Intent)>,<android.speech.tts.TextToSpeechService: IBinder onBind(Intent)>,0,"{
    if (TextToSpeech.Engine.INTENT_ACTION_TTS_SERVICE.equals(intent.getAction())) {
        return mBinder;
    }
    return null;
}","{
    if (TextToSpeech.Engine.INTENT_ACTION_TTS_SERVICE.equals(intent.getAction())) {
        Binder.allowBlocking(mBinder.asBinder());
        return mBinder;
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change involves adding a new method call (Binder.allowBlocking(mBinder.asBinder());) before returning mBinder. Therefore, the code change type is 4.","Since the added method call (Binder.allowBlocking) does not alter the return value and does not introduce any new control paths that could lead to a different behavior observable by the API consumers, there is no Compatibility Issue. The return value is still mBinder (or null if the condition is not met), and no new exceptions are thrown by the change. Thus, the CI type is 0."
665,<android.bluetooth.BluetoothAdapter: int getState()>,29,30,<android.bluetooth.BluetoothAdapter: int getState()>,<android.bluetooth.BluetoothAdapter: int getState()>,0,"{
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    // Consider all internal states as OFF
    if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        if (VDBG) {
            Log.d(TAG, ""Consider "" + BluetoothAdapter.nameForState(state) + "" state as OFF"");
        }
        state = BluetoothAdapter.STATE_OFF;
    }
    if (VDBG) {
        Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + BluetoothAdapter.nameForState(state));
    }
    return state;
}","{
    int state = getStateInternal();
    // Consider all internal states as OFF
    if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        if (VDBG) {
            Log.d(TAG, ""Consider "" + BluetoothAdapter.nameForState(state) + "" state as OFF"");
        }
        state = BluetoothAdapter.STATE_OFF;
    }
    if (VDBG) {
        Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + BluetoothAdapter.nameForState(state));
    }
    return state;
}",1,"/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 *
 * @return current state of Bluetooth adapter
 */
","/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 *
 * @return current state of Bluetooth adapter
 */
",-1,"[@RequiresPermission(Manifest.permission.BLUETOOTH), @AdapterState]","[@RequiresPermission(Manifest.permission.BLUETOOTH), @AdapterState]",-1,-1,-1,-1,-1,-1,"4,5",0,"The early version directly accesses services and uses a lock mechanism, but the late version uses a new method, getStateInternal(), to obtain the state. These changes signify that dependent API implementation has been modified with the introduction of getStateInternal(), and other statements are adjusted accordingly. Therefore, the code change type is 4,5.","The behavior of the method should remain the same externally, considering getStateInternal() is designed to abstract the details on how the state is retrieved. This abstraction should not alter the return value provided that getStateInternal() is correctly implemented. There is no introduction of new return types or exceptions here. Consequently, there's no compatibility issue detected, and the CI type is 0."
667,<android.net.LinkProperties: String toString()>,29,30,<android.net.LinkProperties: String toString()>,<android.net.LinkProperties: String toString()>,0,"{
    // Space as a separator, so no need for spaces at start/end of the individual fragments.
    final StringJoiner resultJoiner = new StringJoiner("" "", ""{"", ""}"");
    if (mIfaceName != null) {
        resultJoiner.add(""InterfaceName:"");
        resultJoiner.add(mIfaceName);
    }
    resultJoiner.add(""LinkAddresses: ["");
    if (!mLinkAddresses.isEmpty()) {
        resultJoiner.add(TextUtils.join("","", mLinkAddresses));
    }
    resultJoiner.add(""]"");
    resultJoiner.add(""DnsAddresses: ["");
    if (!mDnses.isEmpty()) {
        resultJoiner.add(TextUtils.join("","", mDnses));
    }
    resultJoiner.add(""]"");
    if (mUsePrivateDns) {
        resultJoiner.add(""UsePrivateDns: true"");
    }
    if (mPrivateDnsServerName != null) {
        resultJoiner.add(""PrivateDnsServerName:"");
        resultJoiner.add(mPrivateDnsServerName);
    }
    if (!mPcscfs.isEmpty()) {
        resultJoiner.add(""PcscfAddresses: ["");
        resultJoiner.add(TextUtils.join("","", mPcscfs));
        resultJoiner.add(""]"");
    }
    if (!mValidatedPrivateDnses.isEmpty()) {
        final StringJoiner validatedPrivateDnsesJoiner = new StringJoiner("","", ""ValidatedPrivateDnsAddresses: ["", ""]"");
        for (final InetAddress addr : mValidatedPrivateDnses) {
            validatedPrivateDnsesJoiner.add(addr.getHostAddress());
        }
        resultJoiner.add(validatedPrivateDnsesJoiner.toString());
    }
    resultJoiner.add(""Domains:"");
    resultJoiner.add(mDomains);
    resultJoiner.add(""MTU:"");
    resultJoiner.add(Integer.toString(mMtu));
    if (mTcpBufferSizes != null) {
        resultJoiner.add(""TcpBufferSizes:"");
        resultJoiner.add(mTcpBufferSizes);
    }
    resultJoiner.add(""Routes: ["");
    if (!mRoutes.isEmpty()) {
        resultJoiner.add(TextUtils.join("","", mRoutes));
    }
    resultJoiner.add(""]"");
    if (mHttpProxy != null) {
        resultJoiner.add(""HttpProxy:"");
        resultJoiner.add(mHttpProxy.toString());
    }
    if (mNat64Prefix != null) {
        resultJoiner.add(""Nat64Prefix:"");
        resultJoiner.add(mNat64Prefix.toString());
    }
    final Collection<LinkProperties> stackedLinksValues = mStackedLinks.values();
    if (!stackedLinksValues.isEmpty()) {
        final StringJoiner stackedLinksJoiner = new StringJoiner("","", ""Stacked: ["", ""]"");
        for (final LinkProperties lp : stackedLinksValues) {
            stackedLinksJoiner.add(""[ "" + lp + "" ]"");
        }
        resultJoiner.add(stackedLinksJoiner.toString());
    }
    return resultJoiner.toString();
}","{
    // Space as a separator, so no need for spaces at start/end of the individual fragments.
    final StringJoiner resultJoiner = new StringJoiner("" "", ""{"", ""}"");
    if (mIfaceName != null) {
        resultJoiner.add(""InterfaceName:"");
        resultJoiner.add(mIfaceName);
    }
    resultJoiner.add(""LinkAddresses: ["");
    if (!mLinkAddresses.isEmpty()) {
        resultJoiner.add(TextUtils.join("","", mLinkAddresses));
    }
    resultJoiner.add(""]"");
    resultJoiner.add(""DnsAddresses: ["");
    if (!mDnses.isEmpty()) {
        resultJoiner.add(TextUtils.join("","", mDnses));
    }
    resultJoiner.add(""]"");
    if (mUsePrivateDns) {
        resultJoiner.add(""UsePrivateDns: true"");
    }
    if (mPrivateDnsServerName != null) {
        resultJoiner.add(""PrivateDnsServerName:"");
        resultJoiner.add(mPrivateDnsServerName);
    }
    if (!mPcscfs.isEmpty()) {
        resultJoiner.add(""PcscfAddresses: ["");
        resultJoiner.add(TextUtils.join("","", mPcscfs));
        resultJoiner.add(""]"");
    }
    if (!mValidatedPrivateDnses.isEmpty()) {
        final StringJoiner validatedPrivateDnsesJoiner = new StringJoiner("","", ""ValidatedPrivateDnsAddresses: ["", ""]"");
        for (final InetAddress addr : mValidatedPrivateDnses) {
            validatedPrivateDnsesJoiner.add(addr.getHostAddress());
        }
        resultJoiner.add(validatedPrivateDnsesJoiner.toString());
    }
    resultJoiner.add(""Domains:"");
    resultJoiner.add(mDomains);
    resultJoiner.add(""MTU:"");
    resultJoiner.add(Integer.toString(mMtu));
    if (mWakeOnLanSupported) {
        resultJoiner.add(""WakeOnLanSupported: true"");
    }
    if (mDhcpServerAddress != null) {
        resultJoiner.add(""ServerAddress:"");
        resultJoiner.add(mDhcpServerAddress.toString());
    }
    if (mCaptivePortalApiUrl != null) {
        resultJoiner.add(""CaptivePortalApiUrl: "" + mCaptivePortalApiUrl);
    }
    if (mCaptivePortalData != null) {
        resultJoiner.add(""CaptivePortalData: "" + mCaptivePortalData);
    }
    if (mTcpBufferSizes != null) {
        resultJoiner.add(""TcpBufferSizes:"");
        resultJoiner.add(mTcpBufferSizes);
    }
    resultJoiner.add(""Routes: ["");
    if (!mRoutes.isEmpty()) {
        resultJoiner.add(TextUtils.join("","", mRoutes));
    }
    resultJoiner.add(""]"");
    if (mHttpProxy != null) {
        resultJoiner.add(""HttpProxy:"");
        resultJoiner.add(mHttpProxy.toString());
    }
    if (mNat64Prefix != null) {
        resultJoiner.add(""Nat64Prefix:"");
        resultJoiner.add(mNat64Prefix.toString());
    }
    final Collection<LinkProperties> stackedLinksValues = mStackedLinks.values();
    if (!stackedLinksValues.isEmpty()) {
        final StringJoiner stackedLinksJoiner = new StringJoiner("","", ""Stacked: ["", ""]"");
        for (final LinkProperties lp : stackedLinksValues) {
            stackedLinksJoiner.add(""[ "" + lp + "" ]"");
        }
        resultJoiner.add(stackedLinksJoiner.toString());
    }
    return resultJoiner.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
668,"<android.app.Notification: void writeToParcel(Parcel,int)>",29,30,"<android.app.Notification: void writeToParcel(Parcel,int)>","<android.app.Notification: void writeToParcel(Parcel,int)>",0,"{
    // We need to mark all pending intents getting into the notification
    // system as being put there to later allow the notification ranker
    // to launch them and by doing so add the app to the battery saver white
    // list for a short period of time. The problem is that the system
    // cannot look into the extras as there may be parcelables there that
    // the platform does not know how to handle. To go around that we have
    // an explicit list of the pending intents in the extras bundle.
    final boolean collectPendingIntents = (allPendingIntents == null);
    if (collectPendingIntents) {
        PendingIntent.setOnMarshaledListener((PendingIntent intent, Parcel out, int outFlags) -> {
            if (parcel == out) {
                if (allPendingIntents == null) {
                    allPendingIntents = new ArraySet<>();
                }
                allPendingIntents.add(intent);
            }
        });
    }
    try {
        // IMPORTANT: Add marshaling code in writeToParcelImpl as we
        // want to intercept all pending events written to the parcel.
        writeToParcelImpl(parcel, flags);
        // Must be written last!
        parcel.writeArraySet(allPendingIntents);
    } finally {
        if (collectPendingIntents) {
            PendingIntent.setOnMarshaledListener(null);
        }
    }
}","{
    // We need to mark all pending intents getting into the notification
    // system as being put there to later allow the notification ranker
    // to launch them and by doing so add the app to the battery saver white
    // list for a short period of time. The problem is that the system
    // cannot look into the extras as there may be parcelables there that
    // the platform does not know how to handle. To go around that we have
    // an explicit list of the pending intents in the extras bundle.
    final boolean collectPendingIntents = (allPendingIntents == null);
    if (collectPendingIntents) {
        PendingIntent.setOnMarshaledListener((PendingIntent intent, Parcel out, int outFlags) -> {
            if (parcel == out) {
                synchronized (this) {
                    if (allPendingIntents == null) {
                        allPendingIntents = new ArraySet<>();
                    }
                    allPendingIntents.add(intent);
                }
            }
        });
    }
    try {
        // IMPORTANT: Add marshaling code in writeToParcelImpl as we
        // want to intercept all pending events written to the parcel.
        writeToParcelImpl(parcel, flags);
        synchronized (this) {
            // Must be written last!
            parcel.writeArraySet(allPendingIntents);
        }
    } finally {
        if (collectPendingIntents) {
            PendingIntent.setOnMarshaledListener(null);
        }
    }
}",1,"/**
 * Flatten this notification into a parcel.
 */
","/**
 * Flatten this notification into a parcel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version adds synchronized blocks around pieces of code that manipulate `allPendingIntents`, which is a change that does not influence the control flow regarding return statements or exception handling, but affects the thread-safety of the operations. Hence, the code change type is both 3, due to the introduced synchronized blocks representing a change in a control statement that affects how the subsequent code is executed, and 4, because it introduces a new kind of statement (synchronization).","These added synchronized blocks do not change the behavior of the method in terms of the output or exceptions thrown that are visible to the caller of the method. Therefore, they do not introduce a Compatibility Issue, thus the CI type is 0."
670,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",29,30,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>","<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",0,"{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    int currentGeneration = -1;
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
                if (mGenerationTracker != null) {
                    currentGeneration = mGenerationTracker.getCurrentGeneration();
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b;
            // clearCallingIdentity or use a ContentResolver from the caller as needed.
            if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
                final long token = Binder.clearCallingIdentity();
                try {
                    b = cp.call(cr.getPackageName(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            } else {
                b = cp.call(cr.getPackageName(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
            }
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                if (mGenerationTracker != null) {
                                    mGenerationTracker.destroy();
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                            }
                        }
                        if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                            mValues.put(name, value);
                        }
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        Bundle queryArgs = ContentResolver.createSqlQueryBundle(NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        // Same workaround as above.
        if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
            final long token = Binder.clearCallingIdentity();
            try {
                c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
        }
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                mValues.put(name, value);
            }
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}","{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    int currentGeneration = -1;
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
                if (mGenerationTracker != null) {
                    currentGeneration = mGenerationTracker.getCurrentGeneration();
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b;
            // clearCallingIdentity or use a ContentResolver from the caller as needed.
            if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
                final long token = Binder.clearCallingIdentity();
                try {
                    b = cp.call(cr.getPackageName(), cr.getAttributionTag(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            } else {
                b = cp.call(cr.getPackageName(), cr.getAttributionTag(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
            }
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                if (mGenerationTracker != null) {
                                    mGenerationTracker.destroy();
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                                currentGeneration = generation;
                            }
                        }
                        if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                            mValues.put(name, value);
                        }
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        Bundle queryArgs = ContentResolver.createSqlQueryBundle(NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        // Same workaround as above.
        if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
            final long token = Binder.clearCallingIdentity();
            try {
                c = cp.query(cr.getPackageName(), cr.getAttributionTag(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            c = cp.query(cr.getPackageName(), cr.getAttributionTag(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
        }
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                mValues.put(name, value);
            }
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,,,,
671,<android.net.NetworkCapabilities: String toString()>,29,30,<android.net.NetworkCapabilities: String toString()>,<android.net.NetworkCapabilities: String toString()>,0,"{
    final StringBuilder sb = new StringBuilder(""["");
    if (0 != mTransportTypes) {
        sb.append("" Transports: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mTransportTypes, NetworkCapabilities::transportNameOf, ""|"");
    }
    if (0 != mNetworkCapabilities) {
        sb.append("" Capabilities: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (0 != mUnwantedNetworkCapabilities) {
        sb.append("" Unwanted: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mUnwantedNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (mLinkUpBandwidthKbps > 0) {
        sb.append("" LinkUpBandwidth>="").append(mLinkUpBandwidthKbps).append(""Kbps"");
    }
    if (mLinkDownBandwidthKbps > 0) {
        sb.append("" LinkDnBandwidth>="").append(mLinkDownBandwidthKbps).append(""Kbps"");
    }
    if (mNetworkSpecifier != null) {
        sb.append("" Specifier: <"").append(mNetworkSpecifier).append("">"");
    }
    if (mTransportInfo != null) {
        sb.append("" TransportInfo: <"").append(mTransportInfo).append("">"");
    }
    if (hasSignalStrength()) {
        sb.append("" SignalStrength: "").append(mSignalStrength);
    }
    if (null != mUids) {
        if ((1 == mUids.size()) && (mUids.valueAt(0).count() == 1)) {
            sb.append("" Uid: "").append(mUids.valueAt(0).start);
        } else {
            sb.append("" Uids: <"").append(mUids).append("">"");
        }
    }
    if (mEstablishingVpnAppUid != INVALID_UID) {
        sb.append("" EstablishingAppUid: "").append(mEstablishingVpnAppUid);
    }
    if (null != mSSID) {
        sb.append("" SSID: "").append(mSSID);
    }
    sb.append(""]"");
    return sb.toString();
}","{
    final StringBuilder sb = new StringBuilder(""["");
    if (0 != mTransportTypes) {
        sb.append("" Transports: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mTransportTypes, NetworkCapabilities::transportNameOf, ""|"");
    }
    if (0 != mNetworkCapabilities) {
        sb.append("" Capabilities: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (0 != mUnwantedNetworkCapabilities) {
        sb.append("" Unwanted: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mUnwantedNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (mLinkUpBandwidthKbps > 0) {
        sb.append("" LinkUpBandwidth>="").append(mLinkUpBandwidthKbps).append(""Kbps"");
    }
    if (mLinkDownBandwidthKbps > 0) {
        sb.append("" LinkDnBandwidth>="").append(mLinkDownBandwidthKbps).append(""Kbps"");
    }
    if (mNetworkSpecifier != null) {
        sb.append("" Specifier: <"").append(mNetworkSpecifier).append("">"");
    }
    if (mTransportInfo != null) {
        sb.append("" TransportInfo: <"").append(mTransportInfo).append("">"");
    }
    if (hasSignalStrength()) {
        sb.append("" SignalStrength: "").append(mSignalStrength);
    }
    if (null != mUids) {
        if ((1 == mUids.size()) && (mUids.valueAt(0).count() == 1)) {
            sb.append("" Uid: "").append(mUids.valueAt(0).start);
        } else {
            sb.append("" Uids: <"").append(mUids).append("">"");
        }
    }
    if (mOwnerUid != Process.INVALID_UID) {
        sb.append("" OwnerUid: "").append(mOwnerUid);
    }
    if (mAdministratorUids.length == 0) {
        sb.append("" AdministratorUids: "").append(Arrays.toString(mAdministratorUids));
    }
    if (null != mSSID) {
        sb.append("" SSID: "").append(mSSID);
    }
    if (mPrivateDnsBroken) {
        sb.append("" Private DNS is broken"");
    }
    sb.append("" RequestorUid: "").append(mRequestorUid);
    sb.append("" RequestorPackageName: "").append(mRequestorPackageName);
    sb.append(""]"");
    return sb.toString();
}",1,,,-1,"[@Override, @NonNull]","[@Override, @NonNull]",-1,-1,-1,-1,-1,-1,"1,3,4",1,The implementation has several changes: ,"- Appending string literals about the 'mPrivateDnsBroken' status, 'mRequestorUid', and 'mRequestorPackageName'."
672,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",29,30,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        UriGrantsManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    try {
        UriGrantsManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the check for the nullity of 'uri,' which has been changed from Preconditions.checkNotNull to Objects.requireNonNull. This change affects neither the behavior of the API (since both methods serve the same purpose) nor its return value, as both throw a NullPointerException when 'uri' is null. Therefore, the code change type is 4.","No Compatibility Issue arises since the change from Preconditions.checkNotNull to Objects.requireNonNull does not affect the behavior of the method regarding the return value or exception throwing; it merely reflects a switch to a different standard library method for null checking which has the equivalent functionality. Hence, there is no CI and the CI type is 0."
674,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",29,30,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            if (!fixedSize) {
                mLayout.width = myWidth;
                mLayout.height = myHeight;
            } else {
                // Force the wallpaper to cover the screen in both dimensions
                // only internal implementations like ImageWallpaper
                DisplayInfo displayInfo = new DisplayInfo();
                mDisplay.getDisplayInfo(displayInfo);
                final float layoutScale = Math.max((float) displayInfo.logicalHeight / (float) myHeight, (float) displayInfo.logicalWidth / (float) myWidth);
                mLayout.height = (int) (myHeight * layoutScale);
                mLayout.width = (int) (myWidth * layoutScale);
                mWindowFlags |= WindowManager.LayoutParams.FLAG_SCALED;
            }
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mDisplay.getDisplayId(), mWinFrame, mContentInsets, mStableInsets, mOutsets, mDisplayCutout, mInputChannel, mInsetsState) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mDisplayCutout, mMergedConfiguration, mSurfaceControl, mInsetsState);
            if (mSurfaceControl.isValid()) {
                mSurfaceHolder.mSurface.copyFrom(mSurfaceControl);
                mSurfaceControl.release();
            }
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
                mDisplayCutout.set(mDisplayCutout.get().inset(-padding.left, -padding.top, -padding.right, -padding.bottom));
            } else {
                w = myWidth;
                h = myHeight;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(mDisplayCutout.get());
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mDispatchedDisplayCutout = mDisplayCutout.get();
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false, mDispatchedDisplayCutout);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setFitInsetsTypes(0);
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                InputChannel inputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mDisplay.getDisplayId(), mWinFrame, mContentInsets, mStableInsets, mDisplayCutout, inputChannel, mInsetsState, mTempControls) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mSession.setShouldZoomOutWallpaper(mWindow, shouldZoomOutWallpaper());
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(inputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrame, mContentInsets, mVisibleInsets, mStableInsets, mBackdropFrame, mDisplayCutout, mMergedConfiguration, mSurfaceControl, mInsetsState, mTempControls, mSurfaceSize, mTmpSurfaceControl);
            if (mSurfaceControl.isValid()) {
                mSurfaceHolder.mSurface.copyFrom(mSurfaceControl);
                mSurfaceControl.release();
            }
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
                mDisplayCutout.set(mDisplayCutout.get().inset(-padding.left, -padding.top, -padding.right, -padding.bottom));
            } else {
                w = myWidth;
                h = myHeight;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(mDisplayCutout.get());
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedDisplayCutout = mDisplayCutout.get();
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false, mDispatchedDisplayCutout);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow, null);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
675,<android.app.admin.DevicePolicyManager: int getPasswordMaximumLength(int)>,29,30,<android.app.admin.DevicePolicyManager: int getPasswordMaximumLength(int)>,<android.app.admin.DevicePolicyManager: int getPasswordMaximumLength(int)>,0,"{
    PackageManager pm = mContext.getPackageManager();
    if (!pm.hasSystemFeature(PackageManager.FEATURE_SECURE_LOCK_SCREEN)) {
        return 0;
    }
    // Kind-of arbitrary.
    return 16;
}","{
    PackageManager pm = mContext.getPackageManager();
    if (!pm.hasSystemFeature(PackageManager.FEATURE_SECURE_LOCK_SCREEN)) {
        return 0;
    }
    return MAX_PASSWORD_LENGTH;
}",1,"/**
 * Return the maximum password length that the device supports for a
 * particular password quality.
 * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 * password is always empty and this method always returns 0.
 * @param quality The quality being interrogated.
 * @return Returns the maximum length that the user can enter.
 */
","/**
 * Return the maximum password length that the device supports for a
 * particular password quality.
 * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 * password is always empty and this method always returns 0.
 * @param quality The quality being interrogated.
 * @return Returns the maximum length that the user can enter.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The literal return value '16' was changed to 'MAX_PASSWORD_LENGTH' constant. This is a change in an other statement (4). Additionally, since this change alters the value returned by the method, it also classifies as a change in a return statement (1).","Because the return value has changed from a hardcoded '16' to 'MAX_PASSWORD_LENGTH', this could result in the method returning a different value if 'MAX_PASSWORD_LENGTH' is not equal to '16', making the CI type 1."
676,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,29,30,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0 && !isMouseEvent;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);
                    final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
677,"<android.companion.CompanionDeviceManager: void associate(AssociationRequest,Callback,Handler)>",29,30,"<android.companion.CompanionDeviceManager: void associate(AssociationRequest,Callback,Handler)>","<android.companion.CompanionDeviceManager: void associate(AssociationRequest,Callback,Handler)>",0,"{
    if (!checkFeaturePresent()) {
        return;
    }
    checkNotNull(request, ""Request cannot be null"");
    checkNotNull(callback, ""Callback cannot be null"");
    try {
        mService.associate(request, new CallbackProxy(request, callback, Handler.mainIfNull(handler)), getCallingPackage());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (!checkFeaturePresent()) {
        return;
    }
    Objects.requireNonNull(request, ""Request cannot be null"");
    Objects.requireNonNull(callback, ""Callback cannot be null"");
    try {
        mService.associate(request, new CallbackProxy(request, callback, Handler.mainIfNull(handler)), getCallingPackage());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Associate this app with a companion device, selected by user
 *
 * <p>Once at least one appropriate device is found, {@code callback} will be called with a
 * {@link PendingIntent} that can be used to show the list of available devices for the user
 * to select.
 * It should be started for result (i.e. using
 * {@link android.app.Activity#startIntentSenderForResult}), as the resulting
 * {@link android.content.Intent} will contain extra {@link #EXTRA_DEVICE}, with the selected
 * device. (e.g. {@link android.bluetooth.BluetoothDevice})</p>
 *
 * <p>If your app needs to be excluded from battery optimizations (run in the background)
 * or to have unrestricted data access (use data in the background) you can declare that
 * you use the {@link android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND} and {@link
 * android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND} respectively. Note that these
 * special capabilities have a negative effect on the device's battery and user's data
 * usage, therefore you should requested them when absolutely necessary.</p>
 *
 * <p>You can call {@link #getAssociations} to get the list of currently associated
 * devices, and {@link #disassociate} to remove an association. Consider doing so when the
 * association is no longer relevant to avoid unnecessary battery and/or data drain resulting
 * from special privileges that the association provides</p>
 *
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @param request specific details about this request
 * @param callback will be called once there's at least one device found for user to choose from
 * @param handler A handler to control which thread the callback will be delivered on, or null,
 * to deliver it on main thread
 *
 * @see AssociationRequest
 */
","/**
 * Associate this app with a companion device, selected by user
 *
 * <p>Once at least one appropriate device is found, {@code callback} will be called with a
 * {@link PendingIntent} that can be used to show the list of available devices for the user
 * to select.
 * It should be started for result (i.e. using
 * {@link android.app.Activity#startIntentSenderForResult}), as the resulting
 * {@link android.content.Intent} will contain extra {@link #EXTRA_DEVICE}, with the selected
 * device. (e.g. {@link android.bluetooth.BluetoothDevice})</p>
 *
 * <p>If your app needs to be excluded from battery optimizations (run in the background)
 * or to have unrestricted data access (use data in the background) you can declare that
 * you use the {@link android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND} and {@link
 * android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND} respectively. Note that these
 * special capabilities have a negative effect on the device's battery and user's data
 * usage, therefore you should requested them when absolutely necessary.</p>
 *
 * <p>You can call {@link #getAssociations} to get the list of currently associated
 * devices, and {@link #disassociate} to remove an association. Consider doing so when the
 * association is no longer relevant to avoid unnecessary battery and/or data drain resulting
 * from special privileges that the association provides</p>
 *
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @param request specific details about this request
 * @param callback will be called once there's at least one device found for user to choose from
 * @param handler A handler to control which thread the callback will be delivered on, or null,
 * to deliver it on main thread
 *
 * @see AssociationRequest
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method calls `checkNotNull` have been replaced with `Objects.requireNonNull` calls, both of which serve the same purpose of null checking and throwing a null pointer exception if the condition is met. This does not change the control flow or functionality of the program, so the code change type is 4.","Despite the change in method calls for null checking, they are semantically identical, and this would not cause a compatibility issue since they serve the same purpose and would lead to the same outcome. Thus, the CI type is 0."
678,<android.service.dreams.DreamService: void finish()>,29,30,<android.service.dreams.DreamService: void finish()>,<android.service.dreams.DreamService: void finish()>,0,"{
    if (mDebug)
        Slog.v(TAG, ""finish(): mFinished="" + mFinished);
    if (!mFinished) {
        mFinished = true;
        if (mWindowToken == null) {
            Slog.w(TAG, ""Finish was called before the dream was attached."");
        } else {
            try {
                mSandman.finishSelf(mWindowToken, true);
            } catch (RemoteException ex) {
            // system server died
            }
        }
        // if launched via any other means
        stopSelf();
    }
}","{
    if (mDebug)
        Slog.v(TAG, ""finish(): mFinished="" + mFinished);
    Activity activity = mActivity;
    if (activity != null) {
        if (!activity.isFinishing()) {
            // In case the activity is not finished yet, do it now.
            activity.finishAndRemoveTask();
        }
        return;
    }
    if (mFinished) {
        return;
    }
    mFinished = true;
    if (mDreamToken == null) {
        Slog.w(TAG, ""Finish was called before the dream was attached."");
        stopSelf();
        return;
    }
    try {
        // finishSelf will unbind the dream controller from the dream service. This will
        // trigger DreamService.this.onDestroy and DreamService.this will die.
        mDreamManager.finishSelf(mDreamToken, true);
    } catch (RemoteException ex) {
    // system server died
    }
}",1,"/**
 * Stops the dream and detaches from the window.
 * <p>
 * When the dream ends, the system will be allowed to go to sleep fully unless there
 * is a reason for it to be awake such as recent user activity or wake locks being held.
 * </p>
 */
","/**
 * Stops the dream and detaches from the window.
 * <p>
 * When the dream ends, the system will be allowed to go to sleep fully unless there
 * is a reason for it to be awake such as recent user activity or wake locks being held.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The return statements have been added; the exception handling block and the control flow have been changed along with other variable names and call paths, such as from `mSandman.finishSelf` to `mDreamManager.finishSelf`. The usage of variables and the associated if conditions have also been altered, i.e., from `mWindowToken == null` to `mDreamToken == null`, and introduction of a new block checking `activity.isFinishing()`. So, the changes types are 1,2,3,4.","The altered control flow and added return statements potentially change the return values or types. Specifically, the new code checks if an associated `Activity` is not null and if it is not finishing, then it finishes the task which did not occur in the earlier version. Also, the exception handling statement has changed, which could potentially lead to different exceptions being propagated. Therefore, CI types are 1,2."
679,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,29,30,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_DRAW_FINISHED:
            return ""MSG_DRAW_FINISHED"";
        case MSG_INSETS_CHANGED:
            return ""MSG_INSETS_CHANGED"";
        case MSG_INSETS_CONTROL_CHANGED:
            return ""MSG_INSETS_CONTROL_CHANGED"";
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_DRAW_FINISHED:
            return ""MSG_DRAW_FINISHED"";
        case MSG_INSETS_CHANGED:
            return ""MSG_INSETS_CHANGED"";
        case MSG_INSETS_CONTROL_CHANGED:
            return ""MSG_INSETS_CONTROL_CHANGED"";
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"";
        case MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED:
            return ""MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED"";
        case MSG_SHOW_INSETS:
            return ""MSG_SHOW_INSETS"";
        case MSG_HIDE_INSETS:
            return ""MSG_HIDE_INSETS"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"Case statements have been added to the switch block (MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED, MSG_SHOW_INSETS, MSG_HIDE_INSETS), which constitutes a control dependency change (3) and also falls under other statement changed (4).","There is no Compatibility Issue since the changes only add new case statements for additional message types, which won't affect the existing behavior when handling the previously defined messages. Existing message handling and the default return statement remain unchanged, so there's no change in the potential return values or exceptions thrown based on the set of defined message types in the previous version."
680,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>",29,30,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>","<android.content.ContentProviderClient: int delete(Uri,String,String[])>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.delete(mPackageName, url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    return delete(url, ContentResolver.createSqlQueryBundle(selection, selectionArgs));
}",1,"/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
","/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
",-1,[@Override],,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2",There are several changes between the early and late version implementations of the delete method:,2. The try-catch block surrounding the call to mContentProvider.delete is removed.
681,<android.view.View: void draw(Canvas)>,29,30,<android.view.View: void draw(Canvas)>,<android.view.View: void draw(Canvas)>,0,"{
    final int privateFlags = mPrivateFlags;
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    drawBackground(canvas);
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        drawAutofilledHighlight(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
        // Step 7, draw the default focus highlight
        drawDefaultFocusHighlight(canvas);
        if (debugDraw()) {
            debugDrawFocus(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int topSaveCount = -1;
    int bottomSaveCount = -1;
    int leftSaveCount = -1;
    int rightSaveCount = -1;
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        if (drawTop) {
            topSaveCount = canvas.saveUnclippedLayer(left, top, right, top + length);
        }
        if (drawBottom) {
            bottomSaveCount = canvas.saveUnclippedLayer(left, bottom - length, right, bottom);
        }
        if (drawLeft) {
            leftSaveCount = canvas.saveUnclippedLayer(left, top, left + length, bottom);
        }
        if (drawRight) {
            rightSaveCount = canvas.saveUnclippedLayer(right - length, top, right, bottom);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    // must be restored in the reverse order that they were saved
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(rightSaveCount, p);
        } else {
            canvas.drawRect(right - length, top, right, bottom, p);
        }
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(leftSaveCount, p);
        } else {
            canvas.drawRect(left, top, left + length, bottom, p);
        }
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(bottomSaveCount, p);
        } else {
            canvas.drawRect(left, bottom - length, right, bottom, p);
        }
    }
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(topSaveCount, p);
        } else {
            canvas.drawRect(left, top, right, top + length, p);
        }
    }
    canvas.restoreToCount(saveCount);
    drawAutofilledHighlight(canvas);
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
    if (debugDraw()) {
        debugDrawFocus(canvas);
    }
}","{
    final int privateFlags = mPrivateFlags;
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         *      7. If necessary, draw the default focus highlight
         */
    // Step 1, draw the background, if needed
    int saveCount;
    drawBackground(canvas);
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        drawAutofilledHighlight(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
        // Step 7, draw the default focus highlight
        drawDefaultFocusHighlight(canvas);
        if (isShowingLayoutBounds()) {
            debugDrawFocus(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int topSaveCount = -1;
    int bottomSaveCount = -1;
    int leftSaveCount = -1;
    int rightSaveCount = -1;
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        if (drawTop) {
            topSaveCount = canvas.saveUnclippedLayer(left, top, right, top + length);
        }
        if (drawBottom) {
            bottomSaveCount = canvas.saveUnclippedLayer(left, bottom - length, right, bottom);
        }
        if (drawLeft) {
            leftSaveCount = canvas.saveUnclippedLayer(left, top, left + length, bottom);
        }
        if (drawRight) {
            rightSaveCount = canvas.saveUnclippedLayer(right - length, top, right, bottom);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    // must be restored in the reverse order that they were saved
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(rightSaveCount, p);
        } else {
            canvas.drawRect(right - length, top, right, bottom, p);
        }
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(leftSaveCount, p);
        } else {
            canvas.drawRect(left, top, left + length, bottom, p);
        }
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(bottomSaveCount, p);
        } else {
            canvas.drawRect(left, bottom - length, right, bottom, p);
        }
    }
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(topSaveCount, p);
        } else {
            canvas.drawRect(left, top, right, top + length, p);
        }
    }
    canvas.restoreToCount(saveCount);
    drawAutofilledHighlight(canvas);
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
    // Step 7, draw the default focus highlight
    drawDefaultFocusHighlight(canvas);
    if (isShowingLayoutBounds()) {
        debugDrawFocus(canvas);
    }
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,,,,
682,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,0,"{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.tearDown(streamId);
    }
}","{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.tearDown(streamId);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call checkIfCameraClosedOrInError() has been added before iterating through mConfiguredOutputs. This is an 'Other statement changed' as it does not fit into return statement, exception handling, or control dependency change categories.","The newly introduced method call checkIfCameraClosedOrInError() does not lead to a Compatibility Issue because it does not alter the behavior of existing return statements or exception handling. Assuming checkIfCameraClosedOrInError() is handling internal state checks without affecting the external behavior of tearDown(), it presumably throws a runtime exception if the camera is closed or in error, which is a behavior that should have been present in the earlier version as an implicit contract of the API's correct usage."
683,<android.os.PowerManager: boolean isIgnoringBatteryOptimizations(String)>,29,30,<android.os.PowerManager: boolean isIgnoringBatteryOptimizations(String)>,<android.os.PowerManager: boolean isIgnoringBatteryOptimizations(String)>,0,"{
    synchronized (this) {
        if (mIDeviceIdleController == null) {
            mIDeviceIdleController = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
        }
    }
    try {
        return mIDeviceIdleController.isPowerSaveWhitelistApp(packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return getPowerWhitelistManager().isWhitelisted(packageName, true);
}",1,"/**
 * Return whether the given application package name is on the device's power whitelist.
 * Apps can be placed on the whitelist through the settings UI invoked by
 * {@link android.provider.Settings#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS}.
 */
","/**
 * Return whether the given application package name is on the device's power whitelist.
 * Apps can be placed on the whitelist through the settings UI invoked by
 * {@link android.provider.Settings#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has been completely changed from the early to the late version. The early version implementation interacted with `IDeviceIdleController` service, acquiring it and then using its `isPowerSaveWhitelistApp` method. In the late version, it directly uses a method from `getPowerWhitelistManager()`. This observed change includes the deletion of the entire `synchronized` block and a completely different return statement, which are changes in the dependent API called within the method, so the code change type is 1,5.","As the implementation has changed to use a different API method for checking the power save whitelist status, the return value might differ compared to the previous version. As such, it can lead to a different behavior for the callers of `isIgnoringBatteryOptimizations` and, therefore, is a potential Compatibility Issue related to different return values, which is type 1."
684,<android.app.ContextImpl: File getCodeCacheDir()>,29,30,<android.app.ContextImpl: File getCodeCacheDir()>,<android.app.ContextImpl: File getCodeCacheDir()>,0,"{
    synchronized (mSync) {
        if (mCodeCacheDir == null) {
            mCodeCacheDir = new File(getDataDir(), ""code_cache"");
        }
        return ensurePrivateCacheDirExists(mCodeCacheDir, XATTR_INODE_CODE_CACHE);
    }
}","{
    synchronized (mSync) {
        if (mCodeCacheDir == null) {
            mCodeCacheDir = getCodeCacheDirBeforeBind(getDataDir());
        }
        return ensurePrivateCacheDirExists(mCodeCacheDir, XATTR_INODE_CODE_CACHE);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method called to initialize `mCodeCacheDir` has been changed from `new File(getDataDir(), ""code_cache"")` to `getCodeCacheDirBeforeBind(getDataDir())`. This is a change in the dependent API, so the code change type is 5.","The change in how `mCodeCacheDir` is initialized should not cause a Compatibility Issue as long as the new `getCodeCacheDirBeforeBind(getDataDir())` method returns a `File` object that represents the same code cache directory. The replacement of constructing a `File` object directly with a method call suggests an internal refactoring that should not affect the behavior of the `getCodeCacheDir()` method as observed by its clients. Assuming the contract of the `getCodeCacheDir()` method has not been broken by the change, there is no Compatibility Issue. Therefore, the CI type is 0."
685,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,29,30,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,0,"{
    mActivity = Preconditions.checkNotNull(activity, ""activity cannot be null"");
    return this;
}","{
    mActivity = Objects.requireNonNull(activity, ""activity cannot be null"");
    return this;
}",1,"/**
 * Sets the target activity.  A shortcut will be shown along with this activity's icon
 * on the launcher.
 *
 * When selecting a target activity, keep the following in mind:
 * <ul>
 * <li>All dynamic shortcuts must have a target activity.  When a shortcut with no target
 * activity is published using
 * {@link ShortcutManager#addDynamicShortcuts(List)} or
 * {@link ShortcutManager#setDynamicShortcuts(List)},
 * the first main activity defined in the app's <code>AndroidManifest.xml</code>
 * file is used.
 *
 * <li>Only ""main"" activities&mdash;ones that define the {@link Intent#ACTION_MAIN}
 * and {@link Intent#CATEGORY_LAUNCHER} intent filters&mdash;can be target
 * activities.
 *
 * <li>By default, the first main activity defined in the app's manifest is
 * the target activity.
 *
 * <li>A target activity must belong to the publisher app.
 * </ul>
 *
 * @see ShortcutInfo#getActivity()
 */
","/**
 * Sets the target activity.  A shortcut will be shown along with this activity's icon
 * on the launcher.
 *
 * When selecting a target activity, keep the following in mind:
 * <ul>
 * <li>All dynamic shortcuts must have a target activity.  When a shortcut with no target
 * activity is published using
 * {@link ShortcutManager#addDynamicShortcuts(List)} or
 * {@link ShortcutManager#setDynamicShortcuts(List)},
 * the first main activity defined in the app's <code>AndroidManifest.xml</code>
 * file is used.
 *
 * <li>Only ""main"" activities&mdash;ones that define the {@link Intent#ACTION_MAIN}
 * and {@link Intent#CATEGORY_LAUNCHER} intent filters&mdash;can be target
 * activities.
 *
 * <li>By default, the first main activity defined in the app's manifest is
 * the target activity.
 *
 * <li>A target activity must belong to the publisher app.
 * </ul>
 *
 * @see ShortcutInfo#getActivity()
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The statement has changed from using Preconditions.checkNotNull to Objects.requireNonNull, which both serve the same purpose of null-checking but come from different utility classes. They can be considered equivalent for the purposes of null-checking, thus the change type is 5.","Since both Preconditions.checkNotNull and Objects.requireNonNull fundamentally do the same thing (throw a NullPointerException if the given object is null), utilizing one over the other does not lead to a different behavior. As such, there is no compatibility issue caused by this change."
686,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,29,30,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,0,"{
    if (getAutoVerify()) {
        serializer.attribute(null, AUTO_VERIFY_STR, Boolean.toString(true));
    }
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    N = countDataTypes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, TYPE_STR);
        String type = mDataTypes.get(i);
        if (type.indexOf('/') < 0)
            type = type + ""/*"";
        serializer.attribute(null, NAME_STR, type);
        serializer.endTag(null, TYPE_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataSchemeSpecificParts();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SSP_STR);
        PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, SSP_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}","{
    if (getAutoVerify()) {
        serializer.attribute(null, AUTO_VERIFY_STR, Boolean.toString(true));
    }
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    writeDataTypesToXml(serializer);
    N = countMimeGroups();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, GROUP_STR);
        serializer.attribute(null, NAME_STR, mMimeGroups.get(i));
        serializer.endTag(null, GROUP_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataSchemeSpecificParts();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SSP_STR);
        PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, SSP_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}",1,"/**
 * Write the contents of the IntentFilter as an XML stream.
 */
","/**
 * Write the contents of the IntentFilter as an XML stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
687,"<android.app.ActivityThread.AndroidOs: void rename(String,String)>",29,30,"<android.app.ActivityThread.AndroidOs: void rename(String,String)>","<android.app.ActivityThread.AndroidOs: void rename(String,String)>",0,"{
    try {
        super.rename(oldPath, newPath);
    } catch (ErrnoException e) {
        if (e.errno == OsConstants.EXDEV) {
            Log.v(TAG, ""Recovering failed rename "" + oldPath + "" to "" + newPath);
            try {
                Files.move(new File(oldPath).toPath(), new File(newPath).toPath());
            } catch (IOException e2) {
                throw e;
            }
        } else {
            throw e;
        }
    }
}","{
    try {
        super.rename(oldPath, newPath);
    } catch (ErrnoException e) {
        // the primary storage.
        if (e.errno == OsConstants.EXDEV && oldPath.startsWith(""/storage/emulated"") && newPath.startsWith(""/storage/emulated"")) {
            Log.v(TAG, ""Recovering failed rename "" + oldPath + "" to "" + newPath);
            try {
                Files.move(new File(oldPath).toPath(), new File(newPath).toPath(), StandardCopyOption.REPLACE_EXISTING);
            } catch (IOException e2) {
                Log.e(TAG, ""Rename recovery failed "", e);
                throw e;
            }
        } else {
            throw e;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The 'if' statement condition has been extended with additional checks of the paths starting with ""/storage/emulated"" and an extra argument `StandardCopyOption.REPLACE_EXISTING` has been added to the `Files.move` method call. Therefore, we have both control dependency change (3) and other statement change (4).","There are no compatibility issues since the additional checks and the extra argument only provide more detailed control over when the code inside the 'if' block is executed and handle a specific overwrite scenario. They should not cause any different behavior from the perspective of API consumers unless they rely on the failed rename throwing an exception, which would be an incorrect assumption about the API's reliability guarantees. Thus, no new exception is thrown or value is returned under normal operation conditions."
688,"<android.content.res.AssetManager: boolean retrieveAttributes(Parser,int[],int[],int[])>",29,30,"<android.content.res.AssetManager: boolean retrieveAttributes(Parser,int[],int[],int[])>","<android.content.res.AssetManager: boolean retrieveAttributes(Parser,int[],int[],int[])>",0,"{
    Preconditions.checkNotNull(parser, ""parser"");
    Preconditions.checkNotNull(inAttrs, ""inAttrs"");
    Preconditions.checkNotNull(outValues, ""outValues"");
    Preconditions.checkNotNull(outIndices, ""outIndices"");
    synchronized (this) {
        // Need to synchronize on AssetManager because we will be accessing
        // the native implementation of AssetManager.
        ensureValidLocked();
        return nativeRetrieveAttributes(mObject, parser.mParseState, inAttrs, outValues, outIndices);
    }
}","{
    Objects.requireNonNull(parser, ""parser"");
    Objects.requireNonNull(inAttrs, ""inAttrs"");
    Objects.requireNonNull(outValues, ""outValues"");
    Objects.requireNonNull(outIndices, ""outIndices"");
    synchronized (this) {
        // Need to synchronize on AssetManager because we will be accessing
        // the native implementation of AssetManager.
        ensureValidLocked();
        return nativeRetrieveAttributes(mObject, parser.mParseState, inAttrs, outValues, outIndices);
    }
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,4,0,"The checkNotNull methods from Preconditions class have been replaced with requireNonNull methods from Objects class. This is a direct swap of similar functionality, which constitutes an 'Other statement changed' as per code change type 4.","There is no Compatibility Issue since the behavior of the method has not changed despite the replacement of one null-checking method with another, which performs the same operation. Thus, CI type is 0."
690,"<android.hardware.camera2.params.BlackLevelPattern: void copyTo(int[],int)>",29,30,"<android.hardware.camera2.params.BlackLevelPattern: void copyTo(int[],int)>","<android.hardware.camera2.params.BlackLevelPattern: void copyTo(int[],int)>",0,"{
    checkNotNull(destination, ""destination must not be null"");
    if (offset < 0) {
        throw new IllegalArgumentException(""Null offset passed to copyTo"");
    }
    if (destination.length - offset < COUNT) {
        throw new ArrayIndexOutOfBoundsException(""destination too small to fit elements"");
    }
    for (int i = 0; i < COUNT; ++i) {
        destination[offset + i] = mCfaOffsets[i];
    }
}","{
    Objects.requireNonNull(destination, ""destination must not be null"");
    if (offset < 0) {
        throw new IllegalArgumentException(""Null offset passed to copyTo"");
    }
    if (destination.length - offset < COUNT) {
        throw new ArrayIndexOutOfBoundsException(""destination too small to fit elements"");
    }
    for (int i = 0; i < COUNT; ++i) {
        destination[offset + i] = mCfaOffsets[i];
    }
}",1,"/**
 * Copy the ColorChannel offsets into the destination vector.
 *
 * <p>Offsets are given in row-column scan order for a given 2x2 color pattern.</p>
 *
 * @param destination an array big enough to hold at least {@value #COUNT} elements after the
 * {@code offset}
 * @param offset a non-negative offset into the array
 *
 * @throws IllegalArgumentException if the offset is invalid.
 * @throws ArrayIndexOutOfBoundsException if the destination vector is too small.
 * @throws NullPointerException if the destination is null.
 */
","/**
 * Copy the ColorChannel offsets into the destination vector.
 *
 * <p>Offsets are given in row-column scan order for a given 2x2 color pattern.</p>
 *
 * @param destination an array big enough to hold at least {@value #COUNT} elements after the
 * {@code offset}
 * @param offset a non-negative offset into the array
 *
 * @throws IllegalArgumentException if the offset is invalid.
 * @throws ArrayIndexOutOfBoundsException if the destination vector is too small.
 * @throws NullPointerException if the destination is null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the replacement of a method call for checking if the 'destination' is null, from 'checkNotNull(destination, ""destination must not be null"")' to 'Objects.requireNonNull(destination, ""destination must not be null"")'. This is an example of an ""Other statement changed"", hence the code change type is 4.","Although there is a change in the implementation, this change will have no effect on the behaviour of the API regarding the values it returns or the exceptions it throws, because 'checkNotNull' and 'Objects.requireNonNull' have the same purpose and throw the same exception if the 'destination' is null. Thus, there is no Compatibility Issue, the CI type is 0."
693,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,29,30,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,0,"{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0, null, null);
    context.setResources(packageInfo.getResources());
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetrics());
    return context;
}","{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, null, 0, null, null);
    context.setResources(packageInfo.getResources());
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetrics());
    context.mIsSystemOrSystemUiContext = true;
    return context;
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,4,0,"New field assignment `context.mIsSystemOrSystemUiContext = true;` is added in the late implementation. This change is not part of a return statement, exception handling, or control structure but is an instance variable setting, placed under other statement changes, so the code change type is 4.","The additional assignment to the field `mIsSystemOrSystemUiContext` will not affect the method's return value or how it throws exceptions. Therefore, there is no Compatibility Issue, and the CI type is 0."
694,<android.service.voice.AlwaysOnHotwordDetector.RefreshAvailabiltyTask: Void doInBackground(Void)>,29,30,<android.service.voice.AlwaysOnHotwordDetector.RefreshAvailabiltyTask: Void doInBackground(Void)>,<android.service.voice.AlwaysOnHotwordDetector.RefreshAvailabiltyTask: Void doInBackground(Void)>,0,"{
    int availability = internalGetInitialAvailability();
    boolean enrolled = false;
    // Fetch the sound model if the availability is one of the supported ones.
    if (availability == STATE_NOT_READY || availability == STATE_KEYPHRASE_UNENROLLED || availability == STATE_KEYPHRASE_ENROLLED) {
        enrolled = internalGetIsEnrolled(mKeyphraseMetadata.id, mLocale);
        if (!enrolled) {
            availability = STATE_KEYPHRASE_UNENROLLED;
        } else {
            availability = STATE_KEYPHRASE_ENROLLED;
        }
    }
    synchronized (mLock) {
        if (DBG) {
            Slog.d(TAG, ""Hotword availability changed from "" + mAvailability + "" -> "" + availability);
        }
        mAvailability = availability;
        notifyStateChangedLocked();
    }
    return null;
}","{
    int availability = internalGetInitialAvailability();
    synchronized (mLock) {
        if (availability == STATE_NOT_READY) {
            internalUpdateEnrolledKeyphraseMetadata();
            if (mKeyphraseMetadata != null) {
                availability = STATE_KEYPHRASE_ENROLLED;
            } else {
                availability = STATE_KEYPHRASE_UNENROLLED;
            }
        }
        if (DBG) {
            Slog.d(TAG, ""Hotword availability changed from "" + mAvailability + "" -> "" + availability);
        }
        mAvailability = availability;
        notifyStateChangedLocked();
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed due to the removal of the condition checking `enrolled` and changes in the conditions of the if-statement. Additionally, the method `internalGetIsEnrolled` call and related assignment operations to the variable `enrolled` have been removed, constituting an other statement changed. These alterations fall under change types 3 and 4.","There is no Compatibility Issue with the return value, since the method in both versions always returns `null`. Additionally, no new exceptions are thrown or old exceptions handling removed. Thus, despite the changes in the internal control flow and other statements, these changes do not have an impact on the output or exception behavior of the method, making the CI type as 0."
696,<android.widget.Toast: void cancel()>,29,30,<android.widget.Toast: void cancel()>,<android.widget.Toast: void cancel()>,0,"{
    mTN.cancel();
}","{
    if (Compatibility.isChangeEnabled(CHANGE_TEXT_TOASTS_IN_THE_SYSTEM) && mNextView == null) {
        try {
            getService().cancelToast(mContext.getOpPackageName(), mToken);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mTN.cancel();
    }
}",1,"/**
 * Close the view if it's showing, or don't show it if it isn't showing yet.
 * You do not normally have to call this.  Normally view will disappear on its own
 * after the appropriate duration.
 */
","/**
 * Close the view if it's showing, or don't show it if it isn't showing yet.
 * You do not normally have to call this.  Normally view will disappear on its own
 * after the appropriate duration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"There is a new if condition with compatibility check for CHANGE_TEXT_TOASTS_IN_THE_SYSTEM and the logic for handling when mNextView is null has been added. There is also a new exception handling statement for RemoteException, so the code change is 3 for the new condition dependent code and 2 for the handling of the exception.","The new version of the API could throw a different exception when the condition (Compatibility.isChangeEnabled(CHANGE_TEXT_TOASTS_IN_THE_SYSTEM) && mNextView == null) is true. In the early version, this check is not performed, and therefore an exception in that scenario would not have been thrown. This change could cause the method to behave differently ('mTN.cancel()' wouldn't be called), and that's why the CI type is 2."
697,<android.view.DisplayCutout: boolean equals(Object)>,29,30,<android.view.DisplayCutout: boolean equals(Object)>,<android.view.DisplayCutout: boolean equals(Object)>,0,"{
    if (o == this) {
        return true;
    }
    if (o instanceof DisplayCutout) {
        DisplayCutout c = (DisplayCutout) o;
        return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds);
    }
    return false;
}","{
    if (o == this) {
        return true;
    }
    if (o instanceof DisplayCutout) {
        DisplayCutout c = (DisplayCutout) o;
        return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The change is within the 'if' block for the instance check (instanceof DisplayCutout), where an additional condition is added to the 'return' expression (mWaterfallInsets.equals(c.mWaterfallInsets)). This is an ""Other statement changed"" scenario since the alteration is neither a new/removed return statement nor an exception handling statement change nor a dependent API change, and neither is it changing the control flow dependencies.","This change introduces an additional equality check with mWaterfallInsets, which means that the method could potentially return a different value (true or false) based on the new condition, resulting in a CI due to different return values."
699,<android.util.Half: boolean isInfinite(short)>,29,30,<android.util.Half: boolean isInfinite(short)>,<android.util.Half: boolean isInfinite(short)>,0,"{
    return (h & FP16_COMBINED) == FP16_EXPONENT_MAX;
}","{
    return FP16.isInfinite(h);
}",1,"/**
 * Returns true if the specified half-precision float value represents
 * infinity, false otherwise.
 *
 * @param h A half-precision float value
 * @return True if the value is positive infinity or negative infinity,
 * false otherwise
 */
","/**
 * Returns true if the specified half-precision float value represents
 * infinity, false otherwise.
 *
 * @param h A half-precision float value
 * @return True if the value is positive infinity or negative infinity,
 * false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method for checking infinity has been changed from a direct bitwise operation to a call to another method FP16.isInfinite(h), which can be considered as the dependent API changed; hence the code change type is 5.","There is no compatibility issue as the behavior of the API is expected to remain the same. The abstraction of the check into a different method (FP16.isInfinite) is an internal change that should not affect the return values for the users of the API, so the CI type is 0."
700,<android.speech.tts.TextToSpeech: Set<Voice> getVoices()>,29,30,<android.speech.tts.TextToSpeech: Set<Voice> getVoices()>,<android.speech.tts.TextToSpeech: Set<Voice> getVoices()>,0,"{
    return runAction(new Action<Set<Voice>>() {

        @Override
        public Set<Voice> run(ITextToSpeechService service) throws RemoteException {
            List<Voice> voices = service.getVoices();
            return (voices != null) ? new HashSet<Voice>(voices) : new HashSet<Voice>();
        }
    }, null, ""getVoices"");
}","{
    return runAction((ITextToSpeechService service) -> {
        List<Voice> voices = service.getVoices();
        return (voices != null) ? new HashSet<Voice>(voices) : new HashSet<Voice>();
    }, null, ""getVoices"");
}",1,"/**
 * Query the engine about the set of available voices.
 *
 * Each TTS Engine can expose multiple voices for each locale, each with a different set of
 * features.
 *
 * @see #setVoice(Voice)
 * @see Voice
 */
","/**
 * Query the engine about the set of available voices.
 *
 * Each TTS Engine can expose multiple voices for each locale, each with a different set of
 * features.
 *
 * @see #setVoice(Voice)
 * @see Voice
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is from an anonymous class to a lambda expression which does the same action, so the change type is 4.","The change from anonymous class to lambda doesn't alter the functionality or output of the method; it's merely a syntactic change that doesn't affect behavior. Thus, there's no Compatibility Issue, so the CI type is 0."
701,<android.view.contentcapture.ContentCaptureManager: ComponentName getServiceComponentName()>,29,30,<android.view.contentcapture.ContentCaptureManager: ComponentName getServiceComponentName()>,<android.view.contentcapture.ContentCaptureManager: ComponentName getServiceComponentName()>,0,"{
    if (!isContentCaptureEnabled() && !mOptions.lite)
        return null;
    final SyncResultReceiver resultReceiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getServiceComponentName(resultReceiver);
        return resultReceiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (!isContentCaptureEnabled() && !mOptions.lite)
        return null;
    final SyncResultReceiver resultReceiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getServiceComponentName(resultReceiver);
        return resultReceiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get service componentName."");
    }
}",1,"/**
 * Returns the component name of the system service that is consuming the captured events for
 * the current user.
 */
","/**
 * Returns the component name of the system service that is consuming the captured events for
 * the current user.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,2,2,"A new exception handling statement is introduced for SyncResultReceiver.TimeoutException, and it is now caught and results in a RuntimeException, so the code change type is 2.","The new exception handling for SyncResultReceiver.TimeoutException can lead to a different exception being thrown (a RuntimeException instead of a TimeoutException), causing a change in behavior when an exception occurs. Thereby, the CI type is 2."
702,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(Uri)>,29,30,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(Uri)>,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(Uri)>,0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireUnstableProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, uri.getAuthority(), false);
    }
    return null;
}","{
    Objects.requireNonNull(uri, ""uri"");
    IContentProvider provider = acquireUnstableProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, uri.getAuthority(), false);
    }
    return null;
}",1,"/**
 * Like {@link #acquireContentProviderClient(Uri)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
","/**
 * Like {@link #acquireContentProviderClient(Uri)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The method used to check for null has changed from Preconditions.checkNotNull() to Objects.requireNonNull(), which do not change functionality because both serve the same purpose of throwing a NullPointerException when 'uri' is null. As a result, the change type is 4.",No Compatibility Issue arises because the behavior and the return value of the method remain unaffected by changing the method of null-checking.
703,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",29,30,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.addAccount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn);
        }
    }.start();
}","{
    if (Process.myUserHandle().equals(mContext.getUser())) {
        if (accountType == null)
            throw new IllegalArgumentException(""accountType is null"");
        final Bundle optionsIn = new Bundle();
        if (addAccountOptions != null) {
            optionsIn.putAll(addAccountOptions);
        }
        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
        return new AmsTask(activity, handler, callback) {

            @Override
            public void doWork() throws RemoteException {
                mService.addAccount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn);
            }
        }.start();
    } else {
        return addAccountAsUser(accountType, authTokenType, requiredFeatures, addAccountOptions, activity, callback, handler, mContext.getUser());
    }
}",1,"/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process or adding accounts
 * (of this type) has been disabled by policy
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */
","/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process or adding accounts
 * (of this type) has been disabled by policy
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */
",-1,,[@UserHandleAware],-1,-1,-1,-1,-1,-1,3,1,"The new version introduced an additional condition check `Process.myUserHandle().equals(mContext.getUser())`, and only executes the original code block when this condition is true. There is also a new return statement inside an 'else' block which adds functionality for accounts belonging to a different user, so the code change type is 3.","Since there's a new conditional statement that alters the control flow, and under certain circumstances (when the user handle does not match), a completely different method `addAccountAsUser` is called instead of executing the original block, this could result in different returned values. Therefore, the CI type is 1."
704,<android.net.ConnectivityManager: NetworkCapabilities getNetworkCapabilities(Network)>,29,30,<android.net.ConnectivityManager: NetworkCapabilities getNetworkCapabilities(Network)>,<android.net.ConnectivityManager: NetworkCapabilities getNetworkCapabilities(Network)>,0,"{
    try {
        return mService.getNetworkCapabilities(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getNetworkCapabilities(network, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the {@link android.net.NetworkCapabilities} for the given {@link Network}.  This
 * will return {@code null} if the network is unknown.
 *
 * @param network The {@link Network} object identifying the network in question.
 * @return The {@link android.net.NetworkCapabilities} for the network, or {@code null}.
 */
","/**
 * Get the {@link android.net.NetworkCapabilities} for the given {@link Network}.  This
 * will return {@code null} if the network is unknown.
 *
 * @param network The {@link Network} object identifying the network in question.
 * @return The {@link android.net.NetworkCapabilities} for the network, or {@code null}.
 */
",-1,"[@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE), @Nullable]","[@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE), @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The implementation of the API now includes an additional parameter passed to mService.getNetworkCapabilities, which is a change in the dependent API, therefore, the code change type is 5.","Although there is an additional parameter passed to the dependent API (getNetworkCapabilities on the mService object), this does not necessarily lead to a Compatibility Issue since the method name and its external behavior as perceived by the caller should remain the same. The added parameter is internally used and does not reflect a change in the return type or a different exception being thrown that will be visible to the caller. Thus, there is no Compatibility Issue, and the CI type is 0."
706,<android.util.ArraySet: boolean add(E)>,29,30,<android.util.ArraySet: boolean add(E)>,<android.util.ArraySet: boolean add(E)>,0,"{
    final int hash;
    int index;
    if (value == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(value) : value.hashCode();
        index = indexOf(value, hash);
    }
    if (index >= 0) {
        return false;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""add: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""add: copy 0-"" + mSize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG) {
            Log.d(TAG, ""add: move "" + index + ""-"" + (mSize - index) + "" to "" + (index + 1));
        }
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index, mArray, index + 1, mSize - index);
    }
    mHashes[index] = hash;
    mArray[index] = value;
    mSize++;
    return true;
}","{
    final int oSize = mSize;
    final int hash;
    int index;
    if (value == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(value) : value.hashCode();
        index = indexOf(value, hash);
    }
    if (index >= 0) {
        return false;
    }
    index = ~index;
    if (oSize >= mHashes.length) {
        final int n = oSize >= (BASE_SIZE * 2) ? (oSize + (oSize >> 1)) : (oSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""add: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (oSize != mSize) {
            throw new ConcurrentModificationException();
        }
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""add: copy 0-"" + oSize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, oSize);
    }
    if (index < oSize) {
        if (DEBUG) {
            Log.d(TAG, ""add: move "" + index + ""-"" + (oSize - index) + "" to "" + (index + 1));
        }
        System.arraycopy(mHashes, index, mHashes, index + 1, oSize - index);
        System.arraycopy(mArray, index, mArray, index + 1, oSize - index);
    }
    if (oSize != mSize || index >= mHashes.length) {
        throw new ConcurrentModificationException();
    }
    mHashes[index] = hash;
    mArray[index] = value;
    mSize++;
    return true;
}",1,"/**
 * Adds the specified object to this set. The set is not modified if it
 * already contains the object.
 *
 * @param value the object to add.
 * @return {@code true} if this set is modified, {@code false} otherwise.
 * @throws ClassCastException
 * when the class of the object is inappropriate for this set.
 */
","/**
 * Adds the specified object to this set. The set is not modified if it
 * already contains the object.
 *
 * @param value the object to add.
 * @return {@code true} if this set is modified, {@code false} otherwise.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late version code has introduced a new variable `oSize` to hold the original size of the set before modification and added a new exception handling with `ConcurrentModificationException`. Also, there are changes in control statements by using the variable `oSize` instead of `mSize` within conditions, and an additional check to throw `ConcurrentModificationException` if the size or index is not as expected. These are considered as changes in exception handling statements, control dependency, and other statements (2,3,4).","The addition of new paths that can throw `ConcurrentModificationException` leads to a potential different exception handling situation (type 2). This exception was not thrown in the early version. In addition, the introduction of new variable `oSize` and new conditions using this variable could potentially lead to different return values (type 1), since it may affect the flow of control and the value returned based on the new exception handling logic."
708,<android.os.SystemClock: boolean setCurrentTimeMillis(long)>,29,30,<android.os.SystemClock: boolean setCurrentTimeMillis(long)>,<android.os.SystemClock: boolean setCurrentTimeMillis(long)>,0,"{
    final IAlarmManager mgr = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
    if (mgr == null) {
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    } catch (SecurityException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    }
    return false;
}","{
    final IAlarmManager mgr = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
    if (mgr == null) {
        Slog.e(TAG, ""Unable to set RTC: mgr == null"");
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    } catch (SecurityException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    }
    return false;
}",1,"/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */
","/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An extra logging statement 'Slog.e(TAG, ""Unable to set RTC: mgr == null"");' has been added to the early return case when 'mgr == null', so the change type is 4.","The functionality and possible outcomes of the API have not changed; the added logging statement does not affect the return value or exception handling of the API, resulting in no compatibility issues. Thus, the CI type is 0."
710,"<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult[],int)>",29,30,"<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult[],int)>","<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult[],int)>",0,"{
    if (mFailureAllowed) {
        try {
            return applyInternal(provider, backRefs, numBackRefs);
        } catch (Exception e) {
            return new ContentProviderResult(e.getMessage());
        }
    } else {
        return applyInternal(provider, backRefs, numBackRefs);
    }
}","{
    if (mExceptionAllowed) {
        try {
            return applyInternal(provider, backRefs, numBackRefs);
        } catch (Exception e) {
            return new ContentProviderResult(e);
        }
    } else {
        return applyInternal(provider, backRefs, numBackRefs);
    }
}",1,"/**
 * Applies this operation using the given provider. The backRefs array is used to resolve any
 * back references that were requested using
 * {@link Builder#withValueBackReferences(ContentValues)} and
 * {@link Builder#withSelectionBackReference}.
 * @param provider the {@link ContentProvider} on which this batch is applied
 * @param backRefs a {@link ContentProviderResult} array that will be consulted
 * to resolve any requested back references.
 * @param numBackRefs the number of valid results on the backRefs array.
 * @return a {@link ContentProviderResult} that contains either the {@link Uri} of the inserted
 * row if this was an insert otherwise the number of rows affected.
 * @throws OperationApplicationException thrown if either the insert fails or
 * if the number of rows affected didn't match the expected count
 */
","/**
 * Applies this operation using the given provider. The backRefs array is used to resolve any
 * back references that were requested using
 * {@link Builder#withValueBackReferences(ContentValues)} and
 * {@link Builder#withSelectionBackReference}.
 * @param provider the {@link ContentProvider} on which this batch is applied
 * @param backRefs a {@link ContentProviderResult} array that will be consulted
 * to resolve any requested back references.
 * @param numBackRefs the number of valid results on the backRefs array.
 * @return a {@link ContentProviderResult} that contains either the {@link Uri} of the inserted
 * row if this was an insert otherwise the number of rows affected.
 * @throws OperationApplicationException thrown if either the insert fails or
 * if the number of rows affected didn't match the expected count
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,3","1,2","The control variable has been renamed from mFailureAllowed to mExceptionAllowed, and the catch block return statement creates a new instance of ContentProviderResult differently: in the early version with e.getMessage() as a parameter, and in the late version with e as a parameter, so the code change type is 1,3.","Due to the change in the exception handling by the new ContentProviderResult(e), a different behavior will result if an Exception is caught, which could lead to a different return value or even a different type, and thus the CI type is 1,2."
711,"<android.service.voice.VoiceInteractionService: void showSession(Bundle,int)>",29,30,"<android.service.voice.VoiceInteractionService: void showSession(Bundle,int)>","<android.service.voice.VoiceInteractionService: void showSession(Bundle,int)>",0,"{
    if (mSystemService == null) {
        throw new IllegalStateException(""Not available until onReady() is called"");
    }
    try {
        mSystemService.showSession(mInterface, args, flags);
    } catch (RemoteException e) {
    }
}","{
    if (mSystemService == null) {
        throw new IllegalStateException(""Not available until onReady() is called"");
    }
    try {
        mSystemService.showSession(args, flags);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Request that the associated {@link android.service.voice.VoiceInteractionSession} be
 * shown to the user, starting it if necessary.
 * @param args Arbitrary arguments that will be propagated to the session.
 * @param flags Indicates additional optional behavior that should be performed.  May
 * be any combination of
 * {@link VoiceInteractionSession#SHOW_WITH_ASSIST VoiceInteractionSession.SHOW_WITH_ASSIST} and
 * {@link VoiceInteractionSession#SHOW_WITH_SCREENSHOT
 * VoiceInteractionSession.SHOW_WITH_SCREENSHOT}
 * to request that the system generate and deliver assist data on the current foreground
 * app as part of showing the session UI.
 */
","/**
 * Request that the associated {@link android.service.voice.VoiceInteractionSession} be
 * shown to the user, starting it if necessary.
 * @param args Arbitrary arguments that will be propagated to the session.
 * @param flags Indicates additional optional behavior that should be performed.  May
 * be any combination of
 * {@link VoiceInteractionSession#SHOW_WITH_ASSIST VoiceInteractionSession.SHOW_WITH_ASSIST} and
 * {@link VoiceInteractionSession#SHOW_WITH_SCREENSHOT
 * VoiceInteractionSession.SHOW_WITH_SCREENSHOT}
 * to request that the system generate and deliver assist data on the current foreground
 * app as part of showing the session UI.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method signature of mSystemService.showSession() call has changed. It no longer takes mInterface as a parameter. Because no other code has changed and exception handling remains the same, the only change is in the dependent API; therefore, the change type is 5.","Despite the change to the dependent API, there is no indication that this would lead to a different behavior in terms of the current API method's output or thrown exceptions. The API call within showSession() is executed the same way, just with one fewer parameter. Assuming that the removal of the parameter does not affect the semantics of the showSession method (which we cannot determine from the given information), this change should not result in a compatibility issue. The handling of the IllegalStateException and RemoteException remains unchanged. Thus, there is no compatibility issue detected based on the information provided."
712,"<android.speech.tts.TextToSpeech: int playSilentUtterance(long,int,String)>",29,30,"<android.speech.tts.TextToSpeech: int playSilentUtterance(long,int,String)>","<android.speech.tts.TextToSpeech: int playSilentUtterance(long,int,String)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.playSilence(getCallerIdentity(), durationInMs, queueMode, utteranceId);
        }
    }, ERROR, ""playSilentUtterance"");
}","{
    return runAction((ITextToSpeechService service) -> {
        return service.playSilence(getCallerIdentity(), durationInMs, queueMode, utteranceId);
    }, ERROR, ""playSilentUtterance"");
}",1,"/**
 * Plays silence for the specified amount of time using the specified
 * queue mode.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param durationInMs The duration of the silence.
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param utteranceId An unique identifier for this request.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playSilentUtterance operation.
 */
","/**
 * Plays silence for the specified amount of time using the specified
 * queue mode.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param durationInMs The duration of the silence.
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param utteranceId An unique identifier for this request.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playSilentUtterance operation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only related to a switch from an anonymous inner class to a lambda expression. The main functional behavior of the method remains the same, so the code change type is 4.","This change does not lead to any compatibility issue because the lambda expression achieves the same result as the anonymous inner class it replaced; the API's contract remains unchanged. The return value is governed by the same underlying service call, and exception handling has not changed at all. Therefore, no CI can arise from this modification."
715,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,29,30,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,0,"{
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isEnabled();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    return getState() == BluetoothAdapter.STATE_ON;
}",1,"/**
 * Return true if Bluetooth is currently enabled and ready for use.
 * <p>Equivalent to:
 * <code>getBluetoothState() == STATE_ON</code>
 *
 * @return true if the local adapter is turned on
 */
","/**
 * Return true if Bluetooth is currently enabled and ready for use.
 * <p>Equivalent to:
 * <code>getBluetoothState() == STATE_ON</code>
 *
 * @return true if the local adapter is turned on
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method implementation has completely changed, moving away from an interaction with a service to directly checking a state. The old version was using a remote service call to determine if Bluetooth is enabled, while the new version checks the local state. Also, the locking mechanism was removed. Therefore, the change types are 1 for the return statement changed, 4 for other statements changed, and 5 for the dependent API changed, as it no longer uses mService.isEnabled() but getState() instead.","Since the implementation has changed from relying on a remote service's method to a local method getState(), and the return statement has changed to a different mechanism for determining if Bluetooth is enabled, it's very possible that the two versions could return different results under certain conditions (especially in cases where the remote service might not be in sync with the local BluetoothAdapter state). Thus, the CI type is 1 due to potential different return values."
716,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,29,30,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,0,"{
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService);
        }
    }
    return sBluetoothLeScanner;
}","{
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService, getOpPackageName(), getAttributionTag());
        }
    }
    return sBluetoothLeScanner;
}",1,"/**
 * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.
 */
","/**
 * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The constructor for BluetoothLeScanner has changed to include two additional parameters: getOpPackageName(), and getAttributionTag(). This change does not impact the return statement or exception handling. Hence, the change type is 4 for 'Other statement changed', and 5 for 'Dependent API changed'.","There is no Compatibility Issue because the change does not affect the returned value from this method directly. The return value is still sBluetoothLeScanner, which is of the same type. The additional information used in the constructor does not impact the method's signature or the return type."
718,"<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraMetadataNative createRequestTemplate(CameraCharacteristics,int)>",29,30,"<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraMetadataNative createRequestTemplate(CameraCharacteristics,int)>","<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraMetadataNative createRequestTemplate(CameraCharacteristics,int)>",0,"{
    if (!ArrayUtils.contains(sAllowedTemplates, templateId)) {
        throw new IllegalArgumentException(""templateId out of range"");
    }
    CameraMetadataNative m = new CameraMetadataNative();
    /*
         * NOTE: If adding new code here and it needs to query the static info,
         * query the camera characteristics, so we can reuse this for api2 code later
         * to create our own templates in the framework
         */
    /*
         * control.*
         */
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CameraMetadata.CONTROL_AWB_MODE_AUTO);
    // AWB is always unconditionally available in API1 devices
    // control.aeAntibandingMode
    m.set(CaptureRequest.CONTROL_AE_ANTIBANDING_MODE, CONTROL_AE_ANTIBANDING_MODE_AUTO);
    // control.aeExposureCompensation
    m.set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, 0);
    // control.aeLock
    m.set(CaptureRequest.CONTROL_AE_LOCK, false);
    // control.aePrecaptureTrigger
    m.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CONTROL_AE_PRECAPTURE_TRIGGER_IDLE);
    // control.afTrigger
    m.set(CaptureRequest.CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CONTROL_AWB_MODE_AUTO);
    // control.awbLock
    m.set(CaptureRequest.CONTROL_AWB_LOCK, false);
    // control.aeRegions, control.awbRegions, control.afRegions
    {
        Rect activeArray = c.get(SENSOR_INFO_ACTIVE_ARRAY_SIZE);
        MeteringRectangle[] activeRegions = new MeteringRectangle[] { new MeteringRectangle(/*x*/
        0, /*y*/
        0, /*width*/
        activeArray.width() - 1, /*height*/
        activeArray.height() - 1, /*weight*/
        0) };
        m.set(CaptureRequest.CONTROL_AE_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AWB_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AF_REGIONS, activeRegions);
    }
    // control.captureIntent
    {
        int captureIntent;
        switch(templateId) {
            case CameraDevice.TEMPLATE_PREVIEW:
                captureIntent = CONTROL_CAPTURE_INTENT_PREVIEW;
                break;
            case CameraDevice.TEMPLATE_STILL_CAPTURE:
                captureIntent = CONTROL_CAPTURE_INTENT_STILL_CAPTURE;
                break;
            case CameraDevice.TEMPLATE_RECORD:
                captureIntent = CONTROL_CAPTURE_INTENT_VIDEO_RECORD;
                break;
            default:
                // Can't get anything else since it's guarded by the IAE check
                throw new AssertionError(""Impossible; keep in sync with sAllowedTemplates"");
        }
        m.set(CaptureRequest.CONTROL_CAPTURE_INTENT, captureIntent);
    }
    // control.aeMode
    m.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);
    // AE is always unconditionally available in API1 devices
    // control.mode
    m.set(CaptureRequest.CONTROL_MODE, CONTROL_MODE_AUTO);
    // control.afMode
    {
        Float minimumFocusDistance = c.get(LENS_INFO_MINIMUM_FOCUS_DISTANCE);
        int afMode;
        if (minimumFocusDistance != null && minimumFocusDistance == LENS_INFO_MINIMUM_FOCUS_DISTANCE_FIXED_FOCUS) {
            // Cannot control auto-focus with fixed-focus cameras
            afMode = CameraMetadata.CONTROL_AF_MODE_OFF;
        } else {
            // If a minimum focus distance is reported; the camera must have AF
            afMode = CameraMetadata.CONTROL_AF_MODE_AUTO;
            if (templateId == CameraDevice.TEMPLATE_RECORD || templateId == CameraDevice.TEMPLATE_VIDEO_SNAPSHOT) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_VIDEO)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO;
                }
            } else if (templateId == CameraDevice.TEMPLATE_PREVIEW || templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_PICTURE)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
                }
            }
        }
        if (DEBUG) {
            Log.v(TAG, ""createRequestTemplate (templateId="" + templateId + ""),"" + "" afMode="" + afMode + "", minimumFocusDistance="" + minimumFocusDistance);
        }
        m.set(CaptureRequest.CONTROL_AF_MODE, afMode);
    }
    {
        // control.aeTargetFpsRange
        Range<Integer>[] availableFpsRange = c.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);
        // Pick FPS range with highest max value, tiebreak on higher min value
        Range<Integer> bestRange = availableFpsRange[0];
        for (Range<Integer> r : availableFpsRange) {
            if (bestRange.getUpper() < r.getUpper()) {
                bestRange = r;
            } else if (bestRange.getUpper() == r.getUpper() && bestRange.getLower() < r.getLower()) {
                bestRange = r;
            }
        }
        m.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, bestRange);
    }
    // control.sceneMode -- DISABLED is always available
    m.set(CaptureRequest.CONTROL_SCENE_MODE, CONTROL_SCENE_MODE_DISABLED);
    /*
         * statistics.*
         */
    // statistics.faceDetectMode
    m.set(CaptureRequest.STATISTICS_FACE_DETECT_MODE, STATISTICS_FACE_DETECT_MODE_OFF);
    /*
         * flash.*
         */
    // flash.mode
    m.set(CaptureRequest.FLASH_MODE, FLASH_MODE_OFF);
    /*
         * noiseReduction.*
         */
    if (templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
        m.set(CaptureRequest.NOISE_REDUCTION_MODE, NOISE_REDUCTION_MODE_HIGH_QUALITY);
    } else {
        m.set(CaptureRequest.NOISE_REDUCTION_MODE, NOISE_REDUCTION_MODE_FAST);
    }
    /*
        * colorCorrection.*
        */
    if (templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
        m.set(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE, COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY);
    } else {
        m.set(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE, COLOR_CORRECTION_ABERRATION_MODE_FAST);
    }
    /*
         * lens.*
         */
    // lens.focalLength
    m.set(CaptureRequest.LENS_FOCAL_LENGTH, c.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS)[0]);
    /*
         * jpeg.*
         */
    // jpeg.thumbnailSize - set smallest non-zero size if possible
    Size[] sizes = c.get(CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES);
    m.set(CaptureRequest.JPEG_THUMBNAIL_SIZE, (sizes.length > 1) ? sizes[1] : sizes[0]);
    // TODO: map other request template values
    return m;
}","{
    if (!ArrayUtils.contains(sAllowedTemplates, templateId)) {
        throw new IllegalArgumentException(""templateId out of range"");
    }
    CameraMetadataNative m = new CameraMetadataNative();
    /*
         * NOTE: If adding new code here and it needs to query the static info,
         * query the camera characteristics, so we can reuse this for api2 code later
         * to create our own templates in the framework
         */
    /*
         * control.*
         */
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CameraMetadata.CONTROL_AWB_MODE_AUTO);
    // AWB is always unconditionally available in API1 devices
    // control.aeAntibandingMode
    m.set(CaptureRequest.CONTROL_AE_ANTIBANDING_MODE, CONTROL_AE_ANTIBANDING_MODE_AUTO);
    // control.aeExposureCompensation
    m.set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, 0);
    // control.aeLock
    m.set(CaptureRequest.CONTROL_AE_LOCK, false);
    // control.aePrecaptureTrigger
    m.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CONTROL_AE_PRECAPTURE_TRIGGER_IDLE);
    // control.afTrigger
    m.set(CaptureRequest.CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CONTROL_AWB_MODE_AUTO);
    // control.awbLock
    m.set(CaptureRequest.CONTROL_AWB_LOCK, false);
    // control.aeRegions, control.awbRegions, control.afRegions
    {
        Rect activeArray = c.get(SENSOR_INFO_ACTIVE_ARRAY_SIZE);
        MeteringRectangle[] activeRegions = new MeteringRectangle[] { new MeteringRectangle(/*x*/
        0, /*y*/
        0, /*width*/
        activeArray.width() - 1, /*height*/
        activeArray.height() - 1, /*weight*/
        0) };
        m.set(CaptureRequest.CONTROL_AE_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AWB_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AF_REGIONS, activeRegions);
    }
    // control.captureIntent
    {
        int captureIntent;
        switch(templateId) {
            case CameraDevice.TEMPLATE_PREVIEW:
                captureIntent = CONTROL_CAPTURE_INTENT_PREVIEW;
                break;
            case CameraDevice.TEMPLATE_STILL_CAPTURE:
                captureIntent = CONTROL_CAPTURE_INTENT_STILL_CAPTURE;
                break;
            case CameraDevice.TEMPLATE_RECORD:
                captureIntent = CONTROL_CAPTURE_INTENT_VIDEO_RECORD;
                break;
            default:
                // Can't get anything else since it's guarded by the IAE check
                throw new AssertionError(""Impossible; keep in sync with sAllowedTemplates"");
        }
        m.set(CaptureRequest.CONTROL_CAPTURE_INTENT, captureIntent);
    }
    // control.aeMode
    m.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);
    // AE is always unconditionally available in API1 devices
    // control.mode
    m.set(CaptureRequest.CONTROL_MODE, CONTROL_MODE_AUTO);
    // control.afMode
    {
        Float minimumFocusDistance = c.get(LENS_INFO_MINIMUM_FOCUS_DISTANCE);
        int afMode;
        if (minimumFocusDistance != null && minimumFocusDistance == LENS_INFO_MINIMUM_FOCUS_DISTANCE_FIXED_FOCUS) {
            // Cannot control auto-focus with fixed-focus cameras
            afMode = CameraMetadata.CONTROL_AF_MODE_OFF;
        } else {
            // If a minimum focus distance is reported; the camera must have AF
            afMode = CameraMetadata.CONTROL_AF_MODE_AUTO;
            if (templateId == CameraDevice.TEMPLATE_RECORD || templateId == CameraDevice.TEMPLATE_VIDEO_SNAPSHOT) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_VIDEO)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO;
                }
            } else if (templateId == CameraDevice.TEMPLATE_PREVIEW || templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_PICTURE)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
                }
            }
        }
        if (DEBUG) {
            Log.v(TAG, ""createRequestTemplate (templateId="" + templateId + ""),"" + "" afMode="" + afMode + "", minimumFocusDistance="" + minimumFocusDistance);
        }
        m.set(CaptureRequest.CONTROL_AF_MODE, afMode);
    }
    {
        // control.aeTargetFpsRange
        Range<Integer>[] availableFpsRange = c.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);
        // Pick FPS range with highest max value, tiebreak on higher min value
        Range<Integer> bestRange = availableFpsRange[0];
        for (Range<Integer> r : availableFpsRange) {
            if (bestRange.getUpper() < r.getUpper()) {
                bestRange = r;
            } else if (bestRange.getUpper() == r.getUpper() && bestRange.getLower() < r.getLower()) {
                bestRange = r;
            }
        }
        m.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, bestRange);
    }
    // control.sceneMode -- DISABLED is always available
    m.set(CaptureRequest.CONTROL_SCENE_MODE, CONTROL_SCENE_MODE_DISABLED);
    // control.zoomRatio -- 1.0
    m.set(CaptureRequest.CONTROL_ZOOM_RATIO, 1.0f);
    /*
         * statistics.*
         */
    // statistics.faceDetectMode
    m.set(CaptureRequest.STATISTICS_FACE_DETECT_MODE, STATISTICS_FACE_DETECT_MODE_OFF);
    /*
         * flash.*
         */
    // flash.mode
    m.set(CaptureRequest.FLASH_MODE, FLASH_MODE_OFF);
    /*
         * noiseReduction.*
         */
    if (templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
        m.set(CaptureRequest.NOISE_REDUCTION_MODE, NOISE_REDUCTION_MODE_HIGH_QUALITY);
    } else {
        m.set(CaptureRequest.NOISE_REDUCTION_MODE, NOISE_REDUCTION_MODE_FAST);
    }
    /*
        * colorCorrection.*
        */
    if (templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
        m.set(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE, COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY);
    } else {
        m.set(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE, COLOR_CORRECTION_ABERRATION_MODE_FAST);
    }
    /*
         * lens.*
         */
    // lens.focalLength
    m.set(CaptureRequest.LENS_FOCAL_LENGTH, c.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS)[0]);
    /*
         * jpeg.*
         */
    // jpeg.thumbnailSize - set smallest non-zero size if possible
    Size[] sizes = c.get(CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES);
    m.set(CaptureRequest.JPEG_THUMBNAIL_SIZE, (sizes.length > 1) ? sizes[1] : sizes[0]);
    // TODO: map other request template values
    return m;
}",1,"/**
 * Create a request template
 *
 * @param c a non-{@code null} camera characteristics for this camera
 * @param templateId a non-negative template ID
 *
 * @return a non-{@code null} request template
 *
 * @throws IllegalArgumentException if {@code templateId} was invalid
 *
 * @see android.hardware.camera2.CameraDevice#TEMPLATE_MANUAL
 */
","/**
 * Create a request template
 *
 * @param c a non-{@code null} camera characteristics for this camera
 * @param templateId a non-negative template ID
 *
 * @return a non-{@code null} request template
 *
 * @throws IllegalArgumentException if {@code templateId} was invalid
 *
 * @see android.hardware.camera2.CameraDevice#TEMPLATE_MANUAL
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
719,<android.view.textclassifier.TextClassification.Builder: Builder addAction(RemoteAction)>,29,30,<android.view.textclassifier.TextClassification.Builder: Builder addAction(RemoteAction)>,<android.view.textclassifier.TextClassification.Builder: Builder addAction(RemoteAction)>,0,"{
    return addAction(action, null);
}","{
    Preconditions.checkArgument(action != null);
    mActions.add(action);
    return this;
}",1,"/**
 * Adds an action that may be performed on the classified text. Actions should be added in
 * order of likelihood that the user will use them, with the most likely action being added
 * first.
 */
","/**
 * Adds an action that may be performed on the classified text. Actions should be added in
 * order of likelihood that the user will use them, with the most likely action being added
 * first.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement changed to include an additional precondition check and a direct addition of the action into the mActions list instead of calling addAction(action, null). This is a change in the other statements (4) and dependent API changed (5) as the internal handling of the addAction is no longer delegated to another method and the implementation details have significantly changed, affecting the method's behavior.","The addition of Preconditions.checkArgument(action != null) introduces a potential new IllegalArgumentException if the action is null, and the change from calling addAction with two arguments to adding the action directly to mActions list indicates a shift in logic which could potentially lead to different return values (e.g., cases where the previous addAction implementation could handle null differently or perform additional logic). Therefore, the CI type is 1."
720,<android.app.Activity: void setTaskDescription(TaskDescription)>,29,30,<android.app.Activity: void setTaskDescription(TaskDescription)>,<android.app.Activity: void setTaskDescription(TaskDescription)>,0,"{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFromPreserveHiddenFields(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(icon);
        }
    }
    try {
        ActivityTaskManager.getService().setTaskDescription(mToken, mTaskDescription);
    } catch (RemoteException e) {
    }
}","{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFromPreserveHiddenFields(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(Icon.createWithBitmap(icon));
        }
    }
    try {
        ActivityTaskManager.getService().setTaskDescription(mToken, mTaskDescription);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
","/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The method call within the statement `mTaskDescription.setIcon(icon)` changed to `mTaskDescription.setIcon(Icon.createWithBitmap(icon))`. This is classified as an Other statement changed (4).,"This change does not inherently cause a compatibility issue, as it updates the icon within the existing `TaskDescription` object without altering the method's signature, return type, or exception handling. Thus, there's no Compatibility Issue (0)."
721,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor.InputMethodSessionImpl: void finishSession()>,29,30,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor.InputMethodSessionImpl: void finishSession()>,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor.InputMethodSessionImpl: void finishSession()>,0,"{
    synchronized (mSessionLock) {
        if (mCallbackImpl == null || mHandler == null) {
            return;
        }
        mSessionFinished.set(true);
        mHandler.sendMessage(PooledLambda.obtainMessage(CallbackImpl::finishSession, mCallbackImpl));
        mCallbackImpl = null;
        mHandler = null;
    }
}","{
    synchronized (mSessionLock) {
        if (mCallbackImpl == null || mHandler == null) {
            return;
        }
        mCancellationGroupOnFinishSession.cancelAll();
        mHandler.sendMessage(PooledLambda.obtainMessage(CallbackImpl::finishSession, mCallbackImpl));
        mCallbackImpl = null;
        mHandler = null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The addition of mCancellationGroupOnFinishSession.cancelAll(); constitutes an other statement change, so the code change type is 4.","Adding the call to mCancellationGroupOnFinishSession.cancelAll(); does not affect the method's return type nor does it introduce any new exceptions, and since the method return type is 'void', the behavior in terms of return type or thrown exceptions does not change. Thus, there is no Compatibility Issue, so the CI type is 0."
722,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,29,30,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,0,"{
    final int[] displayIds = mGlobal.getDisplayIds();
    synchronized (mLock) {
        try {
            if (category == null) {
                addAllDisplaysLocked(mTempDisplays, displayIds);
            } else if (category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_HDMI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}","{
    final int[] displayIds = mGlobal.getDisplayIds();
    synchronized (mLock) {
        try {
            if (category == null) {
                addAllDisplaysLocked(mTempDisplays, displayIds);
            } else if (category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_EXTERNAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}",1,"/**
 * Gets all currently valid logical displays of the specified category.
 * <p>
 * When there are multiple displays in a category the returned displays are sorted
 * of preference.  For example, if the requested category is
 * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays
 * then the displays are sorted so that the first display in the returned array
 * is the most preferred presentation display.  The application may simply
 * use the first display or allow the user to choose.
 * </p>
 *
 * @param category The requested display category or null to return all displays.
 * @return An array containing all displays sorted by order of preference.
 *
 * @see #DISPLAY_CATEGORY_PRESENTATION
 */
","/**
 * Gets all currently valid logical displays of the specified category.
 * <p>
 * When there are multiple displays in a category the returned displays are sorted
 * of preference.  For example, if the requested category is
 * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays
 * then the displays are sorted so that the first display in the returned array
 * is the most preferred presentation display.  The application may simply
 * use the first display or allow the user to choose.
 * </p>
 *
 * @param category The requested display category or null to return all displays.
 * @return An array containing all displays sorted by order of preference.
 *
 * @see #DISPLAY_CATEGORY_PRESENTATION
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"There is a change in the parameter type of ""addPresentationDisplaysLocked"" method call from Display.TYPE_HDMI to Display.TYPE_EXTERNAL, which is a dependent API change, so the code change type involves 4 and 5.","Since the method ""addPresentationDisplaysLocked"" is now called with a different parameter, it can result in a different set of displays being added to ""mTempDisplays"" if Display.TYPE_HDMI and Display.TYPE_EXTERNAL do not refer to the same value. This can lead to the API returning a different set of Display objects, hence the CI type is 1."
723,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,29,30,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    final int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            removeAllCallbacks();
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_UP:
            if (!mHasSelectorWheel) {
                break;
            }
            switch(event.getAction()) {
                case KeyEvent.ACTION_DOWN:
                    if (mWrapSelectorWheel || ((keyCode == KeyEvent.KEYCODE_DPAD_DOWN) ? getValue() < getMaxValue() : getValue() > getMinValue())) {
                        requestFocus();
                        mLastHandledDownDpadKeyCode = keyCode;
                        removeAllCallbacks();
                        if (mFlingScroller.isFinished()) {
                            changeValueByOne(keyCode == KeyEvent.KEYCODE_DPAD_DOWN);
                        }
                        return true;
                    }
                    break;
                case KeyEvent.ACTION_UP:
                    if (mLastHandledDownDpadKeyCode == keyCode) {
                        mLastHandledDownDpadKeyCode = -1;
                        return true;
                    }
                    break;
            }
    }
    return super.dispatchKeyEvent(event);
}","{
    final int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
        case KeyEvent.KEYCODE_NUMPAD_ENTER:
            removeAllCallbacks();
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_UP:
            if (!mHasSelectorWheel) {
                break;
            }
            switch(event.getAction()) {
                case KeyEvent.ACTION_DOWN:
                    if (mWrapSelectorWheel || ((keyCode == KeyEvent.KEYCODE_DPAD_DOWN) ? getValue() < getMaxValue() : getValue() > getMinValue())) {
                        requestFocus();
                        mLastHandledDownDpadKeyCode = keyCode;
                        removeAllCallbacks();
                        if (mFlingScroller.isFinished()) {
                            changeValueByOne(keyCode == KeyEvent.KEYCODE_DPAD_DOWN);
                        }
                        return true;
                    }
                    break;
                case KeyEvent.ACTION_UP:
                    if (mLastHandledDownDpadKeyCode == keyCode) {
                        mLastHandledDownDpadKeyCode = -1;
                        return true;
                    }
                    break;
            }
    }
    return super.dispatchKeyEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,The switch statement has been modified by adding a case (KeyEvent.KEYCODE_NUMPAD_ENTER) that handles an additional key event to those previously handled. This is classified under control dependency changes (3) since the logic of how keys are handled has changed.,"No Compatibility Issue is detected since the added case in the switch statement for KeyEvent.KEYCODE_NUMPAD_ENTER falls through to the same logic as KeyEvent.KEYCODE_DPAD_CENTER and KeyEvent.KEYCODE_ENTER. Therefore, the behavior of the method remains consistent with the previous version for all cases, and there is no change in return type/value or exception handling."
724,"<android.content.ContentProviderClient: Bundle call(String,String,String,Bundle)>",29,30,"<android.content.ContentProviderClient: Bundle call(String,String,String,Bundle)>","<android.content.ContentProviderClient: Bundle call(String,String,String,Bundle)>",0,"{
    Preconditions.checkNotNull(authority, ""authority"");
    Preconditions.checkNotNull(method, ""method"");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, authority, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(authority, ""authority"");
    Objects.requireNonNull(method, ""method"");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, mAttributionTag, authority, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
","/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",0,"There are changes in the method call within the 'try' block: mContentProvider.call now includes an additional parameter, mAttributionTag. Furthermore, Preconditions.checkNotNull has been replaced with Objects.requireNonNull. These changes indicate modifications in both the statements and dependent API; hence the change types are 4,5.","Despite these changes, they do not lead to different return values or exception handlings from the perspective of the client code. The Objects.requireNonNull serves the same purpose as Preconditions.checkNotNull, and the addition of the mAttributionTag parameter does not change the semantic of how exceptions are thrown or results are returned from this method. Therefore, there is no compatibility issue."
726,<android.app.ContextImpl: Context createContextForSplit(String)>,29,30,<android.app.ContextImpl: Context createContextForSplit(String)>,<android.app.ContextImpl: Context createContextForSplit(String)>,0,"{
    if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        // All Splits are always loaded.
        return this;
    }
    final ClassLoader classLoader = mPackageInfo.getSplitClassLoader(splitName);
    final String[] paths = mPackageInfo.getSplitPaths(splitName);
    final ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null);
    final int displayId = getDisplayId();
    context.setResources(ResourcesManager.getInstance().getResources(mActivityToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader));
    return context;
}","{
    if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        // All Splits are always loaded.
        return this;
    }
    final ClassLoader classLoader = mPackageInfo.getSplitClassLoader(splitName);
    final String[] paths = mPackageInfo.getSplitPaths(splitName);
    final ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null);
    final int displayId = getDisplayId();
    context.setResources(ResourcesManager.getInstance().getResources(mToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader, mResources.getLoaders()));
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Various parameters of constructors and method calls within the method have changed. This includes changing from 'mActivityToken' to 'mToken', the addition of 'mAttributionTag', and the addition of 'mResources.getLoaders()' in 'getResources' method call. Therefore, the code change types are 1 and 4.","Because the method now constructs 'ContextImpl' with a different set of parameters and also calls 'getResources' with an additional parameter, these changes can potentially result in different return values. The use of new parameters could reflect new internal states or operational logic that could influence the returned 'Context'. So the CI type is 1."
728,<android.hardware.radio.TunerCallbackAdapter: void onProgramListUpdated(Chunk)>,29,30,<android.hardware.radio.TunerCallbackAdapter: void onProgramListUpdated(Chunk)>,<android.hardware.radio.TunerCallbackAdapter: void onProgramListUpdated(Chunk)>,0,"{
    synchronized (mLock) {
        if (mProgramList == null)
            return;
        mProgramList.apply(Objects.requireNonNull(chunk));
    }
}","{
    mHandler.post(() -> {
        synchronized (mLock) {
            if (mProgramList == null)
                return;
            mProgramList.apply(Objects.requireNonNull(chunk));
        }
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change is the wrapping of the existing code within a new Lambda expression that is posted to mHandler. This is an asynchronous execution change, so the control flow is altered (type 3), and an 'Other statement changed' is also detected due to the introduction of the Lambda expression (type 4).",There is no Compatibility Issue because the change from synchronous to asynchronous execution does not alter the behavior of the API in terms of what it returns or the exceptions it throws. The returned value and exception handling remain the same; they are just being executed in a different thread context.
729,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,29,30,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,0,"{
    final Object[] cache = ctx.mServiceCache;
    final int[] gates = ctx.mServiceInitializationStateArray;
    for (; ; ) {
        boolean doInitialize = false;
        synchronized (cache) {
            // Return it if we already have a cached instance.
            T service = (T) cache[mCacheIndex];
            if (service != null || gates[mCacheIndex] == ContextImpl.STATE_NOT_FOUND) {
                return service;
            }
            // We start over from STATE_UNINITIALIZED.
            if (gates[mCacheIndex] == ContextImpl.STATE_READY) {
                gates[mCacheIndex] = ContextImpl.STATE_UNINITIALIZED;
            }
            // At this point, the gate must be either UNINITIALIZED or INITIALIZING.
            if (gates[mCacheIndex] == ContextImpl.STATE_UNINITIALIZED) {
                doInitialize = true;
                gates[mCacheIndex] = ContextImpl.STATE_INITIALIZING;
            }
        }
        if (doInitialize) {
            // Only the first thread gets here.
            T service = null;
            @ServiceInitializationState int newState = ContextImpl.STATE_NOT_FOUND;
            try {
                // This thread is the first one to get here. Instantiate the service
                // *without* the cache lock held.
                service = createService(ctx);
                newState = ContextImpl.STATE_READY;
            } catch (ServiceNotFoundException e) {
                onServiceNotFound(e);
            } finally {
                synchronized (cache) {
                    cache[mCacheIndex] = service;
                    gates[mCacheIndex] = newState;
                    cache.notifyAll();
                }
            }
            return service;
        }
        // and go back to the top and retry.
        synchronized (cache) {
            while (gates[mCacheIndex] < ContextImpl.STATE_READY) {
                try {
                    cache.wait();
                } catch (InterruptedException e) {
                    Log.w(TAG, ""getService() interrupted"");
                    Thread.currentThread().interrupt();
                    return null;
                }
            }
        }
    }
}","{
    final Object[] cache = ctx.mServiceCache;
    final int[] gates = ctx.mServiceInitializationStateArray;
    boolean interrupted = false;
    T ret = null;
    for (; ; ) {
        boolean doInitialize = false;
        synchronized (cache) {
            // Return it if we already have a cached instance.
            T service = (T) cache[mCacheIndex];
            if (service != null || gates[mCacheIndex] == ContextImpl.STATE_NOT_FOUND) {
                ret = service;
                // exit the for (;;)
                break;
            }
            // We start over from STATE_UNINITIALIZED.
            if (gates[mCacheIndex] == ContextImpl.STATE_READY) {
                gates[mCacheIndex] = ContextImpl.STATE_UNINITIALIZED;
            }
            // At this point, the gate must be either UNINITIALIZED or INITIALIZING.
            if (gates[mCacheIndex] == ContextImpl.STATE_UNINITIALIZED) {
                doInitialize = true;
                gates[mCacheIndex] = ContextImpl.STATE_INITIALIZING;
            }
        }
        if (doInitialize) {
            // Only the first thread gets here.
            T service = null;
            @ServiceInitializationState int newState = ContextImpl.STATE_NOT_FOUND;
            try {
                // This thread is the first one to get here. Instantiate the service
                // *without* the cache lock held.
                service = createService(ctx);
                newState = ContextImpl.STATE_READY;
            } catch (ServiceNotFoundException e) {
                onServiceNotFound(e);
            } finally {
                synchronized (cache) {
                    cache[mCacheIndex] = service;
                    gates[mCacheIndex] = newState;
                    cache.notifyAll();
                }
            }
            ret = service;
            // exit the for (;;)
            break;
        }
        // and go back to the top and retry.
        synchronized (cache) {
            // path, so we remember the interrupt state here and re-interrupt later.
            while (gates[mCacheIndex] < ContextImpl.STATE_READY) {
                try {
                    // Clear the interrupt state.
                    interrupted |= Thread.interrupted();
                    cache.wait();
                } catch (InterruptedException e) {
                    // This shouldn't normally happen, but if someone interrupts the
                    // thread, it will.
                    Slog.w(TAG, ""getService() interrupted"");
                    interrupted = true;
                }
            }
        }
    }
    if (interrupted) {
        Thread.currentThread().interrupt();
    }
    return ret;
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The change includes the introduction of new variables, a reshaping of the control flow, and changes in the exception handling logic. The loop has been altered with a break statement instead of immediately returning the service, and there is new logic to deal with thread interruption (`interrupted |= Thread.interrupted();` and checking `if (interrupted) { Thread.currentThread().interrupt(); }`). Also, the value to be returned is now stored in a separate variable `ret` instead of returning directly, so code change types are 1,3,4.","Given the logic has been modified to accumulate the interrupt status and only act on it after breaking out of the loop, this code change could cause a different exception handling behavior compared to the early version, where the thread could effectively ignore the interrupt and directly return null. Moreover, the refactored control flow now uses a `ret` variable and breaks from the loop to eventually return `ret`, which could lead to different return values under certain conditions due to this structural shift in handling the return value. There is a potential CI caused by the different return values or types (1) and different exception handling (2)."
730,<android.content.ContentProviderClient: String getType(Uri)>,29,30,<android.content.ContentProviderClient: String getType(Uri)>,<android.content.ContentProviderClient: String getType(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */
","/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the switching from Preconditions.checkNotNull(url, ""url"") to Objects.requireNonNull(url, ""url""), which are functionally equivalent but from different utility classes. This is classified as other statement changed.","There's no compatibility issue because both methods serve the same purpose of checking for null and throwing a NullPointerException if the passed argument is null, with the same message. Therefore, they are interchangeable and would not cause any change in behavior."
732,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,29,30,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,0,"{
    if (mService != null) {
        try {
            long deviceId = 0;
            /* TODO: plumb hardware id to FPMS */
            return mService.isHardwareDetected(deviceId, mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Slog.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.isHardwareDetected(mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Slog.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}",1,"/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_HW_UNAVAILABLE}
 */
","/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_HW_UNAVAILABLE}
 */
",-1,"[@Deprecated, @RequiresPermission(USE_FINGERPRINT), @Override]","[@Deprecated, @RequiresPermission(USE_FINGERPRINT), @Override]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within the try block has changed from mService.isHardwareDetected(deviceId, mContext.getOpPackageName()) to mService.isHardwareDetected(mContext.getOpPackageName()) and there is a removal of the variable deviceId which was an argument in the early version. This constitutes a dependency API change because the dependent method signature has changed and the return statement relies on that changed dependency, so the change type is 1,5.","The change in the dependent API call could potentially return different result, so there is a Compatibility Issue caused by potentially different return values or types, and the CI type is 1."
734,<android.view.MotionEvent: void setSource(int)>,29,30,<android.view.MotionEvent: void setSource(int)>,<android.view.MotionEvent: void setSource(int)>,0,"{
    nativeSetSource(mNativePtr, source);
}","{
    if (source == getSource()) {
        return;
    }
    nativeSetSource(mNativePtr, source);
    updateCursorPosition();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A new conditional check and early return statement have been introduced before the call to nativeSetSource. Moreover, there's an additional method call to updateCursorPosition(), so the code change types are 3 (control dependency changed) and 4 (other statement changed).","Although the new code version added a conditional check and a new method call, the changes do not lead to a Compatibility Issue in terms of different return values (it's a void method, so there is no return value) or different exception handlings (no exceptions are thrown or modified). Therefore, there is no CI as per the definitions provided."
735,<android.app.NotificationChannel: boolean equals(Object)>,29,30,<android.app.NotificationChannel: boolean equals(Object)>,<android.app.NotificationChannel: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannel that = (NotificationChannel) o;
    return getImportance() == that.getImportance() && mBypassDnd == that.mBypassDnd && getLockscreenVisibility() == that.getLockscreenVisibility() && mLights == that.mLights && getLightColor() == that.getLightColor() && getUserLockedFields() == that.getUserLockedFields() && isFgServiceShown() == that.isFgServiceShown() && mVibrationEnabled == that.mVibrationEnabled && mShowBadge == that.mShowBadge && isDeleted() == that.isDeleted() && isBlockableSystem() == that.isBlockableSystem() && mAllowBubbles == that.mAllowBubbles && Objects.equals(getId(), that.getId()) && Objects.equals(getName(), that.getName()) && Objects.equals(mDesc, that.mDesc) && Objects.equals(getSound(), that.getSound()) && Arrays.equals(mVibration, that.mVibration) && Objects.equals(getGroup(), that.getGroup()) && Objects.equals(getAudioAttributes(), that.getAudioAttributes()) && mImportanceLockedByOEM == that.mImportanceLockedByOEM && mImportanceLockedDefaultApp == that.mImportanceLockedDefaultApp;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannel that = (NotificationChannel) o;
    return getImportance() == that.getImportance() && mBypassDnd == that.mBypassDnd && getLockscreenVisibility() == that.getLockscreenVisibility() && mLights == that.mLights && getLightColor() == that.getLightColor() && getUserLockedFields() == that.getUserLockedFields() && isFgServiceShown() == that.isFgServiceShown() && mVibrationEnabled == that.mVibrationEnabled && mShowBadge == that.mShowBadge && isDeleted() == that.isDeleted() && isBlockable() == that.isBlockable() && mAllowBubbles == that.mAllowBubbles && Objects.equals(getId(), that.getId()) && Objects.equals(getName(), that.getName()) && Objects.equals(mDesc, that.mDesc) && Objects.equals(getSound(), that.getSound()) && Arrays.equals(mVibration, that.mVibration) && Objects.equals(getGroup(), that.getGroup()) && Objects.equals(getAudioAttributes(), that.getAudioAttributes()) && mImportanceLockedByOEM == that.mImportanceLockedByOEM && mImportanceLockedDefaultApp == that.mImportanceLockedDefaultApp && mOriginalImportance == that.mOriginalImportance && Objects.equals(getParentChannelId(), that.getParentChannelId()) && Objects.equals(getConversationId(), that.getConversationId()) && isDemoted() == that.isDemoted() && isImportantConversation() == that.isImportantConversation();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The `equals` method has new boolean conditions checking isBlockable(), isDemoted(), and isImportantConversation() against the 'that' object, as well as new Object comparison using `Objects.equals` for getParentChannelId() and getConversationId(). The method also checks mOriginalImportance against that.mOriginalImportance. There are included dependent API changes because the method now depends on the newly introduced API methods within the same class (isBlockable, isDemoted, isImportantConversation, getParentChannelId, getConversationId). This leads to a change in the return statement as the equality check has been expanded, and also a dependent API change because the implementation of the method now depends on new APIs of the same class. There were no changes in the exception handling or control dependencies, so the code change type is 1 (for the return statement change), 4 (other statement changed), and 5 (dependent API changed).","The equals method potentially returns a different value as now it includes additional conditions to evaluate object equality. This new set of equality checks can result in the method returning false where it would have previously returned true had the additional properties not matched, thus there is a potential Compatibility Issue due to different return values, so the CI type is 1."
737,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",29,30,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>","<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",0,"{
    checkLegacyRoutingApiAccess();
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy startUsingNetworkFeature for "" + networkType + "", "" + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, ""renewing startUsingNetworkFeature request "" + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, ""starting startUsingNetworkFeature for request "" + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, "" request Failed"");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}","{
    checkLegacyRoutingApiAccess();
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy startUsingNetworkFeature for "" + networkType + "", "" + feature);
        return DEPRECATED_PHONE_CONSTANT_APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, ""renewing startUsingNetworkFeature request "" + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return DEPRECATED_PHONE_CONSTANT_APN_ALREADY_ACTIVE;
            } else {
                return DEPRECATED_PHONE_CONSTANT_APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, ""starting startUsingNetworkFeature for request "" + request);
        return DEPRECATED_PHONE_CONSTANT_APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, "" request Failed"");
        return DEPRECATED_PHONE_CONSTANT_APN_REQUEST_FAILED;
    }
}",1,"/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} API.
 * In {@link VERSION_CODES#M}, and above, this method is unsupported and will
 * throw {@code UnsupportedOperationException} if called.
 * @removed
 */
","/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} API.
 * In {@link VERSION_CODES#M}, and above, this method is unsupported and will
 * throw {@code UnsupportedOperationException} if called.
 * @removed
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The change exists in the value that is returned; the return constants have been updated to new constant values which have been prefixed with `DEPRECATED_`. This change does not affect the return type, and the purpose of the constants is to indicate the same outcomes as the old ones. This is an example of renaming constants (Other statement changed), so the code change type is 4.","Since the renamed constants presumably represent the same outcomes as before the renaming, there should be no Compatibility Issue arising from this change. The return types have remained the same (int), and the semantics are expected to remain unchanged despite the new names for the constants. The renaming of the constants should not lead to different behavior as constants with `DEPRECATED_` prefix are likely to reflect the same values with a different naming to indicate their deprecated status. Therefore, the CI type is 0."
738,"<android.content.res.AssetManager: int getResourceArray(int,int[])>",29,30,"<android.content.res.AssetManager: int getResourceArray(int,int[])>","<android.content.res.AssetManager: int getResourceArray(int,int[])>",0,"{
    Preconditions.checkNotNull(outData, ""outData"");
    synchronized (this) {
        ensureValidLocked();
        return nativeGetResourceArray(mObject, resId, outData);
    }
}","{
    Objects.requireNonNull(outData, ""outData"");
    synchronized (this) {
        ensureValidLocked();
        return nativeGetResourceArray(mObject, resId, outData);
    }
}",1,"/**
 * Populates `outData` with array elements of `resId`. `outData` is normally
 * used with
 * {@link TypedArray}.
 *
 * Each logical element in `outData` is {@link TypedArray#STYLE_NUM_ENTRIES}
 * long,
 * with the indices of the data representing the type, value, asset cookie,
 * resource ID,
 * configuration change mask, and density of the element.
 *
 * @param resId The resource ID of an array resource.
 * @param outData The array to populate with data.
 * @return The length of the array.
 *
 * @see TypedArray#STYLE_TYPE
 * @see TypedArray#STYLE_DATA
 * @see TypedArray#STYLE_ASSET_COOKIE
 * @see TypedArray#STYLE_RESOURCE_ID
 * @see TypedArray#STYLE_CHANGING_CONFIGURATIONS
 * @see TypedArray#STYLE_DENSITY
 */
","/**
 * Populates `outData` with array elements of `resId`. `outData` is normally
 * used with
 * {@link TypedArray}.
 *
 * Each logical element in `outData` is {@link TypedArray#STYLE_NUM_ENTRIES}
 * long,
 * with the indices of the data representing the type, value, asset cookie,
 * resource ID,
 * configuration change mask, and density of the element.
 *
 * @param resId The resource ID of an array resource.
 * @param outData The array to populate with data.
 * @return The length of the array.
 *
 * @see TypedArray#STYLE_TYPE
 * @see TypedArray#STYLE_DATA
 * @see TypedArray#STYLE_ASSET_COOKIE
 * @see TypedArray#STYLE_RESOURCE_ID
 * @see TypedArray#STYLE_CHANGING_CONFIGURATIONS
 * @see TypedArray#STYLE_DENSITY
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement that checks for non-null array changed from Preconditions.checkNotNull(outData, ""outData"") to Objects.requireNonNull(outData, ""outData""). This change is only a change in the API used to perform the check; no functional change is introduced in how the non-null check behaves, so the code change type is 4.","There is no Compatibility Issue since both versions throw NullPointerException if 'outData' is null, and the rest of the code and logic remain unchanged. Hence, the behavior is the same across versions."
739,<android.view.autofill.AutofillManager: String getUserDataId()>,29,30,<android.view.autofill.AutofillManager: String getUserDataId()>,<android.view.autofill.AutofillManager: String getUserDataId()>,0,"{
    try {
        final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
        mService.getUserDataId(receiver);
        return receiver.getStringResult();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}","{
    try {
        final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
        mService.getUserDataId(receiver);
        return receiver.getStringResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get user data id for field classification."");
    }
}",1,"/**
 * Gets the id of the {@link UserData} used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p>This method is useful when the service must check the status of the {@link UserData} in
 * the device without fetching the whole object.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 *
 * @return id of the {@link UserData} previously set by {@link #setUserData(UserData)}
 * or {@code null} if it was reset or if the caller currently does not have an enabled autofill
 * service for the user.
 */
","/**
 * Gets the id of the {@link UserData} used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p>This method is useful when the service must check the status of the {@link UserData} in
 * the device without fetching the whole object.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 *
 * @return id of the {@link UserData} previously set by {@link #setUserData(UserData)}
 * or {@code null} if it was reset or if the caller currently does not have an enabled autofill
 * service for the user.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,2,2,"The change is in the exception handling statements where the catch block for SyncResultReceiver.TimeoutException has been added in the late version which throws a new RuntimeException. The previous catch block for RemoteException has also been modified from a combination of rethrow and return null to a simple throw statement. These are classified as an exception handling statement change hence, the code change type is 2.","The introduction of a new catch block for SyncResultReceiver.TimeoutException and the modification in the handling of RemoteException could potentially lead to different exception handlings. In the early version, RemoteException would cause a rethrow followed by a return null (since the rethrow does not actually exit the method), while in the late version, it results in a direct throw. And with the late version, a TimeoutException now results in a RuntimeException, a behavior that did not exist previously. Thus, there's a CI due to potentially different exception handlings which is type 2."
741,<android.net.Uri.OpaqueUri: Uri readFrom(Parcel)>,29,30,<android.net.Uri.OpaqueUri: Uri readFrom(Parcel)>,<android.net.Uri.OpaqueUri: Uri readFrom(Parcel)>,0,"{
    return new OpaqueUri(parcel.readString(), Part.readFrom(parcel), Part.readFrom(parcel));
}","{
    return new OpaqueUri(parcel.readString8(), Part.readFrom(parcel), Part.readFrom(parcel));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to read from the parcel has changed from readString() to readString8(), which is a different method call but does not directly influence the value returned by readFrom(). There is no structural change in the return statement or the data being read, thus the code change type is 5.","The change from parcel.readString() to parcel.readString8() is to accommodate a new way of reading strings from the Parcel that may have updated how strings are encoded or represented. However, since both methods are expected to return a string without changing the subsequent behavior of the API, there is no compatibility issue introduced by this change. Therefore, the CI type is 0."
742,"<android.view.SurfaceControl.Transaction: Transaction reparent(SurfaceControl,SurfaceControl)>",29,30,"<android.view.SurfaceControl.Transaction: Transaction reparent(SurfaceControl,SurfaceControl)>","<android.view.SurfaceControl.Transaction: Transaction reparent(SurfaceControl,SurfaceControl)>",0,"{
    sc.checkNotReleased();
    long otherObject = 0;
    if (newParent != null) {
        newParent.checkNotReleased();
        otherObject = newParent.mNativeObject;
    }
    nativeReparent(mNativeObject, sc.mNativeObject, otherObject);
    return this;
}","{
    checkPreconditions(sc);
    long otherObject = 0;
    if (newParent != null) {
        newParent.checkNotReleased();
        otherObject = newParent.mNativeObject;
    }
    nativeReparent(mNativeObject, sc.mNativeObject, otherObject);
    mReparentedSurfaces.put(sc, newParent);
    return this;
}",1,"/**
 * Re-parents a given layer to a new parent. Children inherit transform (position, scaling)
 * crop, visibility, and Z-ordering from their parents, as if the children were pixels within the
 * parent Surface.
 *
 * @param sc The SurfaceControl to reparent
 * @param newParent The new parent for the given control.
 * @return This Transaction
 */
","/**
 * Re-parents a given layer to a new parent. Children inherit transform (position, scaling)
 * crop, visibility, and Z-ordering from their parents, as if the children were pixels within the
 * parent Surface.
 *
 * @param sc The SurfaceControl to reparent
 * @param newParent The new parent for the given control.
 * @return This Transaction
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"There are new method invocations and modifications in the control flow, particularly `checkPreconditions(sc)` calling instead of `sc.checkNotReleased()`, and addition of `mReparentedSurfaces.put(sc, newParent)`. The code change type is 3 (Control dependency changed) due to the new precondition check replacing the old method, and 4 (Other statement changed) due to adding `mReparentedSurfaces.put(sc, newParent)`.","Despite the changes, there is no Compatibility Issue with respect to behavior, as the primary functionality of the API—reparenting the surface—remains the same. The changes don't affect the return values or the exceptions thrown directly; they are more likely about internal state management, which from an API caller's perspective does not change the expected result. Thus, there is No Compatibility Issue (0)."
743,<android.view.SurfaceControl.Builder: SurfaceControl build()>,29,30,<android.view.SurfaceControl.Builder: SurfaceControl build()>,<android.view.SurfaceControl.Builder: SurfaceControl build()>,0,"{
    if (mWidth < 0 || mHeight < 0) {
        throw new IllegalStateException(""width and height must be positive or unset"");
    }
    if ((mWidth > 0 || mHeight > 0) && (isColorLayerSet() || isContainerLayerSet())) {
        throw new IllegalStateException(""Only buffer layers can set a valid buffer size."");
    }
    return new SurfaceControl(mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata);
}","{
    if (mWidth < 0 || mHeight < 0) {
        throw new IllegalStateException(""width and height must be positive or unset"");
    }
    if ((mWidth > 0 || mHeight > 0) && (isEffectLayer() || isContainerLayer())) {
        throw new IllegalStateException(""Only buffer layers can set a valid buffer size."");
    }
    return new SurfaceControl(mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata, mLocalOwnerView, mCallsite);
}",1,"/**
 * Construct a new {@link SurfaceControl} with the set parameters. The builder
 * remains valid.
 */
","/**
 * Construct a new {@link SurfaceControl} with the set parameters. The builder
 * remains valid.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement now includes two additional parameters: mLocalOwnerView and mCallsite. There are also function name changes from isColorLayerSet() to isEffectLayer() which indicates a change in the dependent API, and the addition of parameters could potentially change the type of the returned object. The code change type is 1,4,5.","Since new parameters have been added to the constructor of the returned SurfaceControl object, and the dependent API names have changed, this could possibly lead to a change in the return value or the behavior of the API. Hence, the CI type is 1."
744,<android.permission.PermissionManager.SplitPermissionInfo: boolean equals(Object)>,29,30,<android.permission.PermissionManager.SplitPermissionInfo: boolean equals(Object)>,<android.permission.PermissionManager.SplitPermissionInfo: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    SplitPermissionInfo that = (SplitPermissionInfo) o;
    return mTargetSdk == that.mTargetSdk && mSplitPerm.equals(that.mSplitPerm) && mNewPerms.equals(that.mNewPerms);
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    SplitPermissionInfo that = (SplitPermissionInfo) o;
    return mSplitPermissionInfoParcelable.equals(that.mSplitPermissionInfoParcelable);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The methods used to determine equality, 'mTargetSdk == that.mTargetSdk && mSplitPerm.equals(that.mSplitPerm) && mNewPerms.equals(that.mNewPerms)' have been replaced with 'mSplitPermissionInfoParcelable.equals(that.mSplitPermissionInfoParcelable)', which indicates that the fields being checked for equality have been changed. Therefore, the return statement has been changed, so the code change type is 1.","Because the implementation for determining object equality has changed, objects that were considered equal in the early version may not be equal in the late version, and vice versa. Thus, this can lead to different results when the method is called, which qualifies as a compatibility issue due to potentially different returned values. The CI type is 1."
746,<android.speech.tts.TextToSpeech: Locale getLanguage()>,29,30,<android.speech.tts.TextToSpeech: Locale getLanguage()>,<android.speech.tts.TextToSpeech: Locale getLanguage()>,0,"{
    return runAction(new Action<Locale>() {

        @Override
        public Locale run(ITextToSpeechService service) {
            /* No service call, but we're accessing mParams, hence need for
                   wrapping it as an Action instance */
            String lang = mParams.getString(Engine.KEY_PARAM_LANGUAGE, """");
            String country = mParams.getString(Engine.KEY_PARAM_COUNTRY, """");
            String variant = mParams.getString(Engine.KEY_PARAM_VARIANT, """");
            return new Locale(lang, country, variant);
        }
    }, null, ""getLanguage"");
}","{
    return runAction((ITextToSpeechService service) -> {
        /* No service call, but we're accessing mParams, hence need for
               wrapping it as an Action instance */
        String lang = mParams.getString(Engine.KEY_PARAM_LANGUAGE, """");
        String country = mParams.getString(Engine.KEY_PARAM_COUNTRY, """");
        String variant = mParams.getString(Engine.KEY_PARAM_VARIANT, """");
        return new Locale(lang, country, variant);
    }, null, ""getLanguage"");
}",1,"/**
 * Returns a Locale instance describing the language currently being used for synthesis
 * requests sent to the TextToSpeech engine.
 *
 * In Android 4.2 and before (API <= 17) this function returns the language that is currently
 * being used by the TTS engine. That is the last language set by this or any other
 * client by a {@link TextToSpeech#setLanguage} call to the same engine.
 *
 * In Android versions after 4.2 this function returns the language that is currently being
 * used for the synthesis requests sent from this client. That is the last language set
 * by a {@link TextToSpeech#setLanguage} call on this instance.
 *
 * If a voice is set (by {@link #setVoice(Voice)}), getLanguage will return the language of
 * the currently set voice.
 *
 * Please note that the Locale object returned by this method is NOT a valid Locale object. Its
 * language field contains a three-letter ISO 639-2/T code (where a proper Locale would use
 * a two-letter ISO 639-1 code), and the country field contains a three-letter ISO 3166 country
 * code (where a proper Locale would use a two-letter ISO 3166-1 code).
 *
 * @return language, country (if any) and variant (if any) used by the client stored in a
 * Locale instance, or {@code null} on error.
 *
 * @deprecated As of API level 21, please use <code>getVoice().getLocale()</code>
 * ({@link #getVoice()}).
 */
","/**
 * Returns a Locale instance describing the language currently being used for synthesis
 * requests sent to the TextToSpeech engine.
 *
 * In Android 4.2 and before (API <= 17) this function returns the language that is currently
 * being used by the TTS engine. That is the last language set by this or any other
 * client by a {@link TextToSpeech#setLanguage} call to the same engine.
 *
 * In Android versions after 4.2 this function returns the language that is currently being
 * used for the synthesis requests sent from this client. That is the last language set
 * by a {@link TextToSpeech#setLanguage} call on this instance.
 *
 * If a voice is set (by {@link #setVoice(Voice)}), getLanguage will return the language of
 * the currently set voice.
 *
 * Please note that the Locale object returned by this method is NOT a valid Locale object. Its
 * language field contains a three-letter ISO 639-2/T code (where a proper Locale would use
 * a two-letter ISO 639-1 code), and the country field contains a three-letter ISO 3166 country
 * code (where a proper Locale would use a two-letter ISO 3166-1 code).
 *
 * @return language, country (if any) and variant (if any) used by the client stored in a
 * Locale instance, or {@code null} on error.
 *
 * @deprecated As of API level 21, please use <code>getVoice().getLocale()</code>
 * ({@link #getVoice()}).
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,0,0,The implementation of the method has changed from an anonymous inner class to a lambda expression. Both the inner class and lambda carry out the same operation and therefore there is no functional change to the implementation.,There is no Compatibility Issue as the behaviour of the method does not change. The lambda expression is functionally equivalent to the previously used anonymous inner class.
747,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",29,30,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}","{
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.PBAP:
            BluetoothPbap pbap = (BluetoothPbap) proxy;
            pbap.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
748,<android.view.WindowInsets: Insets getSystemWindowInsets()>,29,30,<android.view.WindowInsets: Insets getSystemWindowInsets()>,<android.view.WindowInsets: Insets getSystemWindowInsets()>,0,"{
    return getInsets(mTypeInsetsMap, compatSystemInsets());
}","{
    Insets result = mCompatIgnoreVisibility ? getInsetsIgnoringVisibility(mCompatInsetsTypes & ~ime()) : getInsets(mCompatInsetsTypes);
    // We can't query max insets for IME, so we need to add it manually after.
    if ((mCompatInsetsTypes & ime()) != 0 && mCompatIgnoreVisibility) {
        result = Insets.max(result, getInsets(ime()));
    }
    return result;
}",1,"/**
 * Returns the system window insets in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The system window insets
 */
","/**
 * Returns the system window insets in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The system window insets
 * @deprecated Use {@link #getInsets(int)} with {@link Type#systemBars()}
 * instead.
 */
",-1,[@NonNull],"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"1,3,5",1,"The implementation of the method has changed significantly. New statements have been introduced which includes new operands, and different methods are called in the 'return' part. Moreover, the late version's implementation includes additional control flow for calculating insets with a different logic when 'mCompatIgnoreVisibility' is true. There is a change in a dependent API, as the implementation relies on different methods (e.g., `getInsetsIgnoringVisibility`, `getInsets`, `max`) than the early version. Thus, the types of code changes are 1, 3, and 5.","Due to the changes in return statements associated with altered logic and dependent API changes (methods involved in returning the final insets), it's likely that the new implementation may return different `Insets` results compared to the old one under certain conditions. Therefore, this is a CI caused by potential different return values or types, and the CI type is 1."
749,<android.app.UiModeManager: void disableCarMode(int)>,29,30,<android.app.UiModeManager: void disableCarMode(int)>,<android.app.UiModeManager: void disableCarMode(int)>,0,"{
    if (mService != null) {
        try {
            mService.disableCarMode(flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    if (mService != null) {
        try {
            mService.disableCarModeByCallingPackage(flags, mContext == null ? null : mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Turn off special mode if currently in car mode.
 * @param flags May be 0 or {@link #DISABLE_CAR_MODE_GO_HOME}.
 */
","/**
 * Turn off special mode if currently in car mode.
 * @param flags One of the disable car mode flags.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called inside the try block has changed from mService.disableCarMode(flags) to mService.disableCarModeByCallingPackage(flags, mContext == null ? null : mContext.getOpPackageName()), this is a change in the dependent API being called, so the code change type is 5.","Even though there is a change in the dependent API, the method's return type is 'void' and does not have any return statements that could return different values, nor does the exception handling statements change. Hence, this code change does not constitute a compatibility issue relating to return values/types or exception handlings. Therefore, the API does not have any compatibility issue, so the CI type is 0."
750,<android.app.Activity: boolean isTaskRoot()>,29,30,<android.app.Activity: boolean isTaskRoot()>,<android.app.Activity: boolean isTaskRoot()>,0,"{
    try {
        return ActivityTaskManager.getService().getTaskForActivity(mToken, true) >= 0;
    } catch (RemoteException e) {
        return false;
    }
}","{
    return mWindowControllerCallback.isTaskRoot();
}",1,"/**
 * Return whether this activity is the root of a task.  The root is the
 * first activity in a task.
 *
 * @return True if this is the root activity, else false.
 */
","/**
 * Return whether this activity is the root of a task.  The root is the
 * first activity in a task.
 *
 * @return True if this is the root activity, else false.
 */
",-1,[@Override],,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has completely changed, it no longer tries to get the result from the ActivityTaskManager service, but now directly calls mWindowControllerCallback.isTaskRoot(). This is a significant change in the dependent API called within the method, hence it is categorized as types 1 (since the return statement is changed) and 5 (since there's a dependent API change).","Given that the implementation of the method now relies on a different mechanism to determine if the activity is the root of a task (via mWindowControllerCallback.isTaskRoot() instead of ActivityTaskManager.getService().getTaskForActivity(mToken, true) >= 0), it can potentially return a different value than before. Therefore, it is classified as type 1 for compatibility issues."
751,<android.util.AtomicFile: void failWrite(FileOutputStream)>,29,30,<android.util.AtomicFile: void failWrite(FileOutputStream)>,<android.util.AtomicFile: void failWrite(FileOutputStream)>,0,"{
    if (str != null) {
        FileUtils.sync(str);
        try {
            str.close();
            mBaseName.delete();
            mBackupName.renameTo(mBaseName);
        } catch (IOException e) {
            Log.w(""AtomicFile"", ""failWrite: Got exception:"", e);
        }
    }
}","{
    if (str == null) {
        return;
    }
    if (!FileUtils.sync(str)) {
        Log.e(LOG_TAG, ""Failed to sync file output stream"");
    }
    try {
        str.close();
    } catch (IOException e) {
        Log.e(LOG_TAG, ""Failed to close file output stream"", e);
    }
    if (!mNewName.delete()) {
        Log.e(LOG_TAG, ""Failed to delete new file "" + mNewName);
    }
}",1,"/**
 * Call when you have failed for some reason at writing to the stream
 * returned by {@link #startWrite()}.  This will close the current
 * write stream, and roll back to the previous state of the file.
 */
","/**
 * Call when you have failed for some reason at writing to the stream
 * returned by {@link #startWrite()}.  This will close the current
 * write stream, and delete the new file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,There are several changes in the code structure: ,"- The closing of ""str"" is wrapped in a try-catch block without additional renaming and deleting operations, which is a return statement changed (1). "
752,<android.view.Display: int getRotation()>,29,30,<android.view.Display: int getRotation()>,<android.view.Display: int getRotation()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.rotation;
    }
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mMayAdjustByFixedRotation ? getDisplayAdjustments().getRotation(mDisplayInfo.rotation) : mDisplayInfo.rotation;
    }
}",1,"/**
 * Returns the rotation of the screen from its ""natural"" orientation.
 * The returned value may be {@link Surface#ROTATION_0 Surface.ROTATION_0}
 * (no rotation), {@link Surface#ROTATION_90 Surface.ROTATION_90},
 * {@link Surface#ROTATION_180 Surface.ROTATION_180}, or
 * {@link Surface#ROTATION_270 Surface.ROTATION_270}.  For
 * example, if a device has a naturally tall screen, and the user has
 * turned it on its side to go into a landscape orientation, the value
 * returned here may be either {@link Surface#ROTATION_90 Surface.ROTATION_90}
 * or {@link Surface#ROTATION_270 Surface.ROTATION_270} depending on
 * the direction it was turned.  The angle is the rotation of the drawn
 * graphics on the screen, which is the opposite direction of the physical
 * rotation of the device.  For example, if the device is rotated 90
 * degrees counter-clockwise, to compensate rendering will be rotated by
 * 90 degrees clockwise and thus the returned value here will be
 * {@link Surface#ROTATION_90 Surface.ROTATION_90}.
 */
","/**
 * Returns the rotation of the screen from its ""natural"" orientation.
 * The returned value may be {@link Surface#ROTATION_0 Surface.ROTATION_0}
 * (no rotation), {@link Surface#ROTATION_90 Surface.ROTATION_90},
 * {@link Surface#ROTATION_180 Surface.ROTATION_180}, or
 * {@link Surface#ROTATION_270 Surface.ROTATION_270}.  For
 * example, if a device has a naturally tall screen, and the user has
 * turned it on its side to go into a landscape orientation, the value
 * returned here may be either {@link Surface#ROTATION_90 Surface.ROTATION_90}
 * or {@link Surface#ROTATION_270 Surface.ROTATION_270} depending on
 * the direction it was turned.  The angle is the rotation of the drawn
 * graphics on the screen, which is the opposite direction of the physical
 * rotation of the device.  For example, if the device is rotated 90
 * degrees counter-clockwise, to compensate rendering will be rotated by
 * 90 degrees clockwise and thus the returned value here will be
 * {@link Surface#ROTATION_90 Surface.ROTATION_90}.
 */
",-1,[@Surface.Rotation],[@Surface.Rotation],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The late implementation version adds a new condition (mMayAdjustByFixedRotation) and a new method call (getDisplayAdjustments().getRotation(mDisplayInfo.rotation)) inside the return statement if the condition is true. This constitutes a control dependency change (3), an other statement change (4), and a dependent API change (5).","The addition of a conditional return statement (using the ternary operator?) means that there is a new behavior depending on the value of 'mMayAdjustByFixedRotation', and a potential different method is called ('getDisplayAdjustments().getRotation()'), resulting in possible different return values. Therefore, a Compatibility Issue due to potential different return values is present, which is type 1."
753,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,29,30,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = mContext.getSystemService(InputMethodManager.class);
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(mTag, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                // The IME could not handle it, so skip along to the next InputStage
                return FORWARD;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}","{
    final int result = mImeFocusController.onProcessImeInputStage(q, q.mEvent, mWindowAttributes, this);
    switch(result) {
        case InputMethodManager.DISPATCH_IN_PROGRESS:
            // callback will be invoked later
            return DEFER;
        case InputMethodManager.DISPATCH_NOT_HANDLED:
            // The IME could not handle it, so skip along to the next InputStage
            return FORWARD;
        case InputMethodManager.DISPATCH_HANDLED:
            return FINISH_HANDLED;
        default:
            throw new IllegalStateException(""Unexpected result="" + result);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The implementation has changed significantly from direct calls to InputMethodManager to delegating the processing to mImeFocusController with a different method signature. The early version includes additional conditions and variable declarations not present in the late version. We observe changes in the control flow, with the condition 'if (mLastWasImTarget && !isInLocalFocusMode())' being removed, the removal of variables such as 'InputMethodManager imm' and 'final InputEvent event', as well as a direct mapping from 'imm.dispatchInputEvent' result to 'onProcessImeInputStage' result. Exception handling logic was also introduced with throwing IllegalStateException, which was not there in the early version. Therefore, there is a change in exception handling statements, control dependency changes, other statements changed, and dependent API change, so the code change type is 1,3,4,5.","Due to the significant refactoring of the method's implementation, including changes to control flow, the removal of checks, and delegation to another method (mImeFocusController.onProcessImeInputStage), this could result in different return values or types for the same inputs, which leads to a CI type of 1. Also, there's the introduction of a new throw statement that didn't exist in the early version, causing a CI due to the potential for different exceptions being thrown, leading to a CI type of 2."
754,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>",29,30,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method used within the try block has changed from `ActivityManager.getService().broadcastIntent` to `ActivityManager.getService().broadcastIntentWithFeature`, including an additional argument `getAttributionTag()`. This indicates a change to a dependent API, so the code change type is 5.","There is no Compatibility Issue detected because the method signature is unchanged, and the added argument `getAttributionTag()` is retrieved from within the method itself. The method `broadcastIntentWithFeature` is expected to be a drop-in replacement for `broadcastIntent`, with the additional argument providing context but not changing the method's behavior in a way that would cause a previous client of the API to encounter an error or different behavior. Thus, the differences in internal implementation do not lead to different return values or exceptions for the client code using this API, and it does not affect the exception handling as well. Therefore, the CI type is 0."
756,<android.gesture.GestureLibraries.FileGestureLibrary: boolean isReadOnly()>,29,30,<android.gesture.GestureLibraries.FileGestureLibrary: boolean isReadOnly()>,<android.gesture.GestureLibraries.FileGestureLibrary: boolean isReadOnly()>,0,"{
    return !mPath.canWrite();
}","{
    if (mPath != null) {
        return !mPath.canWrite();
    }
    return false;
}",1,,"/**
 * <p>If this GestureLibrary was created using a FileDescriptor,
 * this method will always return false.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The change includes the introduction of a control dependency, specifically a new 'if' condition that checks whether mPath is not null. This represents a control dependency change, so the code change type is 3.","With the addition of the 'if' statement, the API could potentially return different values. In the early version, if `mPath` were null, there might have been a `NullPointerException`, whereas in the late version, it will return `false`. Hence, the behavior of the API can potentially change, which implies a CI of type 1."
757,<android.service.textclassifier.TextClassifierService.ProxyCallback: void onFailure(CharSequence)>,29,30,<android.service.textclassifier.TextClassifierService.ProxyCallback: void onFailure(CharSequence)>,<android.service.textclassifier.TextClassifierService.ProxyCallback: void onFailure(CharSequence)>,0,"{
    ITextClassifierCallback callback = mTextClassifierCallback.get();
    if (callback == null) {
        return;
    }
    try {
        callback.onFailure();
    } catch (RemoteException e) {
        Slog.d(LOG_TAG, ""Error calling callback"");
    }
}","{
    try {
        Slog.w(LOG_TAG, ""Request fail: "" + error);
        mTextClassifierCallback.onFailure();
    } catch (RemoteException e) {
        Slog.d(LOG_TAG, ""Error calling callback"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has been inverted as the condition checking if the callback is null has been removed. Additionally, a new logging statement is introduced within the `try` block, which represents another statement change, so the change type is 3,4.","Although there is a change in the control structure and new logging is added, there are no changes to the return values or the exceptions being thrown by the API. The logging changes do not affect the API's external behavior in terms of what it returns or the exceptions it might throw, which is why there is no Compatibility Issue."
758,<android.net.UrlQuerySanitizer.IllegalCharacterValueSanitizer: String sanitize(String)>,29,30,<android.net.UrlQuerySanitizer.IllegalCharacterValueSanitizer: String sanitize(String)>,<android.net.UrlQuerySanitizer.IllegalCharacterValueSanitizer: String sanitize(String)>,0,"{
    if (value == null) {
        return null;
    }
    int length = value.length();
    if ((mFlags & SCRIPT_URL_OK) != 0) {
        if (length >= MIN_SCRIPT_PREFIX_LENGTH) {
            String asLower = value.toLowerCase(Locale.ROOT);
            if (asLower.startsWith(JAVASCRIPT_PREFIX) || asLower.startsWith(VBSCRIPT_PREFIX)) {
                return """";
            }
        }
    }
    // and end of value.
    if ((mFlags & ALL_WHITESPACE_OK) == 0) {
        value = trimWhitespace(value);
        // The length could have changed, so we need to correct
        // the length variable.
        length = value.length();
    }
    StringBuilder stringBuilder = new StringBuilder(length);
    for (int i = 0; i < length; i++) {
        char c = value.charAt(i);
        if (!characterIsLegal(c)) {
            if ((mFlags & SPACE_OK) != 0) {
                c = ' ';
            } else {
                c = '_';
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}","{
    if (value == null) {
        return null;
    }
    int length = value.length();
    if ((mFlags & SCRIPT_URL_OK) == 0) {
        if (length >= MIN_SCRIPT_PREFIX_LENGTH) {
            String asLower = value.toLowerCase(Locale.ROOT);
            if (asLower.startsWith(JAVASCRIPT_PREFIX) || asLower.startsWith(VBSCRIPT_PREFIX)) {
                return """";
            }
        }
    }
    // and end of value.
    if ((mFlags & ALL_WHITESPACE_OK) == 0) {
        value = trimWhitespace(value);
        // The length could have changed, so we need to correct
        // the length variable.
        length = value.length();
    }
    StringBuilder stringBuilder = new StringBuilder(length);
    for (int i = 0; i < length; i++) {
        char c = value.charAt(i);
        if (!characterIsLegal(c)) {
            if ((mFlags & SPACE_OK) != 0) {
                c = ' ';
            } else {
                c = '_';
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}",1,"/**
 * Sanitize a value.
 * <ol>
 * <li>If script URLs are not OK, they will be removed.
 * <li>If neither spaces nor other white space is OK, then
 * white space will be trimmed from the beginning and end of
 * the URL. (Just the actual white space characters are trimmed, not
 * other control codes.)
 * <li> Illegal characters will be replaced with
 * either ' ' or '_', depending on whether a space is itself a
 * legal character.
 * </ol>
 * @param value
 * @return the sanitized value
 */
","/**
 * Sanitize a value.
 * <ol>
 * <li>If script URLs are not OK, they will be removed.
 * <li>If neither spaces nor other white space is OK, then
 * white space will be trimmed from the beginning and end of
 * the URL. (Just the actual white space characters are trimmed, not
 * other control codes.)
 * <li> Illegal characters will be replaced with
 * either ' ' or '_', depending on whether a space is itself a
 * legal character.
 * </ol>
 * @param value
 * @return the sanitized value
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency has changed due to the change in the condition `if ((mFlags & SCRIPT_URL_OK) != 0)` to `if ((mFlags & SCRIPT_URL_OK) == 0)`, so the code change type is 3.","The change in control condition significantly alters when certain blocks of code would execute. The condition that triggers the sanitization of script URLs has been inverted, which means that the method could potentially return different results for the same input. This meets the criteria for a compatibility issue of type 1, as the API potentially returns a different value."
759,<android.service.voice.AlwaysOnHotwordDetector: Intent createEnrollIntent()>,29,30,<android.service.voice.AlwaysOnHotwordDetector: Intent createEnrollIntent()>,<android.service.voice.AlwaysOnHotwordDetector: Intent createEnrollIntent()>,0,"{
    if (DBG)
        Slog.d(TAG, ""createEnrollIntent"");
    synchronized (mLock) {
        return getManageIntentLocked(MANAGE_ACTION_ENROLL);
    }
}","{
    if (DBG)
        Slog.d(TAG, ""createEnrollIntent"");
    synchronized (mLock) {
        return getManageIntentLocked(KeyphraseEnrollmentInfo.MANAGE_ACTION_ENROLL);
    }
}",1,"/**
 * Creates an intent to start the enrollment for the associated keyphrase.
 * This intent must be invoked using {@link Activity#startActivityForResult(Intent, int)}.
 * Starting re-enrollment is only valid if the keyphrase is un-enrolled,
 * i.e. {@link #STATE_KEYPHRASE_UNENROLLED},
 * otherwise {@link #createReEnrollIntent()} should be preferred.
 *
 * @return An {@link Intent} to start enrollment for the given keyphrase.
 * @throws UnsupportedOperationException if managing they keyphrase isn't supported.
 * Callers should only call this method after a supported state callback on
 * {@link Callback#onAvailabilityChanged(int)} to avoid this exception.
 * @throws IllegalStateException if the detector is in an invalid state.
 * This may happen if another detector has been instantiated or the
 * {@link VoiceInteractionService} hosting this detector has been shut down.
 */
","/**
 * Creates an intent to start the enrollment for the associated keyphrase.
 * This intent must be invoked using {@link Context#startForegroundService(Intent)}.
 * Starting re-enrollment is only valid if the keyphrase is un-enrolled,
 * i.e. {@link #STATE_KEYPHRASE_UNENROLLED},
 * otherwise {@link #createReEnrollIntent()} should be preferred.
 *
 * @return An {@link Intent} to start enrollment for the given keyphrase.
 * @throws UnsupportedOperationException if managing they keyphrase isn't supported.
 * Callers should only call this method after a supported state callback on
 * {@link Callback#onAvailabilityChanged(int)} to avoid this exception.
 * @throws IllegalStateException if the detector is in an invalid state.
 * This may happen if another detector has been instantiated or the
 * {@link VoiceInteractionService} hosting this detector has been shut down.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The parameter of getManageIntentLocked() method has been changed from a direct value (MANAGE_ACTION_ENROLL) to a value from another class (KeyphraseEnrollmentInfo.MANAGE_ACTION_ENROLL). This indicates that there is a change in the dependent API, so the code change type is 5.","The change is insubstantial in terms of functional behavior; it's merely referencing the same constant value from a different class. This does not constitute a behavior change in the method itself, hence there is no Compatibility Issue. The method should continue to behave the same way as long as the KeyphraseEnrollmentInfo.MANAGE_ACTION_ENROLL contains the same value as MANAGE_ACTION_ENROLL."
762,"<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>",29,30,"<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>","<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>",0,"{
    final TextView textView = editor.getTextView();
    if (isSelectionStarted() && mAllowReset && textIndex >= mSelectionStart && textIndex <= mSelectionEnd && getText(textView) instanceof Spannable) {
        mAllowReset = false;
        boolean selected = editor.selectCurrentWord();
        if (selected) {
            mSelectionStart = editor.getTextView().getSelectionStart();
            mSelectionEnd = editor.getTextView().getSelectionEnd();
            mLogger.logSelectionAction(textView.getSelectionStart(), textView.getSelectionEnd(), SelectionEvent.ACTION_RESET, /* actionLabel= */
            null, /* classification= */
            null);
        }
        return selected;
    }
    return false;
}","{
    final TextView textView = editor.getTextView();
    if (isSelectionStarted() && mAllowReset && textIndex >= mSelectionStart && textIndex <= mSelectionEnd && getText(textView) instanceof Spannable) {
        mAllowReset = false;
        boolean selected = editor.selectCurrentWord();
        if (selected) {
            final int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(textView);
            mSelectionStart = sortedSelectionIndices[0];
            mSelectionEnd = sortedSelectionIndices[1];
            mLogger.logSelectionAction(sortedSelectionIndices[0], sortedSelectionIndices[1], SelectionEvent.ACTION_RESET, /* actionLabel= */
            null, /* classification= */
            null);
        }
        return selected;
    }
    return false;
}",1,"/**
 * Returns true if the current smart selection should be reset to normal selection based on
 * information that has been recorded about the original selection and the smart selection.
 * The expected UX here is to allow the user to select a word inside of the smart selection
 * on a single tap.
 */
","/**
 * Returns true if the current smart selection should be reset to normal selection based on
 * information that has been recorded about the original selection and the smart selection.
 * The expected UX here is to allow the user to select a word inside of the smart selection
 * on a single tap.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change involves updating the way selection indices are assigned and logged, replacing direct calls to `editor.getTextView().getSelectionStart()` and `editor.getTextView().getSelectionEnd()` with an intermediary method call to `sortSelctionIndicesFromTextView(textView)`. This is a control dependency change because it alters the statements inside a conditional block. It's also an 'other statement changed' because the actual expressions to calculate `mSelectionStart` and `mSelectionEnd` are different. Therefore, the changes are 3 and 4.","Despite the changes in the implementations, there is no compatibility issue that arises from these specific changes. The logic within the conditional block still ultimately returns the variable `selected`, which is determined by `editor.selectCurrentWord()`. The changes made do not alter the return value or exception behavior of the method. Hence, the CI type is 0."
763,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor: Stub createIMultiClientInputMethodSession()>,29,30,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor: Stub createIMultiClientInputMethodSession()>,<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor: Stub createIMultiClientInputMethodSession()>,0,"{
    synchronized (mSessionLock) {
        return new MultiClientInputMethodSessionImpl(mSessionLock, mCallbackImpl, mHandler, mFinished);
    }
}","{
    synchronized (mSessionLock) {
        return new MultiClientInputMethodSessionImpl(mSessionLock, mCallbackImpl, mHandler, mCancellationGroup);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The parameter passed to the constructor of MultiClientInputMethodSessionImpl has changed from `mFinished` to `mCancellationGroup`. This is not a return statement change, exception handling statement change, or a control dependency change, hence the code change type is 4.","The change in a constructor parameter does not by itself cause the method to return a different value or type, and it also does not introduce a new exception handling path. Assuming both `mFinished` and `mCancellationGroup` are properly initialized and intended to be used as the argument for the same parameter in the constructor, this is an internal change that consumers of the API should not be affected by. Therefore, there is no compatibility issue, so the CI type is 0."
764,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,29,30,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,0,"{
    String autoVerify = parser.getAttributeValue(null, AUTO_VERIFY_STR);
    setAutoVerify(TextUtils.isEmpty(autoVerify) ? false : Boolean.getBoolean(autoVerify));
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(SSP_STR)) {
            String ssp = parser.getAttributeValue(null, LITERAL_STR);
            if (ssp != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
            } else if ((ssp = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_PREFIX);
            } else if ((ssp = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((ssp = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_ADVANCED_GLOB);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((path = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_ADVANCED_GLOB);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}","{
    String autoVerify = parser.getAttributeValue(null, AUTO_VERIFY_STR);
    setAutoVerify(TextUtils.isEmpty(autoVerify) ? false : Boolean.getBoolean(autoVerify));
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(STATIC_TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDynamicDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(GROUP_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addMimeGroup(name);
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(SSP_STR)) {
            String ssp = parser.getAttributeValue(null, LITERAL_STR);
            if (ssp != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
            } else if ((ssp = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_PREFIX);
            } else if ((ssp = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((ssp = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_ADVANCED_GLOB);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((path = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_ADVANCED_GLOB);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
765,<android.util.Half: short abs(short)>,29,30,<android.util.Half: short abs(short)>,<android.util.Half: short abs(short)>,0,"{
    return (short) (h & FP16_COMBINED);
}","{
    return (short) (h & FP16.EXPONENT_SIGNIFICAND_MASK);
}",1,"/**
 * Returns the absolute value of the specified half-precision float.
 * Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is positive zero (see {@link #POSITIVE_ZERO})</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is positive infinity (see {@link #POSITIVE_INFINITY})</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The absolute value of the specified half-precision float
 */
","/**
 * Returns the absolute value of the specified half-precision float.
 * Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is positive zero (see {@link #POSITIVE_ZERO})</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is positive infinity (see {@link #POSITIVE_INFINITY})</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The absolute value of the specified half-precision float
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,5,1,"The bit manipulation in the return statement has changed because the constant used has been changed from FP16_COMBINED to FP16.EXPONENT_SIGNIFICAND_MASK. This change could potentially affect the result of the method if FP16_COMBINED and FP16.EXPONENT_SIGNIFICAND_MASK do not have the same value, hence the dependent API has changed, and the code change type is 5.","Since the constant used in the bit manipulation of the return value has changed, this could potentially alter the resulting value returned by the API, creating a Compatibility Issue of type 1."
766,<android.widget.Toast: int getYOffset()>,29,30,<android.widget.Toast: int getYOffset()>,<android.widget.Toast: int getYOffset()>,0,"{
    return mTN.mY;
}","{
    if (isSystemRenderedTextToast()) {
        Log.e(TAG, ""getYOffset() shouldn't be called on text toasts, the result may not reflect"" + "" actual values."");
    }
    return mTN.mY;
}",1,"/**
 * Return the Y offset in pixels to apply to the gravity's location.
 */
","/**
 * Return the Y offset in pixels to apply to the gravity's location.
 *
 * <p><strong>Warning:</strong> Starting from Android {@link Build.VERSION_CODES#R}, for apps
 * targeting API level {@link Build.VERSION_CODES#R} or higher, this method shouldn't be called
 * on text toasts as its return value may not reflect actual value since text toasts are not
 * rendered by the app anymore.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new logging statement has been introduced before the return statement, so the code change type is 4.","The added logging statement does not affect the return value or exception handling of the method; it merely adds a log message. Therefore, it does not pose a compatibility issue, and the CI type is 0."
767,<android.webkit.MimeTypeMap: boolean hasExtension(String)>,29,30,<android.webkit.MimeTypeMap: boolean hasExtension(String)>,<android.webkit.MimeTypeMap: boolean hasExtension(String)>,0,"{
    return MimeUtils.hasExtension(extension);
}","{
    return MimeMap.getDefault().hasExtension(extension);
}",1,"/**
 * Return {@code true} if the given extension has a registered MIME type.
 * @param extension A file extension without the leading '.'
 * @return {@code true} if there is an extension entry in the map.
 */
","/**
 * Return {@code true} if the given extension has a registered MIME type.
 * @param extension A file extension without the leading '.'
 * @return {@code true} if there is an extension entry in the map.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation switches from using MimeUtils.hasExtension(extension) to MimeMap.getDefault().hasExtension(extension), therefore the change type is 5 because a dependent API is changed.","There is no Compatibility Issue indicated because of the changed dependent API. As long as the behavior of MimeMap.getDefault().hasExtension(extension) is intended to be consistent with MimeUtils.hasExtension(extension), then the API should not introduce any new behavior that would create a Compatibility Issue. The change suggests a move to a different underlying implementation while presumably maintaining the same functionality, so the CI type is 0."
768,<android.util.Half: int getSign(short)>,29,30,<android.util.Half: int getSign(short)>,<android.util.Half: int getSign(short)>,0,"{
    return (h & FP16_SIGN_MASK) == 0 ? 1 : -1;
}","{
    return (h & FP16.SIGN_MASK) == 0 ? 1 : -1;
}",1,"/**
 * Returns the sign of the specified half-precision float.
 *
 * @param h A half-precision float value
 * @return 1 if the value is positive, -1 if the value is negative
 */
","/**
 * Returns the sign of the specified half-precision float.
 *
 * @param h A half-precision float value
 * @return 1 if the value is positive, -1 if the value is negative
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is related to how the mask value is accessed, from FP16_SIGN_MASK to FP16.SIGN_MASK. It is likely an internal constant that has been refactored or moved but with the same value, so the change type is 5.","Because this change does not affect the behavior (assuming FP16.SIGN_MASK has the same value as FP16_SIGN_MASK), no Compatibility Issue should arise, so the CI type is 0."
770,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",29,30,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mode, ""mode"");
    try {
        if (mWrapped != null)
            return mWrapped.openAssetFile(uri, mode, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                unstableProvider = null;
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    Objects.requireNonNull(mode, ""mode"");
    try {
        if (mWrapped != null)
            return mWrapped.openAssetFile(uri, mode, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, mAttributionTag, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, mAttributionTag, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                unstableProvider = null;
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file or {@code null} if the
 * provider recently crashed. You own this descriptor and are responsible for closing it
 * when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,,,,
771,<android.content.pm.ShortcutManager: List<ShortcutInfo> getDynamicShortcuts()>,29,30,<android.content.pm.ShortcutManager: List<ShortcutInfo> getDynamicShortcuts()>,<android.content.pm.ShortcutManager: List<ShortcutInfo> getDynamicShortcuts()>,0,"{
    try {
        return mService.getDynamicShortcuts(mContext.getPackageName(), injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_DYNAMIC, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all dynamic shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Return all dynamic shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call within `try` block has changed from `getDynamicShortcuts` to `getShortcuts` with the `FLAG_MATCH_DYNAMIC` flag. The overall structure and logic of the method remain the same, but the method depends on a changed API, so the code change type is 5.","There's no evidence that the dependent API change will lead to a different behavior in terms of returned value or thrown exceptions, assuming that 'getShortcuts' with the 'FLAG_MATCH_DYNAMIC' is intended to replace 'getDynamicShortcuts' and maintains the same behavior for this flag. Therefore, there is no compatibility issue."
772,"<android.os.Parcel: void readException(int,String)>",29,30,"<android.os.Parcel: void readException(int,String)>","<android.os.Parcel: void readException(int,String)>",0,"{
    String remoteStackTrace = null;
    final int remoteStackPayloadSize = readInt();
    if (remoteStackPayloadSize > 0) {
        remoteStackTrace = readString();
    }
    Exception e = createException(code, msg);
    // Attach remote stack trace if availalble
    if (remoteStackTrace != null) {
        RemoteException cause = new RemoteException(""Remote stack trace:\n"" + remoteStackTrace, null, false, false);
        try {
            Throwable rootCause = ExceptionUtils.getRootCause(e);
            if (rootCause != null) {
                rootCause.initCause(cause);
            }
        } catch (RuntimeException ex) {
            Log.e(TAG, ""Cannot set cause "" + cause + "" for "" + e, ex);
        }
    }
    SneakyThrow.sneakyThrow(e);
}","{
    String remoteStackTrace = null;
    final int remoteStackPayloadSize = readInt();
    if (remoteStackPayloadSize > 0) {
        remoteStackTrace = readString();
    }
    Exception e = createException(code, msg);
    // Attach remote stack trace if availalble
    if (remoteStackTrace != null) {
        RemoteException cause = new RemoteException(""Remote stack trace:\n"" + remoteStackTrace, null, false, false);
        ExceptionUtils.appendCause(e, cause);
    }
    SneakyThrow.sneakyThrow(e);
}",1,"/**
 * Throw an exception with the given message. Not intended for use
 * outside the Parcel class.
 *
 * @param code Used to determine which exception class to throw.
 * @param msg The exception message.
 */
","/**
 * Throw an exception with the given message. Not intended for use
 * outside the Parcel class.
 *
 * @param code Used to determine which exception class to throw.
 * @param msg The exception message.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in how the remote exception cause is appended to the main exception ('e'). The early version uses a manual way to set the cause, whereas the late version uses the `ExceptionUtils.appendCause` method. The 'if' condition and 'readInt' method invocation remain the same, so there is no change in control dependency or exception handling. Hence, the code change types are 4 (Other statement changed) and 5 (Dependent API changed) since `ExceptionUtils.appendCause` affects how the exception's cause is set, which is considered dependent API change.","Even though there is an internal change in the exception handling, the behavior observed by the API consumers remains the same. The primary function of the method - reading an exception and throwing it, has not changed, and there is no change in how exceptions are thrown to the callers. The exceptions that are thrown by the methods are not altered between the early and late versions. Therefore, there is no Compatibility Issue introduced by this change."
773,"<android.app.admin.DevicePolicyManager: void setScreenCaptureDisabled(ComponentName,boolean)>",29,30,"<android.app.admin.DevicePolicyManager: void setScreenCaptureDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setScreenCaptureDisabled(ComponentName,boolean)>",0,"{
    throwIfParentInstance(""setScreenCaptureDisabled"");
    if (mService != null) {
        try {
            mService.setScreenCaptureDisabled(admin, disabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setScreenCaptureDisabled(admin, disabled, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a device/profile owner to set whether the screen capture is disabled. Disabling
 * screen capture also prevents the content from being shown on display devices that do not have
 * a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about
 * secure surfaces and secure displays.
 * <p>
 * The calling device admin must be a device or profile owner. If it is not, a security
 * exception will be thrown.
 * <p>
 * From version {@link android.os.Build.VERSION_CODES#M} disabling screen capture also blocks
 * assist requests for all activities of the relevant user.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether screen capture is disabled or not.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Called by a device/profile owner to set whether the screen capture is disabled. Disabling
 * screen capture also prevents the content from being shown on display devices that do not have
 * a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about
 * secure surfaces and secure displays.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance, returned by
 * {@link #getParentProfileInstance(ComponentName)}, where the calling device admin must be
 * the profile owner of an organization-owned managed profile. If it is not, a security
 * exception will be thrown.
 * <p>
 * If the caller is device owner or called on the parent instance by a profile owner of an
 * organization-owned managed profile, then the restriction will be applied to all users.
 * <p>
 * From version {@link android.os.Build.VERSION_CODES#M} disabling screen capture also blocks
 * assist requests for all activities of the relevant user.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether screen capture is disabled or not.
 * @throws SecurityException if {@code admin} is not a device or profile owner or if
 * called on the parent profile and the {@code admin} is not a
 * profile owner of an organization-owned managed profile.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early version of the method contains a call to throwIfParentInstance(""setScreenCaptureDisabled""), which has been removed in the late version. Additionally, the late version of setScreenCaptureDisabled in mService has a new parameter, mParentInstance. This indicates a change in the dependent API call (from setScreenCaptureDisabled(admin, disabled) to setScreenCaptureDisabled(admin, disabled, mParentInstance)), and thus the code change types are 4 and 5.","While there has been a change in how the method interacts with the dependent API, these modifications do not impact the method's behavior concerning its return value (there is no return value, as it's a void method) or exception handling (the try-catch block remains the same). Thus, there is no Compatibility Issue, so the CI type is 0."
774,"<android.view.SurfaceControl.Transaction: Transaction setGeometry(SurfaceControl,Rect,Rect,int)>",29,30,"<android.view.SurfaceControl.Transaction: Transaction setGeometry(SurfaceControl,Rect,Rect,int)>","<android.view.SurfaceControl.Transaction: Transaction setGeometry(SurfaceControl,Rect,Rect,int)>",0,"{
    sc.checkNotReleased();
    nativeSetGeometry(mNativeObject, sc.mNativeObject, sourceCrop, destFrame, orientation);
    return this;
}","{
    checkPreconditions(sc);
    nativeSetGeometry(mNativeObject, sc.mNativeObject, sourceCrop, destFrame, orientation);
    return this;
}",1,"/**
 * Specify how the buffer assosciated with this Surface is mapped in to the
 * parent coordinate space. The source frame will be scaled to fit the destination
 * frame, after being rotated according to the orientation parameter.
 *
 * @param sc The SurfaceControl to specify the geometry of
 * @param sourceCrop The source rectangle in buffer space. Or null for the entire buffer.
 * @param destFrame The destination rectangle in parent space. Or null for the source frame.
 * @param orientation The buffer rotation
 * @return This transaction object.
 */
","/**
 * Specify how the buffer assosciated with this Surface is mapped in to the
 * parent coordinate space. The source frame will be scaled to fit the destination
 * frame, after being rotated according to the orientation parameter.
 *
 * @param sc The SurfaceControl to specify the geometry of
 * @param sourceCrop The source rectangle in buffer space. Or null for the entire buffer.
 * @param destFrame The destination rectangle in parent space. Or null for the source frame.
 * @param orientation The buffer rotation
 * @return This transaction object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change consists of using a different method (from `sc.checkNotReleased()` to `checkPreconditions(sc)`) to perform a precondition check. This may indicate the implementation details of the precondition check have been altered or refactored but the overall semantics of checking preconditions seems preserved. So the change is of type 4,5 (Other statement changed and Dependent API changed).","While there is a change in the method used for the precondition check, if the contractual behavior of the precondition check remains the same (i.e., checks for the same conditions and throws similar exceptions if any), this would not result in a Compatibility Issue. The return type has not changed and the method is still returning 'this' object, indicating that the contract for the client code is maintained. Thus, no Compatibility Issue is detected."
775,"<android.speech.tts.TextToSpeech: int playEarcon(String,int,Bundle,String)>",29,30,"<android.speech.tts.TextToSpeech: int playEarcon(String,int,Bundle,String)>","<android.speech.tts.TextToSpeech: int playEarcon(String,int,Bundle,String)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri earconUri = mEarcons.get(earcon);
            if (earconUri == null) {
                return ERROR;
            }
            return service.playAudio(getCallerIdentity(), earconUri, queueMode, getParams(params), utteranceId);
        }
    }, ERROR, ""playEarcon"");
}","{
    return runAction((ITextToSpeechService service) -> {
        Uri earconUri = mEarcons.get(earcon);
        if (earconUri == null) {
            return ERROR;
        }
        return service.playAudio(getCallerIdentity(), earconUri, queueMode, getParams(params), utteranceId);
    }, ERROR, ""playEarcon"");
}",1,"/**
 * Plays the earcon using the specified queueing mode and parameters.
 * The earcon must already have been added with {@link #addEarcon(String, String)} or
 * {@link #addEarcon(String, String, int)}.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param earcon The earcon that should be played
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playEarcon operation.
 */
","/**
 * Plays the earcon using the specified queueing mode and parameters.
 * The earcon must already have been added with {@link #addEarcon(String, String)} or
 * {@link #addEarcon(String, String, int)}.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param earcon The earcon that should be played
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playEarcon operation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation change is from an anonymous inner class to a lambda expression for the 'runAction' method, which does not affect the behavior of the API as the executable code remains the same; this is a syntactic change that optimizes the readability of the code without altering its functionality. Thus, the code change type is 4.","There is no Compatibility Issue because the lambda expression performs the exact same operation as the anonymous inner class it replaced; there is no change in return values, thrown exceptions, or control flow—just a change in code syntax. The service it relies on and the method calls are unchanged, therefore the behavior will remain the same when invoking the API."
776,<android.os.PowerManager: boolean isPowerSaveMode()>,29,30,<android.os.PowerManager: boolean isPowerSaveMode()>,<android.os.PowerManager: boolean isPowerSaveMode()>,0,"{
    try {
        return mService.isPowerSaveMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return mPowerSaveModeCache.query(null);
}",1,"/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
","/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from invoking mService.isPowerSaveMode() to invoking mPowerSaveModeCache.query(null), where a different method is called on a changed variable. This constitutes a modification in the return statement and dependent API change, so the code change type is 1,5.","Given the entirely new method is being called for the return statement in the late version, this change may lead to the API potentially returning different values even if the logic is intended to provide the same outcome, and thus the CI type is 1."
777,"<android.content.ContentProviderOperation: String[] resolveSelectionArgsBackReferences(ContentProviderResult[],int)>",29,30,"<android.content.ContentProviderOperation: String[] resolveSelectionArgsBackReferences(ContentProviderResult[],int)>","<android.content.ContentProviderOperation: String[] resolveSelectionArgsBackReferences(ContentProviderResult[],int)>",0,"{
    if (mSelectionArgsBackReferences == null) {
        return mSelectionArgs;
    }
    String[] newArgs = new String[mSelectionArgs.length];
    System.arraycopy(mSelectionArgs, 0, newArgs, 0, mSelectionArgs.length);
    for (Map.Entry<Integer, Integer> selectionArgBackRef : mSelectionArgsBackReferences.entrySet()) {
        final Integer selectionArgIndex = selectionArgBackRef.getKey();
        final int backRefIndex = selectionArgBackRef.getValue();
        newArgs[selectionArgIndex] = String.valueOf(backRefToValue(backRefs, numBackRefs, backRefIndex));
    }
    return newArgs;
}","{
    if (mSelectionArgs != null) {
        int max = -1;
        for (int i = 0; i < mSelectionArgs.size(); i++) {
            max = Math.max(max, mSelectionArgs.keyAt(i));
        }
        final String[] selectionArgs = new String[max + 1];
        for (int i = 0; i < mSelectionArgs.size(); i++) {
            final Object value = mSelectionArgs.valueAt(i);
            final Object resolved;
            if (value instanceof BackReference) {
                resolved = ((BackReference) value).resolve(backRefs, numBackRefs);
            } else {
                resolved = value;
            }
            selectionArgs[mSelectionArgs.keyAt(i)] = String.valueOf(resolved);
        }
        return selectionArgs;
    } else {
        return null;
    }
}",1,"/**
 * The Selection Arguments back references are represented as a Map of Integer->Integer where
 * the key is an index into the selection argument array (see {@link Builder#withSelection})
 * and the value is the index of the previous result that should be used for that selection
 * argument array slot.
 * <p>
 * This is intended to be a private method but it is exposed for
 * unit testing purposes
 * @param backRefs an array of previous results
 * @param numBackRefs the number of valid previous results in backRefs
 * @return the ContentValues that should be used in this operation application after
 * expansion of back references. This can be called if either mValues or mValuesBackReferences
 * is null
 */
","/**
 * Return the selection arguments for this operation after resolving any
 * requested back-references using the given results.
 *
 * @param backRefs the results to use when resolving any back-references
 * @param numBackRefs the number of results which are valid
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method implementation has changed significantly - The conditional check has changed from checking if mSelectionArgsBackReferences is null to if mSelectionArgs is not null. The entire for-loop logic and array population strategy have changed, also the entire block for populating newArgs has changed, and new APIs like keyAt(), valueAt(), and a new inner class BackReference with the resolve() method are now used. Additionally, the return value has changed to return null if mSelectionArgs is null, which was not the case in the early version. Therefore, the code change types are 1,3,5.","The change in return type (to possibly return null), the change in how the selectionArgs array is populated, and the new calculations involve a new BackReference which may resolve differently all represent potential compatibility issues. The API could now return a different variable type (null) and different values. Hence, the CI type is 1."
779,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,29,30,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.restartInput(view);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner(StartInputReason.APP_CALLED_RESTART_INPUT_API, null, 0, 0, 0);
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.restartInput(view);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner(StartInputReason.APP_CALLED_RESTART_INPUT_API, null, 0, 0, 0);
}",1,"/**
 * If the input method is currently connected to the given view,
 * restart it with its new contents.  You should call this when the text
 * within your view changes outside of the normal input method or key
 * input flow, such as when an application calls TextView.setText().
 *
 * @param view The view whose text has changed.
 */
","/**
 * If the input method is currently connected to the given view,
 * restart it with its new contents.  You should call this when the text
 * within your view changes outside of the normal input method or key
 * input flow, such as when an application calls TextView.setText().
 *
 * @param view The view whose text has changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A call within a control statement (`if` condition) has been replaced with another method call (from `mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))` to `!hasServedByInputMethodLocked(view)`), however, it's not clear without additional context whether this is a simple refactoring that consolidates the conditions into a new method with the same logic or an actual change in logic. This is classified as a control dependency change (change type 3). Also, the exact behavior of the dependent API `hasServedByInputMethodLocked(view)` is not known, so if it behaves differently from the earlier condition, there might be other statement changes (change type 4).","Based on the information given and assuming that the `hasServedByInputMethodLocked(view)` method encapsulates the same logic as the condition it replaces, there would be no compatibility issue as the overall behavior of `restartInput(View)` would remain the same. The invocation conditions for the `return` statement did not change in a way that would change the API's observable behavior, as presumably, the new method `hasServedByInputMethodLocked` implements the same check. Therefore, no compatibility issue is detected. However, if the new method `hasServedByInputMethodLocked(view)` changes the logic, we might not be able to tell if there is a compatibility issue or not without its implementation details."
780,<android.permission.PermissionManager.SplitPermissionInfo: List<String> getNewPermissions()>,29,30,<android.permission.PermissionManager.SplitPermissionInfo: List<String> getNewPermissions()>,<android.permission.PermissionManager.SplitPermissionInfo: List<String> getNewPermissions()>,0,"{
    return mNewPerms;
}","{
    return mSplitPermissionInfoParcelable.getNewPermissions();
}",1,"/**
 * Get the permissions that are added.
 */
","/**
 * Get the permissions that are added.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation now returns the result of a different method call (mSplitPermissionInfoParcelable.getNewPermissions()) instead of directly returning the member variable mNewPerms. This indicates that the dependent API has changed, so the code change type is 4,5.","Despite the change in how the value is retrieved, as both methods are annotated with [@NonNull], it is implied that they should return a non-null list of permissions. Assuming that mSplitPermissionInfoParcelable.getNewPermissions() is correctly implemented to return the same set of permissions as mNewPerms would have, there should be no compatibility issue arising from this change, hence the CI type is 0."
781,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,29,30,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false);
        } else {
            id = view.getAutofillId();
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true);
                } else {
                    view.setAutofilled(false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false);
            }
        }
        if (mForAugmentedAutofillOnly) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged(): not notifying system server on "" + ""augmented-only mode"");
            }
            return;
        }
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        if (id == null) {
            id = view.getAutofillId();
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false, false);
        } else {
            id = view.getAutofillId();
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                final boolean hideHighlight = mLastAutofilledData.keySet().size() == 1;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true, hideHighlight);
                } else {
                    view.setAutofilled(false, false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false, false);
            }
        }
        if (!mEnabled || !isActiveLocked()) {
            if (!startAutofillIfNeededLocked(view)) {
                if (sVerbose) {
                    Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + ""): ignoring on state "" + getStateAsStringLocked());
                }
            }
            return;
        }
        if (id == null) {
            id = view.getAutofillId();
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}",1,"/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
","/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There was a change in the arguments for the method view.setAutofilled(), which now includes an additional boolean parameter, and there is also the addition of the condition startAutofillIfNeededLocked(view), so other statements and control dependency have been altered, making the change type 3,4.","As the change in view.setAutofilled() method arguments could potentially cause the method to behave differently in terms of whether it will highlight the autofilled view or not, which represents a behavior change from the API consumer’s perspective, there is a potential Compatibility Issue that could arise. Moreover, the addition of the startAutofillIfNeededLocked(view) method call could lead to a different flow of execution, potentially affecting the state of the system or the autofill session, resulting in a CI type of 1."
782,<android.view.textclassifier.TextClassificationManager: TextClassifier createTextClassificationSession(TextClassificationContext)>,29,30,<android.view.textclassifier.TextClassificationManager: TextClassifier createTextClassificationSession(TextClassificationContext)>,<android.view.textclassifier.TextClassificationManager: TextClassifier createTextClassificationSession(TextClassificationContext)>,0,"{
    Preconditions.checkNotNull(classificationContext);
    final TextClassifier textClassifier = mSessionFactory.createTextClassificationSession(classificationContext);
    Preconditions.checkNotNull(textClassifier, ""Session Factory should never return null"");
    return textClassifier;
}","{
    Objects.requireNonNull(classificationContext);
    final TextClassifier textClassifier = mSessionFactory.createTextClassificationSession(classificationContext);
    Objects.requireNonNull(textClassifier, ""Session Factory should never return null"");
    return textClassifier;
}",1,"/**
 * Call this method to start a text classification session with the given context.
 * A session is created with a context helping the classifier better understand
 * what the user needs and consists of queries and feedback events. The queries
 * are directly related to providing useful functionality to the user and the events
 * are a feedback loop back to the classifier helping it learn and better serve
 * future queries.
 *
 * <p> All interactions with the returned classifier are considered part of a single
 * session and are logically grouped. For example, when a text widget is focused
 * all user interactions around text editing (selection, editing, etc) can be
 * grouped together to allow the classifier get better.
 *
 * @param classificationContext The context in which classification would occur
 *
 * @return An instance to perform classification in the given context
 */
","/**
 * Call this method to start a text classification session with the given context.
 * A session is created with a context helping the classifier better understand
 * what the user needs and consists of queries and feedback events. The queries
 * are directly related to providing useful functionality to the user and the events
 * are a feedback loop back to the classifier helping it learn and better serve
 * future queries.
 *
 * <p> All interactions with the returned classifier are considered part of a single
 * session and are logically grouped. For example, when a text widget is focused
 * all user interactions around text editing (selection, editing, etc) can be
 * grouped together to allow the classifier get better.
 *
 * @param classificationContext The context in which classification would occur
 *
 * @return An instance to perform classification in the given context
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change from Preconditions.checkNotNull to Objects.requireNonNull does not affect the behavior of the method because both methods throw a NullPointerException when passed a null argument. Therefore, the change type is 4 (Other statement changed), as this is an implementation detail change.",There is no Compatibility Issue because the underlying behavior and contract of the method remains the same – it will still throw a NullPointerException if the arguments are null. The replacement of Preconditions.checkNotNull with Objects.requireNonNull does not affect the method's observable behavior to the caller.
783,"<android.widget.ListPopupWindow: boolean onKeyDown(int,KeyEvent)>",29,30,"<android.widget.ListPopupWindow: boolean onKeyDown(int,KeyEvent)>","<android.widget.ListPopupWindow: boolean onKeyDown(int,KeyEvent)>",0,"{
    // when the drop down is shown, we drive it directly
    if (isShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || !KeyEvent.isConfirmKey(keyCode))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            final ListAdapter adapter = mAdapter;
            boolean allEnabled;
            int firstItem = Integer.MAX_VALUE;
            int lastItem = Integer.MIN_VALUE;
            if (adapter != null) {
                allEnabled = adapter.areAllItemsEnabled();
                firstItem = allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0, true);
                lastItem = allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
            }
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                show();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.setListSelectionHidden(false);
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, ""Key down: code="" + keyCode + "" list consumed="" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                show();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // event to avoid going to the next focusable widget
                    if (curIndex == lastItem) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    // when the drop down is shown, we drive it directly
    if (isShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || !KeyEvent.isConfirmKey(keyCode))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            final ListAdapter adapter = mAdapter;
            boolean allEnabled;
            int firstItem = Integer.MAX_VALUE;
            int lastItem = Integer.MIN_VALUE;
            if (adapter != null) {
                allEnabled = adapter.areAllItemsEnabled();
                firstItem = allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0, true);
                lastItem = allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
            }
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                show();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.setListSelectionHidden(false);
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, ""Key down: code="" + keyCode + "" list consumed="" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                show();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                    case KeyEvent.KEYCODE_NUMPAD_ENTER:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // event to avoid going to the next focusable widget
                    if (curIndex == lastItem) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                    return true;
                }
            }
        }
    }
    return false;
}",1,"/**
 * Filter key down events. By forwarding key down events to this function,
 * views using non-modal ListPopupWindow can have it handle key selection of items.
 *
 * @param keyCode keyCode param passed to the host view's onKeyDown
 * @param event event param passed to the host view's onKeyDown
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 * @see #onKeyUp(int, KeyEvent)
 */
","/**
 * Filter key down events. By forwarding key down events to this function,
 * views using non-modal ListPopupWindow can have it handle key selection of items.
 *
 * @param keyCode keyCode param passed to the host view's onKeyDown
 * @param event event param passed to the host view's onKeyDown
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 * @see #onKeyUp(int, KeyEvent)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
784,"<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionStarted(TextClassifier,TextClassificationContext,CharSequence,int,int)>",29,30,"<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionStarted(TextClassifier,TextClassificationContext,CharSequence,int,int)>","<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionStarted(TextClassifier,TextClassificationContext,CharSequence,int,int)>",0,"{
    try {
        Preconditions.checkNotNull(text);
        Preconditions.checkArgumentInRange(index, 0, text.length(), ""index"");
        if (mText == null || !mText.contentEquals(text)) {
            mText = text.toString();
        }
        mTokenIterator.setText(mText);
        mStartIndex = index;
        mClassificationSession = classificationSession;
        mClassificationContext = classificationContext;
        if (hasActiveClassificationSession()) {
            mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionStartedEvent(invocationMethod, 0));
        }
    } catch (Exception e) {
        // Avoid crashes due to logging.
        Log.e(LOG_TAG, """" + e.getMessage(), e);
    }
}","{
    try {
        Objects.requireNonNull(text);
        Preconditions.checkArgumentInRange(index, 0, text.length(), ""index"");
        if (mText == null || !mText.contentEquals(text)) {
            mText = text.toString();
        }
        mTokenIterator.setText(mText);
        mStartIndex = index;
        mClassificationSession = classificationSession;
        mClassificationContext = classificationContext;
        if (hasActiveClassificationSession()) {
            mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionStartedEvent(invocationMethod, 0));
        }
    } catch (Exception e) {
        // Avoid crashes due to logging.
        Log.e(LOG_TAG, """" + e.getMessage(), e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only code change is the replacement of `Preconditions.checkNotNull(text)` with `Objects.requireNonNull(text)` for null-check, which does not affect the behavior of the method, so the change type is 4.",There is no compatibility issue as this is a straight substitution of one null-check method for another with the same functionality.
785,<android.content.res.AssetManager: String[] list(String)>,29,30,<android.content.res.AssetManager: String[] list(String)>,<android.content.res.AssetManager: String[] list(String)>,0,"{
    Preconditions.checkNotNull(path, ""path"");
    synchronized (this) {
        ensureValidLocked();
        return nativeList(mObject, path);
    }
}","{
    Objects.requireNonNull(path, ""path"");
    synchronized (this) {
        ensureValidLocked();
        return nativeList(mObject, path);
    }
}",1,"/**
 * Return a String array of all the assets at the given path.
 *
 * @param path A relative path within the assets, i.e., ""docs/home.html"".
 *
 * @return String[] Array of strings, one for each asset.  These file
 * names are relative to 'path'.  You can open the file by
 * concatenating 'path' and a name in the returned string (via
 * File) and passing that to open().
 *
 * @see #open
 */
","/**
 * Return a String array of all the assets at the given path.
 *
 * @param path A relative path within the assets, i.e., ""docs/home.html"".
 *
 * @return String[] Array of strings, one for each asset.  These file
 * names are relative to 'path'.  You can open the file by
 * concatenating 'path' and a name in the returned string (via
 * File) and passing that to open().
 *
 * @see #open
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The API internally changed the way it checks for null. It went from Preconditions.checkNotNull(path, ""path"") to Objects.requireNonNull(path, ""path""). This is a different method used to validate that 'path' is not null but accomplishes the same goal. The change type is 4 (Other statement changed) and 5 (Dependent API changed, due to the swap from Preconditions.checkNotNull to Objects.requireNonNull).","There is no Compatibility Issue here, as both methods have the same behavior and purpose, which is to throw a NullPointerException if 'path' is null. The functionality from the caller's perspective remains consistent between the two versions, and there would not be any new exceptions nor changes in the returned value as long as the input satisfies the non-null precondition."
786,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern)>",29,30,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern)>","<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern)>",0,"{
    throwIfDestroyed();
    Preconditions.checkState(mPresentation != null, ""Dataset presentation not set on constructor"");
    setLifeTheUniverseAndEverything(id, value, null, new DatasetFieldFilter(filter));
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkState(mPresentation != null, ""Dataset presentation not set on constructor"");
    setLifeTheUniverseAndEverything(id, value, null, null, new DatasetFieldFilter(filter));
    return this;
}",1,"/**
 * Sets the value of a field using an <a href=""#Filtering"">explicit filter</a>.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling {@link #setValue(AutofillId, AutofillValue)} and
 * use the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 *
 * @return this builder.
 * @throws IllegalStateException if the builder was constructed without a
 * {@link RemoteViews presentation}.
 */
","/**
 * Sets the value of a field using an <a href=""#Filtering"">explicit filter</a>.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling {@link #setValue(AutofillId, AutofillValue)} and
 * use the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 *
 * @return this builder.
 * @throws IllegalStateException if the builder was constructed without a
 * {@link RemoteViews presentation} or {@link #build()} was already called.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method 'setLifeTheUniverseAndEverything' had an additional null parameter inserted in its call within the method body. Since this is a change to the method's arguments list without altering control flow or return type, the change type is 4 according to Other statement changed, and also 5 since the dependent method 'setLifeTheUniverseAndEverything' has a signature change with an additional parameter.","No Compatibility Issue is detected because there is only an additional parameter passed to a method call within this API which doesn't affect the return value or control flow, and this doesn't pose any issue to code that is dependent on this API method's signature or return type."
791,"<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>",29,30,"<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>","<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mimeTypeFilter, ""mimeTypeFilter"");
    beforeRemote();
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(mimeTypeFilter, ""mimeTypeFilter"");
    beforeRemote();
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */
","/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,4,0,"The method Preconditions.checkNotNull has been replaced with Objects.requireNonNull. This is a simple refactoring change as both methods have the same purpose of checking if an object reference is not null, and it does not alter the program's behaviour. Hence, the code change is of type 4, which corresponds to Other statement changed.","There is no Compatibility Issue because the behavioural aspect of the API has not been altered. Both Preconditions.checkNotNull and Objects.requireNonNull will throw a NullPointerException if the given reference is null, so the use of either does not modify the program's behaviour. The structure of the try-catch block, return statements, and exception handling remain the same. Therefore, the API will behave in the same way."
792,<android.hardware.camera2.impl.CameraMetadataNative: T get(Key<T>)>,29,30,<android.hardware.camera2.impl.CameraMetadataNative: T get(Key<T>)>,<android.hardware.camera2.impl.CameraMetadataNative: T get(Key<T>)>,0,"{
    Preconditions.checkNotNull(key, ""key must not be null"");
    // Check if key has been overridden to use a wrapper class on the java side.
    GetCommand g = sGetCommandMap.get(key);
    if (g != null) {
        return g.getValue(this, key);
    }
    return getBase(key);
}","{
    Objects.requireNonNull(key, ""key must not be null"");
    // Check if key has been overridden to use a wrapper class on the java side.
    GetCommand g = sGetCommandMap.get(key);
    if (g != null) {
        return g.getValue(this, key);
    }
    return getBase(key);
}",1,"/**
 * Look-up a metadata field value by its key.
 *
 * @param key a non-{@code null} key instance
 * @return the field corresponding to the {@code key}, or {@code null} if no value was set
 */
","/**
 * Look-up a metadata field value by its key.
 *
 * @param key a non-{@code null} key instance
 * @return the field corresponding to the {@code key}, or {@code null} if no value was set
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call for checking null has changed from Preconditions.checkNotNull() to Objects.requireNonNull(). However, both methods serve the same purpose, so the behavior of the API hasn't changed, just the internal method call has been updated. Hence, code change type is 4.","There is no Compatibility Issue because the change from Preconditions.checkNotNull() to Objects.requireNonNull() does not affect the returned value or the exceptions thrown (both will throw a NullPointerException if 'key' is null), so the behavior of the API remains the same."
793,<android.webkit.MimeTypeMap: String getExtensionFromMimeType(String)>,29,30,<android.webkit.MimeTypeMap: String getExtensionFromMimeType(String)>,<android.webkit.MimeTypeMap: String getExtensionFromMimeType(String)>,0,"{
    return MimeUtils.guessExtensionFromMimeType(mimeType);
}","{
    return MimeMap.getDefault().guessExtensionFromMimeType(mimeType);
}",1,"/**
 * Return the registered extension for the given MIME type. Note that some
 * MIME types map to multiple extensions. This call will return the most
 * common extension for the given MIME type.
 * @param mimeType A MIME type (i.e. text/plain)
 * @return The extension for the given MIME type or {@code null} if there is none.
 */
","/**
 * Return the registered extension for the given MIME type. Note that some
 * MIME types map to multiple extensions. This call will return the most
 * common extension for the given MIME type.
 * @param mimeType A MIME type (i.e. text/plain)
 * @return The extension for the given MIME type or {@code null} if there is none.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed as it does not directly use MimeUtils but instead uses MimeMap.getDefault() to obtain an instance before calling guessExtensionFromMimeType(mimeType). This is a change in a dependent API, so the code change type is 5.","There is no direct Compatibility Issue present in this change, as the method signature remains the same and the annotation has not changed. It is presumed that the internal behavior of MimeMap.getDefault().guessExtensionFromMimeType() works the same as the previous MimeUtils.guessExtensionFromMimeType(), so the return value should stay consistent. Hence, the CI type is 0."
794,<android.net.LinkAddress: int getFlags()>,29,30,<android.net.LinkAddress: int getFlags()>,<android.net.LinkAddress: int getFlags()>,0,"{
    return flags;
}","{
    int flags = this.flags;
    if (deprecationTime != LIFETIME_UNKNOWN) {
        if (SystemClock.elapsedRealtime() >= deprecationTime) {
            flags |= IFA_F_DEPRECATED;
        } else {
            // If deprecation time is in the future, or permanent.
            flags &= ~IFA_F_DEPRECATED;
        }
    }
    if (expirationTime == LIFETIME_PERMANENT) {
        flags |= IFA_F_PERMANENT;
    } else if (expirationTime != LIFETIME_UNKNOWN) {
        // If we know this address expired or will expire in the future, then this address
        // should not be permanent.
        flags &= ~IFA_F_PERMANENT;
    }
    // Do no touch the original flags. Return the adjusted flags here.
    return flags;
}",1,"/**
 * Returns the flags of this {@code LinkAddress}.
 */
","/**
 * Returns the flags of this {@code LinkAddress}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation introduces new variables and contains additional control structures (if-else statements) that modify the 'flags' value, leading to potential different return values, therefore, the code change type is 1,3,4.","Due to the addition of conditional logic that impacts the value of 'flags' before it is returned, there is a potential for different return values depending on 'deprecationTime' and 'expirationTime'. This constitutes a Compatibility Issue of type 1 caused by potential different return values."
795,<android.app.NotificationManager.Policy: int hashCode()>,29,30,<android.app.NotificationManager.Policy: int hashCode()>,<android.app.NotificationManager.Policy: int hashCode()>,0,"{
    return Objects.hash(priorityCategories, priorityCallSenders, priorityMessageSenders, suppressedVisualEffects);
}","{
    return Objects.hash(priorityCategories, priorityCallSenders, priorityMessageSenders, suppressedVisualEffects, state, priorityConversationSenders);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() method has additional parameters 'state' and 'priorityConversationSenders' included in the hash calculation in the late version, thus the compatibility issue arises due to 'Other statement changed' for incorporating additional fields into the hash computation (the hash value returned can be different even if the unchanged fields are equal), which could lead to an unexpected result if the hash code is used in collections or elsewhere assuming consistency between versions.","Since the hash code value calculation is different due to the inclusion of additional fields, this could lead to a difference in behavior if the hash code is used as a key in a data structure or any scenario where the hash code value impacts program execution. The compatibility issue exists due to a 'Return statement changed,' potentially returning a different hash code value for the same object state concerning the fields considered in version 29."
797,<android.view.textclassifier.TextClassificationContext: String toString()>,29,30,<android.view.textclassifier.TextClassificationContext: String toString()>,<android.view.textclassifier.TextClassificationContext: String toString()>,0,"{
    return String.format(Locale.US, ""TextClassificationContext{"" + ""packageName=%s, widgetType=%s, widgetVersion=%s}"", mPackageName, mWidgetType, mWidgetVersion);
}","{
    return String.format(Locale.US, ""TextClassificationContext{"" + ""packageName=%s, widgetType=%s, widgetVersion=%s, systemTcMetadata=%s}"", mPackageName, mWidgetType, mWidgetVersion, mSystemTcMetadata);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The String being returned by the toString method has been changed to include an additional field, mSystemTcMetadata, in the late version, so the code change type is 1.","As the additional field mSystemTcMetadata is included in the return statement of the late version, the method will return a different value than before, which constitutes a potential Compatibility Issue of type 1."
800,"<android.hardware.camera2.legacy.ParameterUtils: ZoomData convertScalerCropRegion(Rect,Rect,Size,Parameters)>",29,30,"<android.hardware.camera2.legacy.ParameterUtils: ZoomData convertScalerCropRegion(Rect,Rect,Size,Parameters)>","<android.hardware.camera2.legacy.ParameterUtils: ZoomData convertScalerCropRegion(Rect,Rect,Size,Parameters)>",0,"{
    Rect activeArraySizeOnly = new Rect(/*left*/
    0, /*top*/
    0, activeArraySize.width(), activeArraySize.height());
    Rect userCropRegion = cropRegion;
    if (userCropRegion == null) {
        userCropRegion = activeArraySizeOnly;
    }
    if (DEBUG) {
        Log.v(TAG, ""convertScalerCropRegion - user crop region was "" + userCropRegion);
    }
    final Rect reportedCropRegion = new Rect();
    final Rect previewCropRegion = new Rect();
    final int zoomIdx = ParameterUtils.getClosestAvailableZoomCrop(params, activeArraySizeOnly, previewSize, userCropRegion, /*out*/
    reportedCropRegion, /*out*/
    previewCropRegion);
    if (DEBUG) {
        Log.v(TAG, ""convertScalerCropRegion - zoom calculated to: "" + ""zoomIndex = "" + zoomIdx + "", reported crop region = "" + reportedCropRegion + "", preview crop region = "" + previewCropRegion);
    }
    return new ZoomData(zoomIdx, previewCropRegion, reportedCropRegion);
}","{
    Rect activeArraySizeOnly = new Rect(/*left*/
    0, /*top*/
    0, activeArraySize.width(), activeArraySize.height());
    Rect userCropRegion = cropRegion;
    if (userCropRegion == null) {
        userCropRegion = activeArraySizeOnly;
    }
    if (DEBUG) {
        Log.v(TAG, ""convertScalerCropRegion - user crop region was "" + userCropRegion);
    }
    final Rect reportedCropRegion = new Rect();
    final Rect previewCropRegion = new Rect();
    final int zoomIdx = ParameterUtils.getClosestAvailableZoomCrop(params, activeArraySizeOnly, previewSize, userCropRegion, /*out*/
    reportedCropRegion, /*out*/
    previewCropRegion);
    final float reportedZoomRatio = 1.0f;
    if (DEBUG) {
        Log.v(TAG, ""convertScalerCropRegion - zoom calculated to: "" + ""zoomIndex = "" + zoomIdx + "", reported crop region = "" + reportedCropRegion + "", preview crop region = "" + previewCropRegion + "", reported zoom ratio = "" + reportedZoomRatio);
    }
    return new ZoomData(zoomIdx, previewCropRegion, reportedCropRegion, reportedZoomRatio);
}",1,"/**
 * Convert the user-specified crop region into zoom data; which can be used
 * to set the parameters to a specific zoom index, or to report back to the user what the
 * actual zoom was, or for other calculations requiring the current preview crop region.
 *
 * <p>None of the parameters are mutated.</p>
 *
 * @param activeArraySize active array size of the sensor (e.g. max jpeg size)
 * @param cropRegion the user-specified crop region
 * @param previewSize the current preview size (in pixels)
 * @param params the current camera parameters (not mutated)
 *
 * @return the zoom index, and the effective/reported crop regions (relative to active array)
 */
","/**
 * Convert the user-specified crop region into zoom data; which can be used
 * to set the parameters to a specific zoom index, or to report back to the user what the
 * actual zoom was, or for other calculations requiring the current preview crop region.
 *
 * <p>None of the parameters are mutated.</p>
 *
 * @param activeArraySize active array size of the sensor (e.g. max jpeg size)
 * @param cropRegion the user-specified crop region
 * @param previewSize the current preview size (in pixels)
 * @param params the current camera parameters (not mutated)
 *
 * @return the zoom index, and the effective/reported crop regions (relative to active array)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change includes the introduction of a new variable (final float reportedZoomRatio) and a change to the logging statement to include this new variable in the log message. There are no changes to return statements, exception handling, or control flow dependencies.","The compatibility issue situation does not arise because the algorithm's core logic and the returned `ZoomData` object remain unchanged. The additional variable `reportedZoomRatio` is set to a constant value (1.0f) that does not affect the return value of the method. The method signature also does not change, as the returned type is still `ZoomData`."
801,<android.content.IntentFilter: boolean matchAction(String)>,29,30,<android.content.IntentFilter: boolean matchAction(String)>,<android.content.IntentFilter: boolean matchAction(String)>,0,"{
    return hasAction(action);
}","{
    return matchAction(action, false, /*wildcardSupported*/
    null);
}",1,"/**
 * Match this filter against an Intent's action.  If the filter does not
 * specify any actions, the match will always fail.
 *
 * @param action The desired action to look for.
 *
 * @return True if the action is listed in the filter.
 */
","/**
 * Match this filter against an Intent's action.  If the filter does not
 * specify any actions, the match will always fail.
 *
 * @param action The desired action to look for.
 *
 * @return True if the action is listed in the filter.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from directly returning the result of hasAction(action) to returning the result of matchAction(action, false, /*wildcardSupported*/ null). Additionally, the call has changed from hasAction to matchAction with different parameters, which is a dependent API change. Thus, the code change type is 1,5.","Because the method invoked in the return statement has changed with additional parameters, this could potentially lead to a different return value. Therefore, the CI type is 1."
803,<android.webkit.MimeTypeMap: boolean hasMimeType(String)>,29,30,<android.webkit.MimeTypeMap: boolean hasMimeType(String)>,<android.webkit.MimeTypeMap: boolean hasMimeType(String)>,0,"{
    return MimeUtils.hasMimeType(mimeType);
}","{
    return MimeMap.getDefault().hasMimeType(mimeType);
}",1,"/**
 * Return {@code true} if the given MIME type has an entry in the map.
 * @param mimeType A MIME type (i.e. text/plain)
 * @return {@code true} if there is a mimeType entry in the map.
 */
","/**
 * Return {@code true} if the given MIME type has an entry in the map.
 * @param mimeType A MIME type (i.e. text/plain)
 * @return {@code true} if there is a mimeType entry in the map.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from MimeUtils.hasMimeType(mimeType) to MimeMap.getDefault().hasMimeType(mimeType), so the code change type is 5.","Although the dependent API has changed, there's no information indicating that the behavior of the new API would be different. The contract of hasMimeType seems to be preserved across this change, as the functionality appears to be simply delegated to another implementation but expected to return the same result for the same input. So, there should be no Compatibility Issue, hence the CI type is 0."
804,"<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>",29,30,"<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>","<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change involves changing the method call from ActivityManager.getService().broadcastIntent(...) to ActivityManager.getService().broadcastIntentWithFeature(...), adding one more parameter. Hence, the code change types are 4 (Other statement changed) and 5 (Dependent API changed).",There is no Compatibility Issue in terms of returning different values or throwing different exceptions as the method signature remains the same and exceptions are handled identically. The change to a different method with an additional parameter does not affect the behavior from this API's users' perspective.
805,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",29,30,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>","<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, url, mode, remoteSignal, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, mAttributionTag, url, mode, remoteSignal, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the invocation of the `openFile` method of `mContentProvider`, where in late version an additional parameter `mAttributionTag` is passed. The precondition check has been changed from using Preconditions.checkNotNull to Objects.requireNonNull, but they essentially provide the same functionality. Hence, the code change types are 4 (because of the addition of a parameter in `openFile` method) and 5 (because the dependency on the `openFile` method signature changed).","There is no Compatibility Issue detected here regarding the changes made because `mAttributionTag` seems like an additional context being passed for the file opening operation and would not affect the return type or the exceptions thrown, given that if `mAttributionTag` is null, it would have been caught by the `requireNonNull` precondition check. Hence, the user-facing API contract remains the same and there should be no CI - type 0."
806,"<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>",29,30,"<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>","<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>",0,"{
    if (mGhostView != null) {
        mGhostView.invalidate(true);
        return;
    }
    if (skipInvalidate()) {
        return;
    }
    // Reset content capture caches
    mCachedContentCaptureSession = null;
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
        if (fullInvalidate) {
            mLastIsOpaque = isOpaque();
            mPrivateFlags &= ~PFLAG_DRAWN;
        }
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        // Propagate the damage rectangle to the parent view.
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        if (p != null && ai != null && l < r && t < b) {
            final Rect damage = ai.mTmpInvalRect;
            damage.set(l, t, r, b);
            p.invalidateChild(this, damage);
        }
        // Damage the entire projection receiver, if necessary.
        if (mBackground != null && mBackground.isProjected()) {
            final View receiver = getProjectionReceiver();
            if (receiver != null) {
                receiver.damageInParent();
            }
        }
    }
}","{
    if (mGhostView != null) {
        mGhostView.invalidate(true);
        return;
    }
    if (skipInvalidate()) {
        return;
    }
    // Reset content capture caches
    mPrivateFlags4 &= ~PFLAG4_CONTENT_CAPTURE_IMPORTANCE_MASK;
    mContentCaptureSessionCached = false;
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
        if (fullInvalidate) {
            mLastIsOpaque = isOpaque();
            mPrivateFlags &= ~PFLAG_DRAWN;
        }
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        // Propagate the damage rectangle to the parent view.
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        if (p != null && ai != null && l < r && t < b) {
            final Rect damage = ai.mTmpInvalRect;
            damage.set(l, t, r, b);
            p.invalidateChild(this, damage);
        }
        // Damage the entire projection receiver, if necessary.
        if (mBackground != null && mBackground.isProjected()) {
            final View receiver = getProjectionReceiver();
            if (receiver != null) {
                receiver.damageInParent();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The update consists of changing one line that resets the content capture caches by modifying the flag `mPrivateFlags4` and setting `mContentCaptureSessionCached` to false instead of just resetting `mCachedContentCaptureSession` to null. This is considered an 'Other statement changed' since it does not affect the return value, exception handling, or control dependencies.",This change does not indicate a compatibility issue as it is related to internal state management and does not impact the external behavior of the API in terms of returning a different value or throwing a new exception.
808,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,29,30,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,0,"{
    if (mInstance.mUserSecretType == null) {
        mInstance.mUserSecretType = TYPE_LOCKSCREEN;
    }
    Preconditions.checkNotNull(mInstance.mLockScreenUiFormat);
    Preconditions.checkNotNull(mInstance.mKeyDerivationParams);
    if (mInstance.mSecret == null) {
        mInstance.mSecret = new byte[] {};
    }
    return mInstance;
}","{
    if (mInstance.mUserSecretType == null) {
        mInstance.mUserSecretType = TYPE_LOCKSCREEN;
    }
    Objects.requireNonNull(mInstance.mLockScreenUiFormat);
    Objects.requireNonNull(mInstance.mKeyDerivationParams);
    if (mInstance.mSecret == null) {
        mInstance.mSecret = new byte[] {};
    }
    return mInstance;
}",1,"/**
 * Creates a new {@link KeyChainProtectionParams} instance.
 * The instance will include default values, if {@link #setSecret}
 * or {@link #setUserSecretType} were not called.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
","/**
 * Creates a new {@link KeyChainProtectionParams} instance.
 * The instance will include default values, if {@link #setSecret}
 * or {@link #setUserSecretType} were not called.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is the replacement of Preconditions.checkNotNull with Objects.requireNonNull, which are functionally equivalent (both throw a NullPointerException), so the code change type is 4.",There is no Compatibility Issue since the behavior of the API has not been modified; both versions throw a NullPointerException when the checked object is null. The change does not affect the API's return values or the exceptions it might throw.
809,"<android.content.ContentResolver: int delete(Uri,String,String[])>",29,30,"<android.content.ContentResolver: int delete(Uri,String,String[])>","<android.content.ContentResolver: int delete(Uri,String,String[])>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.delete(url, where, selectionArgs);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mPackageName, url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    return delete(url, createSqlQueryBundle(where, selectionArgs));
}",1,"/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
","/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
",-1,[@Override],,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the delete method has been completely changed. The early version has detailed logic including null checks, acquiring a provider, handling RemoteException, and logging, while the late version simply calls another delete method with a different signature. Thus, the changes include the dependent API change (as it calls a different method) and the 'Other statement changed' due to the rewritten method body. The code change type is 4,5.","There is no Compatibility Issue detected because the late version of the method wraps the actual implementation logic into another delete method and handles the previous logic, ensuring consistent behavior with the early version."
810,<android.permission.PermissionManager.SplitPermissionInfo: int hashCode()>,29,30,<android.permission.PermissionManager.SplitPermissionInfo: int hashCode()>,<android.permission.PermissionManager.SplitPermissionInfo: int hashCode()>,0,"{
    return Objects.hash(mSplitPerm, mNewPerms, mTargetSdk);
}","{
    return mSplitPermissionInfoParcelable.hashCode();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The method of generating the hash code has been changed from using Objects.hash with multiple fields to calling hashCode on a single Parcelable object, so the change type is 1.","The manner in which the hash code is calculated has been modified, which may cause a different return value from this method. Hence, there is a potential Compatibility Issue of type 1."
811,<android.util.Half: boolean isNaN(short)>,29,30,<android.util.Half: boolean isNaN(short)>,<android.util.Half: boolean isNaN(short)>,0,"{
    return (h & FP16_COMBINED) > FP16_EXPONENT_MAX;
}","{
    return FP16.isNaN(h);
}",1,"/**
 * Returns true if the specified half-precision float value represents
 * a Not-a-Number, false otherwise.
 *
 * @param h A half-precision float value
 * @return True if the value is a NaN, false otherwise
 */
","/**
 * Returns true if the specified half-precision float value represents
 * a Not-a-Number, false otherwise.
 *
 * @param h A half-precision float value
 * @return True if the value is a NaN, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the isNaN method has changed from directly using a bitwise operation to calling FP16.isNaN(h), and it relies on another API FP16.isNaN(), so the code change type is 4,5.","There is reliance on a new method FP16.isNaN() instead of an inline bitwise operation, but if FP16.isNaN() is semantically identical to the previous implementation (checking if the value represents NaN), there would be no compatibility issue. Assuming FP16.isNaN() is correctly implemented to replace the original inline check, there is no CI. Thus, CI type is 0."
812,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",29,30,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",0,"{
    Preconditions.checkNotNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeGetResourceValue(mObject, resId, (short) densityDpi, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = mApkAssets[cookie - 1].getStringFromPool(outValue.data);
        }
        return true;
    }
}","{
    Objects.requireNonNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeGetResourceValue(mObject, resId, (short) densityDpi, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = getPooledStringForCookie(cookie, outValue.data);
        }
        return true;
    }
}",1,"/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
","/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"4,5",0,"In the early version, the null check for outValue is done using Preconditions.checkNotNull method while in the late version, it is done using Objects.requireNonNull. There is also a change in implementation of how the string value is retrieved; it replaces direct access to the mApkAssets array with a call to the new method getPooledStringForCookie(). Therefore, the code change type is 4 for the other statement change and 5 for a change in the dependent API.","Even though there are changes in method calls (Preconditions.checkNotNull to Objects.requireNonNull and access to mApkAssets with getPooledStringForCookie), these should not result in any Compatibility Issue since they are utility methods that are meant to perform the same action. As long as the intent of the methods has not changed, which in this case it seems they have not, they will not lead to different behaviors in terms of return values or exception handlings. Thus, the CI type is 0."
813,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",29,30,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(initialValues, ""initialValues"");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(initialValues, ""initialValues"");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, mAttributionTag, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
","/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method `bulkInsert` of `mContentProvider` is being called with an additional parameter `mAttributionTag` in the late version, and the Preconditions.checkNotNull method has been replaced by Objects.requireNonNull, so the code changes are of type 4 and 5.","The additional parameter in the method call can potentially change the behavior of the bulkInsert method as it introduces a new aspect that might influence how the method operates, leading to different return values, causing a Compatibility Issue of type 1. The change from Preconditions.checkNotNull to Objects.requireNonNull does not directly cause a CI because they serve the same purpose of null-checking and throwing a NullPointerException if the condition is not satisfied. However, note that the critical CI here is because the underlying `mContentProvider.bulkInsert` method now takes an additional parameter, which could lead to different outcomes."
814,<android.view.ViewConfiguration: ViewConfiguration get(Context)>,29,30,<android.view.ViewConfiguration: ViewConfiguration get(Context)>,<android.view.ViewConfiguration: ViewConfiguration get(Context)>,0,"{
    final DisplayMetrics metrics = context.getResources().getDisplayMetrics();
    final int density = (int) (100.0f * metrics.density);
    ViewConfiguration configuration = sConfigurations.get(density);
    if (configuration == null) {
        configuration = new ViewConfiguration(context);
        sConfigurations.put(density, configuration);
    }
    return configuration;
}","{
    if (!context.isUiContext() && vmIncorrectContextUseEnabled()) {
        final String errorMessage = ""Tried to access UI constants from a non-visual Context:"" + context;
        final String message = ""UI constants, such as display metrics or window metrics, "" + ""must be accessed from Activity or other visual Context. "" + ""Use an Activity or a Context created with "" + ""Context#createWindowContext(int, Bundle), which are adjusted to the "" + ""configuration and visual bounds of an area on screen"";
        final Exception exception = new IllegalArgumentException(errorMessage);
        StrictMode.onIncorrectContextUsed(message, exception);
        Log.e(TAG, errorMessage + message, exception);
    }
    final DisplayMetrics metrics = context.getResources().getDisplayMetrics();
    final int density = (int) (100.0f * metrics.density);
    ViewConfiguration configuration = sConfigurations.get(density);
    if (configuration == null) {
        configuration = new ViewConfiguration(context);
        sConfigurations.put(density, configuration);
    }
    return configuration;
}",1,"/**
 * Returns a configuration for the specified context. The configuration depends on
 * various parameters of the context, like the dimension of the display or the
 * density of the display.
 *
 * @param context The application context used to initialize the view configuration.
 */
","/**
 * Returns a configuration for the specified visual {@link Context}. The configuration depends
 * on various parameters of the {@link Context}, like the dimension of the display or the
 * density of the display.
 *
 * @param context A visual {@link Context} used to initialize the view configuration. It must
 * be {@link Activity} or other {@link Context} created with
 * {@link Context#createWindowContext(int, Bundle)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"The logic introducing a check for the context type and an execution of a strict mode violation has been added before the original logic. This constitutes a control dependency change (3) because there is a new `if` statement added, as well as an ""other statement changed"" (4) since it includes new method calls and variable declarations that are not related to return statements, exception handling, or control dependencies.","Because of the added control dependency that throws a `StrictMode` violation and logs an error, the late version of the API might trigger different exception handling in the calling client code, even though it does not explicitly use `throw`. Therefore, it could lead to a potential Compatibility Issue caused by different exception handling (2)."
815,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",29,30,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>","<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    if (!KeyEvent.isModifierKey(keyCode)) {
        mPreventDefaultMovement = false;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = getInputMethodManager();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = getInputMethodManager();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null) {
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event)) {
            return true;
        }
    }
    if (mMovement != null && mLayout != null) {
        if (mMovement.onKeyUp(this, mSpannable, keyCode, event)) {
            return true;
        }
    }
    return super.onKeyUp(keyCode, event);
}","{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    if (!KeyEvent.isModifierKey(keyCode)) {
        mPreventDefaultMovement = false;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = getInputMethodManager();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
        case KeyEvent.KEYCODE_NUMPAD_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = getInputMethodManager();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null) {
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event)) {
            return true;
        }
    }
    if (mMovement != null && mLayout != null) {
        if (mMovement.onKeyUp(this, mSpannable, keyCode, event)) {
            return true;
        }
    }
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
817,"<android.content.ContentProviderOperation: ContentValues resolveValueBackReferences(ContentProviderResult[],int)>",29,30,"<android.content.ContentProviderOperation: ContentValues resolveValueBackReferences(ContentProviderResult[],int)>","<android.content.ContentProviderOperation: ContentValues resolveValueBackReferences(ContentProviderResult[],int)>",0,"{
    if (mValuesBackReferences == null) {
        return mValues;
    }
    final ContentValues values;
    if (mValues == null) {
        values = new ContentValues();
    } else {
        values = new ContentValues(mValues);
    }
    for (Map.Entry<String, Object> entry : mValuesBackReferences.valueSet()) {
        String key = entry.getKey();
        Integer backRefIndex = mValuesBackReferences.getAsInteger(key);
        if (backRefIndex == null) {
            Log.e(TAG, this.toString());
            throw new IllegalArgumentException(""values backref "" + key + "" is not an integer"");
        }
        values.put(key, backRefToValue(backRefs, numBackRefs, backRefIndex));
    }
    return values;
}","{
    if (mValues != null) {
        final ContentValues values = new ContentValues();
        for (int i = 0; i < mValues.size(); i++) {
            final Object value = mValues.valueAt(i);
            final Object resolved;
            if (value instanceof BackReference) {
                resolved = ((BackReference) value).resolve(backRefs, numBackRefs);
            } else {
                resolved = value;
            }
            values.putObject(mValues.keyAt(i), resolved);
        }
        return values;
    } else {
        return null;
    }
}",1,"/**
 * The ContentValues back references are represented as a ContentValues object where the
 * key refers to a column and the value is an index of the back reference whose
 * valued should be associated with the column.
 * <p>
 * This is intended to be a private method but it is exposed for
 * unit testing purposes
 * @param backRefs an array of previous results
 * @param numBackRefs the number of valid previous results in backRefs
 * @return the ContentValues that should be used in this operation application after
 * expansion of back references. This can be called if either mValues or mValuesBackReferences
 * is null
 */
","/**
 * Return the values for this operation after resolving any requested
 * back-references using the given results.
 *
 * @param backRefs the results to use when resolving any back-references
 * @param numBackRefs the number of results which are valid
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method has a complete control dependency change and the recent implementation does not check for 'mValuesBackReferences' anymore. There is also a change in how 'values' is being created and used to resolve back references. The new implementation returns either new ContentValues with resolved back references or a null reference. Additionally, it uses a new method 'putObject' instead of 'put' which indicates a change in the internal method used for inserting values that potentially changes the return variable. This is a return statement changed (1), control dependency change (3), and dependent API change (5).","The alteration in control flow and the potential difference in the return values (null or ContentValues with different content) can lead to a different behavior. Specifically, the earlier version of the API could never return null, while the newer version can, which indicates a CI caused by potentially different return values or types (1)."
819,"<android.content.res.AssetManager.AssetInputStream: int read(byte[],int,int)>",29,30,"<android.content.res.AssetManager.AssetInputStream: int read(byte[],int,int)>","<android.content.res.AssetManager.AssetInputStream: int read(byte[],int,int)>",0,"{
    ensureOpen();
    Preconditions.checkNotNull(b, ""b"");
    return nativeAssetRead(mAssetNativePtr, b, off, len);
}","{
    ensureOpen();
    Objects.requireNonNull(b, ""b"");
    return nativeAssetRead(mAssetNativePtr, b, off, len);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is from Preconditions.checkNotNull(b, ""b"") to Objects.requireNonNull(b, ""b""). This is a change in the method used to check for a null reference, so the change type is 4 (Other statement changed) and 5 (Dependent API changed).","This change does not affect the behavior of the API with respect to the return value or the exception that is thrown, as both `Preconditions.checkNotNull()` and `Objects.requireNonNull()` serve the same purpose and will throw a `NullPointerException` if the passed array is null. Therefore, there is no Compatibility Issue; the CI type is 0."
820,<android.view.WindowInsets.Builder: WindowInsets build()>,29,30,<android.view.WindowInsets.Builder: WindowInsets build()>,<android.view.WindowInsets.Builder: WindowInsets build()>,0,"{
    return new WindowInsets(mSystemInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutout);
}","{
    return new WindowInsets(mSystemInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutout, systemBars(), false);
}",1,"/**
 * Builds a {@link WindowInsets} instance.
 *
 * @return the {@link WindowInsets} instance.
 */
","/**
 * Builds a {@link WindowInsets} instance.
 *
 * @return the {@link WindowInsets} instance.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,1,1,"The constructor call for `WindowInsets` has been modified to include additional parameters (systemBars(), false) in the late version, which means the return statement has changed. This is the code change type 1.","The change in the constructor call can lead to a difference in the constructed `WindowInsets` object's state, which implies potentially different return values. Therefore, the CI type is 1."
821,"<android.view.SurfaceControl.Transaction: Transaction setBufferSize(SurfaceControl,int,int)>",29,30,"<android.view.SurfaceControl.Transaction: Transaction setBufferSize(SurfaceControl,int,int)>","<android.view.SurfaceControl.Transaction: Transaction setBufferSize(SurfaceControl,int,int)>",0,"{
    sc.checkNotReleased();
    mResizedSurfaces.put(sc, new Point(w, h));
    nativeSetSize(mNativeObject, sc.mNativeObject, w, h);
    return this;
}","{
    checkPreconditions(sc);
    mResizedSurfaces.put(sc, new Point(w, h));
    nativeSetSize(mNativeObject, sc.mNativeObject, w, h);
    return this;
}",1,"/**
 * Set the default buffer size for the SurfaceControl, if there is a
 * {@link Surface} associated with the control, then
 * this will be the default size for buffers dequeued from it.
 * @param sc The surface to set the buffer size for.
 * @param w The default width
 * @param h The default height
 * @return This Transaction
 */
","/**
 * Set the default buffer size for the SurfaceControl, if there is a
 * {@link Surface} associated with the control, then
 * this will be the default size for buffers dequeued from it.
 * @param sc The surface to set the buffer size for.
 * @param w The default width
 * @param h The default height
 * @return This Transaction
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The method 'checkNotReleased()' has been replaced with 'checkPreconditions(sc)', which indicates a change in the precondition checks before executing the remaining logic, so the code change type is 4.","Despite the change in the method used to validate the preconditions, the semantics of the code in terms of functionality handled by the method are expected to remain the same – ensuring that the preconditions are met before performing the operations. Therefore, as long as 'checkPreconditions(sc)' performs the same precondition checks and does not introduce side-effects that would influence the behavior observed by the API consumers, there would be no Compatibility Issue."
822,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain(AccessibilityNodeInfo)>,29,30,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain(AccessibilityNodeInfo)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain(AccessibilityNodeInfo)>,0,"{
    AccessibilityNodeInfo infoClone = AccessibilityNodeInfo.obtain();
    infoClone.init(info);
    return infoClone;
}","{
    AccessibilityNodeInfo infoClone = AccessibilityNodeInfo.obtain();
    infoClone.init(info, true);
    return infoClone;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * create. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * @param info The other info.
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * create. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityNodeInfo(AccessibilityNodeInfo)} instead.
 *
 * @param info The other info.
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The init() method call has changed from init(info) to init(info, true), resulting in a change to the parameters of a dependent API, so the code change type is 1,5.","The second parameter in the init() method may alter the behavior of how the object is initialized, and as such, the returned object may potentially have different state or properties. Therefore, this constitutes a change in the return statement, leading to a CI type of 1."
823,<android.speech.tts.TextToSpeech: boolean isSpeaking()>,29,30,<android.speech.tts.TextToSpeech: boolean isSpeaking()>,<android.speech.tts.TextToSpeech: boolean isSpeaking()>,0,"{
    return runAction(new Action<Boolean>() {

        @Override
        public Boolean run(ITextToSpeechService service) throws RemoteException {
            return service.isSpeaking();
        }
    }, false, ""isSpeaking"");
}","{
    return runAction((ITextToSpeechService service) -> {
        return service.isSpeaking();
    }, false, ""isSpeaking"");
}",1,"/**
 * Checks whether the TTS engine is busy speaking. Note that a speech item is
 * considered complete once it's audio data has been sent to the audio mixer, or
 * written to a file. There might be a finite lag between this point, and when
 * the audio hardware completes playback.
 *
 * @return {@code true} if the TTS engine is speaking.
 */
","/**
 * Checks whether the TTS engine is busy speaking. Note that a speech item is
 * considered complete once it's audio data has been sent to the audio mixer, or
 * written to a file. There might be a finite lag between this point, and when
 * the audio hardware completes playback.
 *
 * @return {@code true} if the TTS engine is speaking.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change happened in the lambda expression syntax. The early version uses an anonymous inner class, while the late version uses a lambda expression for the Action<Boolean>(). This is a syntactic change that does not affect the behavior of the code, so the code change type is 4.","There is no Compatibility Issue because the transformation from the anonymous inner class to a lambda expression does not change the functional behavior of the code. The method still performs the same action and returns the same type of result. Therefore, the CI type is 0."
824,<android.app.Notification.BubbleMetadata.Builder: BubbleMetadata build()>,29,30,<android.app.Notification.BubbleMetadata.Builder: BubbleMetadata build()>,<android.app.Notification.BubbleMetadata.Builder: BubbleMetadata build()>,0,"{
    if (mPendingIntent == null) {
        throw new IllegalStateException(""Must supply pending intent to bubble"");
    }
    if (mIcon == null) {
        throw new IllegalStateException(""Must supply an icon for the bubble"");
    }
    BubbleMetadata data = new BubbleMetadata(mPendingIntent, mDeleteIntent, mIcon, mDesiredHeight, mDesiredHeightResId);
    data.setFlags(mFlags);
    return data;
}","{
    if (mShortcutId == null && mPendingIntent == null) {
        throw new NullPointerException(""Must supply pending intent or shortcut to bubble"");
    }
    if (mShortcutId == null && mIcon == null) {
        throw new NullPointerException(""Must supply an icon or shortcut for the bubble"");
    }
    BubbleMetadata data = new BubbleMetadata(mPendingIntent, mDeleteIntent, mIcon, mDesiredHeight, mDesiredHeightResId, mShortcutId);
    data.setFlags(mFlags);
    return data;
}",1,"/**
 * Creates the {@link BubbleMetadata} defined by this builder.
 *
 * @throws IllegalStateException if {@link #setIntent(PendingIntent)} and/or
 * {@link #setIcon(Icon)} have not been called on this
 * builder.
 */
","/**
 * Creates the {@link BubbleMetadata} defined by this builder.
 *
 * @throws NullPointerException if required elements have not been set.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"2,3,5",2,"The exception that is thrown has changed from IllegalStateException to NullPointerException, and the control statements (if conditions) have been altered to include checks for mShortcutId. Additionally, there is a change in the constructor call to 'BubbleMetadata' which now includes mShortcutId as an additional parameter. Thus, the code change types are 2, 3, and 5.","Since the new version throws a different exception (NullPointerException instead of IllegalStateException) under the same conditions and also the condition upon which the exception is thrown has changed (also checks for mShortcutId now), the behavior of the API can differ for the same inputs. Therefore, the CI type is 2."
825,<android.gesture.GestureLibraries.FileGestureLibrary: boolean save()>,29,30,<android.gesture.GestureLibraries.FileGestureLibrary: boolean save()>,<android.gesture.GestureLibraries.FileGestureLibrary: boolean save()>,0,"{
    if (!mStore.hasChanged())
        return true;
    final File file = mPath;
    final File parentFile = file.getParentFile();
    if (!parentFile.exists()) {
        if (!parentFile.mkdirs()) {
            return false;
        }
    }
    boolean result = false;
    try {
        // noinspection ResultOfMethodCallIgnored
        file.createNewFile();
        mStore.save(new FileOutputStream(file), true);
        result = true;
    } catch (FileNotFoundException e) {
        Log.d(LOG_TAG, ""Could not save the gesture library in "" + mPath, e);
    } catch (IOException e) {
        Log.d(LOG_TAG, ""Could not save the gesture library in "" + mPath, e);
    }
    return result;
}","{
    if (!mStore.hasChanged())
        return true;
    boolean result = false;
    if (mPath != null) {
        final File file = mPath;
        final File parentFile = file.getParentFile();
        if (!parentFile.exists()) {
            if (!parentFile.mkdirs()) {
                return false;
            }
        }
        try {
            // noinspection ResultOfMethodCallIgnored
            file.createNewFile();
            mStore.save(new FileOutputStream(file), true);
            result = true;
        } catch (IOException e) {
            Log.d(LOG_TAG, ""Could not save the gesture library in "" + mPath, e);
        }
    } else {
        try {
            mStore.save(new FileOutputStream(mFd), true);
            result = true;
        } catch (IOException e) {
            Log.d(LOG_TAG, ""Could not save the gesture library"", e);
        }
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early version has a FileNotFoundException handling statement, which is removed in the late version. A new control dependency on whether 'mPath' is null has been introduced, and new logic for saving the gesture library using 'mFd' is added in the late version. As a result, the changes include return statement change (1), control dependency change (3), and other statement change (4).","There is a change in the return statement potentially leading to different return values due to the additional check for 'mPath' being null and the usage of 'mFd', and the exception handling for FileNotFoundException is not available in the late version which may lead to different exception behavior. Therefore, the combination of these changes can potentially lead to different return values and different exceptions being thrown. Hence, we have CI types 1 and 2."
827,<android.net.RouteInfo: boolean equals(Object)>,29,30,<android.net.RouteInfo: boolean equals(Object)>,<android.net.RouteInfo: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (!(obj instanceof RouteInfo))
        return false;
    RouteInfo target = (RouteInfo) obj;
    return Objects.equals(mDestination, target.getDestination()) && Objects.equals(mGateway, target.getGateway()) && Objects.equals(mInterface, target.getInterface()) && mType == target.getType();
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof RouteInfo))
        return false;
    RouteInfo target = (RouteInfo) obj;
    return Objects.equals(mDestination, target.getDestination()) && Objects.equals(mGateway, target.getGateway()) && Objects.equals(mInterface, target.getInterface()) && mType == target.getType() && mMtu == target.getMtu();
}",1,"/**
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
","/**
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"An additional conditional check for equality of `mMtu == target.getMtu()` was added to the return statement, thus altering the potential result of the method. Therefore, the change type is 1.","The new condition in the return statement introduces the possibility that two RouteInfo objects that would have been considered equal in the earlier version will not be equal in the later version if their MTUs differ. Consequently, the behavior when invoking equals can differ between the versions, leading to a CI type of 1."
829,"<android.view.inputmethod.BaseInputConnection: boolean deleteSurroundingText(int,int)>",29,30,"<android.view.inputmethod.BaseInputConnection: boolean deleteSurroundingText(int,int)>","<android.view.inputmethod.BaseInputConnection: boolean deleteSurroundingText(int,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""deleteSurroundingText "" + beforeLength + "" / "" + afterLength);
    final Editable content = getEditable();
    if (content == null)
        return false;
    beginBatchEdit();
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // Ignore the composing text.
    int ca = getComposingSpanStart(content);
    int cb = getComposingSpanEnd(content);
    if (cb < ca) {
        int tmp = ca;
        ca = cb;
        cb = tmp;
    }
    if (ca != -1 && cb != -1) {
        if (ca < a)
            a = ca;
        if (cb > b)
            b = cb;
    }
    int deleted = 0;
    if (beforeLength > 0) {
        int start = a - beforeLength;
        if (start < 0)
            start = 0;
        content.delete(start, a);
        deleted = a - start;
    }
    if (afterLength > 0) {
        b = b - deleted;
        int end = b + afterLength;
        if (end > content.length())
            end = content.length();
        content.delete(b, end);
    }
    endBatchEdit();
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""deleteSurroundingText "" + beforeLength + "" / "" + afterLength);
    final Editable content = getEditable();
    if (content == null)
        return false;
    beginBatchEdit();
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // Skip when the selection is not yet attached.
    if (a == -1 || b == -1) {
        endBatchEdit();
        return false;
    }
    // Ignore the composing text.
    int ca = getComposingSpanStart(content);
    int cb = getComposingSpanEnd(content);
    if (cb < ca) {
        int tmp = ca;
        ca = cb;
        cb = tmp;
    }
    if (ca != -1 && cb != -1) {
        if (ca < a)
            a = ca;
        if (cb > b)
            b = cb;
    }
    int deleted = 0;
    if (beforeLength > 0) {
        int start = a - beforeLength;
        if (start < 0)
            start = 0;
        final int numDeleteBefore = a - start;
        if (a >= 0 && numDeleteBefore > 0) {
            content.delete(start, a);
            deleted = numDeleteBefore;
        }
    }
    if (afterLength > 0) {
        b = b - deleted;
        int end = b + afterLength;
        if (end > content.length())
            end = content.length();
        final int numDeleteAfter = end - b;
        if (b >= 0 && numDeleteAfter > 0) {
            content.delete(b, end);
        }
    }
    endBatchEdit();
    return true;
}",1,"/**
 * The default implementation performs the deletion around the current selection position of the
 * editable text.
 *
 * @param beforeLength The number of characters before the cursor to be deleted, in code unit.
 * If this is greater than the number of existing characters between the beginning of the
 * text and the cursor, then this method does not fail but deletes all the characters in
 * that range.
 * @param afterLength The number of characters after the cursor to be deleted, in code unit.
 * If this is greater than the number of existing characters between the cursor and
 * the end of the text, then this method does not fail but deletes all the characters in
 * that range.
 */
","/**
 * The default implementation performs the deletion around the current selection position of the
 * editable text.
 *
 * @param beforeLength The number of characters before the cursor to be deleted, in code unit.
 * If this is greater than the number of existing characters between the beginning of the
 * text and the cursor, then this method does not fail but deletes all the characters in
 * that range.
 * @param afterLength The number of characters after the cursor to be deleted, in code unit.
 * If this is greater than the number of existing characters between the cursor and
 * the end of the text, then this method does not fail but deletes all the characters in
 * that range.
 *
 * @return {@code true} when selected text is deleted, {@code false} when either the
 * selection is invalid or not yet attached (i.e. selection start or end is -1),
 * or the editable text is {@code null}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code changes include the introduction of a new selection check condition ""if (a == -1 || b == -1)"" and the introduction of additional checks before executing the content.delete(start, a) and content.delete(b, end) methods which check if the deletion range is greater than zero. Since this adds new control dependencies and conditional checks, the code change types are 3,4.","Because the behavior of the method may change due to the new selection check (possibly returning false when previously it would not have), and new bounds checks on the deletions (potentially avoiding deletions that would have occurred), these changes could potentially cause the method to return different values. Thus, the CI type is 1."
830,<android.view.textclassifier.TextClassifier: ConversationActions suggestConversationActions(Request)>,29,30,<android.view.textclassifier.TextClassifier: ConversationActions suggestConversationActions(Request)>,<android.view.textclassifier.TextClassifier: ConversationActions suggestConversationActions(Request)>,0,"{
    Preconditions.checkNotNull(request);
    Utils.checkMainThread();
    return new ConversationActions(Collections.emptyList(), null);
}","{
    Objects.requireNonNull(request);
    Utils.checkMainThread();
    return new ConversationActions(Collections.emptyList(), null);
}",1,"/**
 * Suggests and returns a list of actions according to the given conversation.
 */
","/**
 * Suggests and returns a list of actions according to the given conversation.
 */
",-1,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",0,"The change is from Preconditions.checkNotNull(request) to Objects.requireNonNull(request), which are equivalent operations from different utility classes to check for non-null values. Also, there are no changes to annotations, so the code change type is 4,5.","Since both versions perform a null check and throw a NullPointerException if the 'request' is null, and the rest of the code and annotations remains the same, there is no behavioural change that could lead to a Compatibility Issue. Thus, the CI type is 0."
831,<android.os.ParcelFileDescriptor: void finalize()>,29,30,<android.os.ParcelFileDescriptor: void finalize()>,<android.os.ParcelFileDescriptor: void finalize()>,0,"{
    if (mWrapped != null) {
        releaseResources();
    }
    if (mGuard != null) {
        mGuard.warnIfOpen();
    }
    try {
        if (!mClosed) {
            closeWithStatus(Status.LEAKED, null);
        }
    } finally {
        super.finalize();
    }
}","{
    if (mWrapped != null) {
        releaseResources();
    }
    if (mGuard != null) {
        mGuard.warnIfOpen();
    }
    try {
        if (!mClosed) {
            // mWrapped was and is null.
            closeWithStatus(Status.LEAKED, null);
        }
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the addition of a comment. This does not affect the behavior of the code at all, hence the change type is 4 (Other statement changed).","Comments do not affect the execution or the behavior of the code; therefore, there is no Compatibility Issue arising from this change."
832,<android.net.Uri.AbstractPart: void writeTo(Parcel)>,29,30,<android.net.Uri.AbstractPart: void writeTo(Parcel)>,<android.net.Uri.AbstractPart: void writeTo(Parcel)>,0,"{
    @SuppressWarnings(""StringEquality"") boolean hasEncoded = encoded != NOT_CACHED;
    @SuppressWarnings(""StringEquality"") boolean hasDecoded = decoded != NOT_CACHED;
    if (hasEncoded && hasDecoded) {
        parcel.writeInt(Representation.BOTH);
        parcel.writeString(encoded);
        parcel.writeString(decoded);
    } else if (hasEncoded) {
        parcel.writeInt(Representation.ENCODED);
        parcel.writeString(encoded);
    } else if (hasDecoded) {
        parcel.writeInt(Representation.DECODED);
        parcel.writeString(decoded);
    } else {
        throw new IllegalArgumentException(""Neither encoded nor decoded"");
    }
}","{
    final String canonicalValue;
    if (mCanonicalRepresentation == REPRESENTATION_ENCODED) {
        canonicalValue = encoded;
    } else if (mCanonicalRepresentation == REPRESENTATION_DECODED) {
        canonicalValue = decoded;
    } else {
        throw new IllegalArgumentException(""Unknown representation: "" + mCanonicalRepresentation);
    }
    if (canonicalValue == NOT_CACHED) {
        throw new AssertionError(""Canonical value not cached ("" + mCanonicalRepresentation + "")"");
    }
    parcel.writeInt(mCanonicalRepresentation);
    parcel.writeString8(canonicalValue);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The method's structure has been significantly reworked, involving changes in the control statements and the logic for constructing the exception messages. Additionally, a different method (parcel.writeString8) is now used in place of parcel.writeString. Furthermore, the conditions for triggering a thrown exception and the exception messages themselves have changed. These modifications consist of changes in return statements, exception handling statements, control dependencies, and other statements, hence the code change types are 1,2,3,4.","These changes can potentially lead to different return values (due to changes in what is written to the Parcel) and different exception handlings (due to the changed conditions and messages in the thrown exceptions). Therefore, the potential Compatibility Issues caused by different return values or types, and different exception handlings are type 1 and 2, respectively."
833,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,29,30,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,0,"{
    if (!getLeAccess()) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isOffloadedFilteringSupported();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedFilteringSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (!getLeAccess()) {
        return false;
    }
    return mBluetoothFilteringCache.query(null);
}",1,"/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */
","/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The return statement is changed because in the early version, it accessed a service to determine if offloaded filtering is supported, whereas in the late version, it directly queries a BluetoothFilteringCache object. Additionally, the exception handling for RemoteException is removed, and the read lock on the mServiceLock's readLock is no longer being used. These changes include a new method query on the mBluetoothFilteringCache object, which means a dependent API and other statements are changed. The control flow related to the lock and service check has been removed. Therefore, the changes include types 1, 4, and 5.","The return value could be different due to the different methods of determining the support for offloaded filtering. The elimination of the exception handling for RemoteException can also cause different behavior because earlier code used to catch and log this exception, while the newer code could let it propagate upwards if it were to happen. This would result in a potential difference in exception handling and return values; thus, CI types 1 and 2 apply."
834,"<android.app.admin.DevicePolicyManager: boolean setApplicationHidden(ComponentName,String,boolean)>",29,30,"<android.app.admin.DevicePolicyManager: boolean setApplicationHidden(ComponentName,String,boolean)>","<android.app.admin.DevicePolicyManager: boolean setApplicationHidden(ComponentName,String,boolean)>",0,"{
    throwIfParentInstance(""setApplicationHidden"");
    if (mService != null) {
        try {
            return mService.setApplicationHidden(admin, mContext.getPackageName(), packageName, hidden);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.setApplicationHidden(admin, mContext.getPackageName(), packageName, hidden, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Hide or unhide packages. When a package is hidden it is unavailable for use, but the data and
 * actual package file remain. This function can be called by a device owner, profile owner, or
 * by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to hide or unhide.
 * @param hidden {@code true} if the package should be hidden, {@code false} if it should be
 * unhidden.
 * @return boolean Whether the hidden setting of the package was successfully updated.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
","/**
 * Hide or unhide packages. When a package is hidden it is unavailable for use, but the data and
 * actual package file remain. This function can be called by a device owner, profile owner, or
 * by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance, returned by
 * {@link #getParentProfileInstance(ComponentName)}, where the caller must be the profile owner
 * of an organization-owned managed profile and the package must be a system package. If called
 * on the parent instance, then the package is hidden or unhidden in the personal profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to hide or unhide.
 * @param hidden {@code true} if the package should be hidden, {@code false} if it should be
 * unhidden.
 * @return boolean Whether the hidden setting of the package was successfully updated.
 * @throws SecurityException if {@code admin} is not a device or profile owner or if called on
 * the parent profile and the {@code admin} is not a profile owner of an
 * organization-owned managed profile.
 * @throws IllegalArgumentException if called on the parent profile and the package provided
 * is not a system package.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation has changed due to the removal of the call to throwIfParentInstance and the addition of a new parameter (mParentInstance) to the call of mService.setApplicationHidden. Therefore, the code change type is 4 (Other statement changed) and 5 (Dependent API changed).","Modification in the call to the dependent API (mService.setApplicationHidden) by adding a new parameter can result in the API potentially returning a different value, thus resulting in a Compatibility Issue type of 1."
835,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,29,30,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""title="").append(mTitle);
    builder.append("", id="").append(mId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", bounds="").append(mBoundsInScreen);
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    builder.append("", pictureInPicture="").append(isInPictureInPictureMode());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED_WINDOW_ID);
        builder.append("", isAnchored="").append(mAnchorId != AccessibilityNodeInfo.UNDEFINED_NODE_ID);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""title="").append(mTitle);
    builder.append("", displayId="").append(mDisplayId);
    builder.append("", id="").append(mId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", region="").append(mRegionInScreen);
    builder.append("", bounds="").append(mRegionInScreen.getBounds());
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    builder.append("", pictureInPicture="").append(isInPictureInPictureMode());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED_WINDOW_ID);
        builder.append("", isAnchored="").append(mAnchorId != AccessibilityNodeInfo.UNDEFINED_NODE_ID);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The code change includes the addition and modification of several append statements to the StringBuilder, such as the inclusion of ""displayId="" with mDisplayId, ""region="" with mRegionInScreen instead of ""bounds="", and the added method call to getBounds() on mRegionInScreen. This change does not affect control flow or dependent APIs, but it directly alters the returned string by changing the structure of the toString() representation, therefore the change type is 1,4.","The change in the stringBuilder pattern, which includes additional information and changes existing information, will result in a different return value (the string representation of the object), so the CI type is 1."
839,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>",29,30,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>",0,"{
    if (DEBUG) {
        Log.d(TAG, String.format(""Device error received, code %d, frame number %d, request ID %d, subseq ID %d"", errorCode, resultExtras.getFrameNumber(), resultExtras.getRequestId(), resultExtras.getSubsequenceId()));
    }
    synchronized (mInterfaceLock) {
        if (mRemoteDevice == null) {
            // Camera already closed
            return;
        }
        switch(errorCode) {
            case ERROR_CAMERA_DISCONNECTED:
                final long ident = Binder.clearCallingIdentity();
                try {
                    CameraDeviceImpl.this.mDeviceExecutor.execute(mCallOnDisconnected);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
                break;
            case ERROR_CAMERA_REQUEST:
            case ERROR_CAMERA_RESULT:
            case ERROR_CAMERA_BUFFER:
                onCaptureErrorLocked(errorCode, resultExtras);
                break;
            case ERROR_CAMERA_DEVICE:
                scheduleNotifyError(StateCallback.ERROR_CAMERA_DEVICE);
                break;
            case ERROR_CAMERA_DISABLED:
                scheduleNotifyError(StateCallback.ERROR_CAMERA_DISABLED);
                break;
            default:
                Log.e(TAG, ""Unknown error from camera device: "" + errorCode);
                scheduleNotifyError(StateCallback.ERROR_CAMERA_SERVICE);
        }
    }
}","{
    CameraDeviceImpl.this.onDeviceError(errorCode, resultExtras);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The internal implementation of the method has been fully streamlined to a single method call, CameraDeviceImpl.this.onDeviceError(errorCode, resultExtras), so this signals that there has been a change in the dependent API. Consequently, the change type is 4,5.","Since there has been an overhaul to the dependency methods and the originally detailed implementation for handling various errors is now replaced by a single method call, this implies a potential difference in behavior. It is not possible to determine from the information given whether the onDeviceError method of the CameraDeviceImpl class itself has been changed or not. If the onDeviceError method implements similar logic as found in this earlier version, then the change should not introduce compatibility issues. However, if the implementation differs, this could potentially result in different return values or exception handlings. Therefore, considering the available information, there is a potential Compatibility Issue caused by potential different return values or types (type 1)."
841,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,29,30,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,0,"{
    Preconditions.checkNotNull(name, ""name"");
    IContentProvider provider = acquireUnstableProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, name, false);
    }
    return null;
}","{
    Objects.requireNonNull(name, ""name"");
    IContentProvider provider = acquireUnstableProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, name, false);
    }
    return null;
}",1,"/**
 * Like {@link #acquireContentProviderClient(String)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
","/**
 * Like {@link #acquireContentProviderClient(String)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The implementation change is only in the null-check method, from Preconditions.checkNotNull(name, ""name"") to Objects.requireNonNull(name, ""name""). This constitutes an 'Other statement changed' type as it does not affect control flow, returns, exception handling, or dependent APIs directly. It is merely a change in the method used for the null check, which functions equivalently.",There is no Compatibility Issue since replacing Preconditions.checkNotNull with Objects.requireNonNull does not affect the behaviour of the method; both will throw a NullPointerException if 'name' is null. The return values and exception handlings remain the same. The changed method for null-checking has the same semantics.
843,"<android.accessibilityservice.AccessibilityService: void onPerformGestureResult(int,boolean)>",29,30,"<android.accessibilityservice.AccessibilityService: void onPerformGestureResult(int,boolean)>","<android.accessibilityservice.AccessibilityService: void onPerformGestureResult(int,boolean)>",0,"{
    if (mGestureStatusCallbackInfos == null) {
        return;
    }
    GestureResultCallbackInfo callbackInfo;
    synchronized (mLock) {
        callbackInfo = mGestureStatusCallbackInfos.get(sequence);
    }
    final GestureResultCallbackInfo finalCallbackInfo = callbackInfo;
    if ((callbackInfo != null) && (callbackInfo.gestureDescription != null) && (callbackInfo.callback != null)) {
        if (callbackInfo.handler != null) {
            callbackInfo.handler.post(new Runnable() {

                @Override
                public void run() {
                    if (completedSuccessfully) {
                        finalCallbackInfo.callback.onCompleted(finalCallbackInfo.gestureDescription);
                    } else {
                        finalCallbackInfo.callback.onCancelled(finalCallbackInfo.gestureDescription);
                    }
                }
            });
            return;
        }
        if (completedSuccessfully) {
            callbackInfo.callback.onCompleted(callbackInfo.gestureDescription);
        } else {
            callbackInfo.callback.onCancelled(callbackInfo.gestureDescription);
        }
    }
}","{
    if (mGestureStatusCallbackInfos == null) {
        return;
    }
    GestureResultCallbackInfo callbackInfo;
    synchronized (mLock) {
        callbackInfo = mGestureStatusCallbackInfos.get(sequence);
        mGestureStatusCallbackInfos.remove(sequence);
    }
    final GestureResultCallbackInfo finalCallbackInfo = callbackInfo;
    if ((callbackInfo != null) && (callbackInfo.gestureDescription != null) && (callbackInfo.callback != null)) {
        if (callbackInfo.handler != null) {
            callbackInfo.handler.post(new Runnable() {

                @Override
                public void run() {
                    if (completedSuccessfully) {
                        finalCallbackInfo.callback.onCompleted(finalCallbackInfo.gestureDescription);
                    } else {
                        finalCallbackInfo.callback.onCancelled(finalCallbackInfo.gestureDescription);
                    }
                }
            });
            return;
        }
        if (completedSuccessfully) {
            callbackInfo.callback.onCompleted(callbackInfo.gestureDescription);
        } else {
            callbackInfo.callback.onCancelled(callbackInfo.gestureDescription);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new line ""mGestureStatusCallbackInfos.remove(sequence);"" added in the synchronized block of the late version. This change is not related to return statements, exception handling, control dependencies, or dependent API. So the code change type is 4.","The newly introduced line is only modifying the internal state (removing an item from the map), but because it does not change the control flow or result of the method, nor does it introduce a new exception or outcome, there should be no compatibility issue as a result of this change. The behavior of the API as observed by its output and potential side effects when the method is called remains the same, hence no compatibility issue, which is 0."
844,<android.util.Half: short trunc(short)>,29,30,<android.util.Half: short trunc(short)>,<android.util.Half: short trunc(short)>,0,"{
    int bits = h & 0xffff;
    int e = bits & 0x7fff;
    int result = bits;
    if (e < 0x3c00) {
        result &= FP16_SIGN_MASK;
    } else if (e < 0x6400) {
        e = 25 - (e >> 10);
        int mask = (1 << e) - 1;
        result &= ~mask;
    }
    return (short) result;
}","{
    return FP16.trunc(h);
}",1,"/**
 * Returns the truncated half-precision float value of the specified
 * half-precision float value. Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The truncated half-precision float value of the specified
 * half-precision float value
 */
","/**
 * Returns the truncated half-precision float value of the specified
 * half-precision float value. Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The truncated half-precision float value of the specified
 * half-precision float value
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,5,No Compatibility Issue,"The implementation of the method has changed to use a dependent API FP16.trunc(), so the change is of type 5.","While the internal implementation of the 'trunc' function has been replaced with a call to a presumably equivalent method within the FP16 class, this does not in itself constitute a compatibility issue if the behavior of FP16.trunc(short) is assumed to be identical to the early version's logic. There's no inherent change in the output type or exception behavior solely based on the change to the dependent API. Therefore, there is no compatibility issue assuming FP16.trunc() is a drop-in replacement with no changes to the behavior."
845,<android.view.Surface.HwuiContext: void unlockAndPost(Canvas)>,29,30,<android.view.Surface.HwuiContext: void unlockAndPost(Canvas)>,<android.view.Surface.HwuiContext: void unlockAndPost(Canvas)>,0,"{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    mRenderNode.endRecording();
    mCanvas = null;
    nHwuiDraw(mHwuiRenderer);
}","{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    mRenderNode.endRecording();
    mCanvas = null;
    mHardwareRenderer.createRenderRequest().setVsyncTime(System.nanoTime()).syncAndDraw();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is the replacement of the method `nHwuiDraw(mHwuiRenderer)` with `mHardwareRenderer.createRenderRequest().setVsyncTime(System.nanoTime()).syncAndDraw()`, and it represents a change in method calls but not in the control flow or the potential return type or value, so the change type is 4,5.","Since neither the return type/value nor the exception handling has changed, there is no Compatibility Issue in terms of different return values or exception handlings; hence, the CI type is 0."
846,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",29,30,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData();
        intents[i].prepareToLeaveProcess(context);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, context.getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData(context);
        intents[i].prepareToLeaveProcess(context);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManager.getService().getIntentSenderWithFeature(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, context.getAttributionTag(), null, null, requestCode, intents, resolvedTypes, flags, options, context.getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method invocation intents[i].migrateExtraStreamToClipData() has been modified to intents[i].migrateExtraStreamToClipData(context) with an additional parameter being passed and the call to ActivityManager.getService().getIntentSender() has been changed to ActivityManager.getService().getIntentSenderWithFeature(). In both cases, there has been a change in the dependent APIs being used. Additionally, a new context.getAttributionTag() parameter is added to the call, also indicating a change in dependent API. This corresponds to change type 4 (other statement changed) and type 5 (dependent API changed).","There is no Compatibility Issue detected here. Despite the changes to the method invocations and inclusion of additional parameters, the behavior of the getActivities method is expected to be consistent between versions. The method's purpose is to prepare Intent instances for use outside of the context and retrieve a PendingIntent, which it still does without altering the expected return type or throwing new exceptions. Therefore, it is classified as no Compatibility Issue (0)."
847,<android.speech.tts.TextToSpeech: Set<Locale> getAvailableLanguages()>,29,30,<android.speech.tts.TextToSpeech: Set<Locale> getAvailableLanguages()>,<android.speech.tts.TextToSpeech: Set<Locale> getAvailableLanguages()>,0,"{
    return runAction(new Action<Set<Locale>>() {

        @Override
        public Set<Locale> run(ITextToSpeechService service) throws RemoteException {
            List<Voice> voices = service.getVoices();
            if (voices == null) {
                return new HashSet<Locale>();
            }
            HashSet<Locale> locales = new HashSet<Locale>();
            for (Voice voice : voices) {
                locales.add(voice.getLocale());
            }
            return locales;
        }
    }, null, ""getAvailableLanguages"");
}","{
    return runAction((ITextToSpeechService service) -> {
        List<Voice> voices = service.getVoices();
        if (voices == null) {
            return new HashSet<Locale>();
        }
        HashSet<Locale> locales = new HashSet<Locale>();
        for (Voice voice : voices) {
            locales.add(voice.getLocale());
        }
        return locales;
    }, null, ""getAvailableLanguages"");
}",1,"/**
 * Query the engine about the set of available languages.
 */
","/**
 * Query the engine about the set of available languages.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only about using a lambda expression instead of an anonymous inner class, with no change in the logic of the code, so the code change type is 4.","The replacement of the anonymous inner class with a lambda does not alter the actual functionality of the method; hence, there are no compatibility issues. The method will still return the same values, and still throw the same exceptions if any occur during execution, so the CI type is 0."
848,"<android.content.ContentResolver: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",29,30,"<android.content.ContentResolver: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>","<android.content.ContentResolver: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",0,"{
    Preconditions.checkNotNull(authority, ""authority"");
    Preconditions.checkNotNull(operations, ""operations"");
    try {
        if (mWrapped != null)
            return mWrapped.applyBatch(authority, operations);
    } catch (RemoteException e) {
        return null;
    }
    ContentProviderClient provider = acquireContentProviderClient(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        return provider.applyBatch(operations);
    } finally {
        provider.release();
    }
}","{
    Objects.requireNonNull(authority, ""authority"");
    Objects.requireNonNull(operations, ""operations"");
    try {
        if (mWrapped != null)
            return mWrapped.applyBatch(authority, operations);
    } catch (RemoteException e) {
        return null;
    }
    ContentProviderClient provider = acquireContentProviderClient(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        return provider.applyBatch(operations);
    } finally {
        provider.release();
    }
}",1,"/**
 * Applies each of the {@link ContentProviderOperation} objects and returns an array
 * of their results. Passes through OperationApplicationException, which may be thrown
 * by the call to {@link ContentProviderOperation#apply}.
 * If all the applications succeed then a {@link ContentProviderResult} array with the
 * same number of elements as the operations will be returned. It is implementation-specific
 * how many, if any, operations will have been successfully applied if a call to
 * apply results in a {@link OperationApplicationException}.
 * @param authority the authority of the ContentProvider to which this batch should be applied
 * @param operations the operations to apply
 * @return the results of the applications
 * @throws OperationApplicationException thrown if an application fails.
 * See {@link ContentProviderOperation#apply} for more information.
 * @throws RemoteException thrown if a RemoteException is encountered while attempting
 * to communicate with a remote provider.
 */
","/**
 * Applies each of the {@link ContentProviderOperation} objects and returns an array
 * of their results. Passes through OperationApplicationException, which may be thrown
 * by the call to {@link ContentProviderOperation#apply}.
 * If all the applications succeed then a {@link ContentProviderResult} array with the
 * same number of elements as the operations will be returned. It is implementation-specific
 * how many, if any, operations will have been successfully applied if a call to
 * apply results in a {@link OperationApplicationException}.
 * @param authority the authority of the ContentProvider to which this batch should be applied
 * @param operations the operations to apply
 * @return the results of the applications
 * @throws OperationApplicationException thrown if an application fails.
 * See {@link ContentProviderOperation#apply} for more information.
 * @throws RemoteException thrown if a RemoteException is encountered while attempting
 * to communicate with a remote provider.
 */
",-1,"[@Override, @NonNull]","[@Override, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"The only code change is the replacement of Preconditions.checkNotNull() with Objects.requireNonNull() methods, which serve the same purpose and do not alter the API behavior. Therefore, the type of the change is 4 (Other statement changed).","This change does not represent a Compatibility Issue because both methods are used to ensure that the provided arguments are not null and will throw the same type of exception (NullPointerException) if they are. Hence, there is no change in the possible return values or the exceptions that this method can throw. The method's contract remains the same with respect to the caller."
851,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,29,30,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,0,"{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return getAuthenticatorTypesAsUser(mContext.getUserId());
}",1,"/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
","/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
",-1,,[@UserHandleAware],-1,-1,-1,-1,-1,-1,"4,5",0,The implementation method has changed from directly calling mService.getAuthenticatorTypes with UserHandle.getCallingUserId() to calling a new method getAuthenticatorTypesAsUser with mContext.getUserId(). This is considered a different implementation (code change type 4) and a change in a dependent API (code change type 5).,"A change in dependent API does not necessarily lead to a different behavior because the replacement API is assumed to provide the same functionality but possibly for the current user context. Hence, there is no compatibility issue expected (CI type 0), since it seems like an internal change that doesn't affect the external behavior of the method."
854,<android.service.voice.AlwaysOnHotwordDetector: Intent createUnEnrollIntent()>,29,30,<android.service.voice.AlwaysOnHotwordDetector: Intent createUnEnrollIntent()>,<android.service.voice.AlwaysOnHotwordDetector: Intent createUnEnrollIntent()>,0,"{
    if (DBG)
        Slog.d(TAG, ""createUnEnrollIntent"");
    synchronized (mLock) {
        return getManageIntentLocked(MANAGE_ACTION_UN_ENROLL);
    }
}","{
    if (DBG)
        Slog.d(TAG, ""createUnEnrollIntent"");
    synchronized (mLock) {
        return getManageIntentLocked(KeyphraseEnrollmentInfo.MANAGE_ACTION_UN_ENROLL);
    }
}",1,"/**
 * Creates an intent to start the un-enrollment for the associated keyphrase.
 * This intent must be invoked using {@link Activity#startActivityForResult(Intent, int)}.
 * Starting re-enrollment is only valid if the keyphrase is already enrolled,
 * i.e. {@link #STATE_KEYPHRASE_ENROLLED}, otherwise invoking this may result in an error.
 *
 * @return An {@link Intent} to start un-enrollment for the given keyphrase.
 * @throws UnsupportedOperationException if managing they keyphrase isn't supported.
 * Callers should only call this method after a supported state callback on
 * {@link Callback#onAvailabilityChanged(int)} to avoid this exception.
 * @throws IllegalStateException if the detector is in an invalid state.
 * This may happen if another detector has been instantiated or the
 * {@link VoiceInteractionService} hosting this detector has been shut down.
 */
","/**
 * Creates an intent to start the un-enrollment for the associated keyphrase.
 * This intent must be invoked using {@link Context#startForegroundService(Intent)}.
 * Starting re-enrollment is only valid if the keyphrase is already enrolled,
 * i.e. {@link #STATE_KEYPHRASE_ENROLLED}, otherwise invoking this may result in an error.
 *
 * @return An {@link Intent} to start un-enrollment for the given keyphrase.
 * @throws UnsupportedOperationException if managing they keyphrase isn't supported.
 * Callers should only call this method after a supported state callback on
 * {@link Callback#onAvailabilityChanged(int)} to avoid this exception.
 * @throws IllegalStateException if the detector is in an invalid state.
 * This may happen if another detector has been instantiated or the
 * {@link VoiceInteractionService} hosting this detector has been shut down.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is within the getManageIntentLocked() method call, where the parameter has changed from MANAGE_ACTION_UN_ENROLL to KeyphraseEnrollmentInfo.MANAGE_ACTION_UN_ENROLL. This suggests that there is a change in the dependent API, thus the code change type is 5. ","There is no Compatibility Issue because the change is strictly in the constant value passed to a method, and it is likely that the value of this constant remains the same between versions (assuming that KeyphraseEnrollmentInfo.MANAGE_ACTION_UN_ENROLL is the same as the previous MANAGE_ACTION_UN_ENROLL). This type of change typically indicates a refactoring or clarification of code, rather than a change in behavior. Thus, unless MANAGE_ACTION_UN_ENROLL has a different value in KeyphraseEnrollmentInfo, which is uncertain with the given data, we do not expect a different value to be returned or a different exception to be thrown based on the given information."
855,<android.view.textclassifier.TextClassificationConstants: boolean isSmartLinkifyEnabled()>,29,30,<android.view.textclassifier.TextClassificationConstants: boolean isSmartLinkifyEnabled()>,<android.view.textclassifier.TextClassificationConstants: boolean isSmartLinkifyEnabled()>,0,"{
    return mConfigParser.getBoolean(SMART_LINKIFY_ENABLED, SMART_LINKIFY_ENABLED_DEFAULT);
}","{
    return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_TEXTCLASSIFIER, SMART_LINKIFY_ENABLED, SMART_LINKIFY_ENABLED_DEFAULT);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation for obtaining the boolean value has changed from using mConfigParser to using DeviceConfig.getBoolean with different parameters, which indicates a change in the dependent API, so the code change is type 1,5.","Since the method used to get the boolean value has changed, it could potentially return a different value, therefore the CI type is 1."
856,"<android.content.ContentProviderOperation.Builder: Builder withValueBackReference(String,int)>",29,30,"<android.content.ContentProviderOperation.Builder: Builder withValueBackReference(String,int)>","<android.content.ContentProviderOperation.Builder: Builder withValueBackReference(String,int)>",0,"{
    if (mType != TYPE_INSERT && mType != TYPE_UPDATE && mType != TYPE_ASSERT) {
        throw new IllegalArgumentException(""only inserts, updates, and asserts can have value back-references"");
    }
    if (mValuesBackReferences == null) {
        mValuesBackReferences = new ContentValues();
    }
    mValuesBackReferences.put(key, previousResult);
    return this;
}","{
    assertValuesAllowed();
    setValue(key, new BackReference(fromIndex, null));
    return this;
}",1,"/**
 * Add a ContentValues back reference.
 * A column value from the back references takes precedence over a value specified in
 * {@link #withValues}.
 * This can only be used with builders of type insert, update, or assert.
 * @return this builder, to allow for chaining.
 */
","/**
 * Configure the given value to be dynamically overwritten using the
 * result of a previous operation. This method will replace any
 * previously defined value for this key.
 *
 * @param key the key indicating which value to configure
 * @param fromIndex the index indicating which historical
 * {@link ContentProviderResult} should overwrite the value
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",1,"The late implementation has two new method calls (assertValuesAllowed() and setValue()) which do not exist in the early version. The method calls and their arguments are part of the functional implementation of the code, and they represent a significant alteration in how the method operates internally, hence the code change type is 4,5.","The introduction of new method calls which alter the behavior of the API, introduces a potential Compatibility Issue as they could result in different values being returned, particularly if these new methods behave differently than the replaced code block. Therefore, the CI type is 1."
857,"<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>",29,30,"<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>","<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>",0,"{
    if (position == INVALID_POSITION) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    final boolean isItemEnabled;
    final ViewGroup.LayoutParams lp = view.getLayoutParams();
    if (lp instanceof AbsListView.LayoutParams) {
        isItemEnabled = ((AbsListView.LayoutParams) lp).isEnabled && isEnabled();
    } else {
        isItemEnabled = false;
    }
    info.setEnabled(isItemEnabled);
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_CLEAR_SELECTION);
    } else {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_SELECT);
    }
    if (isItemClickable(view)) {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_CLICK);
        info.setClickable(true);
    }
    if (isLongClickable()) {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}","{
    if (position == INVALID_POSITION) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    boolean isItemEnabled = view.isEnabled() && isEnabled();
    final ViewGroup.LayoutParams lp = view.getLayoutParams();
    if (lp instanceof AbsListView.LayoutParams) {
        isItemEnabled &= ((AbsListView.LayoutParams) lp).isEnabled;
    }
    info.setEnabled(isItemEnabled);
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_CLEAR_SELECTION);
    } else {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_SELECT);
    }
    if (isItemClickable(view)) {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_CLICK);
        // A disabled item is a separator which should not be clickable.
        info.setClickable(isItemEnabled);
    }
    if (isLongClickable()) {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}",1,"/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
","/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The method of calculating the `isItemEnabled` variable has been updated to a direct call to `view.isEnabled()` combined with a bitwise AND operator. This is a modification of the control dependency, and there is also a change in the assignment of the variable `isItemEnabled`, leading to two types of code changes: a return statement changed and a control dependency change (1,3).","The modified logic for setting `isItemEnabled` can lead to a different boolean value for `isItemEnabled`, which is then used to determine the enabled state of the `AccessibilityNodeInfo` and the actions added to it. Moreover, `info.setClickable` has been altered to set clickable based on `isItemEnabled`, rather than defaulting to `true`. Because `isItemEnabled` could potentially be different, the method's behavior in terms of what is set in the `AccessibilityNodeInfo` may change, leading to a Compatibility Issue due to different return values or types (1)."
858,<android.appwidget.AppWidgetHostView: View getDefaultView()>,29,30,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(INFLATER_FILTER);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
            defaultView.setOnClickListener(this::onDefaultViewClicked);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(INFLATER_FILTER);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
            if (!(defaultView instanceof AdapterView)) {
                // AdapterView does not support onClickListener
                defaultView.setOnClickListener(this::onDefaultViewClicked);
            }
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The change between versions concerns the addition of a check for `defaultView` being an instance of `AdapterView` before setting the `OnClickListener`. This represents a control dependency change (3). The modification within the `if` block to prevent setting an `OnClickListener` on an `AdapterView` is an other statement changed (4).,"The change does not affect the method's return value since `defaultView` is returned in both versions regardless of whether an `OnClickListener` is set. Also, the possible exceptions that could be thrown have not changed between versions. Hence, there is no Compatibility Issue (0)."
861,<android.os.Build: String getSerial()>,29,30,<android.os.Build: String getSerial()>,<android.os.Build: String getSerial()>,0,"{
    IDeviceIdentifiersPolicyService service = IDeviceIdentifiersPolicyService.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE));
    try {
        Application application = ActivityThread.currentApplication();
        String callingPackage = application != null ? application.getPackageName() : null;
        return service.getSerialForPackage(callingPackage);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    return UNKNOWN;
}","{
    IDeviceIdentifiersPolicyService service = IDeviceIdentifiersPolicyService.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE));
    try {
        Application application = ActivityThread.currentApplication();
        String callingPackage = application != null ? application.getPackageName() : null;
        return service.getSerialForPackage(callingPackage, null);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    return UNKNOWN;
}",1,"/**
 * Gets the hardware serial number, if available.
 *
 * <p class=""note""><b>Note:</b> Root access may allow you to modify device identifiers, such as
 * the hardware serial number. If you change these identifiers, you can use
 * <a href=""/training/articles/security-key-attestation.html"">key attestation</a> to obtain
 * proof of the device's original identifiers.
 *
 * <p>Requires Permission: READ_PRIVILEGED_PHONE_STATE, for the calling app to be the device or
 * profile owner and have the READ_PHONE_STATE permission, or that the calling app has carrier
 * privileges (see {@link android.telephony.TelephonyManager#hasCarrierPrivileges}). The profile
 * owner is an app that owns a managed profile on the device; for more details see <a
 * href=""https://developer.android.com/work/managed-profiles"">Work profiles</a>. Profile owner
 * access is deprecated and will be removed in a future release.
 *
 * <p>If the calling app does not meet one of these requirements then this method will behave
 * as follows:
 *
 * <ul>
 * <li>If the calling app's target SDK is API level 28 or lower and the app has the
 * READ_PHONE_STATE permission then {@link Build#UNKNOWN} is returned.</li>
 * <li>If the calling app's target SDK is API level 28 or lower and the app does not have
 * the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
 * higher, then a SecurityException is thrown.</li>
 * </ul>
 * *
 * @return The serial number if specified.
 */
","/**
 * Gets the hardware serial number, if available.
 *
 * <p class=""note""><b>Note:</b> Root access may allow you to modify device identifiers, such as
 * the hardware serial number. If you change these identifiers, you can use
 * <a href=""/training/articles/security-key-attestation.html"">key attestation</a> to obtain
 * proof of the device's original identifiers.
 *
 * <p>Starting with API level 29, persistent device identifiers are guarded behind additional
 * restrictions, and apps are recommended to use resettable identifiers (see <a
 * href=""c""> Best practices for unique identifiers</a>). This method can be invoked if one of
 * the following requirements is met:
 * <ul>
 * <li>If the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this
 * is a privileged permission that can only be granted to apps preloaded on the device.
 * <li>If the calling app is the device or profile owner and has been granted the
 * {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that
 * owns a managed profile on the device; for more details see <a
 * href=""https://developer.android.com/work/managed-profiles"">Work profiles</a>.
 * Profile owner access is deprecated and will be removed in a future release.
 * <li>If the calling app has carrier privileges (see {@link
 * android.telephony.TelephonyManager#hasCarrierPrivileges}) on any active subscription.
 * <li>If the calling app is the default SMS role holder (see {@link
 * android.app.role.RoleManager#isRoleHeld(String)}).
 * </ul>
 *
 * <p>If the calling app does not meet one of these requirements then this method will behave
 * as follows:
 *
 * <ul>
 * <li>If the calling app's target SDK is API level 28 or lower and the app has the
 * READ_PHONE_STATE permission then {@link Build#UNKNOWN} is returned.</li>
 * <li>If the calling app's target SDK is API level 28 or lower and the app does not have
 * the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
 * higher, then a SecurityException is thrown.</li>
 * </ul>
 *
 * @return The serial number if specified.
 */
",-1,"[// No support for device / profile owner.
@SuppressAutoDoc, @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)]","[// No support for device / profile owner.
@SuppressAutoDoc, @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)]",-1,-1,-1,-1,-1,-1,5,0,"The dependent API call getSerialForPackage has its parameter list changed by the addition of a new parameter (null is passed as the second parameter in the late version), therefore the change type is 5.","Even though there is a change in the dependent API call, it does not seem to lead to a different return value or exception being thrown because the try-catch block handling the RemoteException is the same in both versions, and the UNKNOWN return statement exists in both versions outside of the try-catch block. Hence, there is no compatibility issue: CI type is 0."
863,"<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>",29,30,"<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>","<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>",0,"{
    if (!acceptFilter()) {
        return false;
    }
    boolean handled = false;
    boolean okToSend = true;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_BACK:
            if (mFiltered && mPopup != null && mPopup.isShowing()) {
                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                    KeyEvent.DispatcherState state = getKeyDispatcherState();
                    if (state != null) {
                        state.startTracking(event, this);
                    }
                    handled = true;
                } else if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
                    handled = true;
                    mTextFilter.setText("""");
                }
            }
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_SPACE:
            // Only send spaces once we are filtered
            okToSend = mFiltered;
            break;
    }
    if (okToSend) {
        createTextFilter(true);
        KeyEvent forwardEvent = event;
        if (forwardEvent.getRepeatCount() > 0) {
            forwardEvent = KeyEvent.changeTimeRepeat(event, event.getEventTime(), 0);
        }
        int action = event.getAction();
        switch(action) {
            case KeyEvent.ACTION_DOWN:
                handled = mTextFilter.onKeyDown(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_UP:
                handled = mTextFilter.onKeyUp(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_MULTIPLE:
                handled = mTextFilter.onKeyMultiple(keyCode, count, event);
                break;
        }
    }
    return handled;
}","{
    if (!acceptFilter()) {
        return false;
    }
    boolean handled = false;
    boolean okToSend = true;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
        case KeyEvent.KEYCODE_NUMPAD_ENTER:
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_BACK:
            if (mFiltered && mPopup != null && mPopup.isShowing()) {
                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                    KeyEvent.DispatcherState state = getKeyDispatcherState();
                    if (state != null) {
                        state.startTracking(event, this);
                    }
                    handled = true;
                } else if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
                    handled = true;
                    mTextFilter.setText("""");
                }
            }
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_SPACE:
            // Only send spaces once we are filtered
            okToSend = mFiltered;
            break;
    }
    if (okToSend) {
        createTextFilter(true);
        KeyEvent forwardEvent = event;
        if (forwardEvent.getRepeatCount() > 0) {
            forwardEvent = KeyEvent.changeTimeRepeat(event, event.getEventTime(), 0);
        }
        int action = event.getAction();
        switch(action) {
            case KeyEvent.ACTION_DOWN:
                handled = mTextFilter.onKeyDown(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_UP:
                handled = mTextFilter.onKeyUp(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_MULTIPLE:
                handled = mTextFilter.onKeyMultiple(keyCode, count, event);
                break;
        }
    }
    return handled;
}",1,"/**
 * Sends a key to the text filter window
 *
 * @param keyCode The keycode for the event
 * @param event The actual key event
 *
 * @return True if the text filter handled the event, false otherwise.
 */
","/**
 * Sends a key to the text filter window
 *
 * @param keyCode The keycode for the event
 * @param event The actual key event
 *
 * @return True if the text filter handled the event, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The switch case statement has been modified to include an additional case, KeyEvent.KEYCODE_NUMPAD_ENTER. This is a control dependency change, so the code change type is 3.","The introduction of a new case statement for KeyEvent.KEYCODE_NUMPAD_ENTER will only prevent sending the NUMPAD_ENTER key through the text filter, just as it does for the other specified keys. It does not affect the method's return type or value for any other input, and it does not introduce a new behavior that results in a different outcome as long as the method contract is to filter out specific keys. Therefore, there's no Compatibility Issue, and the CI type is 0."
864,<android.util.Half: short toHalf(float)>,29,30,<android.util.Half: short toHalf(float)>,<android.util.Half: short toHalf(float)>,0,"{
    int bits = Float.floatToRawIntBits(f);
    int s = (bits >>> FP32_SIGN_SHIFT);
    int e = (bits >>> FP32_EXPONENT_SHIFT) & FP32_EXPONENT_MASK;
    int m = (bits) & FP32_SIGNIFICAND_MASK;
    int outE = 0;
    int outM = 0;
    if (e == 0xff) {
        // Infinite or NaN
        outE = 0x1f;
        outM = m != 0 ? 0x200 : 0;
    } else {
        e = e - FP32_EXPONENT_BIAS + FP16_EXPONENT_BIAS;
        if (e >= 0x1f) {
            // Overflow
            outE = 0x31;
        } else if (e <= 0) {
            // Underflow
            if (e < -10) {
            // The absolute fp32 value is less than MIN_VALUE, flush to +/-0
            } else {
                // The fp32 value is a normalized float less than MIN_NORMAL,
                // we convert to a denorm fp16
                m = (m | 0x800000) >> (1 - e);
                if ((m & 0x1000) != 0)
                    m += 0x2000;
                outM = m >> 13;
            }
        } else {
            outE = e;
            outM = m >> 13;
            if ((m & 0x1000) != 0) {
                // Round to nearest ""0.5"" up
                int out = (outE << FP16_EXPONENT_SHIFT) | outM;
                out++;
                return (short) (out | (s << FP16_SIGN_SHIFT));
            }
        }
    }
    return (short) ((s << FP16_SIGN_SHIFT) | (outE << FP16_EXPONENT_SHIFT) | outM);
}","{
    return FP16.toHalf(f);
}",1,"/**
 * <p>Converts the specified single-precision float value into a
 * half-precision float value. The following special cases are handled:</p>
 * <ul>
 * <li>If the input is NaN (see {@link Float#isNaN(float)}), the returned
 * value is {@link #NaN}</li>
 * <li>If the input is {@link Float#POSITIVE_INFINITY} or
 * {@link Float#NEGATIVE_INFINITY}, the returned value is respectively
 * {@link #POSITIVE_INFINITY} or {@link #NEGATIVE_INFINITY}</li>
 * <li>If the input is 0 (positive or negative), the returned value is
 * {@link #POSITIVE_ZERO} or {@link #NEGATIVE_ZERO}</li>
 * <li>If the input is a less than {@link #MIN_VALUE}, the returned value
 * is flushed to {@link #POSITIVE_ZERO} or {@link #NEGATIVE_ZERO}</li>
 * <li>If the input is a less than {@link #MIN_NORMAL}, the returned value
 * is a denorm half-precision float</li>
 * <li>Otherwise, the returned value is rounded to the nearest
 * representable half-precision float value</li>
 * </ul>
 *
 * @param f The single-precision float value to convert to half-precision
 * @return A half-precision float value
 */
","/**
 * <p>Converts the specified single-precision float value into a
 * half-precision float value. The following special cases are handled:</p>
 * <ul>
 * <li>If the input is NaN (see {@link Float#isNaN(float)}), the returned
 * value is {@link #NaN}</li>
 * <li>If the input is {@link Float#POSITIVE_INFINITY} or
 * {@link Float#NEGATIVE_INFINITY}, the returned value is respectively
 * {@link #POSITIVE_INFINITY} or {@link #NEGATIVE_INFINITY}</li>
 * <li>If the input is 0 (positive or negative), the returned value is
 * {@link #POSITIVE_ZERO} or {@link #NEGATIVE_ZERO}</li>
 * <li>If the input is a less than {@link #MIN_VALUE}, the returned value
 * is flushed to {@link #POSITIVE_ZERO} or {@link #NEGATIVE_ZERO}</li>
 * <li>If the input is a less than {@link #MIN_NORMAL}, the returned value
 * is a denorm half-precision float</li>
 * <li>Otherwise, the returned value is rounded to the nearest
 * representable half-precision float value</li>
 * </ul>
 *
 * @param f The single-precision float value to convert to half-precision
 * @return A half-precision float value
 */
",-1,"[@SuppressWarnings(""StatementWithEmptyBody""), @HalfFloat]","[@SuppressWarnings(""StatementWithEmptyBody""), @HalfFloat]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method's implementation has changed from a block of code that performs the conversion manually to using a static method call FP16.toHalf(f), which is a dependent API change. Therefore, the code change type is 1,5.","This change in implementation could potentially return a different value if the functionality of FP16.toHalf(f) differs from the original manual conversion code. As there is a possibility for different behavior, the CI type is 1."
865,<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(Surface)>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(Surface)>,<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(Surface)>,0,"{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            final List<Surface> surfaces = mConfiguredOutputs.valueAt(i).getSurfaces();
            if (surfaces.contains(surface)) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.prepare(streamId);
    }
}","{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            final List<Surface> surfaces = mConfiguredOutputs.valueAt(i).getSurfaces();
            if (surfaces.contains(surface)) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.prepare(streamId);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call to checkIfCameraClosedOrInError() has been introduced inside the synchronized block, so the code change type is 4.","The introduction of checkIfCameraClosedOrInError() does not affect the return value, nor does it introduce a new exception that wasn't accounted for in the early version, because the method either performs a check without changing the outcome or throws a RuntimeException which would have been an error condition even in the early version. Therefore, there is no Compatibility Issue; the CI type is 0."
866,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        mDeviceExecutor.execute(mCallOnBusy);
        // flush.
        if (mIdle) {
            mDeviceExecutor.execute(mCallOnIdle);
            return;
        }
        long lastFrameNumber = mRemoteDevice.flush();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber, mRepeatingRequestTypes);
            mRepeatingRequestId = REQUEST_ID_NONE;
            mRepeatingRequestTypes = null;
        }
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        mDeviceExecutor.execute(mCallOnBusy);
        // flush.
        if (mIdle) {
            mDeviceExecutor.execute(mCallOnIdle);
            return;
        }
        long lastFrameNumber = mRemoteDevice.flush();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            checkEarlyTriggerSequenceCompleteLocked(mRepeatingRequestId, lastFrameNumber, mRepeatingRequestTypes);
            mRepeatingRequestId = REQUEST_ID_NONE;
            mRepeatingRequestTypes = null;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called checkEarlyTriggerSequenceComplete() has been changed to checkEarlyTriggerSequenceCompleteLocked() within the if block, which seems to be a method renaming with no change in control dependency and without an impact on the return type or value. This suggests an internal change to a dependent API, therefore, the code change types are 4, 5.","No Compatibility Issue arises due to this change because it is an internal implementation detail change that doesn't affect the API's contract regarding the expected return value or the exceptions it throws. Hence, the CI type is 0."
867,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",29,30,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>","<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",0,"{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        // the context without reloading Resources.
        return new ContextImpl(this, mMainThread, mPackageInfo, null, mActivityToken, user, flags, null, null);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken, user, flags, null, null);
        final int displayId = getDisplayId();
        c.setResources(createResources(mActivityToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        // the context without reloading Resources.
        return new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, null, mToken, user, flags, null, null);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mAttributionTag, null, mToken, user, flags, null, null);
        final int displayId = getDisplayId();
        c.setResources(createResources(mToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo(), null));
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The constructor arguments for `ContextImpl` have changed by adding mAttributionTag and replacing mActivityToken with mToken. Additionally, the argument list for `createResources` is altered by adding a new `null` parameter at the end. These changes affect object instantiation and method calls, but no return statements, exception handling, or control flows have been modified. Thus, the change type is 4.","There are no changes in the behavior of returning a value or throwing an exception. The change solely affects internal variable assignments, which do not cause Compatibility Issues as long as internal API contracts remain intact and assuming mAttributionTag and mToken correctly substitute for null and mActivityToken, as seen in the context of how the ContextImpl and createResources are constructed and called within this method. Without further context suggesting these changes would lead to behavior differences when invoking these methods, we should consider no CI, hence the CI type is 0."
868,"<android.util.Half: boolean greaterEquals(short,short)>",29,30,"<android.util.Half: boolean greaterEquals(short,short)>","<android.util.Half: boolean greaterEquals(short,short)>",0,"{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) >= ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff);
}","{
    return FP16.greaterEquals(x, y);
}",1,"/**
 * Returns true if the first half-precision float value is greater (larger
 * toward positive infinity) than or equal to the second half-precision float
 * value. If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is greater than y, false otherwise
 */
","/**
 * Returns true if the first half-precision float value is greater (larger
 * toward positive infinity) than or equal to the second half-precision float
 * value. If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is greater than y, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The early implementation of the method contains the logic for comparing the values, while the late implementation delegates the comparison to the method call FP16.greaterEquals(x, y). This indicates a change with the dependent API, so the code change type is 5.","There is no Compatibility Issue detected because the late implementation is relying on a static method within the FP16 class to perform the comparison, presuming that FP16.greaterEquals(x, y) is implemented to provide the same functionality as the inlined logic in the early version."
869,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,29,30,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingDisplayCutout.get().equals(args.arg9) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                boolean configChanged = false;
                if (!mLastReportedMergedConfiguration.equals(mergedConfiguration)) {
                    // If configuration changed - notify about that and, maybe,
                    // about move to display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                    configChanged = true;
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingDisplayCutout.get().equals(args.arg9) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                setFrame((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingDisplayCutout.set((DisplayCutout) args.arg9);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeSystemBars = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && (framesChanged || configChanged)) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_INSETS_CHANGED:
            mInsetsController.onStateChanged((InsetsState) msg.obj);
            break;
        case MSG_INSETS_CONTROL_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInsetsController.onControlsChanged((InsetsSourceControl[]) args.arg2);
                mInsetsController.onStateChanged((InsetsState) args.arg1);
                break;
            }
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mTmpFrame.left = l;
                mTmpFrame.right = l + w;
                mTmpFrame.top = t;
                mTmpFrame.bottom = t + h;
                setFrame(mTmpFrame);
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                handleWindowFocusChanged();
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from Autofill to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = mContext.getSystemService(InputMethodManager.class);
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
            {
            }
        // fall through
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            {
                systemGestureExclusionChanged();
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingDisplayCutout.get().equals(args.arg9) && mPendingBackDropFrame.equals(args.arg8) && mLastReportedMergedConfiguration.equals(args.arg4) && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                boolean configChanged = false;
                if (!mLastReportedMergedConfiguration.equals(mergedConfiguration)) {
                    // If configuration changed - notify about that and, maybe,
                    // about move to display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                    configChanged = true;
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingDisplayCutout.get().equals(args.arg9);
                setFrame((Rect) args.arg1);
                mPendingDisplayCutout.set((DisplayCutout) args.arg9);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeSystemBars = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && (framesChanged || configChanged)) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_INSETS_CHANGED:
            mInsetsController.onStateChanged((InsetsState) msg.obj);
            break;
        case MSG_INSETS_CONTROL_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                // Deliver state change before control change, such that:
                // a) When gaining control, controller can compare with server state to evaluate
                // whether it needs to run animation.
                // b) When loosing control, controller can restore server state by taking last
                // dispatched state as truth.
                mInsetsController.onStateChanged((InsetsState) args.arg1);
                mInsetsController.onControlsChanged((InsetsSourceControl[]) args.arg2);
                break;
            }
        case MSG_SHOW_INSETS:
            {
                if (mView == null) {
                    Log.e(TAG, String.format(""Calling showInsets(%d,%b) on window that no longer"" + "" has views."", msg.arg1, msg.arg2 == 1));
                }
                mInsetsController.show(msg.arg1, msg.arg2 == 1);
                break;
            }
        case MSG_HIDE_INSETS:
            {
                mInsetsController.hide(msg.arg1, msg.arg2 == 1);
                break;
            }
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mTmpFrame.left = l;
                mTmpFrame.right = l + w;
                mTmpFrame.top = t;
                mTmpFrame.bottom = t + h;
                setFrame(mTmpFrame);
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                handleWindowFocusChanged();
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from Autofill to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                getImeFocusController().checkFocus(false, true);
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
            {
            }
        // fall through
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            {
                systemGestureExclusionChanged();
            }
            break;
        case MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED:
            {
                updateLocationInParentDisplay(msg.arg1, msg.arg2);
            }
            break;
        case MSG_REQUEST_SCROLL_CAPTURE:
            handleScrollCaptureRequest((IScrollCaptureController) msg.obj);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
870,<android.net.Uri.HierarchicalUri: Uri readFrom(Parcel)>,29,30,<android.net.Uri.HierarchicalUri: Uri readFrom(Parcel)>,<android.net.Uri.HierarchicalUri: Uri readFrom(Parcel)>,0,"{
    return new HierarchicalUri(parcel.readString(), Part.readFrom(parcel), PathPart.readFrom(parcel), Part.readFrom(parcel), Part.readFrom(parcel));
}","{
    return new HierarchicalUri(parcel.readString8(), Part.readFrom(parcel), PathPart.readFrom(parcel), Part.readFrom(parcel), Part.readFrom(parcel));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,The dependency method called to read string components from the Parcel has changed from parcel.readString() to parcel.readString8(). There is no change in the structure of the control flow or exception handling; hence the code change type is 5.,"The method readString8() may return different values than readString(), potentially due to differences in the way strings are handled (e.g., encoding). Because the return value of readFrom could be different with the new method used to read string data from the Parcel, the CI type is 1."
871,<android.widget.Editor.SelectionHandleView: boolean onTouchEvent(MotionEvent)>,29,30,<android.widget.Editor.SelectionHandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.SelectionHandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    boolean superResult = super.onTouchEvent(event);
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            // Reset the touch word offset and x value when the user
            // re-engages the handle.
            mTouchWordDelta = 0.0f;
            mPrevX = UNSET_X_VALUE;
            updateMagnifier(event);
            break;
        case MotionEvent.ACTION_MOVE:
            updateMagnifier(event);
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            dismissMagnifier();
            break;
    }
    return superResult;
}","{
    if (!mTextView.isFromPrimePointer(event, true)) {
        return true;
    }
    boolean superResult = super.onTouchEvent(event);
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            // Reset the touch word offset and x value when the user
            // re-engages the handle.
            mTouchWordDelta = 0.0f;
            mPrevX = UNSET_X_VALUE;
            updateMagnifier(event);
            break;
        case MotionEvent.ACTION_MOVE:
            updateMagnifier(event);
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            dismissMagnifier();
            break;
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The introduction of new conditional logic at the beginning (`if (!mTextView.isFromPrimePointer(event, true)) { return true;}`) is a control dependency change, and the additional return statement is an ""Other statement changed"". This could affect the flow of the method and which other code is executed within the method.","Despite the introduction of new logic and an additional return statement, this does not constitute a Compatibility Issue. The new check does not lead to a different value being returned by the method under the same conditions because it is a gatekeeper that ensures a certain condition is met before the rest of the method executes. If the condition is not met, the method shortcuts to returning `true`, but should not affect the method's behavior when operating under the intended conditions. Therefore, it should not cause the method to return a different value than before, as long as the input event is consistent with those intended conditions (i.e., the event is from the primary pointer)."
873,<android.view.Display: String toString()>,29,30,<android.view.Display: String toString()>,<android.view.Display: String toString()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, getDisplayAdjustments());
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + "", "" + mTempMetrics + "", isValid="" + mIsValid;
    }
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        final DisplayAdjustments adjustments = getDisplayAdjustments();
        mDisplayInfo.getAppMetrics(mTempMetrics, adjustments);
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + (mMayAdjustByFixedRotation ? ("", "" + adjustments.getFixedRotationAdjustments() + "", "") : "", "") + mTempMetrics + "", isValid="" + mIsValid;
    }
}",1,"// For debugging purposes
","// For debugging purposes
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has been changed by adding a ternary conditional expression that appends different strings based on the value of mMayAdjustByFixedRotation. It introduces a new control dependency change, so the code change type is 1,3.","As the return statement now includes additional text depending on the value of mMayAdjustByFixedRotation, the output of the function can potentially be different in the late version even for the same input. Therefore, the CI type is 1."
874,"<android.app.admin.DevicePolicyManager: int setGlobalPrivateDnsModeSpecifiedHost(ComponentName,String)>",29,30,"<android.app.admin.DevicePolicyManager: int setGlobalPrivateDnsModeSpecifiedHost(ComponentName,String)>","<android.app.admin.DevicePolicyManager: int setGlobalPrivateDnsModeSpecifiedHost(ComponentName,String)>",0,"{
    throwIfParentInstance(""setGlobalPrivateDnsModeSpecifiedHost"");
    Preconditions.checkNotNull(privateDnsHost, ""dns resolver is null"");
    if (mService == null) {
        return PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;
    }
    if (NetworkUtils.isWeaklyValidatedHostname(privateDnsHost)) {
        if (!PrivateDnsConnectivityChecker.canConnectToPrivateDnsServer(privateDnsHost)) {
            return PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING;
        }
    }
    try {
        return mService.setGlobalPrivateDns(admin, PRIVATE_DNS_MODE_PROVIDER_HOSTNAME, privateDnsHost);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""setGlobalPrivateDnsModeSpecifiedHost"");
    Objects.requireNonNull(privateDnsHost, ""dns resolver is null"");
    if (mService == null) {
        return PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;
    }
    if (NetworkUtils.isWeaklyValidatedHostname(privateDnsHost)) {
        if (!PrivateDnsConnectivityChecker.canConnectToPrivateDnsServer(privateDnsHost)) {
            return PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING;
        }
    }
    try {
        return mService.setGlobalPrivateDns(admin, PRIVATE_DNS_MODE_PROVIDER_HOSTNAME, privateDnsHost);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the global Private DNS host to be used.
 * May only be called by the device owner.
 *
 * <p>Note that the method is blocking as it will perform a connectivity check to the resolver,
 * to ensure it is valid. Because of that, the method should not be called on any thread that
 * relates to user interaction, such as the UI thread.
 *
 * <p>In case a VPN is used in conjunction with Private DNS resolver, the Private DNS resolver
 * must be reachable both from within and outside the VPN. Otherwise, the device may lose
 * the ability to resolve hostnames as system traffic to the resolver may not go through the
 * VPN.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with.
 * @param privateDnsHost The hostname of a server that implements DNS over TLS (RFC7858).
 *
 * @return {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully,
 * {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set or
 * {@code PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING} if the specified host does not
 * implement RFC7858.
 *
 * @throws IllegalArgumentException if the {@code privateDnsHost} is not a valid hostname.
 *
 * @throws SecurityException if the caller is not the device owner.
 */
","/**
 * Sets the global Private DNS host to be used.
 * May only be called by the device owner.
 *
 * <p>Note that the method is blocking as it will perform a connectivity check to the resolver,
 * to ensure it is valid. Because of that, the method should not be called on any thread that
 * relates to user interaction, such as the UI thread.
 *
 * <p>In case a VPN is used in conjunction with Private DNS resolver, the Private DNS resolver
 * must be reachable both from within and outside the VPN. Otherwise, the device may lose
 * the ability to resolve hostnames as system traffic to the resolver may not go through the
 * VPN.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with.
 * @param privateDnsHost The hostname of a server that implements DNS over TLS (RFC7858).
 *
 * @return {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully,
 * {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set or
 * {@code PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING} if the specified host does not
 * implement RFC7858.
 *
 * @throws IllegalArgumentException if the {@code privateDnsHost} is not a valid hostname.
 *
 * @throws SecurityException if the caller is not the device owner.
 */
",-1,"[@WorkerThread, @PrivateDnsModeErrorCodes]","[@WorkerThread, @PrivateDnsModeErrorCodes]",-1,-1,-1,-1,-1,-1,4,0,"The code change is substituting the call to `Preconditions.checkNotNull` with `Objects.requireNonNull`, which are equivalent operations. This change does not affect the control flow or alter behavior from the perspective of the API consumer.",No Compatibility Issue arises from this code change because the behavior of the API remains consistent before and after the change—the parameter checking logic has not substantively changed.
875,<android.app.ContextImpl: PackageManager getPackageManager()>,29,30,<android.app.ContextImpl: PackageManager getPackageManager()>,<android.app.ContextImpl: PackageManager getPackageManager()>,0,"{
    if (mPackageManager != null) {
        return mPackageManager;
    }
    IPackageManager pm = ActivityThread.getPackageManager();
    if (pm != null) {
        // Doesn't matter if we make more than one instance.
        return (mPackageManager = new ApplicationPackageManager(this, pm));
    }
    return null;
}","{
    if (mPackageManager != null) {
        return mPackageManager;
    }
    final IPackageManager pm = ActivityThread.getPackageManager();
    final IPermissionManager permissionManager = ActivityThread.getPermissionManager();
    if (pm != null && permissionManager != null) {
        // Doesn't matter if we make more than one instance.
        return (mPackageManager = new ApplicationPackageManager(this, pm, permissionManager));
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"There is an addition of a new local variable `permissionManager`, a check for its non-null condition, and a change in the return statement where a new `ApplicationPackageManager` is now created with an extra `permissionManager` parameter. This leads to changes in the return statement, other statements, and indicates a change in a dependent API constructor for `ApplicationPackageManager`. Thus, the code change type is 1,4,5.","The late version of the API could potentially return a different instance of `PackageManager`, because a new `ApplicationPackageManager` class constructor that takes different parameters is used. This difference is likely to result in a different behavior when getting the package manager, thus indicating a CI caused by a potential difference in returned values or types, meaning the CI type is 1."
876,"<android.app.ActivityThread.ApplicationThread: void dumpHeap(boolean,boolean,boolean,String,ParcelFileDescriptor,RemoteCallback)>",29,30,"<android.app.ActivityThread.ApplicationThread: void dumpHeap(boolean,boolean,boolean,String,ParcelFileDescriptor,RemoteCallback)>","<android.app.ActivityThread.ApplicationThread: void dumpHeap(boolean,boolean,boolean,String,ParcelFileDescriptor,RemoteCallback)>",0,"{
    DumpHeapData dhd = new DumpHeapData();
    dhd.managed = managed;
    dhd.mallocInfo = mallocInfo;
    dhd.runGc = runGc;
    dhd.path = path;
    try {
        // Since we're going to dump the heap asynchronously, dup the file descriptor before
        // it's closed on returning from the IPC call.
        dhd.fd = fd.dup();
    } catch (IOException e) {
        Slog.e(TAG, ""Failed to duplicate heap dump file descriptor"", e);
        return;
    }
    dhd.finishCallback = finishCallback;
    sendMessage(H.DUMP_HEAP, dhd, 0, 0, true);
}","{
    DumpHeapData dhd = new DumpHeapData();
    dhd.managed = managed;
    dhd.mallocInfo = mallocInfo;
    dhd.runGc = runGc;
    dhd.path = path;
    try {
        // Since we're going to dump the heap asynchronously, dup the file descriptor before
        // it's closed on returning from the IPC call.
        dhd.fd = fd.dup();
    } catch (IOException e) {
        Slog.e(TAG, ""Failed to duplicate heap dump file descriptor"", e);
        return;
    } finally {
        IoUtils.closeQuietly(fd);
    }
    dhd.finishCallback = finishCallback;
    sendMessage(H.DUMP_HEAP, dhd, 0, 0, true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A 'finally' block with a call to IoUtils.closeQuietly(fd) has been added, which is related to a resource cleanup, not to the logic of the method itself. Therefore, the code change type is 3 for the addition of a 'finally' block (control dependency change) and 4 for the statement change within that block (other statement changed).","The change does not impact the behavior of exception throwing or return values. The addition of the finally block ensures that the ParcelFileDescriptor 'fd' is closed after the try-catch block, which is resource cleanup and does not lead to different returned values or thrown exceptions by the API. Therefore, there is no Compatibility Issue related to return values or exception handling."
878,<android.net.MacAddress: int getAddressType()>,29,30,<android.net.MacAddress: int getAddressType()>,<android.net.MacAddress: int getAddressType()>,0,"{
    if (equals(BROADCAST_ADDRESS)) {
        return TYPE_BROADCAST;
    }
    if (isMulticastAddress()) {
        return TYPE_MULTICAST;
    }
    return TYPE_UNICAST;
}","{
    if (equals(BROADCAST_ADDRESS)) {
        return TYPE_BROADCAST;
    }
    if ((mAddr & MULTICAST_MASK) != 0) {
        return TYPE_MULTICAST;
    }
    return TYPE_UNICAST;
}",1,"/**
 * Returns the type of this address.
 *
 * @return the int constant representing the MAC address type of this MacAddress.
 */
","/**
 * Returns the type of this address.
 *
 * @return the int constant representing the MAC address type of this MacAddress.
 */
",-1,[@MacAddressType],[@MacAddressType],-1,-1,-1,-1,-1,-1,3,1,"The condition for the multicast check has changed from calling isMulticastAddress() to directly performing a bitwise operation ((mAddr & MULTICAST_MASK) != 0). Hence, the change is in the control dependency, specifically within an 'if' condition check.","The way the API determines whether the MacAddress is multicast has changed, which can cause the method to return a different address type than before. This is a potential return value change, causing a Compatibility Issue of type 1."
879,<android.app.ActivityView.SurfaceCallback: void surfaceDestroyed(SurfaceHolder)>,29,30,<android.app.ActivityView.SurfaceCallback: void surfaceDestroyed(SurfaceHolder)>,<android.app.ActivityView.SurfaceCallback: void surfaceDestroyed(SurfaceHolder)>,0,"{
    if (mVirtualDisplay != null) {
        mVirtualDisplay.setDisplayState(false);
    }
    clearActivityViewGeometryForIme();
    cleanTapExcludeRegion();
}","{
    mTaskEmbedder.stop();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The entire body of the method has been replaced with a single call to mTaskEmbedder.stop(), indicating other statement changed as well as a potential API that the method is dependent on has changed, so the code change type is 4,5.","Since the method does not contain any return statement or exception handling code, and the purpose of surfaceDestroyed is to execute side-effect tasks when a Surface is destroyed rather than returning a value or throwing an exception as part of its contract, the change in implementation does not indicate a compatibility issue according to the available data. Therefore, the CI type is 0."
880,<android.app.TaskInfo: String toString()>,29,30,<android.app.TaskInfo: String toString()>,<android.app.TaskInfo: String toString()>,0,"{
    return ""TaskInfo{userId="" + userId + "" stackId="" + stackId + "" taskId="" + taskId + "" displayId="" + displayId + "" isRunning="" + isRunning + "" baseIntent="" + baseIntent + "" baseActivity="" + baseActivity + "" topActivity="" + topActivity + "" origActivity="" + origActivity + "" realActivity="" + realActivity + "" numActivities="" + numActivities + "" lastActiveTime="" + lastActiveTime + "" supportsSplitScreenMultiWindow="" + supportsSplitScreenMultiWindow + "" resizeMode="" + resizeMode;
}","{
    return ""TaskInfo{userId="" + userId + "" stackId="" + stackId + "" taskId="" + taskId + "" displayId="" + displayId + "" isRunning="" + isRunning + "" baseIntent="" + baseIntent + "" baseActivity="" + baseActivity + "" topActivity="" + topActivity + "" origActivity="" + origActivity + "" realActivity="" + realActivity + "" numActivities="" + numActivities + "" lastActiveTime="" + lastActiveTime + "" supportsSplitScreenMultiWindow="" + supportsSplitScreenMultiWindow + "" resizeMode="" + resizeMode + "" isResizeable="" + isResizeable + "" token="" + token + "" topActivityType="" + topActivityType + "" pictureInPictureParams="" + pictureInPictureParams + "" topActivityInfo="" + topActivityInfo;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"Additional information is included in the late implementation's return statement, including 'isResizeable', 'token', 'topActivityType', 'pictureInPictureParams', and 'topActivityInfo'. The code change type is 4.","Since the return statement has been modified to include additional state variables, the API will potentially return different values, indicating a new representation of the TaskInfo object. Hence, the CI type is 1."
881,<android.view.autofill.AutofillManager: boolean isAutofillSupported()>,29,30,<android.view.autofill.AutofillManager: boolean isAutofillSupported()>,<android.view.autofill.AutofillManager: boolean isAutofillSupported()>,0,"{
    if (mService == null)
        return false;
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.isServiceSupported(mContext.getUserId(), receiver);
        return receiver.getIntResult() == 1;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null)
        return false;
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.isServiceSupported(mContext.getUserId(), receiver);
        return receiver.getIntResult() == 1;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get autofill supported status."");
    }
}",1,"/**
 * Returns {@code true} if autofill is supported by the current device and
 * is supported for this user.
 *
 * <p>Autofill is typically supported, but it could be unsupported in cases like:
 * <ol>
 * <li>Low-end devices.
 * <li>Device policy rules that forbid its usage.
 * </ol>
 */
","/**
 * Returns {@code true} if autofill is supported by the current device and
 * is supported for this user.
 *
 * <p>Autofill is typically supported, but it could be unsupported in cases like:
 * <ol>
 * <li>Low-end devices.
 * <li>Device policy rules that forbid its usage.
 * </ol>
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The late implementation introduces a new catch block for SyncResultReceiver.TimeoutException, which is an exception handling statement change, so the change type is 2.","Due to the addition of the new catch block for SyncResultReceiver.TimeoutException, which leads to a different exception being thrown (RuntimeException instead of potentially SyncResultReceiver.TimeoutException being propagated up from the method calls without being explicitly caught), there is a Compatibility Issue caused by potential different exception handlings, thus the CI type is 2."
882,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>",29,30,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>","<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API call within the method has changed from ActivityManager.getService().broadcastIntent() to ActivityManager.getService().broadcastIntentWithFeature() and a new parameter getAttributionTag() has been added to the method call. The changes are related to the dependent API and other statements, so the code change type is 4,5.","There is no change to return statements or exception handling statements, and since the change is handling the additional feature flag seamlessly within the same structure of try-catch block, there should be no compatibility issue in how exceptions are thrown either. Therefore, there is no Compatibility Issue, and the CI type is 0."
883,<android.util.EventLog.Event: Object getData()>,29,30,<android.util.EventLog.Event: Object getData()>,<android.util.EventLog.Event: Object getData()>,0,"{
    try {
        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
        if (offset == 0) {
            offset = V1_PAYLOAD_START;
        }
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        if ((offset + DATA_OFFSET) >= mBuffer.limit()) {
            // no payload
            return null;
        }
        // Just after the tag.
        mBuffer.position(offset + DATA_OFFSET);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, ""Illegal entry payload: tag="" + getTag(), e);
        mLastWtf = e;
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, ""Truncated entry payload: tag="" + getTag(), e);
        mLastWtf = e;
        return null;
    }
}","{
    try {
        int offset = getHeaderSize();
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        if ((offset + TAG_LENGTH) >= mBuffer.limit()) {
            // no payload
            return null;
        }
        // Just after the tag.
        mBuffer.position(offset + TAG_LENGTH);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, ""Illegal entry payload: tag="" + getTag(), e);
        mLastWtf = e;
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, ""Truncated entry payload: tag="" + getTag(), e);
        mLastWtf = e;
        return null;
    }
}",1,"/**
 * @return one of Integer, Long, Float, String, null, or Object[] of same.
 */
","/**
 * @return one of Integer, Long, Float, String, null, or Object[] of same.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method implementation has changed from using a hardcoded offset and HEADER_SIZE_OFFSET to using a method call getHeaderSize(). Additionally, DATA_OFFSET is replaced by TAG_LENGTH, and there is a change in how the offset is calculated and used for setting the buffer limit and position. These changes involve modifying the control flow, other statements (like variable assignments), and using a new method call (getHeaderSize), which all suggest code change types 1, 3, 4, 5.","Since the offset used to limit the buffer and the data returned by decodeObject() can be different due to the changed way of calculating the offset and the new method getHeaderSize(), these code changes can result in the API returning a different object. Therefore, the CI type is 1."
884,<android.content.pm.ShortcutManager: List<ShortcutInfo> getPinnedShortcuts()>,29,30,<android.content.pm.ShortcutManager: List<ShortcutInfo> getPinnedShortcuts()>,<android.content.pm.ShortcutManager: List<ShortcutInfo> getPinnedShortcuts()>,0,"{
    try {
        return mService.getPinnedShortcuts(mContext.getPackageName(), injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_PINNED, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all pinned shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Return all pinned shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called on `mService` has changed from `getPinnedShortcuts` to `getShortcuts` with different parameter values, indicating that a dependent API (`mService`'s method) has changed. This affects the return statement because it relies on the output of the changed method, so the change type is 1,5.","Since the method called on `mService` has changed, this could potentially lead to different `ShortcutInfo` objects being returned, which constitutes a return statement change and thus a compatibility issue of type 1."
885,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>",29,30,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, options, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, options, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The method called has changed from broadcastIntent to broadcastIntentWithFeature, which indicates a change in the dependent API, so the code change type is 5.","There is no compatibility issue since the method's signature, return type, thrown exception type, and behavior in handling exceptions remain unchanged. The change in the dependent API does not directly cause a different return value or exception handling behavior in this method's context."
886,"<android.view.inputmethod.InputMethodManager: void toggleSoftInputFromWindow(IBinder,int,int)>",29,30,"<android.view.inputmethod.InputMethodManager: void toggleSoftInputFromWindow(IBinder,int,int)>","<android.view.inputmethod.InputMethodManager: void toggleSoftInputFromWindow(IBinder,int,int)>",0,"{
    synchronized (mH) {
        if (mServedView == null || mServedView.getWindowToken() != windowToken) {
            return;
        }
        if (mCurMethod != null) {
            try {
                mCurMethod.toggleSoftInput(showFlags, hideFlags);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    synchronized (mH) {
        final View servedView = getServedViewLocked();
        if (servedView == null || servedView.getWindowToken() != windowToken) {
            return;
        }
        if (mCurMethod != null) {
            try {
                mCurMethod.toggleSoftInput(showFlags, hideFlags);
            } catch (RemoteException e) {
            }
        }
    }
}",1,"/**
 * This method toggles the input method window display.
 * If the input window is already displayed, it gets hidden.
 * If not the input window will be displayed.
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param showFlags Provides additional operating flags.  May be
 * 0 or have the {@link #SHOW_IMPLICIT},
 * {@link #SHOW_FORCED} bit set.
 * @param hideFlags Provides additional operating flags.  May be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 */
","/**
 * This method toggles the input method window display.
 * If the input window is already displayed, it gets hidden.
 * If not the input window will be displayed.
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param showFlags Provides additional operating flags.  May be
 * 0 or have the {@link #SHOW_IMPLICIT},
 * {@link #SHOW_FORCED} bit set.
 * @param hideFlags Provides additional operating flags.  May be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is the replacement of direct field access ""mServedView"" with a method call ""getServedViewLocked()"". No other logic has been changed. This is an internal change which is likely to be a refactoring aimed at code clarity or maintainability rather than altering the behavior, resulting in change type 4.","There is no Compatibility Issue as the behavior of the public API remains the same; the method still returns early under the same conditions, and it calls ""mCurMethod.toggleSoftInput(showFlags, hideFlags)"" in the same way if the checks pass. There are no changes to the return values, exception handling, or control flow that would affect the exposed behavior, which leads to CI type 0."
887,<android.view.autofill.AutofillManager: boolean hasEnabledAutofillServices()>,29,30,<android.view.autofill.AutofillManager: boolean hasEnabledAutofillServices()>,<android.view.autofill.AutofillManager: boolean hasEnabledAutofillServices()>,0,"{
    if (mService == null)
        return false;
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.isServiceEnabled(mContext.getUserId(), mContext.getPackageName(), receiver);
        return receiver.getIntResult() == 1;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null)
        return false;
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.isServiceEnabled(mContext.getUserId(), mContext.getPackageName(), receiver);
        return receiver.getIntResult() == 1;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get enabled autofill services status."");
    }
}",1,"/**
 * Returns {@code true} if the calling application provides a {@link AutofillService} that is
 * enabled for the current user, or {@code false} otherwise.
 */
","/**
 * Returns {@code true} if the calling application provides a {@link AutofillService} that is
 * enabled for the current user, or {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement for `SyncResultReceiver.TimeoutException` has been added, which does not exist in the early version. This introduces a change related to how the API handles exceptions and is therefore classified under change type 2.","The addition of a new catch block for `SyncResultReceiver.TimeoutException` can lead to the late version of the API throwing a new unchecked exception (`RuntimeException`) when this timeout exception is caught. This difference in exception handling means the late version may throw an exception where the early version would not, which is a change in behavior and could cause a compatibility issue. Therefore, the CI type is 2."
888,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",29,30,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>","<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",0,"{
    if (!restarting) {
        doFinishInput();
    }
    mInputStarted = true;
    mStartedInputConnection = ic;
    mInputEditorInfo = attribute;
    initialize();
    if (DEBUG)
        Log.v(TAG, ""CALL: onStartInput"");
    onStartInput(attribute, restarting);
    if (mDecorViewVisible) {
        if (mShowInputRequested) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartInputView"");
            mInputViewStarted = true;
            onStartInputView(mInputEditorInfo, restarting);
            startExtractingText(true);
        } else if (mCandidatesVisibility == View.VISIBLE) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartCandidatesView"");
            mCandidatesViewStarted = true;
            onStartCandidatesView(mInputEditorInfo, restarting);
        }
    } else if (mCanPreRender && mInputEditorInfo != null && mStartedInputConnection != null) {
        // pre-render IME window and keep it invisible.
        if (DEBUG)
            Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName);
        if (mInShowWindow) {
            Log.w(TAG, ""Re-entrance in to showWindow"");
            return;
        }
        mDecorViewWasVisible = mDecorViewVisible;
        mInShowWindow = true;
        startViews(prepareWindow(true));
        // compute visibility
        mIsPreRendered = true;
        onPreRenderedWindowVisibilityChanged(false);
        // When IME is not pre-rendered, this will actually show the IME.
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
        maybeNotifyPreRendered();
        mDecorViewWasVisible = true;
        mInShowWindow = false;
    } else {
        mIsPreRendered = false;
    }
}","{
    if (!restarting) {
        doFinishInput();
    }
    mInputStarted = true;
    mStartedInputConnection = ic;
    mInputEditorInfo = attribute;
    initialize();
    mInlineSuggestionSessionController.notifyOnStartInput(attribute == null ? null : attribute.packageName, attribute == null ? null : attribute.autofillId);
    if (DEBUG)
        Log.v(TAG, ""CALL: onStartInput"");
    onStartInput(attribute, restarting);
    if (mDecorViewVisible) {
        if (mShowInputRequested) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartInputView"");
            mInputViewStarted = true;
            mInlineSuggestionSessionController.notifyOnStartInputView();
            onStartInputView(mInputEditorInfo, restarting);
            startExtractingText(true);
        } else if (mCandidatesVisibility == View.VISIBLE) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartCandidatesView"");
            mCandidatesViewStarted = true;
            onStartCandidatesView(mInputEditorInfo, restarting);
        }
    } else if (mCanPreRender && mInputEditorInfo != null && mStartedInputConnection != null) {
        // pre-render IME window and keep it invisible.
        if (DEBUG)
            Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName);
        if (mInShowWindow) {
            Log.w(TAG, ""Re-entrance in to showWindow"");
            return;
        }
        mDecorViewWasVisible = mDecorViewVisible;
        mInShowWindow = true;
        startViews(prepareWindow(true));
        // compute visibility
        mIsPreRendered = true;
        onPreRenderedWindowVisibilityChanged(false);
        // When IME is not pre-rendered, this will actually show the IME.
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
        maybeNotifyPreRendered();
        mDecorViewWasVisible = true;
        mInShowWindow = false;
    } else {
        mIsPreRendered = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change involves adding a line which calls notifyOnStartInput on the mInlineSuggestionSessionController object with conditions and also another line which calls notifyOnStartInputView on the same object without any surrounding control flow changes. Therefore, the change type is 4.","There is no evidence of change in the method's return type, return values or exceptions being thrown based on the added calls to mInlineSuggestionSessionController. These appear to be notifications that do not impact the flow of the method. Therefore, there are no compatibility issues indicated through the provided information."
889,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int,Callback,Handler)>",29,30,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int,Callback,Handler)>","<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int,Callback,Handler)>",0,"{
    return createVirtualDisplay(null, /* projection */
    name, width, height, densityDpi, surface, flags, callback, handler, null);
}","{
    final VirtualDisplayConfig.Builder builder = new VirtualDisplayConfig.Builder(name, width, height, densityDpi);
    builder.setFlags(flags);
    if (surface != null) {
        builder.setSurface(surface);
    }
    return createVirtualDisplay(null, /* projection */
    builder.build(), callback, handler);
}",1,"/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p><p>
 * As of {@link android.os.Build.VERSION_CODES#KITKAT_WATCH}, the surface may
 * be attached or detached dynamically using {@link VirtualDisplay#setSurface}.
 * Previously, the surface had to be non-null when {@link #createVirtualDisplay}
 * was called and could not be changed for the lifetime of the display.
 * </p><p>
 * Detaching the surface that backs a virtual display has a similar effect to
 * turning off the screen.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, or null if there is none initially.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION},
 * {@link #VIRTUAL_DISPLAY_FLAG_SECURE}, {@link #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY},
 * or {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR}.
 * @param callback Callback to call when the state of the {@link VirtualDisplay} changes
 * @param handler The handler on which the listener should be invoked, or null
 * if the listener should be invoked on the calling thread's looper.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
","/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p><p>
 * As of {@link android.os.Build.VERSION_CODES#KITKAT_WATCH}, the surface may
 * be attached or detached dynamically using {@link VirtualDisplay#setSurface}.
 * Previously, the surface had to be non-null when {@link #createVirtualDisplay}
 * was called and could not be changed for the lifetime of the display.
 * </p><p>
 * Detaching the surface that backs a virtual display has a similar effect to
 * turning off the screen.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, or null if there is none initially.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION},
 * {@link #VIRTUAL_DISPLAY_FLAG_SECURE}, {@link #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY},
 * or {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR}.
 * @param callback Callback to call when the state of the {@link VirtualDisplay} changes
 * @param handler The handler on which the listener should be invoked, or null
 * if the listener should be invoked on the calling thread's looper.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The late version implementation has introduced a new VirtualDisplayConfig.Builder object to construct arguments that are passed to the createVirtualDisplay method, and also the method 'createVirtualDisplay' itself involves a different number of arguments. This is a significant structural change in the API implementation, categorized under change type 1 for a different return statement and 5 for dependent API change.","Since the VirtualDisplayConfig.Builder is used to build the configuration and the resulting configuration object is then used as an argument in the createVirtualDisplay method, it's plausible that the constructed object and behavior might differ from directly passing the flags and surface as was done in the early version. This constitutes a potential for different return values, and hence aligns with CI type 1."
890,<android.widget.CompoundButton: void setChecked(boolean)>,29,30,<android.widget.CompoundButton: void setChecked(boolean)>,<android.widget.CompoundButton: void setChecked(boolean)>,0,"{
    if (mChecked != checked) {
        mCheckedFromResource = false;
        mChecked = checked;
        refreshDrawableState();
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        final AutofillManager afm = mContext.getSystemService(AutofillManager.class);
        if (afm != null) {
            afm.notifyValueChanged(this);
        }
        mBroadcasting = false;
    }
}","{
    if (mChecked != checked) {
        mCheckedFromResource = false;
        mChecked = checked;
        refreshDrawableState();
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        final AutofillManager afm = mContext.getSystemService(AutofillManager.class);
        if (afm != null) {
            afm.notifyValueChanged(this);
        }
        mBroadcasting = false;
    }
    // setStateDescription will not send out event if the description is unchanged.
    setDefaultStateDescritption();
}",1,"/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
","/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The method implementation contains an additional method call to setDefaultStateDescritption() at the end of the method body, and this is neither in existing control statements nor does it change exception handling or return statements; it's under no conditional or control dependency. The code change type is 3 (for the insertion of the new method outside of control structures), and it is also considered as 4 because calling setDefaultStateDescritption() is an ""Other statement changed"".","The change involves a method call to setDefaultStateDescription() after the if block and does not affect the existing program flow, exceptions or the method's return type or values. Therefore, it does not seem to lead to potential different return values or new exceptions that would not have been thrown before, so there is no Compatibility Issue expected from this change."
891,<android.view.inputmethod.InputMethodManager: boolean isActive()>,29,30,<android.view.inputmethod.InputMethodManager: boolean isActive()>,<android.view.inputmethod.InputMethodManager: boolean isActive()>,0,"{
    checkFocus();
    synchronized (mH) {
        return mServedView != null && mCurrentTextBoxAttribute != null;
    }
}","{
    checkFocus();
    synchronized (mH) {
        return getServedViewLocked() != null && mCurrentTextBoxAttribute != null;
    }
}",1,"/**
 * Return true if any view is currently active in the input method.
 */
","/**
 * Return true if any view is currently active in the input method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method invoked inside the return statement changed from directly accessing mServedView to calling getServedViewLocked(). Thus, the change type is 5.","As long as getServedViewLocked() is internally equivalent to directly accessing mServedView, and there are no changes in the return type or the structure of the control flow, there is no Compatibility Issue. Assuming getServedViewLocked() provides the same value that would have been provided by mServedView, the behavior of isActive() would remain unchanged, hence no CI."
892,<android.service.autofill.Dataset: String toString()>,29,30,<android.service.autofill.Dataset: String toString()>,<android.service.autofill.Dataset: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""Dataset["");
    if (mId == null) {
        builder.append(""noId"");
    } else {
        // Cannot disclose id because it could contain PII.
        builder.append(""id="").append(mId.length()).append(""_chars"");
    }
    if (mFieldIds != null) {
        builder.append("", fieldIds="").append(mFieldIds);
    }
    if (mFieldValues != null) {
        builder.append("", fieldValues="").append(mFieldValues);
    }
    if (mFieldPresentations != null) {
        builder.append("", fieldPresentations="").append(mFieldPresentations.size());
    }
    if (mFieldFilters != null) {
        builder.append("", fieldFilters="").append(mFieldFilters.size());
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    return builder.append(']').toString();
}","{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""Dataset["");
    if (mId == null) {
        builder.append(""noId"");
    } else {
        // Cannot disclose id because it could contain PII.
        builder.append(""id="").append(mId.length()).append(""_chars"");
    }
    if (mFieldIds != null) {
        builder.append("", fieldIds="").append(mFieldIds);
    }
    if (mFieldValues != null) {
        builder.append("", fieldValues="").append(mFieldValues);
    }
    if (mFieldPresentations != null) {
        builder.append("", fieldPresentations="").append(mFieldPresentations.size());
    }
    if (mFieldInlinePresentations != null) {
        builder.append("", fieldInlinePresentations="").append(mFieldInlinePresentations.size());
    }
    if (mFieldFilters != null) {
        builder.append("", fieldFilters="").append(mFieldFilters.size());
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    return builder.append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There is an addition of code to check for the new fields `mFieldInlinePresentations` and `mInlinePresentation`. These changes are appending new information to the `StringBuilder` object but do not alter the method's control flow or exception handling. Since this is a `toString()` method, which typically does not affect the program's logic, the changes are categorized as Other statement changed (4) and Control dependency change (3) because the output now has additional conditions in the control flow.","There's no Compatibility Issue because the `toString()` method is generally used for debugging or logging purposes, so the behavior of the program shouldn't rely on the exact output of `toString()`. The additional information in the `toString()` output does not affect the actual functionality or return type of the method."
893,"<android.view.WindowInsets: WindowInsets inset(int,int,int,int)>",29,30,"<android.view.WindowInsets: WindowInsets inset(int,int,int,int)>","<android.view.WindowInsets: WindowInsets inset(int,int,int,int)>",0,"{
    Preconditions.checkArgumentNonnegative(left);
    Preconditions.checkArgumentNonnegative(top);
    Preconditions.checkArgumentNonnegative(right);
    Preconditions.checkArgumentNonnegative(bottom);
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : insetInsets(mTypeInsetsMap, left, top, right, bottom), mStableInsetsConsumed ? null : insetInsets(mTypeMaxInsetsMap, left, top, right, bottom), mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutoutConsumed ? null : mDisplayCutout == null ? DisplayCutout.NO_CUTOUT : mDisplayCutout.inset(left, top, right, bottom));
}","{
    Preconditions.checkArgumentNonnegative(left);
    Preconditions.checkArgumentNonnegative(top);
    Preconditions.checkArgumentNonnegative(right);
    Preconditions.checkArgumentNonnegative(bottom);
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : insetInsets(mTypeInsetsMap, left, top, right, bottom), mStableInsetsConsumed ? null : insetInsets(mTypeMaxInsetsMap, left, top, right, bottom), mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutoutConsumed ? null : mDisplayCutout == null ? DisplayCutout.NO_CUTOUT : mDisplayCutout.inset(left, top, right, bottom), mCompatInsetsTypes, mCompatIgnoreVisibility);
}",1,"/**
 * Returns a copy of this instance inset in the given directions.
 *
 * This is intended for dispatching insets to areas of the window that are smaller than the
 * current area.
 *
 * <p>Example:
 * <pre>
 * childView.dispatchApplyWindowInsets(insets.inset(
 * childMarginLeft, childMarginTop, childMarginBottom, childMarginRight));
 * </pre>
 *
 * @param left the amount of insets to remove from the left. Must be non-negative.
 * @param top the amount of insets to remove from the top. Must be non-negative.
 * @param right the amount of insets to remove from the right. Must be non-negative.
 * @param bottom the amount of insets to remove from the bottom. Must be non-negative.
 *
 * @return the inset insets
 */
","/**
 * Returns a copy of this instance inset in the given directions.
 *
 * This is intended for dispatching insets to areas of the window that are smaller than the
 * current area.
 *
 * <p>Example:
 * <pre>
 * childView.dispatchApplyWindowInsets(insets.inset(
 * childMarginLeft, childMarginTop, childMarginBottom, childMarginRight));
 * </pre>
 *
 * @param left the amount of insets to remove from the left. Must be non-negative.
 * @param top the amount of insets to remove from the top. Must be non-negative.
 * @param right the amount of insets to remove from the right. Must be non-negative.
 * @param bottom the amount of insets to remove from the bottom. Must be non-negative.
 *
 * @return the inset insets
 *
 * @see #inset(Insets)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The constructor for creating a new WindowInsets object has additional parameters in the late version (mCompatInsetsTypes, mCompatIgnoreVisibility), which means the change type is 4 (Other statement changed).","Although the constructor call for WindowInsets has additional parameters, there is no Compatibility Issue detected, as the contract of the method has not changed, and the additional parameters don't affect how the method behaves with respect to the data types and exceptions witnessed by the caller based on the given code. Thus, the CI type is 0 (No Compatibility Issue)."
894,"<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>",29,30,"<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>","<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursor(view, left, top, right, bottom);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        mTmpCursorRect.set(left, top, right, bottom);
        if (!mCursorRect.equals(mTmpCursorRect)) {
            if (DEBUG)
                Log.d(TAG, ""updateCursor"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""CURSOR CHANGE: "" + mCurMethod);
                mCurMethod.updateCursor(mTmpCursorRect);
                mCursorRect.set(mTmpCursorRect);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursor(view, left, top, right, bottom);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        mTmpCursorRect.set(left, top, right, bottom);
        if (!mCursorRect.equals(mTmpCursorRect)) {
            if (DEBUG)
                Log.d(TAG, ""updateCursor"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""CURSOR CHANGE: "" + mCurMethod);
                mCurMethod.updateCursor(mTmpCursorRect);
                mCursorRect.set(mTmpCursorRect);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}",1,"/**
 * Report the current cursor location in its window.
 *
 * @deprecated Use {@link #updateCursorAnchorInfo(View, CursorAnchorInfo)} instead.
 */
","/**
 * Report the current cursor location in its window.
 *
 * @deprecated Use {@link #updateCursorAnchorInfo(View, CursorAnchorInfo)} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4",0,"The change is the call of a different method `hasServedByInputMethodLocked(view)` instead of the inline conditional checks that were present in the early version. The method likely encapsulates these checks, which are part of a control dependency. Additionally, the debug log statement with tag `TAG` is slightly modified (the content is wrapped in a conditional block `if (DEBUG)`) which is classified under 4 as an ""Other statement changed.""","Though the control flow structure was changed, this modification does not lead to a change in behavior because the newly introduced helper method `hasServedByInputMethodLocked(view)` is expected to perform the same checks as the inline conditional in the early version. Therefore, there is no Compatibility Issue; hence, pred_CI is 0."
895,<android.app.Notification.Action.Builder: Action build()>,29,30,<android.app.Notification.Action.Builder: Action build()>,<android.app.Notification.Action.Builder: Action build()>,0,"{
    checkContextualActionNullFields();
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction, mIsContextual);
}","{
    checkContextualActionNullFields();
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = getParcelableArrayFromBundle(mExtras, EXTRA_DATA_ONLY_INPUTS, RemoteInput.class);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction, mIsContextual);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method used to retrieve the parcelable array from the extras bundle has changed from `mExtras.getParcelableArray()` to `getParcelableArrayFromBundle(mExtras, EXTRA_DATA_ONLY_INPUTS, RemoteInput.class)`. This alteration represents a change in a dependent API. No return statement, exception handling statements, or control dependencies have been altered.","There is no compatibility issue introduced, as the method's behavior remains effectively the same. The new helper method `getParcelableArrayFromBundle` likely provides additional safety checks or casting, but it ultimately serves the same purpose as the previous code for getting `RemoteInput[]` from extras. The return value remains consistent with no alterations to exception handling or control flow, hence no compatibility issue is present."
897,<android.content.ContentResolver: Uri canonicalize(Uri)>,29,30,<android.content.ContentResolver: Uri canonicalize(Uri)>,<android.content.ContentResolver: Uri canonicalize(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.canonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.canonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.canonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        final UriResultListener resultListener = new UriResultListener();
        provider.canonicalizeAsync(mPackageName, mAttributionTag, url, new RemoteCallback(resultListener));
        resultListener.waitForResult(CONTENT_PROVIDER_TIMEOUT_MILLIS);
        if (resultListener.exception != null) {
            throw resultListener.exception;
        }
        return resultListener.result;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Transform the given <var>url</var> to a canonical representation of
 * its referenced resource, which can be used across devices, persisted,
 * backed up and restored, etc.  The returned Uri is still a fully capable
 * Uri for use with its content provider, allowing you to do all of the
 * same content provider operations as with the original Uri --
 * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
 * only difference in behavior between the original and new Uris is that
 * the content provider may need to do some additional work at each call
 * using it to resolve it to the correct resource, especially if the
 * canonical Uri has been moved to a different environment.
 *
 * <p>If you are moving a canonical Uri between environments, you should
 * perform another call to {@link #canonicalize} with that original Uri to
 * re-canonicalize it for the current environment.  Alternatively, you may
 * want to use {@link #uncanonicalize} to transform it to a non-canonical
 * Uri that works only in the current environment but potentially more
 * efficiently than the canonical representation.</p>
 *
 * @param url The {@link Uri} that is to be transformed to a canonical
 * representation.  Like all resolver calls, the input can be either
 * a non-canonical or canonical Uri.
 *
 * @return Returns the official canonical representation of <var>url</var>,
 * or null if the content provider does not support a canonical representation
 * of the given Uri.  Many providers may not support canonicalization of some
 * or all of their Uris.
 *
 * @see #uncanonicalize
 */
","/**
 * Transform the given <var>url</var> to a canonical representation of
 * its referenced resource, which can be used across devices, persisted,
 * backed up and restored, etc.  The returned Uri is still a fully capable
 * Uri for use with its content provider, allowing you to do all of the
 * same content provider operations as with the original Uri --
 * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
 * only difference in behavior between the original and new Uris is that
 * the content provider may need to do some additional work at each call
 * using it to resolve it to the correct resource, especially if the
 * canonical Uri has been moved to a different environment.
 *
 * <p>If you are moving a canonical Uri between environments, you should
 * perform another call to {@link #canonicalize} with that original Uri to
 * re-canonicalize it for the current environment.  Alternatively, you may
 * want to use {@link #uncanonicalize} to transform it to a non-canonical
 * Uri that works only in the current environment but potentially more
 * efficiently than the canonical representation.</p>
 *
 * @param url The {@link Uri} that is to be transformed to a canonical
 * representation.  Like all resolver calls, the input can be either
 * a non-canonical or canonical Uri.
 *
 * @return Returns the official canonical representation of <var>url</var>,
 * or null if the content provider does not support a canonical representation
 * of the given Uri.  Many providers may not support canonicalization of some
 * or all of their Uris.
 *
 * @see #uncanonicalize
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","In the late implementation, the following changes are observed: ","- The method of invoking 'provider.canonicalize' changed to 'provider.canonicalizeAsync' with additional parameters, indicating a dependent API change (5)."
899,"<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>",29,30,"<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>","<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>",0,"{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    GraphicBuffer graphicBuffer = bitmap.createGraphicBufferHandle();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER, graphicBuffer);
                    ColorSpace cs = bitmap.getColorSpace();
                    if (cs != null) {
                        bundle.putInt(BUNDLE_SNAPSHOT_COLOR_SPACE, cs.getId());
                    }
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}","{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    HardwareBuffer hardwareBuffer = bitmap.getHardwareBuffer();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_HARDWARE_BUFFER, hardwareBuffer);
                    ColorSpace cs = bitmap.getColorSpace();
                    if (cs != null) {
                        bundle.putInt(BUNDLE_SNAPSHOT_COLOR_SPACE, cs.getId());
                    }
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}",1,"/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */
","/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method ""bitmap.createGraphicBufferHandle()"" has been replaced with ""bitmap.getHardwareBuffer()"" and the bundle key changed from BUNDLE_SNAPSHOT_GRAPHIC_BUFFER to BUNDLE_SNAPSHOT_HARDWARE_BUFFER, indicating a change in the dependent API, so the code change type is 4,5.","The change in the way the bitmap is handled and the subsequent bundling of that data could potentially lead to the API returning a different Parcelable object in the bundle, thus the CI type is 1."
900,<android.permission.PermissionManager.SplitPermissionInfo: String getSplitPermission()>,29,30,<android.permission.PermissionManager.SplitPermissionInfo: String getSplitPermission()>,<android.permission.PermissionManager.SplitPermissionInfo: String getSplitPermission()>,0,"{
    return mSplitPerm;
}","{
    return mSplitPermissionInfoParcelable.getSplitPermission();
}",1,"/**
 * Get the permission that is split.
 */
","/**
 * Get the permission that is split.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method of getting the value for the return statement has changed. The early version returns directly the member variable 'mSplitPerm', while the late version calls a method 'getSplitPermission()' on the object 'mSplitPermissionInfoParcelable'. This implies a dependency change, so the change type is 5.","As long as the 'getSplitPermission()' method on 'mSplitPermissionInfoParcelable' is guaranteed to return the same value as 'mSplitPerm', there will be no compatibility issue regarding the return type or value. Since the annotation [@NonNull] remains unchanged and ensures that a non-null value will be returned, it does not indicate any issue with returned values or exceptions. Hence, there is no compatibility issue, and the CI type is 0."
901,"<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>",29,30,"<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>","<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>",0,"{
    if (args != null && args.length > 0) {
        // Handle special cases
        switch(args[0]) {
            case ""--autofill"":
                dumpAutofillManager(prefix, writer);
                return;
            case ""--contentcapture"":
                dumpContentCaptureManager(prefix, writer);
                return;
        }
    }
    writer.print(prefix);
    writer.print(""Local Activity "");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println("" State:"");
    String innerPrefix = prefix + ""  "";
    writer.print(innerPrefix);
    writer.print(""mResumed="");
    writer.print(mResumed);
    writer.print("" mStopped="");
    writer.print(mStopped);
    writer.print("" mFinished="");
    writer.println(mFinished);
    writer.print(innerPrefix);
    writer.print(""mChangingConfigurations="");
    writer.println(mChangingConfigurations);
    writer.print(innerPrefix);
    writer.print(""mCurrentConfig="");
    writer.println(mCurrentConfig);
    mFragments.dumpLoaders(innerPrefix, fd, writer, args);
    mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.dump(innerPrefix, fd, writer, args);
    }
    if (getWindow() != null && getWindow().peekDecorView() != null && getWindow().peekDecorView().getViewRootImpl() != null) {
        getWindow().peekDecorView().getViewRootImpl().dump(prefix, fd, writer, args);
    }
    mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
    dumpAutofillManager(prefix, writer);
    dumpContentCaptureManager(prefix, writer);
    ResourcesManager.getInstance().dump(prefix, writer);
}","{
    if (args != null && args.length > 0) {
        // Handle special cases
        switch(args[0]) {
            case ""--autofill"":
                dumpAutofillManager(prefix, writer);
                return;
            case ""--contentcapture"":
                dumpContentCaptureManager(prefix, writer);
                return;
        }
    }
    writer.print(prefix);
    writer.print(""Local Activity "");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println("" State:"");
    String innerPrefix = prefix + ""  "";
    writer.print(innerPrefix);
    writer.print(""mResumed="");
    writer.print(mResumed);
    writer.print("" mStopped="");
    writer.print(mStopped);
    writer.print("" mFinished="");
    writer.println(mFinished);
    writer.print(innerPrefix);
    writer.print(""mIsInMultiWindowMode="");
    writer.print(mIsInMultiWindowMode);
    writer.print("" mIsInPictureInPictureMode="");
    writer.println(mIsInPictureInPictureMode);
    writer.print(innerPrefix);
    writer.print(""mChangingConfigurations="");
    writer.println(mChangingConfigurations);
    writer.print(innerPrefix);
    writer.print(""mCurrentConfig="");
    writer.println(mCurrentConfig);
    if (getResources().hasOverrideDisplayAdjustments()) {
        writer.print(innerPrefix);
        writer.print(""FixedRotationAdjustments="");
        writer.println(getResources().getDisplayAdjustments().getFixedRotationAdjustments());
    }
    mFragments.dumpLoaders(innerPrefix, fd, writer, args);
    mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.dump(innerPrefix, fd, writer, args);
    }
    if (getWindow() != null && getWindow().peekDecorView() != null && getWindow().peekDecorView().getViewRootImpl() != null) {
        getWindow().peekDecorView().getViewRootImpl().dump(prefix, fd, writer, args);
    }
    mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
    dumpAutofillManager(prefix, writer);
    dumpContentCaptureManager(prefix, writer);
    ResourcesManager.getInstance().dump(prefix, writer);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are new print statements added to print ""mIsInMultiWindowMode"" and ""mIsInPictureInPictureMode,"" along with a conditionally executed block that prints out ""FixedRotationAdjustments."" These changes are categorized as (3) since they change what is being printed, and (4) because they are neither return, exception handling, control dependency changes, nor changes of a dependent API. There is also a change of the order of statements concerning the dumping of the autofill manager and content capture manager, but since they are both executed unconditionally and are just swapped, they do not affect the execution flow.","There are no changes to return values, thrown exceptions, or execution flows based on different inputs, so no Compatibility Issue arises in the API's behavior. These changes purely affect the output to the PrintWriter, which typically won't result in binary incompatibilities for callers of `dumpInner`."
904,"<android.content.res.AssetManager: boolean resolveAttrs(long,int,int,int[],int[],int[],int[])>",29,30,"<android.content.res.AssetManager: boolean resolveAttrs(long,int,int,int[],int[],int[],int[])>","<android.content.res.AssetManager: boolean resolveAttrs(long,int,int,int[],int[],int[],int[])>",0,"{
    Preconditions.checkNotNull(inAttrs, ""inAttrs"");
    Preconditions.checkNotNull(outValues, ""outValues"");
    Preconditions.checkNotNull(outIndices, ""outIndices"");
    synchronized (this) {
        // Need to synchronize on AssetManager because we will be accessing
        // the native implementation of AssetManager.
        ensureValidLocked();
        return nativeResolveAttrs(mObject, themePtr, defStyleAttr, defStyleRes, inValues, inAttrs, outValues, outIndices);
    }
}","{
    Objects.requireNonNull(inAttrs, ""inAttrs"");
    Objects.requireNonNull(outValues, ""outValues"");
    Objects.requireNonNull(outIndices, ""outIndices"");
    synchronized (this) {
        // Need to synchronize on AssetManager because we will be accessing
        // the native implementation of AssetManager.
        ensureValidLocked();
        return nativeResolveAttrs(mObject, themePtr, defStyleAttr, defStyleRes, inValues, inAttrs, outValues, outIndices);
    }
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is from using Preconditions.checkNotNull to Objects.requireNonNull for input parameter validation, which both perform null checks but come from different utility classes. The dependent API call has thus changed, and since the methods are semantically equivalent, we have a change type 4,5.","There is no Compatibility Issue because both Preconditions.checkNotNull and Objects.requireNonNull serve the same purpose and have equivalent functionality. The behavior of the API has not been altered in terms of returned values, thrown exceptions, or control flow. Hence, CI type is 0."
906,<android.view.autofill.AutofillManager.AugmentedAutofillManagerClient: Rect getViewCoordinates(AutofillId)>,29,30,<android.view.autofill.AutofillManager.AugmentedAutofillManagerClient: Rect getViewCoordinates(AutofillId)>,<android.view.autofill.AutofillManager.AugmentedAutofillManagerClient: Rect getViewCoordinates(AutofillId)>,0,"{
    final AutofillManager afm = mAfm.get();
    if (afm == null)
        return null;
    final AutofillClient client = afm.getClient();
    if (client == null) {
        Log.w(TAG, ""getViewCoordinates("" + id + ""): no autofill client"");
        return null;
    }
    final View view = client.autofillClientFindViewByAutofillIdTraversal(id);
    if (view == null) {
        Log.w(TAG, ""getViewCoordinates("" + id + ""): could not find view"");
        return null;
    }
    final Rect windowVisibleDisplayFrame = new Rect();
    view.getWindowVisibleDisplayFrame(windowVisibleDisplayFrame);
    final int[] location = new int[2];
    view.getLocationOnScreen(location);
    final Rect rect = new Rect(location[0], location[1] - windowVisibleDisplayFrame.top, location[0] + view.getWidth(), location[1] - windowVisibleDisplayFrame.top + view.getHeight());
    if (sVerbose) {
        Log.v(TAG, ""Coordinates for "" + id + "": "" + rect);
    }
    return rect;
}","{
    final AutofillManager afm = mAfm.get();
    if (afm == null)
        return null;
    final View view = getView(afm, id);
    if (view == null) {
        return null;
    }
    final Rect windowVisibleDisplayFrame = new Rect();
    view.getWindowVisibleDisplayFrame(windowVisibleDisplayFrame);
    final int[] location = new int[2];
    view.getLocationOnScreen(location);
    final Rect rect = new Rect(location[0], location[1] - windowVisibleDisplayFrame.top, location[0] + view.getWidth(), location[1] - windowVisibleDisplayFrame.top + view.getHeight());
    if (sVerbose) {
        Log.v(TAG, ""Coordinates for "" + id + "": "" + rect);
    }
    return rect;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The code change includes refactoring where part of the logic is moved to a new method getView(), the Log warning in the case of the client being null is removed, and the method call to client.autofillClientFindViewByAutofillIdTraversal() has been replaced by the new getView() method. Therefore, the following changes are present: Control dependency changed (the code path now uses the new getView method), Other statement changed (removal of the Log call), and Dependent API changed (reliance on a new or modified API, getView()).","There is no Compatibility Issue because the external behavior of the API and the contract of the return value have not changed. The refactoring does not alter the conditions under which a Rect is returned or null is returned; it simply changes the internal workings of how the View object is retrieved. All return paths provide the same Rect semantics as before, and no new exceptions are introduced. The removed log statement does not affect the API's behavior from the perspective of its caller."
907,<android.view.autofill.AutofillManager: boolean isFieldClassificationEnabled()>,29,30,<android.view.autofill.AutofillManager: boolean isFieldClassificationEnabled()>,<android.view.autofill.AutofillManager: boolean isFieldClassificationEnabled()>,0,"{
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.isFieldClassificationEnabled(receiver);
        return receiver.getIntResult() == 1;
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return false;
    }
}","{
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.isFieldClassificationEnabled(receiver);
        return receiver.getIntResult() == 1;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get field classification enabled status."");
    }
}",1,"/**
 * Checks if <a href=""AutofillService.html#FieldClassification"">field classification</a> is
 * enabled.
 *
 * <p>As field classification is an expensive operation, it could be disabled, either
 * temporarily (for example, because the service exceeded a rate-limit threshold) or
 * permanently (for example, because the device is a low-level device).
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
","/**
 * Checks if <a href=""AutofillService.html#FieldClassification"">field classification</a> is
 * enabled.
 *
 * <p>As field classification is an expensive operation, it could be disabled, either
 * temporarily (for example, because the service exceeded a rate-limit threshold) or
 * permanently (for example, because the device is a low-level device).
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,The exception handling statement has changed by the addition of a new catch block for `SyncResultReceiver.TimeoutException` so the change type is 2.,"The late version introduces a new potential source of exceptions by throwing a `RuntimeException` if a timeout occurs (`SyncResultReceiver.TimeoutException` is caught). This can cause different exception handling compared to the early version which did not include this catch block. Therefore, the late version of the API could lead to an `RuntimeException` being thrown where the early version would not, indicating a CI type of 2."
908,<android.os.ServiceManagerProxy: String[] listServices(int)>,29,30,<android.os.ServiceManagerProxy: String[] listServices(int)>,<android.os.ServiceManagerProxy: String[] listServices(int)>,0,"{
    ArrayList<String> services = new ArrayList<String>();
    int n = 0;
    while (true) {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IServiceManager.descriptor);
        data.writeInt(n);
        data.writeInt(dumpPriority);
        n++;
        try {
            boolean res = mRemote.transact(LIST_SERVICES_TRANSACTION, data, reply, 0);
            if (!res) {
                break;
            }
        } catch (RuntimeException e) {
            // returning a nice result...  so eat it here and go on.
            break;
        }
        services.add(reply.readString());
        reply.recycle();
        data.recycle();
    }
    String[] array = new String[services.size()];
    services.toArray(array);
    return array;
}","{
    return mServiceManager.listServices(dumpPriority);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed from a block of code that performs a loop and various operations to a single method call to mServiceManager.listServices(dumpPriority), and the method used in the return statement has changed from an internal implementation to a different method, so the code change type is 1,5.","The original code has been replaced by a different implementation altogether which likely has a different behaviour. The late version API's behaviour will solely depend on mServiceManager.listServices(dumpPriority), and given that this is a method call change, it could potentially return different values from the earlier version. Therefore, the CI type is 1."
909,<android.os.Parcel: String[] createStringArray()>,29,30,<android.os.Parcel: String[] createStringArray()>,<android.os.Parcel: String[] createStringArray()>,0,"{
    int N = readInt();
    if (N >= 0) {
        String[] val = new String[N];
        for (int i = 0; i < N; i++) {
            val[i] = readString();
        }
        return val;
    } else {
        return null;
    }
}","{
    return createString16Array();
}",1,,,-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The implementation uses a different dependent API createString16Array() instead of manually creating and populating the String[]. Therefore, the code change type is 5.","Assuming createString16Array() does the exact same thing which is to create a String array from the Parcel data, which was also done by the previous implementation, there wouldn't be a difference in the behavior of the API. It's an internal refactoring that should not modify the outward behavior. Thus, there is no Compatibility Issue; the CI type is 0."
910,<android.view.autofill.AutofillManager: ComponentName getAutofillServiceComponentName()>,29,30,<android.view.autofill.AutofillManager: ComponentName getAutofillServiceComponentName()>,<android.view.autofill.AutofillManager: ComponentName getAutofillServiceComponentName()>,0,"{
    if (mService == null)
        return null;
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getAutofillServiceComponentName(receiver);
        return receiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null)
        return null;
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getAutofillServiceComponentName(receiver);
        return receiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get autofill services component name."");
    }
}",1,"/**
 * Returns the component name of the {@link AutofillService} that is enabled for the current
 * user.
 */
","/**
 * Returns the component name of the {@link AutofillService} that is enabled for the current
 * user.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,2,2,"An additional exception handling for SyncResultReceiver.TimeoutException has been introduced, so the code change type is 2.","Since a new exception handling statement for SyncResultReceiver.TimeoutException was added and it throws a new RuntimeException that was not present in the previous version, this change could potentially lead to different exception handlings. Therefore, the CI type is 2."
911,<android.util.Half: int getExponent(short)>,29,30,<android.util.Half: int getExponent(short)>,<android.util.Half: int getExponent(short)>,0,"{
    return ((h >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK) - FP16_EXPONENT_BIAS;
}","{
    return ((h >>> FP16.EXPONENT_SHIFT) & FP16.SHIFTED_EXPONENT_MASK) - FP16.EXPONENT_BIAS;
}",1,"/**
 * Returns the unbiased exponent used in the representation of
 * the specified  half-precision float value. if the value is NaN
 * or infinite, this* method returns {@link #MAX_EXPONENT} + 1.
 * If the argument is 0 or a subnormal representation, this method
 * returns {@link #MIN_EXPONENT} - 1.
 *
 * @param h A half-precision float value
 * @return The unbiased exponent of the specified value
 */
","/**
 * Returns the unbiased exponent used in the representation of
 * the specified  half-precision float value. if the value is NaN
 * or infinite, this* method returns {@link #MAX_EXPONENT} + 1.
 * If the argument is 0 or a subnormal representation, this method
 * returns {@link #MIN_EXPONENT} - 1.
 *
 * @param h A half-precision float value
 * @return The unbiased exponent of the specified value
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The constants from FP16_EXPONENT_SHIFT, FP16_EXPONENT_MASK, and FP16_EXPONENT_BIAS have been changed to FP16.EXPONENT_SHIFT, FP16.SHIFTED_EXPONENT_MASK, and FP16.EXPONENT_BIAS respectively. This indicates that there have been changes in the dependent API (constant values), so the code change type is 5.","The modified constants still represent the same underlying value, as these seem to be just changes in how the field names are referenced, potentially due to refactoring for better code organization (moving them to the FP16 class). Assuming that the new constants' values are identical to the old ones, there would be no change in the behavior of the method. Therefore, this would not cause a Compatibility Issue, and the CI type is 0."
912,"<android.provider.Settings.Global: boolean putString(ContentResolver,String,String)>",29,30,"<android.provider.Settings.Global: boolean putString(ContentResolver,String,String)>","<android.provider.Settings.Global: boolean putString(ContentResolver,String,String)>",0,"{
    return putStringForUser(resolver, name, value, null, false, resolver.getUserId());
}","{
    return putStringForUser(resolver, name, value, null, false, resolver.getUserId(), DEFAULT_OVERRIDEABLE_BY_RESTORE);
}",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in calling `putStringForUser` with an additional parameter `DEFAULT_OVERRIDEABLE_BY_RESTORE` being passed in the late version. This modification implies a change in the dependent API, so the code change type is 5.","Without additional context on how `DEFAULT_OVERRIDEABLE_BY_RESTORE` affects the behavior of `putStringForUser`, we cannot definitively say there is a compatibility issue solely based on the addition of a constant parameter to a method call. Compatibility issues would depend on the logic inside `putStringForUser`. Assuming `DEFAULT_OVERRIDEABLE_BY_RESTORE` is a behavior flag that does not alter the fundamental contract of `putStringForUser` in terms of return value or exceptions, there would be no compatibility issue. Therefore, the CI type is 0."
913,"<android.widget.AutoCompleteTextView: boolean onKeyUp(int,KeyEvent)>",29,30,"<android.widget.AutoCompleteTextView: boolean onKeyUp(int,KeyEvent)>","<android.widget.AutoCompleteTextView: boolean onKeyUp(int,KeyEvent)>",0,"{
    boolean consumed = mPopup.onKeyUp(keyCode, event);
    if (consumed) {
        switch(keyCode) {
            // from the drop down as its content
            case KeyEvent.KEYCODE_ENTER:
            case KeyEvent.KEYCODE_DPAD_CENTER:
            case KeyEvent.KEYCODE_TAB:
                if (event.hasNoModifiers()) {
                    performCompletion();
                }
                return true;
        }
    }
    if (isPopupShowing() && keyCode == KeyEvent.KEYCODE_TAB && event.hasNoModifiers()) {
        performCompletion();
        return true;
    }
    return super.onKeyUp(keyCode, event);
}","{
    boolean consumed = mPopup.onKeyUp(keyCode, event);
    if (consumed) {
        switch(keyCode) {
            // from the drop down as its content
            case KeyEvent.KEYCODE_ENTER:
            case KeyEvent.KEYCODE_NUMPAD_ENTER:
            case KeyEvent.KEYCODE_DPAD_CENTER:
            case KeyEvent.KEYCODE_TAB:
                if (event.hasNoModifiers()) {
                    performCompletion();
                }
                return true;
        }
    }
    if (isPopupShowing() && keyCode == KeyEvent.KEYCODE_TAB && event.hasNoModifiers()) {
        performCompletion();
        return true;
    }
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The only change is the addition of a case for KeyEvent.KEYCODE_NUMPAD_ENTER in the switch statement, which is a type of control dependency change; thus, the change type is 3.","There are no changes to the return statements, exception handling, or dependent API calls. The addition of the case for KeyEvent.KEYCODE_NUMPAD_ENTER does not cause a compatibility issue, as it only adds an additional condition for the method to perform the same action it previously would perform for similar key events. Therefore, there is no CI, and the type is 0."
914,<android.hardware.usb.UsbRequest: boolean cancel()>,29,30,<android.hardware.usb.UsbRequest: boolean cancel()>,<android.hardware.usb.UsbRequest: boolean cancel()>,0,"{
    return native_cancel();
}","{
    if (mConnection == null) {
        return false;
    }
    return mConnection.cancelRequest(this);
}",1,"/**
 * Cancels a pending queue operation.
 *
 * @return true if cancelling succeeded
 */
","/**
 * Cancels a pending queue operation.
 *
 * @return true if cancelling succeeded
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The implementation now includes a control dependency change where a conditional check is introduced (`if (mConnection == null)`). This results in a potential different return value when `mConnection` is `null`, where it will return `false` instead of potentially attempting to cancel the request via `native_cancel()`. Additionally, there is now a dependent API change as it is using `mConnection.cancelRequest(this)` instead of `native_cancel()`, so the change types are 1, 3, 5.","This change introduces a new conditional return value, which can lead to different behavior of the method when `mConnection` is `null`. Previously, the method would call `native_cancel()` regardless of the state of `mConnection`, whereas now it will return `false` if `mConnection` is `null`, thus leading to a compatibility issue type 1."
915,"<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor.MultiClientInputMethodSessionImpl: void startInputOrWindowGainedFocus(IInputContext,int,EditorInfo,int,int,int)>",29,30,"<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor.MultiClientInputMethodSessionImpl: void startInputOrWindowGainedFocus(IInputContext,int,EditorInfo,int,int,int)>","<android.inputmethodservice.MultiClientInputMethodClientCallbackAdaptor.MultiClientInputMethodSessionImpl: void startInputOrWindowGainedFocus(IInputContext,int,EditorInfo,int,int,int)>",0,"{
    synchronized (mSessionLock) {
        if (mCallbackImpl == null || mHandler == null) {
            return;
        }
        final SomeArgs args = SomeArgs.obtain();
        // TODO(Bug 119211536): Remove dependency on AbstractInputMethodService from ICW
        final WeakReference<AbstractInputMethodService> fakeIMS = new WeakReference<>(null);
        args.arg1 = (inputContext == null) ? null : new InputConnectionWrapper(fakeIMS, inputContext, missingMethods, mSessionFinished);
        args.arg2 = editorInfo;
        args.argi1 = controlFlags;
        args.argi2 = softInputMode;
        args.argi3 = windowHandle;
        mHandler.sendMessage(PooledLambda.obtainMessage(CallbackImpl::startInputOrWindowGainedFocus, mCallbackImpl, args));
    }
}","{
    synchronized (mSessionLock) {
        if (mCallbackImpl == null || mHandler == null) {
            return;
        }
        final SomeArgs args = SomeArgs.obtain();
        // TODO(Bug 119211536): Remove dependency on AbstractInputMethodService from ICW
        final WeakReference<AbstractInputMethodService> fakeIMS = new WeakReference<>(null);
        args.arg1 = (inputContext == null) ? null : new InputConnectionWrapper(fakeIMS, inputContext, missingMethods, mCancellationGroupOnFinishSession);
        args.arg2 = editorInfo;
        args.argi1 = controlFlags;
        args.argi2 = softInputMode;
        args.argi3 = windowHandle;
        mHandler.sendMessage(PooledLambda.obtainMessage(CallbackImpl::startInputOrWindowGainedFocus, mCallbackImpl, args));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The only change in the code is the replacement of mSessionFinished with mCancellationGroupOnFinishSession when creating a new instance of InputConnectionWrapper. This change falls under 'Other statement changed' category.,"Since it is a change in the arguments of the constructor of InputConnectionWrapper and it doesn't affect control flow, return values, or exception handling, there is no Compatibility Issue according to the provided definition."
916,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",29,30,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>","<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",0,"{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            return ActivityTaskManager.getService().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData(this);
            intent.prepareToLeaveProcess(this);
            return ActivityTaskManager.getService().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method `migrateExtraStreamToClipData` changed its argument from no argument in `migrateExtraStreamToClipData()` to taking `this` as an argument in `migrateExtraStreamToClipData(this)`. This indicates that a dependent API has changed, so the code change type is 4,5.","The change in the method does not introduce a new behavior of the `startNextMatchingActivity` method in terms of returning a different value or throwing a new exception directly, because the control flow remained the same and the catch block is empty in both versions, meaning that no exception is expected to be thrown or handled differently as a consequence of this particular change. Thus, there's no Compatibility Issue, and the CI type is 0."
917,<android.content.pm.ShortcutManager: List<ShortcutInfo> getManifestShortcuts()>,29,30,<android.content.pm.ShortcutManager: List<ShortcutInfo> getManifestShortcuts()>,<android.content.pm.ShortcutManager: List<ShortcutInfo> getManifestShortcuts()>,0,"{
    try {
        return mService.getManifestShortcuts(mContext.getPackageName(), injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_MANIFEST, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all static (manifest) shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Return all static (manifest) shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called within the try block has changed from getManifestShortcuts() to getShortcuts() with different parameters. This is reflected in the code change type 1,5 since the return statement relies on a different method call, implying a dependent API has also changed.","Given that the implementation now relies on a different method, getShortcuts() instead of getManifestShortcuts(), it has the potential to return a different value which could lead to a change in behavior. Hence, the CI type is 1, indicating a Compatibility Issue caused by potential different return values."
918,<android.app.WallpaperManager: Drawable peekDrawable()>,29,30,<android.app.WallpaperManager: Drawable peekDrawable()>,<android.app.WallpaperManager: Drawable peekDrawable()>,0,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}","{
    final ColorManagementProxy cmProxy = getColorManagementProxy();
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM, cmProxy);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}",1,"/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
","/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The parameter of the method sGlobals.peekWallpaperBitmap() has been changed by adding an additional parameter (cmProxy). This is captured as change type 4 (Other statement changed). Additionally, a new method invocation (getColorManagementProxy()) is used in the late version, which captures change type 5 (Dependent API changed).","No Compatibility Issue arises, as the change does not affect the return values or types, nor does it introduce new exception handlings. The method still returns a Drawable based on the Bitmap obtained, or null if the Bitmap is null, which is consistent with the previous version. Hence, the API's behavior is preserved."
919,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews)>",29,30,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews)>","<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews)>",0,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, null);
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, null, null);
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the  {@code value} parameter.
 *
 * <p>Theme does not work with RemoteViews layout. Avoid hardcoded text color
 * or background color: Autofill on different platforms may have different themes.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the  {@code value} parameter.
 *
 * <p>Theme does not work with RemoteViews layout. Avoid hardcoded text color
 * or background color: Autofill on different platforms may have different themes.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method `setLifeTheUniverseAndEverything` has been called with an additional `null` parameter in the later version. This is a change in a dependent API being called, so the code change type is 5.","Since the additional parameter is `null`, it does not change the semantic or observable behavior of the method in a way that would lead to a Compatibility Issue. The change appears to be an internal change that does not affect callers of this method, assuming that the dependent method is designed to handle the extra `null` parameter without changing its external behavior. Therefore, there is no Compatibility Issue."
920,<android.content.res.AssetManager.AssetInputStream: int read(byte[])>,29,30,<android.content.res.AssetManager.AssetInputStream: int read(byte[])>,<android.content.res.AssetManager.AssetInputStream: int read(byte[])>,0,"{
    ensureOpen();
    Preconditions.checkNotNull(b, ""b"");
    return nativeAssetRead(mAssetNativePtr, b, 0, b.length);
}","{
    ensureOpen();
    Objects.requireNonNull(b, ""b"");
    return nativeAssetRead(mAssetNativePtr, b, 0, b.length);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method used for the null check of the array 'b' changed from Preconditions.checkNotNull() to Objects.requireNonNull(), but both of these methods essentially do the same job and would throw a NullPointException if 'b' is null, and thus the behavior of the API wouldn't change. This qualifies the change as type 4 (Other statement changed).","There is no Compatibility Issue since the change from Preconditions.checkNotNull() to Objects.requireNonNull() doesn't affect the method's return type, values, or the exceptions thrown. The method's signature and behavior remain the same."
921,<android.app.ContextImpl: Display getDisplay()>,29,30,<android.app.ContextImpl: Display getDisplay()>,<android.app.ContextImpl: Display getDisplay()>,0,"{
    if (mDisplay == null) {
        return mResourcesManager.getAdjustedDisplay(Display.DEFAULT_DISPLAY, mResources);
    }
    return mDisplay;
}","{
    if (!mIsSystemOrSystemUiContext && !mIsAssociatedWithDisplay) {
        throw new UnsupportedOperationException(""Tried to obtain display from a Context not "" + ""associated with  one. Only visual Contexts (such as Activity or one created "" + ""with Context#createWindowContext) or ones created with "" + ""Context#createDisplayContext are associated with displays. Other types of "" + ""Contexts are typically related to background entities and may return an "" + ""arbitrary display."");
    }
    return getDisplayNoVerify();
}",1,,,-1,"[@TestApi, @Override]",[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The change includes a new if condition that leads to an exception being thrown, a return statement being removed, and the addition of a new return statement calling a different method (getDisplayNoVerify). Furthermore, the condition being checked has also changed. Therefore, the code change types are 1,2,3,5.","The new exception being thrown could cause the API to throw an UnsupportedOperationException where previously it would have returned a Display object or null. The new condition checks also significantly change the contexts in which a Display object will be successfully returned, which may result in different return values or types. Thus, the CI types are 1,2."
922,<android.net.LinkAddress: boolean equals(Object)>,29,30,<android.net.LinkAddress: boolean equals(Object)>,<android.net.LinkAddress: boolean equals(Object)>,0,"{
    if (!(obj instanceof LinkAddress)) {
        return false;
    }
    LinkAddress linkAddress = (LinkAddress) obj;
    return this.address.equals(linkAddress.address) && this.prefixLength == linkAddress.prefixLength && this.flags == linkAddress.flags && this.scope == linkAddress.scope;
}","{
    if (!(obj instanceof LinkAddress)) {
        return false;
    }
    LinkAddress linkAddress = (LinkAddress) obj;
    return this.address.equals(linkAddress.address) && this.prefixLength == linkAddress.prefixLength && this.flags == linkAddress.flags && this.scope == linkAddress.scope && this.deprecationTime == linkAddress.deprecationTime && this.expirationTime == linkAddress.expirationTime;
}",1,"/**
 * Compares this {@code LinkAddress} instance against {@code obj}. Two addresses are equal if
 * their address, prefix length, flags and scope are equal. Thus, for example, two addresses
 * that have the same address and prefix length are not equal if one of them is deprecated and
 * the other is not.
 *
 * @param obj the object to be tested for equality.
 * @return {@code true} if both objects are equal, {@code false} otherwise.
 */
","/**
 * Compares this {@code LinkAddress} instance against {@code obj}. Two addresses are equal if
 * their address, prefix length, flags and scope are equal. Thus, for example, two addresses
 * that have the same address and prefix length are not equal if one of them is deprecated and
 * the other is not.
 *
 * @param obj the object to be tested for equality.
 * @return {@code true} if both objects are equal, {@code false} otherwise.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,The return statement has been expanded to include checks on two additional fields: this.deprecationTime and this.expirationTime. This means that the comparison between objects of the class now includes more fields.,"The change in the return statement means that the method could potentially return different results for comparisons involving LinkAddress objects. In the earlier version, the comparison did not consider deprecationTime and expirationTime, while the later version does consider them. If a developer was relying on the behavior of equals() from the earlier version, this could lead to unexpected behavior and is therefore a Compatibility Issue caused by potential different return values or types."
923,<android.view.accessibility.AccessibilityEvent: String toString()>,29,30,<android.view.accessibility.AccessibilityEvent: String toString()>,<android.view.accessibility.AccessibilityEvent: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    if (!DEBUG_CONCISE_TOSTRING || mMovementGranularity != 0) {
        builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    }
    if (!DEBUG_CONCISE_TOSTRING || mAction != 0) {
        builder.append(""; Action: "").append(mAction);
    }
    if (!DEBUG_CONCISE_TOSTRING || mContentChangeTypes != 0) {
        builder.append(""; ContentChangeTypes: "").append(contentChangeTypesToString(mContentChangeTypes));
    }
    if (!DEBUG_CONCISE_TOSTRING || mWindowChangeTypes != 0) {
        builder.append(""; WindowChangeTypes: "").append(windowChangeTypesToString(mWindowChangeTypes));
    }
    super.appendTo(builder);
    if (DEBUG || DEBUG_CONCISE_TOSTRING) {
        if (!DEBUG_CONCISE_TOSTRING) {
            builder.append(""\n"");
        }
        if (DEBUG) {
            builder.append(""; SourceWindowId: "").append(mSourceWindowId);
            builder.append(""; SourceNodeId: "").append(mSourceNodeId);
        }
        for (int i = 0; i < getRecordCount(); i++) {
            builder.append(""  Record "").append(i).append("":"");
            getRecord(i).appendTo(builder).append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    if (!DEBUG_CONCISE_TOSTRING || mMovementGranularity != 0) {
        builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    }
    if (!DEBUG_CONCISE_TOSTRING || mAction != 0) {
        builder.append(""; Action: "").append(mAction);
    }
    if (!DEBUG_CONCISE_TOSTRING || mContentChangeTypes != 0) {
        builder.append(""; ContentChangeTypes: "").append(contentChangeTypesToString(mContentChangeTypes));
    }
    if (!DEBUG_CONCISE_TOSTRING || mWindowChangeTypes != 0) {
        builder.append(""; WindowChangeTypes: "").append(windowChangeTypesToString(mWindowChangeTypes));
    }
    super.appendTo(builder);
    if (DEBUG || DEBUG_CONCISE_TOSTRING) {
        if (!DEBUG_CONCISE_TOSTRING) {
            builder.append(""\n"");
        }
        if (DEBUG) {
            builder.append(""; SourceWindowId: 0x"").append(Long.toHexString(mSourceWindowId));
            builder.append(""; SourceNodeId: 0x"").append(Long.toHexString(mSourceNodeId));
        }
        for (int i = 0; i < getRecordCount(); i++) {
            builder.append(""  Record "").append(i).append("":"");
            getRecord(i).appendTo(builder).append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only code change is in the string representation of the mSourceWindowId and mSourceNodeId values. They are formatted as hexadecimal strings in the late version as opposed to plain numbers in the early version. This is classified as an ""Other statement changed"" since it modifies only the output format and not the logic or control flow of the method.",There is no Compatibility Issue since the purpose of the toString() method is to provide a string representation of the object. Changing the format of the output does not affect the behavior or control flow of applications using this API.
924,<android.app.WallpaperManager: Drawable getFastDrawable()>,29,30,<android.app.WallpaperManager: Drawable getFastDrawable()>,<android.app.WallpaperManager: Drawable getFastDrawable()>,0,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true, FLAG_SYSTEM);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}","{
    final ColorManagementProxy cmProxy = getColorManagementProxy();
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true, FLAG_SYSTEM, cmProxy);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}",1,"/**
 * Like {@link #getDrawable()}, but the returned Drawable has a number
 * of limitations to reduce its overhead as much as possible. It will
 * never scale the wallpaper (only centering it if the requested bounds
 * do match the bitmap bounds, which should not be typical), doesn't
 * allow setting an alpha, color filter, or other attributes, etc.  The
 * bounds of the returned drawable will be initialized to the same bounds
 * as the wallpaper, so normally you will not need to touch it.  The
 * drawable also assumes that it will be used in a context running in
 * the same density as the screen (not in density compatibility mode).
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */
","/**
 * Like {@link #getDrawable()}, but the returned Drawable has a number
 * of limitations to reduce its overhead as much as possible. It will
 * never scale the wallpaper (only centering it if the requested bounds
 * do match the bitmap bounds, which should not be typical), doesn't
 * allow setting an alpha, color filter, or other attributes, etc.  The
 * bounds of the returned drawable will be initialized to the same bounds
 * as the wallpaper, so normally you will not need to touch it.  The
 * drawable also assumes that it will be used in a context running in
 * the same density as the screen (not in density compatibility mode).
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */
",-1,[@RequiresPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)],[@RequiresPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)],-1,-1,-1,-1,-1,-1,5,0,"The method 'peekWallpaperBitmap' in the late version API has an additional parameter 'cmProxy' compared to the early version. This reflects a change in a dependent API, consequently, the code change type is 5.","There are no new return statements or new exceptions introduced; the change is purely adding an extra parameter to a method call. As long as the behavior of 'peekWallpaperBitmap' has not changed in a way that it would return a different Bitmap object given the same 'mContext', 'true', 'FLAG_SYSTEM', and regardless of 'cmProxy', and since there's no alteration in exception handling or return statements in 'getFastDrawable()', there is no potential CI introduced by this change. Thus, the CI type is 0."
925,<android.net.RouteInfo: String toString()>,29,30,<android.net.RouteInfo: String toString()>,<android.net.RouteInfo: String toString()>,0,"{
    String val = """";
    if (mDestination != null)
        val = mDestination.toString();
    if (mType == RTN_UNREACHABLE) {
        val += "" unreachable"";
    } else if (mType == RTN_THROW) {
        val += "" throw"";
    } else {
        val += "" ->"";
        if (mGateway != null)
            val += "" "" + mGateway.getHostAddress();
        if (mInterface != null)
            val += "" "" + mInterface;
        if (mType != RTN_UNICAST) {
            val += "" unknown type "" + mType;
        }
    }
    return val;
}","{
    String val = """";
    if (mDestination != null)
        val = mDestination.toString();
    if (mType == RTN_UNREACHABLE) {
        val += "" unreachable"";
    } else if (mType == RTN_THROW) {
        val += "" throw"";
    } else {
        val += "" ->"";
        if (mGateway != null)
            val += "" "" + mGateway.getHostAddress();
        if (mInterface != null)
            val += "" "" + mInterface;
        if (mType != RTN_UNICAST) {
            val += "" unknown type "" + mType;
        }
    }
    val += "" mtu "" + mMtu;
    return val;
}",1,"/**
 * Returns a human-readable description of this object.
 */
","/**
 * Returns a human-readable description of this object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"Another expression has been added to the 'val' string at the end of the method with 'val += "" mtu "" + mMtu;'. Therefore, the change types are both 1 (Return statement changed) and 4 (Other statement changed).","The added string to 'val' within the late version will alter the return value of the method, so there is a Compatibility Issue of type 1 due to potential different return values."
926,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk,String)>",29,30,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk,String)>","<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk,String)>",0,"{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0, null, opPackageName);
    context.setResources(packageInfo.getResources());
    return context;
}","{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, null, 0, null, opPackageName);
    context.setResources(packageInfo.getResources());
    context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);
    return context;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method signature remains the same but a new line of code `context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);` is added, which is assignment to a new member variable. This change is an ""Other statement changed"" type.","This added line of code sets a property on the context object but does not affect the method’s return value or its exception handling. Therefore, there's no Compatibility Issue as the behavior observed by the API's consumer (the return value and the exceptions) remains unchanged."
927,"<android.hardware.usb.UsbDeviceConnection: boolean open(String,ParcelFileDescriptor,Context)>",29,30,"<android.hardware.usb.UsbDeviceConnection: boolean open(String,ParcelFileDescriptor,Context)>","<android.hardware.usb.UsbDeviceConnection: boolean open(String,ParcelFileDescriptor,Context)>",0,"{
    mContext = context.getApplicationContext();
    boolean wasOpened = native_open(name, pfd.getFileDescriptor());
    if (wasOpened) {
        mCloseGuard.open(""close"");
    }
    return wasOpened;
}","{
    mContext = context.getApplicationContext();
    synchronized (mLock) {
        boolean wasOpened = native_open(name, pfd.getFileDescriptor());
        if (wasOpened) {
            mCloseGuard.open(""close"");
        }
        return wasOpened;
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The method implementation has been enclosed within a 'synchronized' block with an unmodified lock object `mLock`, so the code change type is 3.","Adding synchronization does not inherently change the behavior of the return values or exception handling, it rather ensures thread safety during operation. Thus, there is no Compatibility Issue in this case."
928,<android.app.usage.UsageEvents: boolean getNextEvent(Event)>,29,30,<android.app.usage.UsageEvents: boolean getNextEvent(Event)>,<android.app.usage.UsageEvents: boolean getNextEvent(Event)>,0,"{
    if (mIndex >= mEventCount) {
        return false;
    }
    readEventFromParcel(mParcel, eventOut);
    mIndex++;
    if (mIndex >= mEventCount) {
        mParcel.recycle();
        mParcel = null;
    }
    return true;
}","{
    if (mIndex >= mEventCount) {
        return false;
    }
    if (mParcel != null) {
        readEventFromParcel(mParcel, eventOut);
    } else {
        eventOut.copyFrom(mEventsToWrite.get(mIndex));
    }
    mIndex++;
    if (mIndex >= mEventCount && mParcel != null) {
        mParcel.recycle();
        mParcel = null;
    }
    return true;
}",1,"/**
 * Retrieve the next {@link android.app.usage.UsageEvents.Event} from the collection and put the
 * resulting data into {@code eventOut}.
 *
 * @param eventOut The {@link android.app.usage.UsageEvents.Event} object that will receive the
 * next event data.
 * @return true if an event was available, false if there are no more events.
 */
","/**
 * Retrieve the next {@link android.app.usage.UsageEvents.Event} from the collection and put the
 * resulting data into {@code eventOut}.
 *
 * @param eventOut The {@link android.app.usage.UsageEvents.Event} object that will receive the
 * next event data.
 * @return true if an event was available, false if there are no more events.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The additional 'if' condition to check `mParcel != null` has been added, and a new branch for the condition `mParcel == null` where a different method to set `eventOut` is used. Additionally, there's a slight modification in recycling condition, now checking both `mIndex >= mEventCount` and `mParcel != null`. These constitute control dependency changes and other statement changes.","With the addition of a new 'if' condition checking `mParcel != null` and the alternative code path, the variable `eventOut` may be populated differently (from `mParcel` or `mEventsToWrite`). This represents a potential different return value as the state of `eventOut` affects the return value, constituting a CI type 1."
929,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",29,30,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>","<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",0,"{
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}","{
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}",1,"/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfying a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains invalid network capabilities.
 * @throws SecurityException if missing the appropriate permissions.
 * @throws RuntimeException if request limit per UID is exceeded.
 */
","/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfying a request with these capabilities.
 *
 * <p>To avoid performance issues due to apps leaking callbacks, the system will limit the
 * number of outstanding requests to 100 per app (identified by their UID), shared with
 * all variants of this method, of {@link #registerNetworkCallback} as well as
 * {@link ConnectivityDiagnosticsManager#registerConnectivityDiagnosticsCallback}.
 * Requesting a network with this method will count toward this limit. If this limit is
 * exceeded, an exception will be thrown. To avoid hitting this issue and to conserve resources,
 * make sure to unregister the callbacks with {@link #unregisterNetworkCallback(PendingIntent)}
 * or {@link #releaseNetworkRequest(PendingIntent)}.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains invalid network capabilities.
 * @throws SecurityException if missing the appropriate permissions.
 * @throws RuntimeException if the app already has too many callbacks registered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API mService.pendingRequestForNetwork has had an additional parameter added in the late version, which did not exist in the early version. This is a clear example of a change in a dependent API, thus the code change type is 5.","There is an addition of a new parameter to the dependent API call, but it does not change the method's return type or value, nor does it introduce new exceptions or modify existing ones. Therefore, no Compatibility Issue is detected, and the CI type is 0."
930,<android.widget.TextView: TextClassifier getTextClassifier()>,29,30,<android.widget.TextView: TextClassifier getTextClassifier()>,<android.widget.TextView: TextClassifier getTextClassifier()>,0,"{
    if (mTextClassifier == null) {
        final TextClassificationManager tcm = mContext.getSystemService(TextClassificationManager.class);
        if (tcm != null) {
            return tcm.getTextClassifier();
        }
        return TextClassifier.NO_OP;
    }
    return mTextClassifier;
}","{
    if (mTextClassifier == null) {
        final TextClassificationManager tcm = getTextClassificationManagerForUser();
        if (tcm != null) {
            return tcm.getTextClassifier();
        }
        return TextClassifier.NO_OP;
    }
    return mTextClassifier;
}",1,"/**
 * Returns the {@link TextClassifier} used by this TextView.
 * If no TextClassifier has been set, this TextView uses the default set by the
 * {@link TextClassificationManager}.
 */
","/**
 * Returns the {@link TextClassifier} used by this TextView.
 * If no TextClassifier has been set, this TextView uses the default set by the
 * {@link TextClassificationManager}.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call within the if-block has changed from `mContext.getSystemService(TextClassificationManager.class)` to `getTextClassificationManagerForUser()`. This is a change in the dependent API, so the code change type is 5.","There is no Compatibility Issue, the structure and the return statements of the API are unchanged, and only the way of obtaining the `TextClassificationManager` instance is different, which doesn't affect the public API behavior assuming that `getTextClassificationManagerForUser()` is intended to return an equivalent `TextClassificationManager` instance as the prior code did. Hence, there's no change in behavior that could lead to a CI, so CI type is 0."
931,"<android.app.Activity: void dispatchActivityResult(String,int,int,Intent,String)>",29,30,"<android.app.Activity: void dispatchActivityResult(String,int,int,Intent,String)>","<android.app.Activity: void dispatchActivityResult(String,int,int,Intent,String)>",0,"{
    if (false)
        Log.v(TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode + "", resCode="" + resultCode + "", data="" + data);
    mFragments.noteStateNotSaved();
    if (who == null) {
        onActivityResult(requestCode, resultCode, data);
    } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
        who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
        if (TextUtils.isEmpty(who)) {
            dispatchRequestPermissionsResult(requestCode, data);
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
            }
        }
    } else if (who.startsWith(""@android:view:"")) {
        ArrayList<ViewRootImpl> views = WindowManagerGlobal.getInstance().getRootViews(getActivityToken());
        for (ViewRootImpl viewRoot : views) {
            if (viewRoot.getView() != null && viewRoot.getView().dispatchActivityResult(who, requestCode, resultCode, data)) {
                return;
            }
        }
    } else if (who.startsWith(AUTO_FILL_AUTH_WHO_PREFIX)) {
        Intent resultData = (resultCode == Activity.RESULT_OK) ? data : null;
        getAutofillManager().onAuthenticationResult(requestCode, resultData, getCurrentFocus());
    } else {
        Fragment frag = mFragments.findFragmentByWho(who);
        if (frag != null) {
            frag.onActivityResult(requestCode, resultCode, data);
        }
    }
    writeEventLog(LOG_AM_ON_ACTIVITY_RESULT_CALLED, reason);
}","{
    if (false)
        Log.v(TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode + "", resCode="" + resultCode + "", data="" + data);
    mFragments.noteStateNotSaved();
    if (who == null) {
        onActivityResult(requestCode, resultCode, data);
    } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
        who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
        if (TextUtils.isEmpty(who)) {
            dispatchRequestPermissionsResult(requestCode, data);
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
            }
        }
    } else if (who.startsWith(""@android:view:"")) {
        ArrayList<ViewRootImpl> views = WindowManagerGlobal.getInstance().getRootViews(getActivityToken());
        for (ViewRootImpl viewRoot : views) {
            if (viewRoot.getView() != null && viewRoot.getView().dispatchActivityResult(who, requestCode, resultCode, data)) {
                return;
            }
        }
    } else if (who.startsWith(AUTO_FILL_AUTH_WHO_PREFIX)) {
        Intent resultData = (resultCode == Activity.RESULT_OK) ? data : null;
        getAutofillManager().onAuthenticationResult(requestCode, resultData, getCurrentFocus());
    } else {
        Fragment frag = mFragments.findFragmentByWho(who);
        if (frag != null) {
            frag.onActivityResult(requestCode, resultCode, data);
        }
    }
    EventLogTags.writeWmOnActivityResultCalled(mIdent, getComponentName().getClassName(), reason);
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,4,0,"There is a change in the method used to log the event, from `writeEventLog(LOG_AM_ON_ACTIVITY_RESULT_CALLED, reason)` to `EventLogTags.writeWmOnActivityResultCalled(mIdent, getComponentName().getClassName(), reason)`. This is a change in a logging mechanism and does not affect the API's behavior. Hence, the change type is 4.","There is no Compatibility Issue as the change does not affect the method's return value, behavior, or exception handling; it merely changes the internal logging implementation."
933,<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,29,30,<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.viewClicked(view);
        return;
    }
    final boolean focusChanged = mServedView != mNextServedView;
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""onViewClicked: "" + focusChanged);
            mCurMethod.viewClicked(focusChanged);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.viewClicked(view);
        return;
    }
    final View servedView;
    final View nextServedView;
    synchronized (mH) {
        servedView = getServedViewLocked();
        nextServedView = getNextServedViewLocked();
    }
    final boolean focusChanged = servedView != nextServedView;
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""onViewClicked: "" + focusChanged);
            mCurMethod.viewClicked(focusChanged);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}",1,"/**
 * Notify the event when the user tapped or clicked the text view.
 *
 * @param view {@link View} which is being clicked.
 * @see InputMethodService#onViewClicked(boolean)
 * @deprecated The semantics of this method can never be defined well for composite {@link View}
 * that works as a giant ""Canvas"", which can host its own UI hierarchy and sub focus
 * state. {@link android.webkit.WebView} is a good example. Application / IME
 * developers should not rely on this method.
 */
","/**
 * Notify the event when the user tapped or clicked the text view.
 *
 * @param view {@link View} which is being clicked.
 * @see InputMethodService#onViewClicked(boolean)
 * @deprecated The semantics of this method can never be defined well for composite {@link View}
 * that works as a giant ""Canvas"", which can host its own UI hierarchy and sub focus
 * state. {@link android.webkit.WebView} is a good example. Application / IME
 * developers should not rely on this method.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation uses additional local variables `servedView` and `nextServedView` instead of directly accessing `mServedView` and `mNextServedView`. Even though the code structure is changed, it doesn't alter the logic since the behavior remains the same. The 'if' condition has been refactored to a method call `hasServedByInputMethodLocked(view)`. These are changes in control dependency (introduction of local variables) and other changes (refactoring the condition), thus the change type is 3,4.","Even though the code has been restructured, the semantics of the code have not changed. The assignments and checks done in the early version are equivalent to the assignments and checks done in the late version; they now use a method call that presumably encapsulates the same logic. Therefore, the restructuring does not introduce potential Compatibility Issues, and the CI type is 0."
