Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
2,<android.widget.GridLayout.Spec: Spec copyWriteSpan(Interval)>,20,21,<android.widget.GridLayout.Spec: Spec copyWriteSpan(Interval)>,<android.widget.GridLayout.Spec: Spec copyWriteSpan(Interval)>,0,"{
    return new Spec(startDefined, span, alignment);
}","{
    return new Spec(startDefined, span, alignment, weight);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor call for Spec has changed by including an additional parameter 'weight' in the late version, which indicates a change in the associated dependent API as the constructor signature has been modified. Therefore, the code change type is 1,5 because the returned Spec object may now have different properties.","The addition of a new parameter 'weight' in the constructor potentially alters the return value since the Spec object in the late version contains additional information compared to the early version. Hence, the CI type is 1 as the API may return a Spec with different attributes."
4,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int,int[])>",20,21,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int,int[])>","<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int,int[])>",0,"{
    int len = attrs.length;
    TypedArray array = getCachedStyledAttributes(len);
    array.mRsrcs = attrs;
    AssetManager.applyStyle(mTheme, 0, resid, 0, attrs, array.mData, array.mIndices);
    if (false) {
        int[] data = array.mData;
        System.out.println(""**********************************************************"");
        System.out.println(""**********************************************************"");
        System.out.println(""**********************************************************"");
        System.out.println(""Attributes:"");
        String s = ""  Attrs:"";
        int i;
        for (i = 0; i < attrs.length; i++) {
            s = s + "" 0x"" + Integer.toHexString(attrs[i]);
        }
        System.out.println(s);
        s = ""  Found:"";
        TypedValue value = new TypedValue();
        for (i = 0; i < attrs.length; i++) {
            int d = i * AssetManager.STYLE_NUM_ENTRIES;
            value.type = data[d + AssetManager.STYLE_TYPE];
            value.data = data[d + AssetManager.STYLE_DATA];
            value.assetCookie = data[d + AssetManager.STYLE_ASSET_COOKIE];
            value.resourceId = data[d + AssetManager.STYLE_RESOURCE_ID];
            s = s + "" 0x"" + Integer.toHexString(attrs[i]) + ""="" + value;
        }
        System.out.println(s);
    }
    return array;
}","{
    final int len = attrs.length;
    final TypedArray array = TypedArray.obtain(Resources.this, len);
    array.mTheme = this;
    if (false) {
        int[] data = array.mData;
        System.out.println(""**********************************************************"");
        System.out.println(""**********************************************************"");
        System.out.println(""**********************************************************"");
        System.out.println(""Attributes:"");
        String s = ""  Attrs:"";
        int i;
        for (i = 0; i < attrs.length; i++) {
            s = s + "" 0x"" + Integer.toHexString(attrs[i]);
        }
        System.out.println(s);
        s = ""  Found:"";
        TypedValue value = new TypedValue();
        for (i = 0; i < attrs.length; i++) {
            int d = i * AssetManager.STYLE_NUM_ENTRIES;
            value.type = data[d + AssetManager.STYLE_TYPE];
            value.data = data[d + AssetManager.STYLE_DATA];
            value.assetCookie = data[d + AssetManager.STYLE_ASSET_COOKIE];
            value.resourceId = data[d + AssetManager.STYLE_RESOURCE_ID];
            s = s + "" 0x"" + Integer.toHexString(attrs[i]) + ""="" + value;
        }
        System.out.println(s);
    }
    AssetManager.applyStyle(mTheme, 0, resid, 0, attrs, array.mData, array.mIndices);
    return array;
}",1,"/**
 * Return a TypedArray holding the values defined by the style
 * resource <var>resid</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param resid The desired style resource.
 * @param attrs The desired attributes in the style.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
","/**
 * Return a TypedArray holding the values defined by the style
 * resource <var>resid</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param resid The desired style resource.
 * @param attrs The desired attributes in the style.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is related to the ordering of statements and the variable initialization inside the method. There is a change from getCachedStyledAttributes(len) to TypedArray.obtain(Resources.this, len) and array.mTheme = this; being added. Therefore, the code change type is 4.","There is no Compatibility Issue because the return type is unchanged. The ordering of operational statements does not make a difference in the output unless there are any side effects, which are not present here. Thus, the potential behavior of the API remains the same meaning no CI arises according to the available information."
5,<android.text.format.Time: void clear(String)>,20,21,<android.text.format.Time: void clear(String)>,<android.text.format.Time: void clear(String)>,0,"{
    if (timezone == null) {
        throw new NullPointerException(""timezone is null!"");
    }
    this.timezone = timezone;
    this.allDay = false;
    this.second = 0;
    this.minute = 0;
    this.hour = 0;
    this.monthDay = 0;
    this.month = 0;
    this.year = 0;
    this.weekDay = 0;
    this.yearDay = 0;
    this.gmtoff = 0;
    this.isDst = -1;
}","{
    if (timezoneId == null) {
        throw new NullPointerException(""timezone is null!"");
    }
    this.timezone = timezoneId;
    this.allDay = false;
    this.second = 0;
    this.minute = 0;
    this.hour = 0;
    this.monthDay = 0;
    this.month = 0;
    this.year = 0;
    this.weekDay = 0;
    this.yearDay = 0;
    this.gmtoff = 0;
    this.isDst = -1;
}",1,"/**
 * Clears all values, setting the timezone to the given timezone. Sets isDst
 * to a negative value to mean ""unknown"".
 * @param timezone the timezone to use.
 */
","/**
 * Clears all values, setting the timezone to the given timezone. Sets isDst
 * to a negative value to mean ""unknown"".
 * @param timezoneId the timezone to use.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the two implementations is the parameter name within the method from `timezone` to `timezoneId`. The rest of the method's body remains the same. As the parameter name is an internal detail of the method implementation and not part of the method signature, it should have no effect on the method's behavior from an outside perspective. Therefore, the change type is 4.","Since the internal parameter name change does not affect the method's behavior or the observable output, no compatibility issue should arise. The method's behavior remains consistent despite the internal change of the parameter name. Thus, the CI type is 0."
6,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",20,21,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>","<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",0,"{
    if (setOverride(key, value)) {
        return;
    }
    setBase(key, value);
}","{
    set(key.getNativeKey(), value);
}",1,"/**
 * Set a camera metadata field to a value. The field definitions can be
 * found in {@link CameraCharacteristics}, {@link CaptureResult}, and
 * {@link CaptureRequest}.
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */
",,-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","The implementation has been completely altered with the removal of condition and 'setOverride(key, value)' method, and a new 'set(key.getNativeKey(), value)' method is used instead. Therefore, the change is of type 1 for the changed return statement, and 5 for the changes in dependent API.","Since the early version had a condition that may have prevented 'setBase(key, value)' from being called if 'setOverride(key, value)' was successful, and this condition along with both 'setOverride' and 'setBase' methods have been removed and replaced with a different method ('set(key.getNativeKey(), value)'), the modified API now always uses the new 'set' method. This change leads to CIs of types 1 for potential different returned values (or behaviors), and type 2 if 'setOverride' had different exception throwing behavior from the new 'set' method."
8,"<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>",20,21,"<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>","<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>",0,"{
    if (count < 4)
        return;
    if ((offset | count) < 0 || offset + count > pts.length) {
        throw new IllegalArgumentException(""The lines array must contain 4 elements per line."");
    }
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawLines(mRenderer, pts, offset, count, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (count < 4)
        return;
    if ((offset | count) < 0 || offset + count > pts.length) {
        throw new IllegalArgumentException(""The lines array must contain 4 elements per line."");
    }
    nDrawLines(mRenderer, pts, offset, count, paint.mNativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The try-finally block and the call to nResetModifiers(mRenderer, modifiers) have been removed, so the code change types are 2 (exception handling statement changed) and 4 (other statement changed).","The late version of the API has removed the finally block and the call to reset modifiers for the paint object. This could potentially result in a Compatibility Issue due to the lack of modifier resetting when exceptions occur during the drawing operation, which might cause different behavior in the presence of exceptions. Therefore, the CI type is 2."
9,<android.view.MotionEvent: int axisFromString(String)>,20,21,<android.view.MotionEvent: int axisFromString(String)>,<android.view.MotionEvent: int axisFromString(String)>,0,"{
    if (symbolicName == null) {
        throw new IllegalArgumentException(""symbolicName must not be null"");
    }
    final int count = AXIS_SYMBOLIC_NAMES.size();
    for (int i = 0; i < count; i++) {
        if (symbolicName.equals(AXIS_SYMBOLIC_NAMES.valueAt(i))) {
            return i;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return -1;
    }
}","{
    if (symbolicName.startsWith(LABEL_PREFIX)) {
        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
        int axis = nativeAxisFromString(symbolicName);
        if (axis >= 0) {
            return axis;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return -1;
    }
}",1,"/**
 * Gets an axis by its symbolic name such as ""AXIS_X"" or an
 * equivalent numeric constant such as ""42"".
 *
 * @param symbolicName The symbolic name of the axis.
 * @return The axis or -1 if not found.
 * @see KeyEvent#keyCodeToString(int)
 */
","/**
 * Gets an axis by its symbolic name such as ""AXIS_X"" or an
 * equivalent numeric constant such as ""42"".
 *
 * @param symbolicName The symbolic name of the axis.
 * @return The axis or -1 if not found.
 * @see KeyEvent#keyCodeToString(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The method has significant changes in its control flow, introduction of a string manipulation and usage of a native method, and there’s a removal of a for-loop. The entire structure of how the string is processed to retrieve an axis value has changed, along with a change in the dependent method from AXIS_SYMBOLIC_NAMES lookup to nativeAxisFromString method, so the code change types are 3,4,5.","The new implementation uses a native method and changes how the input string is processed, which means the API could return a different value when the input `symbolicName` starts with `LABEL_PREFIX`, or when the `nativeAxisFromString` method interprets the axis differently than the previous AXIS_SYMBOLIC_NAMES lookup did. Therefore, the CI is of type 1."
10,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,20,21,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.isAdminActive(who, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    return isAdminActiveAsUser(who, UserHandle.myUserId());
}",1,"/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */
","/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from using mService.isAdminActive(who, UserHandle.myUserId()) within a try-catch block to return isAdminActiveAsUser(who, UserHandle.myUserId()). Additionally, this change also indicates a dependency on the changed API isAdminActiveAsUser. Hence, the code change type is 1,5.","The change from a direct call to mService.isAdminActive() to a call to isAdminActiveAsUser() could potentially lead to different return values due to the implementation differences in these methods. Therefore, this is a compatibility issue of type 1, caused by potential different return values."
14,<android.os.Parcel: void writeException(Exception)>,20,21,<android.os.Parcel: void writeException(Exception)>,<android.os.Parcel: void writeException(Exception)>,0,"{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}","{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}",1,"/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
","/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",2,"An additional 'else if' block has been added to check for another type of exception (UnsupportedOperationException) and set a corresponding code for it. This implies both a control dependency change and dependent API changed, so the code change types are 3 and 5.","The new else-if block introduces a new conditional path which can result in a different exception being thrown (or not thrown) if an UnsupportedOperationException occurs. This means the method's behavior could change in terms of exception handling between the two versions, and thus there is a Compatibility Issue of type 2."
15,"<android.appwidget.AppWidgetManager: void updateAppWidget(int,RemoteViews)>",20,21,"<android.appwidget.AppWidgetManager: void updateAppWidget(int,RemoteViews)>","<android.appwidget.AppWidgetManager: void updateAppWidget(int,RemoteViews)>",0,"{
    updateAppWidget(new int[] { appWidgetId }, views);
}","{
    if (mService == null) {
        return;
    }
    updateAppWidget(new int[] { appWidgetId }, views);
}",1,"/**
 * Set the RemoteViews to use for the specified appWidgetId.
 *
 * Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
 * contain a complete representation of the widget. For performing partial widget updates, see
 * {@link #partiallyUpdateAppWidget(int, RemoteViews)}.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * The total Bitmap memory used by the RemoteViews object cannot exceed that required to
 * fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
 *
 * @param appWidgetId      The AppWidget instance for which to set the RemoteViews.
 * @param views         The RemoteViews object to show.
 */
","/**
 * Set the RemoteViews to use for the specified appWidgetId.
 * <p>
 * Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
 * contain a complete representation of the widget. For performing partial widget updates, see
 * {@link #partiallyUpdateAppWidget(int, RemoteViews)}.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * The total Bitmap memory used by the RemoteViews object cannot exceed that required to
 * fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
 *
 * @param appWidgetId      The AppWidget instance for which to set the RemoteViews.
 * @param views         The RemoteViews object to show.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new control flow statement (an if-statement check) has been introduced before the updateAppWidget method call, so the code change type is 3.","The newly introduced if-statement only exits the method early if mService is null, which would just prevent the subsequent method call. This control flow change doesn't result in any new behavior as such, but it avoids calling the method with a potentially null mService, which might have resulted in a NullPointerException or some form of invalid operation originally. Because the method is void and the insertion of this if-statement simply adds a conditional check that stops execution, no new exception handling or return behavior is introduced. Hence, there is no CI (0)."
16,<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,20,21,<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,0,"{
    try {
        return sService.getAppWidgetOptions(appWidgetId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return Bundle.EMPTY;
    }
    try {
        return mService.getAppWidgetOptions(mPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get the extras associated with a given widget instance.
 *
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #updateAppWidgetOptions(int, Bundle)
 *
 * @param appWidgetId     The AppWidget instances for which to set the RemoteViews.
 * @return                The options associated with the given widget instance.
 */
","/**
 * Get the extras associated with a given widget instance.
 * <p>
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #updateAppWidgetOptions(int, Bundle)
 *
 * @param appWidgetId The AppWidget instances for which to set the RemoteViews.
 * @return The options associated with the given widget instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5","1,2","The late version introduces an additional null check for 'mService' and a different set of parameters used in 'mService.getAppWidgetOptions()' call. Additionally, a different object 'mService' is being used in place of 'sService', and there's an additional parameter 'mPackageName' being used. Thus, the code change types are 3,4,5.","The additional null check for `mService` could potentially lead to the API returning `Bundle.EMPTY` instead of throwing a `RuntimeException` in case of a `RemoteException`, which would be a different behavior from the early version. The difference in parameters ('mContext.getUserId()' replaced with 'mPackageName') and object ('sService' to 'mService') could also result in different return values. Therefore, the CI types can be both 1 and 2."
17,<android.view.ViewPropertyAnimator: ViewPropertyAnimator setStartDelay(long)>,20,21,<android.view.ViewPropertyAnimator: ViewPropertyAnimator setStartDelay(long)>,<android.view.ViewPropertyAnimator: ViewPropertyAnimator setStartDelay(long)>,0,"{
    if (startDelay < 0) {
        throw new IllegalArgumentException(""Animators cannot have negative duration: "" + startDelay);
    }
    mStartDelaySet = true;
    mStartDelay = startDelay;
    return this;
}","{
    if (startDelay < 0) {
        throw new IllegalArgumentException(""Animators cannot have negative start "" + ""delay: "" + startDelay);
    }
    mStartDelaySet = true;
    mStartDelay = startDelay;
    return this;
}",1,"/**
 * Sets the startDelay for the underlying animator that animates the requested properties.
 * By default, the animator uses the default value for ValueAnimator. Calling this method
 * will cause the declared value to be used instead.
 * @param startDelay The delay of ensuing property animations, in milliseconds. The value
 * cannot be negative.
 * @return This object, allowing calls to methods in this class to be chained.
 */
","/**
 * Sets the startDelay for the underlying animator that animates the requested properties.
 * By default, the animator uses the default value for ValueAnimator. Calling this method
 * will cause the declared value to be used instead.
 * @param startDelay The delay of ensuing property animations, in milliseconds. The value
 * cannot be negative.
 * @return This object, allowing calls to methods in this class to be chained.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change lies in the exception message text in the IllegalArgumentException, so the code change type is 4.","Even though there is a change in the exception message, this would not cause a compatibility issue since it does not affect the behavior of the API or change the exception thrown. The method signature, logic, and exceptions are the same; only the error message has been clarified. Therefore, no compatibility issue arises, so the CI type is 0."
19,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,20,21,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (DBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The addition of synchronization block with a change to the mDeviceBusy variable, and a replacement of DBG with VDBG constant represent a control dependency change and other statement change, leading to the change type of 3,4.","The new introduction of the synchronization block checking mDeviceBusy can potentially lead to the method returning false where previously it might have returned true; thus, the CI type is 1 due to a potential different return value."
20,<android.net.LocalSocketImpl.SocketInputStream: int available()>,20,21,<android.net.LocalSocketImpl.SocketInputStream: int available()>,<android.net.LocalSocketImpl.SocketInputStream: int available()>,0,"{
    return available_native(fd);
}","{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    return available_native(myFd);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4,5","1,2","The code change involves introducing a new local variable (FileDescriptor myFd = fd), a new if statement with a throw, and calling the available_native() method with the new local variable instead of the class field directly. Therefore, the change types are 2, 4, and 5.","The introduction of a new if statement that checks if the fd is null and throws an IOException if the condition is true will alter the exception thrown by the method, which may occur in situations where it previously did not. The use of a new local variable instead of direct usage may affect the behavior if any concurrent changes occur to fd after the check myFd == null but before the method call to available_native(myFd). Therefore, the CI types are 1 and 2."
21,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,20,21,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,0,"{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBLITY_NODE_INFOS_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBLITY_NODE_INFOS_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        case MSG_COMPUTE_CLICK_POINT_IN_SCREEN:
            return ""MSG_COMPUTE_CLICK_POINT_IN_SCREEN"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version of the code introduces an additional case statement for MSG_COMPUTE_CLICK_POINT_IN_SCREEN in the switch block, and there is no equivalent case in the early version of the code. This is a control dependency change (3). Since the addition of a new case may alter the return value for a certain input, it is considered a return statement change as well (1).","The newly added case statement means that when message.what matches MSG_COMPUTE_CLICK_POINT_IN_SCREEN, the function will now return ""MSG_COMPUTE_CLICK_POINT_IN_SCREEN"" in the late version. Since this behavior didn't exist in the early version, it introduces a compatibility issue where a different return value is provided based on the message's 'what' value, and thus, the CI type is 1."
22,<android.app.FragmentBreadCrumbs: void updateCrumbs()>,20,21,<android.app.FragmentBreadCrumbs: void updateCrumbs()>,<android.app.FragmentBreadCrumbs: void updateCrumbs()>,0,"{
    FragmentManager fm = mActivity.getFragmentManager();
    int numEntries = fm.getBackStackEntryCount();
    int numPreEntries = getPreEntryCount();
    int numViews = mContainer.getChildCount();
    for (int i = 0; i < numEntries + numPreEntries; i++) {
        BackStackEntry bse = i < numPreEntries ? getPreEntry(i) : fm.getBackStackEntryAt(i - numPreEntries);
        if (i < numViews) {
            View v = mContainer.getChildAt(i);
            Object tag = v.getTag();
            if (tag != bse) {
                for (int j = i; j < numViews; j++) {
                    mContainer.removeViewAt(i);
                }
                numViews = i;
            }
        }
        if (i >= numViews) {
            final View item = mInflater.inflate(com.android.internal.R.layout.fragment_bread_crumb_item, this, false);
            final TextView text = (TextView) item.findViewById(com.android.internal.R.id.title);
            text.setText(bse.getBreadCrumbTitle());
            text.setTag(bse);
            if (i == 0) {
                item.findViewById(com.android.internal.R.id.left_icon).setVisibility(View.GONE);
            }
            mContainer.addView(item);
            text.setOnClickListener(mOnClickListener);
        }
    }
    int viewI = numEntries + numPreEntries;
    numViews = mContainer.getChildCount();
    while (numViews > viewI) {
        mContainer.removeViewAt(numViews - 1);
        numViews--;
    }
    // Adjust the visibility and availability of the bread crumbs and divider
    for (int i = 0; i < numViews; i++) {
        final View child = mContainer.getChildAt(i);
        // Disable the last one
        child.findViewById(com.android.internal.R.id.title).setEnabled(i < numViews - 1);
        if (mMaxVisible > 0) {
            // Make only the last mMaxVisible crumbs visible
            child.setVisibility(i < numViews - mMaxVisible ? View.GONE : View.VISIBLE);
            final View leftIcon = child.findViewById(com.android.internal.R.id.left_icon);
            // Remove the divider for all but the last mMaxVisible - 1
            leftIcon.setVisibility(i > numViews - mMaxVisible && i != 0 ? View.VISIBLE : View.GONE);
        }
    }
}","{
    FragmentManager fm = mActivity.getFragmentManager();
    int numEntries = fm.getBackStackEntryCount();
    int numPreEntries = getPreEntryCount();
    int numViews = mContainer.getChildCount();
    for (int i = 0; i < numEntries + numPreEntries; i++) {
        BackStackEntry bse = i < numPreEntries ? getPreEntry(i) : fm.getBackStackEntryAt(i - numPreEntries);
        if (i < numViews) {
            View v = mContainer.getChildAt(i);
            Object tag = v.getTag();
            if (tag != bse) {
                for (int j = i; j < numViews; j++) {
                    mContainer.removeViewAt(i);
                }
                numViews = i;
            }
        }
        if (i >= numViews) {
            final View item = mInflater.inflate(mLayoutResId, this, false);
            final TextView text = (TextView) item.findViewById(com.android.internal.R.id.title);
            text.setText(bse.getBreadCrumbTitle());
            text.setTag(bse);
            text.setTextColor(mTextColor);
            if (i == 0) {
                item.findViewById(com.android.internal.R.id.left_icon).setVisibility(View.GONE);
            }
            mContainer.addView(item);
            text.setOnClickListener(mOnClickListener);
        }
    }
    int viewI = numEntries + numPreEntries;
    numViews = mContainer.getChildCount();
    while (numViews > viewI) {
        mContainer.removeViewAt(numViews - 1);
        numViews--;
    }
    // Adjust the visibility and availability of the bread crumbs and divider
    for (int i = 0; i < numViews; i++) {
        final View child = mContainer.getChildAt(i);
        // Disable the last one
        child.findViewById(com.android.internal.R.id.title).setEnabled(i < numViews - 1);
        if (mMaxVisible > 0) {
            // Make only the last mMaxVisible crumbs visible
            child.setVisibility(i < numViews - mMaxVisible ? View.GONE : View.VISIBLE);
            final View leftIcon = child.findViewById(com.android.internal.R.id.left_icon);
            // Remove the divider for all but the last mMaxVisible - 1
            leftIcon.setVisibility(i > numViews - mMaxVisible && i != 0 ? View.VISIBLE : View.GONE);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is in setting the text color for the TextView text (`text.setTextColor(mTextColor);`). This is the only alteration that does not affect the return type, exception handling, control flow, or dependent API, thus the code change type is 4.","The addition of setting text color does not affect the method's behavior regarding its logic or output (values returned or exceptions thrown); it only changes the appearance. Therefore, there is no Compatibility Issue, so the CI type is 0."
23,"<android.widget.TextView: boolean performAccessibilityAction(int,Bundle)>",20,21,"<android.widget.TextView: boolean performAccessibilityAction(int,Bundle)>","<android.widget.TextView: boolean performAccessibilityAction(int,Bundle)>",0,"{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_COPY:
            {
                if (isFocused() && canCopy()) {
                    if (onTextContextMenuItem(ID_COPY)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_PASTE:
            {
                if (isFocused() && canPaste()) {
                    if (onTextContextMenuItem(ID_PASTE)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CUT:
            {
                if (isFocused() && canCut()) {
                    if (onTextContextMenuItem(ID_CUT)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                if (isFocused() && canSelectText()) {
                    CharSequence text = getIterableTextForAccessibility();
                    if (text == null) {
                        return false;
                    }
                    final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                    final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                    if ((getSelectionStart() != start || getSelectionEnd() != end)) {
                        // No arguments clears the selection.
                        if (start == end && end == -1) {
                            Selection.removeSelection((Spannable) text);
                            return true;
                        }
                        if (start >= 0 && start <= end && end <= text.length()) {
                            Selection.setSelection((Spannable) text, start, end);
                            // Make sure selection mode is engaged.
                            if (mEditor != null) {
                                mEditor.startSelectionActionMode();
                            }
                            return true;
                        }
                    }
                }
            }
            return false;
        default:
            {
                return super.performAccessibilityAction(action, arguments);
            }
    }
}","{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                boolean handled = false;
                // Simulate View.onTouchEvent for an ACTION_UP event.
                if (isClickable() || isLongClickable()) {
                    if (isFocusable() && !isFocused()) {
                        requestFocus();
                    }
                    performClick();
                    handled = true;
                }
                // Simulate TextView.onTouchEvent for an ACTION_UP event.
                if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null && (isTextEditable() || isTextSelectable()) && isFocused()) {
                    // Show the IME, except when selecting in read-only text.
                    final InputMethodManager imm = InputMethodManager.peekInstance();
                    viewClicked(imm);
                    if (!isTextSelectable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                        handled |= imm.showSoftInput(this, 0);
                    }
                }
                return handled;
            }
        case AccessibilityNodeInfo.ACTION_COPY:
            {
                if (isFocused() && canCopy()) {
                    if (onTextContextMenuItem(ID_COPY)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_PASTE:
            {
                if (isFocused() && canPaste()) {
                    if (onTextContextMenuItem(ID_PASTE)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CUT:
            {
                if (isFocused() && canCut()) {
                    if (onTextContextMenuItem(ID_CUT)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                if (isFocused() && canSelectText()) {
                    CharSequence text = getIterableTextForAccessibility();
                    if (text == null) {
                        return false;
                    }
                    final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                    final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                    if ((getSelectionStart() != start || getSelectionEnd() != end)) {
                        // No arguments clears the selection.
                        if (start == end && end == -1) {
                            Selection.removeSelection((Spannable) text);
                            return true;
                        }
                        if (start >= 0 && start <= end && end <= text.length()) {
                            Selection.setSelection((Spannable) text, start, end);
                            // Make sure selection mode is engaged.
                            if (mEditor != null) {
                                mEditor.startSelectionActionMode();
                            }
                            return true;
                        }
                    }
                }
            }
            return false;
        default:
            {
                return super.performAccessibilityAction(action, arguments);
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"A case 'AccessibilityNodeInfo.ACTION_CLICK' has been added to the switch statement with its own block of code, which is a control flow modification and an additional sequence of statements. Therefore, both control dependency and other statements have been changed, leading to the change types being 3 and 4.","The introduction of a new case within the switch statement for 'AccessibilityNodeInfo.ACTION_CLICK' creates a path where a different return value could be produced compared to the early version which lacked this case. This can consequently cause a Compatibility Issue where different return values or types are produced. Therefore, the CI type is 1."
24,<android.widget.CalendarView: int getSelectedWeekBackgroundColor()>,20,21,<android.widget.CalendarView: int getSelectedWeekBackgroundColor()>,<android.widget.CalendarView: int getSelectedWeekBackgroundColor()>,0,"{
    return mSelectedWeekBackgroundColor;
}","{
    return mDelegate.getSelectedWeekBackgroundColor();
}",1,"/**
 * Gets the background color for the selected week.
 *
 * @return The week background color.
 *
 * @attr ref android.R.styleable#CalendarView_selectedWeekBackgroundColor
 */
","/**
 * Gets the background color for the selected week.
 *
 * @return The week background color.
 *
 * @attr ref android.R.styleable#CalendarView_selectedWeekBackgroundColor
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation of getting the selected week background color changed from returning a direct field reference to calling a method on the delegate object, so the code change type is 5.","The behavior of the method could potentially change if the 'getSelectedWeekBackgroundColor' method on 'mDelegate' returns a different value from what 'mSelectedWeekBackgroundColor' returned, thus the CI type is 1."
25,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>",20,21,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        float left, top, right, bottom;
        if (src == null) {
            left = top = 0;
            right = bitmap.getWidth();
            bottom = bitmap.getHeight();
        } else {
            left = src.left;
            right = src.right;
            top = src.top;
            bottom = src.bottom;
        }
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    float left, top, right, bottom;
    if (src == null) {
        left = top = 0;
        right = bitmap.getWidth();
        bottom = bitmap.getHeight();
    } else {
        left = src.left;
        right = src.right;
        top = src.top;
        bottom = src.bottom;
    }
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There's a removal of shader related modifier setup and cleanup code, but the core functionality of drawing the bitmap has not been altered. This constitutes a change in other statements (4).","Since only the shader modifier setup and cleanup are removed and these do not affect the outcome of drawing the bitmap to the canvas, there is no compatibility issue with regards to output or exceptions. Therefore, there is no compatibility issue (0)."
27,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,20,21,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,0,"{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    int num = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG)
            Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" op #"" + num + "" base fragment #"" + mOps[pos]);
        int findex = mOps[pos++];
        if (findex >= 0) {
            Fragment f = fm.mActive.get(findex);
            op.fragment = f;
        } else {
            op.fragment = null;
        }
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        final int N = mOps[pos++];
        if (N > 0) {
            op.removed = new ArrayList<Fragment>(N);
            for (int i = 0; i < N; i++) {
                if (FragmentManagerImpl.DEBUG)
                    Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" set remove fragment #"" + mOps[pos]);
                Fragment r = fm.mActive.get(mOps[pos++]);
                op.removed.add(r);
            }
        }
        bse.addOp(op);
        num++;
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.bumpBackStackNesting(1);
    return bse;
}","{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    int num = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG) {
            Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" op #"" + num + "" base fragment #"" + mOps[pos]);
        }
        int findex = mOps[pos++];
        if (findex >= 0) {
            Fragment f = fm.mActive.get(findex);
            op.fragment = f;
        } else {
            op.fragment = null;
        }
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        final int N = mOps[pos++];
        if (N > 0) {
            op.removed = new ArrayList<Fragment>(N);
            for (int i = 0; i < N; i++) {
                if (FragmentManagerImpl.DEBUG) {
                    Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" set remove fragment #"" + mOps[pos]);
                }
                Fragment r = fm.mActive.get(mOps[pos++]);
                op.removed.add(r);
            }
        }
        bse.addOp(op);
        num++;
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.mSharedElementSourceNames = mSharedElementSourceNames;
    bse.mSharedElementTargetNames = mSharedElementTargetNames;
    bse.bumpBackStackNesting(1);
    return bse;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change includes the addition of two assignments `bse.mSharedElementSourceNames = mSharedElementSourceNames` and `bse.mSharedElementTargetNames = mSharedElementTargetNames`. The change type is 4 (Other statement changed) as it involves assignments that are not return statements, exception handling, or control dependencies.","These changes do not alter the return type or value directly, nor do they introduce any changes in exception handling. Therefore, there is no Compatibility Issue as per the provided definitions."
29,<android.os.UserManager: boolean isUserAGoat()>,20,21,<android.os.UserManager: boolean isUserAGoat()>,<android.os.UserManager: boolean isUserAGoat()>,0,"{
    return false;
}","{
    return mContext.getPackageManager().isPackageAvailable(""com.coffeestainstudios.goatsimulator"");
}",1,"/**
 * Used to determine whether the user making this call is subject to
 * teleportations.
 * @return whether the user making this call is a goat
 */
","/**
 * Used to determine whether the user making this call is subject to
 * teleportations.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method can
 * now automatically identify goats using advanced goat recognition technology.</p>
 *
 * @return Returns true if the user making this call is a goat.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been completely changed from returning a constant value 'false' to returning the result of mContext.getPackageManager().isPackageAvailable(""com.coffeestainstudios.goatsimulator""), and it now relies on the availability of a package to determine the return value, so the code change type is 1,5.","Since the return value of the method is now dynamic and based on the result of whether a certain package is available or not, whereas previously it was always 'false', the late version of the API can return a different value. This constitutes a change that could potentially lead to a CI, and the CI type is 1."
30,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter()>,20,21,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter()>,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter()>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""createPrintDocumentAdapter"");
    return mProvider.createPrintDocumentAdapter();
}","{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""createPrintDocumentAdapter"");
    return mProvider.createPrintDocumentAdapter(""default"");
}",1,"/**
 * Creates a PrintDocumentAdapter that provides the content of this Webview for printing.
 * Only supported for API levels
 * {@link android.os.Build.VERSION_CODES#KITKAT} and above.
 *
 * The adapter works by converting the Webview contents to a PDF stream. The Webview cannot
 * be drawn during the conversion process - any such draws are undefined. It is recommended
 * to use a dedicated off screen Webview for the printing. If necessary, an application may
 * temporarily hide a visible WebView by using a custom PrintDocumentAdapter instance
 * wrapped around the object returned and observing the onStart and onFinish methods. See
 * {@link android.print.PrintDocumentAdapter} for more information.
 */
","/**
 * @deprecated Use {@link #createPrintDocumentAdapter(String)} which requires user
 * to provide a print document name.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The change is that a String argument ""default"" has been added to the method createPrintDocumentAdapter() of the object mProvider. This is a parameter change in the dependent API, so the code change type is 1,5.","Since a new argument has been supplied to the dependent API method call, this could lead to a different behavior of the API as it may potentially return a different result. This constitutes a change in the return value, and therefore the CI type is 1."
33,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,20,21,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,0,"{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        if (subtype.mSubtypeId != 0 || mSubtypeId != 0) {
            return (subtype.hashCode() == hashCode());
        }
        return (subtype.hashCode() == hashCode()) && (subtype.getNameResId() == getNameResId()) && (subtype.getMode().equals(getMode())) && (subtype.getIconResId() == getIconResId()) && (subtype.getLocale().equals(getLocale())) && (subtype.getExtraValue().equals(getExtraValue())) && (subtype.isAuxiliary() == isAuxiliary()) && (subtype.isAsciiCapable() == isAsciiCapable());
    }
    return false;
}","{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        if (subtype.mSubtypeId != 0 || mSubtypeId != 0) {
            return (subtype.hashCode() == hashCode());
        }
        return (subtype.hashCode() == hashCode()) && (subtype.getLocale().equals(getLocale())) && (subtype.getMode().equals(getMode())) && (subtype.getExtraValue().equals(getExtraValue())) && (subtype.isAuxiliary() == isAuxiliary()) && (subtype.overridesImplicitlyEnabledSubtype() == overridesImplicitlyEnabledSubtype()) && (subtype.isAsciiCapable() == isAsciiCapable());
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has been changed with the removal of the comparisons involving getNameResId() and getIconResId(), and the addition of a comparison for overridesImplicitlyEnabledSubtype(). There has also been a change in the control dependency due to the altered logic of the comparison sequence, so the code change types are 1 and 3.","Since the change in the return statement removes checks (getNameResId() and getIconResId()) that were present in the early version and introduces a new check (overridesImplicitlyEnabledSubtype()) in the late version, this could potentially lead to the method returning a different value when comparing the same instances of InputMethodSubtype in different versions. Therefore, the CI type is 1."
36,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,20,21,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int actionMasked = ev.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                onTouchDown(ev);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                onTouchMove(ev);
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                onTouchUp(ev);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                onTouchCancel();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}","{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (mIsDetaching || !isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    startNestedScroll(SCROLL_AXIS_VERTICAL);
    if (mFastScroll != null) {
        boolean intercepted = mFastScroll.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    initVelocityTrackerIfNotExists();
    final MotionEvent vtev = MotionEvent.obtain(ev);
    final int actionMasked = ev.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        mNestedYOffset = 0;
    }
    vtev.offsetLocation(0, mNestedYOffset);
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                onTouchDown(ev);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                onTouchMove(ev, vtev);
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                onTouchUp(ev);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                onTouchCancel();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    if (mVelocityTracker != null) {
        mVelocityTracker.addMovement(vtev);
    }
    vtev.recycle();
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
38,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,20,21,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,0,"{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
            } catch (RemoteException e) {
            }
        }
    }
}",1,"/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */
","/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There's an additional parameter being passed to the method `mService.updateWakeLockWorkSource`, which is `mHistoryTag`. This constitutes a change in the parameters of a method call within the implementation (a dependent API), classifying as type 5. However, this did not result in a control dependency change; thus, type 3 is not applicable. It is an ""Other statement changed"" because of the alteration in the method call parameters, categorizing it as type 4.","This change does not lead to a different return value or type, nor a different exception being thrown by the API, because the try-catch block is designed to handle all `RemoteException`s identically, without any change in behavior. Therefore, there should be no Compatibility Issue resulting from this modification."
40,<android.view.ViewRootImpl.SyntheticTouchNavigationHandler: void process(MotionEvent)>,20,21,<android.view.ViewRootImpl.SyntheticTouchNavigationHandler: void process(MotionEvent)>,<android.view.ViewRootImpl.SyntheticTouchNavigationHandler: void process(MotionEvent)>,0,"{
    // Update the current device information.
    final long time = event.getEventTime();
    final int deviceId = event.getDeviceId();
    final int source = event.getSource();
    if (mCurrentDeviceId != deviceId || mCurrentSource != source) {
        finishKeys(time);
        finishTracking(time);
        mCurrentDeviceId = deviceId;
        mCurrentSource = source;
        mCurrentDeviceSupported = false;
        InputDevice device = event.getDevice();
        if (device != null) {
            // In order to support an input device, we must know certain
            // characteristics about it, such as its size and resolution.
            InputDevice.MotionRange xRange = device.getMotionRange(MotionEvent.AXIS_X);
            InputDevice.MotionRange yRange = device.getMotionRange(MotionEvent.AXIS_Y);
            if (xRange != null && yRange != null) {
                mCurrentDeviceSupported = true;
                // Infer the resolution if it not actually known.
                float xRes = xRange.getResolution();
                if (xRes <= 0) {
                    xRes = xRange.getRange() / DEFAULT_WIDTH_MILLIMETERS;
                }
                float yRes = yRange.getResolution();
                if (yRes <= 0) {
                    yRes = yRange.getRange() / DEFAULT_HEIGHT_MILLIMETERS;
                }
                float nominalRes = (xRes + yRes) * 0.5f;
                // Precompute all of the configuration thresholds we will need.
                mConfigTickDistance = TICK_DISTANCE_MILLIMETERS * nominalRes;
                mConfigMinFlingVelocity = MIN_FLING_VELOCITY_TICKS_PER_SECOND * mConfigTickDistance;
                mConfigMaxFlingVelocity = MAX_FLING_VELOCITY_TICKS_PER_SECOND * mConfigTickDistance;
                if (LOCAL_DEBUG) {
                    Log.d(LOCAL_TAG, ""Configured device "" + mCurrentDeviceId + "" ("" + Integer.toHexString(mCurrentSource) + ""): "" + "", mConfigTickDistance="" + mConfigTickDistance + "", mConfigMinFlingVelocity="" + mConfigMinFlingVelocity + "", mConfigMaxFlingVelocity="" + mConfigMaxFlingVelocity);
                }
            }
        }
    }
    if (!mCurrentDeviceSupported) {
        return;
    }
    // Handle the event.
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                boolean caughtFling = mFlinging;
                finishKeys(time);
                finishTracking(time);
                mActivePointerId = event.getPointerId(0);
                mVelocityTracker = VelocityTracker.obtain();
                mVelocityTracker.addMovement(event);
                mStartTime = time;
                mStartX = event.getX();
                mStartY = event.getY();
                mLastX = mStartX;
                mLastY = mStartY;
                mAccumulatedX = 0;
                mAccumulatedY = 0;
                // If we caught a fling, then pretend that the tap slop has already
                // been exceeded to suppress taps whose only purpose is to stop the fling.
                mConsumedMovement = caughtFling;
                break;
            }
        case MotionEvent.ACTION_MOVE:
        case MotionEvent.ACTION_UP:
            {
                if (mActivePointerId < 0) {
                    break;
                }
                final int index = event.findPointerIndex(mActivePointerId);
                if (index < 0) {
                    finishKeys(time);
                    finishTracking(time);
                    break;
                }
                mVelocityTracker.addMovement(event);
                final float x = event.getX(index);
                final float y = event.getY(index);
                mAccumulatedX += x - mLastX;
                mAccumulatedY += y - mLastY;
                mLastX = x;
                mLastY = y;
                // Consume any accumulated movement so far.
                final int metaState = event.getMetaState();
                consumeAccumulatedMovement(time, metaState);
                // Detect taps and flings.
                if (action == MotionEvent.ACTION_UP) {
                    if (mConsumedMovement && mPendingKeyCode != KeyEvent.KEYCODE_UNKNOWN) {
                        // It might be a fling.
                        mVelocityTracker.computeCurrentVelocity(1000, mConfigMaxFlingVelocity);
                        final float vx = mVelocityTracker.getXVelocity(mActivePointerId);
                        final float vy = mVelocityTracker.getYVelocity(mActivePointerId);
                        if (!startFling(time, vx, vy)) {
                            finishKeys(time);
                        }
                    }
                    finishTracking(time);
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                finishKeys(time);
                finishTracking(time);
                break;
            }
    }
}","{
    // Update the current device information.
    final long time = event.getEventTime();
    final int deviceId = event.getDeviceId();
    final int source = event.getSource();
    if (mCurrentDeviceId != deviceId || mCurrentSource != source) {
        finishKeys(time);
        finishTracking(time);
        mCurrentDeviceId = deviceId;
        mCurrentSource = source;
        mCurrentDeviceSupported = false;
        InputDevice device = event.getDevice();
        if (device != null) {
            // In order to support an input device, we must know certain
            // characteristics about it, such as its size and resolution.
            InputDevice.MotionRange xRange = device.getMotionRange(MotionEvent.AXIS_X);
            InputDevice.MotionRange yRange = device.getMotionRange(MotionEvent.AXIS_Y);
            if (xRange != null && yRange != null) {
                mCurrentDeviceSupported = true;
                // Infer the resolution if it not actually known.
                float xRes = xRange.getResolution();
                if (xRes <= 0) {
                    xRes = xRange.getRange() / DEFAULT_WIDTH_MILLIMETERS;
                }
                float yRes = yRange.getResolution();
                if (yRes <= 0) {
                    yRes = yRange.getRange() / DEFAULT_HEIGHT_MILLIMETERS;
                }
                float nominalRes = (xRes + yRes) * 0.5f;
                // Precompute all of the configuration thresholds we will need.
                mConfigTickDistance = TICK_DISTANCE_MILLIMETERS * nominalRes;
                mConfigMinFlingVelocity = MIN_FLING_VELOCITY_TICKS_PER_SECOND * mConfigTickDistance;
                mConfigMaxFlingVelocity = MAX_FLING_VELOCITY_TICKS_PER_SECOND * mConfigTickDistance;
                if (LOCAL_DEBUG) {
                    Log.d(LOCAL_TAG, ""Configured device "" + mCurrentDeviceId + "" ("" + Integer.toHexString(mCurrentSource) + ""): "" + "", mConfigTickDistance="" + mConfigTickDistance + "", mConfigMinFlingVelocity="" + mConfigMinFlingVelocity + "", mConfigMaxFlingVelocity="" + mConfigMaxFlingVelocity);
                }
            }
        }
    }
    if (!mCurrentDeviceSupported) {
        return;
    }
    // Handle the event.
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                boolean caughtFling = mFlinging;
                finishKeys(time);
                finishTracking(time);
                mActivePointerId = event.getPointerId(0);
                mVelocityTracker = VelocityTracker.obtain();
                mVelocityTracker.addMovement(event);
                mStartX = event.getX();
                mStartY = event.getY();
                mLastX = mStartX;
                mLastY = mStartY;
                mAccumulatedX = 0;
                mAccumulatedY = 0;
                // If we caught a fling, then pretend that the tap slop has already
                // been exceeded to suppress taps whose only purpose is to stop the fling.
                mConsumedMovement = caughtFling;
                break;
            }
        case MotionEvent.ACTION_MOVE:
        case MotionEvent.ACTION_UP:
            {
                if (mActivePointerId < 0) {
                    break;
                }
                final int index = event.findPointerIndex(mActivePointerId);
                if (index < 0) {
                    finishKeys(time);
                    finishTracking(time);
                    break;
                }
                mVelocityTracker.addMovement(event);
                final float x = event.getX(index);
                final float y = event.getY(index);
                mAccumulatedX += x - mLastX;
                mAccumulatedY += y - mLastY;
                mLastX = x;
                mLastY = y;
                // Consume any accumulated movement so far.
                final int metaState = event.getMetaState();
                consumeAccumulatedMovement(time, metaState);
                // Detect taps and flings.
                if (action == MotionEvent.ACTION_UP) {
                    if (mConsumedMovement && mPendingKeyCode != KeyEvent.KEYCODE_UNKNOWN) {
                        // It might be a fling.
                        mVelocityTracker.computeCurrentVelocity(1000, mConfigMaxFlingVelocity);
                        final float vx = mVelocityTracker.getXVelocity(mActivePointerId);
                        final float vy = mVelocityTracker.getYVelocity(mActivePointerId);
                        if (!startFling(time, vx, vy)) {
                            finishKeys(time);
                        }
                    }
                    finishTracking(time);
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                finishKeys(time);
                finishTracking(time);
                break;
            }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
41,<android.transition.TransitionSet: TransitionSet removeTarget(int)>,20,21,<android.transition.TransitionSet: TransitionSet removeTarget(int)>,<android.transition.TransitionSet: TransitionSet removeTarget(int)>,0,"{
    return (TransitionSet) super.removeTarget(targetId);
}","{
    for (int i = 0; i < mTransitions.size(); i++) {
        mTransitions.get(i).removeTarget(targetId);
    }
    return (TransitionSet) super.removeTarget(targetId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There's a new 'for' loop added to iterate over `mTransitions` and apply `removeTarget(targetId)` on each element, which is not present in the early version, and there is also the introduction of new method invocations (`mTransitions.get(i).removeTarget(targetId)`), so the code change is of the types 3 and 4.","There's no compatibility issue arising from the changes made. The removed target applies to individual transitions within the set as well as the set itself. The method continues to return the same `TransitionSet` object after the removal operation, and the underlying functionality of removing the target by its 'targetId' remains consistent between versions, despite the additional loop to ensure individual transitions have the target removed as well. The contract of the method is maintained, thus there is no compatibility issue (0)."
42,<android.print.PrintManager.PrintDocumentAdapterDelegate: void setObserver(IPrintDocumentAdapterObserver)>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate: void setObserver(IPrintDocumentAdapterObserver)>,<android.print.PrintManager.PrintDocumentAdapterDelegate: void setObserver(IPrintDocumentAdapterObserver)>,0,"{
    final boolean destroyed;
    synchronized (mLock) {
        if (!mDestroyed) {
            mObserver = observer;
        }
        destroyed = mDestroyed;
    }
    if (destroyed) {
        try {
            observer.onDestroy();
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error announcing destroyed state"", re);
        }
    }
}","{
    final boolean destroyed;
    synchronized (mLock) {
        mObserver = observer;
        destroyed = isDestroyedLocked();
    }
    if (destroyed && observer != null) {
        try {
            observer.onDestroy();
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error announcing destroyed state"", re);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"Two changes were noticed: the assignment of 'mObserver' occurs regardless of 'mDestroyed' state in the late version, and there is an additional null check for 'observer'. The condition 'if (!mDestroyed)' is removed and the method 'isDestroyedLocked()' is used. That is control dependency change. Moreover, adding 'observer != null' check is another statement change, which is other than return, exception handling, or control dependency change. Thus the code change types are 3 and 4.","Despite the changes described, neither of them results in a different return value or exception throwing behavior. The modification ensures that 'observer.onDestroy()' is only called if 'observer' is not null, which could prevent potential NullPointerException, thus it's not introducing any compatibility issues. The setting of 'mObserver' outside of the if-statement controlled by 'mDestroyed' in the late version does not change the method's behavior from an API consumer's perspective because the state of 'destroyed' is always checked before calling 'observer.onDestroy()'. Therefore, there is no CI introduced by these changes."
45,"<android.widget.Editor.SelectionActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",20,21,"<android.widget.Editor.SelectionActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>","<android.widget.Editor.SelectionActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",0,"{
    TypedArray styledAttributes = mTextView.getContext().obtainStyledAttributes(com.android.internal.R.styleable.SelectionModeDrawables);
    mode.setTitle(mTextView.getContext().getString(com.android.internal.R.string.textSelectionCABTitle));
    mode.setSubtitle(null);
    mode.setTitleOptionalHint(true);
    menu.add(0, TextView.ID_SELECT_ALL, 0, com.android.internal.R.string.selectAll).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeSelectAllDrawable, 0)).setAlphabeticShortcut('a').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    if (mTextView.canCut()) {
        menu.add(0, TextView.ID_CUT, 0, com.android.internal.R.string.cut).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCutDrawable, 0)).setAlphabeticShortcut('x').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (mTextView.canCopy()) {
        menu.add(0, TextView.ID_COPY, 0, com.android.internal.R.string.copy).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCopyDrawable, 0)).setAlphabeticShortcut('c').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (mTextView.canPaste()) {
        menu.add(0, TextView.ID_PASTE, 0, com.android.internal.R.string.paste).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModePasteDrawable, 0)).setAlphabeticShortcut('v').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    styledAttributes.recycle();
    if (mCustomSelectionActionModeCallback != null) {
        if (!mCustomSelectionActionModeCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode
            return false;
        }
    }
    if (menu.hasVisibleItems() || mode.getCustomView() != null) {
        getSelectionController().show();
        mTextView.setHasTransientState(true);
        return true;
    } else {
        return false;
    }
}","{
    final boolean legacy = mTextView.getContext().getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.LOLLIPOP;
    final Context context = !legacy && menu instanceof MenuBuilder ? ((MenuBuilder) menu).getContext() : mTextView.getContext();
    final TypedArray styledAttributes = context.obtainStyledAttributes(com.android.internal.R.styleable.SelectionModeDrawables);
    mode.setTitle(mTextView.getContext().getString(com.android.internal.R.string.textSelectionCABTitle));
    mode.setSubtitle(null);
    mode.setTitleOptionalHint(true);
    menu.add(0, TextView.ID_SELECT_ALL, 0, com.android.internal.R.string.selectAll).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeSelectAllDrawable, 0)).setAlphabeticShortcut('a').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    if (mTextView.canCut()) {
        menu.add(0, TextView.ID_CUT, 0, com.android.internal.R.string.cut).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCutDrawable, 0)).setAlphabeticShortcut('x').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (mTextView.canCopy()) {
        menu.add(0, TextView.ID_COPY, 0, com.android.internal.R.string.copy).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCopyDrawable, 0)).setAlphabeticShortcut('c').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (mTextView.canPaste()) {
        menu.add(0, TextView.ID_PASTE, 0, com.android.internal.R.string.paste).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModePasteDrawable, 0)).setAlphabeticShortcut('v').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    styledAttributes.recycle();
    if (mCustomSelectionActionModeCallback != null) {
        if (!mCustomSelectionActionModeCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode
            return false;
        }
    }
    if (menu.hasVisibleItems() || mode.getCustomView() != null) {
        getSelectionController().show();
        mTextView.setHasTransientState(true);
        return true;
    } else {
        return false;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The implementation changes involve adding a new condition to determine the context used to obtain styled attributes. Besides that, the method's logic remains the same since the added condition is only related to the context from which resources are obtained, and it is not modifying any existing control structures that would change the behavior of the method. Therefore, changes can be classified as 3 (Control dependency changed) and 5 (Dependent API changed).","The Compatibility Issue type is 0, since the change in context based on the application's targetSdkVersion does not directly affect the method's behavior in terms of its output (return values), side effects, or thrown exceptions. The changes merely provide alternative resources based on the SDK version, but the overall logic and possible outcomes of the method remain consistent across the versions."
46,<android.animation.AnimatorSet: AnimatorSet clone()>,20,21,<android.animation.AnimatorSet: AnimatorSet clone()>,<android.animation.AnimatorSet: AnimatorSet clone()>,0,"{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    anim.mNeedsSort = true;
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new HashMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>();
    anim.mSortedNodes = new ArrayList<Node>();
    // Walk through the old nodes list, cloning each node and adding it to the new nodemap.
    // One problem is that the old node dependencies point to nodes in the old AnimatorSet.
    // We need to track the old/new nodes in order to reconstruct the dependencies in the clone.
    // <old, new>
    HashMap<Node, Node> nodeCloneMap = new HashMap<Node, Node>();
    for (Node node : mNodes) {
        Node nodeClone = node.clone();
        nodeCloneMap.put(node, nodeClone);
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.animation, nodeClone);
        // Clear out the dependencies in the clone; we'll set these up manually later
        nodeClone.dependencies = null;
        nodeClone.tmpDependencies = null;
        nodeClone.nodeDependents = null;
        nodeClone.nodeDependencies = null;
        // clear out any listeners that were set up by the AnimatorSet; these will
        // be set up when the clone's nodes are sorted
        ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
        if (cloneListeners != null) {
            ArrayList<AnimatorListener> listenersToRemove = null;
            for (AnimatorListener listener : cloneListeners) {
                if (listener instanceof AnimatorSetListener) {
                    if (listenersToRemove == null) {
                        listenersToRemove = new ArrayList<AnimatorListener>();
                    }
                    listenersToRemove.add(listener);
                }
            }
            if (listenersToRemove != null) {
                for (AnimatorListener listener : listenersToRemove) {
                    cloneListeners.remove(listener);
                }
            }
        }
    }
    // dependencies, mapping the old dependencies to the new nodes
    for (Node node : mNodes) {
        Node nodeClone = nodeCloneMap.get(node);
        if (node.dependencies != null) {
            for (Dependency dependency : node.dependencies) {
                Node clonedDependencyNode = nodeCloneMap.get(dependency.node);
                Dependency cloneDependency = new Dependency(clonedDependencyNode, dependency.rule);
                nodeClone.addDependency(cloneDependency);
            }
        }
    }
    return anim;
}","{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    anim.mNeedsSort = true;
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new HashMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>();
    anim.mSortedNodes = new ArrayList<Node>();
    anim.mReversible = mReversible;
    anim.mSetListener = null;
    // Walk through the old nodes list, cloning each node and adding it to the new nodemap.
    // One problem is that the old node dependencies point to nodes in the old AnimatorSet.
    // We need to track the old/new nodes in order to reconstruct the dependencies in the clone.
    // <old, new>
    HashMap<Node, Node> nodeCloneMap = new HashMap<Node, Node>();
    for (Node node : mNodes) {
        Node nodeClone = node.clone();
        nodeCloneMap.put(node, nodeClone);
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.animation, nodeClone);
        // Clear out the dependencies in the clone; we'll set these up manually later
        nodeClone.dependencies = null;
        nodeClone.tmpDependencies = null;
        nodeClone.nodeDependents = null;
        nodeClone.nodeDependencies = null;
        // clear out any listeners that were set up by the AnimatorSet; these will
        // be set up when the clone's nodes are sorted
        ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
        if (cloneListeners != null) {
            ArrayList<AnimatorListener> listenersToRemove = null;
            for (AnimatorListener listener : cloneListeners) {
                if (listener instanceof AnimatorSetListener) {
                    if (listenersToRemove == null) {
                        listenersToRemove = new ArrayList<AnimatorListener>();
                    }
                    listenersToRemove.add(listener);
                }
            }
            if (listenersToRemove != null) {
                for (AnimatorListener listener : listenersToRemove) {
                    cloneListeners.remove(listener);
                }
            }
        }
    }
    // dependencies, mapping the old dependencies to the new nodes
    for (Node node : mNodes) {
        Node nodeClone = nodeCloneMap.get(node);
        if (node.dependencies != null) {
            for (Dependency dependency : node.dependencies) {
                Node clonedDependencyNode = nodeCloneMap.get(dependency.node);
                Dependency cloneDependency = new Dependency(clonedDependencyNode, dependency.rule);
                nodeClone.addDependency(cloneDependency);
            }
        }
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
47,"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>",20,21,"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>","<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            ParcelFileDescriptor fileDescriptor;
            int returnValue;
            try {
                File file = new File(filename);
                if (file.exists() && !file.canWrite()) {
                    Log.e(TAG, ""Can't write to "" + filename);
                    return ERROR;
                }
                fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE);
                returnValue = service.synthesizeToFileDescriptor(getCallerIdentity(), text, fileDescriptor, getParams(params));
                fileDescriptor.close();
                return returnValue;
            } catch (FileNotFoundException e) {
                Log.e(TAG, ""Opening file "" + filename + "" failed"", e);
                return ERROR;
            } catch (IOException e) {
                Log.e(TAG, ""Closing file "" + filename + "" failed"", e);
                return ERROR;
            }
        }
    }, ERROR, ""synthesizeToFile"");
}","{
    return synthesizeToFile(text, convertParamsHashMaptoBundle(params), new File(filename), params.get(Engine.KEY_PARAM_UTTERANCE_ID));
}",1,"/**
 * Synthesizes the given text to a file using the specified parameters.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param text The text that should be synthesized. No longer than
 * {@link #getMaxSpeechInputLength()} characters.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param filename Absolute file filename to write the generated audio data to.It should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the synthesizeToFile operation.
 */
","/**
 * Synthesizes the given text to a file using the specified parameters.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param text The text that should be synthesized. No longer than
 * {@link #getMaxSpeechInputLength()} characters.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param filename Absolute file filename to write the generated audio data to.It should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the synthesizeToFile operation.
 * @deprecated As of API level 21, replaced by
 * {@link #synthesizeToFile(CharSequence, Bundle, File, String)}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the method has changed significantly from an anonymous inner class to a direct method call with different parameters, so the code change type is 1,4,5. The return type and the fundamental behaviour of the method may have also changed due to the switch from using `ParcelFileDescriptor` to the new method implementation.","Given that the implementation has changed from using `ParcelFileDescriptor` directly within the method to calling another method which may use different mechanisms for file synthesis, this could potentially lead to the API returning different values, thus the CI type is 1."
48,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,20,21,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,0,"{
    FloatKeyframe kfClone = mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction());
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}","{
    FloatKeyframe kfClone = mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction());
    kfClone.setInterpolator(getInterpolator());
    kfClone.mValueWasSetOnStart = mValueWasSetOnStart;
    return kfClone;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new assignment statement 'kfClone.mValueWasSetOnStart = mValueWasSetOnStart;' has been added in the late version, which represents a change that is not related to return, exception handling, control dependency, or a dependent API change, so the code change type is 4.","The added assignment only sets a value to an additional field of the cloned object but does not affect the object's structure returned nor its behaviour from the perspective of an API user. Therefore, it does not introduce a compatibility issue, and the CI type is 0."
49,"<android.view.GLES20Canvas: void drawTextOnPath(String,Path,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawTextOnPath(String,Path,float,float,Paint)>","<android.view.GLES20Canvas: void drawTextOnPath(String,Path,float,float,Paint)>",0,"{
    if (text.length() == 0)
        return;
    int modifiers = setupModifiers(paint);
    try {
        nDrawTextOnPath(mRenderer, text, 0, text.length(), path.mNativePath, hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (text.length() == 0)
        return;
    nDrawTextOnPath(mRenderer, text, 0, text.length(), path.mNativePath, hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change involves deletes the `modifiers` setup and block as well as a 'try-finally' block, and adds an extra parameter (`paint.mNativeTypeface`) in the method `nDrawTextOnPath`, the code change type is 4.","These changes do not affect the return values nor the exception handling since the method return type is `void` and no exception handling logic was changed. Thus, it will not result in any compatibility issues, so the CI type is 0."
55,<android.app.ApplicationPackageManager: Drawable getActivityIcon(ComponentName)>,20,21,<android.app.ApplicationPackageManager: Drawable getActivityIcon(ComponentName)>,<android.app.ApplicationPackageManager: Drawable getActivityIcon(ComponentName)>,0,"{
    return getActivityInfo(activityName, 0).loadIcon(this);
}","{
    return getActivityInfo(activityName, sDefaultFlags).loadIcon(this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The parameter passed to the getActivityInfo() method has been changed from a literal (0) to a variable (sDefaultFlags), so the code change type is 5.","Due to the change in the parameter value passed to the dependent API getActivityInfo(), the returned Drawable object may potentially be different if sDefaultFlags affects the behavior of getActivityInfo. This would lead to a different return value from getActivityIcon(ComponentName), so the CI type is 1."
58,<android.transition.TransitionSet: TransitionSet addTarget(int)>,20,21,<android.transition.TransitionSet: TransitionSet addTarget(int)>,<android.transition.TransitionSet: TransitionSet addTarget(int)>,0,"{
    return (TransitionSet) super.addTarget(targetId);
}","{
    for (int i = 0; i < mTransitions.size(); i++) {
        mTransitions.get(i).addTarget(targetId);
    }
    return (TransitionSet) super.addTarget(targetId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The late version adds a loop that iterates over a collection 'mTransitions' and applies the 'addTarget' method to each element. This is a control dependency change. Additionally, the implementation now relies on the internal behavior of 'mTransitions.get(i).addTarget(targetId)', which indicates a dependent API change. Thus, the change type is 3,5.","Although the implementation details have changed, the method's contract presumably remains the same: it adds a target and returns the TransitionSet object. Since there's no change in return type or value, nor in exception handling, there's no compatibility issue expected from this change; thus, the CI type is 0."
61,<android.widget.TimePicker: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,20,21,<android.widget.TimePicker: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,<android.widget.TimePicker: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,0,"{
    onPopulateAccessibilityEvent(event);
    return true;
}","{
    return mDelegate.dispatchPopulateAccessibilityEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method's return statement changed from always returning true to now returning the result of mDelegate.dispatchPopulateAccessibilityEvent(event), which introduces a dependency on an implementation detail that could be different (dependent API has changed). Hence, the change types are 1,5.","The change in the return statement means that the API potentially returns a different value in the late version, which leads to a CI type of 1."
63,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",20,21,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>","<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        checkRange(colors.length, colorOffset, count);
    }
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        checkRange(colors.length, colorOffset, count);
    }
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the removal of the try-finally block and the associated modification logic (modifiers related code). This is considered an ""Other statement changed"".","This change does not introduce a CI because it does not affect the return value or the exceptions thrown by the method—the functionality related to how the bitmap mesh is drawn remains the same. Removing the modifiers logic could be related to an internal optimization or refactoring, which doesn't change the external behavior of the API as perceived by the caller."
64,"<android.view.inputmethod.BaseInputConnection: boolean commitText(CharSequence,int)>",20,21,"<android.view.inputmethod.BaseInputConnection: boolean commitText(CharSequence,int)>","<android.view.inputmethod.BaseInputConnection: boolean commitText(CharSequence,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""commitText "" + text);
    replaceText(text, newCursorPosition, false);
    sendCurrentText();
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""commitText "" + text);
    replaceText(text, newCursorPosition, false);
    mIMM.notifyUserAction();
    sendCurrentText();
    return true;
}",1,"/**
 * Default implementation replaces any existing composing text with
 * the given text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
","/**
 * Default implementation replaces any existing composing text with
 * the given text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change in the code is the addition of a new method call mIMM.notifyUserAction(); hence, the code change is of type 4 (Other statement changed).","Despite the additional method call mIMM.notifyUserAction(), there is no modification to the return type or value and no change in exception handling. The new method call does not appear to affect the return value or the exception flow of the method, so there's no Compatibility Issue; therefore, the CI situation is 0."
65,"<android.content.pm.ResolveInfo.DisplayNameComparator: int compare(ResolveInfo,ResolveInfo)>",20,21,"<android.content.pm.ResolveInfo.DisplayNameComparator: int compare(ResolveInfo,ResolveInfo)>","<android.content.pm.ResolveInfo.DisplayNameComparator: int compare(ResolveInfo,ResolveInfo)>",0,"{
    CharSequence sa = a.loadLabel(mPM);
    if (sa == null)
        sa = a.activityInfo.name;
    CharSequence sb = b.loadLabel(mPM);
    if (sb == null)
        sb = b.activityInfo.name;
    return mCollator.compare(sa.toString(), sb.toString());
}","{
    // We want to put the one targeted to another user at the end of the dialog.
    if (a.targetUserId != UserHandle.USER_CURRENT) {
        return 1;
    }
    if (b.targetUserId != UserHandle.USER_CURRENT) {
        return -1;
    }
    CharSequence sa = a.loadLabel(mPM);
    if (sa == null)
        sa = a.activityInfo.name;
    CharSequence sb = b.loadLabel(mPM);
    if (sb == null)
        sb = b.activityInfo.name;
    return mCollator.compare(sa.toString(), sb.toString());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"New conditional control statements are added and the statements within them have changed. Thus, the code change types include 1 and 3.","With the introduction of the new condition checks on `a.targetUserId` and `b.targetUserId`, the method can now return different values (-1 or 1) based on these new conditions before reaching the previous logic. This is a compatibility issue of type 1 since it will return a different value due to the added conditional logic."
67,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliablePipe()>,20,21,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliablePipe()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliablePipe()>,0,"{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor[] fds = Libcore.os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
","/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called inside the try block is changed from Libcore.os.pipe() to Os.pipe(). This is a change in the invocation of a dependent API, so the code change type is 5.","There is no Compatibility Issue because the behavior of the try block is not altered in a way that would cause it to return different values or throw different exceptions. The catch block remains the same, and the method signature has not changed. The change to the dependent API does not, by itself, indicate a behavioral change since it's assumed that Os.pipe() is functionally equivalent to Libcore.os.pipe(). Therefore, no Compatibility Issue is detected."
69,<android.util.JsonReader: void skipValue()>,20,21,<android.util.JsonReader: void skipValue()>,<android.util.JsonReader: void skipValue()>,0,"{
    skipping = true;
    try {
        int count = 0;
        do {
            JsonToken token = advance();
            if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {
                count++;
            } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {
                count--;
            }
        } while (count != 0);
    } finally {
        skipping = false;
    }
}","{
    skipping = true;
    try {
        if (!hasNext() || peek() == JsonToken.END_DOCUMENT) {
            throw new IllegalStateException(""No element left to skip"");
        }
        int count = 0;
        do {
            JsonToken token = advance();
            if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {
                count++;
            } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {
                count--;
            }
        } while (count != 0);
    } finally {
        skipping = false;
    }
}",1,"/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */
","/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"There is an addition of an 'if' statement along with a 'throw' statement in the latest version that checks if there is an element to skip. It is not a control dependency change because the added 'if' condition does not affect the control flow of existing blocks, but rather adds a new block with a control condition that depends on the state of 'hasNext()' and 'peek()'.","Since a new exception 'IllegalStateException' may be thrown in circumstances where it would not have been thrown in the previous version (when there is no element left to skip), a CI has been introduced, and this is a 'Exception handling statement changed' scenario, which corresponds to CI type 2."
71,"<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>",20,21,"<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>","<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>",0,"{
    final Sensor sensor = sHandleToSensor.get(handle);
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    switch(t.sensor.getType()) {
        // Only report accuracy for sensors that support it.
        case Sensor.TYPE_MAGNETIC_FIELD:
        case Sensor.TYPE_ORIENTATION:
            // call onAccuracyChanged() only if the value changes
            final int accuracy = mSensorAccuracies.get(handle);
            if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
                mSensorAccuracies.put(handle, t.accuracy);
                mListener.onAccuracyChanged(t.sensor, t.accuracy);
            }
            break;
        default:
            // For other sensors, just report the accuracy once
            if (mFirstEvent.get(handle) == false) {
                mFirstEvent.put(handle, true);
                mListener.onAccuracyChanged(t.sensor, SENSOR_STATUS_ACCURACY_HIGH);
            }
            break;
    }
    mListener.onSensorChanged(t);
}","{
    final Sensor sensor = sHandleToSensor.get(handle);
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    // call onAccuracyChanged() only if the value changes
    final int accuracy = mSensorAccuracies.get(handle);
    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
        mSensorAccuracies.put(handle, t.accuracy);
        mListener.onAccuracyChanged(t.sensor, t.accuracy);
    }
    mListener.onSensorChanged(t);
}",1,"// Called from native code.
","// Called from native code.
",-1,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",-1,-1,-1,-1,-1,-1,"3,4",1,"The switch statement that adjusts the type of sensor being handled has been removed. Now, all sensors undergo the same process for reporting accuracy changes. This change is represented in categories 3 for control dependency change due to removal of the switch case, and 4 for the other adjustments needed to align with the logic without the switch statement.","Removing the switch case alters not only the flow of control but also the API's potential behavior regarding how and when it reports accuracy changes for different sensor types. The previous distinction made by the switch case can lead to different values being reported in the late version as opposed to the early version for sensors other than TYPE_MAGNETIC_FIELD and TYPE_ORIENTATION, thus resulting in a CI of type 1."
72,<android.bluetooth.BluetoothGatt: boolean connect()>,20,21,<android.bluetooth.BluetoothGatt: boolean connect()>,<android.bluetooth.BluetoothGatt: boolean connect()>,0,"{
    try {
        mService.clientConnect(mClientIf, mDevice.getAddress(), // autoConnect is inverse of ""isDirect""
        false);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
}","{
    try {
        mService.clientConnect(mClientIf, mDevice.getAddress(), false, // autoConnect is inverse of ""isDirect""
        mTransport);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
}",1,"/**
 * Connect back to remote device.
 *
 * <p>This method is used to re-connect to a remote device after the
 * connection has been dropped. If the device is not in range, the
 * re-connection will be triggered once the device is back in range.
 *
 * @return true, if the connection attempt was initiated successfully
 */
","/**
 * Connect back to remote device.
 *
 * <p>This method is used to re-connect to a remote device after the
 * connection has been dropped. If the device is not in range, the
 * re-connection will be triggered once the device is back in range.
 *
 * @return true, if the connection attempt was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call to mService.clientConnect(...) now includes an additional parameter, mTransport, which indicates that the dependent API clientConnect has changed. The code change type is thus 5, for a Dependent API changed.","There is no direct indication of a change in possible return values or exceptions thrown. The method's catch block remains the same, still catching RemoteException and returning false. The true branch has not been affected in a way that would change the return value. Therefore, there is no Compatibility Issue, so the CI type is 0."
73,<android.hardware.display.VirtualDisplay: String toString()>,20,21,<android.hardware.display.VirtualDisplay: String toString()>,<android.hardware.display.VirtualDisplay: String toString()>,0,"{
    return ""VirtualDisplay{display="" + mDisplay + "", token="" + mToken + ""}"";
}","{
    return ""VirtualDisplay{display="" + mDisplay + "", token="" + mToken + "", surface="" + mSurface + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been modified to include an additional concatenation ("", surface="" + mSurface), which is an Other statement change (4), and since the returned string is different, the Return statement has changed as well (1).","The returned value of the toString() method has changed because it now includes additional information about the surface associated with the VirtualDisplay, which can be identified as a Compatibility Issue caused by potentially different return values (1)."
74,<android.provider.DocumentsProvider: String getType(Uri)>,20,21,<android.provider.DocumentsProvider: String getType(Uri)>,<android.provider.DocumentsProvider: String getType(Uri)>,0,"{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOT:
                return DocumentsContract.Root.MIME_TYPE_ITEM;
            case MATCH_DOCUMENT:
                return getDocumentType(getDocumentId(uri));
            default:
                return null;
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, ""Failed during getType"", e);
        return null;
    }
}","{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOT:
                return DocumentsContract.Root.MIME_TYPE_ITEM;
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return getDocumentType(getDocumentId(uri));
            default:
                return null;
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, ""Failed during getType"", e);
        return null;
    }
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #getDocumentType(String)
 */
","/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #getDocumentType(String)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The switch statement has been modified in the late version to handle an additional case (MATCH_DOCUMENT_TREE) along with the existing MATCH_DOCUMENT case which now also calls enforceTree(uri) before getDocumentType(getDocumentId(uri)). This is a control dependency change, so the code change type is 3.","The additional MATCH_DOCUMENT_TREE case in the switch statement and calling enforceTree(uri) method could potentially affect which type is returned for certain URIs. Consequently, the API may behave different from the early version, where URIs that matched MATCH_DOCUMENT_TREE would have previously returned null. This means there's a possibility for different return values, therefore the CI type is 1."
75,<android.speech.tts.SynthesisRequest: String getText()>,20,21,<android.speech.tts.SynthesisRequest: String getText()>,<android.speech.tts.SynthesisRequest: String getText()>,0,"{
    return mText;
}","{
    return mText.toString();
}",1,"/**
 * Gets the text which should be synthesized.
 */
","/**
 * Gets the text which should be synthesized.
 * @deprecated As of API level 21, replaced by {@link #getCharSequenceText}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The code change is calling `.toString()` on `mText` instead of directly returning it. Since `mText` is likely already a String object, calling `toString()` on it should not change the behavior; therefore, the code change type is 4.",There is no Compatibility Issue since `toString()` on a String object returns the string itself.
76,<android.database.sqlite.SQLiteDatabase: boolean deleteDatabase(File)>,20,21,<android.database.sqlite.SQLiteDatabase: boolean deleteDatabase(File)>,<android.database.sqlite.SQLiteDatabase: boolean deleteDatabase(File)>,0,"{
    if (file == null) {
        throw new IllegalArgumentException(""file must not be null"");
    }
    boolean deleted = false;
    deleted |= file.delete();
    deleted |= new File(file.getPath() + ""-journal"").delete();
    deleted |= new File(file.getPath() + ""-shm"").delete();
    deleted |= new File(file.getPath() + ""-wal"").delete();
    File dir = file.getParentFile();
    if (dir != null) {
        final String prefix = file.getName() + ""-mj"";
        final FileFilter filter = new FileFilter() {

            @Override
            public boolean accept(File candidate) {
                return candidate.getName().startsWith(prefix);
            }
        };
        for (File masterJournal : dir.listFiles(filter)) {
            deleted |= masterJournal.delete();
        }
    }
    return deleted;
}","{
    if (file == null) {
        throw new IllegalArgumentException(""file must not be null"");
    }
    boolean deleted = false;
    deleted |= file.delete();
    deleted |= new File(file.getPath() + ""-journal"").delete();
    deleted |= new File(file.getPath() + ""-shm"").delete();
    deleted |= new File(file.getPath() + ""-wal"").delete();
    File dir = file.getParentFile();
    if (dir != null) {
        final String prefix = file.getName() + ""-mj"";
        File[] files = dir.listFiles(new FileFilter() {

            @Override
            public boolean accept(File candidate) {
                return candidate.getName().startsWith(prefix);
            }
        });
        if (files != null) {
            for (File masterJournal : files) {
                deleted |= masterJournal.delete();
            }
        }
    }
    return deleted;
}",1,"/**
 * Deletes a database including its journal file and other auxiliary files
 * that may have been created by the database engine.
 *
 * @param file The database file path.
 * @return True if the database was successfully deleted.
 */
","/**
 * Deletes a database including its journal file and other auxiliary files
 * that may have been created by the database engine.
 *
 * @param file The database file path.
 * @return True if the database was successfully deleted.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The change is the introduction of a null-check for the result of `dir.listFiles(new FileFilter()...)` before iterating over the array of files. This preserves the behavior when the listFiles method doesn't return null but adds a protection against a NullPointerException if it does return null.,"This does not introduce a compatibility issue since the functionality has been safeguarded to prevent possible crashes due to a null return value from listFiles. If listFiles returns null in the early version, it would lead to a NullPointerException whereas in the late version it avoids the iteration and simply returns the current state of the 'deleted' variable. Therefore, the functional outcome remains the same as the exception being thrown is not part of the API contract; rather, it's a runtime issue being safeguarded against."
79,"<android.net.nsd.NsdManager: void discoverServices(String,int,DiscoveryListener)>",20,21,"<android.net.nsd.NsdManager: void discoverServices(String,int,DiscoveryListener)>","<android.net.nsd.NsdManager: void discoverServices(String,int,DiscoveryListener)>",0,"{
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    if (TextUtils.isEmpty(serviceType)) {
        throw new IllegalArgumentException(""Service type cannot be empty"");
    }
    if (protocolType != PROTOCOL_DNS_SD) {
        throw new IllegalArgumentException(""Unsupported protocol"");
    }
    NsdServiceInfo s = new NsdServiceInfo();
    s.setServiceType(serviceType);
    mAsyncChannel.sendMessage(DISCOVER_SERVICES, 0, putListener(listener, s), s);
}","{
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    if (TextUtils.isEmpty(serviceType)) {
        throw new IllegalArgumentException(""Service type cannot be empty"");
    }
    if (protocolType != PROTOCOL_DNS_SD) {
        throw new IllegalArgumentException(""Unsupported protocol"");
    }
    NsdServiceInfo s = new NsdServiceInfo();
    s.setServiceType(serviceType);
    int key = putListener(listener, s);
    if (key == BUSY_LISTENER_KEY) {
        throw new IllegalArgumentException(""listener already in use"");
    }
    mAsyncChannel.sendMessage(DISCOVER_SERVICES, 0, key, s);
}",1,"/**
 * Initiate service discovery to browse for instances of a service type. Service discovery
 * consumes network bandwidth and will continue until the application calls
 * {@link #stopServiceDiscovery}.
 *
 * <p> The function call immediately returns after sending a request to start service
 * discovery to the framework. The application is notified of a success to initiate
 * discovery through the callback {@link DiscoveryListener#onDiscoveryStarted} or a failure
 * through {@link DiscoveryListener#onStartDiscoveryFailed}.
 *
 * <p> Upon successful start, application is notified when a service is found with
 * {@link DiscoveryListener#onServiceFound} or when a service is lost with
 * {@link DiscoveryListener#onServiceLost}.
 *
 * <p> Upon failure to start, service discovery is not active and application does
 * not need to invoke {@link #stopServiceDiscovery}
 *
 * @param serviceType The service type being discovered. Examples include ""_http._tcp"" for
 * http services or ""_ipp._tcp"" for printers
 * @param protocolType The service discovery protocol
 * @param listener  The listener notifies of a successful discovery and is used
 * to stop discovery on this serviceType through a call on {@link #stopServiceDiscovery}.
 * Cannot be null.
 */
","/**
 * Initiate service discovery to browse for instances of a service type. Service discovery
 * consumes network bandwidth and will continue until the application calls
 * {@link #stopServiceDiscovery}.
 *
 * <p> The function call immediately returns after sending a request to start service
 * discovery to the framework. The application is notified of a success to initiate
 * discovery through the callback {@link DiscoveryListener#onDiscoveryStarted} or a failure
 * through {@link DiscoveryListener#onStartDiscoveryFailed}.
 *
 * <p> Upon successful start, application is notified when a service is found with
 * {@link DiscoveryListener#onServiceFound} or when a service is lost with
 * {@link DiscoveryListener#onServiceLost}.
 *
 * <p> Upon failure to start, service discovery is not active and application does
 * not need to invoke {@link #stopServiceDiscovery}
 *
 * <p> The application should call {@link #stopServiceDiscovery} when discovery of this
 * service type is no longer required, and/or whenever the application is paused or
 * stopped.
 *
 * @param serviceType The service type being discovered. Examples include ""_http._tcp"" for
 * http services or ""_ipp._tcp"" for printers
 * @param protocolType The service discovery protocol
 * @param listener  The listener notifies of a successful discovery and is used
 * to stop discovery on this serviceType through a call on {@link #stopServiceDiscovery}.
 * Cannot be null. Cannot be in use for an active service discovery.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late version introduces additional exception handling with a new 'throw' statement to check if the listener is already in use and associates it with a new constant BUSY_LISTENER_KEY. There is also a new local variable 'key' being introduced and used in sendMessage. These include changes in exception handling statement (2), control dependency (3), and other statements (4).","The new 'throw' statement introduces a case where an IllegalArgumentException is potentially thrown if the key is equal to BUSY_LISTENER_KEY, which is a new behavior compared to the early version. This could lead to new exceptions being thrown (CI type 2). Also, the introduction of a new 'if' statement creates a new branch which is part of control flow, and thus could cause the method to execute differently in terms of logic and returned results (CI type 1)."
80,"<android.content.Intent: Intent parseIntent(Resources,XmlPullParser,AttributeSet)>",20,21,"<android.content.Intent: Intent parseIntent(Resources,XmlPullParser,AttributeSet)>","<android.content.Intent: Intent parseIntent(Resources,XmlPullParser,AttributeSet)>",0,"{
    Intent intent = new Intent();
    TypedArray sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.Intent);
    intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
    String data = sa.getString(com.android.internal.R.styleable.Intent_data);
    String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
    intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
    String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
    String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
    if (packageName != null && className != null) {
        intent.setComponent(new ComponentName(packageName, className));
    }
    sa.recycle();
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String nodeName = parser.getName();
        if (nodeName.equals(""category"")) {
            sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.IntentCategory);
            String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
            sa.recycle();
            if (cat != null) {
                intent.addCategory(cat);
            }
            XmlUtils.skipCurrentTag(parser);
        } else if (nodeName.equals(""extra"")) {
            if (intent.mExtras == null) {
                intent.mExtras = new Bundle();
            }
            resources.parseBundleExtra(""extra"", attrs, intent.mExtras);
            XmlUtils.skipCurrentTag(parser);
        } else {
            XmlUtils.skipCurrentTag(parser);
        }
    }
    return intent;
}","{
    Intent intent = new Intent();
    TypedArray sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.Intent);
    intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
    String data = sa.getString(com.android.internal.R.styleable.Intent_data);
    String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
    intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
    String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
    String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
    if (packageName != null && className != null) {
        intent.setComponent(new ComponentName(packageName, className));
    }
    sa.recycle();
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String nodeName = parser.getName();
        if (nodeName.equals(TAG_CATEGORIES)) {
            sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.IntentCategory);
            String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
            sa.recycle();
            if (cat != null) {
                intent.addCategory(cat);
            }
            XmlUtils.skipCurrentTag(parser);
        } else if (nodeName.equals(TAG_EXTRA)) {
            if (intent.mExtras == null) {
                intent.mExtras = new Bundle();
            }
            resources.parseBundleExtra(TAG_EXTRA, attrs, intent.mExtras);
            XmlUtils.skipCurrentTag(parser);
        } else {
            XmlUtils.skipCurrentTag(parser);
        }
    }
    return intent;
}",1,"/**
 * Parses the ""intent"" element (and its children) from XML and instantiates
 * an Intent object.  The given XML parser should be located at the tag
 * where parsing should start (often named ""intent""), from which the
 * basic action, data, type, and package and class name will be
 * retrieved.  The function will then parse in to any child elements,
 * looking for <category android:name=""xxx""> tags to add categories and
 * <extra android:name=""xxx"" android:value=""yyy""> to attach extra data
 * to the intent.
 *
 * @param resources The Resources to use when inflating resources.
 * @param parser The XML parser pointing at an ""intent"" tag.
 * @param attrs The AttributeSet interface for retrieving extended
 * attribute data at the current <var>parser</var> location.
 * @return An Intent object matching the XML data.
 * @throws XmlPullParserException If there was an XML parsing error.
 * @throws IOException If there was an I/O error.
 */
","/**
 * Parses the ""intent"" element (and its children) from XML and instantiates
 * an Intent object.  The given XML parser should be located at the tag
 * where parsing should start (often named ""intent""), from which the
 * basic action, data, type, and package and class name will be
 * retrieved.  The function will then parse in to any child elements,
 * looking for <category android:name=""xxx""> tags to add categories and
 * <extra android:name=""xxx"" android:value=""yyy""> to attach extra data
 * to the intent.
 *
 * @param resources The Resources to use when inflating resources.
 * @param parser The XML parser pointing at an ""intent"" tag.
 * @param attrs The AttributeSet interface for retrieving extended
 * attribute data at the current <var>parser</var> location.
 * @return An Intent object matching the XML data.
 * @throws XmlPullParserException If there was an XML parsing error.
 * @throws IOException If there was an I/O error.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The structure of the implementation did not change, but the string literals in if conditions within the while loop ('category' and 'extra') have been replaced with constants (TAG_CATEGORIES and TAG_EXTRA). This is considered Other statement changed, which is denoted by code change type 4.","The replacement of string literals with constants has no impact on the behaviour of the method. Both the method signature and method behaviour remain the same. Therefore, there is no Compatibility Issue, which is denoted by code change type 0."
81,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",20,21,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    float dx;
                    float dy;
                    if (cap) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}","{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                ds[0].mIsSelectionStarted = false;
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                        if (event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                            ds[0].mIsActivelySelecting = true;
                            ds[0].mIsSelectionStarted = true;
                        }
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        ds[0].mIsActivelySelecting = false;
                    }
                    float dx;
                    float dy;
                    if (cap && event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        scrollTo(widget, layout, nx, ny);
                    }
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}",1,"/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
","/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
82,<android.view.View: boolean hasIdentityMatrix()>,20,21,<android.view.View: boolean hasIdentityMatrix()>,<android.view.View: boolean hasIdentityMatrix()>,0,"{
    if (mTransformationInfo != null) {
        updateMatrix();
        return mTransformationInfo.mMatrixIsIdentity;
    }
    return true;
}","{
    return mRenderNode.hasIdentityMatrix();
}",1,"/**
 * Returns true if the transform matrix is the identity matrix.
 * Recomputes the matrix if necessary.
 *
 * @return True if the transform matrix is the identity matrix, false otherwise.
 */
","/**
 * Returns true if the transform matrix is the identity matrix.
 * Recomputes the matrix if necessary.
 *
 * @return True if the transform matrix is the identity matrix, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has entirely changed from checking a condition and potentially updating a matrix before returning the result to directly calling a method on the mRenderNode object, so the code change type is 1,5.","As the late version API is invoking a different method to determine the return value, it is possible that the new method behaves differently than the previous conditions and method call. Thus, it may cause the API to return a different value, and the CI type is 1."
83,<android.widget.CalendarView: void setFirstDayOfWeek(int)>,20,21,<android.widget.CalendarView: void setFirstDayOfWeek(int)>,<android.widget.CalendarView: void setFirstDayOfWeek(int)>,0,"{
    if (mFirstDayOfWeek == firstDayOfWeek) {
        return;
    }
    mFirstDayOfWeek = firstDayOfWeek;
    mAdapter.init();
    setUpHeader();
}","{
    mDelegate.setFirstDayOfWeek(firstDayOfWeek);
}",1,"/**
 * Sets the first day of week.
 *
 * @param firstDayOfWeek The first day of the week conforming to the
 * {@link CalendarView} APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */
","/**
 * Sets the first day of week.
 *
 * @param firstDayOfWeek The first day of the week conforming to the
 * {@link CalendarView} APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has been changed entirely from direct manipulation of member variables and calling internal methods to delegating the operation to a 'mDelegate' object. Therefore, the type of change is a 4,5 since it's not one of the return, exception handling, or control dependency changes, and it's also a change in a dependent API.","There's no compatibility issue detected. Although the method has been significantly refactored, from the external API user perspective, it accepts the same parameter and does not return any value (since it is a 'void' method). This change is internal and should not affect how the method is used or the outcomes are expected, assuming 'mDelegate.setFirstDayOfWeek(firstDayOfWeek)' correctly encapsulates the old behavior."
84,<android.os.Message: Message obtain(Message)>,20,21,<android.os.Message: Message obtain(Message)>,<android.os.Message: Message obtain(Message)>,0,"{
    Message m = obtain();
    m.what = orig.what;
    m.arg1 = orig.arg1;
    m.arg2 = orig.arg2;
    m.obj = orig.obj;
    m.replyTo = orig.replyTo;
    if (orig.data != null) {
        m.data = new Bundle(orig.data);
    }
    m.target = orig.target;
    m.callback = orig.callback;
    return m;
}","{
    Message m = obtain();
    m.what = orig.what;
    m.arg1 = orig.arg1;
    m.arg2 = orig.arg2;
    m.obj = orig.obj;
    m.replyTo = orig.replyTo;
    m.sendingUid = orig.sendingUid;
    if (orig.data != null) {
        m.data = new Bundle(orig.data);
    }
    m.target = orig.target;
    m.callback = orig.callback;
    return m;
}",1,"/**
 * Same as {@link #obtain()}, but copies the values of an existing
 * message (including its target) into the new one.
 * @param orig Original message to copy.
 * @return A Message object from the global pool.
 */
","/**
 * Same as {@link #obtain()}, but copies the values of an existing
 * message (including its target) into the new one.
 * @param orig Original message to copy.
 * @return A Message object from the global pool.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new assignment statement `m.sendingUid = orig.sendingUid;` is introduced in the late version without altering the logic how `Message` is obtained and returned, so the code change type is 4 (Other statement changed).","Although there is a change in the implementation, it doesn't change the behavior of the API in terms of its return values or the exceptions it may throw. The method still returns a `Message` object with the same properties copied from the original, with the addition of `sendingUid`. This additional field does not represent a change in the type or the potential values of the returned object in a way that would cause compatibility issues for existing clients of the API. Therefore, there is no Compatibility Issue here."
86,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,20,21,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}",1,"/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */
","/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The arguments passed to `findAccessibilityNodeInfoByAccessibilityId` have changed. The flag `FLAG_PREFETCH_PREDECESSORS` has been added to the late version. This indicates a change in the dependent API type, so the code change type is 5.","The change in the flags for the method `findAccessibilityNodeInfoByAccessibilityId` alters the type of data prefetched when fetching the `AccessibilityNodeInfo`, but it does not directly affect the return type or the value of the `AccessibilityNodeInfo` object returned by the `getLabelFor()` method. Therefore, this should not cause a compatibility issue in terms of the object returned by `getLabelFor()`, so the CI type is 0."
87,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,20,21,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    if (onFilterTouchEventForSecurity(event)) {
        // noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
            return true;
        }
        if (onTouchEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}","{
    boolean result = false;
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }
    if (onFilterTouchEventForSecurity(event)) {
        // noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }
    if (!result && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN && !result)) {
        stopNestedScroll();
    }
    return result;
}",1,"/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late implementation introduces additional control flow with the variable 'actionMasked', and a new variable named 'result' is used to determine the return value. The code also includes extra calls to 'stopNestedScroll()' within control flow statements. Therefore, changes are classified under both 'Control dependency changed' and 'Other statement changed'.","The introduction of new control flow and changes in how the return value 'result' is determined can lead to a different return value, particularly with new conditions checking 'actionMasked' and additional logic for setting 'result'. Hence, a Compatibility Issue arises due to potential different return values, classified as CI type 1."
88,<android.app.Activity: void performStart()>,20,21,<android.app.Activity: void performStart()>,<android.app.Activity: void performStart()>,0,"{
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    if (mAllLoaderManagers != null) {
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = mAllLoaderManagers.valueAt(i);
        }
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            lm.finishRetain();
            lm.doReportStart();
        }
    }
}","{
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    if (mAllLoaderManagers != null) {
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = mAllLoaderManagers.valueAt(i);
        }
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            lm.finishRetain();
            lm.doReportStart();
        }
    }
    mActivityTransitionState.enterReady(this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"New statements were added at the beginning and end of the method implementation, but no existing statements were modified or removed, so the code change type is 4.","The added statements do not change existing return values or exception handlings, and they have no impact on the general control flow of the method. The method's behavior is enhanced with additional functionality, but it doesn't constitute an API compatibility issue for existing clients of the API. As such, the CI type is 0."
89,<android.app.ActivityThread.H: String codeToString(int)>,20,21,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case CANCEL_VISIBLE_BEHIND:
                return ""CANCEL_VISIBLE_BEHIND"";
            case BACKGROUND_VISIBLE_BEHIND_CHANGED:
                return ""BACKGROUND_VISIBLE_BEHIND_CHANGED"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
91,<android.view.View: void setBackgroundResource(int)>,20,21,<android.view.View: void setBackgroundResource(int)>,<android.view.View: void setBackgroundResource(int)>,0,"{
    if (resid != 0 && resid == mBackgroundResource) {
        return;
    }
    Drawable d = null;
    if (resid != 0) {
        d = mResources.getDrawable(resid);
    }
    setBackground(d);
    mBackgroundResource = resid;
}","{
    if (resid != 0 && resid == mBackgroundResource) {
        return;
    }
    Drawable d = null;
    if (resid != 0) {
        d = mContext.getDrawable(resid);
    }
    setBackground(d);
    mBackgroundResource = resid;
}",1,"/**
 * Set the background to a given resource. The resource should refer to
 * a Drawable object or 0 to remove the background.
 * @param resid The identifier of the resource.
 *
 * @attr ref android.R.styleable#View_background
 */
","/**
 * Set the background to a given resource. The resource should refer to
 * a Drawable object or 0 to remove the background.
 * @param resid The identifier of the resource.
 *
 * @attr ref android.R.styleable#View_background
 */
",-1,[@RemotableViewMethod],[@RemotableViewMethod],-1,-1,-1,-1,-1,-1,"4,5",0,"The API implementation has a change in which the Drawable is retrieved: in the late version, the Drawable is accessed using mContext.getDrawable(resid) instead of mResources.getDrawable(resid). This is a change in the statement other than return, exception handling, or control dependency, so it falls under the category of 4. Additionally, the expression indicates that a dependent API (getDrawable) is being called with potentially different objects, which constitutes a dependent API change, thus category 5 is also appropriate.","There is no Compatibility Issue detected since both early and late implementations essentially retrieve a Drawable resource and set it as a background. The difference lies in the object from which the resource is obtained (mContext versus mResources), which is an internal detail and should not affect the behavior of the API as observed by the user, provided that both mContext and mResources refer to the same logical resource source. Therefore, no CI is detected."
92,<android.transition.TransitionSet: TransitionSet addTarget(View)>,20,21,<android.transition.TransitionSet: TransitionSet addTarget(View)>,<android.transition.TransitionSet: TransitionSet addTarget(View)>,0,"{
    return (TransitionSet) super.addTarget(target);
}","{
    for (int i = 0; i < mTransitions.size(); i++) {
        mTransitions.get(i).addTarget(target);
    }
    return (TransitionSet) super.addTarget(target);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A for-loop has been added to iterate over `mTransitions` and call `addTarget(target)` on each transition object within the list before calling and returning `super.addTarget(target)`. Thus, additional operations are being performed, so the change type is 3,4, because of the new loop (control dependency change) and the method calls within it (other statement change).","There isn't a compatibility issue in terms of return values or exceptions, since the API still returns the result of `super.addTarget(target)` just like before. The additional loop modifies internal state but does not affect the output of the method directly nor introduces new exceptions, so there's no compatibility issue, and the CI type is 0."
93,<android.content.SyncRequest.Builder: Builder setDisallowMetered(boolean)>,20,21,<android.content.SyncRequest.Builder: Builder setDisallowMetered(boolean)>,<android.content.SyncRequest.Builder: Builder setDisallowMetered(boolean)>,0,"{
    mDisallowMetered = disallow;
    return this;
}","{
    if (mIgnoreSettings && disallow) {
        throw new IllegalArgumentException(""setDisallowMetered(true) after having"" + ""specified that settings are ignored."");
    }
    mDisallowMetered = disallow;
    return this;
}",1,"/**
 * @see android.net.ConnectivityManager#isActiveNetworkMetered()
 * @param disallow true to enforce that this transfer not occur on metered networks.
 * Default false.
 */
","/**
 * Will throw an <code>IllegalArgumentException</code> if called and
 * {@link #setIgnoreSettings(boolean ignoreSettings)} has already been called.
 * @param disallow true to allow this transfer on metered networks. Default false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","An if condition has been added that throws an exception under certain conditions. So, there is a control dependency change and an exception handling statement change, hence the code change type is 2,3.","The added if statement that throws an IllegalArgumentException can lead to Compatibility Issues. If 'mIgnoreSettings' is true and 'disallow' is also true, an exception will be thrown which did not happen in the early version. Plus, the added conditional may affect the flow of the method, possibly preventing the method from reaching 'mDisallowMetered = disallow' and 'return this'. Thus, there is a potential for a CI due to a different value return (CI type 1) and also due to the introduction of a new exception which was not thrown before (CI type 2)."
94,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain(AccessibilityEvent)>,20,21,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain(AccessibilityEvent)>,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain(AccessibilityEvent)>,0,"{
    AccessibilityEvent eventClone = AccessibilityEvent.obtain();
    eventClone.init(event);
    final int recordCount = event.mRecords.size();
    for (int i = 0; i < recordCount; i++) {
        AccessibilityRecord record = event.mRecords.get(i);
        AccessibilityRecord recordClone = AccessibilityRecord.obtain(record);
        eventClone.mRecords.add(recordClone);
    }
    return eventClone;
}","{
    AccessibilityEvent eventClone = AccessibilityEvent.obtain();
    eventClone.init(event);
    if (event.mRecords != null) {
        final int recordCount = event.mRecords.size();
        eventClone.mRecords = new ArrayList<AccessibilityRecord>(recordCount);
        for (int i = 0; i < recordCount; i++) {
            final AccessibilityRecord record = event.mRecords.get(i);
            final AccessibilityRecord recordClone = AccessibilityRecord.obtain(record);
            eventClone.mRecords.add(recordClone);
        }
    }
    return eventClone;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>event</code>.
 *
 * @param event The other event.
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>event</code>.
 *
 * @param event The other event.
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The late version includes a new if block that checks if event.mRecords is not null and initializes eventClone.mRecords with a new ArrayList, so the code change is a Control dependency change, corresponding to type 3.","The new if condition introduced to check whether event.mRecords is not null does not result in a Compatibility Issue, as the assignment of a new ArrayList<AccessibilityRecord> to eventClone.mRecords would have been done by the add method implicitly in the early version if event.mRecords was not null. Since this only makes the code clearer and safer by ensuring a null check before accessing event.mRecords, it should not change the API's behavior from an external point of view. As such, there is no Compatibility Issue, corresponding to type 0."
95,"<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle)>",20,21,"<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle)>","<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle)>",0,"{
    if (opts != null && opts.containsKey(EXTRA_THUMBNAIL_SIZE)) {
        final Point sizeHint = opts.getParcelable(EXTRA_THUMBNAIL_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, null);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts);
    }
}","{
    enforceTree(uri);
    if (opts != null && opts.containsKey(ContentResolver.EXTRA_SIZE)) {
        final Point sizeHint = opts.getParcelable(ContentResolver.EXTRA_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, null);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts);
    }
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 */
","/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The code added a method call to ""enforceTree(uri)"" and changed the key for options bundle from ""EXTRA_THUMBNAIL_SIZE"" to ""ContentResolver.EXTRA_SIZE"", so the change type is 3,4,5. Modification of the bundle key and additional method call before options checking can cause other statements to execute differently.","The addition of the ""enforceTree(uri)"" method could throw new exceptions not present in the earlier version, and the change in the key used to retrieve the thumbnail size from the options Bundle can cause the method to return different results if the callers do not update the key accordingly. Hence, the CI type is 1."
96,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromFd(int)>,20,21,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromFd(int)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromFd(int)>,0,"{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = Libcore.os.dup(original);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = Os.dup(original);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */
","/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in the method used for duplicating a file descriptor from Libcore.os.dup(original) to Os.dup(original). This indicates that a dependent API has been changed, so the code change type is 5.","There is no Compatibility Issue because the same process is being performed and no change in return values, exceptions thrown or control flow is observed. The underlying implementation to duplicate the file descriptor has changed, yet it is transparent to the users of the fromFd method, and the behavior is expected to remain consistent if the Os.dup(original) method is assumed to be functionally equivalent to Libcore.os.dup(original)."
97,"<android.view.View: Bitmap createSnapshot(Config,int,boolean)>",20,21,"<android.view.View: Bitmap createSnapshot(Config,int,boolean)>","<android.view.View: Bitmap createSnapshot(Config,int,boolean)>",0,"{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Resources resources = getResources();
    if (resources != null) {
        bitmap.setDensity(resources.getDisplayMetrics().densityDpi);
    }
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
        dispatchDraw(canvas);
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().draw(canvas);
        }
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    canvas.setBitmap(null);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}","{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Resources resources = getResources();
    if (resources != null) {
        bitmap.setDensity(resources.getDisplayMetrics().densityDpi);
    }
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
        dispatchDraw(canvas);
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().draw(canvas);
        }
    } else {
        draw(canvas);
    }
    drawAccessibilityFocus(canvas);
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    canvas.setBitmap(null);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}",1,"/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
","/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
99,<android.view.View: Matrix getMatrix()>,20,21,<android.view.View: Matrix getMatrix()>,<android.view.View: Matrix getMatrix()>,0,"{
    if (mTransformationInfo != null) {
        updateMatrix();
        return mTransformationInfo.mMatrix;
    }
    return Matrix.IDENTITY_MATRIX;
}","{
    ensureTransformationInfo();
    final Matrix matrix = mTransformationInfo.mMatrix;
    mRenderNode.getMatrix(matrix);
    return matrix;
}",1,"/**
 * The transform matrix of this view, which is calculated based on the current
 * roation, scale, and pivot properties.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The current transform matrix for the view
 */
","/**
 * The transform matrix of this view, which is calculated based on the current
 * rotation, scale, and pivot properties.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The current transform matrix for the view
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The change from calling updateMatrix() to ensureTransformationInfo() and mRenderNode.getMatrix(matrix) indicates a change in the dependent API (rule 5), and the change in logic marks an other statement changed (rule 4). Additionally, the entire return statement logic has been altered, which counts as a return statement changed (rule 1), leading to a code change type of 1,4,5.","The late version's return value is derived from a different sequence of calls and assignments, which will likely result in a changed value returned by the API. Hence, there's a potential Compatibility Issue of type 1 caused by potentially different return values."
101,"<android.content.res.TypedArray: int getLayoutDimension(int,String)>",20,21,"<android.content.res.TypedArray: int getLayoutDimension(int,String)>","<android.content.res.TypedArray: int getLayoutDimension(int,String)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new RuntimeException(getPositionDescription() + "": You must supply a "" + name + "" attribute."");
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new RuntimeException(getPositionDescription() + "": You must supply a "" + name + "" attribute."");
}",1,"/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 */
","/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The changes include an added if statement that throws an exception at the beginning of the method, a new exception handling scenario for when type == TypedValue.TYPE_ATTRIBUTE, and a removal of the 'mResources' reference changing to 'mMetrics'. These changes are of types 2,3,4.","The CI type is 1,2 due to the introduction of a new exception that could be thrown if the 'mRecycled' boolean is true, and also because of the additional conditional check for TypedValue.TYPE_ATTRIBUTE, which introduces another scenario where an exception is thrown. This alters the exceptions that could be thrown by this method. Moreover, the method may now return different values due to the addition of the 'mRecycled' check that may prevent further execution and the changed condition regarding the TYPE_ATTRIBUTE leading to a new route through which the RuntimeException is thrown."
104,<android.widget.CalendarView: int getWeekDayTextAppearance()>,20,21,<android.widget.CalendarView: int getWeekDayTextAppearance()>,<android.widget.CalendarView: int getWeekDayTextAppearance()>,0,"{
    return mWeekDayTextAppearanceResId;
}","{
    return mDelegate.getWeekDayTextAppearance();
}",1,"/**
 * Gets the text appearance for the week day abbreviation of the calendar header.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_weekDayTextAppearance
 */
","/**
 * Gets the text appearance for the week day abbreviation of the calendar header.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_weekDayTextAppearance
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method implementation changed from directly returning a class member variable to calling a method on a delegate object to obtain the value, which implies that the dependent API has changed, so the code change type is 5.","Since the value returned now depends on the implementation of 'getWeekDayTextAppearance()' method in the delegate object, which can potentially change between versions, the API could return a different value. Moreover, the late version might even be relying on a different source for the appearance data, which means the result might not reflect the value held in 'mWeekDayTextAppearanceResId' as it did in the early version. Thus, the CI type is 1."
106,<android.hardware.usb.UsbDevice: String toString()>,20,21,<android.hardware.usb.UsbDevice: String toString()>,<android.hardware.usb.UsbDevice: String toString()>,0,"{
    return ""UsbDevice[mName="" + mName + "",mVendorId="" + mVendorId + "",mProductId="" + mProductId + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mInterfaces="" + mInterfaces + ""]"";
}","{
    StringBuilder builder = new StringBuilder(""UsbDevice[mName="" + mName + "",mVendorId="" + mVendorId + "",mProductId="" + mProductId + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mManufacturerName="" + mManufacturerName + "",mProductName="" + mProductName + "",mSerialNumber="" + mSerialNumber + "",mConfigurations=["");
    for (int i = 0; i < mConfigurations.length; i++) {
        builder.append(""\n"");
        builder.append(mConfigurations[i].toString());
    }
    builder.append(""]"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation was changed from a simple string return statement to a StringBuilder with a loop for building a string. Two new fields mManufacturerName, mProductName, mSerialNumber are added to the final string, and mInterfaces is replaced by mConfigurations with a loop construction. Therefore, the change type is 1 (return statement changed) and 4 (other statement changed).","Because the late version of the implementation constructs a string with additional fields and a different way of representing configurations, the returned string will be different. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
107,<android.widget.CalendarView: long getDate()>,20,21,<android.widget.CalendarView: long getDate()>,<android.widget.CalendarView: long getDate()>,0,"{
    return mAdapter.mSelectedDate.getTimeInMillis();
}","{
    return mDelegate.getDate();
}",1,"/**
 * Gets the selected date in milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @return The selected date.
 */
","/**
 * Gets the selected date in milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @return The selected date.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method called to return the date has changed from `mAdapter.mSelectedDate.getTimeInMillis()` to `mDelegate.getDate()`, which indicates both a change in the return statement and a dependent API change. Thus, the code change types are 1 and 5.","Because the implementation has switched from using mAdapter to mDelegate to get the date, it will potentially return a different value since the source of the date value has changed. Hence, the CI type is 1."
109,<android.webkit.WebView: String findAddress(String)>,20,21,<android.webkit.WebView: String findAddress(String)>,<android.webkit.WebView: String findAddress(String)>,0,"{
    return getFactory().getStatics().findAddress(addr);
}","{
    // Could also be deprecated
    return getFactory().getStatics().findAddress(addr);
}",1,"/**
 * Gets the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * <ul>
 * <li>a house number</li>
 * <li>a street name</li>
 * <li>a street type (Road, Circle, etc), either spelled out or
 * abbreviated</li>
 * <li>a city name</li>
 * <li>a state or territory, either spelled out or two-letter abbr</li>
 * <li>an optional 5 digit or 9 digit zip code</li>
 * </ul>
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 *
 * @param addr the string to search for addresses
 * @return the address, or if no address is found, null
 */
","/**
 * Gets the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * <ul>
 * <li>a house number</li>
 * <li>a street name</li>
 * <li>a street type (Road, Circle, etc), either spelled out or
 * abbreviated</li>
 * <li>a city name</li>
 * <li>a state or territory, either spelled out or two-letter abbr</li>
 * <li>an optional 5 digit or 9 digit zip code</li>
 * </ul>
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 *
 * @param addr the string to search for addresses
 * @return the address, or if no address is found, null
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no code change between the two versions except for the addition of a comment which does not affect the code execution.,"As there is no actual change in the code's logic or in the control flow, there is no potential for a Compatibility Issue arising from this comparison."
110,<android.speech.tts.PlaybackSynthesisCallback: int done()>,20,21,<android.speech.tts.PlaybackSynthesisCallback: int done()>,<android.speech.tts.PlaybackSynthesisCallback: int done()>,0,"{
    if (DBG)
        Log.d(TAG, ""done()"");
    SynthesisPlaybackQueueItem item = null;
    synchronized (mStateLock) {
        if (mDone) {
            Log.w(TAG, ""Duplicate call to done()"");
            return TextToSpeech.ERROR;
        }
        mDone = true;
        if (mItem == null) {
            return TextToSpeech.ERROR;
        }
        item = mItem;
    }
    item.done();
    mLogger.onEngineComplete();
    return TextToSpeech.SUCCESS;
}","{
    if (DBG)
        Log.d(TAG, ""done()"");
    int statusCode = 0;
    SynthesisPlaybackQueueItem item = null;
    synchronized (mStateLock) {
        if (mDone) {
            Log.w(TAG, ""Duplicate call to done()"");
            // setStatusCode
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        mDone = true;
        if (mItem == null) {
            // .done() was called before .start. Treat it as successful synthesis
            // for a client, despite service bad implementation.
            Log.w(TAG, ""done() was called before start() call"");
            if (mStatusCode == TextToSpeech.SUCCESS) {
                mDispatcher.dispatchOnSuccess();
            } else {
                mDispatcher.dispatchOnError(mStatusCode);
            }
            mLogger.onEngineComplete();
            return TextToSpeech.ERROR;
        }
        item = mItem;
        statusCode = mStatusCode;
    }
    // Signal done or error to item
    if (statusCode == TextToSpeech.SUCCESS) {
        item.done();
    } else {
        item.stop(statusCode);
    }
    mLogger.onEngineComplete();
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The implementation changes include the addition of a new variable `statusCode`, a new if-statement checking `mStatusCode`, additional logging, and changes within the synchronized block and after it. These fall under categories 1, 3, and 4 (Return statement changed, Control dependency changed, Other statement changed).","The potential CI arises from both different return values and exception handling. In the late version, there's a new conditional check that may return `errorCodeOnStop()` which was not present in the early version. This contributes to a CI of type 1 (Compatibility Issue caused by potential different return values). "
112,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",20,21,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>","<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",0,"{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // The the accessibility state of the view may change while temporary
    // detached and we do not allow detached views to fire accessibility
    // events. So we are announcing that the subtree changed giving a chance
    // to clients holding on to a view in this subtree to refresh it.
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        // Clear any system-managed transient state.
        if (scrap.isAccessibilityFocused()) {
            scrap.clearAccessibilityFocus();
        }
        scrap.setAccessibilityDelegate(null);
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}","{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // The the accessibility state of the view may change while temporary
    // detached and we do not allow detached views to fire accessibility
    // events. So we are announcing that the subtree changed giving a chance
    // to clients holding on to a view in this subtree to refresh it.
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}",1,"/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */
","/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no code change in the method implementation between the early version and the late version.,"Since there is no code change, there is no compatibility issue."
113,"<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>",20,21,"<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>","<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>",0,"{
    // Look up where all of our various well-defined dir trees live on this device
    String mainDir;
    String filesDir;
    String dbDir;
    String spDir;
    String cacheDir;
    String libDir;
    String efDir = null;
    String filePath;
    ApplicationInfo appInfo = getApplicationInfo();
    try {
        mainDir = new File(appInfo.dataDir).getCanonicalPath();
        filesDir = getFilesDir().getCanonicalPath();
        dbDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
        spDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
        cacheDir = getCacheDir().getCanonicalPath();
        libDir = (appInfo.nativeLibraryDir == null) ? null : new File(appInfo.nativeLibraryDir).getCanonicalPath();
        // may or may not have external files access to attempt backup/restore there
        if (Process.myUid() != Process.SYSTEM_UID) {
            File efLocation = getExternalFilesDir(null);
            if (efLocation != null) {
                efDir = efLocation.getCanonicalPath();
            }
        }
        // Now figure out which well-defined tree the file is placed in, working from
        // most to least specific.  We also specifically exclude the lib and cache dirs.
        filePath = file.getCanonicalPath();
    } catch (IOException e) {
        Log.w(TAG, ""Unable to obtain canonical paths"");
        return;
    }
    if (filePath.startsWith(cacheDir) || filePath.startsWith(libDir)) {
        Log.w(TAG, ""lib and cache files are not backed up"");
        return;
    }
    final String domain;
    String rootpath = null;
    if (filePath.startsWith(dbDir)) {
        domain = FullBackup.DATABASE_TREE_TOKEN;
        rootpath = dbDir;
    } else if (filePath.startsWith(spDir)) {
        domain = FullBackup.SHAREDPREFS_TREE_TOKEN;
        rootpath = spDir;
    } else if (filePath.startsWith(filesDir)) {
        domain = FullBackup.DATA_TREE_TOKEN;
        rootpath = filesDir;
    } else if (filePath.startsWith(mainDir)) {
        domain = FullBackup.ROOT_TREE_TOKEN;
        rootpath = mainDir;
    } else if ((efDir != null) && filePath.startsWith(efDir)) {
        domain = FullBackup.MANAGED_EXTERNAL_TREE_TOKEN;
        rootpath = efDir;
    } else {
        Log.w(TAG, ""File "" + filePath + "" is in an unsupported location; skipping"");
        return;
    }
    // And now that we know where it lives, semantically, back it up appropriately
    Log.i(TAG, ""backupFile() of "" + filePath + "" => domain="" + domain + "" rootpath="" + rootpath);
    FullBackup.backupToTar(getPackageName(), domain, null, rootpath, filePath, output.getData());
}","{
    // Look up where all of our various well-defined dir trees live on this device
    String mainDir;
    String filesDir;
    String nbFilesDir;
    String dbDir;
    String spDir;
    String cacheDir;
    String libDir;
    String efDir = null;
    String filePath;
    ApplicationInfo appInfo = getApplicationInfo();
    try {
        mainDir = new File(appInfo.dataDir).getCanonicalPath();
        filesDir = getFilesDir().getCanonicalPath();
        nbFilesDir = getNoBackupFilesDir().getCanonicalPath();
        dbDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
        spDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
        cacheDir = getCacheDir().getCanonicalPath();
        libDir = (appInfo.nativeLibraryDir == null) ? null : new File(appInfo.nativeLibraryDir).getCanonicalPath();
        // may or may not have external files access to attempt backup/restore there
        if (Process.myUid() != Process.SYSTEM_UID) {
            File efLocation = getExternalFilesDir(null);
            if (efLocation != null) {
                efDir = efLocation.getCanonicalPath();
            }
        }
        // Now figure out which well-defined tree the file is placed in, working from
        // most to least specific.  We also specifically exclude the lib and cache dirs.
        filePath = file.getCanonicalPath();
    } catch (IOException e) {
        Log.w(TAG, ""Unable to obtain canonical paths"");
        return;
    }
    if (filePath.startsWith(cacheDir) || filePath.startsWith(libDir) || filePath.startsWith(nbFilesDir)) {
        Log.w(TAG, ""lib, cache, and no_backup files are not backed up"");
        return;
    }
    final String domain;
    String rootpath = null;
    if (filePath.startsWith(dbDir)) {
        domain = FullBackup.DATABASE_TREE_TOKEN;
        rootpath = dbDir;
    } else if (filePath.startsWith(spDir)) {
        domain = FullBackup.SHAREDPREFS_TREE_TOKEN;
        rootpath = spDir;
    } else if (filePath.startsWith(filesDir)) {
        domain = FullBackup.DATA_TREE_TOKEN;
        rootpath = filesDir;
    } else if (filePath.startsWith(mainDir)) {
        domain = FullBackup.ROOT_TREE_TOKEN;
        rootpath = mainDir;
    } else if ((efDir != null) && filePath.startsWith(efDir)) {
        domain = FullBackup.MANAGED_EXTERNAL_TREE_TOKEN;
        rootpath = efDir;
    } else {
        Log.w(TAG, ""File "" + filePath + "" is in an unsupported location; skipping"");
        return;
    }
    // And now that we know where it lives, semantically, back it up appropriately
    Log.i(TAG, ""backupFile() of "" + filePath + "" => domain="" + domain + "" rootpath="" + rootpath);
    FullBackup.backupToTar(getPackageName(), domain, null, rootpath, filePath, output.getData());
}",1,"/**
 * Write an entire file as part of a full-backup operation.  The file's contents
 * will be delivered to the backup destination along with the metadata necessary
 * to place it with the proper location and permissions on the device where the
 * data is restored.
 *
 * @param file The file to be backed up.  The file must exist and be readable by
 * the caller.
 * @param output The destination to which the backed-up file data will be sent.
 */
","/**
 * Write an entire file as part of a full-backup operation.  The file's contents
 * will be delivered to the backup destination along with the metadata necessary
 * to place it with the proper location and permissions on the device where the
 * data is restored.
 *
 * <p class=""note"">It is safe to explicitly back up files underneath your application's
 * {@link #getNoBackupFilesDir()} directory, and they will be restored to that
 * location correctly.
 *
 * @param file The file to be backed up.  The file must exist and be readable by
 * the caller.
 * @param output The destination to which the backed-up file data will be sent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
114,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",20,21,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>","<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",0,"{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change detected between the early version and the late version of the implementation, so the code change type is 0.","Since there are no changes in the implementation, there can be no Compatibility Issue, and the CI type is 0."
116,"<android.content.ContentResolver: List<PeriodicSync> getPeriodicSyncs(Account,String)>",20,21,"<android.content.ContentResolver: List<PeriodicSync> getPeriodicSyncs(Account,String)>","<android.content.ContentResolver: List<PeriodicSync> getPeriodicSyncs(Account,String)>",0,"{
    try {
        return getContentService().getPeriodicSyncs(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    try {
        return getContentService().getPeriodicSyncs(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}",1,"/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */
","/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getContentService().getPeriodicSyncs has an additional parameter 'null' passed to it in the late version, indicating that the dependent API's call signature has changed, so the code change type is 5.","There is no Compatibility Issue detected due to no change in the return value or exception thrown in the observed implementation, so the CI type is 0."
118,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,20,21,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    onUserInteraction();
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}","{
    onUserInteraction();
    // the window handling it
    if (event.getKeyCode() == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
        return true;
    }
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}",1,"/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
","/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version adds a new if-statement to check if the event's key code is `KeyEvent.KEYCODE_MENU` and whether `mActionBar` can handle the key event, along with the usage of mActionBar.onMenuKeyEvent(event). This change is a combination of control dependency change (3) due to the new if-statement and other statement changed (4) due to the new call to `mActionBar.onMenuKeyEvent(event)`.","With the introduction of a new if-statement that returns true based on certain conditions related to the `mActionBar`, there could be a scenario where the early version would not return true, but the late version does. Consequently, this could lead to the API returning different values for the same input, so the CI type is 1."
119,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(AttributeSet,int[],int,int)>",20,21,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(AttributeSet,int[],int,int)>","<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(AttributeSet,int[],int,int)>",0,"{
    int len = attrs.length;
    TypedArray array = getCachedStyledAttributes(len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);
    array.mRsrcs = attrs;
    array.mXml = parser;
    if (false) {
        int[] data = array.mData;
        System.out.println(""Attributes:"");
        String s = ""  Attrs:"";
        int i;
        for (i = 0; i < set.getAttributeCount(); i++) {
            s = s + "" "" + set.getAttributeName(i);
            int id = set.getAttributeNameResource(i);
            if (id != 0) {
                s = s + ""(0x"" + Integer.toHexString(id) + "")"";
            }
            s = s + ""="" + set.getAttributeValue(i);
        }
        System.out.println(s);
        s = ""  Found:"";
        TypedValue value = new TypedValue();
        for (i = 0; i < attrs.length; i++) {
            int d = i * AssetManager.STYLE_NUM_ENTRIES;
            value.type = data[d + AssetManager.STYLE_TYPE];
            value.data = data[d + AssetManager.STYLE_DATA];
            value.assetCookie = data[d + AssetManager.STYLE_ASSET_COOKIE];
            value.resourceId = data[d + AssetManager.STYLE_RESOURCE_ID];
            s = s + "" 0x"" + Integer.toHexString(attrs[i]) + ""="" + value;
        }
        System.out.println(s);
    }
    return array;
}","{
    final int len = attrs.length;
    final TypedArray array = TypedArray.obtain(Resources.this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    final XmlBlock.Parser parser = (XmlBlock.Parser) set;
    AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);
    array.mTheme = this;
    array.mXml = parser;
    if (false) {
        int[] data = array.mData;
        System.out.println(""Attributes:"");
        String s = ""  Attrs:"";
        int i;
        for (i = 0; i < set.getAttributeCount(); i++) {
            s = s + "" "" + set.getAttributeName(i);
            int id = set.getAttributeNameResource(i);
            if (id != 0) {
                s = s + ""(0x"" + Integer.toHexString(id) + "")"";
            }
            s = s + ""="" + set.getAttributeValue(i);
        }
        System.out.println(s);
        s = ""  Found:"";
        TypedValue value = new TypedValue();
        for (i = 0; i < attrs.length; i++) {
            int d = i * AssetManager.STYLE_NUM_ENTRIES;
            value.type = data[d + AssetManager.STYLE_TYPE];
            value.data = data[d + AssetManager.STYLE_DATA];
            value.assetCookie = data[d + AssetManager.STYLE_ASSET_COOKIE];
            value.resourceId = data[d + AssetManager.STYLE_RESOURCE_ID];
            s = s + "" 0x"" + Integer.toHexString(attrs[i]) + ""="" + value;
        }
        System.out.println(s);
    }
    return array;
}",1,"/**
 * Return a TypedArray holding the attribute values in
 * <var>set</var>
 * that are listed in <var>attrs</var>.  In addition, if the given
 * AttributeSet specifies a style class (through the ""style"" attribute),
 * that style will be applied on top of the base attributes it defines.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * <p>When determining the final value of a particular attribute, there
 * are four inputs that come into play:</p>
 *
 * <ol>
 * <li> Any attribute values in the given AttributeSet.
 * <li> The style resource specified in the AttributeSet (named
 * ""style"").
 * <li> The default style specified by <var>defStyleAttr</var> and
 * <var>defStyleRes</var>
 * <li> The base values in this theme.
 * </ol>
 *
 * <p>Each of these inputs is considered in-order, with the first listed
 * taking precedence over the following ones.  In other words, if in the
 * AttributeSet you have supplied <code>&lt;Button
 * textColor=""#ff000000""&gt;</code>, then the button's text will
 * <em>always</em> be black, regardless of what is specified in any of
 * the styles.
 *
 * @param set The base set of attribute values.  May be null.
 * @param attrs The desired attributes to be retrieved.
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(int, int[])
 */
","/**
 * Return a TypedArray holding the attribute values in
 * <var>set</var>
 * that are listed in <var>attrs</var>.  In addition, if the given
 * AttributeSet specifies a style class (through the ""style"" attribute),
 * that style will be applied on top of the base attributes it defines.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * <p>When determining the final value of a particular attribute, there
 * are four inputs that come into play:</p>
 *
 * <ol>
 * <li> Any attribute values in the given AttributeSet.
 * <li> The style resource specified in the AttributeSet (named
 * ""style"").
 * <li> The default style specified by <var>defStyleAttr</var> and
 * <var>defStyleRes</var>
 * <li> The base values in this theme.
 * </ol>
 *
 * <p>Each of these inputs is considered in-order, with the first listed
 * taking precedence over the following ones.  In other words, if in the
 * AttributeSet you have supplied <code>&lt;Button
 * textColor=""#ff000000""&gt;</code>, then the button's text will
 * <em>always</em> be black, regardless of what is specified in any of
 * the styles.
 *
 * @param set The base set of attribute values.  May be null.
 * @param attrs The desired attributes to be retrieved.
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(int, int[])
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method to obtain a TypedArray has changed from getCachedStyledAttributes(len) to TypedArray.obtain(Resources.this, len), which is a dependent API changed (5). Also, array.mRsrcs is not present in the late version, and instead array.mTheme = this; has been introduced, which is an other statement changed (4).","There is no Compatibility Issue as the return type remains the same (TypedArray), and there is no change in the behavior related to return values or exception handling in the rest of the method body. The removal of array.mRsrcs and the addition of array.mTheme doesn't affect how the API behaves from the caller's perspective, assuming internal implementation consistency within the TypedArray class."
120,"<android.database.CursorToBulkCursorAdaptor.ContentObserverProxy: void onChange(boolean,Uri)>",20,21,"<android.database.CursorToBulkCursorAdaptor.ContentObserverProxy: void onChange(boolean,Uri)>","<android.database.CursorToBulkCursorAdaptor.ContentObserverProxy: void onChange(boolean,Uri)>",0,"{
    try {
        mRemote.onChange(selfChange, uri);
    } catch (RemoteException ex) {
    // Do nothing, the far side is dead
    }
}","{
    try {
        mRemote.onChange(selfChange, uri, android.os.Process.myUid());
    } catch (RemoteException ex) {
    // Do nothing, the far side is dead
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The method mRemote.onChange has changed in the way it is called; a new parameter (android.os.Process.myUid()) is added to the method call, which is regarded as a change in the dependent API, so the code change type is 5.","The addition of a new parameter to the method call could potentially lead to a different behavior of the API because the implementation of the called method might depend on the new parameter. This qualifies as a CI type 1, where a different value could be returned due to the modified behavior of the dependent API."
121,<android.util.ArrayMap: V removeAt(int)>,20,21,<android.util.ArrayMap: V removeAt(int)>,<android.util.ArrayMap: V removeAt(int)>,0,"{
    final Object old = mArray[(index << 1) + 1];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        freeArrays(mHashes, mArray, mSize);
        mHashes = ContainerHelpers.EMPTY_INTS;
        mArray = ContainerHelpers.EMPTY_OBJECTS;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
            mArray[mSize << 1] = null;
            mArray[(mSize << 1) + 1] = null;
        }
    }
    return (V) old;
}","{
    final Object old = mArray[(index << 1) + 1];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
            mArray[mSize << 1] = null;
            mArray[(mSize << 1) + 1] = null;
        }
    }
    return (V) old;
}",1,"/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
","/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
123,"<android.content.ContentResolver: void setSyncAutomatically(Account,String,boolean)>",20,21,"<android.content.ContentResolver: void setSyncAutomatically(Account,String,boolean)>","<android.content.ContentResolver: void setSyncAutomatically(Account,String,boolean)>",0,"{
    try {
        getContentService().setSyncAutomatically(account, authority, sync);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}","{
    setSyncAutomaticallyAsUser(account, authority, sync, UserHandle.myUserId());
}",1,"/**
 * Set whether or not the provider is synced when it receives a network tickle.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being controlled
 * @param sync true if the provider should be synced when tickles are received for it
 */
","/**
 * Set whether or not the provider is synced when it receives a network tickle.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being controlled
 * @param sync true if the provider should be synced when tickles are received for it
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The late implementation calls a different method (setSyncAutomaticallyAsUser instead of getContentService().setSyncAutomatically) and it includes an additional parameter (UserHandle.myUserId()), so the code change type is 4,5.","Although there is a change in the method call, there is no direct change in return value or exception handling. The late version does not contain any try-catch block to catch RemoteException, but since the RemoteException is ignored in the early version and no other behavior of the method is modified, this should not lead to a Compatibility Issue, and the CI type is 0."
126,<android.content.ContentResolver: String getType(Uri)>,20,21,<android.content.ContentResolver: String getType(Uri)>,<android.content.ContentResolver: String getType(Uri)>,0,"{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(url, UserHandle.myUserId());
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}","{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}",1,"/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
","/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The change in the line invoking ActivityManagerNative.getDefault().getProviderMimeType() method includes wrapping the 'url' with ContentProvider.getUriWithoutUserId(url) and using resolveUserId(url) as a second parameter, so the dependent API has changed. These changes modify how the 'type' variable is assigned, so there are both Other statement changed and Dependent API changed, classified as 4,5.","The modified 'type' variable assignment alters how the return value is computed when SCHEME_CONTENT equals the url's scheme, hence this has the potential to change the returned value, constituting a compatibility issue of type 1."
127,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireProvider(Context,String)>",20,21,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireProvider(Context,String)>","<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireProvider(Context,String)>",0,"{
    return mMainThread.acquireProvider(context, auth, mUser.getIdentifier(), true);
}","{
    return mMainThread.acquireProvider(context, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation now has additional method calls: ContentProvider.getAuthorityWithoutUserId(auth) and resolveUserIdFromAuthority(auth). These methods are used to process the 'auth' parameter before it is passed to mMainThread.acquireProvider. These changes are code change type 4 since these are not changes related to control statements, exception handling, or return statements, and 5 because these additional calls indicate a change in the dependency on other APIs.","Since there is a change in how the parameters are derived before being passed to `acquireProvider`, this could potentially change the behavior of the API. Specifically, it might result in acquiring a different `IContentProvider` or not acquiring any provider at all if the resolution of the user ID or authority part alters the final parameters. Therefore, a CI type 1 for different return values or types is possible."
130,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,20,21,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final boolean customChildOrder = isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = customChildOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = children[childIndex];
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}","{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final ArrayList<View> preorderedList = buildOrderedChildList();
            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
            if (preorderedList != null)
                preorderedList.clear();
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@SuppressWarnings({ ""ConstantConditions"" }), @Override]","[@SuppressWarnings({ ""ConstantConditions"" }), @Override]",-1,-1,-1,-1,-1,-1,,,,
132,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireUnstableProvider(Context,String)>",20,21,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireUnstableProvider(Context,String)>","<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireUnstableProvider(Context,String)>",0,"{
    return mMainThread.acquireProvider(c, auth, mUser.getIdentifier(), false);
}","{
    return mMainThread.acquireProvider(c, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The dependent API call within the method body has changed from mMainThread.acquireProvider(c, auth, mUser.getIdentifier(), false) to mMainThread.acquireProvider(c, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), false), where the parameters supplied to acquireProvider are different because of the introduction of ContentProvider.getAuthorityWithoutUserId(auth) and resolveUserIdFromAuthority(auth). This change is not just a refactoring, because the parameters' values might be different when running the code, especially that the authority string is being manipulated and the user ID is being resolved, which leads us to classify the change types as 4,5.","The change to the parameters in the dependent API acquireProvider call may cause the API to return a different IContentProvider instance, depending on how ContentProvider.getAuthorityWithoutUserId and resolveUserIdFromAuthority behave. Any change in the composition of the string 'auth' or the resolution of the user ID could lead to acquiring a different provider, hence there is a CI type 1."
133,"<android.util.Log: int wtf(String,String,Throwable)>",20,21,"<android.util.Log: int wtf(String,String,Throwable)>","<android.util.Log: int wtf(String,String,Throwable)>",0,"{
    return wtf(LOG_ID_MAIN, tag, msg, tr, false);
}","{
    return wtf(LOG_ID_MAIN, tag, msg, tr, false, false);
}",1,"/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
","/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation change is an additional parameter in the call to the wtf method. This reflects a change in the dependent API, thus the code change type is 5.","As just an extra parameter is passed which is handled within the method being called, and there's no change in the behaviour of the current API itself (the signature of the current API remains the same, and what it does with the parameters it receives remains unchanged), there is no Compatibility Issue; hence, the CI type is 0."
134,"<android.view.GLES20Canvas: void drawTextOnPath(char[],int,int,Path,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawTextOnPath(char[],int,int,Path,float,float,Paint)>","<android.view.GLES20Canvas: void drawTextOnPath(char[],int,int,Path,float,float,Paint)>",0,"{
    if (index < 0 || index + count > text.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawTextOnPath(mRenderer, text, index, count, path.mNativePath, hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (index < 0 || index + count > text.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    nDrawTextOnPath(mRenderer, text, index, count, path.mNativePath, hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",0,"The removal of the modifiers setup and reset logic result in code change type 4. Furthermore, there is an additional parameter (paint.mNativeTypeface) in the nDrawTextOnPath method call, which indicates a dependent API change, thus code change type 5. Since 'modifiers' logic is removed, but does not result in a different return value or exception behavior, there is no return statement changed, which is type 1.","There is no Compatibility Issue because there's no change in the potential return value or exception thrown by the method; the method signature remains void, and the exception type thrown for incorrect text array usage has not been altered (still throws ArrayIndexOutOfBoundsException). Moreover, the modifiers logic does not affect output seen by API consumers (it is an internal mechanism), so its removal doesn't constitute a CI."
136,<android.view.View: float getPivotY()>,20,21,<android.view.View: float getPivotY()>,<android.view.View: float getPivotY()>,0,"{
    return mTransformationInfo != null ? mTransformationInfo.mPivotY : 0;
}","{
    return mRenderNode.getPivotY();
}",1,"/**
 * The y location of the point around which the view is {@link #setRotation(float) rotated}
 * and {@link #setScaleY(float) scaled}.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotY()
 * @return The y location of the pivot point.
 *
 * @attr ref android.R.styleable#View_transformPivotY
 */
","/**
 * The y location of the point around which the view is {@link #setRotation(float) rotated}
 * and {@link #setScaleY(float) scaled}.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotY()
 * @return The y location of the pivot point.
 *
 * @attr ref android.R.styleable#View_transformPivotY
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed from using the ternary operator and a condition check to a direct method call (mRenderNode.getPivotY()), and the source from which the pivot Y value is obtained has changed, which is a dependent API change. Thus, the change types are 1 and 5.","The change in the return statement involves a different method being used to obtain the pivot Y value, which could potentially result in a different return value. This qualifies as a change that could cause different behavior in the API, therefore the CI type is 1."
138,<android.view.View: boolean hasFocusable()>,20,21,<android.view.View: boolean hasFocusable()>,<android.view.View: boolean hasFocusable()>,0,"{
    return (mViewFlags & VISIBILITY_MASK) == VISIBLE && isFocusable();
}","{
    if (!isFocusableInTouchMode()) {
        for (ViewParent p = mParent; p instanceof ViewGroup; p = p.getParent()) {
            final ViewGroup g = (ViewGroup) p;
            if (g.shouldBlockFocusForTouchscreen()) {
                return false;
            }
        }
    }
    return (mViewFlags & VISIBILITY_MASK) == VISIBLE && isFocusable();
}",1,"/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns true. A ""reachable hasFocusable()""
 * is a View whose parents do not block descendants focus.
 *
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * @return True if the view is focusable or if the view contains a focusable
 * View, false otherwise.
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 */
","/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns true. A ""reachable hasFocusable()""
 * is a View whose parents do not block descendants focus.
 *
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * @return True if the view is focusable or if the view contains a focusable
 * View, false otherwise.
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 * @see ViewGroup#getTouchscreenBlocksFocus()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version of the method includes an additional block of code before the return statement that checks conditions not present in the early version. Other than this, the return statement and the condition it checks remains the same. However, due to the introduction of a new code block with control flow logic (`if` condition and a loop), this change is classified as type 1 and 3.","The newly introduced check of isFocusableInTouchMode() and the code block within the 'if' statement could potentially cause the method to return `false` before it reaches the final return statement evaluating visibility and focusability. This is a deviation from the previous behavior that only evaluated the visibility and focusability without considering the touch mode focusable state or parent's blocking behavior. As a result, the method may return a different value, causing a Compatibility Issue of type 1."
139,<android.animation.ValueAnimator: ValueAnimator setDuration(long)>,20,21,<android.animation.ValueAnimator: ValueAnimator setDuration(long)>,<android.animation.ValueAnimator: ValueAnimator setDuration(long)>,0,"{
    if (duration < 0) {
        throw new IllegalArgumentException(""Animators cannot have negative duration: "" + duration);
    }
    mUnscaledDuration = duration;
    mDuration = (long) (duration * sDurationScale);
    return this;
}","{
    if (duration < 0) {
        throw new IllegalArgumentException(""Animators cannot have negative duration: "" + duration);
    }
    mUnscaledDuration = duration;
    updateScaledDuration();
    return this;
}",1,"/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */
","/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change from a direct assignment to mDuration to a call to updateScaledDuration() method. This suggests a change in implementation detail where the scaling of duration is handled, so the code change type is 4.",#CI_description
140,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",20,21,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>","<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    boolean parentsEqual = (startParent == endParent) || (startParent.getId() == endParent.getId());
    // of reparenting the views.
    if (!mReparent || parentsEqual) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        int startLeft = startBounds.left;
        int endLeft = endBounds.left;
        int startTop = startBounds.top;
        int endTop = endBounds.top;
        int startRight = startBounds.right;
        int endRight = endBounds.right;
        int startBottom = startBounds.bottom;
        int endBottom = endBounds.bottom;
        int startWidth = startRight - startLeft;
        int startHeight = startBottom - startTop;
        int endWidth = endRight - endLeft;
        int endHeight = endBottom - endTop;
        int numChanges = 0;
        if (startWidth != 0 && startHeight != 0 && endWidth != 0 && endHeight != 0) {
            if (startLeft != endLeft)
                ++numChanges;
            if (startTop != endTop)
                ++numChanges;
            if (startRight != endRight)
                ++numChanges;
            if (startBottom != endBottom)
                ++numChanges;
        }
        if (numChanges > 0) {
            if (!mResizeClip) {
                PropertyValuesHolder[] pvh = new PropertyValuesHolder[numChanges];
                int pvhIndex = 0;
                if (startLeft != endLeft)
                    view.setLeft(startLeft);
                if (startTop != endTop)
                    view.setTop(startTop);
                if (startRight != endRight)
                    view.setRight(startRight);
                if (startBottom != endBottom)
                    view.setBottom(startBottom);
                if (startLeft != endLeft) {
                    pvh[pvhIndex++] = PropertyValuesHolder.ofInt(""left"", startLeft, endLeft);
                }
                if (startTop != endTop) {
                    pvh[pvhIndex++] = PropertyValuesHolder.ofInt(""top"", startTop, endTop);
                }
                if (startRight != endRight) {
                    pvh[pvhIndex++] = PropertyValuesHolder.ofInt(""right"", startRight, endRight);
                }
                if (startBottom != endBottom) {
                    pvh[pvhIndex++] = PropertyValuesHolder.ofInt(""bottom"", startBottom, endBottom);
                }
                ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(view, pvh);
                if (view.getParent() instanceof ViewGroup) {
                    final ViewGroup parent = (ViewGroup) view.getParent();
                    parent.suppressLayout(true);
                    TransitionListener transitionListener = new TransitionListenerAdapter() {

                        boolean mCanceled = false;

                        @Override
                        public void onTransitionCancel(Transition transition) {
                            parent.suppressLayout(false);
                            mCanceled = true;
                        }

                        @Override
                        public void onTransitionEnd(Transition transition) {
                            if (!mCanceled) {
                                parent.suppressLayout(false);
                            }
                        }

                        @Override
                        public void onTransitionPause(Transition transition) {
                            parent.suppressLayout(false);
                        }

                        @Override
                        public void onTransitionResume(Transition transition) {
                            parent.suppressLayout(true);
                        }
                    };
                    addListener(transitionListener);
                }
                return anim;
            } else {
                if (startWidth != endWidth)
                    view.setRight(endLeft + Math.max(startWidth, endWidth));
                if (startHeight != endHeight)
                    view.setBottom(endTop + Math.max(startHeight, endHeight));
                // TODO: don't clobber TX/TY
                if (startLeft != endLeft)
                    view.setTranslationX(startLeft - endLeft);
                if (startTop != endTop)
                    view.setTranslationY(startTop - endTop);
                // Animate location with translationX/Y and size with clip bounds
                float transXDelta = endLeft - startLeft;
                float transYDelta = endTop - startTop;
                int widthDelta = endWidth - startWidth;
                int heightDelta = endHeight - startHeight;
                numChanges = 0;
                if (transXDelta != 0)
                    numChanges++;
                if (transYDelta != 0)
                    numChanges++;
                if (widthDelta != 0 || heightDelta != 0)
                    numChanges++;
                PropertyValuesHolder[] pvh = new PropertyValuesHolder[numChanges];
                int pvhIndex = 0;
                if (transXDelta != 0) {
                    pvh[pvhIndex++] = PropertyValuesHolder.ofFloat(""translationX"", view.getTranslationX(), 0);
                }
                if (transYDelta != 0) {
                    pvh[pvhIndex++] = PropertyValuesHolder.ofFloat(""translationY"", view.getTranslationY(), 0);
                }
                if (widthDelta != 0 || heightDelta != 0) {
                    Rect tempStartBounds = new Rect(0, 0, startWidth, startHeight);
                    Rect tempEndBounds = new Rect(0, 0, endWidth, endHeight);
                    pvh[pvhIndex++] = PropertyValuesHolder.ofObject(""clipBounds"", sRectEvaluator, tempStartBounds, tempEndBounds);
                }
                ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(view, pvh);
                if (view.getParent() instanceof ViewGroup) {
                    final ViewGroup parent = (ViewGroup) view.getParent();
                    parent.suppressLayout(true);
                    TransitionListener transitionListener = new TransitionListenerAdapter() {

                        boolean mCanceled = false;

                        @Override
                        public void onTransitionCancel(Transition transition) {
                            parent.suppressLayout(false);
                            mCanceled = true;
                        }

                        @Override
                        public void onTransitionEnd(Transition transition) {
                            if (!mCanceled) {
                                parent.suppressLayout(false);
                            }
                        }

                        @Override
                        public void onTransitionPause(Transition transition) {
                            parent.suppressLayout(false);
                        }

                        @Override
                        public void onTransitionResume(Transition transition) {
                            parent.suppressLayout(true);
                        }
                    };
                    addListener(transitionListener);
                }
                anim.addListener(new AnimatorListenerAdapter() {

                    @Override
                    public void onAnimationEnd(Animator animation) {
                        view.setClipBounds(null);
                    }
                });
                return anim;
            }
        }
    } else {
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X);
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y);
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X);
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y);
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            sceneRoot.getLocationInWindow(tempLocation);
            Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            view.setVisibility(View.INVISIBLE);
            sceneRoot.getOverlay().add(drawable);
            Rect startBounds1 = new Rect(startX - tempLocation[0], startY - tempLocation[1], startX - tempLocation[0] + view.getWidth(), startY - tempLocation[1] + view.getHeight());
            Rect endBounds1 = new Rect(endX - tempLocation[0], endY - tempLocation[1], endX - tempLocation[0] + view.getWidth(), endY - tempLocation[1] + view.getHeight());
            ObjectAnimator anim = ObjectAnimator.ofObject(drawable, ""bounds"", sRectEvaluator, startBounds1, endBounds1);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setVisibility(View.VISIBLE);
                }
            });
            return anim;
        }
    }
    return null;
}","{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    if (parentMatches(startParent, endParent)) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        int startLeft = startBounds.left;
        int endLeft = endBounds.left;
        int startTop = startBounds.top;
        int endTop = endBounds.top;
        int startRight = startBounds.right;
        int endRight = endBounds.right;
        int startBottom = startBounds.bottom;
        int endBottom = endBounds.bottom;
        int startWidth = startRight - startLeft;
        int startHeight = startBottom - startTop;
        int endWidth = endRight - endLeft;
        int endHeight = endBottom - endTop;
        int numChanges = 0;
        if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
            if (startLeft != endLeft || startTop != endTop)
                ++numChanges;
            if (startRight != endRight || startBottom != endBottom)
                ++numChanges;
        }
        if (numChanges > 0) {
            if (!mResizeClip) {
                Animator anim;
                if (startWidth == endWidth && startHeight == endHeight) {
                    view.offsetLeftAndRight(startLeft - view.getLeft());
                    view.offsetTopAndBottom(startTop - view.getTop());
                    Path positionPath = getPathMotion().getPath(0, 0, endLeft - startLeft, endTop - startTop);
                    anim = ObjectAnimator.ofInt(view, new HorizontalOffsetProperty(), new VerticalOffsetProperty(), positionPath);
                } else {
                    if (startLeft != endLeft)
                        view.setLeft(startLeft);
                    if (startTop != endTop)
                        view.setTop(startTop);
                    if (startRight != endRight)
                        view.setRight(startRight);
                    if (startBottom != endBottom)
                        view.setBottom(startBottom);
                    ObjectAnimator topLeftAnimator = null;
                    if (startLeft != endLeft || startTop != endTop) {
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        topLeftAnimator = ObjectAnimator.ofInt(view, ""left"", ""top"", topLeftPath);
                    }
                    ObjectAnimator bottomRightAnimator = null;
                    if (startRight != endRight || startBottom != endBottom) {
                        Path bottomRightPath = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                        bottomRightAnimator = ObjectAnimator.ofInt(view, ""right"", ""bottom"", bottomRightPath);
                    }
                    anim = TransitionUtils.mergeAnimators(topLeftAnimator, bottomRightAnimator);
                }
                if (view.getParent() instanceof ViewGroup) {
                    final ViewGroup parent = (ViewGroup) view.getParent();
                    parent.suppressLayout(true);
                    TransitionListener transitionListener = new TransitionListenerAdapter() {

                        boolean mCanceled = false;

                        @Override
                        public void onTransitionCancel(Transition transition) {
                            parent.suppressLayout(false);
                            mCanceled = true;
                        }

                        @Override
                        public void onTransitionEnd(Transition transition) {
                            if (!mCanceled) {
                                parent.suppressLayout(false);
                            }
                        }

                        @Override
                        public void onTransitionPause(Transition transition) {
                            parent.suppressLayout(false);
                        }

                        @Override
                        public void onTransitionResume(Transition transition) {
                            parent.suppressLayout(true);
                        }
                    };
                    addListener(transitionListener);
                }
                return anim;
            } else {
                if (startWidth != endWidth)
                    view.setRight(endLeft + Math.max(startWidth, endWidth));
                if (startHeight != endHeight)
                    view.setBottom(endTop + Math.max(startHeight, endHeight));
                // TODO: don't clobber TX/TY
                if (startLeft != endLeft)
                    view.setTranslationX(startLeft - endLeft);
                if (startTop != endTop)
                    view.setTranslationY(startTop - endTop);
                // Animate location with translationX/Y and size with clip bounds
                float transXDelta = endLeft - startLeft;
                float transYDelta = endTop - startTop;
                int widthDelta = endWidth - startWidth;
                int heightDelta = endHeight - startHeight;
                numChanges = 0;
                if (transXDelta != 0)
                    numChanges++;
                if (transYDelta != 0)
                    numChanges++;
                if (widthDelta != 0 || heightDelta != 0)
                    numChanges++;
                ObjectAnimator translationAnimator = null;
                if (transXDelta != 0 || transYDelta != 0) {
                    Path topLeftPath = getPathMotion().getPath(0, 0, transXDelta, transYDelta);
                    translationAnimator = ObjectAnimator.ofFloat(view, View.TRANSLATION_X, View.TRANSLATION_Y, topLeftPath);
                }
                ObjectAnimator clipAnimator = null;
                if (widthDelta != 0 || heightDelta != 0) {
                    Rect tempStartBounds = new Rect(0, 0, startWidth, startHeight);
                    Rect tempEndBounds = new Rect(0, 0, endWidth, endHeight);
                    clipAnimator = ObjectAnimator.ofObject(view, ""clipBounds"", sRectEvaluator, tempStartBounds, tempEndBounds);
                }
                Animator anim = TransitionUtils.mergeAnimators(translationAnimator, clipAnimator);
                if (view.getParent() instanceof ViewGroup) {
                    final ViewGroup parent = (ViewGroup) view.getParent();
                    parent.suppressLayout(true);
                    TransitionListener transitionListener = new TransitionListenerAdapter() {

                        boolean mCanceled = false;

                        @Override
                        public void onTransitionCancel(Transition transition) {
                            parent.suppressLayout(false);
                            mCanceled = true;
                        }

                        @Override
                        public void onTransitionEnd(Transition transition) {
                            if (!mCanceled) {
                                parent.suppressLayout(false);
                            }
                        }

                        @Override
                        public void onTransitionPause(Transition transition) {
                            parent.suppressLayout(false);
                        }

                        @Override
                        public void onTransitionResume(Transition transition) {
                            parent.suppressLayout(true);
                        }
                    };
                    addListener(transitionListener);
                }
                anim.addListener(new AnimatorListenerAdapter() {

                    @Override
                    public void onAnimationEnd(Animator animation) {
                        view.setClipBounds(null);
                    }
                });
                return anim;
            }
        }
    } else {
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X);
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y);
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X);
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y);
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            sceneRoot.getLocationInWindow(tempLocation);
            Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            final float transitionAlpha = view.getTransitionAlpha();
            view.setTransitionAlpha(0);
            sceneRoot.getOverlay().add(drawable);
            Path topLeftPath = getPathMotion().getPath(startX - tempLocation[0], startY - tempLocation[1], endX - tempLocation[0], endY - tempLocation[1]);
            PropertyValuesHolder origin = PropertyValuesHolder.ofObject(DRAWABLE_ORIGIN_PROPERTY, null, topLeftPath);
            ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(drawable, origin);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setTransitionAlpha(transitionAlpha);
                }
            });
            return anim;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
142,<android.view.View: float getRotationY()>,20,21,<android.view.View: float getRotationY()>,<android.view.View: float getRotationY()>,0,"{
    return mTransformationInfo != null ? mTransformationInfo.mRotationY : 0;
}","{
    return mRenderNode.getRotationY();
}",1,"/**
 * The degrees that the view is rotated around the vertical axis through the pivot point.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @see #setRotationY(float)
 *
 * @return The degrees of Y rotation.
 */
","/**
 * The degrees that the view is rotated around the vertical axis through the pivot point.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @see #setRotationY(float)
 *
 * @return The degrees of Y rotation.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method of acquiring the rotation Y value has changed from using a conditional statement checking 'mTransformationInfo' to directly calling 'mRenderNode.getRotationY()'. It implies a change in the return statement and the dependency on another API, so the code change type is 1,5.","Since the implementation for getting the rotation Y value has altered, the method may now potentially return a different value, therefore, the CI is of type 1."
143,"<android.transition.Visibility: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",20,21,"<android.transition.Visibility: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>","<android.transition.Visibility: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",0,"{
    VisibilityInfo visInfo = getVisibilityChangeInfo(startValues, endValues);
    if (visInfo.visibilityChange) {
        // Only transition views that are either targets of this transition
        // or whose parent hierarchies remain stable between scenes
        boolean isTarget = false;
        if (mTargets.size() > 0 || mTargetIds.size() > 0) {
            View startView = startValues != null ? startValues.view : null;
            View endView = endValues != null ? endValues.view : null;
            int startId = startView != null ? startView.getId() : -1;
            int endId = endView != null ? endView.getId() : -1;
            isTarget = isValidTarget(startView, startId) || isValidTarget(endView, endId);
        }
        if (isTarget || ((visInfo.startParent != null || visInfo.endParent != null))) {
            if (visInfo.fadeIn) {
                return onAppear(sceneRoot, startValues, visInfo.startVisibility, endValues, visInfo.endVisibility);
            } else {
                return onDisappear(sceneRoot, startValues, visInfo.startVisibility, endValues, visInfo.endVisibility);
            }
        }
    }
    return null;
}","{
    VisibilityInfo visInfo = getVisibilityChangeInfo(startValues, endValues);
    if (visInfo.visibilityChange && (visInfo.startParent != null || visInfo.endParent != null)) {
        if (visInfo.fadeIn) {
            return onAppear(sceneRoot, startValues, visInfo.startVisibility, endValues, visInfo.endVisibility);
        } else {
            return onDisappear(sceneRoot, startValues, visInfo.startVisibility, endValues, visInfo.endVisibility);
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"In the late version, the condition 'if (mTargets.size() > 0 || mTargetIds.size() > 0)' and associated block are removed. Also, the later condition in 'if (visInfo.visibilityChange)' is simplified by directly integrating the check for parent existence into it, resulting in removal of one layer of if-statement. Thus, the change type is 3 (Control dependency change).","Due to the change in the control flow, which includes simplifying the if-statements, and removal of the targets-related checks, the conditions under which the createAnimator method will enter the following block if(visInfo.fadeIn) { ... } else { ... } are changed. Specifically, the previously required target-related condition check is no longer present. As a result, there is a potential change in the return value depending on whether 'isTarget' was true or not in the previous implementation. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
144,"<android.view.GLES20Canvas: void drawPatch(NinePatch,Rect,Paint)>",20,21,"<android.view.GLES20Canvas: void drawPatch(NinePatch,Rect,Paint)>","<android.view.GLES20Canvas: void drawPatch(NinePatch,Rect,Paint)>",0,"{
    Bitmap bitmap = patch.getBitmap();
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing patches
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawPatch(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, patch.mNativeChunk, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
}","{
    Bitmap bitmap = patch.getBitmap();
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawPatch(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, patch.mNativeChunk, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The try-finally block has been removed, along with the related code that handles color filters. This includes the deletion of the setupColorFilter() call and the condition inside the finally block, so the change types are 3 and 4.","Despite the code changes, since the actual drawing operation (nDrawPatch) remains the same and the signature of the method remains unchanged, these changes do not affect what value or type is being returned or any exception being thrown. Therefore, there is no Compatibility Issue regarding different return values or types and exception handlings."
148,<android.util.ArrayMap: V get(Object)>,20,21,<android.util.ArrayMap: V get(Object)>,<android.util.ArrayMap: V get(Object)>,0,"{
    final int index = key == null ? indexOfNull() : indexOf(key, key.hashCode());
    return index >= 0 ? (V) mArray[(index << 1) + 1] : null;
}","{
    final int index = indexOfKey(key);
    return index >= 0 ? (V) mArray[(index << 1) + 1] : null;
}",1,"/**
 * Retrieve a value from the array.
 * @param key The key of the value to retrieve.
 * @return Returns the value associated with the given key,
 * or null if there is no such key.
 */
","/**
 * Retrieve a value from the array.
 * @param key The key of the value to retrieve.
 * @return Returns the value associated with the given key,
 * or null if there is no such key.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method used to calculate 'index' has been changed from a ternary operation involving 'indexOfNull()' or 'indexOf(key, key.hashCode())' to a single method call 'indexOfKey(key)'. Therefore, the code change type is 5 due to a change in the dependent API.","There is no Compatibility Issue caused by this code change because the behavior of getting the value associated with the key in an ArrayMap remains consistent—the method change is an internal change to how the index is calculated, and it does not affect the return value or exception handling of the 'get' method."
150,<android.widget.CalendarView: int getDateTextAppearance()>,20,21,<android.widget.CalendarView: int getDateTextAppearance()>,<android.widget.CalendarView: int getDateTextAppearance()>,0,"{
    return mDateTextAppearanceResId;
}","{
    return mDelegate.getDateTextAppearance();
}",1,"/**
 * Gets the text appearance for the calendar dates.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_dateTextAppearance
 */
","/**
 * Gets the text appearance for the calendar dates.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_dateTextAppearance
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation changes from directly returning a member variable to calling a method on another object (mDelegate.getDateTextAppearance()), so the code change types are 1 for the return statement change and 5 for the change in the dependent API.","As the implementation now depends on a method call instead of a direct member variable access, this could potentially lead to a different return value, so the CI type is 1."
153,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,20,21,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,0,"{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetFloatMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // Couldn't find it via JNI - try reflection next. Probably means the method
    // doesn't exist, or the type is wrong. An error will be logged later if
    // reflection fails as well.
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}","{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Long jniSetter = propertyMap.get(mPropertyName);
            if (jniSetter != null) {
                mJniSetter = jniSetter;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetFloatMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Long>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // Couldn't find it via JNI - try reflection next. Probably means the method
    // doesn't exist, or the type is wrong. An error will be logged later if
    // reflection fails as well.
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The type of elements within the propertyMap was changed from `Integer` to `Long`, which is an internal change in the way the JNI setter is stored. The key variable `mJniSetter` seems to be of a type that can accommodate the new `Long` value without issues, but this still represents an internal change (Other statement changed: 4). This change also reflects an altered dependent API (the expected types within the sJNISetterPropertyMap have changed: 5).",There should be no Compatibility Issues as a result of this change because the modified part of the code (HashMap element type and its management) does not affect the API behavior as seen by the API users. There is no difference in the way users interact with the `setupSetter` method nor in the expected results when using this method. The function's interface and expected effects remain unchanged.
155,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,20,21,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        SparseLongArray childIds = mChildNodeIds;
        builder.append(""; childAccessibilityIds: ["");
        for (int i = 0, count = childIds.size(); i < count; i++) {
            builder.append(childIds.valueAt(i));
            if (i < count - 1) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "" + isScrollable());
    builder.append(""; ["");
    for (int actionBits = mActions; actionBits != 0; ) {
        final int action = 1 << Integer.numberOfTrailingZeros(actionBits);
        actionBits &= ~action;
        builder.append(getActionSymbolicName(action));
        if (actionBits != 0) {
            builder.append("", "");
        }
    }
    builder.append(""]"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
157,<android.view.accessibility.AccessibilityManager: boolean removeAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,20,21,<android.view.accessibility.AccessibilityManager: boolean removeAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean removeAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,0,"{
    return mAccessibilityStateChangeListeners.remove(listener);
}","{
    // Final CopyOnArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.remove(listener);
}",1,"/**
 * Unregisters an {@link AccessibilityStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
","/**
 * Unregisters an {@link AccessibilityStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The change is simply the addition of a comment and does not affect the execution of the code around it. This type of change is classified under other statement changed (4).,"The addition of a comment does not alter the behavior of the code or affect the result. Therefore, there is no compatibility issue as a result of this change (0)."
159,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,20,21,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,0,"{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        default:
            return null;
    }
}","{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The switch statement has added a new case, `FLAG_RETRIEVE_INTERACTIVE_WINDOWS`, resulting in changes to the control dependency (3), and this addition introduces a new possible return value (1).","For the value corresponding to `FLAG_RETRIEVE_INTERACTIVE_WINDOWS`, the early version of the API would have returned `null`, but the late version will now return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"". Therefore, the behavior of the API has changed with the possibility of returning a new value where it previously would not, making the CI type 1."
160,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",20,21,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>","<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",0,"{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The changes include control dependency changes with additional 'else if' blocks for BluetoothProfile.A2DP_SINK and BluetoothProfile.AVRCP_CONTROLLER, the initialization of respective Bluetooth profile object instances (BluetoothA2dpSink and BluetoothAvrcpController), and the addition of a new block for BluetoothProfile.HEADSET_CLIENT with the initialization of BluetoothHeadsetClient. We see no changes to return types, exception handling, or external dependencies specifically within the method body regarding referenced types from other APIs. These changes represent an addition of functionality without altering the existing behavior for existing profiles. ","No Compatibility Issue due to the nature of the changes. The existing functionality has not been modified and will behave the same way for existing profiles. The new profiles have been added to extend functionality, but they do not introduce backward compatibility issues for the existing profiles or any sort of behavior change when one of the previously existing profiles is passed in. As long as the early version caller doesn't use the new profiles, they would experience the same behavior."
161,<android.content.RestrictionEntry: String[] getAllSelectedStrings()>,20,21,<android.content.RestrictionEntry: String[] getAllSelectedStrings()>,<android.content.RestrictionEntry: String[] getAllSelectedStrings()>,0,"{
    return currentValues;
}","{
    return mCurrentValues;
}",1,"/**
 * Returns the list of currently selected values.
 * @return the list of current selections, if type is {@link #TYPE_MULTI_SELECT},
 * null otherwise.
 */
","/**
 * Returns the list of currently selected values.
 * @return the list of current selections, if type is {@link #TYPE_MULTI_SELECT},
 * null otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has changed only the variable name from 'currentValues' to 'mCurrentValues', which indicates a possible refactoring of the variable name in the class. The return type and the behavior of the method remain the same, so the change type is 4.",No Compatibility Issue is detected because the change does not alter the behavior of the method. It simply renames a variable which doesn't affect the outcome or how the method operates.
162,<android.ddm.DdmHandleViewDebug: Chunk handleChunk(Chunk)>,20,21,<android.ddm.DdmHandleViewDebug: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleViewDebug: Chunk handleChunk(Chunk)>,0,"{
    int type = request.type;
    if (type == CHUNK_VUGL) {
        return handleOpenGlTrace(request);
    } else if (type == CHUNK_VULW) {
        return listWindows();
    }
    ByteBuffer in = wrapChunk(request);
    int op = in.getInt();
    View rootView = getRootView(in);
    if (rootView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid View Root"");
    }
    if (type == CHUNK_VURT) {
        if (op == VURT_DUMP_HIERARCHY)
            return dumpHierarchy(rootView, in);
        else if (op == VURT_CAPTURE_LAYERS)
            return captureLayers(rootView);
        else
            return createFailChunk(ERR_INVALID_OP, ""Unknown view root operation: "" + op);
    }
    final View targetView = getTargetView(rootView, in);
    if (targetView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid target view"");
    }
    if (type == CHUNK_VUOP) {
        switch(op) {
            case VUOP_CAPTURE_VIEW:
                return captureView(rootView, targetView);
            case VUOP_DUMP_DISPLAYLIST:
                return dumpDisplayLists(rootView, targetView);
            case VUOP_PROFILE_VIEW:
                return profileView(rootView, targetView);
            case VUOP_INVOKE_VIEW_METHOD:
                return invokeViewMethod(rootView, targetView, in);
            case VUOP_SET_LAYOUT_PARAMETER:
                return setLayoutParameter(rootView, targetView, in);
            default:
                return createFailChunk(ERR_INVALID_OP, ""Unknown view operation: "" + op);
        }
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    int type = request.type;
    if (type == CHUNK_VUGL) {
        return handleOpenGlTrace(request);
    } else if (type == CHUNK_VULW) {
        return listWindows();
    }
    ByteBuffer in = wrapChunk(request);
    int op = in.getInt();
    View rootView = getRootView(in);
    if (rootView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid View Root"");
    }
    if (type == CHUNK_VURT) {
        if (op == VURT_DUMP_HIERARCHY)
            return dumpHierarchy(rootView, in);
        else if (op == VURT_CAPTURE_LAYERS)
            return captureLayers(rootView);
        else if (op == VURT_DUMP_THEME)
            return dumpTheme(rootView);
        else
            return createFailChunk(ERR_INVALID_OP, ""Unknown view root operation: "" + op);
    }
    final View targetView = getTargetView(rootView, in);
    if (targetView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid target view"");
    }
    if (type == CHUNK_VUOP) {
        switch(op) {
            case VUOP_CAPTURE_VIEW:
                return captureView(rootView, targetView);
            case VUOP_DUMP_DISPLAYLIST:
                return dumpDisplayLists(rootView, targetView);
            case VUOP_PROFILE_VIEW:
                return profileView(rootView, targetView);
            case VUOP_INVOKE_VIEW_METHOD:
                return invokeViewMethod(rootView, targetView, in);
            case VUOP_SET_LAYOUT_PARAMETER:
                return setLayoutParameter(rootView, targetView, in);
            default:
                return createFailChunk(ERR_INVALID_OP, ""Unknown view operation: "" + op);
        }
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the addition of an `else if` block to handle the case where `op == VURT_DUMP_THEME` by returning `dumpTheme(rootView);`. This is an other statement change (4), introducing new functionality without altering existing behavior of any previously existing control paths.","This change does not introduce a Compatibility Issue because it does not alter the behavior of the API for existing inputs. It only adds behavior for a new operation code (VURT_DUMP_THEME) which would not have been used in the early version because it did not exist then. For all existing operation codes and control paths, the API behavior remains unchanged."
163,<android.speech.tts.TextToSpeech.Connection.SetupConnectionAsyncTask: Integer doInBackground(Void)>,20,21,<android.speech.tts.TextToSpeech.Connection.SetupConnectionAsyncTask: Integer doInBackground(Void)>,<android.speech.tts.TextToSpeech.Connection.SetupConnectionAsyncTask: Integer doInBackground(Void)>,0,"{
    synchronized (mStartLock) {
        if (isCancelled()) {
            return null;
        }
        try {
            mService.setCallback(getCallerIdentity(), mCallback);
            String[] defaultLanguage = mService.getClientDefaultLanguage();
            mParams.putString(Engine.KEY_PARAM_LANGUAGE, defaultLanguage[0]);
            mParams.putString(Engine.KEY_PARAM_COUNTRY, defaultLanguage[1]);
            mParams.putString(Engine.KEY_PARAM_VARIANT, defaultLanguage[2]);
            Log.i(TAG, ""Set up connection to "" + mName);
            return SUCCESS;
        } catch (RemoteException re) {
            Log.e(TAG, ""Error connecting to service, setCallback() failed"");
            return ERROR;
        }
    }
}","{
    synchronized (mStartLock) {
        if (isCancelled()) {
            return null;
        }
        try {
            mService.setCallback(getCallerIdentity(), mCallback);
            if (mParams.getString(Engine.KEY_PARAM_LANGUAGE) == null) {
                String[] defaultLanguage = mService.getClientDefaultLanguage();
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, defaultLanguage[0]);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, defaultLanguage[1]);
                mParams.putString(Engine.KEY_PARAM_VARIANT, defaultLanguage[2]);
                // Get the default voice for the locale.
                String defaultVoiceName = mService.getDefaultVoiceNameFor(defaultLanguage[0], defaultLanguage[1], defaultLanguage[2]);
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, defaultVoiceName);
            }
            Log.i(TAG, ""Set up connection to "" + mName);
            return SUCCESS;
        } catch (RemoteException re) {
            Log.e(TAG, ""Error connecting to service, setCallback() failed"");
            return ERROR;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There's a new condition introduced and new 'putString' operations are added for mParams. The condition 'if (mParams.getString(Engine.KEY_PARAM_LANGUAGE) == null)' and additional operations inside the condition represent a control dependency change. Additionally, the new operation 'mParams.putString(Engine.KEY_PARAM_VOICE_NAME, defaultVoiceName)' could change the contents of mParams, which is not controlled by a control statement, therefore, there's also an other statement change, so the code change type is 3,4.","The added condition and new operations influence what values are put into the mParams bundle, which can alter the behavior of subsequent operations that rely on mParams. Since this change affects the return value from the doInBackground() method by potentially altering the mParams bundle, there is a CI caused by potential different return values, so the CI type is 1."
164,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyHandler: void handleMessage(Message)>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyHandler: void handleMessage(Message)>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyHandler: void handleMessage(Message)>,0,"{
    if (isFinished()) {
        return;
    }
    switch(message.what) {
        case MSG_START:
            {
                final PrintDocumentAdapter adapter;
                synchronized (mLock) {
                    adapter = mDocumentAdapter;
                }
                if (adapter != null) {
                    adapter.onStart();
                }
            }
            break;
        case MSG_LAYOUT:
            {
                final PrintDocumentAdapter adapter;
                final CancellationSignal cancellation;
                final LayoutSpec layoutSpec;
                synchronized (mLock) {
                    adapter = mDocumentAdapter;
                    layoutSpec = mLastLayoutSpec;
                    mLastLayoutSpec = null;
                    cancellation = new CancellationSignal();
                    mLayoutOrWriteCancellation = cancellation;
                }
                if (layoutSpec != null && adapter != null) {
                    if (DEBUG) {
                        Log.i(LOG_TAG, ""Performing layout"");
                    }
                    adapter.onLayout(layoutSpec.oldAttributes, layoutSpec.newAttributes, cancellation, new MyLayoutResultCallback(layoutSpec.callback, layoutSpec.sequence), layoutSpec.metadata);
                }
            }
            break;
        case MSG_WRITE:
            {
                final PrintDocumentAdapter adapter;
                final CancellationSignal cancellation;
                final WriteSpec writeSpec;
                synchronized (mLock) {
                    adapter = mDocumentAdapter;
                    writeSpec = mLastWriteSpec;
                    mLastWriteSpec = null;
                    cancellation = new CancellationSignal();
                    mLayoutOrWriteCancellation = cancellation;
                }
                if (writeSpec != null && adapter != null) {
                    if (DEBUG) {
                        Log.i(LOG_TAG, ""Performing write"");
                    }
                    adapter.onWrite(writeSpec.pages, writeSpec.fd, cancellation, new MyWriteResultCallback(writeSpec.callback, writeSpec.fd, writeSpec.sequence));
                }
            }
            break;
        case MSG_FINISH:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""Performing finish"");
                }
                final PrintDocumentAdapter adapter;
                final Activity activity;
                synchronized (mLock) {
                    adapter = mDocumentAdapter;
                    activity = mActivity;
                    clearLocked();
                }
                if (adapter != null) {
                    adapter.onFinish();
                }
                if (activity != null) {
                    activity.getApplication().unregisterActivityLifecycleCallbacks(PrintDocumentAdapterDelegate.this);
                }
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + message.what);
            }
    }
}","{
    switch(message.what) {
        case MSG_ON_START:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""onStart()"");
                }
                ((PrintDocumentAdapter) message.obj).onStart();
            }
            break;
        case MSG_ON_LAYOUT:
            {
                SomeArgs args = (SomeArgs) message.obj;
                PrintDocumentAdapter adapter = (PrintDocumentAdapter) args.arg1;
                PrintAttributes oldAttributes = (PrintAttributes) args.arg2;
                PrintAttributes newAttributes = (PrintAttributes) args.arg3;
                CancellationSignal cancellation = (CancellationSignal) args.arg4;
                LayoutResultCallback callback = (LayoutResultCallback) args.arg5;
                Bundle metadata = (Bundle) args.arg6;
                args.recycle();
                if (DEBUG) {
                    StringBuilder builder = new StringBuilder();
                    builder.append(""PrintDocumentAdapter#onLayout() {\n"");
                    builder.append(""\n  oldAttributes:"").append(oldAttributes);
                    builder.append(""\n  newAttributes:"").append(newAttributes);
                    builder.append(""\n  preview:"").append(metadata.getBoolean(PrintDocumentAdapter.EXTRA_PRINT_PREVIEW));
                    builder.append(""\n}"");
                    Log.i(LOG_TAG, builder.toString());
                }
                adapter.onLayout(oldAttributes, newAttributes, cancellation, callback, metadata);
            }
            break;
        case MSG_ON_WRITE:
            {
                SomeArgs args = (SomeArgs) message.obj;
                PrintDocumentAdapter adapter = (PrintDocumentAdapter) args.arg1;
                PageRange[] pages = (PageRange[]) args.arg2;
                ParcelFileDescriptor fd = (ParcelFileDescriptor) args.arg3;
                CancellationSignal cancellation = (CancellationSignal) args.arg4;
                WriteResultCallback callback = (WriteResultCallback) args.arg5;
                args.recycle();
                if (DEBUG) {
                    StringBuilder builder = new StringBuilder();
                    builder.append(""PrintDocumentAdapter#onWrite() {\n"");
                    builder.append(""\n  pages:"").append(Arrays.toString(pages));
                    builder.append(""\n}"");
                    Log.i(LOG_TAG, builder.toString());
                }
                adapter.onWrite(pages, fd, cancellation, callback);
            }
            break;
        case MSG_ON_FINISH:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""onFinish()"");
                }
                ((PrintDocumentAdapter) message.obj).onFinish();
                // should not be used anymore.
                synchronized (mLock) {
                    destroyLocked();
                }
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + message.what);
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
165,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",20,21,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>","<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",0,"{
    if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_CONNECTED_TO_PROVISIONING_APN)) {
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(mApnType, apnType)) {
            return;
        }
        if (DBG) {
            log(""Broadcast received: "" + intent.getAction() + "" apnType="" + apnType + "" apnName="" + apnName);
        }
        // Make us in the connecting state until we make a new TYPE_MOBILE_PROVISIONING
        mMobileDataState = PhoneConstants.DataState.CONNECTING;
        updateLinkProperitesAndCapatilities(intent);
        mNetworkInfo.setIsConnectedToProvisioningNetwork(true);
        // Change state to SUSPENDED so setDetailedState
        // sends EVENT_STATE_CHANGED to connectivityService
        setDetailedState(DetailedState.SUSPENDED, """", apnName);
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        // Assume this isn't a provisioning network.
        mNetworkInfo.setIsConnectedToProvisioningNetwork(false);
        if (DBG) {
            log(""Broadcast received: "" + intent.getAction() + "" apnType="" + apnType);
        }
        int oldSubtype = mNetworkInfo.getSubtype();
        int newSubType = TelephonyManager.getDefault().getNetworkType();
        String subTypeName = TelephonyManager.getDefault().getNetworkTypeName();
        mNetworkInfo.setSubtype(newSubType, subTypeName);
        if (newSubType != oldSubtype && mNetworkInfo.isConnected()) {
            Message msg = mTarget.obtainMessage(EVENT_NETWORK_SUBTYPE_CHANGED, oldSubtype, 0, mNetworkInfo);
            msg.sendToTarget();
        }
        PhoneConstants.DataState state = Enum.valueOf(PhoneConstants.DataState.class, intent.getStringExtra(PhoneConstants.STATE_KEY));
        String reason = intent.getStringExtra(PhoneConstants.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        mNetworkInfo.setRoaming(intent.getBooleanExtra(PhoneConstants.DATA_NETWORK_ROAMING_KEY, false));
        if (VDBG) {
            log(mApnType + "" setting isAvailable to "" + intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        }
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    updateLinkProperitesAndCapatilities(intent);
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
            if (VDBG) {
                Slog.d(TAG, ""TelephonyMgr.DataConnectionStateChanged"");
                if (mNetworkInfo != null) {
                    Slog.d(TAG, ""NetworkInfo = "" + mNetworkInfo.toString());
                    Slog.d(TAG, ""subType = "" + String.valueOf(mNetworkInfo.getSubtype()));
                    Slog.d(TAG, ""subType = "" + mNetworkInfo.getSubtypeName());
                }
                if (mLinkProperties != null) {
                    Slog.d(TAG, ""LinkProperties = "" + mLinkProperties.toString());
                } else {
                    Slog.d(TAG, ""LinkProperties = "");
                }
                if (mLinkCapabilities != null) {
                    Slog.d(TAG, ""LinkCapabilities = "" + mLinkCapabilities.toString());
                } else {
                    Slog.d(TAG, ""LinkCapabilities = "");
                }
            }
            /* lets not sample traffic data across state changes */
            mSamplingDataTracker.resetSamplingData();
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, PhoneConstants.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    loge(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        // Assume this isn't a provisioning network.
        mNetworkInfo.setIsConnectedToProvisioningNetwork(false);
        String reason = intent.getStringExtra(PhoneConstants.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        if (DBG) {
            log(""Broadcast received: "" + intent.getAction() + "" reason="" + reason == null ? ""null"" : reason);
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}","{
    if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_CONNECTED_TO_PROVISIONING_APN)) {
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(mApnType, apnType)) {
            return;
        }
        if (DBG) {
            log(""Broadcast received: "" + intent.getAction() + "" apnType="" + apnType + "" apnName="" + apnName);
        }
        // Make us in the connecting state until we make a new TYPE_MOBILE_PROVISIONING
        mMobileDataState = PhoneConstants.DataState.CONNECTING;
        updateLinkProperitesAndCapatilities(intent);
        mNetworkInfo.setIsConnectedToProvisioningNetwork(true);
        // Change state to SUSPENDED so setDetailedState
        // sends EVENT_STATE_CHANGED to connectivityService
        setDetailedState(DetailedState.SUSPENDED, """", apnName);
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        // Assume this isn't a provisioning network.
        mNetworkInfo.setIsConnectedToProvisioningNetwork(false);
        if (DBG) {
            log(""Broadcast received: "" + intent.getAction() + "" apnType="" + apnType);
        }
        int oldSubtype = mNetworkInfo.getSubtype();
        int newSubType = TelephonyManager.getDefault().getNetworkType();
        String subTypeName = TelephonyManager.getDefault().getNetworkTypeName();
        mNetworkInfo.setSubtype(newSubType, subTypeName);
        if (newSubType != oldSubtype && mNetworkInfo.isConnected()) {
            Message msg = mTarget.obtainMessage(EVENT_NETWORK_SUBTYPE_CHANGED, oldSubtype, 0, mNetworkInfo);
            msg.sendToTarget();
        }
        PhoneConstants.DataState state = Enum.valueOf(PhoneConstants.DataState.class, intent.getStringExtra(PhoneConstants.STATE_KEY));
        String reason = intent.getStringExtra(PhoneConstants.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        mNetworkInfo.setRoaming(intent.getBooleanExtra(PhoneConstants.DATA_NETWORK_ROAMING_KEY, false));
        if (VDBG) {
            log(mApnType + "" setting isAvailable to "" + intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        }
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    updateLinkProperitesAndCapatilities(intent);
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
            if (VDBG) {
                Slog.d(TAG, ""TelephonyMgr.DataConnectionStateChanged"");
                if (mNetworkInfo != null) {
                    Slog.d(TAG, ""NetworkInfo = "" + mNetworkInfo);
                    Slog.d(TAG, ""subType = "" + mNetworkInfo.getSubtype());
                    Slog.d(TAG, ""subType = "" + mNetworkInfo.getSubtypeName());
                }
                if (mLinkProperties != null) {
                    Slog.d(TAG, ""LinkProperties = "" + mLinkProperties);
                } else {
                    Slog.d(TAG, ""LinkProperties = "");
                }
                if (mNetworkCapabilities != null) {
                    Slog.d(TAG, mNetworkCapabilities.toString());
                } else {
                    Slog.d(TAG, ""NetworkCapabilities = "");
                }
            }
            /* lets not sample traffic data across state changes */
            mSamplingDataTracker.resetSamplingData();
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, PhoneConstants.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    loge(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        // Assume this isn't a provisioning network.
        mNetworkInfo.setIsConnectedToProvisioningNetwork(false);
        String reason = intent.getStringExtra(PhoneConstants.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        if (DBG) {
            log(""Broadcast received: "" + intent.getAction() + "" reason="" + reason == null ? ""null"" : reason);
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
167,"<android.animation.ObjectAnimator: ObjectAnimator ofPropertyValuesHolder(Object,PropertyValuesHolder)>",20,21,"<android.animation.ObjectAnimator: ObjectAnimator ofPropertyValuesHolder(Object,PropertyValuesHolder)>","<android.animation.ObjectAnimator: ObjectAnimator ofPropertyValuesHolder(Object,PropertyValuesHolder)>",0,"{
    ObjectAnimator anim = new ObjectAnimator();
    anim.mTarget = target;
    anim.setValues(values);
    return anim;
}","{
    ObjectAnimator anim = new ObjectAnimator();
    anim.setTarget(target);
    anim.setValues(values);
    return anim;
}",1,"/**
 * Constructs and returns an ObjectAnimator that animates between the sets of values specified
 * in <code>PropertyValueHolder</code> objects. This variant should be used when animating
 * several properties at once with the same ObjectAnimator, since PropertyValuesHolder allows
 * you to associate a set of animation values with a property name.
 *
 * @param target The object whose property is to be animated. Depending on how the
 * PropertyValuesObjects were constructed, the target object should either have the {@link
 * android.util.Property} objects used to construct the PropertyValuesHolder objects or (if the
 * PropertyValuesHOlder objects were created with property names) the target object should have
 * public methods on it called <code>setName()</code>, where <code>name</code> is the name of
 * the property passed in as the <code>propertyName</code> parameter for each of the
 * PropertyValuesHolder objects.
 * @param values A set of PropertyValuesHolder objects whose values will be animated between
 * over time.
 * @return An ObjectAnimator object that is set up to animate between the given values.
 */
","/**
 * Constructs and returns an ObjectAnimator that animates between the sets of values specified
 * in <code>PropertyValueHolder</code> objects. This variant should be used when animating
 * several properties at once with the same ObjectAnimator, since PropertyValuesHolder allows
 * you to associate a set of animation values with a property name.
 *
 * @param target The object whose property is to be animated. Depending on how the
 * PropertyValuesObjects were constructed, the target object should either have the {@link
 * android.util.Property} objects used to construct the PropertyValuesHolder objects or (if the
 * PropertyValuesHOlder objects were created with property names) the target object should have
 * public methods on it called <code>setName()</code>, where <code>name</code> is the name of
 * the property passed in as the <code>propertyName</code> parameter for each of the
 * PropertyValuesHolder objects.
 * @param values A set of PropertyValuesHolder objects whose values will be animated between
 * over time.
 * @return An ObjectAnimator object that is set up to animate between the given values.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the method used to set the target of the animation. In the early version, the 'mTarget' field is directly assigned, whereas in the late version, the 'setTarget()' method is called instead. This indicates a change of dependent API (the method used to set the target), so the code change type is 4,5.","The change from direct assignment to using a setter method does not inherently cause a different behavior since both operations aim to set the same property (the target of the animation). No new return statement or exception handling statement was introduced. Therefore, no potential Compatibility Issue could arise from this change, and the CI type is 0."
168,<android.os.PowerManager: void goToSleep(long)>,20,21,<android.os.PowerManager: void goToSleep(long)>,<android.os.PowerManager: void goToSleep(long)>,0,"{
    try {
        mService.goToSleep(time, GO_TO_SLEEP_REASON_USER);
    } catch (RemoteException e) {
    }
}","{
    goToSleep(time, GO_TO_SLEEP_REASON_APPLICATION, 0);
}",1,"/**
 * Forces the device to go to sleep.
 * <p>
 * Overrides all the wake locks that are held.
 * This is what happens when the power key is pressed to turn off the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to go to sleep was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the go to sleep request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to go to sleep.
 *
 * @see #userActivity
 * @see #wakeUp
 */
","/**
 * Forces the device to go to sleep.
 * <p>
 * Overrides all the wake locks that are held.
 * This is what happens when the power key is pressed to turn off the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to go to sleep was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the go to sleep request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to go to sleep.
 *
 * @see #userActivity
 * @see #wakeUp
 *
 * @removed Requires signature permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation now calls an overloaded version of goToSleep with additional parameters instead of the original single-parameter method. This indicates a dependent API has changed, so the change type is 5.","There is no direct compatibility issue as the method signature remains unchanged and it's an internal call to another method within the API. Therefore, the call should be handled within the class and should not affect the callers of the goToSleep(long) method. Hence, the CI type is 0."
170,<android.content.res.Resources: TypedArray obtainTypedArray(int)>,20,21,<android.content.res.Resources: TypedArray obtainTypedArray(int)>,<android.content.res.Resources: TypedArray obtainTypedArray(int)>,0,"{
    int len = mAssets.getArraySize(id);
    if (len < 0) {
        throw new NotFoundException(""Array resource ID #0x"" + Integer.toHexString(id));
    }
    TypedArray array = getCachedStyledAttributes(len);
    array.mLength = mAssets.retrieveArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}","{
    int len = mAssets.getArraySize(id);
    if (len < 0) {
        throw new NotFoundException(""Array resource ID #0x"" + Integer.toHexString(id));
    }
    TypedArray array = TypedArray.obtain(this, len);
    array.mLength = mAssets.retrieveArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}",1,"/**
 * Return an array of heterogeneous values.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the array values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 */
","/**
 * Return an array of heterogeneous values.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the array values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method used to obtain `TypedArray` instance has changed from `getCachedStyledAttributes(len)` to `TypedArray.obtain(this, len)`. This represents a change in the dependent API, thus the code change types are 4,5.","Since there is a change in how the `TypedArray` instance is obtained, it could potentially affect the returned `TypedArray` object, therefore a compatibility issue could arise due to a different return value, making the CI type 1."
171,<android.os.Process: int myTid()>,20,21,<android.os.Process: int myTid()>,<android.os.Process: int myTid()>,0,"{
    return Libcore.os.gettid();
}","{
    return Os.gettid();
}",1,"/**
 * Returns the identifier of the calling thread, which be used with
 * {@link #setThreadPriority(int, int)}.
 */
","/**
 * Returns the identifier of the calling thread, which be used with
 * {@link #setThreadPriority(int, int)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to get the thread ID has changed from 'Libcore.os.gettid()' to 'Os.gettid()', so the code change type is 5 due to the change involving a dependent API.","There is no indication that the behavior of the method 'Os.gettid()' should be different from 'Libcore.os.gettid()', as they are presumably designed to provide the same functionality. Hence, this change does not introduce a compatibility issue, as long as 'gettid()' method of 'Os' directly replaces 'Libcore.os.gettid()' with the same behavior. Therefore, the CI type is 0."
174,"<android.os.MessageQueue: void removeMessages(Handler,Runnable,Object)>",20,21,"<android.os.MessageQueue: void removeMessages(Handler,Runnable,Object)>","<android.os.MessageQueue: void removeMessages(Handler,Runnable,Object)>",0,"{
    if (h == null || r == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && p.callback == r && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycle();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && n.callback == r && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycle();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}","{
    if (h == null || r == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && p.callback == r && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycleUnchecked();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && n.callback == r && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycleUnchecked();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only changes are method calls from `p.recycle()` to `p.recycleUnchecked()` and `n.recycle()` to `n.recycleUnchecked()`. These changes are inside the body of the loops that remove messages and constitute a dependent API change (5). Additionally, this is not a return statement, exception handling statement, or control statement change, so we classify it as other statement changed (4).","Since the signature and the logic of the method have not changed, and recycleUnchecked() is presumably a variant of recycle() that should perform the same role in the context of this method with possibly less checking, there should be no Compatibility Issue that affects the functionality from the perspective of the API user. Thus, the pred_CI is 0."
176,<android.view.TextureView: Bitmap getBitmap(Bitmap)>,20,21,<android.view.TextureView: Bitmap getBitmap(Bitmap)>,<android.view.TextureView: Bitmap getBitmap(Bitmap)>,0,"{
    if (bitmap != null && isAvailable()) {
        AttachInfo info = mAttachInfo;
        if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled()) {
            if (!info.mHardwareRenderer.validate()) {
                throw new IllegalStateException(""Could not acquire hardware rendering context"");
            }
        }
        applyUpdate();
        applyTransformMatrix();
        // this method
        if (mLayer == null && mUpdateSurface) {
            getHardwareLayer();
        }
        if (mLayer != null) {
            mLayer.copyInto(bitmap);
        }
    }
    return bitmap;
}","{
    if (bitmap != null && isAvailable()) {
        applyUpdate();
        applyTransformMatrix();
        // this method
        if (mLayer == null && mUpdateSurface) {
            getHardwareLayer();
        }
        if (mLayer != null) {
            mLayer.copyInto(bitmap);
        }
    }
    return bitmap;
}",1,"/**
 * <p>Copies the content of this view's surface texture into the specified
 * bitmap. If the surface texture is not available, the copy is not executed.
 * The content of the surface texture will be scaled to fit exactly inside
 * the specified bitmap.</p>
 *
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 *
 * <p>If an error occurs, the bitmap is left unchanged.</p>
 *
 * @param bitmap The bitmap to copy the content of the surface texture into,
 * cannot be null, all configurations are supported
 *
 * @return The bitmap specified as a parameter
 *
 * @see #isAvailable()
 * @see #getBitmap(int, int)
 * @see #getBitmap()
 *
 * @throws IllegalStateException if the hardware rendering context cannot be
 * acquired to capture the bitmap
 */
","/**
 * <p>Copies the content of this view's surface texture into the specified
 * bitmap. If the surface texture is not available, the copy is not executed.
 * The content of the surface texture will be scaled to fit exactly inside
 * the specified bitmap.</p>
 *
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 *
 * <p>If an error occurs, the bitmap is left unchanged.</p>
 *
 * @param bitmap The bitmap to copy the content of the surface texture into,
 * cannot be null, all configurations are supported
 *
 * @return The bitmap specified as a parameter
 *
 * @see #isAvailable()
 * @see #getBitmap(int, int)
 * @see #getBitmap()
 *
 * @throws IllegalStateException if the hardware rendering context cannot be
 * acquired to capture the bitmap
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency related to checking the hardware renderer and throwing an exception if not valid has been removed. Also, a block of code related to validating and throwing an exception for the hardware rendering context has been removed, so the change types are 3 (Control dependency change) and 4 (Other statement changed).","Even though there is a change in the implementation, it doesn’t lead to a Compatibility Issue according to the definitions provided; the return value of the `getBitmap` method remains the same, and no new exceptions are thrown or caught. The removal of the validity check for the hardware renderer does not affect the return value nor does it introduce a change in the exceptions that could be thrown by the method; hence, there is no CI."
177,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",20,21,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>","<android.view.View: boolean draw(Canvas,ViewGroup,long)>",0,"{
    boolean useDisplayListProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) == PFLAG3_VIEW_IS_ANIMATING_TRANSFORM && mDisplayList != null) {
            // No longer animating: clear out old animation matrix
            mDisplayList.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!useDisplayListProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    useDisplayListProperties &= hasDisplayList;
    if (useDisplayListProperties) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
            useDisplayListProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!useDisplayListProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!useDisplayListProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (useDisplayListProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = useDisplayListProperties ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (useDisplayListProperties) {
                        displayList.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !useDisplayListProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (useDisplayListProperties) {
                        displayList.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && !useDisplayListProperties && cache == null) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (!useDisplayListProperties && hasDisplayList) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !useDisplayListProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            if (alpha < 1) {
                cachePaint.setAlpha((int) (alpha * 255));
                parent.mGroupFlags |= ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                cachePaint.setAlpha(255);
                parent.mGroupFlags &= ~ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    boolean usingRenderNodeProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!usingRenderNodeProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (usingRenderNodeProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (usingRenderNodeProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    usingRenderNodeProperties &= hasDisplayList;
    if (usingRenderNodeProperties) {
        renderNode = getDisplayList();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            hasDisplayList = false;
            usingRenderNodeProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!usingRenderNodeProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!usingRenderNodeProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (usingRenderNodeProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = usingRenderNodeProperties ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (usingRenderNodeProperties) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !usingRenderNodeProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (usingRenderNodeProperties) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + (mRight - mLeft), scrollY + (mBottom - mTop), multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!usingRenderNodeProperties) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!usingRenderNodeProperties && hasDisplayList) {
        renderNode = getDisplayList();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !usingRenderNodeProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                int restoreAlpha = mLayerPaint.getAlpha();
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                mLayerPaint.setAlpha(restoreAlpha);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                    if (mOverlay != null && !mOverlay.isEmpty()) {
                        mOverlay.getOverlayView().draw(canvas);
                    }
                } else {
                    draw(canvas);
                }
                drawAccessibilityFocus(canvas);
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawRenderNode(renderNode, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        int restoreAlpha = 0;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
        } else {
            cachePaint = mLayerPaint;
            restoreAlpha = mLayerPaint.getAlpha();
        }
        cachePaint.setAlpha((int) (alpha * 255));
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        cachePaint.setAlpha(restoreAlpha);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
178,<android.os.Bundle: ArrayList<Integer> getIntegerArrayList(String)>,20,21,<android.os.Bundle: ArrayList<Integer> getIntegerArrayList(String)>,<android.os.Bundle: ArrayList<Integer> getIntegerArrayList(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<Integer>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""ArrayList<Integer>"", e);
        return null;
    }
}","{
    return super.getIntegerArrayList(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method's implementation has changed to call the superclass method super.getIntegerArrayList(key), which indicates a change in the dependency. Hence, the code change type is 5.","There is no Compatibility Issue because the superclass's getIntegerArrayList(String) method is expected to perform the same logic that was explicitly implemented in the early version of the API. The behavior of the API should remain consistent as long as the superclass method adheres to the contract of returning an ArrayList<Integer> associated with the specified key or null if none. Therefore, this change does not lead to CI."
183,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",20,21,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = mountSecureContainer(id, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = encryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = changeEncryptionPassword(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                StorageVolume[] result = getVolumeList();
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mkdirs:
            {
                data.enforceInterface(DESCRIPTOR);
                String callingPkg = data.readString();
                String path = data.readString();
                int result = mkdirs(callingPkg, path);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}","{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean readOnly;
                readOnly = data.readInt() != 0;
                int resultCode = mountSecureContainer(id, key, ownerUid, readOnly);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = encryptStorage(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = changeEncryptionPassword(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                StorageVolume[] result = getVolumeList();
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mkdirs:
            {
                data.enforceInterface(DESCRIPTOR);
                String callingPkg = data.readString();
                String path = data.readString();
                int result = mkdirs(callingPkg, path);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPasswordType:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getPasswordType();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String result = getPassword();
                reply.writeNoException();
                reply.writeString(result);
                return true;
            }
        case TRANSACTION_clearPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                clearPassword();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = data.readString();
                setField(field, contents);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = getField(field);
                reply.writeNoException();
                reply.writeString(contents);
                return true;
            }
        case TRANSACTION_resizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String key;
                key = data.readString();
                int resultCode = resizeSecureContainer(id, sizeMb, key);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
184,<android.service.notification.StatusBarNotification: StatusBarNotification clone()>,20,21,<android.service.notification.StatusBarNotification: StatusBarNotification clone()>,<android.service.notification.StatusBarNotification: StatusBarNotification clone()>,0,"{
    return new StatusBarNotification(this.pkg, this.basePkg, this.id, this.tag, this.uid, this.initialPid, this.score, this.notification.clone(), this.user, this.postTime);
}","{
    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, this.score, this.notification.clone(), this.user, this.postTime);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The constructor parameter has changed from this.basePkg to this.opPkg. While this indicates a change in the dependency (other object's field is used), it does not affect the method's control flow, return type, or exception handling directly. Thus the change is 4 for other statement changed, and 5 for dependent API changed.","There's no Compatibility Issue in terms of differing return values or exception behavior, as the constructor's signature stays the same and assumes that the new field 'this.opPkg' is intended to have the same type and act as a direct replacement for 'this.basePkg'. The code change indicates an internal detail modification rather than an interface alteration that affects backward compatibility. Hence, the CI type is 0."
186,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,20,21,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,0,"{
    if (eventType == TYPES_ALL_MASK) {
        return ""TYPES_ALL_MASK"";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_LONG_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SELECTED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_ENTER"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_EXIT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_NOTIFICATION_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_CONTENT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_SELECTION_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SCROLLED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_ANNOUNCEMENT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_END"");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}","{
    if (eventType == TYPES_ALL_MASK) {
        return ""TYPES_ALL_MASK"";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_LONG_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SELECTED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_ENTER"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_EXIT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_NOTIFICATION_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_CONTENT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_SELECTION_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SCROLLED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_ANNOUNCEMENT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOWS_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOWS_CHANGED"");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}",1,"/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
","/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
187,<android.os.Bundle: char[] getCharArray(String)>,20,21,<android.os.Bundle: char[] getCharArray(String)>,<android.os.Bundle: char[] getCharArray(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (char[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""char[]"", e);
        return null;
    }
}","{
    return super.getCharArray(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a char[] value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a char[] value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The late version implementation calls a different method (super.getCharArray(key)) instead of using the previous implementation with internal logic, so the code change type is 5.","Since there is no indication of changes to the behavior of the super.getCharArray(key) method compared to the original logic, and it is assumed that the superclass method is correctly returning a char array for the given key or null if not present, this change does not suggest any difference in the return value or type, and thus does not lead to a CI. Therefore, the CI type is 0."
188,<android.app.backup.BackupManager: void dataChanged(String)>,20,21,<android.app.backup.BackupManager: void dataChanged(String)>,<android.app.backup.BackupManager: void dataChanged(String)>,0,"{
    checkServiceBinder();
    if (sService != null) {
        try {
            sService.dataChanged(packageName);
        } catch (RemoteException e) {
            Log.d(TAG, ""dataChanged(pkg) couldn't connect"");
        }
    }
}","{
    checkServiceBinder();
    if (sService != null) {
        try {
            sService.dataChanged(packageName);
        } catch (RemoteException e) {
            Log.e(TAG, ""dataChanged(pkg) couldn't connect"");
        }
    }
}",1,"/**
 * Convenience method for callers who need to indicate that some other package
 * needs a backup pass.  This can be useful in the case of groups of packages
 * that share a uid.
 * <p>
 * This method requires that the application hold the ""android.permission.BACKUP""
 * permission if the package named in the argument does not run under the same uid
 * as the caller.
 *
 * @param packageName The package name identifying the application to back up.
 */
","/**
 * Convenience method for callers who need to indicate that some other package
 * needs a backup pass.  This can be useful in the case of groups of packages
 * that share a uid.
 * <p>
 * This method requires that the application hold the ""android.permission.BACKUP""
 * permission if the package named in the argument does not run under the same uid
 * as the caller.
 *
 * @param packageName The package name identifying the application to back up.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The logging level in the catch block has changed from Log.d (debug) to Log.e (error), which is not related to the return value or the exceptions thrown by the method. Therefore, the change type is 4.","The change is only in the logging level and does not affect the method’s behavior from an API consumer perspective. So, there is no Compatibility Issue, and the CI type is 0."
189,<android.print.PrintDocumentInfo.Builder: Builder setPageCount(int)>,20,21,<android.print.PrintDocumentInfo.Builder: Builder setPageCount(int)>,<android.print.PrintDocumentInfo.Builder: Builder setPageCount(int)>,0,"{
    if (pageCount < 0 && pageCount != PAGE_COUNT_UNKNOWN) {
        throw new IllegalArgumentException(""pageCount"" + "" must be greater than or euqal to zero or"" + "" DocumentInfo#PAGE_COUNT_UNKNOWN"");
    }
    mPrototype.mPageCount = pageCount;
    return this;
}","{
    if (pageCount < 0 && pageCount != PAGE_COUNT_UNKNOWN) {
        throw new IllegalArgumentException(""pageCount"" + "" must be greater than or equal to zero or"" + "" DocumentInfo#PAGE_COUNT_UNKNOWN"");
    }
    mPrototype.mPageCount = pageCount;
    return this;
}",1,"/**
 * Sets the total number of pages.
 * <p>
 * <strong>Default: </strong> {@link #PAGE_COUNT_UNKNOWN}
 * </p>
 *
 * @param pageCount The number of pages. Must be greater than
 * or equal to zero or {@link PrintDocumentInfo#PAGE_COUNT_UNKNOWN}.
 */
","/**
 * Sets the total number of pages.
 * <p>
 * <strong>Default: </strong> {@link #PAGE_COUNT_UNKNOWN}
 * </p>
 *
 * @param pageCount The number of pages. Must be greater than
 * or equal to zero or {@link PrintDocumentInfo#PAGE_COUNT_UNKNOWN}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no difference between the early implementation and the late implementation of the method.,"Since there is no code change, there is no Compatibility Issue."
190,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,20,21,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,0,"{
    return getRunningTasks(maxNum, 0, null);
}","{
    try {
        return ActivityManagerNative.getDefault().getTasks(maxNum, 0);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}",1,"/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 *
 * @throws SecurityException Throws SecurityException if the caller does
 * not hold the {@link android.Manifest.permission#GET_TASKS} permission.
 */
","/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still retu rn a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The method implementation has changed significantly from getRunningTasks(maxNum, 0, null) to calling a different method ActivityManagerNative.getDefault().getTasks(maxNum, 0), and a new exception handling block is introduced. So, the change types are 1,2 (for a new return statement of 'null' and exception handling) and 5 (for calling a different method).","The late version introduces a try-catch block with a new return statement that returns 'null' when encountering a RemoteException, unlike the early version. This leads to a potential different return value. Additionally, there is a potential different exception handling as the early version does not catch RemoteExceptions and this could cause different behaviors when exceptions are thrown. Thus, the CI type is 1,2."
191,"<android.net.nsd.NsdManager: void registerService(NsdServiceInfo,int,RegistrationListener)>",20,21,"<android.net.nsd.NsdManager: void registerService(NsdServiceInfo,int,RegistrationListener)>","<android.net.nsd.NsdManager: void registerService(NsdServiceInfo,int,RegistrationListener)>",0,"{
    if (TextUtils.isEmpty(serviceInfo.getServiceName()) || TextUtils.isEmpty(serviceInfo.getServiceType())) {
        throw new IllegalArgumentException(""Service name or type cannot be empty"");
    }
    if (serviceInfo.getPort() <= 0) {
        throw new IllegalArgumentException(""Invalid port number"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    if (protocolType != PROTOCOL_DNS_SD) {
        throw new IllegalArgumentException(""Unsupported protocol"");
    }
    mAsyncChannel.sendMessage(REGISTER_SERVICE, 0, putListener(listener, serviceInfo), serviceInfo);
}","{
    if (TextUtils.isEmpty(serviceInfo.getServiceName()) || TextUtils.isEmpty(serviceInfo.getServiceType())) {
        throw new IllegalArgumentException(""Service name or type cannot be empty"");
    }
    if (serviceInfo.getPort() <= 0) {
        throw new IllegalArgumentException(""Invalid port number"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    if (protocolType != PROTOCOL_DNS_SD) {
        throw new IllegalArgumentException(""Unsupported protocol"");
    }
    int key = putListener(listener, serviceInfo);
    if (key == BUSY_LISTENER_KEY) {
        throw new IllegalArgumentException(""listener already in use"");
    }
    mAsyncChannel.sendMessage(REGISTER_SERVICE, 0, key, serviceInfo);
}",1,"/**
 * Register a service to be discovered by other services.
 *
 * <p> The function call immediately returns after sending a request to register service
 * to the framework. The application is notified of a success to initiate
 * discovery through the callback {@link RegistrationListener#onServiceRegistered} or a failure
 * through {@link RegistrationListener#onRegistrationFailed}.
 *
 * @param serviceInfo The service being registered
 * @param protocolType The service discovery protocol
 * @param listener The listener notifies of a successful registration and is used to
 * unregister this service through a call on {@link #unregisterService}. Cannot be null.
 */
","/**
 * Register a service to be discovered by other services.
 *
 * <p> The function call immediately returns after sending a request to register service
 * to the framework. The application is notified of a successful registration
 * through the callback {@link RegistrationListener#onServiceRegistered} or a failure
 * through {@link RegistrationListener#onRegistrationFailed}.
 *
 * <p> The application should call {@link #unregisterService} when the service
 * registration is no longer required, and/or whenever the application is stopped.
 *
 * @param serviceInfo The service being registered
 * @param protocolType The service discovery protocol
 * @param listener The listener notifies of a successful registration and is used to
 * unregister this service through a call on {@link #unregisterService}. Cannot be null.
 * Cannot be in use for an active service registration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4","1,2","A new exception handling statement has been introduced to check if the 'key' equals 'BUSY_LISTENER_KEY', and it throws a new IllegalArgumentException if true, alongside changes in the statement that sends the message. Hence, the code changed type is both 1 and 4.","The new exception handling could potentially lead to a different exception being thrown if the 'key' is equal to 'BUSY_LISTENER_KEY', which was not checked in the early version. Moreover, since the message sending now uses 'key' instead of a constructed object from the 'putListener()' function which can affect the message content being sent, it can fall into a different return type or value scenario. So the CI type is 1,2."
193,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,20,21,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,0,"{
    synchronized (mIMM.mH) {
        ViewRootImpl viewRootImpl = mTargetView != null ? mTargetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mIMM.mServedView != null) {
                viewRootImpl = mIMM.mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
    return false;
}","{
    synchronized (mIMM.mH) {
        ViewRootImpl viewRootImpl = mTargetView != null ? mTargetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mIMM.mServedView != null) {
                viewRootImpl = mIMM.mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
    mIMM.notifyUserAction();
    return false;
}",1,"/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */
","/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional method call mIMM.notifyUserAction() has been introduced, which does not affect the return value or the exceptions thrown by this method, hence the code change type is 4.","There is no change in the return value or exception handling of the method. The additional call to mIMM.notifyUserAction() likely relates to internal state modification or logging, and thus does not introduce a compatibility issue as per the available information. Therefore, there is no compatibility issue, and the CI type is 0."
195,<android.app.TimePickerDialog: Bundle onSaveInstanceState()>,20,21,<android.app.TimePickerDialog: Bundle onSaveInstanceState()>,<android.app.TimePickerDialog: Bundle onSaveInstanceState()>,0,"{
    Bundle state = super.onSaveInstanceState();
    state.putInt(HOUR, mTimePicker.getCurrentHour());
    state.putInt(MINUTE, mTimePicker.getCurrentMinute());
    state.putBoolean(IS_24_HOUR, mTimePicker.is24HourView());
    return state;
}","{
    final Bundle state = super.onSaveInstanceState();
    state.putInt(HOUR, mTimePicker.getCurrentHour());
    state.putInt(MINUTE, mTimePicker.getCurrentMinute());
    state.putBoolean(IS_24_HOUR, mTimePicker.is24HourView());
    return state;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,The only change found is in the declaration of the `state` variable being declared as final in the late version. This does not impact the behavior of the method and no other changes are present in the code.,"There is no compatibility issue since there is no change in the logic or return value of the method, and the method's behavior remains the same."
196,"<android.app.Activity: View onCreateView(View,String,Context,AttributeSet)>",20,21,"<android.app.Activity: View onCreateView(View,String,Context,AttributeSet)>","<android.app.Activity: View onCreateView(View,String,Context,AttributeSet)>",0,"{
    if (!""fragment"".equals(name)) {
        return onCreateView(name, context, attrs);
    }
    String fname = attrs.getAttributeValue(null, ""class"");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Must specify unique android:id, android:tag, or have a parent with an id for "" + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? mFragments.findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = mFragments.findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = mFragments.findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, ""onCreateView: id=0x"" + Integer.toHexString(id) + "" fname="" + fname + "" existing="" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(this, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = mFragments;
        fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        mFragments.addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Duplicate id 0x"" + Integer.toHexString(id) + "", tag "" + tag + "", or parent id 0x"" + Integer.toHexString(containerId) + "" with another fragment for "" + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        }
        mFragments.moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException(""Fragment "" + fname + "" did not create a view."");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}","{
    if (!""fragment"".equals(name)) {
        return onCreateView(name, context, attrs);
    }
    return mFragments.onCreateView(parent, name, context, attrs);
}",1,"/**
 * Standard implementation of
 * {@link android.view.LayoutInflater.Factory2#onCreateView(View, String, Context, AttributeSet)}
 * used when inflating with the LayoutInflater returned by {@link #getSystemService}.
 * This implementation handles <fragment> tags to embed fragments inside
 * of the activity.
 *
 * @see android.view.LayoutInflater#createView
 * @see android.view.Window#getLayoutInflater
 */
","/**
 * Standard implementation of
 * {@link android.view.LayoutInflater.Factory2#onCreateView(View, String, Context, AttributeSet)}
 * used when inflating with the LayoutInflater returned by {@link #getSystemService}.
 * This implementation handles <fragment> tags to embed fragments inside
 * of the activity.
 *
 * @see android.view.LayoutInflater#createView
 * @see android.view.Window#getLayoutInflater
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The late version has completely refactored and simplified the implementation of the method, moving the logic to `mFragments.onCreateView(parent, name, context, attrs);`. These changes include the elimination of local processing, exception handling, and control flow. The code change falls into categories 1, 3, 4, and 5, as it completely changes all return statements, modifies control dependencies, introduces new other statements, and relies on a changed implementation of a dependent API (`mFragments.onCreateView` instead of the previous local implementation).","Due to the changed implementation and reliance on a different method within a dependent API for creating a view, a Compatibility Issue is present as return values or types may potentially differ. The processing of attributes, fragment retrieval, and exception handling has moved to another method, which might create views differently or handle exceptions in a different way than the prior version. The CI type is 1 because these changes can lead to the API returning a different value."
197,<android.os.Process: int myUid()>,20,21,<android.os.Process: int myUid()>,<android.os.Process: int myUid()>,0,"{
    return Libcore.os.getuid();
}","{
    return Os.getuid();
}",1,"/**
 * Returns the identifier of this process's uid.  This is the kernel uid
 * that the process is running under, which is the identity of its
 * app-specific sandbox.  It is different from {@link #myUserHandle} in that
 * a uid identifies a specific app sandbox in a specific user.
 */
","/**
 * Returns the identifier of this process's uid.  This is the kernel uid
 * that the process is running under, which is the identity of its
 * app-specific sandbox.  It is different from {@link #myUserHandle} in that
 * a uid identifies a specific app sandbox in a specific user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from calling Libcore.os.getuid() to Os.getuid(). There is a change in the dependent API, so the code change type is 5.","Despite changing the dependency from Libcore.os.getuid() to Os.getuid(), the behavior of the API as it relates to what the method is expected to return, namely the UID of the process, remains consistent. There is no compatibility issue as the return value remains the same, thus CI type is 0."
198,"<android.view.GLES20Canvas: void drawText(char[],int,int,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawText(char[],int,int,float,float,Paint)>","<android.view.GLES20Canvas: void drawText(char[],int,int,float,float,Paint)>",0,"{
    if ((index | count | (index + count) | (text.length - index - count)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, index, count, x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if ((index | count | (index + count) | (text.length - index - count)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    nDrawText(mRenderer, text, index, count, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation has been changed by removing the setup of modifiers (`int modifiers = setupModifiers(paint);`) and the accompanying try-finally block. Moreover, there is a simplification involving directly calling `nDrawText` without setting up or resetting modifiers, and adding `paint.mNativeTypeface` as an additional parameter. Thus, the code change type is 1 for the removed return inside the finally block and 4 for other changes that do not fall under the return, exception handling, control flow, and dependent API changes.","The removal of the try-finally block and the related modifiers setup and reset can alter the behavior of the API, potentially causing the method to behave differently than before. This change might affect the appearance of the text drawn by this method. Therefore, we classify this as a compatibility issue type 1, which is caused by potential different return values or types, considering that the output of the drawing (though not a direct return value) can be perceived as the ""result"" of this void method."
199,"<android.content.res.XmlBlock.Parser: boolean getAttributeBooleanValue(int,boolean)>",20,21,"<android.content.res.XmlBlock.Parser: boolean getAttributeBooleanValue(int,boolean)>","<android.content.res.XmlBlock.Parser: boolean getAttributeBooleanValue(int,boolean)>",0,"{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on appt doing the conversion for us.
    if (t >= TypedValue.TYPE_FIRST_INT && t <= TypedValue.TYPE_LAST_INT) {
        return nativeGetAttributeData(mParseState, idx) != 0;
    }
    return defaultValue;
}","{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on aapt doing the conversion for us.
    if (t >= TypedValue.TYPE_FIRST_INT && t <= TypedValue.TYPE_LAST_INT) {
        return nativeGetAttributeData(mParseState, idx) != 0;
    }
    return defaultValue;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the API implementation between the early version and the late version.,"As there is no change, no Compatibility Issue will arise."
200,<android.widget.Editor.ActionPopupWindow: int clipVertically(int)>,20,21,<android.widget.Editor.ActionPopupWindow: int clipVertically(int)>,<android.widget.Editor.ActionPopupWindow: int clipVertically(int)>,0,"{
    if (positionY < 0) {
        final int offset = getTextOffset();
        final Layout layout = mTextView.getLayout();
        final int line = layout.getLineForOffset(offset);
        positionY += layout.getLineBottom(line) - layout.getLineTop(line);
        positionY += mContentView.getMeasuredHeight();
        // Assumes insertion and selection handles share the same height
        final Drawable handle = mTextView.getResources().getDrawable(mTextView.mTextSelectHandleRes);
        positionY += handle.getIntrinsicHeight();
    }
    return positionY;
}","{
    if (positionY < 0) {
        final int offset = getTextOffset();
        final Layout layout = mTextView.getLayout();
        final int line = layout.getLineForOffset(offset);
        positionY += layout.getLineBottom(line) - layout.getLineTop(line);
        positionY += mContentView.getMeasuredHeight();
        // Assumes insertion and selection handles share the same height
        final Drawable handle = mTextView.getContext().getDrawable(mTextView.mTextSelectHandleRes);
        positionY += handle.getIntrinsicHeight();
    }
    return positionY;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change is how the `Drawable handle` is obtained. In the early version, it uses `mTextView.getResources().getDrawable()`, while in the late version it uses `mTextView.getContext().getDrawable()`. This change indicates that the method for obtaining resources has been altered, which corresponds to a dependent API change, so the code change type is 5.","Since the overall logic and return statement of the method did not change and the purpose of the changed line was just to obtain a resource, as long as the resource `mTextView.mTextSelectHandleRes` remains the same across both contexts (`Resources` and `Context`), the API should behave identically in terms of what it returns. Hence, no compatibility issue is detected."
202,"<android.app.ApplicationPackageManager: ProviderInfo resolveContentProvider(String,int)>",20,21,"<android.app.ApplicationPackageManager: ProviderInfo resolveContentProvider(String,int)>","<android.app.ApplicationPackageManager: ProviderInfo resolveContentProvider(String,int)>",0,"{
    try {
        return mPM.resolveContentProvider(name, flags, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    return resolveContentProviderAsUser(name, flags, mContext.getUserId());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation directly calls a method from mPM with a try-catch block, but the late implementation calls a different method resolveContentProviderAsUser(). This change in the API used for resolving the content provider suggests there's a code change type of 1 due to the different return statement, and 5 because the dependent API has changed.","Since there's a change in the API used to get the result, the returned ProviderInfo may be different, causing a potential Compatibility Issue of type 1 due to the possibility of different return values."
203,<android.os.Bundle: void readFromParcel(Parcel)>,20,21,<android.os.Bundle: void readFromParcel(Parcel)>,<android.os.Bundle: void readFromParcel(Parcel)>,0,"{
    int length = parcel.readInt();
    if (length < 0) {
        throw new RuntimeException(""Bad length in parcel: "" + length);
    }
    readFromParcelInner(parcel, length);
}","{
    super.readFromParcelInner(parcel);
    mHasFds = mParcelledData.hasFileDescriptors();
    mFdsKnown = true;
}",1,"/**
 * Reads the Parcel contents into this Bundle, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */
","/**
 * Reads the Parcel contents into this Bundle, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",2,The method has changed significantly and includes the following:,"- The entire logic with the 'length' check and exception throwing has been removed, which can be regarded as 'return statement changed' since it affects the final outcome of the method."
204,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,20,21,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    /*
         * Don't try to intercept touch if we can't scroll anyway.
         */
    if (getScrollY() == 0 && !canScrollVertically(1)) {
        return false;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int y = (int) ev.getY(pointerIndex);
                final int yDiff = Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int y = (int) ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    /*
         * Don't try to intercept touch if we can't scroll anyway.
         */
    if (getScrollY() == 0 && !canScrollVertically(1)) {
        return false;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int y = (int) ev.getY(pointerIndex);
                final int yDiff = Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    mNestedYOffset = 0;
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int y = (int) ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                postInvalidateOnAnimation();
            }
            stopNestedScroll();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
206,"<android.hardware.camera2.utils.CameraBinderDecorator.CameraBinderDecoratorListener: boolean onCatchException(Method,Object[],Throwable)>",20,21,"<android.hardware.camera2.utils.CameraBinderDecorator.CameraBinderDecoratorListener: boolean onCatchException(Method,Object[],Throwable)>","<android.hardware.camera2.utils.CameraBinderDecorator.CameraBinderDecoratorListener: boolean onCatchException(Method,Object[],Throwable)>",0,"{
    if (t instanceof DeadObjectException) {
        UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED, ""Process hosting the camera service has died unexpectedly"", t));
    } else if (t instanceof RemoteException) {
        throw new UnsupportedOperationException(""An unknown RemoteException was thrown"" + "" which should never happen."", t);
    }
    return false;
}","{
    if (t instanceof DeadObjectException) {
        throw new CameraRuntimeException(CAMERA_DISCONNECTED, ""Process hosting the camera service has died unexpectedly"", t);
    } else if (t instanceof RemoteException) {
        throw new UnsupportedOperationException(""An unknown RemoteException was thrown"" + "" which should never happen."", t);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,2,"The method used to throw the exception changed from UncheckedThrow.throwAnyException(...) to a simple throw statement. This modification affects the way exceptions are thrown even though the type of exception remains the same, hence the change type is 4. ","The change in exception throwing mechanism constitutes a different exception handling behavior. While the exception type remains the same, the change in the propagation of the exception (from using a utility method to direct throwing) could affect the caller differently, especially if there are any subtle differences in the stack trace or exception handling upstream. Therefore, the CI type is 2."
207,"<android.view.GLES20Canvas: void drawPath(Path,Paint)>",20,21,"<android.view.GLES20Canvas: void drawPath(Path,Paint)>","<android.view.GLES20Canvas: void drawPath(Path,Paint)>",0,"{
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        if (path.isSimplePath) {
            if (path.rects != null) {
                nDrawRects(mRenderer, path.rects.mNativeRegion, paint.mNativePaint);
            }
        } else {
            nDrawPath(mRenderer, path.mNativePath, paint.mNativePaint);
        }
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (path.isSimplePath) {
        if (path.rects != null) {
            nDrawRects(mRenderer, path.rects.mNativeRegion, paint.mNativePaint);
        }
    } else {
        nDrawPath(mRenderer, path.mNativePath, paint.mNativePaint);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",0,"The try-finally block and the invocation of setupModifiers() and nResetModifiers() have been removed, so the change type is 2 (exception handling statement changed) as the try-finally block is related to exception handling and 4 (other statement changed) for the removal of method calls.","These changes do not introduce a potential Compatibility Issue because there has been no alteration to the flow that determines the return value or exception thrown by the method. The method's signature remains the same and it continues to not return any value (void method). Furthermore, since the previous implementation does not throw any checked exception, the removal of the try-finally block does not result in a different exception handling behavior for the client. Therefore, no Compatibility Issue is detected."
208,<android.app.ApplicationPackageManager: Drawable getApplicationIcon(String)>,20,21,<android.app.ApplicationPackageManager: Drawable getApplicationIcon(String)>,<android.app.ApplicationPackageManager: Drawable getApplicationIcon(String)>,0,"{
    return getApplicationIcon(getApplicationInfo(packageName, 0));
}","{
    return getApplicationIcon(getApplicationInfo(packageName, sDefaultFlags));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change is in the argument passed to the getApplicationInfo method, which has changed from a literal 0 to a variable sDefaultFlags. The change depends on what sDefaultFlags represents, but without that context, it's classified as a dependent API change (5).","If sDefaultFlags variable results in the same value as the literal 0 used in the earlier version, there is no compatibility issue because the getApplicationInfo method would behave the same way. If, however, sDefaultFlags contains different flag values, it could potentially affect the outcome of getApplicationInfo, and hence different Drawable objects might be returned. Given we cannot determine the value of sDefaultFlags from the provided information, we cannot definitively state there is a compatibility issue based on the given code. Thus, by default, the Compatibility Issue is considered as 0."
210,<android.os.Bundle: short[] getShortArray(String)>,20,21,<android.os.Bundle: short[] getShortArray(String)>,<android.os.Bundle: short[] getShortArray(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (short[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""short[]"", e);
        return null;
    }
}","{
    return super.getShortArray(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a short[] value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a short[] value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed to call a method from its superclass with the same signature, this indicates a Dependent API changed, so the code change type is 5.","There are no compatibility issues since it calls an overridden method that's expected to provide the same functionality as the earlier implementation, transposing the logic to the superclass. Thus, the CI type is 0."
211,<android.os.Bundle: float[] getFloatArray(String)>,20,21,<android.os.Bundle: float[] getFloatArray(String)>,<android.os.Bundle: float[] getFloatArray(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (float[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""float[]"", e);
        return null;
    }
}","{
    return super.getFloatArray(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a float[] value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a float[] value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire body of the method has been replaced with a call to super.getFloatArray(key), which is a change in the dependent API, so the code change type is 1,5.","As the implementation now delegates to the superclass's method, this changes the behavior of the method potentially leading to a different return value, especially if the superclass's implementation differs from the originally inlined code. Therefore, the CI type is 1."
212,<android.os.Message: Message obtain()>,20,21,<android.os.Message: Message obtain()>,<android.os.Message: Message obtain()>,0,"{
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null;
            sPoolSize--;
            return m;
        }
    }
    return new Message();
}","{
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null;
            // clear in-use flag
            m.flags = 0;
            sPoolSize--;
            return m;
        }
    }
    return new Message();
}",1,"/**
 * Return a new Message instance from the global pool. Allows us to
 * avoid allocating new objects in many cases.
 */
","/**
 * Return a new Message instance from the global pool. Allows us to
 * avoid allocating new objects in many cases.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An assignment statement `m.flags = 0;` is introduced, which is not a change of the return or exception handling statements, so the code change type is 4.","The addition of `m.flags = 0;` would reset the flags of the Message object before it is returned to the caller. However, it does not affect the type or value of what is returned, because it is manipulating the internal state of the Message prior to returning it. Thus, it should not lead to a Compatibility Issue as far as the API's signature and contract are concerned."
214,<android.bluetooth.BluetoothAdapter: void stopLeScan(LeScanCallback)>,20,21,<android.bluetooth.BluetoothAdapter: void stopLeScan(LeScanCallback)>,<android.bluetooth.BluetoothAdapter: void stopLeScan(LeScanCallback)>,0,"{
    if (DBG)
        Log.d(TAG, ""stopLeScan()"");
    GattCallbackWrapper wrapper;
    synchronized (mLeScanClients) {
        wrapper = mLeScanClients.remove(callback);
        if (wrapper == null)
            return;
    }
    wrapper.stopLeScan();
}","{
    if (DBG)
        Log.d(TAG, ""stopLeScan()"");
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        return;
    }
    synchronized (mLeScanClients) {
        ScanCallback scanCallback = mLeScanClients.remove(callback);
        if (scanCallback == null) {
            if (DBG)
                Log.d(TAG, ""scan not started yet"");
            return;
        }
        scanner.stopScan(scanCallback);
    }
}",1,"/**
 * Stops an ongoing Bluetooth LE device scan.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param callback used to identify which scan to stop
 * must be the same handle used to start the scan
 */
","/**
 * Stops an ongoing Bluetooth LE device scan.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param callback used to identify which scan to stop
 * must be the same handle used to start the scan
 * @deprecated Use {@link BluetoothLeScanner#stopScan(ScanCallback)} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,There are multiple changes: ,- A new log statement inside the condition `if (scanCallback == null)` has been introduced.
216,<android.nfc.cardemulation.CardEmulation: CardEmulation getInstance(NfcAdapter)>,20,21,<android.nfc.cardemulation.CardEmulation: CardEmulation getInstance(NfcAdapter)>,<android.nfc.cardemulation.CardEmulation: CardEmulation getInstance(NfcAdapter)>,0,"{
    if (adapter == null)
        throw new NullPointerException(""NfcAdapter is null"");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, ""NfcAdapter context is null."");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, ""Cannot get PackageManager"");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
                Log.e(TAG, ""This device does not support card emulation"");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, ""PackageManager query failed."");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}","{
    if (adapter == null)
        throw new NullPointerException(""NfcAdapter is null"");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, ""NfcAdapter context is null."");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, ""Cannot get PackageManager"");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
                Log.e(TAG, ""This device does not support card emulation"");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, ""PackageManager query failed."");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        if (service == null) {
            Log.e(TAG, ""This device does not implement the INfcCardEmulation interface."");
            throw new UnsupportedOperationException();
        }
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}",1,"/**
 * Helper to get an instance of this class.
 *
 * @param adapter A reference to an NfcAdapter object.
 * @return
 */
","/**
 * Helper to get an instance of this class.
 *
 * @param adapter A reference to an NfcAdapter object.
 * @return
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new 'if' control structure is introduced to check if the 'service' is null, and an 'throw new UnsupportedOperationException()' statement is added in that block, so the change type is 3,4.","The late version throws a new `UnsupportedOperationException` if the `service` is null, which could lead to a different exception being thrown when the method is called, thus the CI type is 2. However, upon closer inspection, I realize that it could also lead to a different return value when the service is not null (since the previous version could potentially return a faulty manager object). Thus, the CI types should be 1,2."
218,<android.app.ApplicationPackageManager: Resources getResourcesForActivity(ComponentName)>,20,21,<android.app.ApplicationPackageManager: Resources getResourcesForActivity(ComponentName)>,<android.app.ApplicationPackageManager: Resources getResourcesForActivity(ComponentName)>,0,"{
    return getResourcesForApplication(getActivityInfo(activityName, 0).applicationInfo);
}","{
    return getResourcesForApplication(getActivityInfo(activityName, sDefaultFlags).applicationInfo);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The argument within getActivityInfo() method call has changed from a literal 0 to using sDefaultFlags variable, but there is no other change visible in the methods, so the code change type is 5.","Since only the argument of a method call has changed, without further information on whether the value represented by sDefaultFlags differs from the literal 0, it's not possible to definitively determine if a CI would occur based solely on this code snippet. Assuming sDefaultFlags is properly set to represent default flags that include the same behavior as when 0 was passed, there would be no CI, so the CI type is 0."
220,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",20,21,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>","<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",0,"{
    // TODO(Bluetooth) check whether platform support BLE
    // Do the check here or in GattServer?
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    IBluetoothManager managerService = adapter.getBluetoothManager();
    try {
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return null;
        }
        BluetoothGatt gatt = new BluetoothGatt(context, iGatt, this);
        gatt.connect(autoConnect, callback);
        return gatt;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO));
}",1,"/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
","/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The late implementation has been completely changed to call a different (overloaded) method of 'connectGatt' with an additional parameter 'TRANSPORT_AUTO', directly returning its result. Thus the original logic including error handling and object creation has been removed. Therefore, the change types are 1 (return statement changed), 4 (other statement changed, as the entire body of the method is different), and 5 (dependent API changed, because it now calls a different overload of 'connectGatt').","Since the previous method body has been replaced by a call to a different method overload that potentially returns different results and the original exception handling is removed, there is a Compatibility Issue arising from potentially different return values (CI type 1)."
222,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The code change includes removing the logic related to paint modifiers setup and reset; therefore, it falls under the types 1 and 4. Specifically, the 'modifiers' variable setup, the conditional check, and the call to 'nResetModifiers' have been removed.","There is no Compatibility Issue because, despite the change, the API still accepts the same parameters and does not modify the behavior related to exceptions, control flow, or return types. The removed code related to modifiers does not affect what the API returns nor does it change exception handling. The API performs the drawing operation as before, without the additional modifier logic, which does not affect the output from the perspective of the API's functionality."
223,<android.os.Bundle: Serializable getSerializable(String)>,20,21,<android.os.Bundle: Serializable getSerializable(String)>,<android.os.Bundle: Serializable getSerializable(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Serializable) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Serializable"", e);
        return null;
    }
}","{
    return super.getSerializable(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Serializable value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Serializable value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed completely from a specific implementation to a call to the superclass with `return super.getSerializable(key);`, indicating the method has been overridden in the late version. The control flow and the internal logic previously contained in the method are no longer present, and since there is no indication that the superclass’s `getSerializable` method behavior has changed, this is indicative of a Dependent API changed.","There is no Compatibility Issue since the method's contract appears to remain the same -- it returns a Serializable object for the given key or null. The action of retrieving the serializable from the map is just deferred to the superclass's implementation. The change to the annotation @Override typically does not affect the method's behavior and is more informational, indicating this method is implemented from an interface or overridden from a superclass. Therefore, we assume that the superclass's method behaves correctly and consistently with the previous direct implementation."
228,<android.view.MotionEvent.PointerCoords: float getAxisValue(int)>,20,21,<android.view.MotionEvent.PointerCoords: float getAxisValue(int)>,<android.view.MotionEvent.PointerCoords: float getAxisValue(int)>,0,"{
    switch(axis) {
        case AXIS_X:
            return x;
        case AXIS_Y:
            return y;
        case AXIS_PRESSURE:
            return pressure;
        case AXIS_SIZE:
            return size;
        case AXIS_TOUCH_MAJOR:
            return touchMajor;
        case AXIS_TOUCH_MINOR:
            return touchMinor;
        case AXIS_TOOL_MAJOR:
            return toolMajor;
        case AXIS_TOOL_MINOR:
            return toolMinor;
        case AXIS_ORIENTATION:
            return orientation;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException(""Axis out of range."");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 1L << axis;
                if ((bits & axisBit) == 0) {
                    return 0;
                }
                final int index = Long.bitCount(bits & (axisBit - 1L));
                return mPackedAxisValues[index];
            }
    }
}","{
    switch(axis) {
        case AXIS_X:
            return x;
        case AXIS_Y:
            return y;
        case AXIS_PRESSURE:
            return pressure;
        case AXIS_SIZE:
            return size;
        case AXIS_TOUCH_MAJOR:
            return touchMajor;
        case AXIS_TOUCH_MINOR:
            return touchMinor;
        case AXIS_TOOL_MAJOR:
            return toolMajor;
        case AXIS_TOOL_MINOR:
            return toolMinor;
        case AXIS_ORIENTATION:
            return orientation;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException(""Axis out of range."");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                if ((bits & axisBit) == 0) {
                    return 0;
                }
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                return mPackedAxisValues[index];
            }
    }
}",1,"/**
 * Gets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to retrieve.
 * @return The value associated with the axis, or 0 if none.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */
","/**
 * Gets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to retrieve.
 * @return The value associated with the axis, or 0 if none.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the default case in the switch statement has changed, involving a bitwise operation to determine axisBit and the calculation of the index. While the switch cases for defined axes have not changed, the handling of bits for custom axes (default case) has been modified. This change in implementation may affect the return value for custom axes, which is a dependent API change, and the other statement in the default case also has been modified.","Since the way custom axes values are retrieved has been altered ('axisBit' calculation and 'index' calculation), this could lead to a different return value for axes beyond the predefined ones like AXIS_X, AXIS_Y, etc. Thus, there's a potential for different return values when the axis parameter is not one of the predefined axes, making the CI type 1."
229,"<android.bluetooth.BluetoothGattServer: boolean connect(BluetoothDevice,boolean)>",20,21,"<android.bluetooth.BluetoothGattServer: boolean connect(BluetoothDevice,boolean)>","<android.bluetooth.BluetoothGattServer: boolean connect(BluetoothDevice,boolean)>",0,"{
    if (DBG)
        Log.d(TAG, ""connect() - device: "" + device.getAddress() + "", auto: "" + autoConnect);
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.serverConnect(mServerIf, device.getAddress(), // autoConnect is inverse of ""isDirect""
        autoConnect ? false : true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""connect() - device: "" + device.getAddress() + "", auto: "" + autoConnect);
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.serverConnect(mServerIf, device.getAddress(), autoConnect ? false : true, // autoConnect is inverse of ""isDirect""
        mTransport);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattServerCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect paramter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
","/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattServerCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect paramter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API called within try block, `mService.serverConnect()` has an additional parameter `mTransport` in the late version. This parameter is added at the end of the method call and does not affect the return type or the value being returned by the `connect()` method. Therefore, the code change type is 5.","The addition of a parameter to the dependent API does not inherently change the behavior of the `connect()` method. It's an internal change which is hidden from the API user as long as the contract of `serverConnect()` is the same and no exceptions other than the ones already caught are thrown. Therefore, there is no compatibility issue; the result is 0."
230,"<android.speech.tts.TextToSpeech: int playEarcon(String,int,HashMap<String, String>)>",20,21,"<android.speech.tts.TextToSpeech: int playEarcon(String,int,HashMap<String, String>)>","<android.speech.tts.TextToSpeech: int playEarcon(String,int,HashMap<String, String>)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri earconUri = mEarcons.get(earcon);
            if (earconUri == null) {
                return ERROR;
            }
            return service.playAudio(getCallerIdentity(), earconUri, queueMode, getParams(params));
        }
    }, ERROR, ""playEarcon"");
}","{
    return playEarcon(earcon, queueMode, convertParamsHashMaptoBundle(params), params == null ? null : params.get(Engine.KEY_PARAM_UTTERANCE_ID));
}",1,"/**
 * Plays the earcon using the specified queueing mode and parameters.
 * The earcon must already have been added with {@link #addEarcon(String, String)} or
 * {@link #addEarcon(String, String, int)}.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param earcon The earcon that should be played
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playEarcon operation.
 */
","/**
 * Plays the earcon using the specified queueing mode and parameters.
 * The earcon must already have been added with {@link #addEarcon(String, String)} or
 * {@link #addEarcon(String, String, int)}.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param earcon The earcon that should be played
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playEarcon operation.
 * @deprecated As of API level 21, replaced by
 * {@link #playEarcon(String, int, Bundle, String)}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has been completely replaced with a call to playEarcon() that has different parameters, which indicates that there is a change in the dependent API being used internally. Therefore, the change type is 5. ","There are no Compatibility Issues that can be inferred from this change because the method signature remains the same and the new definition of the method is not provided. Compatibility Issues would depend on whether the internal implementation of the new playEarcon() behaves differently with respect to returning different values or throwing exceptions. Without additional details on the implementation of the new playEarcon() method, it cannot be concluded that there is a Compatibility Issue solely based on the change in the method called internally."
231,<android.widget.TextView: int getExtendedPaddingBottom()>,20,21,<android.widget.TextView: int getExtendedPaddingBottom()>,<android.widget.TextView: int getExtendedPaddingBottom()>,0,"{
    if (mMaxMode != LINES) {
        return getCompoundPaddingBottom();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingBottom();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return bottom;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return bottom + viewht - layoutht;
    } else if (gravity == Gravity.BOTTOM) {
        return bottom;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return bottom + (viewht - layoutht) / 2;
    }
}","{
    if (mMaxMode != LINES) {
        return getCompoundPaddingBottom();
    }
    if (mLayout == null) {
        assumeLayout();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingBottom();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return bottom;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return bottom + viewht - layoutht;
    } else if (gravity == Gravity.BOTTOM) {
        return bottom;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return bottom + (viewht - layoutht) / 2;
    }
}",1,"/**
 * Returns the extended bottom padding of the view, including both the
 * bottom Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */
","/**
 * Returns the extended bottom padding of the view, including both the
 * bottom Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change is an additional check for mLayout and a call to assumeLayout() if mLayout is null. This is a control dependency change, so the code change type is 3.","The added condition ensures mLayout is not null before proceeding. This change is designed to enforce stability and should not affect the normal flow for existing behavior where mLayout is not null, which is the common case. Hence, there is no CI because this will not lead to any difference in return values or types, nor does it introduce new exception behavior for existing flows; only ensures proper initialization before use."
232,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,20,21,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS);
}","{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS);
}",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"There is an insertion of a new 'if' statement that checks if mChildNodeIds is null before attempting to get a child ID, which is a change in control dependency, so the code change type is 3.","The new 'if' statement that returns null early if mChildNodeIds is null could potentially lead to a different return value (null instead of the result of findAccessibilityNodeInfoByAccessibilityId), which means there is a CI type of 1 caused by potential different return values."
233,<android.print.PrintManager.PrintDocumentAdapterDelegate: void finish()>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate: void finish()>,<android.print.PrintManager.PrintDocumentAdapterDelegate: void finish()>,0,"{
    synchronized (mLock) {
        // Start not called or finish called or destroyed - nothing to do.
        if (!mStartReqeusted || mFinishRequested || mDestroyed) {
            return;
        }
        mFinishRequested = true;
        // will do the pending work.
        if (mLastLayoutSpec != null || mLastWriteSpec != null) {
            if (DEBUG) {
                Log.i(LOG_TAG, ""Waiting for current operation"");
            }
            return;
        }
        doPendingWorkLocked();
    }
}","{
    synchronized (mLock) {
        // If destroyed the handler is null.
        if (!isDestroyedLocked()) {
            mHandler.obtainMessage(MyHandler.MSG_ON_FINISH, mDocumentAdapter).sendToTarget();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control flow, logic conditions, and other statements inside the method have completely changed, which includes: 1) deleted logic conditions for early return; 2) the replacement of the mFinishRequested flag setting; 3) removal of mLastLayoutSpec and mLastWriteSpec checks; 4) removed DEBUG log message; 5) replaced the doPendingWorkLocked call with a message handling approach. Thus, all types of changes are included except for 2): 1,3,4.","The new implementation sends a message to a handler instead of directly calling doPendingWorkLocked(). This implies the behavior of the method could potentially be very different and it will not immediately execute the pending work as in the early version. Consequently, its behavior with respect to when and how the finish-related tasks are executed is altered, which results in a CI of type 1."
235,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,20,21,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            String variant = loc.getVariant();
            // Check if the language, country, variant are available, and cache
            // the available parts.
            // Note that the language is not actually set here, instead it is cached so it
            // will be associated with all upcoming utterances.
            int result = service.loadLanguage(getCallerIdentity(), language, country, variant);
            if (result >= LANG_AVAILABLE) {
                if (result < LANG_COUNTRY_VAR_AVAILABLE) {
                    variant = """";
                    if (result < LANG_COUNTRY_AVAILABLE) {
                        country = """";
                    }
                }
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
                mParams.putString(Engine.KEY_PARAM_VARIANT, variant);
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, ""setLanguage"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            String variant = loc.getVariant();
            // As of API level 21, setLanguage is implemented using setVoice.
            // (which, in the default implementation, will call loadLanguage on the service
            // interface).
            // Sanitize locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                if (result < LANG_COUNTRY_VAR_AVAILABLE) {
                    variant = """";
                    if (result < LANG_COUNTRY_AVAILABLE) {
                        country = """";
                    }
                }
                // Get the default voice for the locale.
                String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
                if (TextUtils.isEmpty(voiceName)) {
                    Log.w(TAG, ""Couldn't find the default voice for "" + language + ""/"" + country + ""/"" + variant);
                    return LANG_NOT_SUPPORTED;
                }
                // Load it.
                if (service.loadVoice(getCallerIdentity(), voiceName) == TextToSpeech.ERROR) {
                    return LANG_NOT_SUPPORTED;
                }
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, voiceName);
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
                mParams.putString(Engine.KEY_PARAM_VARIANT, variant);
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, ""setLanguage"");
}",1,"/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * This method sets the current voice to the default one for the given Locale;
 * {@link #getVoice()} can be used to retrieve it.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The call to `service.loadLanguage` has been replaced with a call to `service.isLanguageAvailable` and a new call to `service.getDefaultVoiceNameFor`. Then a condition and a new call to `service.loadVoice` has been introduced, followed by a change from setting language, country, and variant parameters to setting a voice name parameter in addition to these. The method invoked and parameters used have changed, so the code change type is 4,5.","Since there is a change in the logic of the API (from using `loadLanguage` to `isLanguageAvailable` and `getDefaultVoiceNameFor` and then potentially `loadVoice`), which can lead to a potential change in the returned value from the API (such as returning `LANG_NOT_SUPPORTED` in situations where it might have returned a positive value before), the CI type is 1."
236,<android.view.Surface: Canvas lockCanvas(Rect)>,20,21,<android.view.Surface: Canvas lockCanvas(Rect)>,<android.view.Surface: Canvas lockCanvas(Rect)>,0,"{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mLockedObject != 0) {
            // we just refuse to re-lock the Surface.
            throw new IllegalStateException(""Surface was already locked"");
        }
        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
        return mCanvas;
    }
}","{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mLockedObject != 0) {
            // we just refuse to re-lock the Surface.
            throw new IllegalArgumentException(""Surface was already locked"");
        }
        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
        return mCanvas;
    }
}",1,"/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param inOutDirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller must redraw the entire dirty region as represented
 * by the contents of the inOutDirty rectangle upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 *
 * @throws IllegalArgumentException If the inOutDirty rectangle is not valid.
 * @throws OutOfResourcesException If the canvas cannot be locked.
 */
","/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param inOutDirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller must redraw the entire dirty region as represented
 * by the contents of the inOutDirty rectangle upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 *
 * @throws IllegalArgumentException If the inOutDirty rectangle is not valid.
 * @throws OutOfResourcesException If the canvas cannot be locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The type of exception thrown has changed from IllegalStateException to IllegalArgumentException, so the code change type is 2.","The API now throws a different exception type for the same error condition, which could lead to a different exception handling behavior in the code that calls this API, and the CI type is 2."
237,<android.net.nsd.NsdServiceInfo: String toString()>,20,21,<android.net.nsd.NsdServiceInfo: String toString()>,<android.net.nsd.NsdServiceInfo: String toString()>,0,"{
    StringBuffer sb = new StringBuffer();
    sb.append(""name: "").append(mServiceName).append(""type: "").append(mServiceType).append(""host: "").append(mHost).append(""port: "").append(mPort).append(""txtRecord: "").append(mTxtRecord);
    return sb.toString();
}","{
    StringBuffer sb = new StringBuffer();
    sb.append(""name: "").append(mServiceName).append("", type: "").append(mServiceType).append("", host: "").append(mHost).append("", port: "").append(mPort);
    byte[] txtRecord = getTxtRecord();
    if (txtRecord != null) {
        sb.append("", txtRecord: "").append(new String(txtRecord, StandardCharsets.UTF_8));
    }
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The return statement has been modified, with changes to how the txtRecord is appended (including the addition of a null check and the use of a new `getTxtRecord()` method). The control flow has changed due to the addition of the `if` statement. A new dependent API, `getTxtRecord()`, is called which did not exist in the earlier version, so the change types are 1,3,5.","The API now potentially returns different values, as the txtRecord portion of the string may or may not be included based on whether `txtRecord` is null and because it is now generated from a potentially different method `getTxtRecord()`, so the CI type is 1."
238,<android.view.accessibility.AccessibilityEvent: AccessibilityRecord getRecord(int)>,20,21,<android.view.accessibility.AccessibilityEvent: AccessibilityRecord getRecord(int)>,<android.view.accessibility.AccessibilityEvent: AccessibilityRecord getRecord(int)>,0,"{
    return mRecords.get(index);
}","{
    if (mRecords == null) {
        throw new IndexOutOfBoundsException(""Invalid index "" + index + "", size is 0"");
    }
    return mRecords.get(index);
}",1,"/**
 * Gets the record at a given index.
 *
 * @param index The index.
 * @return The record at the specified index.
 */
","/**
 * Gets the record at a given index.
 *
 * @param index The index.
 * @return The record at the specified index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The introduction of a new condition check and throwing an IndexOutOfBoundsException cause the code change to be a 2,3. A new exception handling statement is introduced, which is a check for 'mRecords' being null and throwing an exception if it is true.","This change introduces a new exception that would be thrown if 'mRecords' is null, which is different from the original behavior where no such check existed, potentially causing an IndexOutOfBoundsException or a NullPointerException depending on the state of 'mRecords'. The addition of this exception handling represents a change in behavior of the API and can cause a Compatibility Issue of type 2."
240,"<android.text.method.QwertyKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>",20,21,"<android.text.method.QwertyKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>","<android.text.method.QwertyKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>",0,"{
    int selStart, selEnd;
    int pref = 0;
    if (view != null) {
        pref = TextKeyListener.getInstance().getPrefs(view.getContext());
    }
    {
        int a = Selection.getSelectionStart(content);
        int b = Selection.getSelectionEnd(content);
        selStart = Math.min(a, b);
        selEnd = Math.max(a, b);
        if (selStart < 0 || selEnd < 0) {
            selStart = selEnd = 0;
            Selection.setSelection(content, 0, 0);
        }
    }
    int activeStart = content.getSpanStart(TextKeyListener.ACTIVE);
    int activeEnd = content.getSpanEnd(TextKeyListener.ACTIVE);
    // QWERTY keyboard normal case
    int i = event.getUnicodeChar(getMetaState(content, event));
    if (!mFullKeyboard) {
        int count = event.getRepeatCount();
        if (count > 0 && selStart == selEnd && selStart > 0) {
            char c = content.charAt(selStart - 1);
            if (c == i || c == Character.toUpperCase(i) && view != null) {
                if (showCharacterPicker(view, content, c, false, count)) {
                    resetMetaState(content);
                    return true;
                }
            }
        }
    }
    if (i == KeyCharacterMap.PICKER_DIALOG_INPUT) {
        if (view != null) {
            showCharacterPicker(view, content, KeyCharacterMap.PICKER_DIALOG_INPUT, true, 1);
        }
        resetMetaState(content);
        return true;
    }
    if (i == KeyCharacterMap.HEX_INPUT) {
        int start;
        if (selStart == selEnd) {
            start = selEnd;
            while (start > 0 && selEnd - start < 4 && Character.digit(content.charAt(start - 1), 16) >= 0) {
                start--;
            }
        } else {
            start = selStart;
        }
        int ch = -1;
        try {
            String hex = TextUtils.substring(content, start, selEnd);
            ch = Integer.parseInt(hex, 16);
        } catch (NumberFormatException nfe) {
        }
        if (ch >= 0) {
            selStart = start;
            Selection.setSelection(content, selStart, selEnd);
            i = ch;
        } else {
            i = 0;
        }
    }
    if (i != 0) {
        boolean dead = false;
        if ((i & KeyCharacterMap.COMBINING_ACCENT) != 0) {
            dead = true;
            i = i & KeyCharacterMap.COMBINING_ACCENT_MASK;
        }
        if (activeStart == selStart && activeEnd == selEnd) {
            boolean replace = false;
            if (selEnd - selStart - 1 == 0) {
                char accent = content.charAt(selStart);
                int composed = event.getDeadChar(accent, i);
                if (composed != 0) {
                    i = composed;
                    replace = true;
                    dead = false;
                }
            }
            if (!replace) {
                Selection.setSelection(content, selEnd);
                content.removeSpan(TextKeyListener.ACTIVE);
                selStart = selEnd;
            }
        }
        if ((pref & TextKeyListener.AUTO_CAP) != 0 && Character.isLowerCase(i) && TextKeyListener.shouldCap(mAutoCap, content, selStart)) {
            int where = content.getSpanEnd(TextKeyListener.CAPPED);
            int flags = content.getSpanFlags(TextKeyListener.CAPPED);
            if (where == selStart && (((flags >> 16) & 0xFFFF) == i)) {
                content.removeSpan(TextKeyListener.CAPPED);
            } else {
                flags = i << 16;
                i = Character.toUpperCase(i);
                if (selStart == 0)
                    content.setSpan(TextKeyListener.CAPPED, 0, 0, Spannable.SPAN_MARK_MARK | flags);
                else
                    content.setSpan(TextKeyListener.CAPPED, selStart - 1, selStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE | flags);
            }
        }
        if (selStart != selEnd) {
            Selection.setSelection(content, selEnd);
        }
        content.setSpan(OLD_SEL_START, selStart, selStart, Spannable.SPAN_MARK_MARK);
        content.replace(selStart, selEnd, String.valueOf((char) i));
        int oldStart = content.getSpanStart(OLD_SEL_START);
        selEnd = Selection.getSelectionEnd(content);
        if (oldStart < selEnd) {
            content.setSpan(TextKeyListener.LAST_TYPED, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            if (dead) {
                Selection.setSelection(content, oldStart, selEnd);
                content.setSpan(TextKeyListener.ACTIVE, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }
        adjustMetaAfterKeypress(content);
        if ((pref & TextKeyListener.AUTO_TEXT) != 0 && mAutoText && (i == ' ' || i == '\t' || i == '\n' || i == ',' || i == '.' || i == '!' || i == '?' || i == '""' || Character.getType(i) == Character.END_PUNCTUATION) && content.getSpanEnd(TextKeyListener.INHIBIT_REPLACEMENT) != oldStart) {
            int x;
            for (x = oldStart; x > 0; x--) {
                char c = content.charAt(x - 1);
                if (c != '\'' && !Character.isLetter(c)) {
                    break;
                }
            }
            String rep = getReplacement(content, x, oldStart, view);
            if (rep != null) {
                Replaced[] repl = content.getSpans(0, content.length(), Replaced.class);
                for (int a = 0; a < repl.length; a++) content.removeSpan(repl[a]);
                char[] orig = new char[oldStart - x];
                TextUtils.getChars(content, x, oldStart, orig, 0);
                content.setSpan(new Replaced(orig), x, oldStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                content.replace(x, oldStart, rep);
            }
        }
        if ((pref & TextKeyListener.AUTO_PERIOD) != 0 && mAutoText) {
            selEnd = Selection.getSelectionEnd(content);
            if (selEnd - 3 >= 0) {
                if (content.charAt(selEnd - 1) == ' ' && content.charAt(selEnd - 2) == ' ') {
                    char c = content.charAt(selEnd - 3);
                    for (int j = selEnd - 3; j > 0; j--) {
                        if (c == '""' || Character.getType(c) == Character.END_PUNCTUATION) {
                            c = content.charAt(j - 1);
                        } else {
                            break;
                        }
                    }
                    if (Character.isLetter(c) || Character.isDigit(c)) {
                        content.replace(selEnd - 2, selEnd - 1, ""."");
                    }
                }
            }
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_DEL && (event.hasNoModifiers() || event.hasModifiers(KeyEvent.META_ALT_ON)) && selStart == selEnd) {
        // special backspace case for undoing autotext
        int consider = 1;
        if (content.getSpanEnd(TextKeyListener.LAST_TYPED) == selStart) {
            if (content.charAt(selStart - 1) != '\n')
                consider = 2;
        }
        Replaced[] repl = content.getSpans(selStart - consider, selStart, Replaced.class);
        if (repl.length > 0) {
            int st = content.getSpanStart(repl[0]);
            int en = content.getSpanEnd(repl[0]);
            String old = new String(repl[0].mText);
            content.removeSpan(repl[0]);
            // itself).
            if (selStart >= en) {
                content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en, en, Spannable.SPAN_POINT_POINT);
                content.replace(st, en, old);
                en = content.getSpanStart(TextKeyListener.INHIBIT_REPLACEMENT);
                if (en - 1 >= 0) {
                    content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en - 1, en, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    content.removeSpan(TextKeyListener.INHIBIT_REPLACEMENT);
                }
                adjustMetaAfterKeypress(content);
            } else {
                adjustMetaAfterKeypress(content);
                return super.onKeyDown(view, content, keyCode, event);
            }
            return true;
        }
    }
    return super.onKeyDown(view, content, keyCode, event);
}","{
    int selStart, selEnd;
    int pref = 0;
    if (view != null) {
        pref = TextKeyListener.getInstance().getPrefs(view.getContext());
    }
    {
        int a = Selection.getSelectionStart(content);
        int b = Selection.getSelectionEnd(content);
        selStart = Math.min(a, b);
        selEnd = Math.max(a, b);
        if (selStart < 0 || selEnd < 0) {
            selStart = selEnd = 0;
            Selection.setSelection(content, 0, 0);
        }
    }
    int activeStart = content.getSpanStart(TextKeyListener.ACTIVE);
    int activeEnd = content.getSpanEnd(TextKeyListener.ACTIVE);
    // QWERTY keyboard normal case
    int i = event.getUnicodeChar(getMetaState(content, event));
    if (!mFullKeyboard) {
        int count = event.getRepeatCount();
        if (count > 0 && selStart == selEnd && selStart > 0) {
            char c = content.charAt(selStart - 1);
            if ((c == i || c == Character.toUpperCase(i)) && view != null) {
                if (showCharacterPicker(view, content, c, false, count)) {
                    resetMetaState(content);
                    return true;
                }
            }
        }
    }
    if (i == KeyCharacterMap.PICKER_DIALOG_INPUT) {
        if (view != null) {
            showCharacterPicker(view, content, KeyCharacterMap.PICKER_DIALOG_INPUT, true, 1);
        }
        resetMetaState(content);
        return true;
    }
    if (i == KeyCharacterMap.HEX_INPUT) {
        int start;
        if (selStart == selEnd) {
            start = selEnd;
            while (start > 0 && selEnd - start < 4 && Character.digit(content.charAt(start - 1), 16) >= 0) {
                start--;
            }
        } else {
            start = selStart;
        }
        int ch = -1;
        try {
            String hex = TextUtils.substring(content, start, selEnd);
            ch = Integer.parseInt(hex, 16);
        } catch (NumberFormatException nfe) {
        }
        if (ch >= 0) {
            selStart = start;
            Selection.setSelection(content, selStart, selEnd);
            i = ch;
        } else {
            i = 0;
        }
    }
    if (i != 0) {
        boolean dead = false;
        if ((i & KeyCharacterMap.COMBINING_ACCENT) != 0) {
            dead = true;
            i = i & KeyCharacterMap.COMBINING_ACCENT_MASK;
        }
        if (activeStart == selStart && activeEnd == selEnd) {
            boolean replace = false;
            if (selEnd - selStart - 1 == 0) {
                char accent = content.charAt(selStart);
                int composed = event.getDeadChar(accent, i);
                if (composed != 0) {
                    i = composed;
                    replace = true;
                    dead = false;
                }
            }
            if (!replace) {
                Selection.setSelection(content, selEnd);
                content.removeSpan(TextKeyListener.ACTIVE);
                selStart = selEnd;
            }
        }
        if ((pref & TextKeyListener.AUTO_CAP) != 0 && Character.isLowerCase(i) && TextKeyListener.shouldCap(mAutoCap, content, selStart)) {
            int where = content.getSpanEnd(TextKeyListener.CAPPED);
            int flags = content.getSpanFlags(TextKeyListener.CAPPED);
            if (where == selStart && (((flags >> 16) & 0xFFFF) == i)) {
                content.removeSpan(TextKeyListener.CAPPED);
            } else {
                flags = i << 16;
                i = Character.toUpperCase(i);
                if (selStart == 0)
                    content.setSpan(TextKeyListener.CAPPED, 0, 0, Spannable.SPAN_MARK_MARK | flags);
                else
                    content.setSpan(TextKeyListener.CAPPED, selStart - 1, selStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE | flags);
            }
        }
        if (selStart != selEnd) {
            Selection.setSelection(content, selEnd);
        }
        content.setSpan(OLD_SEL_START, selStart, selStart, Spannable.SPAN_MARK_MARK);
        content.replace(selStart, selEnd, String.valueOf((char) i));
        int oldStart = content.getSpanStart(OLD_SEL_START);
        selEnd = Selection.getSelectionEnd(content);
        if (oldStart < selEnd) {
            content.setSpan(TextKeyListener.LAST_TYPED, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            if (dead) {
                Selection.setSelection(content, oldStart, selEnd);
                content.setSpan(TextKeyListener.ACTIVE, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }
        adjustMetaAfterKeypress(content);
        if ((pref & TextKeyListener.AUTO_TEXT) != 0 && mAutoText && (i == ' ' || i == '\t' || i == '\n' || i == ',' || i == '.' || i == '!' || i == '?' || i == '""' || Character.getType(i) == Character.END_PUNCTUATION) && content.getSpanEnd(TextKeyListener.INHIBIT_REPLACEMENT) != oldStart) {
            int x;
            for (x = oldStart; x > 0; x--) {
                char c = content.charAt(x - 1);
                if (c != '\'' && !Character.isLetter(c)) {
                    break;
                }
            }
            String rep = getReplacement(content, x, oldStart, view);
            if (rep != null) {
                Replaced[] repl = content.getSpans(0, content.length(), Replaced.class);
                for (int a = 0; a < repl.length; a++) content.removeSpan(repl[a]);
                char[] orig = new char[oldStart - x];
                TextUtils.getChars(content, x, oldStart, orig, 0);
                content.setSpan(new Replaced(orig), x, oldStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                content.replace(x, oldStart, rep);
            }
        }
        if ((pref & TextKeyListener.AUTO_PERIOD) != 0 && mAutoText) {
            selEnd = Selection.getSelectionEnd(content);
            if (selEnd - 3 >= 0) {
                if (content.charAt(selEnd - 1) == ' ' && content.charAt(selEnd - 2) == ' ') {
                    char c = content.charAt(selEnd - 3);
                    for (int j = selEnd - 3; j > 0; j--) {
                        if (c == '""' || Character.getType(c) == Character.END_PUNCTUATION) {
                            c = content.charAt(j - 1);
                        } else {
                            break;
                        }
                    }
                    if (Character.isLetter(c) || Character.isDigit(c)) {
                        content.replace(selEnd - 2, selEnd - 1, ""."");
                    }
                }
            }
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_DEL && (event.hasNoModifiers() || event.hasModifiers(KeyEvent.META_ALT_ON)) && selStart == selEnd) {
        // special backspace case for undoing autotext
        int consider = 1;
        if (content.getSpanEnd(TextKeyListener.LAST_TYPED) == selStart) {
            if (content.charAt(selStart - 1) != '\n')
                consider = 2;
        }
        Replaced[] repl = content.getSpans(selStart - consider, selStart, Replaced.class);
        if (repl.length > 0) {
            int st = content.getSpanStart(repl[0]);
            int en = content.getSpanEnd(repl[0]);
            String old = new String(repl[0].mText);
            content.removeSpan(repl[0]);
            // itself).
            if (selStart >= en) {
                content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en, en, Spannable.SPAN_POINT_POINT);
                content.replace(st, en, old);
                en = content.getSpanStart(TextKeyListener.INHIBIT_REPLACEMENT);
                if (en - 1 >= 0) {
                    content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en - 1, en, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    content.removeSpan(TextKeyListener.INHIBIT_REPLACEMENT);
                }
                adjustMetaAfterKeypress(content);
            } else {
                adjustMetaAfterKeypress(content);
                return super.onKeyDown(view, content, keyCode, event);
            }
            return true;
        }
    }
    return super.onKeyDown(view, content, keyCode, event);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
244,<android.widget.TextView: int getExtendedPaddingTop()>,20,21,<android.widget.TextView: int getExtendedPaddingTop()>,<android.widget.TextView: int getExtendedPaddingTop()>,0,"{
    if (mMaxMode != LINES) {
        return getCompoundPaddingTop();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingTop();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return top;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return top;
    } else if (gravity == Gravity.BOTTOM) {
        return top + viewht - layoutht;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return top + (viewht - layoutht) / 2;
    }
}","{
    if (mMaxMode != LINES) {
        return getCompoundPaddingTop();
    }
    if (mLayout == null) {
        assumeLayout();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingTop();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return top;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return top;
    } else if (gravity == Gravity.BOTTOM) {
        return top + viewht - layoutht;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return top + (viewht - layoutht) / 2;
    }
}",1,"/**
 * Returns the extended top padding of the view, including both the
 * top Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */
","/**
 * Returns the extended top padding of the view, including both the
 * top Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"An additional if statement to check if mLayout is null is added, and a new method call assumeLayout() is introduced within this new conditional block. This is considered as a control dependency change and an other statement change, so the code change type is 3,4.","The potential Compatibility Issue is not present because the additional condition and method call (assumeLayout()) serve to ensure that mLayout is not null before proceeding with calculations that rely on mLayout. This change does not immediately lead to a different return value or exception being thrown from what would have occurred without it; instead, it ensures `mLayout` is properly initialized before it's used, which does not constitute a Compatibility Issue. Thus, CI type is 0."
245,<android.app.Notification.Builder: Notification build()>,20,21,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    Notification n = buildUnstyled();
    if (mStyle != null) {
        n = mStyle.buildStyled(n);
    }
    n.extras = mExtras != null ? new Bundle(mExtras) : new Bundle();
    addExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    return n;
}","{
    mOriginatingUserId = mContext.getUserId();
    mHasThreeLines = hasThreeLines();
    Notification n = buildUnstyled();
    if (mStyle != null) {
        n = mStyle.buildStyled(n);
    }
    if (mExtras != null) {
        n.extras.putAll(mExtras);
    }
    if (mRebuildBundle.size() > 0) {
        n.extras.putAll(mRebuildBundle);
        mRebuildBundle.clear();
    }
    populateExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    mHasThreeLines = false;
    return n;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There are new assignments to variables `mOriginatingUserId` and `mHasThreeLines`, a different approach for populating `n.extras` (using `putAll` instead of creating a new Bundle), and a call to `populateExtras(n.extras)` instead of `addExtras(n.extras)`. There is also a condition to check if `mRebuildBundle` has elements and if so, it puts all of it into `n.extras`. The assignment of `mHasThreeLines = false` before returning the notification object is also new. There is also a dependency on the methods `mContext.getUserId()` and `hasThreeLines()`. Thus, the changes are classified as 4,5.","Despite several lines and structure changes (new method calls, logic additions, and assignments), the builder's purpose of creating a `Notification` object and returning it to the caller remains consistent. Without information about the change in behavior of dependent APIs and assuming their backward compatibility, there is no change that directly affects the return type or thrown exceptions of the build method itself. Hence, there is no compatibility issue detected."
246,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,20,21,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}",1,"/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */
","/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the flags used in the method call to `client.findAccessibilityNodeInfoByAccessibilityId`. The change is from `FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS` to `FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS`, which corresponds to an additional flag being passed (FLAG_PREFETCH_PREDECESSORS). This constitutes an ""Other statement changed"", so the code change type is 4.","Although there is a change in the flags, this change affects the behavior of prefetching nodes in the node info retrieval process and does not impact the return type or the value of what is returned by the `getLabeledBy` method itself. The return value should still be an `AccessibilityNodeInfo` object or `null` as dictated by the control flow. Thus, this change does not represent a compatibility issue, it merely changes the internal behavior of the method call without affecting its external interface or the contract with the caller. Therefore, there is no Compatibility Issue."
247,<android.util.Patterns: String concatGroups(Matcher)>,20,21,<android.util.Patterns: String concatGroups(Matcher)>,<android.util.Patterns: String concatGroups(Matcher)>,0,"{
    StringBuilder b = new StringBuilder();
    final int numGroups = matcher.groupCount();
    for (int i = 1; i <= numGroups; i++) {
        String s = matcher.group(i);
        System.err.println(""Group("" + i + "") : "" + s);
        if (s != null) {
            b.append(s);
        }
    }
    return b.toString();
}","{
    StringBuilder b = new StringBuilder();
    final int numGroups = matcher.groupCount();
    for (int i = 1; i <= numGroups; i++) {
        String s = matcher.group(i);
        if (s != null) {
            b.append(s);
        }
    }
    return b.toString();
}",1,"/**
 * Convenience method to take all of the non-null matching groups in a
 * regex Matcher and return them as a concatenated string.
 *
 * @param matcher      The Matcher object from which grouped text will
 * be extracted
 *
 * @return             A String comprising all of the non-null matched
 * groups concatenated together
 */
","/**
 * Convenience method to take all of the non-null matching groups in a
 * regex Matcher and return them as a concatenated string.
 *
 * @param matcher      The Matcher object from which grouped text will
 * be extracted
 *
 * @return             A String comprising all of the non-null matched
 * groups concatenated together
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the removal of the debugging statement (System.err.println(""Group("" + i + "") : "" + s);). This qualifies as a change under the ""Other statement changed"" category, so the code change type is 4.","The removed statement was merely for debugging purposes and does not affect the behavior of the method from a return value or exception perspective. Therefore, no Compatibility Issue arises from this change, so the CI type is 0."
248,<android.hardware.usb.UsbDevice: int getInterfaceCount()>,20,21,<android.hardware.usb.UsbDevice: int getInterfaceCount()>,<android.hardware.usb.UsbDevice: int getInterfaceCount()>,0,"{
    return mInterfaces.length;
}","{
    return getInterfaceList().length;
}",1,"/**
 * Returns the number of {@link UsbInterface}s this device contains.
 *
 * @return the number of interfaces
 */
","/**
 * Returns the number of {@link UsbInterface}s this device contains.
 * For devices with multiple configurations, you will probably want to use
 * {@link UsbConfiguration#getInterfaceCount} instead.
 *
 * @return the number of interfaces
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation relies on different method calls to get the interface count (`mInterfaces.length` is changed to `getInterfaceList().length`), which suggests the dependent API has changed but the overall behavior of the API remains the same. The code change type is 5.","There is no change in logic, exception handling or control flow, and the method appears to be a straightforward getter. Assuming `getInterfaceList()` is an internal getter that correctly returns an array representing the interfaces (and that array's length is consistent with `mInterfaces.length`), this should not lead to a compatibility issue. Therefore, the CI type is 0."
251,<android.widget.DatePicker: void setEnabled(boolean)>,20,21,<android.widget.DatePicker: void setEnabled(boolean)>,<android.widget.DatePicker: void setEnabled(boolean)>,0,"{
    if (mIsEnabled == enabled) {
        return;
    }
    super.setEnabled(enabled);
    mDaySpinner.setEnabled(enabled);
    mMonthSpinner.setEnabled(enabled);
    mYearSpinner.setEnabled(enabled);
    mCalendarView.setEnabled(enabled);
    mIsEnabled = enabled;
}","{
    if (mDelegate.isEnabled() == enabled) {
        return;
    }
    super.setEnabled(enabled);
    mDelegate.setEnabled(enabled);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"There is a control dependency change where the condition in the 'if' statement has changed from checking 'mIsEnabled' to 'mDelegate.isEnabled()'. Moreover, the statements inside the method body have changed from directly operating on the 'mDaySpinner', 'mMonthSpinner', 'mYearSpinner', 'mCalendarView', to operating on a single 'mDelegate' object. There is also an implicit change of the dependent API 'setEnabled' for each spinner and calendar view to a singular setEnabled on 'mDelegate'. Thus, the code change type is 3,5.","Despite the change in how 'setEnabled' is implemented, there is no indication that it would affect the behavior from a caller's perspective – the end result should remain that the DatePicker's enabled state is set according to the 'enabled' parameter. Thus, there is no Compatibility Issue, and the CI type is 0."
253,<android.widget.DatePicker: Parcelable onSaveInstanceState()>,20,21,<android.widget.DatePicker: Parcelable onSaveInstanceState()>,<android.widget.DatePicker: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    return new SavedState(superState, getYear(), getMonth(), getDayOfMonth());
}","{
    Parcelable superState = super.onSaveInstanceState();
    return mDelegate.onSaveInstanceState(superState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from creating a new `SavedState` object using `getYear()`, `getMonth()`, and `getDayOfMonth()` methods directly to calling `onSaveInstanceState` on the `mDelegate` object with `superState` as a parameter. This indicates a change in the logic used to generate the saved state. Additionally, since the method `onSaveInstanceState()` on `mDelegate` is being used, which is not defined in the visibility here, we infer this to be a `Dependent API changed`, thus the change type is 1,5.","The structure of the Parcelable object returned by the `onSaveInstanceState` method has likely changed because it's no longer created with the same set of constructor parameters (`new SavedState(superState, getYear(), getMonth(), getDayOfMonth())` vs `mDelegate.onSaveInstanceState(superState)`). Therefore, the API potentially returns a different value. Hence, the CI type is 1."
254,"<android.app.FragmentManagerImpl: boolean popBackStackState(Handler,String,int,int)>",20,21,"<android.app.FragmentManagerImpl: boolean popBackStackState(Handler,String,int,int)>","<android.app.FragmentManagerImpl: boolean popBackStackState(Handler,String,int,int)>",0,"{
    if (mBackStack == null) {
        return false;
    }
    if (name == null && id < 0 && (flags & POP_BACK_STACK_INCLUSIVE) == 0) {
        int last = mBackStack.size() - 1;
        if (last < 0) {
            return false;
        }
        final BackStackRecord bss = mBackStack.remove(last);
        bss.popFromBackStack(true);
        reportBackStackChanged();
    } else {
        int index = -1;
        if (name != null || id >= 0) {
            // If a name or ID is specified, look for that place in
            // the stack.
            index = mBackStack.size() - 1;
            while (index >= 0) {
                BackStackRecord bss = mBackStack.get(index);
                if (name != null && name.equals(bss.getName())) {
                    break;
                }
                if (id >= 0 && id == bss.mIndex) {
                    break;
                }
                index--;
            }
            if (index < 0) {
                return false;
            }
            if ((flags & POP_BACK_STACK_INCLUSIVE) != 0) {
                index--;
                // Consume all following entries that match.
                while (index >= 0) {
                    BackStackRecord bss = mBackStack.get(index);
                    if ((name != null && name.equals(bss.getName())) || (id >= 0 && id == bss.mIndex)) {
                        index--;
                        continue;
                    }
                    break;
                }
            }
        }
        if (index == mBackStack.size() - 1) {
            return false;
        }
        final ArrayList<BackStackRecord> states = new ArrayList<BackStackRecord>();
        for (int i = mBackStack.size() - 1; i > index; i--) {
            states.add(mBackStack.remove(i));
        }
        final int LAST = states.size() - 1;
        for (int i = 0; i <= LAST; i++) {
            if (DEBUG)
                Log.v(TAG, ""Popping back stack state: "" + states.get(i));
            states.get(i).popFromBackStack(i == LAST);
        }
        reportBackStackChanged();
    }
    return true;
}","{
    if (mBackStack == null) {
        return false;
    }
    if (name == null && id < 0 && (flags & POP_BACK_STACK_INCLUSIVE) == 0) {
        int last = mBackStack.size() - 1;
        if (last < 0) {
            return false;
        }
        final BackStackRecord bss = mBackStack.remove(last);
        SparseArray<Fragment> firstOutFragments = new SparseArray<Fragment>();
        SparseArray<Fragment> lastInFragments = new SparseArray<Fragment>();
        bss.calculateBackFragments(firstOutFragments, lastInFragments);
        bss.popFromBackStack(true, null, firstOutFragments, lastInFragments);
        reportBackStackChanged();
    } else {
        int index = -1;
        if (name != null || id >= 0) {
            // If a name or ID is specified, look for that place in
            // the stack.
            index = mBackStack.size() - 1;
            while (index >= 0) {
                BackStackRecord bss = mBackStack.get(index);
                if (name != null && name.equals(bss.getName())) {
                    break;
                }
                if (id >= 0 && id == bss.mIndex) {
                    break;
                }
                index--;
            }
            if (index < 0) {
                return false;
            }
            if ((flags & POP_BACK_STACK_INCLUSIVE) != 0) {
                index--;
                // Consume all following entries that match.
                while (index >= 0) {
                    BackStackRecord bss = mBackStack.get(index);
                    if ((name != null && name.equals(bss.getName())) || (id >= 0 && id == bss.mIndex)) {
                        index--;
                        continue;
                    }
                    break;
                }
            }
        }
        if (index == mBackStack.size() - 1) {
            return false;
        }
        final ArrayList<BackStackRecord> states = new ArrayList<BackStackRecord>();
        for (int i = mBackStack.size() - 1; i > index; i--) {
            states.add(mBackStack.remove(i));
        }
        final int LAST = states.size() - 1;
        SparseArray<Fragment> firstOutFragments = new SparseArray<Fragment>();
        SparseArray<Fragment> lastInFragments = new SparseArray<Fragment>();
        for (int i = 0; i <= LAST; i++) {
            states.get(i).calculateBackFragments(firstOutFragments, lastInFragments);
        }
        BackStackRecord.TransitionState state = null;
        for (int i = 0; i <= LAST; i++) {
            if (DEBUG)
                Log.v(TAG, ""Popping back stack state: "" + states.get(i));
            state = states.get(i).popFromBackStack(i == LAST, state, firstOutFragments, lastInFragments);
        }
        reportBackStackChanged();
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
255,<android.content.RestrictionEntry: String toString()>,20,21,<android.content.RestrictionEntry: String toString()>,<android.content.RestrictionEntry: String toString()>,0,"{
    return ""RestrictionsEntry {type="" + type + "", key="" + key + "", value="" + currentValue + ""}"";
}","{
    return ""RestrictionsEntry {type="" + mType + "", key="" + mKey + "", value="" + mCurrentValue + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the renaming of variables from type, key, currentValue to mType, mKey, mCurrentValue respectively. This constitutes an 'Other statement changed' scenario, as it's just a change in the variable names, so the code change type is 4.","Since the change is merely renaming of variables without affecting the method's functionality or output, there is no Compatibility Issue. The return type, the exceptions thrown, and the control flow remain unchanged."
256,<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int[])>,20,21,<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int[])>,<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int[])>,0,"{
    int len = attrs.length;
    TypedArray array = getCachedStyledAttributes(len);
    array.mRsrcs = attrs;
    AssetManager.applyStyle(mTheme, 0, 0, 0, attrs, array.mData, array.mIndices);
    return array;
}","{
    final int len = attrs.length;
    final TypedArray array = TypedArray.obtain(Resources.this, len);
    array.mTheme = this;
    AssetManager.applyStyle(mTheme, 0, 0, 0, attrs, array.mData, array.mIndices);
    return array;
}",1,"/**
 * Return a TypedArray holding the values defined by
 * <var>Theme</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param attrs The desired attributes.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int, int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
","/**
 * Return a TypedArray holding the values defined by
 * <var>Theme</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param attrs The desired attributes.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int, int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The way to obtain 'array' has changed from 'getCachedStyledAttributes(len)' to 'TypedArray.obtain(Resources.this, len)', and 'array.mTheme = this' is a new statement that sets the theme for 'array'. There is also a constant modifier added to the 'len' and 'array' declaration. Therefore, the code change type is 1,5. ","Since 'array' is being obtained differently and has a different theme set on it, the returned 'TypedArray' can be potentially different, which could lead to CI type 1."
258,<android.service.notification.NotificationListenerService: StatusBarNotification[] getActiveNotifications()>,20,21,<android.service.notification.NotificationListenerService: StatusBarNotification[] getActiveNotifications()>,<android.service.notification.NotificationListenerService: StatusBarNotification[] getActiveNotifications()>,0,"{
    try {
        return getNotificationInterface().getActiveNotificationsFromListener(mWrapper);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, ""Unable to contact notification manager"", ex);
    }
    return null;
}","{
    return getActiveNotifications(null, TRIM_FULL);
}",1,"/**
 * Request the list of outstanding notifications (that is, those that are visible to the
 * current user). Useful when starting up and you don't know what's already been posted.
 *
 * @return An array of active notifications.
 */
","/**
 * Request the list of outstanding notifications (that is, those that are visible to the
 * current user). Useful when you don't know what's already been posted.
 *
 * @return An array of active notifications, sorted in natural order.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from invoking getNotificationInterface().getActiveNotificationsFromListener(mWrapper) to getActiveNotifications(null, TRIM_FULL) and the entire try-catch block has been removed, indicating a change in the dependent API as the method call is different, so the code change type is 1,5.","The change in return statement and removal of exception handling, i.e., catching RemoteException, will likely result in a different value or exception behavior. If the new method throws an exception, it is not logged and caught as in the previous version, and if it returns a value, it might be different due to the different method signature. Therefore, the CI type is 1."
260,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",20,21,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""],"" + offset + "","" + length + "")"");
    }
    if (length > getMaxBufferSize() || length <= 0) {
        throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)"");
    }
    SynthesisPlaybackQueueItem item = null;
    synchronized (mStateLock) {
        if (mItem == null || mStopped) {
            return TextToSpeech.ERROR;
        }
        item = mItem;
    }
    // Sigh, another copy.
    final byte[] bufferCopy = new byte[length];
    System.arraycopy(buffer, offset, bufferCopy, 0, length);
    // be consumed.
    try {
        item.put(bufferCopy);
    } catch (InterruptedException ie) {
        return TextToSpeech.ERROR;
    }
    mLogger.onEngineDataReceived();
    return TextToSpeech.SUCCESS;
}","{
    if (DBG)
        Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""],"" + offset + "","" + length + "")"");
    if (length > getMaxBufferSize() || length <= 0) {
        throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)"");
    }
    SynthesisPlaybackQueueItem item = null;
    synchronized (mStateLock) {
        if (mItem == null) {
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            return errorCodeOnStop();
        }
        item = mItem;
    }
    // Sigh, another copy.
    final byte[] bufferCopy = new byte[length];
    System.arraycopy(buffer, offset, bufferCopy, 0, length);
    // be consumed.
    try {
        item.put(bufferCopy);
    } catch (InterruptedException ie) {
        synchronized (mStateLock) {
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
    }
    mLogger.onEngineDataReceived();
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The condition check for `mStopped` is replaced with a check on `mStatusCode` and new log messages are added within the `synchronized` block. Additionally, a handling for the `InterruptedException` to set `mStatusCode` inside a `synchronized` block has been introduced. These modifications include control dependency changes, other statement changes, and return statement changes, so the change type is 1,3,4.","Due to the condition change from `mStopped` to `mStatusCode` checks and the modification on exception handling, this may result in a different error code returned. These changes would possibly lead to different return values and altered exception handling behavior between the two versions, making the CI type 1,2."
262,"<android.view.ViewGroup: void requestChildFocus(View,View)>",20,21,"<android.view.ViewGroup: void requestChildFocus(View,View)>","<android.view.ViewGroup: void requestChildFocus(View,View)>",0,"{
    if (DBG) {
        System.out.println(this + "" requestChildFocus()"");
    }
    if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) {
        return;
    }
    // Unfocus us, if necessary
    super.unFocus();
    // We had a previous notion of who had focus. Clear it.
    if (mFocused != child) {
        if (mFocused != null) {
            mFocused.unFocus();
        }
        mFocused = child;
    }
    if (mParent != null) {
        mParent.requestChildFocus(this, focused);
    }
}","{
    if (DBG) {
        System.out.println(this + "" requestChildFocus()"");
    }
    if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) {
        return;
    }
    // Unfocus us, if necessary
    super.unFocus(focused);
    // We had a previous notion of who had focus. Clear it.
    if (mFocused != child) {
        if (mFocused != null) {
            mFocused.unFocus(focused);
        }
        mFocused = child;
    }
    if (mParent != null) {
        mParent.requestChildFocus(this, focused);
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"Parameters in the methods `super.unFocus()` and `mFocused.unFocus()` are updated to `super.unFocus(focused)` and `mFocused.unFocus(focused)`. This change affects the method signature of the called methods, hence it is a change in the dependent API, so the code change type is 4,5.","Changing the arguments of method calls can lead to a different behavior depending on the implementation of the called methods. Given that the behavior of `unFocus()` could change when provided with different arguments, the impact is that the API potentially returns a different variable, making the CI type 1."
263,<android.widget.CalendarView: void setShowWeekNumber(boolean)>,20,21,<android.widget.CalendarView: void setShowWeekNumber(boolean)>,<android.widget.CalendarView: void setShowWeekNumber(boolean)>,0,"{
    if (mShowWeekNumber == showWeekNumber) {
        return;
    }
    mShowWeekNumber = showWeekNumber;
    mAdapter.notifyDataSetChanged();
    setUpHeader();
}","{
    mDelegate.setShowWeekNumber(showWeekNumber);
}",1,"/**
 * Sets whether to show the week number.
 *
 * @param showWeekNumber True to show the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */
","/**
 * Sets whether to show the week number.
 *
 * @param showWeekNumber True to show the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method content has been wholly replaced with a call to a delegate method setShowWeekNumber(showWeekNumber), which indicates a dependent API change, so the code change type is 5.","The change delegates the functionality to another method within the object, and since there is no evidence that the behavior of setShowWeekNumber in mDelegate is different, there does not appear to be a compatibility issue in terms of the return value or exception handling changes. Therefore, the CI type is 0."
264,<android.util.ArrayMap: boolean containsKey(Object)>,20,21,<android.util.ArrayMap: boolean containsKey(Object)>,<android.util.ArrayMap: boolean containsKey(Object)>,0,"{
    return key == null ? (indexOfNull() >= 0) : (indexOf(key, key.hashCode()) >= 0);
}","{
    return indexOfKey(key) >= 0;
}",1,"/**
 * Check whether a key exists in the array.
 *
 * @param key The key to search for.
 * @return Returns true if the key exists, else false.
 */
","/**
 * Check whether a key exists in the array.
 *
 * @param key The key to search for.
 * @return Returns true if the key exists, else false.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed from the use of a ternary operation and explicit index search logic to the use of a single method call (indexOfKey(key)), and the logic inside the indexOfKey method could be different. Therefore, the change type is 1,5 since the return statement has changed and a dependent API (indexOfKey) is being used, which may have different implementation details.","The change in the return statement will make the API potentially return a different value, as the logic to check the existence of a key has been altered by delegating it to a different method that could have a differing implementation. Thus, the CI type is 1."
265,<android.os.Bundle: char getChar(String)>,20,21,<android.os.Bundle: char getChar(String)>,<android.os.Bundle: char getChar(String)>,0,"{
    unparcel();
    return getChar(key, (char) 0);
}","{
    return super.getChar(key);
}",1,"/**
 * Returns the value associated with the given key, or (char) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a char value
 */
","/**
 * Returns the value associated with the given key, or (char) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a char value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed to use the method from the superclass. The dependent API `getChar` from the superclass has become the method to be used, which is a change in dependent API. So, the code change type is 5.","Assuming that the superclass's implementation of `getChar` adheres to the same contract and does not introduce any behavioral changes apart from delegation, there is no compatibility issue due to this change. The wrapper implementation doesn't change any logic or behave differently from the subclass perspective; it redirects the call. Therefore, the CI type is 0."
268,"<android.app.WallpaperManager: Drawable getBuiltInDrawable(int,int,boolean,float,float)>",20,21,"<android.app.WallpaperManager: Drawable getBuiltInDrawable(int,int,boolean,float,float)>","<android.app.WallpaperManager: Drawable getBuiltInDrawable(int,int,boolean,float,float)>",0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return null;
    }
    Resources resources = mContext.getResources();
    horizontalAlignment = Math.max(0, Math.min(1, horizontalAlignment));
    verticalAlignment = Math.max(0, Math.min(1, verticalAlignment));
    InputStream is = new BufferedInputStream(resources.openRawResource(com.android.internal.R.drawable.default_wallpaper));
    if (is == null) {
        Log.e(TAG, ""default wallpaper input stream is null"");
        return null;
    } else {
        if (outWidth <= 0 || outHeight <= 0) {
            Bitmap fullSize = BitmapFactory.decodeStream(is, null, null);
            return new BitmapDrawable(resources, fullSize);
        } else {
            int inWidth;
            int inHeight;
            {
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeStream(is, null, options);
                if (options.outWidth != 0 && options.outHeight != 0) {
                    inWidth = options.outWidth;
                    inHeight = options.outHeight;
                } else {
                    Log.e(TAG, ""default wallpaper dimensions are 0"");
                    return null;
                }
            }
            is = new BufferedInputStream(resources.openRawResource(com.android.internal.R.drawable.default_wallpaper));
            RectF cropRectF;
            outWidth = Math.min(inWidth, outWidth);
            outHeight = Math.min(inHeight, outHeight);
            if (scaleToFit) {
                cropRectF = getMaxCropRect(inWidth, inHeight, outWidth, outHeight, horizontalAlignment, verticalAlignment);
            } else {
                float left = (inWidth - outWidth) * horizontalAlignment;
                float right = left + outWidth;
                float top = (inHeight - outHeight) * verticalAlignment;
                float bottom = top + outHeight;
                cropRectF = new RectF(left, top, right, bottom);
            }
            Rect roundedTrueCrop = new Rect();
            cropRectF.roundOut(roundedTrueCrop);
            if (roundedTrueCrop.width() <= 0 || roundedTrueCrop.height() <= 0) {
                Log.w(TAG, ""crop has bad values for full size image"");
                return null;
            }
            // See how much we're reducing the size of the image
            int scaleDownSampleSize = Math.min(roundedTrueCrop.width() / outWidth, roundedTrueCrop.height() / outHeight);
            // Attempt to open a region decoder
            BitmapRegionDecoder decoder = null;
            try {
                decoder = BitmapRegionDecoder.newInstance(is, true);
            } catch (IOException e) {
                Log.w(TAG, ""cannot open region decoder for default wallpaper"");
            }
            Bitmap crop = null;
            if (decoder != null) {
                // Do region decoding to get crop bitmap
                BitmapFactory.Options options = new BitmapFactory.Options();
                if (scaleDownSampleSize > 1) {
                    options.inSampleSize = scaleDownSampleSize;
                }
                crop = decoder.decodeRegion(roundedTrueCrop, options);
                decoder.recycle();
            }
            if (crop == null) {
                // BitmapRegionDecoder has failed, try to crop in-memory
                is = new BufferedInputStream(resources.openRawResource(com.android.internal.R.drawable.default_wallpaper));
                Bitmap fullSize = null;
                if (is != null) {
                    BitmapFactory.Options options = new BitmapFactory.Options();
                    if (scaleDownSampleSize > 1) {
                        options.inSampleSize = scaleDownSampleSize;
                    }
                    fullSize = BitmapFactory.decodeStream(is, null, options);
                }
                if (fullSize != null) {
                    crop = Bitmap.createBitmap(fullSize, roundedTrueCrop.left, roundedTrueCrop.top, roundedTrueCrop.width(), roundedTrueCrop.height());
                }
            }
            if (crop == null) {
                Log.w(TAG, ""cannot decode default wallpaper"");
                return null;
            }
            // Scale down if necessary
            if (outWidth > 0 && outHeight > 0 && (crop.getWidth() != outWidth || crop.getHeight() != outHeight)) {
                Matrix m = new Matrix();
                RectF cropRect = new RectF(0, 0, crop.getWidth(), crop.getHeight());
                RectF returnRect = new RectF(0, 0, outWidth, outHeight);
                m.setRectToRect(cropRect, returnRect, Matrix.ScaleToFit.FILL);
                Bitmap tmp = Bitmap.createBitmap((int) returnRect.width(), (int) returnRect.height(), Bitmap.Config.ARGB_8888);
                if (tmp != null) {
                    Canvas c = new Canvas(tmp);
                    Paint p = new Paint();
                    p.setFilterBitmap(true);
                    c.drawBitmap(crop, m, p);
                    crop = tmp;
                }
            }
            return new BitmapDrawable(resources, crop);
        }
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return null;
    }
    Resources resources = mContext.getResources();
    horizontalAlignment = Math.max(0, Math.min(1, horizontalAlignment));
    verticalAlignment = Math.max(0, Math.min(1, verticalAlignment));
    InputStream is = new BufferedInputStream(openDefaultWallpaper(mContext));
    if (is == null) {
        Log.e(TAG, ""default wallpaper input stream is null"");
        return null;
    } else {
        if (outWidth <= 0 || outHeight <= 0) {
            Bitmap fullSize = BitmapFactory.decodeStream(is, null, null);
            return new BitmapDrawable(resources, fullSize);
        } else {
            int inWidth;
            int inHeight;
            {
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeStream(is, null, options);
                if (options.outWidth != 0 && options.outHeight != 0) {
                    inWidth = options.outWidth;
                    inHeight = options.outHeight;
                } else {
                    Log.e(TAG, ""default wallpaper dimensions are 0"");
                    return null;
                }
            }
            is = new BufferedInputStream(openDefaultWallpaper(mContext));
            RectF cropRectF;
            outWidth = Math.min(inWidth, outWidth);
            outHeight = Math.min(inHeight, outHeight);
            if (scaleToFit) {
                cropRectF = getMaxCropRect(inWidth, inHeight, outWidth, outHeight, horizontalAlignment, verticalAlignment);
            } else {
                float left = (inWidth - outWidth) * horizontalAlignment;
                float right = left + outWidth;
                float top = (inHeight - outHeight) * verticalAlignment;
                float bottom = top + outHeight;
                cropRectF = new RectF(left, top, right, bottom);
            }
            Rect roundedTrueCrop = new Rect();
            cropRectF.roundOut(roundedTrueCrop);
            if (roundedTrueCrop.width() <= 0 || roundedTrueCrop.height() <= 0) {
                Log.w(TAG, ""crop has bad values for full size image"");
                return null;
            }
            // See how much we're reducing the size of the image
            int scaleDownSampleSize = Math.min(roundedTrueCrop.width() / outWidth, roundedTrueCrop.height() / outHeight);
            // Attempt to open a region decoder
            BitmapRegionDecoder decoder = null;
            try {
                decoder = BitmapRegionDecoder.newInstance(is, true);
            } catch (IOException e) {
                Log.w(TAG, ""cannot open region decoder for default wallpaper"");
            }
            Bitmap crop = null;
            if (decoder != null) {
                // Do region decoding to get crop bitmap
                BitmapFactory.Options options = new BitmapFactory.Options();
                if (scaleDownSampleSize > 1) {
                    options.inSampleSize = scaleDownSampleSize;
                }
                crop = decoder.decodeRegion(roundedTrueCrop, options);
                decoder.recycle();
            }
            if (crop == null) {
                // BitmapRegionDecoder has failed, try to crop in-memory
                is = new BufferedInputStream(openDefaultWallpaper(mContext));
                Bitmap fullSize = null;
                if (is != null) {
                    BitmapFactory.Options options = new BitmapFactory.Options();
                    if (scaleDownSampleSize > 1) {
                        options.inSampleSize = scaleDownSampleSize;
                    }
                    fullSize = BitmapFactory.decodeStream(is, null, options);
                }
                if (fullSize != null) {
                    crop = Bitmap.createBitmap(fullSize, roundedTrueCrop.left, roundedTrueCrop.top, roundedTrueCrop.width(), roundedTrueCrop.height());
                }
            }
            if (crop == null) {
                Log.w(TAG, ""cannot decode default wallpaper"");
                return null;
            }
            // Scale down if necessary
            if (outWidth > 0 && outHeight > 0 && (crop.getWidth() != outWidth || crop.getHeight() != outHeight)) {
                Matrix m = new Matrix();
                RectF cropRect = new RectF(0, 0, crop.getWidth(), crop.getHeight());
                RectF returnRect = new RectF(0, 0, outWidth, outHeight);
                m.setRectToRect(cropRect, returnRect, Matrix.ScaleToFit.FILL);
                Bitmap tmp = Bitmap.createBitmap((int) returnRect.width(), (int) returnRect.height(), Bitmap.Config.ARGB_8888);
                if (tmp != null) {
                    Canvas c = new Canvas(tmp);
                    Paint p = new Paint();
                    p.setFilterBitmap(true);
                    c.drawBitmap(crop, m, p);
                    crop = tmp;
                }
            }
            return new BitmapDrawable(resources, crop);
        }
    }
}",1,"/**
 * Returns a drawable for the system built-in static wallpaper. Based on the parameters, the
 * drawable can be cropped and scaled
 *
 * @param outWidth The width of the returned drawable
 * @param outWidth The height of the returned drawable
 * @param scaleToFit If true, scale the wallpaper down rather than just cropping it
 * @param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
 * 0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
 * @param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
 * 0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
 */
","/**
 * Returns a drawable for the system built-in static wallpaper. Based on the parameters, the
 * drawable can be cropped and scaled
 *
 * @param outWidth The width of the returned drawable
 * @param outWidth The height of the returned drawable
 * @param scaleToFit If true, scale the wallpaper down rather than just cropping it
 * @param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
 * 0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
 * @param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
 * 0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
270,"<android.app.ApplicationPackageManager: void installPackage(Uri,IPackageInstallObserver,int,String)>",20,21,"<android.app.ApplicationPackageManager: void installPackage(Uri,IPackageInstallObserver,int,String)>","<android.app.ApplicationPackageManager: void installPackage(Uri,IPackageInstallObserver,int,String)>",0,"{
    try {
        mPM.installPackage(packageURI, observer, flags, installerPackageName);
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    final VerificationParams verificationParams = new VerificationParams(null, null, null, VerificationParams.NO_UID, null);
    installCommon(packageURI, new LegacyPackageInstallObserver(observer), flags, installerPackageName, verificationParams, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the method changed from directly calling `mPM.installPackage` to calling `installCommon` with a new `LegacyPackageInstallObserver(observer)` and a `VerificationParams` object. This is an other statement change because neither the return statement nor the exception handling has changed. Additionally, the method now depends on the `installCommon` method and `LegacyPackageInstallObserver` and `VerificationParams` classes, which represents a change in dependent APIs.","There seems to be no change that would lead to a compatibility issue in the way exceptions or return values are handled. The observed changes are more related to how the functionality is implemented under the hood, while the external API behavior remains consistent. Therefore, no compatibility issue is predicted."
272,"<android.widget.DatePicker: void updateDate(int,int,int)>",20,21,"<android.widget.DatePicker: void updateDate(int,int,int)>","<android.widget.DatePicker: void updateDate(int,int,int)>",0,"{
    if (!isNewDate(year, month, dayOfMonth)) {
        return;
    }
    setDate(year, month, dayOfMonth);
    updateSpinners();
    updateCalendarView();
    notifyDateChanged();
}","{
    mDelegate.updateDate(year, month, dayOfMonth);
}",1,"/**
 * Updates the current date.
 *
 * @param year The year.
 * @param month The month which is <strong>starting from zero</strong>.
 * @param dayOfMonth The day of the month.
 */
","/**
 * Update the current date.
 *
 * @param year The year.
 * @param month The month which is <strong>starting from zero</strong>.
 * @param dayOfMonth The day of the month.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The entire body of the method has been replaced with a call to mDelegate.updateDate(year, month, dayOfMonth), indicating a potential change in the dependent API, so the code change type is 5.","Since the new implementation delegates the action to mDelegate.updateDate, without specific information on how mDelegate.updateDate is implemented or if its behavior has changed, we cannot determine based on the given information that there is an inherent compatibility issue simply from delegating. Therefore, there's no compatibility issue detected given the context of this analysis."
274,"<android.content.res.XmlBlock.Parser: int getAttributeIntValue(int,int)>",20,21,"<android.content.res.XmlBlock.Parser: int getAttributeIntValue(int,int)>","<android.content.res.XmlBlock.Parser: int getAttributeIntValue(int,int)>",0,"{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on appt doing the conversion for us.
    if (t >= TypedValue.TYPE_FIRST_INT && t <= TypedValue.TYPE_LAST_INT) {
        return nativeGetAttributeData(mParseState, idx);
    }
    return defaultValue;
}","{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on aapt doing the conversion for us.
    if (t >= TypedValue.TYPE_FIRST_INT && t <= TypedValue.TYPE_LAST_INT) {
        return nativeGetAttributeData(mParseState, idx);
    }
    return defaultValue;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the implementation; only a comment is updated with a spelling correction which does not affect the code execution. Since comments are not executable code and there are no other changes, the code change type is 0.","Since there is no change in the actual implementation code, no Compatibility Issue can arise from this difference. Therefore, the CI type is 0."
275,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,20,21,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"{
    synchronized (mLock) {
        if (!getOrCreateDeviceIdListLocked().contains(cameraId)) {
            throw new IllegalArgumentException(String.format(""Camera id %s does not match any"" + "" currently connected camera device"", cameraId));
        }
    }
    CameraMetadataNative info = new CameraMetadataNative();
    try {
        mCameraService.getCameraCharacteristics(Integer.valueOf(cameraId), info);
    } catch (CameraRuntimeException e) {
        throw e.asChecked();
    } catch (RemoteException e) {
        // impossible
        return null;
    }
    return new CameraCharacteristics(info);
}","{
    CameraCharacteristics characteristics = null;
    synchronized (mLock) {
        if (!getOrCreateDeviceIdListLocked().contains(cameraId)) {
            throw new IllegalArgumentException(String.format(""Camera id %s does not match any"" + "" currently connected camera device"", cameraId));
        }
        int id = Integer.valueOf(cameraId);
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = getCameraServiceLocked();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                String[] outParameters = new String[1];
                cameraService.getLegacyParameters(id, /*out*/
                outParameters);
                String parameters = outParameters[0];
                CameraInfo info = new CameraInfo();
                cameraService.getCameraInfo(id, /*out*/
                info);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = new CameraMetadataNative();
                cameraService.getCameraCharacteristics(id, info);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * currently connected camera device.
 * @throws CameraAccessException if the camera is disabled by device policy.
 * @throws SecurityException if the application does not have permission to
 * access the camera
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera is disabled by device policy, or
 * the camera device has been disconnected.
 * @throws SecurityException if the application does not have permission to
 * access the camera
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The late implementation introduces a much larger change, including:",- Changes to the method of getting camera characteristics (using legacy shim or the normal path).
276,<android.widget.Spinner: void setAdapter(SpinnerAdapter)>,20,21,<android.widget.Spinner: void setAdapter(SpinnerAdapter)>,<android.widget.Spinner: void setAdapter(SpinnerAdapter)>,0,"{
    super.setAdapter(adapter);
    mRecycler.clear();
    if (mPopup != null) {
        mPopup.setAdapter(new DropDownAdapter(adapter));
    } else {
        mTempAdapter = new DropDownAdapter(adapter);
    }
}","{
    super.setAdapter(adapter);
    mRecycler.clear();
    final int targetSdkVersion = mContext.getApplicationInfo().targetSdkVersion;
    if (targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP && adapter != null && adapter.getViewTypeCount() != 1) {
        throw new IllegalArgumentException(""Spinner adapter view type count must be 1"");
    }
    if (mPopup != null) {
        mPopup.setAdapter(new DropDownAdapter(adapter));
    } else {
        mTempAdapter = new DropDownAdapter(adapter);
    }
}",1,"/**
 * Sets the Adapter used to provide the data which backs this Spinner.
 * <p>
 * Note that Spinner overrides {@link Adapter#getViewTypeCount()} on the
 * Adapter associated with this view. Calling
 * {@link Adapter#getItemViewType(int) getItemViewType(int)} on the object
 * returned from {@link #getAdapter()} will always return 0. Calling
 * {@link Adapter#getViewTypeCount() getViewTypeCount()} will always return
 * 1.
 *
 * @see AbsSpinner#setAdapter(SpinnerAdapter)
 */
","/**
 * Sets the Adapter used to provide the data which backs this Spinner.
 * <p>
 * Note that Spinner overrides {@link Adapter#getViewTypeCount()} on the
 * Adapter associated with this view. Calling
 * {@link Adapter#getItemViewType(int) getItemViewType(int)} on the object
 * returned from {@link #getAdapter()} will always return 0. Calling
 * {@link Adapter#getViewTypeCount() getViewTypeCount()} will always return
 * 1. On API {@link Build.VERSION_CODES#LOLLIPOP} and above, attempting to set an
 * adapter with more than one view type will throw an
 * {@link IllegalArgumentException}.
 *
 * @param adapter the adapter to set
 *
 * @see AbsSpinner#setAdapter(SpinnerAdapter)
 * @throws IllegalArgumentException if the adapter has more than one view
 * type
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","An additional exception check is added to throw an IllegalArgumentException if the adapter view type count is more than one. There is also a control dependency added with the if statement checking the targetSdkVersion and adapter getViewTypeCount(). Additionally, there is a dependent API call to mContext.getApplicationInfo().targetSdkVersion which may have its behaviour changed in the new platform version, thus resulting in change types 2,3,4.","The early version does not throw an IllegalArgumentException, whereas the late version will throw this exception if adapter.getViewTypeCount() != 1 when targetSdkVersion is >= Build.VERSION_CODES.LOLLIPOP. This difference leads to a Compatibility Issue arising from different exception handlings and potentially different API behaviors (the method may now terminate early with an exception instead of completing its execution), hence the CI types are 1,2."
279,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(String)>,20,21,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(String)>,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(String)>,0,"{
    return getResourcesForApplication(getApplicationInfo(appPackageName, 0));
}","{
    return getResourcesForApplication(getApplicationInfo(appPackageName, sDefaultFlags));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The only change is in the argument passed to the getApplicationInfo method from a literal 0 to a static variable sDefaultFlags. This is a change in the parameter of a method call within the implementation, so the change type is 4 (Other statement changed). Furthermore, since it's not using a fixed value anymore and depends on what sDefaultFlags resolves to, it is also a change in the dependent API, hence change type 5 (Dependent API changed) applies.","There is no indication that changing the flags parameter for getApplicationInfo would lead to a change in the behavior of getResourcesForApplication. The presumption is that sDefaultFlags contains the value that would be passed as part of normal operation, and this change merely refactors the code to use a variable instead of a hardcoded value. This should not cause a compatibility issue, thus the pred_CI is 0 (No Compatibility Issue)."
281,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,20,21,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mCaller.mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
282,<android.widget.DatePicker: boolean isEnabled()>,20,21,<android.widget.DatePicker: boolean isEnabled()>,<android.widget.DatePicker: boolean isEnabled()>,0,"{
    return mIsEnabled;
}","{
    return mDelegate.isEnabled();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method of getting the enabled state has been changed from direct field access (mIsEnabled) to calling a delegate method (mDelegate.isEnabled()), indicating a change in the dependent API. The change types are 4 for the other statement changed and 5 for the dependent API changed.","Using a different method to determine the enabled state may result in a change in behavior, specifically if the delegate's isEnabled method contains different logic than simply accessing the mIsEnabled field directly. Thus, there is a potential Compatibility Issue due to different return values, so the CI type is 1."
285,<android.appwidget.AppWidgetHost: void stopListening()>,20,21,<android.appwidget.AppWidgetHost: void stopListening()>,<android.appwidget.AppWidgetHost: void stopListening()>,0,"{
    try {
        sService.stopListening(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}","{
    try {
        sService.stopListening(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}",1,"/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
","/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The parameters for the call to sService.stopListening have changed from (mHostId, mContext.getUserId()) to (mContext.getOpPackageName(), mHostId), indicating that a dependent API has changed, which corresponds to code change type 5.","Although the parameters for sService.stopListening have changed, the function call itself, as well as the exception handling and the call to clearViews, remain the same. Consequently, there is no introduction of a new return statement or exception handling change, and there is no alteration in the control structure that would lead to a different behavior. Therefore, no compatibility issue should arise due to this change, which corresponds to CI type 0."
287,"<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>",20,21,"<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>","<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>",0,"{
    if (mWrapped != null) {
        try {
            mWrapped.writeToParcel(out, flags);
        } finally {
            releaseResources();
        }
    } else {
        out.writeFileDescriptor(mFd);
        if (mCommFd != null) {
            out.writeInt(1);
            out.writeFileDescriptor(mCommFd);
        } else {
            out.writeInt(0);
        }
        if ((flags & PARCELABLE_WRITE_RETURN_VALUE) != 0 && !mClosed) {
            // Not a real close, so emit no status
            closeWithStatus(Status.SILENCE, null);
        }
    }
}","{
    // in frameworks/native/libs/binder/Parcel.cpp
    if (mWrapped != null) {
        try {
            mWrapped.writeToParcel(out, flags);
        } finally {
            releaseResources();
        }
    } else {
        out.writeFileDescriptor(mFd);
        if (mCommFd != null) {
            out.writeInt(1);
            out.writeFileDescriptor(mCommFd);
        } else {
            out.writeInt(0);
        }
        if ((flags & PARCELABLE_WRITE_RETURN_VALUE) != 0 && !mClosed) {
            // Not a real close, so emit no status
            closeWithStatus(Status.SILENCE, null);
        }
    }
}",1,"/**
 * {@inheritDoc}
 * If {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set in flags,
 * the file descriptor will be closed after a copy is written to the Parcel.
 */
","/**
 * {@inheritDoc}
 * If {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set in flags,
 * the file descriptor will be closed after a copy is written to the Parcel.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation of the method between the two versions; the comments and annotations remain the same as well.,"As there are no changes in any part of the implementations or annotations, there is no Compatibility Issue between these two versions of the method."
289,"<android.content.ContentResolver: void cancelSync(Account,String)>",20,21,"<android.content.ContentResolver: void cancelSync(Account,String)>","<android.content.ContentResolver: void cancelSync(Account,String)>",0,"{
    try {
        getContentService().cancelSync(account, authority);
    } catch (RemoteException e) {
    }
}","{
    try {
        getContentService().cancelSync(account, authority, null);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Cancel any active or pending syncs that match account and authority. The account and
 * authority can each independently be set to null, which means that syncs with any account
 * or authority, respectively, will match.
 *
 * @param account filters the syncs that match by this account
 * @param authority filters the syncs that match by this authority
 */
","/**
 * Cancel any active or pending syncs that match account and authority. The account and
 * authority can each independently be set to null, which means that syncs with any account
 * or authority, respectively, will match.
 *
 * @param account filters the syncs that match by this account
 * @param authority filters the syncs that match by this authority
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API within the method body has changed its parameter list (from cancelSync(account, authority) to cancelSync(account, authority, null)), thus the change is of type 5.","There is no Compatibility Issue because the added null parameter might be an overload of the existing method which was designed to handle such situations, and it is being caught in the existing try-catch block. Additionally, the method's signature, return type, and exception handling have not changed, so it should not lead to different behavior from the perspective of a caller."
290,"<android.os.PowerManager: void userActivity(long,boolean)>",20,21,"<android.os.PowerManager: void userActivity(long,boolean)>","<android.os.PowerManager: void userActivity(long,boolean)>",0,"{
    try {
        mService.userActivity(when, USER_ACTIVITY_EVENT_OTHER, noChangeLights ? USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS : 0);
    } catch (RemoteException e) {
    }
}","{
    userActivity(when, USER_ACTIVITY_EVENT_OTHER, noChangeLights ? USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS : 0);
}",1,"/**
 * Notifies the power manager that user activity happened.
 * <p>
 * Resets the auto-off timer and brightens the screen if the device
 * is not asleep.  This is what happens normally when a key or the touch
 * screen is pressed or when some other user activity occurs.
 * This method does not wake up the device if it has been put to sleep.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param when The time of the user activity, in the {@link SystemClock#uptimeMillis()}
 * time base.  This timestamp is used to correctly order the user activity request with
 * other power management functions.  It should be set
 * to the timestamp of the input event that caused the user activity.
 * @param noChangeLights If true, does not cause the keyboard backlight to turn on
 * because of this event.  This is set when the power key is pressed.
 * We want the device to stay on while the button is down, but we're about
 * to turn off the screen so we don't want the keyboard backlight to turn on again.
 * Otherwise the lights flash on and then off and it looks weird.
 *
 * @see #wakeUp
 * @see #goToSleep
 */
","/**
 * Notifies the power manager that user activity happened.
 * <p>
 * Resets the auto-off timer and brightens the screen if the device
 * is not asleep.  This is what happens normally when a key or the touch
 * screen is pressed or when some other user activity occurs.
 * This method does not wake up the device if it has been put to sleep.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param when The time of the user activity, in the {@link SystemClock#uptimeMillis()}
 * time base.  This timestamp is used to correctly order the user activity request with
 * other power management functions.  It should be set
 * to the timestamp of the input event that caused the user activity.
 * @param noChangeLights If true, does not cause the keyboard backlight to turn on
 * because of this event.  This is set when the power key is pressed.
 * We want the device to stay on while the button is down, but we're about
 * to turn off the screen so we don't want the keyboard backlight to turn on again.
 * Otherwise the lights flash on and then off and it looks weird.
 *
 * @see #wakeUp
 * @see #goToSleep
 *
 * @removed Requires signature or system permission.
 * @deprecated Use {@link #userActivity(long, int, int)}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The implementation in the earlier version calls 'mService.userActivity' within a try-catch block that handles RemoteException, but in the later version, it simply calls another method 'userActivity'. The new 'userActivity' called method may be an overloaded method within the same class or a completely different method (details not provided). Since there's no internal code change within the method provided and it directly calls another method which means the dependency has changed, the code change type is 5.","There is no Compatibility Issue because the new implementation calls another method which is assumed to perform the equivalent operation as the inlined version previously. The behavior has not changed from the standpoint of the caller. RemoteException is an unchecked exception in the context of Android's Binder calls, and it's usually not expected to be caught by client code, as it indicates catastrophic failure (like the whole system service went down). As the exception was previously being caught and ignored, the new code that does not have this catch block will not behave differently from the perspective of the API consumer. Thus, there is no compatibility issue introduced with this change."
291,<android.app.ContextImpl: File getFilesDir()>,20,21,<android.app.ContextImpl: File getFilesDir()>,<android.app.ContextImpl: File getFilesDir()>,0,"{
    synchronized (mSync) {
        if (mFilesDir == null) {
            mFilesDir = new File(getDataDirFile(), ""files"");
        }
        if (!mFilesDir.exists()) {
            if (!mFilesDir.mkdirs()) {
                if (mFilesDir.exists()) {
                    // spurious failure; probably racing with another process for this app
                    return mFilesDir;
                }
                Log.w(TAG, ""Unable to create files directory "" + mFilesDir.getPath());
                return null;
            }
            FileUtils.setPermissions(mFilesDir.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        }
        return mFilesDir;
    }
}","{
    synchronized (mSync) {
        if (mFilesDir == null) {
            mFilesDir = new File(getDataDirFile(), ""files"");
        }
        return createFilesDirLocked(mFilesDir);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"Return statement has been changed to call a new method createFilesDirLocked(mFilesDir) instead of directly returning mFilesDir, statements related to the directory's existence and creation have been removed, and a dependent API (createFilesDirLocked) is called instead. Therefore, the code changes includes 1 (Return statement changed), 4 (Other statement changed), and 5 (Dependent API changed).","Since the original implementation's return value could potentially be different due to the changes in how the directory is being checked and created, this could cause the late version of the API to return different results, which is a compatibility issue of type 1 (Compatibility Issue caused by potential different return values)."
292,"<android.print.PrintManager.PrintDocumentAdapterDelegate: void layout(PrintAttributes,PrintAttributes,ILayoutResultCallback,Bundle,int)>",20,21,"<android.print.PrintManager.PrintDocumentAdapterDelegate: void layout(PrintAttributes,PrintAttributes,ILayoutResultCallback,Bundle,int)>","<android.print.PrintManager.PrintDocumentAdapterDelegate: void layout(PrintAttributes,PrintAttributes,ILayoutResultCallback,Bundle,int)>",0,"{
    final boolean destroyed;
    synchronized (mLock) {
        destroyed = mDestroyed;
        // If start called and not finished called and not destroyed - do some work.
        if (mStartReqeusted && !mFinishRequested && !mDestroyed) {
            // Layout cancels write and overrides layout.
            if (mLastWriteSpec != null) {
                IoUtils.closeQuietly(mLastWriteSpec.fd);
                mLastWriteSpec = null;
            }
            mLastLayoutSpec = new LayoutSpec();
            mLastLayoutSpec.callback = callback;
            mLastLayoutSpec.oldAttributes = oldAttributes;
            mLastLayoutSpec.newAttributes = newAttributes;
            mLastLayoutSpec.metadata = metadata;
            mLastLayoutSpec.sequence = sequence;
            // cancellation completes we will do the pending work.
            if (cancelPreviousCancellableOperationLocked()) {
                return;
            }
            doPendingWorkLocked();
        }
    }
    if (destroyed) {
        try {
            callback.onLayoutFailed(null, sequence);
        } catch (RemoteException re) {
            Log.i(LOG_TAG, ""Error notifying for cancelled layout"", re);
        }
    }
}","{
    ICancellationSignal cancellationTransport = CancellationSignal.createTransport();
    try {
        callback.onLayoutStarted(cancellationTransport, sequence);
    } catch (RemoteException re) {
        // The spooler is dead - can't recover.
        Log.e(LOG_TAG, ""Error notifying for layout start"", re);
        return;
    }
    synchronized (mLock) {
        // If destroyed the handler is null.
        if (isDestroyedLocked()) {
            return;
        }
        CancellationSignal cancellationSignal = CancellationSignal.fromTransport(cancellationTransport);
        SomeArgs args = SomeArgs.obtain();
        args.arg1 = mDocumentAdapter;
        args.arg2 = oldAttributes;
        args.arg3 = newAttributes;
        args.arg4 = cancellationSignal;
        args.arg5 = new MyLayoutResultCallback(callback, sequence);
        args.arg6 = metadata;
        mHandler.obtainMessage(MyHandler.MSG_ON_LAYOUT, args).sendToTarget();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",The late implementation has completely changed from the early implementation. We note that:,"- Instead of direct work, the `MyHandler.MSG_ON_LAYOUT` message is sent to the target handler."
293,<android.widget.CalendarView: long getMinDate()>,20,21,<android.widget.CalendarView: long getMinDate()>,<android.widget.CalendarView: long getMinDate()>,0,"{
    return mMinDate.getTimeInMillis();
}","{
    return mDelegate.getMinDate();
}",1,"/**
 * Gets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */
","/**
 * Gets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method from which the return value is obtained has changed from mMinDate.getTimeInMillis() in the early version to mDelegate.getMinDate() in the late version, indicating a dependent API change. Hence, the code change type is 1,5.","The change in the method that provides the return value can possibly lead to a different return type or value if the new method mDelegate.getMinDate() behaves differently from the old method mMinDate.getTimeInMillis(), leading to a Compatibility Issue of type 1."
294,<android.widget.TextView: int getShadowColor()>,20,21,<android.widget.TextView: int getShadowColor()>,<android.widget.TextView: int getShadowColor()>,0,"{
    return mTextPaint.shadowColor;
}","{
    return mShadowColor;
}",1,"/**
 * @return the color of the shadow layer
 *
 * @see #setShadowLayer(float, float, float, int)
 *
 * @attr ref android.R.styleable#TextView_shadowColor
 */
","/**
 * @return the color of the shadow layer
 *
 * @see #setShadowLayer(float, float, float, int)
 *
 * @attr ref android.R.styleable#TextView_shadowColor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation changed from returning `mTextPaint.shadowColor` to directly returning `mShadowColor`, and the source of the shadow color value is different, constituting a return statement changed and other statement changed, so the code change type is 1,4.","The change directly affects the returned value of the method: if `mShadowColor` is different from `mTextPaint.shadowColor`, the method will return a different value in the late version, so the CI type is 1."
295,<android.provider.DocumentsContract: String getRootId(Uri)>,20,21,<android.provider.DocumentsContract: String getRootId(Uri)>,<android.provider.DocumentsContract: String getRootId(Uri)>,0,"{
    final List<String> paths = rootUri.getPathSegments();
    if (paths.size() < 2) {
        throw new IllegalArgumentException(""Not a root: "" + rootUri);
    }
    if (!PATH_ROOT.equals(paths.get(0))) {
        throw new IllegalArgumentException(""Not a root: "" + rootUri);
    }
    return paths.get(1);
}","{
    final List<String> paths = rootUri.getPathSegments();
    if (paths.size() >= 2 && PATH_ROOT.equals(paths.get(0))) {
        return paths.get(1);
    }
    throw new IllegalArgumentException(""Invalid URI: "" + rootUri);
}",1,"/**
 * Extract the {@link Root#COLUMN_ROOT_ID} from the given URI.
 */
","/**
 * Extract the {@link Root#COLUMN_ROOT_ID} from the given URI.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3","1,2","The control dependency has changed with a new condition introduced and the exception message has been altered. So the change type is 1,3.","The change potentially causes the method to throw a different exception message (""Not a root"" vs ""Invalid URI""), and the control flow has also changed, which could impact return value as well ('return paths.get(1)' may now be reached under different circumstances). Therefore, the CI types are 1,2."
297,<android.content.RestrictionEntry: boolean equals(Object)>,20,21,<android.content.RestrictionEntry: boolean equals(Object)>,<android.content.RestrictionEntry: boolean equals(Object)>,0,"{
    if (o == this)
        return true;
    if (!(o instanceof RestrictionEntry))
        return false;
    final RestrictionEntry other = (RestrictionEntry) o;
    // Make sure that either currentValue matches or currentValues matches.
    return type == other.type && key.equals(other.key) && ((currentValues == null && other.currentValues == null && currentValue != null && currentValue.equals(other.currentValue)) || (currentValue == null && other.currentValue == null && currentValues != null && equalArrays(currentValues, other.currentValues)));
}","{
    if (o == this)
        return true;
    if (!(o instanceof RestrictionEntry))
        return false;
    final RestrictionEntry other = (RestrictionEntry) o;
    // Make sure that either currentValue matches or currentValues matches.
    return mType == other.mType && mKey.equals(other.mKey) && ((mCurrentValues == null && other.mCurrentValues == null && mCurrentValue != null && mCurrentValue.equals(other.mCurrentValue)) || (mCurrentValue == null && other.mCurrentValue == null && mCurrentValues != null && equalArrays(mCurrentValues, other.mCurrentValues)));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The variable names inside the equal method have been prefixed with 'm', but this does not change the logic or functionality of the code, so the code change type is 4.","There's no change in the behavior of the equals method; it still performs the same checks and returns the same values for the same conditions. Hence, there is no compatibility issue, so the CI type is 0."
298,<android.view.View: boolean removeCallbacks(Runnable)>,20,21,<android.view.View: boolean removeCallbacks(Runnable)>,<android.view.View: boolean removeCallbacks(Runnable)>,0,"{
    if (action != null) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            attachInfo.mHandler.removeCallbacks(action);
            attachInfo.mViewRootImpl.mChoreographer.removeCallbacks(Choreographer.CALLBACK_ANIMATION, action, null);
        } else {
            // Assume that post will succeed later
            ViewRootImpl.getRunQueue().removeCallbacks(action);
        }
    }
    return true;
}","{
    if (action != null) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            attachInfo.mHandler.removeCallbacks(action);
            attachInfo.mViewRootImpl.mChoreographer.removeCallbacks(Choreographer.CALLBACK_ANIMATION, action, null);
        }
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().removeCallbacks(action);
    }
    return true;
}",1,"/**
 * <p>Removes the specified Runnable from the message queue.</p>
 *
 * @param action The Runnable to remove from the message handling queue
 *
 * @return true if this view could ask the Handler to remove the Runnable,
 * false otherwise. When the returned value is true, the Runnable
 * may or may not have been actually removed from the message queue
 * (for instance, if the Runnable was not in the queue already.)
 *
 * @see #post
 * @see #postDelayed
 * @see #postOnAnimation
 * @see #postOnAnimationDelayed
 */
","/**
 * <p>Removes the specified Runnable from the message queue.</p>
 *
 * @param action The Runnable to remove from the message handling queue
 *
 * @return true if this view could ask the Handler to remove the Runnable,
 * false otherwise. When the returned value is true, the Runnable
 * may or may not have been actually removed from the message queue
 * (for instance, if the Runnable was not in the queue already.)
 *
 * @see #post
 * @see #postDelayed
 * @see #postOnAnimation
 * @see #postOnAnimationDelayed
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The only difference between the early and late versions is that the late version moved the call `ViewRootImpl.getRunQueue().removeCallbacks(action);` outside the `else` block, so it is executed unconditionally now. This is a control dependency change, classified as type 3.","There is no Compatibility Issue because the return value remains `true` regardless of the code path taken. Action is removed from the queue in both the cases where `attachInfo` is not `null` and when it is. The behavior for the caller stays consistent, hence there's no CI."
299,"<android.view.GLES20Canvas: int saveLayer(RectF,Paint,int)>",20,21,"<android.view.GLES20Canvas: int saveLayer(RectF,Paint,int)>","<android.view.GLES20Canvas: int saveLayer(RectF,Paint,int)>",0,"{
    if (bounds != null) {
        return saveLayer(bounds.left, bounds.top, bounds.right, bounds.bottom, paint, saveFlags);
    }
    int count;
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        count = nSaveLayer(mRenderer, nativePaint, saveFlags);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
    return count;
}","{
    if (bounds != null) {
        return saveLayer(bounds.left, bounds.top, bounds.right, bounds.bottom, paint, saveFlags);
    }
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    return nSaveLayer(mRenderer, nativePaint, saveFlags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The code change consists of removing the try-finally block and the 'modifier' variable, as well as the call to nResetModifiers(mRenderer, modifier). The 'count' variable is no longer being declared or used. This leads to a change in the control flow of the method, removal of the final 'return count;' statement, and the statement 'final int nativePaint = paint == null ? 0 : paint.mNativePaint;' has been changed to use long instead of int. The statement changes fit within categories 1, 3, and 4.","The removal of the try-finally block and associated code potentially changes the return behavior of the method because the modifier is no longer reset, which could affect subsequent operations if the setupColorFilter(paint) had side effects. The change of 'nativePaint' from an int to a long might lead to different behaviors if the underlying native method expects a different type, although Java would typically handle this through implicit type conversion as long as there are no overloads that might result in a different method being called. This means both the return value and types could potentially change, so the CI type is 1."
300,<android.appwidget.AppWidgetManager: AppWidgetManager getInstance(Context)>,20,21,<android.appwidget.AppWidgetManager: AppWidgetManager getInstance(Context)>,<android.appwidget.AppWidgetManager: AppWidgetManager getInstance(Context)>,0,"{
    synchronized (sManagerCache) {
        if (sService == null) {
            IBinder b = ServiceManager.getService(Context.APPWIDGET_SERVICE);
            sService = IAppWidgetService.Stub.asInterface(b);
        }
        WeakReference<AppWidgetManager> ref = sManagerCache.get(context);
        AppWidgetManager result = null;
        if (ref != null) {
            result = ref.get();
        }
        if (result == null) {
            result = new AppWidgetManager(context);
            sManagerCache.put(context, new WeakReference<AppWidgetManager>(result));
        }
        return result;
    }
}","{
    return (AppWidgetManager) context.getSystemService(Context.APPWIDGET_SERVICE);
}",1,"/**
 * Get the AppWidgetManager instance to use for the supplied {@link android.content.Context
 * Context} object.
 */
","/**
 * Get the AppWidgetManager instance to use for the supplied {@link android.content.Context
 * Context} object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method implementation has completely changed from a custom mechanism managing a cache of `AppWidgetManager` instances to a call to `context.getSystemService(Context.APPWIDGET_SERVICE)`. There's a change in the return statement and the dependent API (`getSystemService`), thus the code change type is 1,4,5.","Because the mechanism for obtaining an `AppWidgetManager` instance has been altered significantly, it may return different instances of `AppWidgetManager` than previously, leading to a CI type of 1."
301,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,20,21,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,0,"{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                perfromAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBLITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                perfromAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        case MSG_COMPUTE_CLICK_POINT_IN_SCREEN:
            {
                computeClickPointInScreenUiThread(message);
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A case for MSG_COMPUTE_CLICK_POINT_IN_SCREEN has been added to the switch statement, but this is just an additional case and does not affect the existing functionality, so the code change type is 4.","There is no change in existing return values or exception handling; a new case is just added, which will not lead to CI for the existing functionality; thus, the CI type is 0."
302,<android.view.accessibility.AccessibilityManager: boolean addAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,20,21,<android.view.accessibility.AccessibilityManager: boolean addAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean addAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,0,"{
    return mAccessibilityStateChangeListeners.add(listener);
}","{
    // Final CopyOnArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.add(listener);
}",1,"/**
 * Registers an {@link AccessibilityStateChangeListener} for changes in
 * the global accessibility state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
","/**
 * Registers an {@link AccessibilityStateChangeListener} for changes in
 * the global accessibility state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change except for the addition of a comment, which does not alter any behavior of the method. So the code change type is 0.","Since there are no changes in the functioning of the code, no Compatibility Issue could arise. Hence, the CI type is 0."
303,<android.text.format.Time: String format(String)>,20,21,<android.text.format.Time: String format(String)>,<android.text.format.Time: String format(String)>,0,"{
    synchronized (Time.class) {
        Locale locale = Locale.getDefault();
        if (sLocale == null || locale == null || !(locale.equals(sLocale))) {
            LocaleData localeData = LocaleData.get(locale);
            sAm = localeData.amPm[0];
            sPm = localeData.amPm[1];
            sZeroDigit = localeData.zeroDigit;
            sShortMonths = localeData.shortMonthNames;
            sLongMonths = localeData.longMonthNames;
            sLongStandaloneMonths = localeData.longStandAloneMonthNames;
            sShortWeekdays = localeData.shortWeekdayNames;
            sLongWeekdays = localeData.longWeekdayNames;
            Resources r = Resources.getSystem();
            sTimeOnlyFormat = r.getString(com.android.internal.R.string.time_of_day);
            sDateOnlyFormat = r.getString(com.android.internal.R.string.month_day_year);
            sDateTimeFormat = r.getString(com.android.internal.R.string.date_and_time);
            sLocale = locale;
        }
        String result = format1(format);
        if (sZeroDigit != '0') {
            result = localizeDigits(result);
        }
        return result;
    }
}","{
    calculator.copyFieldsFromTime(this);
    return calculator.format(format);
}",1,"/**
 * Print the current value given the format string provided. See man
 * strftime for what means what. The final string must be less than 256
 * characters.
 * @param format a string containing the desired format.
 * @return a String containing the current time expressed in the current locale.
 */
","/**
 * Print the current value given the format string provided. See man
 * strftime for what means what. The final string must be less than 256
 * characters.
 * @param format a string containing the desired format.
 * @return a String containing the current time expressed in the current locale.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the format method has changed significantly from using a synchronized block with a bunch of locale-related operations to using a 'calculator' object to perform the formatting. Additionally, this transition to using 'calculator.format(format)' indicates that the new implementation depends on another API 'calculator.format', making it a dependent API change. The code structure and possibly the behavior of the method have changed, which could potentially lead to different return values. Hence, the change types are 1, 4, and 5.","Considering the extensive changes to the implementation, which now delegates the formatting to a different object 'calculator', this may cause the method to return different values. The change in the method's behavior due to these altered code statements could result in different output, given the same input. Therefore, the potential for Compatibility Issues arises due to the possibility of different return values, and the CI type is 1."
304,"<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>",20,21,"<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>","<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>",0,"{
    if (opts != null && opts.containsKey(EXTRA_THUMBNAIL_SIZE)) {
        final Point sizeHint = opts.getParcelable(EXTRA_THUMBNAIL_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, signal);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts, signal);
    }
}","{
    enforceTree(uri);
    if (opts != null && opts.containsKey(ContentResolver.EXTRA_SIZE)) {
        final Point sizeHint = opts.getParcelable(ContentResolver.EXTRA_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, signal);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts, signal);
    }
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 */
","/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,The code changes include:,- Change of the constant key used in the `opts.containsKey` and `opts.getParcelable` method calls from an unspecified constant to `ContentResolver.EXTRA_SIZE`.
306,<android.view.accessibility.AccessibilityNodeInfo: void addAction(int)>,20,21,<android.view.accessibility.AccessibilityNodeInfo: void addAction(int)>,<android.view.accessibility.AccessibilityNodeInfo: void addAction(int)>,0,"{
    enforceNotSealed();
    mActions |= action;
}","{
    enforceNotSealed();
    if ((action & ACTION_TYPE_MASK) != 0) {
        throw new IllegalArgumentException(""Action is not a combination of the standard "" + ""actions: "" + action);
    }
    addLegacyStandardActions(action);
}",1,"/**
 * Adds an action that can be performed on the node.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param action The action.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Adds an action that can be performed on the node.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param action The action.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 * @throws IllegalArgumentException If the argument is not one of the standard actions.
 *
 * @deprecated This has been deprecated for {@link #addAction(AccessibilityAction)}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"2,3,4",2,"There are new condition checks and throwing of IllegalArgumentException in the late implementation which are not present in the early implementation. Furthermore, there is a new method call 'addLegacyStandardActions(action)' which replaced direct bitwise operation on mActions. So the code changes include exception handling statement changes (2), control dependency changes (3), and other statement changes (4).","The late version of the method can throw IllegalArgumentException which was not the case in the early version; this constitutes a change in exception handling behavior and could lead to a Compatibility Issue (2). The addition of the 'if' control structure introduces different exception handling depending on the action's value, which wasn't present earlier."
307,<android.widget.AnalogClock: void onAttachedToWindow()>,20,21,<android.widget.AnalogClock: void onAttachedToWindow()>,<android.widget.AnalogClock: void onAttachedToWindow()>,0,"{
    super.onAttachedToWindow();
    if (!mAttached) {
        mAttached = true;
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_TIME_TICK);
        filter.addAction(Intent.ACTION_TIME_CHANGED);
        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
        getContext().registerReceiver(mIntentReceiver, filter, null, mHandler);
    }
    // NOTE: It's safe to do these after registering the receiver since the receiver always runs
    // in the main thread, therefore the receiver can't run before this method returns.
    // The time zone may have changed while the receiver wasn't registered, so update the Time
    mCalendar = new Time();
    // Make sure we update to the current time
    onTimeChanged();
}","{
    super.onAttachedToWindow();
    if (!mAttached) {
        mAttached = true;
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_TIME_TICK);
        filter.addAction(Intent.ACTION_TIME_CHANGED);
        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
        // OK, this is gross but needed. This class is supported by the
        // remote views machanism and as a part of that the remote views
        // can be inflated by a context for another user without the app
        // having interact users permission - just for loading resources.
        // For exmaple, when adding widgets from a user profile to the
        // home screen. Therefore, we register the receiver as the current
        // user not the one the context is for.
        getContext().registerReceiverAsUser(mIntentReceiver, android.os.Process.myUserHandle(), filter, null, mHandler);
    }
    // NOTE: It's safe to do these after registering the receiver since the receiver always runs
    // in the main thread, therefore the receiver can't run before this method returns.
    // The time zone may have changed while the receiver wasn't registered, so update the Time
    mCalendar = new Time();
    // Make sure we update to the current time
    onTimeChanged();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API used for registering a receiver has changed from registerReceiver() to registerReceiverAsUser(). This is a change in how the receiver is registered but not a change in the overall behavior of how to handle attached state, so the code change type is 4,5.",No Compatibility Issue is introduced by this change because the change does not affect the return value of the method (since the method is void and does not return anything) or the exceptions that it throws. The functional behavior of the registration process changes internally to how the receiver is registered but not to how the method behaves externally to the caller.
308,<android.os.Message: void recycle()>,20,21,<android.os.Message: void recycle()>,<android.os.Message: void recycle()>,0,"{
    clearForRecycle();
    synchronized (sPoolSync) {
        if (sPoolSize < MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}","{
    if (isInUse()) {
        if (gCheckRecycle) {
            throw new IllegalStateException(""This message cannot be recycled because it "" + ""is still in use."");
        }
        return;
    }
    recycleUnchecked();
}",1,"/**
 * Return a Message instance to the global pool.  You MUST NOT touch
 * the Message after calling this function -- it has effectively been
 * freed.
 */
","/**
 * Return a Message instance to the global pool.
 * <p>
 * You MUST NOT touch the Message after calling this function because it has
 * effectively been freed.  It is an error to recycle a message that is currently
 * enqueued or that is in the process of being delivered to a Handler.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The code change includes a new control flow with 'if' statement and subsequent logic including a new return statement, a new exception handling statement (throw), and a call to recycleUnchecked() replacing clearForRecycle() and original synchronization block. Despite most of the changes are under the new 'if' control structure, the removal of the synchronized block with the condition on 'sPoolSize' also affects the method behavior outside of any new control structures introduced. Therefore, the changes are categorized as 1,3,4.","There are differences that can lead to a different behavior. A new condition checks if the message is in use and potentially throws an IllegalStateException, which is a new behavior. In the later version, the message will not be recycled and will throw an exception instead if it is still in use. This represents a compatibility issue of type 1 regarding different return values or types, since the method can now prematurely return without recycling the message, and type 2 regarding different exception handlings, because a new exception can be thrown where previously there was none."
310,<android.os.Bundle: boolean hasFileDescriptors()>,20,21,<android.os.Bundle: boolean hasFileDescriptors()>,<android.os.Bundle: boolean hasFileDescriptors()>,0,"{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.get(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if ((array.size() > 0) && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}","{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}",1,"/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
","/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the ArrayList condition check from `(array.size() > 0)` to `!array.isEmpty()`. This modification is functionally equivalent because both expressions are checking that the array is not empty before proceeding. Thus, the change type is 4, indeed reflecting refactoring rather than a functional difference.","There is no compatibility issue because the change does not affect the behavior of the API; the logic and control flow remain the same. The check for an empty array is just done using a different method, which does not lead to a different outcome within the context of this API."
311,"<android.app.ContextImpl: void grantUriPermission(String,Uri,int)>",20,21,"<android.app.ContextImpl: void grantUriPermission(String,Uri,int)>","<android.app.ContextImpl: void grantUriPermission(String,Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().grantUriPermission(mMainThread.getApplicationThread(), toPackage, uri, modeFlags);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().grantUriPermission(mMainThread.getApplicationThread(), toPackage, ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method signature of the dependent API call within grantUriPermission has changed since additional parameters have been introduced (ContentProvider.getUriWithoutUserId(uri) and resolveUserId(uri)). The statement has changed, but the exception handling statement and return statement remain unaffected, so the change types are 4 and 5.","There is no Compatibility Issue because both implementations are wrapped in a try-catch block that catches all RemoteExceptions and does not allow them to propagate. There is no change in the method's return type or exception handling that would affect the caller, as RemoteException is caught within the method in both versions. Therefore, the API's behavior from the caller's perspective remains unchanged."
313,"<android.hardware.camera2.CameraManager.CameraServiceListener: void onStatusChanged(int,int)>",20,21,"<android.hardware.camera2.CameraManager.CameraServiceListener: void onStatusChanged(int,int)>","<android.hardware.camera2.CameraManager.CameraServiceListener: void onStatusChanged(int,int)>",0,"{
    synchronized (CameraManager.this.mLock) {
        Log.v(TAG, String.format(""Camera id %d has status changed to 0x%x"", cameraId, status));
        final String id = String.valueOf(cameraId);
        if (!validStatus(status)) {
            Log.e(TAG, String.format(""Ignoring invalid device %d status 0x%x"", cameraId, status));
            return;
        }
        Integer oldStatus = mDeviceStatus.put(id, status);
        if (oldStatus != null && oldStatus == status) {
            Log.v(TAG, String.format(""Device status changed to 0x%x, which is what it already was"", status));
            return;
        }
        // not available -> not available => no new update
        if (oldStatus != null && isAvailable(status) == isAvailable(oldStatus)) {
            Log.v(TAG, String.format(""Device status was previously available (%d), "" + "" and is now again available (%d)"" + ""so no new client visible update will be sent"", isAvailable(status), isAvailable(status)));
            return;
        }
        final int listenerCount = mListenerMap.size();
        for (int i = 0; i < listenerCount; i++) {
            Handler handler = mListenerMap.valueAt(i);
            final AvailabilityListener listener = mListenerMap.keyAt(i);
            if (isAvailable(status)) {
                handler.post(new Runnable() {

                    @Override
                    public void run() {
                        listener.onCameraAvailable(id);
                    }
                });
            } else {
                handler.post(new Runnable() {

                    @Override
                    public void run() {
                        listener.onCameraUnavailable(id);
                    }
                });
            }
        }
    // for
    }
// synchronized
}","{
    synchronized (CameraManager.this.mLock) {
        onStatusChangedLocked(status, String.valueOf(cameraId));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The entire body within the `synchronized` block has been replaced by a call to `onStatusChangedLocked(status, String.valueOf(cameraId));`, which is a change in the dependent method invocation, therefore the code change is type 5.","Since the implementation details within the `onStatusChangedLocked` method are not provided, we cannot determine if there's a compatibility issue based solely on the current information. Thus, there is no detected compatibility issue (0) unless further details about the implementation of `onStatusChangedLocked` or the behavior changes in `onStatusChanged` indicate otherwise."
316,<android.os.Bundle: boolean[] getBooleanArray(String)>,20,21,<android.os.Bundle: boolean[] getBooleanArray(String)>,<android.os.Bundle: boolean[] getBooleanArray(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (boolean[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""byte[]"", e);
        return null;
    }
}","{
    return super.getBooleanArray(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a boolean[] value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a boolean[] value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has been changed to simply return the result of a call to the superclass method `super.getBooleanArray(key)`. This indicates the behavior is now entirely dependent on the superclass's implementation of `getBooleanArray(String)`, so the change type is 5.","As long as the superclass's `getBooleanArray(String)` method has not changed its behavior between the early and late versions, there will be no compatibility issue since the method's contract appears to be the same. If the superclass's method adheres to the same contract, the change should not introduce any new behavior, and thus, there is no compatibility issue - CI type is 0. However, without knowing details about the superclass's changes, if any, we cannot conclusively determine if a CI has been introduced strictly from the context of this method's change. The provided information assumes no change in the superclass behavior."
317,"<android.app.ApplicationPackageManager: void installPackageWithVerification(Uri,IPackageInstallObserver,int,String,Uri,ManifestDigest,ContainerEncryptionParams)>",20,21,"<android.app.ApplicationPackageManager: void installPackageWithVerification(Uri,IPackageInstallObserver,int,String,Uri,ManifestDigest,ContainerEncryptionParams)>","<android.app.ApplicationPackageManager: void installPackageWithVerification(Uri,IPackageInstallObserver,int,String,Uri,ManifestDigest,ContainerEncryptionParams)>",0,"{
    try {
        mPM.installPackageWithVerification(packageURI, observer, flags, installerPackageName, verificationURI, manifestDigest, encryptionParams);
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    final VerificationParams verificationParams = new VerificationParams(verificationURI, null, null, VerificationParams.NO_UID, manifestDigest);
    installCommon(packageURI, new LegacyPackageInstallObserver(observer), flags, installerPackageName, verificationParams, encryptionParams);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code changes include the creation of a new VerificationParams object with different parameters, and a call to a different install method, installCommon(), with differently organized parameters. Thus, the code change type is 4,5.","Although the implementation details have changed significantly, as long as the behavior of installCommon() and the new VerificationParams constructor is internally consistent with the behavior of the original mPM.installPackageWithVerification() method, this should not introduce a CI from an API consumer's perspective. It seems the late version is an internal refactoring to use a new helper method and classes that streamline the installation process, with no expected compatibility issue provided that the internal logic is consistent. Therefore, the CI type is 0."
319,"<android.view.View: void measure(int,int)>",20,21,"<android.view.View: void measure(int,int)>","<android.view.View: void measure(int,int)>",0,"{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    // Suppress sign extension for the low bytes
    long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;
    if (mMeasureCache == null)
        mMeasureCache = new LongSparseLongArray(2);
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        int cacheIndex = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex < 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimension((int) (value >> 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 | // suppress sign extension
    (long) mMeasuredHeight & 0xffffffffL);
}","{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    // Suppress sign extension for the low bytes
    long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;
    if (mMeasureCache == null)
        mMeasureCache = new LongSparseLongArray(2);
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        int cacheIndex = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex < 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimensionRaw((int) (value >> 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 | // suppress sign extension
    (long) mMeasuredHeight & 0xffffffffL);
}",1,"/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
","/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to set the measured dimension has changed from setMeasuredDimension() to setMeasuredDimensionRaw(). Since only the internal method call for setting the dimensions has changed but not the actual logic of how the dimensions are computed or the return type/value of the method, the code change type is 4. Also, this is an example of a change in a dependent API, so it is 5.","There is no Compatibility Issue because the change does not affect the external behaviour of how this API works or interacts with its callers. The process of setting the measured dimension internally within the View object has changed, but the contracts of measuring and setting remain the same from the caller's perspective. The public API does not indicate any change affecting the inputs or outputs of the `measure` method."
320,<android.view.GLES20Canvas: void drawPicture(Picture)>,20,21,<android.view.GLES20Canvas: void drawPicture(Picture)>,<android.view.GLES20Canvas: void drawPicture(Picture)>,0,"{
    if (picture.createdFromStream) {
        return;
    }
    picture.endRecording();
// TODO: Implement rendering
}","{
    picture.endRecording();
// TODO: Implement rendering
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The removal of the conditional 'if' statement which included a 'return' action represents a change in the control structure of the flow, specifically a control dependency change. This is why it's classified as type 3.","The removal of the 'if' statement does not lead to a different return type or value (because the method has no return value—it's void) or throw a different exception, hence no compatibility issue arises from this code change."
321,"<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean)>",20,21,"<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean)>","<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean)>",0,"{
    // A HandleView relies on the layout, which may be nulled by external methods
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        // Will update controllers' state, hiding them and stopping selection mode if needed
        prepareCursorControllers();
        return;
    }
    boolean offsetChanged = offset != mPreviousOffset;
    if (offsetChanged || parentScrolled) {
        if (offsetChanged) {
            updateSelection(offset);
            addPositionToTouchUpFilter(offset);
        }
        final int line = layout.getLineForOffset(offset);
        mPositionX = (int) (layout.getPrimaryHorizontal(offset) - 0.5f - mHotspotX);
        mPositionY = layout.getLineBottom(line);
        // Take TextView's padding and scroll into account.
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionY += mTextView.viewportToContentVerticalOffset();
        mPreviousOffset = offset;
        mPositionHasChanged = true;
    }
}","{
    // A HandleView relies on the layout, which may be nulled by external methods
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        // Will update controllers' state, hiding them and stopping selection mode if needed
        prepareCursorControllers();
        return;
    }
    boolean offsetChanged = offset != mPreviousOffset;
    if (offsetChanged || parentScrolled) {
        if (offsetChanged) {
            updateSelection(offset);
            addPositionToTouchUpFilter(offset);
        }
        final int line = layout.getLineForOffset(offset);
        mPositionX = (int) (layout.getPrimaryHorizontal(offset) - 0.5f - mHotspotX - getHorizontalOffset() + getCursorOffset());
        mPositionY = layout.getLineBottom(line);
        // Take TextView's padding and scroll into account.
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionY += mTextView.viewportToContentVerticalOffset();
        mPreviousOffset = offset;
        mPositionHasChanged = true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method `positionAtCursorOffset` now includes two new method calls (`getHorizontalOffset()` and `getCursorOffset()`) when calculating the value of `mPositionX`. This signifies a change in an ""other statement"", specifically an arithmetic operation statement, which is type 4.","The changes in how `mPositionX` is calculated are local to the method and do not affect the method's signature or its return type because the method's return type is void and does not return any value to the caller. Therefore, there is no Compatibility Issue related to different return values or types. Additionally, there are no changes in exception handling. Thus, the CI situation is 0."
322,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",20,21,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>","<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",0,"{
    int type = sensor.mType;
    // Set it to 3 for backward compatibility.
    if (type == Sensor.TYPE_ROTATION_VECTOR && sdkLevel <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        return 3;
    }
    int offset = type * 2 + 1;
    if (offset >= sSensorReportingModes.length) {
        // sensor
        return 16;
    }
    return sSensorReportingModes[offset];
}","{
    // Set it to 3 for backward compatibility.
    if (sensor.mType == Sensor.TYPE_ROTATION_VECTOR && sdkLevel <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        return 3;
    }
    int offset = sensor.mType;
    if (offset >= sSensorReportingModes.length) {
        // sensor
        return 16;
    }
    return sSensorReportingModes[offset];
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change is in the way 'offset' is calculated and the removal of variable 'type'. In the early implementation, 'offset' was calculated using the sensor type multiplied by 2 and then adding 1, whereas in the late implementation, 'offset' is directly assigned the sensor type. Additionally, there has been a refactoring change where sensor.mType is used directly in the 'if' condition instead of assigning it to a local variable 'type'. Hence, change type is 3,4 (Control dependency changed and Other statement changed).","There is not a Compatibility Issue because the values that would be returned for given inputs and sensor types remain consistent across the API versions. The change doesn't affect the behavior of the method in terms of what value is returned or what exceptions could be thrown. The logic remains the same, just using a simplified way to determine the 'offset'. Hence, the CI type is 0 (No Compatibility Issue)."
323,<android.os.Environment: boolean isExternalStorageEmulated()>,20,21,<android.os.Environment: boolean isExternalStorageEmulated()>,<android.os.Environment: boolean isExternalStorageEmulated()>,0,"{
    final StorageVolume primary = getPrimaryVolume();
    return (primary != null && primary.isEmulated());
}","{
    if (isStorageDisabled())
        return false;
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return isExternalStorageEmulated(externalDir);
}",1,"/**
 * Returns whether the device has an external storage device which is
 * emulated. If true, the device does not have real external storage, and the directory
 * returned by {@link #getExternalStorageDirectory()} will be allocated using a portion of
 * the internal storage system.
 *
 * <p>Certain system services, such as the package manager, use this
 * to determine where to install an application.
 *
 * <p>Emulated external storage may also be encrypted - see
 * {@link android.app.admin.DevicePolicyManager#setStorageEncryption(
 * android.content.ComponentName, boolean)} for additional details.
 */
","/**
 * Returns whether the primary ""external"" storage device is emulated. If
 * true, data stored on this device will be stored on a portion of the
 * internal storage system.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The implementation in the late version introduces a new condition check (isStorageDisabled()) and uses a different approach to determine if the external storage is emulated, including the usage of new dependent APIs (isStorageDisabled, sCurrentUser.getExternalDirsForApp, and isExternalStorageEmulated with a different parameter). This includes control dependency changes and other statement changes, as well as a change in dependent APIs, so the code change types are 3,4,5.","The inclusion of a new conditional check and the change in the method used to determine emulation may result in the late version potentially returning different values compared to the early version, and therefore, the CI type is 1."
325,<android.os.Process: int myPid()>,20,21,<android.os.Process: int myPid()>,<android.os.Process: int myPid()>,0,"{
    return Libcore.os.getpid();
}","{
    return Os.getpid();
}",1,"/**
 * Returns the identifier of this process, which can be used with
 * {@link #killProcess} and {@link #sendSignal}.
 */
","/**
 * Returns the identifier of this process, which can be used with
 * {@link #killProcess} and {@link #sendSignal}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The code change is that the method called for getting the process ID has changed from `Libcore.os.getpid()` to `Os.getpid()`. This implies a change in the dependent API being used.,"Despite the change in the dependent API used, the return value of the method, which is the process ID, is expected to remain unchanged because both calls are expected to return the PID of the current process. Hence, there is no compatibility issue expected from this change."
328,<android.widget.TimePicker: Parcelable onSaveInstanceState()>,20,21,<android.widget.TimePicker: Parcelable onSaveInstanceState()>,<android.widget.TimePicker: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    return new SavedState(superState, getCurrentHour(), getCurrentMinute());
}","{
    Parcelable superState = super.onSaveInstanceState();
    return mDelegate.onSaveInstanceState(superState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the return statement has changed from creating a new SavedState with `getCurrentHour()` and `getCurrentMinute()` to calling `mDelegate.onSaveInstanceState(superState)`, indicating the dependent API `onSaveInstanceState` has a different behavior, so the change type is 1,5.","Since the return statement creates a different object in the late version, potentially with different hour and minute, hence the API could return a different value, the CI type is 1."
331,<android.service.dreams.DreamService: WindowManager getWindowManager()>,20,21,<android.service.dreams.DreamService: WindowManager getWindowManager()>,<android.service.dreams.DreamService: WindowManager getWindowManager()>,0,"{
    return mWindowManager;
}","{
    return mWindow != null ? mWindow.getWindowManager() : null;
}",1,"/**
 * Retrieves the current {@link android.view.WindowManager} for the dream.
 * Behaves similarly to {@link android.app.Activity#getWindowManager()}.
 *
 * @return The current window manager, or null if the dream is not started.
 */
","/**
 * Retrieves the current {@link android.view.WindowManager} for the dream.
 * Behaves similarly to {@link android.app.Activity#getWindowManager()}.
 *
 * @return The current window manager, or null if the dream is not started.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has been changed from a direct return of an instance variable (mWindowManager) to a conditional statement that may return a value from a method call or null, so the code change type is 1.","The modification to the return statement introduces a conditional check and potentially a different return value, which could impact the behavior of the API; therefore, the CI type is 1."
332,<android.animation.PropertyValuesHolder: String toString()>,20,21,<android.animation.PropertyValuesHolder: String toString()>,<android.animation.PropertyValuesHolder: String toString()>,0,"{
    return mPropertyName + "": "" + mKeyframeSet.toString();
}","{
    return mPropertyName + "": "" + mKeyframes.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The object whose `toString` method is being called has changed from `mKeyframeSet` to `mKeyframes`, and there is no indication that `mKeyframeSet` and `mKeyframes` are equivalent, so the change type is 1,5.","Since the method is calling `toString` on a different member variable, this could potentially lead to the API returning a different value. Thus, the CI type is 1."
333,<android.view.LayoutInflater: void setFactory2(Factory2)>,20,21,<android.view.LayoutInflater: void setFactory2(Factory2)>,<android.view.LayoutInflater: void setFactory2(Factory2)>,0,"{
    if (mFactorySet) {
        throw new IllegalStateException(""A factory has already been set on this LayoutInflater"");
    }
    if (factory == null) {
        throw new NullPointerException(""Given factory can not be null"");
    }
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = mFactory2 = factory;
    } else {
        mFactory = new FactoryMerger(factory, factory, mFactory, mFactory2);
    }
}","{
    if (mFactorySet) {
        throw new IllegalStateException(""A factory has already been set on this LayoutInflater"");
    }
    if (factory == null) {
        throw new NullPointerException(""Given factory can not be null"");
    }
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = mFactory2 = factory;
    } else {
        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);
    }
}",1,"/**
 * Like {@link #setFactory}, but allows you to set a {@link Factory2}
 * interface.
 */
","/**
 * Like {@link #setFactory}, but allows you to set a {@link Factory2}
 * interface.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment within the else block has changed, but it does not affect the return value or exception handling, therefore, the code change type is 4.",There is no compatibility issue since the alteration does not lead to different return values or the throwing of different exceptions.
334,"<android.net.nsd.NsdManager: void resolveService(NsdServiceInfo,ResolveListener)>",20,21,"<android.net.nsd.NsdManager: void resolveService(NsdServiceInfo,ResolveListener)>","<android.net.nsd.NsdManager: void resolveService(NsdServiceInfo,ResolveListener)>",0,"{
    if (TextUtils.isEmpty(serviceInfo.getServiceName()) || TextUtils.isEmpty(serviceInfo.getServiceType())) {
        throw new IllegalArgumentException(""Service name or type cannot be empty"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    mAsyncChannel.sendMessage(RESOLVE_SERVICE, 0, putListener(listener, serviceInfo), serviceInfo);
}","{
    if (TextUtils.isEmpty(serviceInfo.getServiceName()) || TextUtils.isEmpty(serviceInfo.getServiceType())) {
        throw new IllegalArgumentException(""Service name or type cannot be empty"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    int key = putListener(listener, serviceInfo);
    if (key == BUSY_LISTENER_KEY) {
        throw new IllegalArgumentException(""listener already in use"");
    }
    mAsyncChannel.sendMessage(RESOLVE_SERVICE, 0, key, serviceInfo);
}",1,"/**
 * Resolve a discovered service. An application can resolve a service right before
 * establishing a connection to fetch the IP and port details on which to setup
 * the connection.
 *
 * @param serviceInfo service to be resolved
 * @param listener to receive callback upon success or failure. Cannot be null.
 */
","/**
 * Resolve a discovered service. An application can resolve a service right before
 * establishing a connection to fetch the IP and port details on which to setup
 * the connection.
 *
 * @param serviceInfo service to be resolved
 * @param listener to receive callback upon success or failure. Cannot be null.
 * Cannot be in use for an active service resolution.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","A new block of control dependency has been introduced which involves exception handling with a new condition to be checked before calling 'mAsyncChannel.sendMessage'. The variable 'key' has been introduced to hold the result of 'putListener' and based on this result, an IllegalArgumentException is potentially thrown. These changes affect both the control flow and exception handling, so the code change types are 3 for control dependency change and 4 for other statement change.","The introduction of a new 'if' statement that checks the result of 'putListener' and can throw an IllegalArgumentException leads to potential changes in exception handling as this exception was not present in the early version. This means the code could throw a different exception when the 'key' equals 'BUSY_LISTENER_KEY', which wasn't checked before. Additionally, due to this extra check, the behavior and potentially the return value can change because the method may now throw an exception where it previously would not have, so the CI types are 1 for potentially different return values and 2 for potentially different exception handling."
335,"<android.app.ApplicationPackageManager: CharSequence getText(String,int,ApplicationInfo)>",20,21,"<android.app.ApplicationPackageManager: CharSequence getText(String,int,ApplicationInfo)>","<android.app.ApplicationPackageManager: CharSequence getText(String,int,ApplicationInfo)>",0,"{
    ResourceName name = new ResourceName(packageName, resid);
    CharSequence text = getCachedString(name);
    if (text != null) {
        return text;
    }
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, 0);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    try {
        Resources r = getResourcesForApplication(appInfo);
        text = r.getText(resid);
        putCachedString(name, text);
        return text;
    } catch (NameNotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for"" + appInfo.packageName);
    } catch (RuntimeException e) {
        // If an exception was thrown, fall through to return
        // default icon.
        Log.w(""PackageManager"", ""Failure retrieving text 0x"" + Integer.toHexString(resid) + "" in package "" + packageName, e);
    }
    return null;
}","{
    ResourceName name = new ResourceName(packageName, resid);
    CharSequence text = getCachedString(name);
    if (text != null) {
        return text;
    }
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, sDefaultFlags);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    try {
        Resources r = getResourcesForApplication(appInfo);
        text = r.getText(resid);
        putCachedString(name, text);
        return text;
    } catch (NameNotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for "" + appInfo.packageName);
    } catch (RuntimeException e) {
        // If an exception was thrown, fall through to return
        // default icon.
        Log.w(""PackageManager"", ""Failure retrieving text 0x"" + Integer.toHexString(resid) + "" in package "" + packageName, e);
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,The code change consists of altering the parameter of the getApplicationInfo() method from a literal 0 to sDefaultFlags variable. This is considered a change in the dependent API.,"Since the change only affects the arguments passed to the getApplicationInfo() method, and assuming that sDefaultFlags is defined to have the same value that was previously passed as a literal (0), the behavior of the method won't change. Therefore, there would be no compatibility issue based solely on this change."
336,<android.widget.GridLayout.Spec: Spec copyWriteAlignment(Alignment)>,20,21,<android.widget.GridLayout.Spec: Spec copyWriteAlignment(Alignment)>,<android.widget.GridLayout.Spec: Spec copyWriteAlignment(Alignment)>,0,"{
    return new Spec(startDefined, span, alignment);
}","{
    return new Spec(startDefined, span, alignment, weight);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed with the addition of a new parameter 'weight' in the constructor of Spec, resulting in a new Spec object being created with a different set of parameters. This indicates both 1 (Return statement changed) and 5 (Dependent API changed - the constructor signature changed).","The change in the constructor of Spec due to an added parameter 'weight' can lead to a different object being returned, introducing potential Compatibility Issues because the behaviour of the method and the result will differ from the previous version. Thus CI type is 1."
337,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",20,21,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    int initialScrollX = -1;
    int initialScrollY = -1;
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (action == MotionEvent.ACTION_DOWN) {
            if (isSelecting(buffer)) {
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            }
        } else if (action == MotionEvent.ACTION_MOVE) {
            if (isSelecting(buffer) && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            if (isSelecting(buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}","{
    int initialScrollX = -1;
    int initialScrollY = -1;
    final int action = event.getAction();
    final boolean isMouse = event.isFromSource(InputDevice.SOURCE_MOUSE);
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (action == MotionEvent.ACTION_DOWN) {
            // For touch events, the code should run only when selection is active.
            if (isMouse || isTouchSelecting(isMouse, buffer)) {
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            }
        } else if (action == MotionEvent.ACTION_MOVE) {
            // text selection will start from mouse pointer location.
            if (isMouse && Touch.isSelectionStarted(buffer)) {
                int offset = buffer.getSpanStart(LAST_TAP_DOWN);
                Selection.setSelection(buffer, offset);
            }
            if (isTouchSelecting(isMouse, buffer) && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            if (isTouchSelecting(isMouse, buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
339,"<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>","<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>",0,"{
    if ((start | end | (end - start) | (text.length() - end)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, start, end, x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if ((start | end | (end - start) | (text.length() - end)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    nDrawText(mRenderer, text, start, end, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The modification includes the removal of try-finally block and modifiers related code, and the addition of an extra parameter to nDrawText method, which is paint.mNativeTypeface. This alteration is categorized as Other statement changed (4) due to the removed try-finally block and modification of method parameters, and Exception handling statement changed (2) due to the elimination of the finally block which could affect exception handling.","Since the finally block is removed in the late version including nResetModifiers call, there is a Compatibility Issue due to a change in exception handling. If an exception is thrown during the execution of nDrawText, any potential reset of modifiers done by nResetModifiers will not be performed in the late version, which indicates a Compatibility Issue caused by potential different exception handlings (2)."
340,<android.os.Looper: void loop()>,20,21,<android.os.Looper: void loop()>,<android.os.Looper: void loop()>,0,"{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        msg.target.dispatchMessage(msg);
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycle();
    }
}","{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        msg.target.dispatchMessage(msg);
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call msg.recycle() has been changed to msg.recycleUnchecked() in the loop, and this is not a return statement, control dependency, or exception handling statement, so the change type is 4.","No Compatibility Issues could arise from this change because it does not affect how exceptions are thrown, nor does it change the method's return value or type. The change is an internal implementation detail inside the method loop() that is unlikely to impact the API's external behavior."
341,<android.nfc.tech.Ndef: NdefMessage getNdefMessage()>,20,21,<android.nfc.tech.Ndef: NdefMessage getNdefMessage()>,<android.nfc.tech.Ndef: NdefMessage getNdefMessage()>,0,"{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService == null) {
            throw new IOException(""Mock tags don't support this operation."");
        }
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            NdefMessage msg = tagService.ndefRead(serviceHandle);
            if (msg == null && !tagService.isPresent(serviceHandle)) {
                throw new TagLostException();
            }
            return msg;
        } else {
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        return null;
    }
}","{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService == null) {
            throw new IOException(""Mock tags don't support this operation."");
        }
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            NdefMessage msg = tagService.ndefRead(serviceHandle);
            if (msg == null && !tagService.isPresent(serviceHandle)) {
                throw new TagLostException();
            }
            return msg;
        } else if (!tagService.isPresent(serviceHandle)) {
            throw new TagLostException();
        } else {
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        return null;
    }
}",1,"/**
 * Read the current {@link android.nfc.NdefMessage} on this tag.
 *
 * <p>This always reads the current NDEF Message stored on the tag.
 *
 * <p>Note that this method may return null if the tag was in the
 * INITIALIZED state as defined by NFC Forum, as in that state the
 * tag is formatted to support NDEF but does not contain a message yet.
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @return the NDEF Message, can be null
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 * @throws FormatException if the NDEF Message on the tag is malformed
 */
","/**
 * Read the current {@link android.nfc.NdefMessage} on this tag.
 *
 * <p>This always reads the current NDEF Message stored on the tag.
 *
 * <p>Note that this method may return null if the tag was in the
 * INITIALIZED state as defined by NFC Forum, as in that state the
 * tag is formatted to support NDEF but does not contain a message yet.
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @return the NDEF Message, can be null
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 * @throws FormatException if the NDEF Message on the tag is malformed
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed with an added else-if condition to check if the tagService.isPresent(serviceHandle) when the tag is not NDEF, which alters the workflow of the method, so the code change type is 3.","There is no compatibility issue because this change does not alter the behavior that would affect existing clients. The addition only throws a TagLostException when the tag is not present and it is not NDEF, which would be expected behavior for the API and does not represent a change in the contract of the method; the method previously could throw a TagLostException for the same reasons, just within a different condition's part. Therefore, there's no compatibility issue, which is indicated as 0."
342,<android.view.accessibility.AccessibilityManager: boolean isTouchExplorationEnabled()>,20,21,<android.view.accessibility.AccessibilityManager: boolean isTouchExplorationEnabled()>,<android.view.accessibility.AccessibilityManager: boolean isTouchExplorationEnabled()>,0,"{
    synchronized (mHandler) {
        return mIsTouchExplorationEnabled;
    }
}","{
    synchronized (mLock) {
        IAccessibilityManager service = getServiceLocked();
        if (service == null) {
            return false;
        }
        return mIsTouchExplorationEnabled;
    }
}",1,"/**
 * Returns if the touch exploration in the system is enabled.
 *
 * @return True if touch exploration is enabled, false otherwise.
 */
","/**
 * Returns if the touch exploration in the system is enabled.
 *
 * @return True if touch exploration is enabled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The control dependency has changed by introducing a new if condition that checks if a service is null and, if so, returns false. Further, a new dependent API call getServiceLocked() has been introduced. The synchronization lock object has been changed from mHandler to mLock. These changes lead to code change types 1, 3, 4, and 5.","The new if condition can alter the return value of the method to false when the service is null, which was not considered in the early version. The change in synchronization lock could potentially alter the conditions under which the block is entered, and the new dependency on getServiceLocked() introduces a new behavior. Therefore, there is a potential for a Compatibility Issue due to different return values, which corresponds to CI type 1."
343,<android.widget.DatePicker: void setMaxDate(long)>,20,21,<android.widget.DatePicker: void setMaxDate(long)>,<android.widget.DatePicker: void setMaxDate(long)>,0,"{
    mTempDate.setTimeInMillis(maxDate);
    if (mTempDate.get(Calendar.YEAR) == mMaxDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMaxDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    mMaxDate.setTimeInMillis(maxDate);
    mCalendarView.setMaxDate(maxDate);
    if (mCurrentDate.after(mMaxDate)) {
        mCurrentDate.setTimeInMillis(mMaxDate.getTimeInMillis());
        updateCalendarView();
    }
    updateSpinners();
}","{
    mDelegate.setMaxDate(maxDate);
}",1,"/**
 * Sets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param maxDate The maximal supported date.
 */
","/**
 * Sets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param maxDate The maximal supported date.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire implementation of the method has been changed from multiple operations to a single call to mDelegate.setMaxDate(maxDate). This change affected the return statement, other statements, and dependent API which are 1,4 and 5 respectively.","The method's behavior is altered significantly as it now relies on a delegate's implementation which could potentially return different values, have a different flow, or handle exceptions differently. This could cause a change in behavior observable by the users of the method, so the CI type is 1."
344,"<android.transition.Transition: Transition excludeChildren(Class,boolean)>",20,21,"<android.transition.Transition: Transition excludeChildren(Class,boolean)>","<android.transition.Transition: Transition excludeChildren(Class,boolean)>",0,"{
    mTargetTypeChildExcludes = excludeType(mTargetTypeChildExcludes, type, exclude);
    return this;
}","{
    mTargetTypeChildExcludes = excludeObject(mTargetTypeChildExcludes, type, exclude);
    return this;
}",1,"/**
 * Whether to add the given type to the list of types whose children should
 * be excluded from this transition. The <code>exclude</code> parameter
 * specifies whether the target type should be added to or removed from
 * the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeTarget(Class, boolean)
 * @see #excludeChildren(int, boolean)
 * @see #excludeChildren(View, boolean)
 *
 * @param type The type to ignore when running this transition.
 * @param exclude Whether to add the target type to or remove it from the
 * current list of excluded target types.
 * @return This transition object.
 */
","/**
 * Whether to add the given type to the list of types whose children should
 * be excluded from this transition. The <code>exclude</code> parameter
 * specifies whether the target type should be added to or removed from
 * the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeTarget(Class, boolean)
 * @see #excludeChildren(int, boolean)
 * @see #excludeChildren(View, boolean)
 *
 * @param type The type to ignore when running this transition.
 * @param exclude Whether to add the target type to or remove it from the
 * current list of excluded target types.
 * @return This transition object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code has changed a method call from excludeType to excludeObject with the same parameters within the method body, but the return statement remains the same, thus indicating a change in the dependent API. Therefore, the code change type is 5.","Even though the method that is being called has changed, the return type 'this' remains the same, and there is no indication that the behavior of the 'excludeObject' method is different in terms of the exceptional flow or the effect on the 'Transition' object's state. Therefore, there seems to be no Compatibility Issue, so the CI type is 0."
347,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>",20,21,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>","<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>",0,"{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    tba.packageName = view.getContext().getPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        // Notify the served view that its previous input connection is finished
        notifyInputConnectionFinished();
        mServedInputConnection = ic;
        ControlledInputConnectionWrapper servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            InputBindResult res;
            if (windowGainingFocus != null) {
                res = mService.windowGainedFocus(mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext);
            } else {
                res = mService.startInput(mClient, servedContext, tba, controlFlags);
            }
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, ""ABORT input: no input method!"");
                        return true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    tba.packageName = view.getContext().getPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        // Notify the served view that its previous input connection is finished
        notifyInputConnectionFinished();
        mServedInputConnection = ic;
        ControlledInputConnectionWrapper servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            InputBindResult res;
            if (windowGainingFocus != null) {
                res = mService.windowGainedFocus(mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext);
            } else {
                res = mService.startInput(mClient, servedContext, tba, controlFlags);
            }
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, ""ABORT input: no input method!"");
                        return true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
348,<android.view.View: void setClipBounds(Rect)>,20,21,<android.view.View: void setClipBounds(Rect)>,<android.view.View: void setClipBounds(Rect)>,0,"{
    if (clipBounds != null) {
        if (clipBounds.equals(mClipBounds)) {
            return;
        }
        if (mClipBounds == null) {
            invalidate();
            mClipBounds = new Rect(clipBounds);
        } else {
            invalidate(Math.min(mClipBounds.left, clipBounds.left), Math.min(mClipBounds.top, clipBounds.top), Math.max(mClipBounds.right, clipBounds.right), Math.max(mClipBounds.bottom, clipBounds.bottom));
            mClipBounds.set(clipBounds);
        }
    } else {
        if (mClipBounds != null) {
            invalidate();
            mClipBounds = null;
        }
    }
}","{
    if (clipBounds != null) {
        if (clipBounds.equals(mClipBounds)) {
            return;
        }
        if (mClipBounds == null) {
            invalidate();
            mClipBounds = new Rect(clipBounds);
        } else {
            invalidate(Math.min(mClipBounds.left, clipBounds.left), Math.min(mClipBounds.top, clipBounds.top), Math.max(mClipBounds.right, clipBounds.right), Math.max(mClipBounds.bottom, clipBounds.bottom));
            mClipBounds.set(clipBounds);
        }
    } else {
        if (mClipBounds != null) {
            invalidate();
            mClipBounds = null;
        }
    }
    mRenderNode.setClipBounds(mClipBounds);
}",1,"/**
 * Sets a rectangular area on this view to which the view will be clipped
 * when it is drawn. Setting the value to null will remove the clip bounds
 * and the view will draw normally, using its full bounds.
 *
 * @param clipBounds The rectangular area, in the local coordinates of
 * this view, to which future drawing operations will be clipped.
 */
","/**
 * Sets a rectangular area on this view to which the view will be clipped
 * when it is drawn. Setting the value to null will remove the clip bounds
 * and the view will draw normally, using its full bounds.
 *
 * @param clipBounds The rectangular area, in the local coordinates of
 * this view, to which future drawing operations will be clipped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version of the implementation adds a new statement `mRenderNode.setClipBounds(mClipBounds);` at the end of the method. The control flow has not been changed and no new return statement or exception handling has been introduced, therefore, the code change type is 4.","The newly added statement does not affect the return type or value, nor does it introduce a new exception handling code. It is an internal change most likely to enhance or add additional functionality. Therefore, no compatibility issue of types 1 or 2 should arise from this particular change."
349,<android.animation.AnimatorSet.Builder: Builder before(Animator)>,20,21,<android.animation.AnimatorSet.Builder: Builder before(Animator)>,<android.animation.AnimatorSet.Builder: Builder before(Animator)>,0,"{
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(mCurrentNode, Dependency.AFTER);
    node.addDependency(dependency);
    return this;
}","{
    mReversible = false;
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(mCurrentNode, Dependency.AFTER);
    node.addDependency(dependency);
    return this;
}",1,"/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * ends.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method ends.
 */
","/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * ends.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method ends.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change in the code is the addition of the statement 'mReversible = false;'. This is an assignment to a field and does not affect return statements, exception handling, or control flow. Therefore, the code change type is 4.","The addition of 'mReversible = false;' does not affect the behavior of the method with regards to what it returns or the exceptions it might throw. There's no new return statement introduced, no existing return statement removed or changed, and exception handling has not changed. Thus, there is no Compatibility Issue, which is indicated as 0."
351,"<android.view.GLES20Canvas: void drawText(CharSequence,int,int,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawText(CharSequence,int,int,float,float,Paint)>","<android.view.GLES20Canvas: void drawText(CharSequence,int,int,float,float,Paint)>",0,"{
    int modifiers = setupModifiers(paint);
    try {
        if (text instanceof String || text instanceof SpannedString || text instanceof SpannableString) {
            nDrawText(mRenderer, text.toString(), start, end, x, y, paint.mBidiFlags, paint.mNativePaint);
        } else if (text instanceof GraphicsOperations) {
            ((GraphicsOperations) text).drawText(this, start, end, x, y, paint);
        } else {
            char[] buf = TemporaryBuffer.obtain(end - start);
            TextUtils.getChars(text, start, end, buf, 0);
            nDrawText(mRenderer, buf, 0, end - start, x, y, paint.mBidiFlags, paint.mNativePaint);
            TemporaryBuffer.recycle(buf);
        }
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (text instanceof String || text instanceof SpannedString || text instanceof SpannableString) {
        nDrawText(mRenderer, text.toString(), start, end, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
    } else if (text instanceof GraphicsOperations) {
        ((GraphicsOperations) text).drawText(this, start, end, x, y, paint);
    } else {
        char[] buf = TemporaryBuffer.obtain(end - start);
        TextUtils.getChars(text, start, end, buf, 0);
        nDrawText(mRenderer, buf, 0, end - start, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
        TemporaryBuffer.recycle(buf);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the parameters passed to the `nDrawText` function, as `paint.mNativeTypeface` is added as a new parameter. However, this additional parameter is always pulled from the same source (`paint` object) that is passed to the method in both versions. So, the code change type is 4 (Other statement changed) and 5 (Dependent API changed).","The change does not lead to a different variable value being returned or a different exception being thrown, and there's no control dependency change. It merely extends the information provided to a lower-level drawing function, which does not inherently suggest any change in behavior at the API level, provided that `paint.mNativeTypeface` existed and was correctly managed in both versions. Thus, there is no Compatibility Issue (0)."
352,<android.preference.PreferenceActivity: void switchToHeader(Header)>,20,21,<android.preference.PreferenceActivity: void switchToHeader(Header)>,<android.preference.PreferenceActivity: void switchToHeader(Header)>,0,"{
    if (mCurHeader == header) {
        // This is the header we are currently displaying.  Just make sure
        // to pop the stack up to its root state.
        getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE);
    } else {
        if (header.fragment == null) {
            throw new IllegalStateException(""can't switch to header that has no fragment"");
        }
        int direction = mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
        switchToHeaderInner(header.fragment, header.fragmentArguments, direction);
        setSelectedHeader(header);
    }
}","{
    if (mCurHeader == header) {
        // This is the header we are currently displaying.  Just make sure
        // to pop the stack up to its root state.
        getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE);
    } else {
        if (header.fragment == null) {
            throw new IllegalStateException(""can't switch to header that has no fragment"");
        }
        switchToHeaderInner(header.fragment, header.fragmentArguments);
        setSelectedHeader(header);
    }
}",1,"/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
","/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The line `int direction = mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);` has been removed and consequently, the parameter `direction` is no longer passed to the `switchToHeaderInner` method. This is an ""other statement changed"" case, so the code change type is 4.","The API's behavior should not be impacted by this change in terms of what it returns, nor should it impact exception handling as the removal of `direction` likely indicates an internal change in how `switchToHeaderInner` operates. It does not change the method signature or expected results from the method's execution, so there is no compatibility issue; hence, CI type is 0."
355,"<android.view.View: void setLayerType(int,Paint)>",20,21,"<android.view.View: void setLayerType(int,Paint)>","<android.view.View: void setLayerType(int,Paint)>",0,"{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    if (layerType == mLayerType) {
        if (layerType != LAYER_TYPE_NONE && paint != mLayerPaint) {
            mLayerPaint = paint == null ? new Paint() : paint;
            invalidateParentCaches();
            invalidate(true);
        }
        return;
    }
    // Destroy any previous software drawing cache if needed
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            destroyLayer(false);
        // fall through - non-accelerated views may use software layer mechanism instead
        case LAYER_TYPE_SOFTWARE:
            destroyDrawingCache();
            break;
        default:
            break;
    }
    mLayerType = layerType;
    final boolean layerDisabled = mLayerType == LAYER_TYPE_NONE;
    mLayerPaint = layerDisabled ? null : (paint == null ? new Paint() : paint);
    mLocalDirtyRect = layerDisabled ? null : new Rect();
    invalidateParentCaches();
    invalidate(true);
}","{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    boolean typeChanged = mRenderNode.setLayerType(layerType);
    if (!typeChanged) {
        setLayerPaint(paint);
        return;
    }
    // Destroy any previous software drawing cache if needed
    if (mLayerType == LAYER_TYPE_SOFTWARE) {
        destroyDrawingCache();
    }
    mLayerType = layerType;
    final boolean layerDisabled = (mLayerType == LAYER_TYPE_NONE);
    mLayerPaint = layerDisabled ? null : (paint == null ? new Paint() : paint);
    mRenderNode.setLayerPaint(mLayerPaint);
    // draw() behaves differently if we are on a layer, so we need to
    // invalidate() here
    invalidateParentCaches();
    invalidate(true);
}",1,"/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is superceded
 * by this view's alpha value.</p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE},
 * {@link #LAYER_TYPE_SOFTWARE} and {@link #LAYER_TYPE_HARDWARE}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The type of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
","/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is superceded
 * by this view's alpha value.</p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE},
 * {@link #LAYER_TYPE_SOFTWARE} and {@link #LAYER_TYPE_HARDWARE}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The type of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The 'if' condition that checks `mLayerType` and updates `mLayerPaint` has been replaced with a call to `mRenderNode.setLayerType(layerType)` and `setLayerPaint(paint)`. There is also a change in the control structure: the 'switch' statement has been simplified to an 'if' statement. The direct setting of `mLayerPaint` and `mLocalDirtyRect` has been removed, and a call to `mRenderNode.setLayerPaint(mLayerPaint)` has been added. The setLayerType and setLayerPaint method are potentially dependent APIs that may have changed, so the change types are 1,3,4,5.","The changes in exception handling have not been modified; however, the changes to the logic of setting `mLayerPaint`, controlling when caches are invalidated, and how the layer type is set and used could result in different behavior when calling `setLayerType`. Therefore, we have a Compatibility Issue caused by potentially different return values (the logic of the method has changed affecting its behavior), and the CI type is 1."
356,<android.content.SyncRequest.Builder: SyncRequest build()>,20,21,<android.content.SyncRequest.Builder: SyncRequest build()>,<android.content.SyncRequest.Builder: SyncRequest build()>,0,"{
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true);
    }
    mSyncConfigExtras.putLong(ContentResolver.SYNC_EXTRAS_EXPECTED_UPLOAD, mTxBytes);
    mSyncConfigExtras.putLong(ContentResolver.SYNC_EXTRAS_EXPECTED_DOWNLOAD, mRxBytes);
    mSyncConfigExtras.putInt(ContentResolver.SYNC_EXTRAS_PRIORITY, mPriority);
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        validatePeriodicExtras(mCustomExtras);
        validatePeriodicExtras(mSyncConfigExtras);
        // Verify that account and provider are not null.
        if (mAccount == null) {
            throw new IllegalArgumentException(""Account must not be null for periodic"" + "" sync."");
        }
        if (mAuthority == null) {
            throw new IllegalArgumentException(""Authority must not be null for periodic"" + "" sync."");
        }
    } else if (mSyncType == SYNC_TYPE_UNKNOWN) {
        throw new IllegalArgumentException(""Must call either syncOnce() or syncPeriodic()"");
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException(""Must specify an adapter with "" + ""setSyncAdapter(Account, String"");
    }
    return new SyncRequest(this);
}","{
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException(""Illegal extras were set"");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException(""Must specify an adapter with"" + "" setSyncAdapter(Account, String"");
    }
    return new SyncRequest(this);
}",1,"/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */
","/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2",The code changes include:,- The implementation logic of periodic check has changed.
357,"<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>",20,21,"<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>","<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>",0,"{
    try {
        sService.updateAppWidgetProvider(provider, views, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetProvider(provider, views);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Set the RemoteViews to use for all AppWidget instances for the supplied AppWidget provider.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * @param provider      The {@link ComponentName} for the {@link
 * android.content.BroadcastReceiver BroadcastReceiver} provider
 * for your AppWidget.
 * @param views         The RemoteViews object to show.
 */
","/**
 * Set the RemoteViews to use for all AppWidget instances for the supplied AppWidget provider.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * @param provider      The {@link ComponentName} for the {@link
 * android.content.BroadcastReceiver BroadcastReceiver} provider
 * for your AppWidget.
 * @param views         The RemoteViews object to show.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5",2,"There is a new control flow introduced (if statement checking if `mService` is null) which implies a return without calling `updateAppWidgetProvider`, and the invocation of updateAppWidgetProvider() now does not pass mContext.getUserId() parameter. These are classified as a control dependency change (3) and a dependent API change (5). Additionally, an early return statement is introduced, which is classified as an exception handling statement change (2).","Because of the newly introduced if statement, there might be scenarios where the late version of the method does nothing and returns early, which is different from the early version which always attempts to update the app widget provider. This is a Compatibility Issue caused by potential different exception handlings (2), considering that the earlier version will throw an exception while the late version might return without throwing an exception."
360,<android.appwidget.AppWidgetProviderInfo: String toString()>,20,21,<android.appwidget.AppWidgetProviderInfo: String toString()>,<android.appwidget.AppWidgetProviderInfo: String toString()>,0,"{
    return ""AppWidgetProviderInfo(provider="" + this.provider + "")"";
}","{
    return ""AppWidgetProviderInfo("" + getProfile() + '/' + provider + ')';
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The literal string within the return statement has been changed and now includes a new method call (getProfile()), which indicates a change in the format and potential content of the returned string. The change type is 1 for return statement changed, and 4 for other changes due to the addition of the method call.","This change in the return statement will make the API potentially return a different value than the earlier version. Therefore, the CI type is 1."
361,<android.os.PowerManager.WakeLock: void finalize()>,20,21,<android.os.PowerManager.WakeLock: void finalize()>,<android.os.PowerManager.WakeLock: void finalize()>,0,"{
    synchronized (mToken) {
        if (mHeld) {
            Log.wtf(TAG, ""WakeLock finalized while still held: "" + mTag);
            try {
                mService.releaseWakeLock(mToken, 0);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    synchronized (mToken) {
        if (mHeld) {
            Log.wtf(TAG, ""WakeLock finalized while still held: "" + mTag);
            Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0);
            try {
                mService.releaseWakeLock(mToken, 0);
            } catch (RemoteException e) {
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The line Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0); has been added to the late version. This is a tracing statement that does not affect the logic of the code path or modify return variables or exception handling, so the code change type is 4.","Since the added line is for tracing purposes and does not alter any return values or exception handling, it will not create a Compatibility Issue. Therefore, the CI type is 0."
362,"<android.app.ApplicationPackageManager: Drawable getDrawable(String,int,ApplicationInfo)>",20,21,"<android.app.ApplicationPackageManager: Drawable getDrawable(String,int,ApplicationInfo)>","<android.app.ApplicationPackageManager: Drawable getDrawable(String,int,ApplicationInfo)>",0,"{
    ResourceName name = new ResourceName(packageName, resid);
    Drawable dr = getCachedIcon(name);
    if (dr != null) {
        return dr;
    }
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, 0);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    try {
        Resources r = getResourcesForApplication(appInfo);
        dr = r.getDrawable(resid);
        if (false) {
            RuntimeException e = new RuntimeException(""here"");
            e.fillInStackTrace();
            Log.w(TAG, ""Getting drawable 0x"" + Integer.toHexString(resid) + "" from package "" + packageName + "": app scale="" + r.getCompatibilityInfo().applicationScale + "", caller scale="" + mContext.getResources().getCompatibilityInfo().applicationScale, e);
        }
        if (DEBUG_ICONS)
            Log.v(TAG, ""Getting drawable 0x"" + Integer.toHexString(resid) + "" from "" + r + "": "" + dr);
        putCachedIcon(name, dr);
        return dr;
    } catch (NameNotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for"" + appInfo.packageName);
    } catch (Resources.NotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for"" + appInfo.packageName + "": "" + e.getMessage());
    } catch (RuntimeException e) {
        // If an exception was thrown, fall through to return
        // default icon.
        Log.w(""PackageManager"", ""Failure retrieving icon 0x"" + Integer.toHexString(resid) + "" in package "" + packageName, e);
    }
    return null;
}","{
    ResourceName name = new ResourceName(packageName, resid);
    Drawable dr = getCachedIcon(name);
    if (dr != null) {
        return dr;
    }
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, sDefaultFlags);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    try {
        Resources r = getResourcesForApplication(appInfo);
        dr = r.getDrawable(resid);
        if (false) {
            RuntimeException e = new RuntimeException(""here"");
            e.fillInStackTrace();
            Log.w(TAG, ""Getting drawable 0x"" + Integer.toHexString(resid) + "" from package "" + packageName + "": app scale="" + r.getCompatibilityInfo().applicationScale + "", caller scale="" + mContext.getResources().getCompatibilityInfo().applicationScale, e);
        }
        if (DEBUG_ICONS)
            Log.v(TAG, ""Getting drawable 0x"" + Integer.toHexString(resid) + "" from "" + r + "": "" + dr);
        putCachedIcon(name, dr);
        return dr;
    } catch (NameNotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for "" + appInfo.packageName);
    } catch (Resources.NotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for "" + appInfo.packageName + "": "" + e.getMessage());
    } catch (RuntimeException e) {
        // If an exception was thrown, fall through to return
        // default icon.
        Log.w(""PackageManager"", ""Failure retrieving icon 0x"" + Integer.toHexString(resid) + "" in package "" + packageName, e);
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code has changed in the argument passed to the method getApplicationInfo from 0 to sDefaultFlags. This indicates a change to a constant value or variable being passed to a method call which is not a return statement or exception handling change, so it is classified as another statement change (4). Additionally, since the argument to a method call has changed, this suggests that a dependent API may have a different behavior due to the different input (5).","This change does not directly affect the return value or exception handling of the getDrawable method because the logic and the flow of the function remain the same; the default flags might change how getApplicationInfo behaves internally, but it does not necessarily affect the behavior of getDrawable in a way that would cause it to return different values or throw new exceptions based on the shown context. However, without knowing the internal implementation changes introduced by sDefaultFlags, we cannot be certain that there is no CI. Given the visible code and assuming sDefaultFlags would not change the nature of the exception or the Drawable returned, the pred_CI would be 0."
363,<android.content.res.TypedArray: int getIndexCount()>,20,21,<android.content.res.TypedArray: int getIndexCount()>,<android.content.res.TypedArray: int getIndexCount()>,0,"{
    return mIndices[0];
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return mIndices[0];
}",1,"/**
 * Return the number of indices in the array that actually have data.
 */
","/**
 * Return the number of indices in the array that actually have data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The late version introduces a new if condition that throws a RuntimeException if mRecycled is true, which did not exist in the early version. Therefore, the code change types are 2 (exception handling statement changed) and 3 (control dependency changed).","The introduction of a new if condition with a RuntimeException being thrown introduces a new behavior where the method could throw an exception it did not throw before. This is a potential compatibility issue because now the method can fail with an exception instead of always returning a value, so the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
366,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,20,21,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,0,"{
    try {
        return sService.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot fetchUuidsWithSdp"");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */
","/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version has added a null check for the service object along with an associated log message and early return if the service is null. Additionally, the variable 'service' is introduced to hold 'sService' reference. The changes are categorized as code change type 3 due to the addition of a conditional check (`if (service == null)`) which is a control structure change, and code change type 4 due to the addition of a new log statement and the use of a temporary variable 'service'.","The new null check for 'service' introduces a behavior where the method can return false early if the service is null, where previously it would have attempted the operation and caught a 'RemoteException'. Thus, it could lead to a different return outcome without reaching the try block. Therefore, there is potential for a Compatibility Issue of type 1 because the API can return a different value."
367,"<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>",20,21,"<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>","<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>",0,"{
    if (VDBG)
        Log.d(TAG, ""read in:  "" + mSocketIS + "" len: "" + length);
    int ret = mSocketIS.read(b, offset, length);
    if (ret < 0)
        throw new IOException(""bt socket closed, read return: "" + ret);
    if (VDBG)
        Log.d(TAG, ""read out:  "" + mSocketIS + "" ret: "" + ret);
    return ret;
}","{
    if (mSocketIS == null)
        throw new IOException(""read is called on null InputStream"");
    if (VDBG)
        Log.d(TAG, ""read in:  "" + mSocketIS + "" len: "" + length);
    int ret = mSocketIS.read(b, offset, length);
    if (ret < 0)
        throw new IOException(""bt socket closed, read return: "" + ret);
    if (VDBG)
        Log.d(TAG, ""read out:  "" + mSocketIS + "" ret: "" + ret);
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","An exception handling statement has been added (throw new IOException...) and a new condition is introduced, which changes the control dependency, so the change type is 2,3.","There is a new exception that could be thrown if mSocketIS is null, which wasn't handled in the early version, and an earlier return from the function due to this new check can change the flow of the method resulting in either a different exception being thrown or a different value being returned. Thus, the CI type is 1,2."
370,<android.widget.CompoundButton: Parcelable onSaveInstanceState()>,20,21,<android.widget.CompoundButton: Parcelable onSaveInstanceState()>,<android.widget.CompoundButton: Parcelable onSaveInstanceState()>,0,"{
    // Force our ancestor class to save its state
    setFreezesText(true);
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    ss.checked = isChecked();
    return ss;
}","{
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    ss.checked = isChecked();
    return ss;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the deletion of the method call setFreezesText(true), which is not a return, exception handling, or control dependency change, so the code change type is 4.","The removal of the setFreezesText(true) call doesn't cause a change in the value returned by onSaveInstanceState() nor does it introduce a difference in exception handling. Therefore, there should not be any compatibility issue because the state saved and the returned Parcelable object remain unchanged; as such, the CI type is 0."
371,"<android.view.animation.AnimationUtils: Interpolator loadInterpolator(Context,int)>",20,21,"<android.view.animation.AnimationUtils: Interpolator loadInterpolator(Context,int)>","<android.view.animation.AnimationUtils: Interpolator loadInterpolator(Context,int)>",0,"{
    XmlResourceParser parser = null;
    try {
        parser = context.getResources().getAnimation(id);
        return createInterpolatorFromXml(context, parser);
    } catch (XmlPullParserException ex) {
        NotFoundException rnf = new NotFoundException(""Can't load animation resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        NotFoundException rnf = new NotFoundException(""Can't load animation resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null)
            parser.close();
    }
}","{
    XmlResourceParser parser = null;
    try {
        parser = context.getResources().getAnimation(id);
        return createInterpolatorFromXml(context.getResources(), context.getTheme(), parser);
    } catch (XmlPullParserException ex) {
        NotFoundException rnf = new NotFoundException(""Can't load animation resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        NotFoundException rnf = new NotFoundException(""Can't load animation resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null)
            parser.close();
    }
}",1,"/**
 * Loads an {@link Interpolator} object from a resource
 *
 * @param context Application context used to access resources
 * @param id The resource id of the animation to load
 * @return The animation object reference by the specified id
 * @throws NotFoundException
 */
","/**
 * Loads an {@link Interpolator} object from a resource
 *
 * @param context Application context used to access resources
 * @param id The resource id of the animation to load
 * @return The animation object reference by the specified id
 * @throws NotFoundException
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API `createInterpolatorFromXml` is changed, as it now takes three parameters instead of two. The added parameters are `context.getResources()` and `context.getTheme()`, so the code change type is 5.","There is no Compatibility Issue detected since the change does not affect the behavior of `loadInterpolator` in a way that would lead to different return values or exceptions thrown by this method itself. The additional parameters passed to `createInterpolatorFromXml` provide the same context and should not alter the logic of `loadInterpolator`. Therefore, the API still handles exceptions and returns values in the same manner as before."
372,"<android.widget.NumberPicker.AccessibilityNodeProviderImpl: boolean performAction(int,int,Bundle)>",20,21,"<android.widget.NumberPicker.AccessibilityNodeProviderImpl: boolean performAction(int,int,Bundle)>","<android.widget.NumberPicker.AccessibilityNodeProviderImpl: boolean performAction(int,int,Bundle)>",0,"{
    switch(virtualViewId) {
        case View.NO_ID:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                requestAccessibilityFocus();
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                clearAccessibilityFocus();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
                        {
                            if (NumberPicker.this.isEnabled() && (getWrapSelectorWheel() || getValue() < getMaxValue())) {
                                changeValueByOne(true);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
                        {
                            if (NumberPicker.this.isEnabled() && (getWrapSelectorWheel() || getValue() > getMinValue())) {
                                changeValueByOne(false);
                                return true;
                            }
                        }
                        return false;
                }
            }
            break;
        case VIRTUAL_VIEW_ID_INPUT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_FOCUS:
                        {
                            if (NumberPicker.this.isEnabled() && !mInputText.isFocused()) {
                                return mInputText.requestFocus();
                            }
                        }
                        break;
                    case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
                        {
                            if (NumberPicker.this.isEnabled() && mInputText.isFocused()) {
                                mInputText.clearFocus();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                showSoftInput();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                mInputText.invalidate();
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                mInputText.invalidate();
                                return true;
                            }
                        }
                        return false;
                    default:
                        {
                            return mInputText.performAccessibilityAction(action, arguments);
                        }
                }
            }
            return false;
        case VIRTUAL_VIEW_ID_INCREMENT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                NumberPicker.this.changeValueByOne(true);
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_CLICKED);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
                                return true;
                            }
                        }
                        return false;
                }
            }
            return false;
        case VIRTUAL_VIEW_ID_DECREMENT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                final boolean increment = (virtualViewId == VIRTUAL_VIEW_ID_INCREMENT);
                                NumberPicker.this.changeValueByOne(increment);
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_CLICKED);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
                                return true;
                            }
                        }
                        return false;
                }
            }
            return false;
    }
    return super.performAction(virtualViewId, action, arguments);
}","{
    switch(virtualViewId) {
        case View.NO_ID:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                requestAccessibilityFocus();
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                clearAccessibilityFocus();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
                        {
                            if (NumberPicker.this.isEnabled() && (getWrapSelectorWheel() || getValue() < getMaxValue())) {
                                changeValueByOne(true);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
                        {
                            if (NumberPicker.this.isEnabled() && (getWrapSelectorWheel() || getValue() > getMinValue())) {
                                changeValueByOne(false);
                                return true;
                            }
                        }
                        return false;
                }
            }
            break;
        case VIRTUAL_VIEW_ID_INPUT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_FOCUS:
                        {
                            if (NumberPicker.this.isEnabled() && !mInputText.isFocused()) {
                                return mInputText.requestFocus();
                            }
                        }
                        break;
                    case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
                        {
                            if (NumberPicker.this.isEnabled() && mInputText.isFocused()) {
                                mInputText.clearFocus();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                performClick();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_LONG_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                performLongClick();
                                return true;
                            }
                            return false;
                        }
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                mInputText.invalidate();
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                mInputText.invalidate();
                                return true;
                            }
                        }
                        return false;
                    default:
                        {
                            return mInputText.performAccessibilityAction(action, arguments);
                        }
                }
            }
            return false;
        case VIRTUAL_VIEW_ID_INCREMENT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                NumberPicker.this.changeValueByOne(true);
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_CLICKED);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
                                return true;
                            }
                        }
                        return false;
                }
            }
            return false;
        case VIRTUAL_VIEW_ID_DECREMENT:
            {
                switch(action) {
                    case AccessibilityNodeInfo.ACTION_CLICK:
                        {
                            if (NumberPicker.this.isEnabled()) {
                                final boolean increment = (virtualViewId == VIRTUAL_VIEW_ID_INCREMENT);
                                NumberPicker.this.changeValueByOne(increment);
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_CLICKED);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView != virtualViewId) {
                                mAccessibilityFocusedView = virtualViewId;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
                                return true;
                            }
                        }
                        return false;
                    case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                        {
                            if (mAccessibilityFocusedView == virtualViewId) {
                                mAccessibilityFocusedView = UNDEFINED;
                                sendAccessibilityEventForVirtualView(virtualViewId, AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
                                return true;
                            }
                        }
                        return false;
                }
            }
            return false;
    }
    return super.performAction(virtualViewId, action, arguments);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
373,"<android.app.ApplicationPackageManager: void installPackageWithVerificationAndEncryption(Uri,IPackageInstallObserver,int,String,VerificationParams,ContainerEncryptionParams)>",20,21,"<android.app.ApplicationPackageManager: void installPackageWithVerificationAndEncryption(Uri,IPackageInstallObserver,int,String,VerificationParams,ContainerEncryptionParams)>","<android.app.ApplicationPackageManager: void installPackageWithVerificationAndEncryption(Uri,IPackageInstallObserver,int,String,VerificationParams,ContainerEncryptionParams)>",0,"{
    try {
        mPM.installPackageWithVerificationAndEncryption(packageURI, observer, flags, installerPackageName, verificationParams, encryptionParams);
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    installCommon(packageURI, new LegacyPackageInstallObserver(observer), flags, installerPackageName, verificationParams, encryptionParams);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within the try block was changed to a call to a different method (installCommon) with a modified set of arguments (new LegacyPackageInstallObserver(observer) instead of observer), and a catch block for RemoteException was deleted, so the code change type is 4,5.","Despite the change in the implementation, the removal of the RemoteException catch block won't cause a compatibility issue because this exception is a checked exception that was caught and the block was empty, indicating that the exception was ignored. The new implementation delegates the call to another method (installCommon), but for a user of the API, it does not change the expected behavior. Therefore, there is no compatibility issue, as the method signature remains the same and the API's contract regarding exceptions and return values does not change."
375,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,20,21,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,0,"{
    List<AccessibilityServiceInfo> services = null;
    try {
        services = mService.getEnabledAccessibilityServiceList(feedbackTypeFlags, mUserId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    return Collections.unmodifiableList(services);
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getEnabledAccessibilityServiceList(feedbackTypeFlags, userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}",1,"/**
 * Returns the {@link AccessibilityServiceInfo}s of the enabled accessibility services
 * for a given feedback type.
 *
 * @param feedbackTypeFlags The feedback type flags.
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 *
 * @see AccessibilityServiceInfo#FEEDBACK_AUDIBLE
 * @see AccessibilityServiceInfo#FEEDBACK_GENERIC
 * @see AccessibilityServiceInfo#FEEDBACK_HAPTIC
 * @see AccessibilityServiceInfo#FEEDBACK_SPOKEN
 * @see AccessibilityServiceInfo#FEEDBACK_VISUAL
 */
","/**
 * Returns the {@link AccessibilityServiceInfo}s of the enabled accessibility services
 * for a given feedback type.
 *
 * @param feedbackTypeFlags The feedback type flags.
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 *
 * @see AccessibilityServiceInfo#FEEDBACK_AUDIBLE
 * @see AccessibilityServiceInfo#FEEDBACK_GENERIC
 * @see AccessibilityServiceInfo#FEEDBACK_HAPTIC
 * @see AccessibilityServiceInfo#FEEDBACK_SPOKEN
 * @see AccessibilityServiceInfo#FEEDBACK_VISUAL
 * @see AccessibilityServiceInfo#FEEDBACK_BRAILLE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There is a mechanism change to obtain the 'service' and the 'userId' which are used later in the function (introducing synchronized block and checking if 'service' is null), an additional check for 'services' being null before returning it, and a change in the return value for null 'service'. These changes fall under 1,3,4 as they introduce control dependency changes, change in the return statement, and other changes in how the method behaves.","Given the additional condition that returns an empty list if 'service' is null or if 'services' is null after the try-catch block, the method can now return a different value than the previous version under certain conditions, leading to the potential Compatibility Issue caused by potential different return values or types, which is CI type 1."
376,"<android.widget.TextView.CharWrapper: int getTextRunCursor(int,int,int,int,int,Paint)>",20,21,"<android.widget.TextView.CharWrapper: int getTextRunCursor(int,int,int,int,int,Paint)>","<android.widget.TextView.CharWrapper: int getTextRunCursor(int,int,int,int,int,Paint)>",0,"{
    int contextCount = contextEnd - contextStart;
    return p.getTextRunCursor(mChars, contextStart + mStart, contextCount, flags, offset + mStart, cursorOpt);
}","{
    int contextCount = contextEnd - contextStart;
    return p.getTextRunCursor(mChars, contextStart + mStart, contextCount, dir, offset + mStart, cursorOpt);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There has been a change in a parameter (from 'flags' to 'dir') for the 'getTextRunCursor' method call, so the code change type is 4.","Though there is a parameter change, without further context on whether 'flags' and 'dir' impact the behavior differently, I cannot assume a Compatibility Issue solely based on the parameter name change. Therefore, based on the information provided, it seems there would be no Compatibility Issue, so the CI type is 0."
377,"<android.hardware.camera2.utils.CameraBinderDecorator.CameraBinderDecoratorListener: void onAfterInvocation(Method,Object[],Object)>",20,21,"<android.hardware.camera2.utils.CameraBinderDecorator.CameraBinderDecoratorListener: void onAfterInvocation(Method,Object[],Object)>","<android.hardware.camera2.utils.CameraBinderDecorator.CameraBinderDecoratorListener: void onAfterInvocation(Method,Object[],Object)>",0,"{
    // int return type => status_t => convert to exception
    if (m.getReturnType() == Integer.TYPE) {
        int returnValue = (Integer) result;
        switch(returnValue) {
            case NO_ERROR:
                return;
            case PERMISSION_DENIED:
                throw new SecurityException(""Lacking privileges to access camera service"");
            case ALREADY_EXISTS:
                // just means we tried to do an operation that already completed.
                return;
            case BAD_VALUE:
                throw new IllegalArgumentException(""Bad argument passed to camera service"");
            case DEAD_OBJECT:
                UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
            case EACCES:
                UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISABLED));
            case EBUSY:
                UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_IN_USE));
            case EUSERS:
                UncheckedThrow.throwAnyException(new CameraRuntimeException(MAX_CAMERAS_IN_USE));
            case ENODEV:
                UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DISCONNECTED));
            case EOPNOTSUPP:
                UncheckedThrow.throwAnyException(new CameraRuntimeException(CAMERA_DEPRECATED_HAL));
        }
        /**
         * Trap the rest of the negative return values. If we have known
         * error codes i.e. ALREADY_EXISTS that aren't really runtime
         * errors, then add them to the top switch statement
         */
        if (returnValue < 0) {
            throw new UnsupportedOperationException(String.format(""Unknown error %d"", returnValue));
        }
    }
}","{
    // int return type => status_t => convert to exception
    if (m.getReturnType() == Integer.TYPE) {
        int returnValue = (Integer) result;
        throwOnError(returnValue);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",2,"The entire switch-case block and the conditional block that threw an UnsupportedOperationException in the early version have been replaced with a single call to throwOnError(returnValue), so this is an ""Other statement changed"" (4). Moreover, this method call refers to a different API, which is a ""Dependent API changed"" (5).","The refactoring to use throwOnError(returnValue) changes the exception handling behavior but this refactoring appears to be structural, aiming to centralize error handling. If throwOnError(returnValue) correctly maps all the previous return values to their corresponding exceptions, then from the client code perspective, this should maintain the original behavior, so no CI would be caused by different return values or types. However, the Dependendent API change means there is a reliance on the implementation of throwOnError, which if different could lead to a CI due to different exception handling (2). The CI arises due to the possibility that throwOnError might not throw the same exceptions as the inline code in the early version."
378,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",20,21,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>","<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",0,"{
    if (extras == null) {
        throw new IllegalArgumentException(""Must specify extras."");
    }
    SyncRequest request = new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build();
    requestSync(request);
}","{
    requestSyncAsUser(account, authority, UserHandle.myUserId(), extras);
}",1,"/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * <li>Account</li>
 * <li>null</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
","/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * <li>Account</li>
 * <li>null</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has completely changed. It delegates the work to another method `requestSyncAsUser` with different parameters. The method signature, however, has not changed, and therefore is considered a change in a dependent API (5).","There are no different return types or values, and no different exceptions handled explicitly within the method. The behavior and output are expected to remain consistent across versions as long as the `requestSyncAsUser` and `UserHandle.myUserId()` methods provide the same functionality in context. Thus, there is no compatibility issue detected (0)."
379,<android.widget.Toast: void show()>,20,21,<android.widget.Toast: void show()>,<android.widget.Toast: void show()>,0,"{
    if (mNextView == null) {
        throw new RuntimeException(""setView must have been called"");
    }
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    try {
        service.enqueueToast(pkg, tn, mDuration);
    } catch (RemoteException e) {
    // Empty
    }
}","{
    if (mNextView == null) {
        throw new RuntimeException(""setView must have been called"");
    }
    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    try {
        service.enqueueToast(pkg, tn, mDuration);
    } catch (RemoteException e) {
    // Empty
    }
}",1,"/**
 * Show the view for the specified duration.
 */
","/**
 * Show the view for the specified duration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the implementation code is the call from `mContext.getPackageName()` to `mContext.getOpPackageName()`. It is a change in a dependent API call due to the invoked method changing, so the code change type is 4,5.","Since the exception handling block is empty in both versions and the only change is the method call to get the package name, which likely returns the same value for the purpose of identifying the caller's package, this would not cause a different behavior in how exceptions are handled or what the method returns (which is `void`). Therefore, there should be no compatibility issue, and the CI type is 0."
381,<android.widget.CalendarView: void setMaxDate(long)>,20,21,<android.widget.CalendarView: void setMaxDate(long)>,<android.widget.CalendarView: void setMaxDate(long)>,0,"{
    mTempDate.setTimeInMillis(maxDate);
    if (isSameDate(mTempDate, mMaxDate)) {
        return;
    }
    mMaxDate.setTimeInMillis(maxDate);
    // reinitialize the adapter since its range depends on max date
    mAdapter.init();
    Calendar date = mAdapter.mSelectedDate;
    if (date.after(mMaxDate)) {
        setDate(mMaxDate.getTimeInMillis());
    } else {
        // we go to the current date to force the ListView to query its
        // adapter for the shown views since we have changed the adapter
        // range and the base from which the later calculates item indices
        // note that calling setDate will not work since the date is the same
        goTo(date, false, true, false);
    }
}","{
    mDelegate.setMaxDate(maxDate);
}",1,"/**
 * Sets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param maxDate The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */
","/**
 * Sets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param maxDate The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire method's implementation was changed from a detailed procedure to a single method call to mDelegate.setMaxDate(maxDate). This includes the deletion of all the checks, condition handling, and adapter initialization logic within the method body, indicating that the underlying implementation has been offloaded to another method, hence the code change type is 1,5.","Considering the code now simply delegates the task of setting the max date, without any prior checks or logic it performed earlier, it can lead to different behavior. If the method mDelegate.setMaxDate implements additional or fewer checks than the previous implementation or even the same checks but in a different manner, this could potentially return different values. For example, the setDate(mMaxDate.getTimeInMillis()) call in case the selected date is after the new max date is now dependent on the new implementation in the delegate class. If mDelegate.setMaxDate(maxDate) handles this differently, the observed behavior when invoking this API might change, qualifying for CI type 1."
382,<android.app.ApplicationPackageManager: Drawable getApplicationLogo(String)>,20,21,<android.app.ApplicationPackageManager: Drawable getApplicationLogo(String)>,<android.app.ApplicationPackageManager: Drawable getApplicationLogo(String)>,0,"{
    return getApplicationLogo(getApplicationInfo(packageName, 0));
}","{
    return getApplicationLogo(getApplicationInfo(packageName, sDefaultFlags));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed by replacing the constant `0` with `sDefaultFlags` in the call to `getApplicationInfo()`. Since this is a change in the argument passed to another API method, the code change type is 4 for the other statement change and 5 for the dependent API changed.","There is no Compatibility Issue if `sDefaultFlags` is equivalent to `0`. Since there's no information that `sDefaultFlags` leads to different behavior, the CI type is 0. However, if `sDefaultFlags` does not equal `0` and this change in flags affects the behavior of `getApplicationInfo()` in a way that could affect the returned logo, then the corresponding CI type should be 1. But based on the information at hand and without knowing the value and implications of `sDefaultFlags`, we can't conclude if there's a compatibility issue. Therefore, we default to no Compatibility Issue, which is represented by 0."
383,<android.widget.AbsListView.RecycleBin: View getScrapView(int)>,20,21,<android.widget.AbsListView.RecycleBin: View getScrapView(int)>,<android.widget.AbsListView.RecycleBin: View getScrapView(int)>,0,"{
    if (mViewTypeCount == 1) {
        return retrieveFromScrap(mCurrentScrap, position);
    } else {
        int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap >= 0 && whichScrap < mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
    }
    return null;
}","{
    if (mViewTypeCount == 1) {
        return retrieveFromScrap(mCurrentScrap, position);
    } else {
        final int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap >= 0 && whichScrap < mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
    }
    return null;
}",1,"/**
 * @return A view from the ScrapViews collection. These are unordered.
 */
","/**
 * @return A view from the ScrapViews collection. These are unordered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no difference in the actual implementation except for a minor change from 'int' to 'final int', which does not affect functionality since the 'whichScrap' variable is already treated as final due to not being modified after initialization. The return statements remain unchanged, and no new control dependency or other changes are introduced.","As there are no changes in how the method behaves internally or externally, there is no compatibility issue between the two versions."
385,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",20,21,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>","<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",0,"{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException(""signedData is null"");
        }
        Collection encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException(""encCerts is empty"");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            cert = new X509CertImpl((org.apache.harmony.security.x509.Certificate) it.next());
        } else {
            throw new SignatureException(""signature contains no certificates"");
        }
        List sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException(""no signer infos!"");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery only handles SHA1withRSA and
        // SHA256withRSA signatures.  SignApk chooses which to use
        // based on the signature algorithm of the cert:
        // 
        // ""SHA256withRSA"" cert -> ""SHA256withRSA"" signature
        // ""SHA1withRSA"" cert   -> ""SHA1withRSA"" signature
        // ""MD5withRSA"" cert    -> ""SHA1withRSA"" signature (for backwards compatibility)
        // any other cert       -> SignApk fails
        // 
        // Here we ignore whatever the cert says, and instead use
        // whatever algorithm is used by the signature.
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + ""with"" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
}","{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException(""signedData is null"");
        }
        List<Certificate> encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException(""encCerts is empty"");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator<Certificate> it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            InputStream is = new ByteArrayInputStream(it.next().getEncoded());
            cert = (X509Certificate) cf.generateCertificate(is);
        } else {
            throw new SignatureException(""signature contains no certificates"");
        }
        List<SignerInfo> sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException(""no signer infos!"");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<X509Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (X509Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery only handles SHA1withRSA and
        // SHA256withRSA signatures.  SignApk chooses which to use
        // based on the signature algorithm of the cert:
        // 
        // ""SHA256withRSA"" cert -> ""SHA256withRSA"" signature
        // ""SHA1withRSA"" cert   -> ""SHA1withRSA"" signature
        // ""MD5withRSA"" cert    -> ""SHA1withRSA"" signature (for backwards compatibility)
        // any other cert       -> SignApk fails
        // 
        // Here we ignore whatever the cert says, and instead use
        // whatever algorithm is used by the signature.
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + ""with"" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
}",1,"/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
","/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
387,<android.hardware.usb.UsbDevice: UsbInterface getInterface(int)>,20,21,<android.hardware.usb.UsbDevice: UsbInterface getInterface(int)>,<android.hardware.usb.UsbDevice: UsbInterface getInterface(int)>,0,"{
    return (UsbInterface) mInterfaces[index];
}","{
    return getInterfaceList()[index];
}",1,"/**
 * Returns the {@link UsbInterface} at the given index.
 *
 * @return the interface
 */
","/**
 * Returns the {@link UsbInterface} at the given index.
 * For devices with multiple configurations, you will probably want to use
 * {@link UsbConfiguration#getInterface} instead.
 *
 * @return the interface
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method for obtaining a UsbInterface has changed from directly accessing the array `mInterfaces[index]` to calling `getInterfaceList()[index]`, so the code change type is 5.","There is no Compatibility Issue detected. Although the method of accessing the UsbInterface has changed, it's an internal change and no new behavior is introduced. Both implementations are designed to return the UsbInterface at the given index without altering the control flow. Therefore, the API should behave the same way in terms of the return value and exception handling, assuming `getInterfaceList()` encapsulates the same array `mInterfaces`."
389,"<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>",20,21,"<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>","<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>",0,"{
    check(address, prefixLength);
    int offset = prefixLength / 8;
    byte[] bytes = address.getAddress();
    if (offset < bytes.length) {
        for (bytes[offset] <<= prefixLength % 8; offset < bytes.length; ++offset) {
            if (bytes[offset] != 0) {
                throw new IllegalArgumentException(""Bad address"");
            }
        }
    }
    mRoutes.add(new RouteInfo(new LinkAddress(address, prefixLength), null));
    return this;
}","{
    check(address, prefixLength);
    int offset = prefixLength / 8;
    byte[] bytes = address.getAddress();
    if (offset < bytes.length) {
        for (bytes[offset] <<= prefixLength % 8; offset < bytes.length; ++offset) {
            if (bytes[offset] != 0) {
                throw new IllegalArgumentException(""Bad address"");
            }
        }
    }
    mRoutes.add(new RouteInfo(new LinkAddress(address, prefixLength), null));
    mConfig.updateAllowedFamilies(address);
    return this;
}",1,"/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
","/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * Adding a route implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has added a new statement ""mConfig.updateAllowedFamilies(address);"" which updates some configuration, and there are no changes to return values or exception handling, so the change type is 4.","Since the new statement does not affect the return value or the exceptions thrown by the method, it does not introduce a Compatibility Issue. The method still returns the same Builder object with an updated internal state, so there is no CI caused by potential different return values or types."
392,<android.app.ActivityThread.H: void handleMessage(Message)>,20,21,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case REQUEST_THUMBNAIL:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""requestThumbnail"");
            handleRequestThumbnail((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, (msg.arg1 & 1) != 0, msg.arg2, (msg.arg1 & 2) != 0);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, (msg.arg1 & 1) != 0, msg.arg2, (msg.arg1 & 1) != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
393,<android.view.View: void invalidate(boolean)>,20,21,<android.view.View: void invalidate(boolean)>,<android.view.View: void invalidate(boolean)>,0,"{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || isOpaque() != mLastIsOpaque) {
        mLastIsOpaque = isOpaque();
        mPrivateFlags &= ~PFLAG_DRAWN;
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final Rect r = ai.mTmpInvalRect;
            r.set(0, 0, mRight - mLeft, mBottom - mTop);
            // Don't call invalidate -- we don't want to internally scroll
            // our own bounds
            p.invalidateChild(this, r);
        }
    }
}","{
    invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);
}",1,"/**
 * This is where the invalidate() work actually happens. A full invalidate()
 * causes the drawing cache to be invalidated, but this function can be called with
 * invalidateCache set to false to skip that invalidation step for cases that do not
 * need it (for example, a component that remains at the same dimensions with the same
 * content).
 *
 * @param invalidateCache Whether the drawing cache for this view should be invalidated as
 * well. This is usually true for a full invalidate, but may be set to false if the
 * View's contents or dimensions have not changed.
 */
","/**
 * This is where the invalidate() work actually happens. A full invalidate()
 * causes the drawing cache to be invalidated, but this function can be
 * called with invalidateCache set to false to skip that invalidation step
 * for cases that do not need it (for example, a component that remains at
 * the same dimensions with the same content).
 *
 * @param invalidateCache Whether the drawing cache for this view should be
 * invalidated as well. This is usually true for a full
 * invalidate, but may be set to false if the View's contents or
 * dimensions have not changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early version of the code contains multiple control statements and assignments that directly modify the object's state, whereas the late version replaces this entire block with a call to the 'invalidateInternal' method. This counts as an 'Other statement changed' because various statements have been changed to a method call. Moreover, a 'Return statement changed' is observed since control paths that included return statements in the early implementation were not present in the late implementation. Finally, it is a 'Dependent API changed' as it now calls a different method ('invalidateInternal') that didn't appear in the early version, indicating the implementation is now dependent on this new API.","The shift from inline code to a method call (invalidateInternal), which encapsulates all the invalidation logic, can potentially change the behavior of the method and the exact process by which the view is invalidated. This encapsulation implies that any change in the behavior of 'invalidateInternal' can affect 'invalidate(boolean)', thereby potentially leading to different return types or values if 'invalidateInternal' has a different implementation or side effects. Hence, the CI type is 1."
394,<android.view.View: float getScaleY()>,20,21,<android.view.View: float getScaleY()>,<android.view.View: float getScaleY()>,0,"{
    return mTransformationInfo != null ? mTransformationInfo.mScaleY : 1;
}","{
    return mRenderNode.getScaleY();
}",1,"/**
 * The amount that the view is scaled in y around the pivot point, as a proportion of
 * the view's unscaled height. A value of 1, the default, means that no scaling is applied.
 *
 * <p>By default, this is 1.0f.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The scaling factor.
 */
","/**
 * The amount that the view is scaled in y around the pivot point, as a proportion of
 * the view's unscaled height. A value of 1, the default, means that no scaling is applied.
 *
 * <p>By default, this is 1.0f.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The scaling factor.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has changed from using `mTransformationInfo` to directly retrieving the scale via `mRenderNode.getScaleY()`. This indicates that the method is now relying on a potentially different underlying mechanism (or source of truth) for getting the Y scale, so the code change type is 1,5.","Since the source for the scale information has changed, it potentially returns a different value than the previous version which may lead to different behavior in apps that rely on this API; thus, the CI type is 1."
397,"<android.view.accessibility.AccessibilityNodeInfo.CollectionInfo: CollectionInfo obtain(int,int,boolean)>",20,21,"<android.view.accessibility.AccessibilityNodeInfo.CollectionInfo: CollectionInfo obtain(int,int,boolean)>","<android.view.accessibility.AccessibilityNodeInfo.CollectionInfo: CollectionInfo obtain(int,int,boolean)>",0,"{
    CollectionInfo info = sPool.acquire();
    return (info != null) ? info : new CollectionInfo(rowCount, columnCount, hierarchical);
}","{
    return obtain(rowCount, columnCount, hierarchical, SELECTION_MODE_NONE);
}",1,"/**
 * Obtains a pooled instance.
 *
 * @param rowCount The number of rows.
 * @param columnCount The number of columns.
 * @param hierarchical Whether the collection is hierarchical.
 */
","/**
 * Obtains a pooled instance.
 *
 * @param rowCount The number of rows.
 * @param columnCount The number of columns.
 * @param hierarchical Whether the collection is hierarchical.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed. In the early version, there is an object pool from which an instance is acquired or a new instance is created if the pool returns null. In the late version, the method directly calls another overload of the 'obtain' method, passing an additional hard-coded parameter, SELECTION_MODE_NONE, which indicates a dependent API change as well. So the code change type is 1,5.","Since the behavior of obtaining a CollectionInfo instance has changed (the method now always calls another method with an additional parameter), the API potentially returns a different object, which could have a different selection mode value than in the early version. The behavior differences arise due to the additional parameter set in the later version, thus resulting in a potential Compatibility Issue of type 1."
399,<android.app.Activity: ActionBar getActionBar()>,20,21,<android.app.Activity: ActionBar getActionBar()>,<android.app.Activity: ActionBar getActionBar()>,0,"{
    initActionBar();
    return mActionBar;
}","{
    initWindowDecorActionBar();
    return mActionBar;
}",1,"/**
 * Retrieve a reference to this activity's ActionBar.
 *
 * @return The Activity's ActionBar, or null if it does not have one.
 */
","/**
 * Retrieve a reference to this activity's ActionBar.
 *
 * @return The Activity's ActionBar, or null if it does not have one.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change is related to the method call for initializing the ActionBar; the method name changed from initActionBar() to initWindowDecorActionBar(). No changes in return statements or exception handling statements have been made, so the code change type is 4 for the method call change, and 5 for the dependent API change.","There is no Compatibility Issue in terms of returning different values or throwing different exceptions. The change in the method that initializes the ActionBar is internal and should not affect the return value of the getActionBar() API; hence, the CI type is 0."
400,"<android.animation.PropertyValuesHolder: PropertyValuesHolder ofKeyframe(Property,Keyframe)>",20,21,"<android.animation.PropertyValuesHolder: PropertyValuesHolder ofKeyframe(Property,Keyframe)>","<android.animation.PropertyValuesHolder: PropertyValuesHolder ofKeyframe(Property,Keyframe)>",0,"{
    KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
    if (keyframeSet instanceof IntKeyframeSet) {
        return new IntPropertyValuesHolder(property, (IntKeyframeSet) keyframeSet);
    } else if (keyframeSet instanceof FloatKeyframeSet) {
        return new FloatPropertyValuesHolder(property, (FloatKeyframeSet) keyframeSet);
    } else {
        PropertyValuesHolder pvh = new PropertyValuesHolder(property);
        pvh.mKeyframeSet = keyframeSet;
        pvh.mValueType = ((Keyframe) values[0]).getType();
        return pvh;
    }
}","{
    KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
    return ofKeyframes(property, keyframeSet);
}",1,"/**
 * Constructs and returns a PropertyValuesHolder object with the specified property and set
 * of values. These values can be of any type, but the type should be consistent so that
 * an appropriate {@link android.animation.TypeEvaluator} can be found that matches
 * the common type.
 * <p>If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling the property's
 * {@link android.util.Property#get(Object)} function.
 * Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction with
 * {@link ObjectAnimator}, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 * @param property The property associated with this set of values. Should not be null.
 * @param values The set of values to animate between.
 */
","/**
 * Constructs and returns a PropertyValuesHolder object with the specified property and set
 * of values. These values can be of any type, but the type should be consistent so that
 * an appropriate {@link android.animation.TypeEvaluator} can be found that matches
 * the common type.
 * <p>If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling the property's
 * {@link android.util.Property#get(Object)} function.
 * Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction with
 * {@link ObjectAnimator}, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 * @param property The property associated with this set of values. Should not be null.
 * @param values The set of values to animate between.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has been simplified by calling a new method 'ofKeyframes(property, keyframeSet)' instead of individually creating instances of `IntPropertyValuesHolder`, `FloatPropertyValuesHolder`, or `PropertyValuesHolder` based on conditions, and the control logic checks like instance checks are not present in the late implementation. This implies a change in the return statement, other statements, and dependent API, hence the classification 1,4,5.","Since the late implementation uses a new method `ofKeyframes` to create and return the PropertyValuesHolder, there is the likelihood that this method encapsulates the same logic checks and returns an instance based on the type of KeyframeSet, which was done explicitly in the previous version. If this is true, the returned value would still be a PropertyValuesHolder of the appropriate type. However, because there is no insight into how the new method `ofKeyframes` works, and because the instance checks and explicit casting have been removed, this change has the potential to return a different value compared to the early version if `ofKeyframes` does not replicate the old behaviour. This results in the CI type being 1."
402,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",20,21,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    int channelConfig = BlockingAudioTrack.getChannelConfig(channelCount);
    if (channelConfig == 0) {
        Log.e(TAG, ""Unsupported number of channels :"" + channelCount);
        return TextToSpeech.ERROR;
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""stop() called before start(), returning."");
            return TextToSpeech.ERROR;
        }
        SynthesisPlaybackQueueItem item = new SynthesisPlaybackQueueItem(mStreamType, sampleRateInHz, audioFormat, channelCount, mVolume, mPan, mDispatcher, mCallerIdentity, mLogger);
        mAudioTrackHandler.enqueue(item);
        mItem = item;
    }
    return TextToSpeech.SUCCESS;
}","{
    if (DBG)
        Log.d(TAG, ""start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    int channelConfig = BlockingAudioTrack.getChannelConfig(channelCount);
    synchronized (mStateLock) {
        if (channelConfig == 0) {
            Log.e(TAG, ""Unsupported number of channels :"" + channelCount);
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""stop() called before start(), returning."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mItem != null) {
            Log.e(TAG, ""Start called twice"");
            return TextToSpeech.ERROR;
        }
        SynthesisPlaybackQueueItem item = new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger);
        mAudioTrackHandler.enqueue(item);
        mItem = item;
    }
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The order of the checks for `channelConfig` and `mStopped` has changed along with the control flow. New exception handling logic is introduced using `errorCodeOnStop` instead of immediately returning `TextToSpeech.ERROR`. The `mStatusCode` variable is also now checked against `TextToSpeech.STOPPED` and `TextToSpeech.SUCCESS`, and a check for `mItem != null` is added which involves a new return statement for an error condition. Moreover, the instance creation of `SynthesisPlaybackQueueItem` uses `mAudioParams` in `new SynthesisPlaybackQueueItem` instead of separate parameters which also implies an update to a dependent API (`SynthesisPlaybackQueueItem` constructor). So the changes include change types 1,2,3,4,5.","Due to the added checks and modified control flows, the function could potentially return different error codes than before (type 1). Additionally, the introduction of `errorCodeOnStop` may result in different exceptions or error returns (type 2). Also, the previous synchronization block checked `mStopped` first, while in the late version the check of `channelConfig == 0` has been moved inside the block, and additional conditions have been introduced before creating `SynthesisPlaybackQueueItem`. Hence the API will behave differently under certain conditions which could lead to compatibility issues both in terms of different return values (type 1) and different exception handlings (type 2)."
404,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,20,21,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
405,<android.content.Intent: boolean filterEquals(Intent)>,20,21,<android.content.Intent: boolean filterEquals(Intent)>,<android.content.Intent: boolean filterEquals(Intent)>,0,"{
    if (other == null) {
        return false;
    }
    if (mAction != other.mAction) {
        if (mAction != null) {
            if (!mAction.equals(other.mAction)) {
                return false;
            }
        } else {
            if (!other.mAction.equals(mAction)) {
                return false;
            }
        }
    }
    if (mData != other.mData) {
        if (mData != null) {
            if (!mData.equals(other.mData)) {
                return false;
            }
        } else {
            if (!other.mData.equals(mData)) {
                return false;
            }
        }
    }
    if (mType != other.mType) {
        if (mType != null) {
            if (!mType.equals(other.mType)) {
                return false;
            }
        } else {
            if (!other.mType.equals(mType)) {
                return false;
            }
        }
    }
    if (mPackage != other.mPackage) {
        if (mPackage != null) {
            if (!mPackage.equals(other.mPackage)) {
                return false;
            }
        } else {
            if (!other.mPackage.equals(mPackage)) {
                return false;
            }
        }
    }
    if (mComponent != other.mComponent) {
        if (mComponent != null) {
            if (!mComponent.equals(other.mComponent)) {
                return false;
            }
        } else {
            if (!other.mComponent.equals(mComponent)) {
                return false;
            }
        }
    }
    if (mCategories != other.mCategories) {
        if (mCategories != null) {
            if (!mCategories.equals(other.mCategories)) {
                return false;
            }
        } else {
            if (!other.mCategories.equals(mCategories)) {
                return false;
            }
        }
    }
    return true;
}","{
    if (other == null) {
        return false;
    }
    if (!Objects.equals(this.mAction, other.mAction))
        return false;
    if (!Objects.equals(this.mData, other.mData))
        return false;
    if (!Objects.equals(this.mType, other.mType))
        return false;
    if (!Objects.equals(this.mPackage, other.mPackage))
        return false;
    if (!Objects.equals(this.mComponent, other.mComponent))
        return false;
    if (!Objects.equals(this.mCategories, other.mCategories))
        return false;
    return true;
}",1,"/**
 * Determine if two intents are the same for the purposes of intent
 * resolution (filtering). That is, if their action, data, type,
 * class, and categories are the same.  This does <em>not</em> compare
 * any extra data included in the intents.
 *
 * @param other The other Intent to compare against.
 *
 * @return Returns true if action, data, type, class, and categories
 * are the same.
 */
","/**
 * Determine if two intents are the same for the purposes of intent
 * resolution (filtering). That is, if their action, data, type,
 * class, and categories are the same.  This does <em>not</em> compare
 * any extra data included in the intents.
 *
 * @param other The other Intent to compare against.
 *
 * @return Returns true if action, data, type, class, and categories
 * are the same.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code has been refactored to use the Objects.equals method instead of the manual null checks and equality checks, resulting in a more concise condition statement. No new return or exception handling statements have been introduced or removed. Therefore, the code change types are 3 for control dependency change and 4 for other statement change.","There is no CI issue; the logic for comparing mAction, mData, mType, mPackage, mComponent, and mCategories remains equivalent between the two implementations, just expressed more concisely in the late version. The behavior of the API should be consistent and yield the same result, hence no potential different return values or exception handling."
408,<android.view.WindowManager.LayoutParams: String toString()>,20,21,<android.view.WindowManager.LayoutParams: String toString()>,<android.view.WindowManager.LayoutParams: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (preferredRefreshRate != 0) {
        sb.append("" preferredRefreshRate="");
        sb.append(preferredRefreshRate);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    if (!surfaceInsets.equals(Insets.NONE)) {
        sb.append("" surfaceInsets="").append(surfaceInsets);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
409,<android.os.Bundle: byte getByte(String)>,20,21,<android.os.Bundle: byte getByte(String)>,<android.os.Bundle: byte getByte(String)>,0,"{
    unparcel();
    return getByte(key, (byte) 0);
}","{
    return super.getByte(key);
}",1,"/**
 * Returns the value associated with the given key, or (byte) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a byte value
 */
","/**
 * Returns the value associated with the given key, or (byte) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a byte value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,1,"The implementation has changed to call `super.getByte(key)` instead of directly calling `getByte(key, (byte) 0)` after `unparcel()`, so a dependent API call has changed, which is categorized as 5.","Since the dependent API call in the method has changed, which could potentially alter the behavior of the API (for instance, if the superclass's implementation of `getByte` behaves differently compared to using a default value of `(byte) 0` when the key doesn't exist), the compatibility issue type is 1."
410,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,20,21,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,0,"{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.getScript(ICU.addLikelySubtags(locale.toString()));
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}","{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.addLikelySubtags(locale).getScript();
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}",1,"/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
","/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has been changed regarding how `scriptSubtag` is obtained: previously it was getting the script subtag using the `ICU.getScript(ICU.addLikelySubtags(locale.toString()))` and now it is getting it using `ICU.addLikelySubtags(locale).getScript()`. The dependent API `ICU.addLikelySubtags` is used differently in invoking the method, hence the type of change is 4,5.","There is no Compatibility Issue due to the following reasoning: Although there is a change in how the script subtag is retrieved, the logic to determine the layout direction remains unchanged. The conditional checks and the return values are the same in both versions. The change only affects the way the required information is obtained but does not actually change the behavior of the method from an external perspective. It is an internal change that should not affect the output as long as the new `ICU.addLikelySubtags(locale).getScript()` method call is a valid refactoring and returns the same result as the previous implementation in all cases. Assuming the dependent API provides the same output, no compatibility issue is introduced, hence the CI type is 0."
412,<android.bluetooth.BluetoothHealth: boolean doBind()>,20,21,<android.bluetooth.BluetoothHealth: boolean doBind()>,<android.bluetooth.BluetoothHealth: boolean doBind()>,0,"{
    Intent intent = new Intent(IBluetoothHealth.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindService(intent, mConnection, 0)) {
        Log.e(TAG, ""Could not bind to Bluetooth Health Service with "" + intent);
        return false;
    }
    return true;
}","{
    Intent intent = new Intent(IBluetoothHealth.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, android.os.Process.myUserHandle())) {
        Log.e(TAG, ""Could not bind to Bluetooth Health Service with "" + intent);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method call within the if statement has changed from mContext.bindService(intent, mConnection, 0) to mContext.bindServiceAsUser(intent, mConnection, 0, android.os.Process.myUserHandle()), which implies the use of a different method with additional parameters (`android.os.Process.myUserHandle()`). Hence, the code change type is 4,5.","Since a different method (bindServiceAsUser instead of bindService) with additional parameters has been called, this could potentially lead to a change in the return value of the doBind() method because the system could behave differently when binding to a service as a specific user. Therefore, the CI type is 1."
413,<android.os.Parcel: Serializable readSerializable()>,20,21,<android.os.Parcel: Serializable readSerializable()>,<android.os.Parcel: Serializable readSerializable()>,0,"{
    String name = readString();
    if (name == null) {
        // return null, which indicates that the name wasn't found in the parcel.
        return null;
    }
    byte[] serializedData = createByteArray();
    ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
    try {
        ObjectInputStream ois = new ObjectInputStream(bais);
        return (Serializable) ois.readObject();
    } catch (IOException ioe) {
        throw new RuntimeException(""Parcelable encountered "" + ""IOException reading a Serializable object (name = "" + name + "")"", ioe);
    } catch (ClassNotFoundException cnfe) {
        throw new RuntimeException(""Parcelable encountered"" + ""ClassNotFoundException reading a Serializable object (name = "" + name + "")"", cnfe);
    }
}","{
    return readSerializable(null);
}",1,"/**
 * Read and return a new Serializable object from the parcel.
 * @return the Serializable object, or null if the Serializable name
 * wasn't found in the parcel.
 */
","/**
 * Read and return a new Serializable object from the parcel.
 * @return the Serializable object, or null if the Serializable name
 * wasn't found in the parcel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the readSerializable method in the later version delegates to another method, readSerializable(null), which indicates a dependent API change. Moreover, as the internals of how the Serializable is read now depends on another method, we cannot guarantee that the returned value will be the same even if the parameter passed is null. Therefore, the code change type is 1,5.","Since the return statement directly delegates to another method, and the body of the original method is completely removed, it potentially changes the variable that is returned. This can lead to a different return value or type, and hence there is a potential Compatibility Issue of type 1."
414,"<android.view.MotionEvent.PointerCoords: void setAxisValue(int,float)>",20,21,"<android.view.MotionEvent.PointerCoords: void setAxisValue(int,float)>","<android.view.MotionEvent.PointerCoords: void setAxisValue(int,float)>",0,"{
    switch(axis) {
        case AXIS_X:
            x = value;
            break;
        case AXIS_Y:
            y = value;
            break;
        case AXIS_PRESSURE:
            pressure = value;
            break;
        case AXIS_SIZE:
            size = value;
            break;
        case AXIS_TOUCH_MAJOR:
            touchMajor = value;
            break;
        case AXIS_TOUCH_MINOR:
            touchMinor = value;
            break;
        case AXIS_TOOL_MAJOR:
            toolMajor = value;
            break;
        case AXIS_TOOL_MINOR:
            toolMinor = value;
            break;
        case AXIS_ORIENTATION:
            orientation = value;
            break;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException(""Axis out of range."");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 1L << axis;
                final int index = Long.bitCount(bits & (axisBit - 1L));
                float[] values = mPackedAxisValues;
                if ((bits & axisBit) == 0) {
                    if (values == null) {
                        values = new float[INITIAL_PACKED_AXIS_VALUES];
                        mPackedAxisValues = values;
                    } else {
                        final int count = Long.bitCount(bits);
                        if (count < values.length) {
                            if (index != count) {
                                System.arraycopy(values, index, values, index + 1, count - index);
                            }
                        } else {
                            float[] newValues = new float[count * 2];
                            System.arraycopy(values, 0, newValues, 0, index);
                            System.arraycopy(values, index, newValues, index + 1, count - index);
                            values = newValues;
                            mPackedAxisValues = values;
                        }
                    }
                    mPackedAxisBits = bits | axisBit;
                }
                values[index] = value;
            }
    }
}","{
    switch(axis) {
        case AXIS_X:
            x = value;
            break;
        case AXIS_Y:
            y = value;
            break;
        case AXIS_PRESSURE:
            pressure = value;
            break;
        case AXIS_SIZE:
            size = value;
            break;
        case AXIS_TOUCH_MAJOR:
            touchMajor = value;
            break;
        case AXIS_TOUCH_MINOR:
            touchMinor = value;
            break;
        case AXIS_TOOL_MAJOR:
            toolMajor = value;
            break;
        case AXIS_TOOL_MINOR:
            toolMinor = value;
            break;
        case AXIS_ORIENTATION:
            orientation = value;
            break;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException(""Axis out of range."");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                float[] values = mPackedAxisValues;
                if ((bits & axisBit) == 0) {
                    if (values == null) {
                        values = new float[INITIAL_PACKED_AXIS_VALUES];
                        mPackedAxisValues = values;
                    } else {
                        final int count = Long.bitCount(bits);
                        if (count < values.length) {
                            if (index != count) {
                                System.arraycopy(values, index, values, index + 1, count - index);
                            }
                        } else {
                            float[] newValues = new float[count * 2];
                            System.arraycopy(values, 0, newValues, 0, index);
                            System.arraycopy(values, index, newValues, index + 1, count - index);
                            values = newValues;
                            mPackedAxisValues = values;
                        }
                    }
                    mPackedAxisBits = bits | axisBit;
                }
                values[index] = value;
            }
    }
}",1,"/**
 * Sets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to assign.
 * @param value The value to set.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */
","/**
 * Sets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to assign.
 * @param value The value to set.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change involves bitwise operations when handling axes that are not predefined. Specifically, in setting axisBit and computing the index, different bitwise operations are used. Hence, the code change type is 4 (Other statement changed).","There is no change in the behavior of exception handling, return types, or control dependencies. So, there should be no Compatibility Issue since the functionality appears to perform the same action despite the change in bitwise operations, thus keeping the method's contract the same."
415,"<android.text.Layout: float measurePara(TextPaint,CharSequence,int,int)>",20,21,"<android.text.Layout: float measurePara(TextPaint,CharSequence,int,int)>","<android.text.Layout: float measurePara(TextPaint,CharSequence,int,int)>",0,"{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}","{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        // leading margins should be taken into account when measuring a paragraph
        int margin = 0;
        if (text instanceof Spanned) {
            Spanned spanned = (Spanned) text;
            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
            for (LeadingMarginSpan lms : spans) {
                margin += lms.getLeadingMargin(true);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return margin + tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"A new computation for `margin` is introduced and the final return value now includes this margin added to `tl.metrics(null)`. A new for-loop iteration is added to calculate the margin based on certain conditions. There's also a new local variable `margin` introduced, and this variable is a component of the return statement, which affects the method's behavior. So the code change types are 1 for the change in the return value, 3 for the addition of the control dependency due to the for-loop, and 4 for the additional lines of code that do not fit into other specified categories.","Since the return value now includes an additional `margin` that did not exist in the early version, the API could potentially return different values when the `text` parameter is an instance of `Spanned`, resulting in a different layout measurement. Therefore, there is a Compatibility Issue caused by potential different return values or types, and the CI type is 1."
416,<android.content.pm.ResolveInfo: int getIconResource()>,20,21,<android.content.pm.ResolveInfo: int getIconResource()>,<android.content.pm.ResolveInfo: int getIconResource()>,0,"{
    if (icon != 0)
        return icon;
    final ComponentInfo ci = getComponentInfo();
    if (ci != null)
        return ci.getIconResource();
    return 0;
}","{
    if (noResourceId)
        return 0;
    if (icon != 0)
        return icon;
    final ComponentInfo ci = getComponentInfo();
    if (ci != null) {
        return ci.getIconResource();
    }
    return 0;
}",1,"/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */
","/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new control statement 'if (noResourceId)' has been introduced and the order of 'if' statements has changed, so the code change type is 3.","There is no Compatibility Issue as the method still returns the icon resource ID correctly, it only adds an additional early return condition which does not affect the output for cases that would have previously returned a valid icon ID. Thus, the change does not lead to a different value being returned in scenarios where the previous version would have returned a valid result."
417,"<android.provider.DocumentsProvider: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",20,21,"<android.provider.DocumentsProvider: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>","<android.provider.DocumentsProvider: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",0,"{
    return openDocument(getDocumentId(uri), mode, signal);
}","{
    enforceTree(uri);
    return openDocument(getDocumentId(uri), mode, signal);
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocument(String, String, CancellationSignal)
 */
","/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocument(String, String, CancellationSignal)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"An additional enforcement method `enforceTree(uri)` has been inserted before the return statement. Thus, there is a change pertaining to other statements, marking it as change type 3. Since `enforceTree(uri)` does not impact the return value or the exceptions thrown, it implies change type 4.","The introduction of `enforceTree(uri)` does not inherently change the return value or add different exception handling. It seems to be a security or validation check on the input parameter `uri`. As such, there is no evidence indicating a potential Compatibility Issue, hence the CI type is 0."
419,"<android.bluetooth.BluetoothGattServer: boolean sendResponse(BluetoothDevice,int,int,int,byte[])>",20,21,"<android.bluetooth.BluetoothGattServer: boolean sendResponse(BluetoothDevice,int,int,int,byte[])>","<android.bluetooth.BluetoothGattServer: boolean sendResponse(BluetoothDevice,int,int,int,byte[])>",0,"{
    if (DBG)
        Log.d(TAG, ""sendResponse() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.sendResponse(mServerIf, device.getAddress(), requestId, status, offset, value);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""sendResponse() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.sendResponse(mServerIf, device.getAddress(), requestId, status, offset, value);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Send a response to a read or write request to a remote device.
 *
 * <p>This function must be invoked in when a remote read/write request
 * is received by one of these callback methods:
 *
 * <ul>
 * <li>{@link BluetoothGattServerCallback#onCharacteristicReadRequest}
 * <li>{@link BluetoothGattServerCallback#onCharacteristicWriteRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorReadRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorWriteRequest}
 * </ul>
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to send this response to
 * @param requestId The ID of the request that was received with the callback
 * @param status The status of the request to be sent to the remote devices
 * @param offset Value offset for partial read/write response
 * @param value The value of the attribute that was read/written (optional)
 */
","/**
 * Send a response to a read or write request to a remote device.
 *
 * <p>This function must be invoked in when a remote read/write request
 * is received by one of these callback methods:
 *
 * <ul>
 * <li>{@link BluetoothGattServerCallback#onCharacteristicReadRequest}
 * <li>{@link BluetoothGattServerCallback#onCharacteristicWriteRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorReadRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorWriteRequest}
 * </ul>
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to send this response to
 * @param requestId The ID of the request that was received with the callback
 * @param status The status of the request to be sent to the remote devices
 * @param offset Value offset for partial read/write response
 * @param value The value of the attribute that was read/written (optional)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change is the constant used for logging (DBG to VDBG); this does not affect the behavior of the method since it is only for debugging purposes. So the change is classified as type 4.,There is no Compatibility Issue as there is no substantive change in the method's functionality; it will still return the same values and handle exceptions in the same way as before. The logging change does not affect the API's external behavior.
420,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",20,21,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>","<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",0,"{
    if (msg.isInUse()) {
        throw new AndroidRuntimeException(msg + "" This message is already in use."");
    }
    if (msg.target == null) {
        throw new AndroidRuntimeException(""Message must have a target."");
    }
    synchronized (this) {
        if (mQuitting) {
            RuntimeException e = new RuntimeException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(""MessageQueue"", e.getMessage(), e);
            return false;
        }
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (; ; ) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        }
        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}","{
    if (msg.target == null) {
        throw new IllegalArgumentException(""Message must have a target."");
    }
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + "" This message is already in use."");
    }
    synchronized (this) {
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(""MessageQueue"", e.getMessage(), e);
            msg.recycle();
            return false;
        }
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (; ; ) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        }
        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The code changes include the exception type and the exception message being thrown, a different exception statement being introduced (msg.recycle()), and marking the message as in use (msg.markInUse()). Hence, it involves exception handling statement changed (2), control dependency changed (3) as recycling the message changes the behavior within the synchronized block if mQuitting is true, and other statement changed (4) due to the msg.markInUse() call.","The changed exceptions thrown and the additional call to msg.recycle() could potentially lead to different exception handlings. Previously, an AndroidRuntimeException could be thrown; now, IllegalArgumentException or IllegalStateException is thrown instead. The msg.recycle() call also introduces a new behavior when mQuitting is true, which is a change from the previous behavior. Therefore, the CI type is 2."
424,<android.widget.DatePicker: void setMinDate(long)>,20,21,<android.widget.DatePicker: void setMinDate(long)>,<android.widget.DatePicker: void setMinDate(long)>,0,"{
    mTempDate.setTimeInMillis(minDate);
    if (mTempDate.get(Calendar.YEAR) == mMinDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMinDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    mMinDate.setTimeInMillis(minDate);
    mCalendarView.setMinDate(minDate);
    if (mCurrentDate.before(mMinDate)) {
        mCurrentDate.setTimeInMillis(mMinDate.getTimeInMillis());
        updateCalendarView();
    }
    updateSpinners();
}","{
    mDelegate.setMinDate(minDate);
}",1,"/**
 * Sets the minimal date supported by this {@link NumberPicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param minDate The minimal supported date.
 */
","/**
 * Sets the minimal date supported by this {@link NumberPicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param minDate The minimal supported date.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"There's a complete overhaul of the implementation. The late implementation delegates the operation to mDelegate.setMinDate(minDate), which is significantly different from multiple operations in the early implementation like setting the mMinDate, updating the calendar view, checking conditions and updating spinners. Due to the method delegation, it indicates there's a dependent API change, so the change types are 1,5.","Considering the early version includes multiple evaluations and updates within the method, and the new implementation delegates all responsibility to another method, the behavior of the setMinDate API could be fundamentally different. This could lead to the API behaving differently which makes it a compatibility issue of type 1 (Return statement changed), since the values and side effects expected from the method could differ before and after the change."
425,<android.transition.TransitionSet: TransitionSet removeTarget(View)>,20,21,<android.transition.TransitionSet: TransitionSet removeTarget(View)>,<android.transition.TransitionSet: TransitionSet removeTarget(View)>,0,"{
    return (TransitionSet) super.removeTarget(target);
}","{
    for (int i = 0; i < mTransitions.size(); i++) {
        mTransitions.get(i).removeTarget(target);
    }
    return (TransitionSet) super.removeTarget(target);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new for-loop has been introduced before the return statement to remove the target from each transition in the collection. However, the actual type of the return value remains the same as both versions invoke the same method from the superclass and cast the result to TransitionSet, so the code change type is 4.","There is no compatibility issue because the method still behaves the same way in terms of the return type and value; the additional operations performed inside the method (removing the target from each transition) do not affect how the method returns the value to the caller, so the CI type is 0."
426,<android.view.accessibility.AccessibilityManager.MyHandler: void handleMessage(Message)>,20,21,<android.view.accessibility.AccessibilityManager.MyHandler: void handleMessage(Message)>,<android.view.accessibility.AccessibilityManager.MyHandler: void handleMessage(Message)>,0,"{
    switch(message.what) {
        case DO_SET_STATE:
            setState(message.arg1);
            return;
        default:
            Log.w(LOG_TAG, ""Unknown message type: "" + message.what);
    }
}","{
    switch(message.what) {
        case MSG_NOTIFY_ACCESSIBILITY_STATE_CHANGED:
            {
                handleNotifyAccessibilityStateChanged();
            }
            break;
        case MSG_NOTIFY_EXPLORATION_STATE_CHANGED:
            {
                handleNotifyTouchExplorationStateChanged();
            }
            break;
        case MSG_NOTIFY_HIGH_TEXT_CONTRAST_STATE_CHANGED:
            {
                handleNotifyHighTextContrastStateChanged();
            }
            break;
        case MSG_SET_STATE:
            {
                // See comment at mClient
                final int state = message.arg1;
                synchronized (mLock) {
                    setStateLocked(state);
                }
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,"The handleMessage method has had multiple changes. Switch case identifiers are changed to new constants, and the handling behavior of each case is changed with new method calls and some additional logic like synchronization. Moreover, the default case with the log warning is removed. These changes are classified as Return statement changed (1) due to the deletion of the return statement, Control dependency changed (3) because of the modification in switch-case structure and case handling, and Other statement changed (4) because of the addition of new methods, logic, and deletion of the log statement.","Despite the changes in the method's structure and behavior, they do not translate to a compatibility issue because the handleMessage method does not return a value to the caller (its return type is void), and the new implementation does not change the type or manner of exceptions that could be thrown. The API behavior in terms of observable output remains the same, so there is no compatibility issue (0). It will handle the messages as per the updated internal logic without affecting the client code that relies on this method."
427,"<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int,RemoteViews)>",20,21,"<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int,RemoteViews)>","<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int,RemoteViews)>",0,"{
    partiallyUpdateAppWidget(new int[] { appWidgetId }, views);
}","{
    if (mService == null) {
        return;
    }
    partiallyUpdateAppWidget(new int[] { appWidgetId }, views);
}",1,"/**
 * Perform an incremental update or command on the widget specified by appWidgetId.
 *
 * This update  differs from {@link #updateAppWidget(int, RemoteViews)} in that the RemoteViews
 * object which is passed is understood to be an incomplete representation of the widget, and
 * hence is not cached by the AppWidgetService. Note that because these updates are not cached,
 * any state that they modify that is not restored by restoreInstanceState will not persist in
 * the case that the widgets are restored using the cached version in AppWidgetService.
 *
 * Use with {@link RemoteViews#showNext(int)}, {@link RemoteViews#showPrevious(int)},
 * {@link RemoteViews#setScrollPosition(int, int)} and similar commands.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * This method will be ignored if a widget has not received a full update via
 * {@link #updateAppWidget(int[], RemoteViews)}.
 *
 * @param appWidgetId      The AppWidget instance for which to set the RemoteViews.
 * @param views            The RemoteViews object containing the incremental update / command.
 */
","/**
 * Perform an incremental update or command on the widget specified by appWidgetId.
 * <p>
 * This update  differs from {@link #updateAppWidget(int, RemoteViews)} in that the RemoteViews
 * object which is passed is understood to be an incomplete representation of the widget, and
 * hence is not cached by the AppWidgetService. Note that because these updates are not cached,
 * any state that they modify that is not restored by restoreInstanceState will not persist in
 * the case that the widgets are restored using the cached version in AppWidgetService.
 *
 * Use with {@link RemoteViews#showNext(int)}, {@link RemoteViews#showPrevious(int)},
 * {@link RemoteViews#setScrollPosition(int, int)} and similar commands.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * This method will be ignored if a widget has not received a full update via
 * {@link #updateAppWidget(int[], RemoteViews)}.
 *
 * @param appWidgetId      The AppWidget instance for which to set the RemoteViews.
 * @param views            The RemoteViews object containing the incremental update / command.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new control statement (if condition) has been added before calling the `partiallyUpdateAppWidget` method, so the code change type is 3.","There could be a scenario where `mService` is null, and as a result, the early version would attempt to proceed with the operation and potentially throw a NullPointerException, while the late version would not proceed and simply return. However, since the early version does not include any code after this check, the introduction of a return early in the method execution due to `mService` being null would not change the method's behavior from an API perspective. The method in either version does not proceed when `mService` is null. Thus, there is no Compatibility Issue."
428,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,20,21,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,0,"{
    if (DBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The condition debugging log has changed from DBG to VDBG, and a new synchronization block with a condition check and an update on `mDeviceBusy` has been introduced. The control dependency has changed in the addition of the synchronization block, and there's an 'Other statement changed' due to the update on the debugging condition, so the code change type is 3,4.","The added synchronization block and check do not introduce a new return value or change the exceptions thrown; they just prevent concurrent modifications which could potentially create race conditions. The method still returns the same values and handles exceptions in the same way as before; therefore, there is no Compatibility Issue, and the CI type is 0."
429,"<android.os.Bundle: boolean getBoolean(String,boolean)>",20,21,"<android.os.Bundle: boolean getBoolean(String,boolean)>","<android.os.Bundle: boolean getBoolean(String,boolean)>",0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (Boolean) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Boolean"", defaultValue, e);
        return defaultValue;
    }
}","{
    return super.getBoolean(key, defaultValue);
}",1,"/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a boolean value
 */
","/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a boolean value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The entire implementation of the method has been replaced by a call to super.getBoolean(key, defaultValue), so dependent API has changed (class type 5).","Even though the implementation now calls the superclass method, this does not inherently cause a Compatibility Issue, as the superclass method is expected to perform the same logic. There is no clear change in the method's behavior or signature that would lead to potential different return values or thrown exceptions, hence there is no Compatibility Issue (CI type 0)."
431,"<android.provider.DocumentsProvider: Cursor query(Uri,String[],String,String[],String)>",20,21,"<android.provider.DocumentsProvider: Cursor query(Uri,String[],String,String[],String)>","<android.provider.DocumentsProvider: Cursor query(Uri,String[],String,String[],String)>",0,"{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
                if (DocumentsContract.isManageMode(uri)) {
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, sortOrder);
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, sortOrder);
                }
            default:
                throw new UnsupportedOperationException(""Unsupported Uri "" + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, ""Failed during query"", e);
        return null;
    }
}","{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
            case MATCH_CHILDREN_TREE:
                enforceTree(uri);
                if (DocumentsContract.isManageMode(uri)) {
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, sortOrder);
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, sortOrder);
                }
            default:
                throw new UnsupportedOperationException(""Unsupported Uri "" + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, ""Failed during query"", e);
        return null;
    }
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #queryRoots(String[])
 * @see #queryRecentDocuments(String, String[])
 * @see #queryDocument(String, String[])
 * @see #queryChildDocuments(String, String[], String)
 * @see #querySearchDocuments(String, String, String[])
 */
","/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #queryRoots(String[])
 * @see #queryRecentDocuments(String, String[])
 * @see #queryDocument(String, String[])
 * @see #queryChildDocuments(String, String[], String)
 * @see #querySearchDocuments(String, String, String[])
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There are new case statements added (MATCH_DOCUMENT_TREE, MATCH_CHILDREN_TREE) in the switch control structure and a new call to `enforceTree(uri)` method within these cases. This counts as a control dependency change (3), and other statement changed (4) since there's an addition of a new method invocation.","There is no Compatibility Issue because the behavior of existing case statements didn't change. The new cases handle additional Uri matchings and do not alter the behavior of the existing Uri patterns. While there is a change that would affect how new Uri patterns are handled, it would not affect the results of calls to the API made with the same arguments before and after the change."
433,"<android.text.format.DateFormat: String getBestDateTimePattern(Locale,String)>",20,21,"<android.text.format.DateFormat: String getBestDateTimePattern(Locale,String)>","<android.text.format.DateFormat: String getBestDateTimePattern(Locale,String)>",0,"{
    return ICU.getBestDateTimePattern(skeleton, locale.toString());
}","{
    return ICU.getBestDateTimePattern(skeleton, locale);
}",1,"/**
 * Returns the best possible localized form of the given skeleton for the given
 * locale. A skeleton is similar to, and uses the same format characters as, a Unicode
 * <a href=""http://www.unicode.org/reports/tr35/#Date_Format_Patterns"">UTS #35</a>
 * pattern.
 *
 * <p>One difference is that order is irrelevant. For example, ""MMMMd"" will return
 * ""MMMM d"" in the {@code en_US} locale, but ""d. MMMM"" in the {@code de_CH} locale.
 *
 * <p>Note also in that second example that the necessary punctuation for German was
 * added. For the same input in {@code es_ES}, we'd have even more extra text:
 * ""d 'de' MMMM"".
 *
 * <p>This method will automatically correct for grammatical necessity. Given the
 * same ""MMMMd"" input, this method will return ""d LLLL"" in the {@code fa_IR} locale,
 * where stand-alone months are necessary. Lengths are preserved where meaningful,
 * so ""Md"" would give a different result to ""MMMd"", say, except in a locale such as
 * {@code ja_JP} where there is only one length of month.
 *
 * <p>This method will only return patterns that are in CLDR, and is useful whenever
 * you know what elements you want in your format string but don't want to make your
 * code specific to any one locale.
 *
 * @param locale the locale into which the skeleton should be localized
 * @param skeleton a skeleton as described above
 * @return a string pattern suitable for use with {@link java.text.SimpleDateFormat}.
 */
","/**
 * Returns the best possible localized form of the given skeleton for the given
 * locale. A skeleton is similar to, and uses the same format characters as, a Unicode
 * <a href=""http://www.unicode.org/reports/tr35/#Date_Format_Patterns"">UTS #35</a>
 * pattern.
 *
 * <p>One difference is that order is irrelevant. For example, ""MMMMd"" will return
 * ""MMMM d"" in the {@code en_US} locale, but ""d. MMMM"" in the {@code de_CH} locale.
 *
 * <p>Note also in that second example that the necessary punctuation for German was
 * added. For the same input in {@code es_ES}, we'd have even more extra text:
 * ""d 'de' MMMM"".
 *
 * <p>This method will automatically correct for grammatical necessity. Given the
 * same ""MMMMd"" input, this method will return ""d LLLL"" in the {@code fa_IR} locale,
 * where stand-alone months are necessary. Lengths are preserved where meaningful,
 * so ""Md"" would give a different result to ""MMMd"", say, except in a locale such as
 * {@code ja_JP} where there is only one length of month.
 *
 * <p>This method will only return patterns that are in CLDR, and is useful whenever
 * you know what elements you want in your format string but don't want to make your
 * code specific to any one locale.
 *
 * @param locale the locale into which the skeleton should be localized
 * @param skeleton a skeleton as described above
 * @return a string pattern suitable for use with {@link java.text.SimpleDateFormat}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The parameter passed to the method ICU.getBestDateTimePattern() has changed from locale.toString() to locale, indicating a change in the dependent API.","There is no direct indication that the change from using locale.toString() to using locale as a parameter will cause the API to return different values, as long as ICU.getBestDateTimePattern() is expected to handle both calls appropriately. However, without precise documentation on ICU.getBestDateTimePattern()'s implementation and handling of these two types of inputs, we cannot definitively rule out a behavior change. But strictly following the instructions given, this should not be considered a compatibility issue since it seems to be an internal change to how the parameter is passed, and it's assumed the API will handle Locale objects correctly. Thus, there is no Compatibility Issue."
434,"<android.widget.AbsListView: View obtainView(int,boolean[])>",20,21,"<android.widget.AbsListView: View obtainView(int,boolean[])>","<android.widget.AbsListView: View obtainView(int,boolean[])>",0,"{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                mRecycler.addScrapView(updatedView, position);
            }
        }
        // Scrap view implies temporary detachment.
        isScrap[0] = true;
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;
            // recycle this view and bind it to different data.
            if (child.isAccessibilityFocused()) {
                child.clearAccessibilityFocus();
            }
            child.dispatchFinishTemporaryDetach();
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}","{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }
        // Scrap view implies temporary detachment.
        isScrap[0] = true;
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;
            child.dispatchFinishTemporaryDetach();
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    setItemViewLayoutParams(child, position);
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}",1,"/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
","/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
435,<android.view.accessibility.AccessibilityManager: void interrupt()>,20,21,<android.view.accessibility.AccessibilityManager: void interrupt()>,<android.view.accessibility.AccessibilityManager: void interrupt()>,0,"{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    try {
        mService.interrupt(mUserId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
        }
        userId = mUserId;
    }
    try {
        service.interrupt(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}",1,"/**
 * Requests feedback interruption from all accessibility services.
 */
","/**
 * Requests feedback interruption from all accessibility services.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The late version of the method implementation includes control dependency changes due to the addition of a synchronized block on `mLock`, which changes how and when the check for a non-null `service` occurs. This adds a `return` statement inside the synchronized block for cases where `service` is null, which did not exist in the early version. The check for `mIsEnabled` and the retrieval of `userId` are also relocated inside this synchronized block. There's a change of the dependent API from `mService.interrupt(mUserId)` to `service.interrupt(userId)` after storing the values from the synchronized block. The overall statement and the way these variables are accessed have been changed. Additionally, the variable names used for the service and userId have been changed within the implementation, which indicates other statement changes. These alterations can all influence the behavior of the API.","The different control flow introduced by the new `return` statement and the synchronization can lead to returning earlier than the early version under some conditions (specifically, when `service` is null). This represents a change in the API behavior that could result in a different outcome, hence there is a compatibility issue due to potential different return values or types. The changes also modify the timing and conditions under which an `IllegalStateException` is thrown, which could lead to compatibility issues due to a change in exception handling, although the same exception is thrown for essentially the same condition (`mIsEnabled` being false)."
436,<android.view.View: float getY()>,20,21,<android.view.View: float getY()>,<android.view.View: float getY()>,0,"{
    return mTop + (mTransformationInfo != null ? mTransformationInfo.mTranslationY : 0);
}","{
    return mTop + getTranslationY();
}",1,"/**
 * The visual y position of this view, in pixels. This is equivalent to the
 * {@link #setTranslationY(float) translationY} property plus the current
 * {@link #getTop() top} property.
 *
 * @return The visual y position of this view, in pixels.
 */
","/**
 * The visual y position of this view, in pixels. This is equivalent to the
 * {@link #setTranslationY(float) translationY} property plus the current
 * {@link #getTop() top} property.
 *
 * @return The visual y position of this view, in pixels.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,5,0,"The return statement has changed from using a conditional expression (ternary operator) to directly calling a method getTranslationY(). Since getTranslationY() is likely an accessor for mTransformationInfo.mTranslationY, this likely represents a refactor where the same value is being returned but with improved code clarity. The code change type is 5 because this depends on the implementation of getTranslationY().","As long as getTranslationY() is returning mTransformationInfo.mTranslationY value (or the equivalent, given that mTransformationInfo is not null), it will not cause a CI in terms of different return values or types. However, the change could potentially introduce CI if getTranslationY() has its own exception handling different from the inline null check in the early version. But based on typical accessor method practices in Java, getTranslationY() would likely not introduce such a change, and therefore, there is no expected CI. Thus the CI type is 0."
437,<android.view.View: float getRotation()>,20,21,<android.view.View: float getRotation()>,<android.view.View: float getRotation()>,0,"{
    return mTransformationInfo != null ? mTransformationInfo.mRotation : 0;
}","{
    return mRenderNode.getRotation();
}",1,"/**
 * The degrees that the view is rotated around the pivot point.
 *
 * @see #setRotation(float)
 * @see #getPivotX()
 * @see #getPivotY()
 *
 * @return The degrees of rotation.
 */
","/**
 * The degrees that the view is rotated around the pivot point.
 *
 * @see #setRotation(float)
 * @see #getPivotX()
 * @see #getPivotY()
 *
 * @return The degrees of rotation.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed the source of the rotation value from mTransformationInfo.mRotation to mRenderNode.getRotation(), and the method from which the return value is obtained has been changed. The late version uses a method call to mRenderNode.getRotation() instead of a direct field access, so the code change type is 1,5.","Because the late version is getting the rotation value from a different method within a potentially different object (mRenderNode instead of mTransformationInfo), the API could return a different value, and this constitutes a CI. The late version of the API may behave differently, particularly if the mRenderNode's rotation value does not match what would have been found in mTransformationInfo.mRotation. Thus, the CI type is 1."
438,<android.widget.GridLayout.Spec: int getFlexibility()>,20,21,<android.widget.GridLayout.Spec: int getFlexibility()>,<android.widget.GridLayout.Spec: int getFlexibility()>,0,"{
    return (alignment == UNDEFINED_ALIGNMENT) ? INFLEXIBLE : CAN_STRETCH;
}","{
    return (alignment == UNDEFINED_ALIGNMENT && weight == 0) ? INFLEXIBLE : CAN_STRETCH;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The conditional expression in the return statement has an added condition for checking 'weight == 0', and thus both a control dependency change (as the condition for returning 'INFLEXIBLE' is now different) and a change in the return statement occur, so the change type is 1,3.","This change in the conditional logic can potentially lead to different return values under certain circumstances, specifically when the 'alignment' is 'UNDEFINED_ALIGNMENT' and 'weight' is not zero, the function would now return 'CAN_STRETCH' instead of 'INFLEXIBLE'. Hence the CI type is 1 due to potential different return values."
441,"<android.widget.TextView: int getTextColor(Context,TypedArray,int)>",20,21,"<android.widget.TextView: int getTextColor(Context,TypedArray,int)>","<android.widget.TextView: int getTextColor(Context,TypedArray,int)>",0,"{
    ColorStateList colors = getTextColors(context, attrs);
    if (colors == null) {
        return def;
    } else {
        return colors.getDefaultColor();
    }
}","{
    final ColorStateList colors = getTextColors(context, attrs);
    if (colors == null) {
        return def;
    } else {
        return colors.getDefaultColor();
    }
}",1,"/**
 * Returns the default color from the TextView_textColor attribute
 * from the AttributeSet, if set, or the default color from the
 * TextAppearance_textColor from the TextView_textAppearance attribute,
 * if TextView_textColor was not set directly.
 */
","/**
 * Returns the default color from the TextView_textColor attribute from the
 * AttributeSet, if set, or the default color from the
 * TextAppearance_textColor from the TextView_textAppearance attribute, if
 * TextView_textColor was not set directly.
 *
 * @removed
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes in implementation other than the addition of 'final' modifier to the 'colors' variable, which doesn't affect the API behavior.","Since there's no change in behavior of the API, there's no Compatibility Issue."
444,<android.service.dreams.DreamService: boolean dispatchTouchEvent(MotionEvent)>,20,21,<android.service.dreams.DreamService: boolean dispatchTouchEvent(MotionEvent)>,<android.service.dreams.DreamService: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    // but finish()es on any other kind of activity
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Finishing on touchEvent"");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchTouchEvent(event);
}","{
    // but finish()es on any other kind of activity
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on touchEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTouchEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"There are changes in a conditional branch of the method, including a modification from calling safelyFinish() to calling wakeUp(), and a change in the log message from ""Finishing on touchEvent"" to ""Waking up on touchEvent"". The control dependency change is about the if condition body getting modified to perform different operations. The return type is the same, but the action taken (what the return value signifies) is different, so the change type is 1,3.","The change in the conditional branch of the code from safelyFinish() to wakeUp() results in different behavior when the condition `!mInteractive` evaluates to true. Previously, the method would finish, and now it wakes up instead. This behavioral change means that the API could return the same value (true) but for a different reason leading to different resultant states, hence the CI type is 1."
445,"<android.bluetooth.BluetoothGattServer: boolean notifyCharacteristicChanged(BluetoothDevice,BluetoothGattCharacteristic,boolean)>",20,21,"<android.bluetooth.BluetoothGattServer: boolean notifyCharacteristicChanged(BluetoothDevice,BluetoothGattCharacteristic,boolean)>","<android.bluetooth.BluetoothGattServer: boolean notifyCharacteristicChanged(BluetoothDevice,BluetoothGattCharacteristic,boolean)>",0,"{
    if (DBG)
        Log.d(TAG, ""notifyCharacteristicChanged() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    try {
        mService.sendNotification(mServerIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), confirm, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""notifyCharacteristicChanged() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    if (characteristic.getValue() == null) {
        throw new IllegalArgumentException(""Chracteristic value is empty. Use "" + ""BluetoothGattCharacteristic#setvalue to update"");
    }
    try {
        mService.sendNotification(mServerIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), confirm, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Send a notification or indication that a local characteristic has been
 * updated.
 *
 * <p>A notification or indication is sent to the remote device to signal
 * that the characteristic has been updated. This function should be invoked
 * for every client that requests notifications/indications by writing
 * to the ""Client Configuration"" descriptor for the given characteristic.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to receive the notification/indication
 * @param characteristic The local characteristic that has been updated
 * @param confirm true to request confirmation from the client (indication),
 * false to send a notification
 * @return true, if the notification has been triggered successfully
 */
","/**
 * Send a notification or indication that a local characteristic has been
 * updated.
 *
 * <p>A notification or indication is sent to the remote device to signal
 * that the characteristic has been updated. This function should be invoked
 * for every client that requests notifications/indications by writing
 * to the ""Client Configuration"" descriptor for the given characteristic.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to receive the notification/indication
 * @param characteristic The local characteristic that has been updated
 * @param confirm true to request confirmation from the client (indication),
 * false to send a notification
 * @throws IllegalArgumentException
 * @return true, if the notification has been triggered successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","There is a change in the control dependency, as a new 'if' statement is introduced to check if characteristic.getValue() is null and throwing an IllegalArgumentException. The debug log has also changed from DBG to VDBG, and the debug message has stayed the same, so these constitute other statement changes (type 4), but without a compatibility issue. The added check for the characteristic value being null changes how the API behaves, which leads to both new return value possibilities and a new exception that can be thrown.","The introduced control structure (if statement) with a new exception throwing (IllegalArgumentException) indicates a compatibility issue of type 2 because the API will throw an exception where previously it would not. Furthermore, the introduced control structure may prevent the method from reaching its previous 'return true' execution path if the new condition (characteristic.getValue() == null) is met, which can lead to a different return value (by throwing the exception instead), therefore there is a compatibility issue of type 1."
446,<android.widget.CalendarView: int getWeekSeparatorLineColor()>,20,21,<android.widget.CalendarView: int getWeekSeparatorLineColor()>,<android.widget.CalendarView: int getWeekSeparatorLineColor()>,0,"{
    return mWeekSeparatorLineColor;
}","{
    return mDelegate.getWeekSeparatorLineColor();
}",1,"/**
 * Gets the color for the separator line between weeks.
 *
 * @return The week separator color.
 *
 * @attr ref android.R.styleable#CalendarView_weekSeparatorLineColor
 */
","/**
 * Gets the color for the separator line between weeks.
 *
 * @return The week separator color.
 *
 * @attr ref android.R.styleable#CalendarView_weekSeparatorLineColor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method is altered to return the value from a different source: initially it returns a direct field access mWeekSeparatorLineColor, and in the late version it calls a method on the mDelegate object to obtain the value. This means there is a change in both the return statement and a dependent API, so the code change types are 1 and 5.","Since the source of the returned value has changed, there's the potential for the method to return a different value if the delegate's implementation of getWeekSeparatorLineColor() is different from the direct field access that was used before. Thus, the CI type is 1."
447,<android.widget.CalendarView: int getFirstDayOfWeek()>,20,21,<android.widget.CalendarView: int getFirstDayOfWeek()>,<android.widget.CalendarView: int getFirstDayOfWeek()>,0,"{
    return mFirstDayOfWeek;
}","{
    return mDelegate.getFirstDayOfWeek();
}",1,"/**
 * Gets the first day of week.
 *
 * @return The first day of the week conforming to the {@link CalendarView}
 * APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */
","/**
 * Gets the first day of week.
 *
 * @return The first day of the week conforming to the {@link CalendarView}
 * APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method's return value source has changed from a direct variable access (mFirstDayOfWeek) to a delegated method call (mDelegate.getFirstDayOfWeek()), so the code change types are 1,5.","Since the method now returns the result of a call to another method rather than directly accessing a variable, it could potentially return a different value if the implementation of getFirstDayOfWeek in the mDelegate object differs from the previous direct variable access. This change could cause a Compatibility Issue of type 1 due to different return values."
448,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",20,21,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>","<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",0,"{
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""inflate"");
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = mContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                View temp;
                if (TAG_1995.equals(name)) {
                    temp = new BlinkLayout(mContext, attrs);
                } else {
                    temp = createViewFromTag(root, name, attrs);
                }
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp
                rInflate(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (IOException e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        return result;
    }
}","{
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""inflate"");
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = mContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, attrs, false, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, attrs, false);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp
                rInflate(parser, temp, attrs, true, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (IOException e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        return result;
    }
}",1,"/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
","/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
450,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",20,21,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(uri, modeFlags);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}",1,"/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method ActivityManagerNative.getDefault().releasePersistableUriPermission() now takes different parameters, introducing two new method calls: ContentProvider.getUriWithoutUserId(uri) and resolveUserId(uri). Thus, the code change types are 4 and 5.","Even though the dependent API has been changed with additional method calls, there is no Compatibility Issue since the try block's behavior remains the same in terms of both values returned and exceptions thrown – any RemoteException is caught, and the method return type is void, so no change in the returned value or thrown exception is introduced. Therefore, the CI type is 0."
451,<android.widget.ListView: void layoutChildren()>,20,21,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }
    mBlockLayoutRequests = true;
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only from "" + ""the UI thread. Make sure your adapter calls notifyDataSetChanged() "" + ""when its content changes. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Remember which child, if any, had accessibility focus.
        final int accessibilityFocusPosition;
        final View accessFocusedChild = getAccessibilityFocusedChild();
        if (accessFocusedChild != null) {
            accessibilityFocusPosition = getPositionForView(accessFocusedChild);
            accessFocusedChild.setHasTransientState(true);
        } else {
            accessibilityFocusPosition = INVALID_POSITION;
        }
        // Ensure the child containing focus, if any, has transient state.
        // If the list data hasn't changed, or if the adapter has stable
        // IDs, this will maintain focus.
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            focusedChild.setHasTransientState(true);
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            final boolean shouldPlaceFocus = mItemsCanFocus && hasFocus();
            final boolean maintainedFocus = focusedChild != null && focusedChild.hasFocus();
            if (shouldPlaceFocus && !maintainedFocus && !sel.hasFocus()) {
                if (sel.requestFocus()) {
                    // Successfully placed focus, clear selection.
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                } else {
                    // Failed to place focus, clear current (invalid) focus.
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            // Otherwise, clear selection.
            if (mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING) {
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
        }
        if (accessFocusedChild != null) {
            accessFocusedChild.setHasTransientState(false);
            // view, attempt to restore it to the previous position.
            if (!accessFocusedChild.isAccessibilityFocused() && accessibilityFocusPosition != INVALID_POSITION) {
                // Bound the position within the visible children.
                final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                final View restoreView = getChildAt(position);
                if (restoreView != null) {
                    restoreView.requestAccessibilityFocus();
                }
            }
        }
        if (focusedChild != null) {
            focusedChild.setHasTransientState(false);
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }
    mBlockLayoutRequests = true;
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only from "" + ""the UI thread. Make sure your adapter calls notifyDataSetChanged() "" + ""when its content changes. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();
            if (focusHost != null) {
                final View focusChild = getAccessibilityFocusedChild(focusHost);
                if (focusChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(focusChild) || focusChild.hasTransientState() || mAdapterHasStableIds) {
                        // The views won't be changing, so try to maintain
                        // focus on the current host and virtual view.
                        accessibilityFocusLayoutRestoreView = focusHost;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    }
                    // If all else fails, maintain focus at the same
                    // position.
                    accessibilityFocusPosition = getPositionForView(focusChild);
                }
            }
        }
        View focusLayoutRestoreDirectChild = null;
        View focusLayoutRestoreView = null;
        // Take focus back to us temporarily to avoid the eventual call to
        // clear focus when removing the focused child below from messing
        // things up when ViewAncestor assigns focus back to someone else.
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // header or footer.
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // Remember the specific view that had focus.
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // Tell it we are going to mess with it.
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // focusable.
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // Selected item didn't take focus, but we still want to
                    // make sure something else outside of the selected view
                    // has focus.
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING;
            if (inTouchMode) {
                // If the user's finger is down, select the motion position.
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else if (mSelectorPosition != INVALID_POSITION) {
                // If we had previously positioned the selector somewhere,
                // put it back there. It might not match up with the data,
                // but it's transitioning out so it's not a big deal.
                final View child = getChildAt(mSelectorPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mSelectorPosition, child);
                }
            } else {
                // Otherwise, clear selection.
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // restore focus (i.e. something focusable in touch mode).
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus, if necessary.
        if (viewRootImpl != null) {
            final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (newAccessibilityFocusedView == null) {
                if (accessibilityFocusLayoutRestoreView != null && accessibilityFocusLayoutRestoreView.isAttachedToWindow()) {
                    final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
                    if (accessibilityFocusLayoutRestoreNode != null && provider != null) {
                        final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                        provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
                    } else {
                        accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
                    }
                } else if (accessibilityFocusPosition != INVALID_POSITION) {
                    // Bound the position within the visible children.
                    final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                    final View restoreView = getChildAt(position);
                    if (restoreView != null) {
                        restoreView.requestAccessibilityFocus();
                    }
                }
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
453,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",20,21,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>","<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",0,"{
    final Context context = getContext();
    if (!method.startsWith(""android:"")) {
        // Let non-platform methods pass through
        return super.call(method, arg, extras);
    }
    final String documentId = extras.getString(Document.COLUMN_DOCUMENT_ID);
    final Uri documentUri = DocumentsContract.buildDocumentUri(mAuthority, documentId);
    // Require that caller can manage requested document
    final boolean callerHasManage = context.checkCallingOrSelfPermission(android.Manifest.permission.MANAGE_DOCUMENTS) == PackageManager.PERMISSION_GRANTED;
    enforceWritePermissionInner(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            out.putString(Document.COLUMN_DOCUMENT_ID, newDocumentId);
            // Extend permission grant towards caller if needed
            if (!callerHasManage) {
                final Uri newDocumentUri = DocumentsContract.buildDocumentUri(mAuthority, newDocumentId);
                context.grantUriPermission(getCallingPackage(), newDocumentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            context.revokeUriPermission(documentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        } else {
            throw new UnsupportedOperationException(""Method not supported "" + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
    return out;
}","{
    if (!method.startsWith(""android:"")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException(""Requested authority "" + authority + "" doesn't match provider "" + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException(""Method not supported "" + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
    return out;
}",1,"/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 *
 * @see #openDocument(String, String, CancellationSignal)
 * @see #deleteDocument(String)
 */
","/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","In the late version of the implementation, there are significant changes throughout the code:",- The way of retrieving documentId from the URI has changed from extras.getString() to DocumentsContract.getDocumentId(documentUri).
454,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",20,21,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round and outset info
                final WindowManager windowService = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                final Display display = windowService.getDefaultDisplay();
                final boolean shouldUseBottomOutset = display.getDisplayId() == Display.DEFAULT_DISPLAY;
                if (shouldUseBottomOutset && windowStyle.hasValue(R.styleable.Window_windowOutsetBottom)) {
                    if (mOutsetBottom == null)
                        mOutsetBottom = new TypedValue();
                    windowStyle.getValue(R.styleable.Window_windowOutsetBottom, mOutsetBottom);
                } else {
                    mOutsetBottom = null;
                }
                mWindowIsRound = getResources().getBoolean(com.android.internal.R.bool.config_windowIsRound);
                windowStyle.recycle();
                // detect emulator
                mIsEmulator = Build.HARDWARE.contains(""goldfish"");
                mIsCircularEmulator = SystemProperties.getBoolean(ViewRootImpl.PROPERTY_EMULATOR_CIRCULAR, false);
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    final boolean isRound = (mIsEmulator && mIsCircularEmulator) || mWindowIsRound;
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    if (mOutsetBottom != null) {
                        final DisplayMetrics metrics = getResources().getDisplayMetrics();
                        mFinalSystemInsets.bottom = ((int) mOutsetBottom.getDimension(metrics)) + mIWallpaperEngine.mDisplayPadding.bottom;
                    }
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, isRound);
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
455,"<android.content.res.ColorStateList: ColorStateList createFromXml(Resources,XmlPullParser)>",20,21,"<android.content.res.ColorStateList: ColorStateList createFromXml(Resources,XmlPullParser)>","<android.content.res.ColorStateList: ColorStateList createFromXml(Resources,XmlPullParser)>",0,"{
    AttributeSet attrs = Xml.asAttributeSet(parser);
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    }
    if (type != XmlPullParser.START_TAG) {
        throw new XmlPullParserException(""No start tag found"");
    }
    return createFromXmlInner(r, parser, attrs);
}","{
    final AttributeSet attrs = Xml.asAttributeSet(parser);
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    }
    if (type != XmlPullParser.START_TAG) {
        throw new XmlPullParserException(""No start tag found"");
    }
    return createFromXmlInner(r, parser, attrs);
}",1,"/**
 * Create a ColorStateList from an XML document, given a set of {@link Resources}.
 */
","/**
 * Create a ColorStateList from an XML document, given a set of {@link Resources}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no functional change in the implementation; the only difference is the addition of the 'final' modifier to the `attrs` variable, which is an internal implementation detail and does not affect the external API behavior.","There is no Compatibility Issue since the code change does not affect the behavior of the method. The API will behave the same way as before, and clients of the API will not notice any difference."
457,<android.view.ViewGroup: void removeAllViewsInLayout()>,20,21,<android.view.ViewGroup: void removeAllViewsInLayout()>,<android.view.ViewGroup: void removeAllViewsInLayout()>,0,"{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus();
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}","{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}",1,"/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
","/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is that the `view.unFocus()` method call has been updated to `view.unFocus(null)` which is a change in the method signature, but since it does not affect any return values, control flow, or exceptions thrown, the code change type is 4.",There is no compatibility issue since the method's behavior remains consistent despite the change in the method call to `unFocus`. The `null` parameter most likely is an update that doesn't change the semantic meaning of the call and thus doesn't lead to different behaviors.
459,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,20,21,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
460,<android.app.ActivityThread.ProviderKey: boolean equals(Object)>,20,21,<android.app.ActivityThread.ProviderKey: boolean equals(Object)>,<android.app.ActivityThread.ProviderKey: boolean equals(Object)>,0,"{
    if (o instanceof ProviderKey) {
        final ProviderKey other = (ProviderKey) o;
        return Objects.equal(authority, other.authority) && userId == other.userId;
    }
    return false;
}","{
    if (o instanceof ProviderKey) {
        final ProviderKey other = (ProviderKey) o;
        return Objects.equals(authority, other.authority) && userId == other.userId;
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method used to compare 'authority' changed from Objects.equal to Objects.equals; this is an implementation detail and does not affect the semantics of the method. Therefore, the code change type is 4 (Other statement changed).",This change does not lead to a Compatibility Issue because both Objects.equal and Objects.equals are used to check for equality between two objects. This is a simple renaming of the method and does not alter the behavior in terms of how the equality is checked or the result that is returned. The outcome of the equals method remains consistent between versions.
461,<android.print.PrintManager: List<PrintJob> getPrintJobs()>,20,21,<android.print.PrintManager: List<PrintJob> getPrintJobs()>,<android.print.PrintManager: List<PrintJob> getPrintJobs()>,0,"{
    try {
        List<PrintJobInfo> printJobInfos = mService.getPrintJobInfos(mAppId, mUserId);
        if (printJobInfos == null) {
            return Collections.emptyList();
        }
        final int printJobCount = printJobInfos.size();
        List<PrintJob> printJobs = new ArrayList<PrintJob>(printJobCount);
        for (int i = 0; i < printJobCount; i++) {
            printJobs.add(new PrintJob(printJobInfos.get(i), this));
        }
        return printJobs;
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error getting print jobs"", re);
    }
    return Collections.emptyList();
}","{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return Collections.emptyList();
    }
    try {
        List<PrintJobInfo> printJobInfos = mService.getPrintJobInfos(mAppId, mUserId);
        if (printJobInfos == null) {
            return Collections.emptyList();
        }
        final int printJobCount = printJobInfos.size();
        List<PrintJob> printJobs = new ArrayList<PrintJob>(printJobCount);
        for (int i = 0; i < printJobCount; i++) {
            printJobs.add(new PrintJob(printJobInfos.get(i), this));
        }
        return printJobs;
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error getting print jobs"", re);
    }
    return Collections.emptyList();
}",1,"/**
 * Gets the print jobs for this application.
 *
 * @return The print job list.
 * @see PrintJob
 */
","/**
 * Gets the print jobs for this application.
 *
 * @return The print job list.
 * @see PrintJob
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,The late version of the implementation code adds an 'if' condition at the beginning to check if mService is null and return an empty list early. This is a control dependency change.,"The newly introduced 'if' control in the late implementation version can lead to the method returning `Collections.emptyList()` earlier than it would in the early version if `mService` is null. This represents a change in the method's behavior which could cause Compatibility Issues due to the potential for different return values, thus CI type is 1."
463,"<android.os.Bundle: short getShort(String,short)>",20,21,"<android.os.Bundle: short getShort(String,short)>","<android.os.Bundle: short getShort(String,short)>",0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (Short) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Short"", defaultValue, e);
        return defaultValue;
    }
}","{
    return super.getShort(key, defaultValue);
}",1,"/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a short value
 */
","/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a short value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method was changed to directly call a method from the superclass with the same signature, so the change is of type 5 (Dependent API changed).","Since the method in the late implementation delegates the call to the superclass's implementation of `getShort(String, short)`, and does not introduce any additional logic, the behavior would remain consistent assuming the superclass's method is correctly implemented to match this specification. There is no inherent compatibility issue introduced by this change."
464,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,20,21,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final View[] children = mChildren;
                    final boolean customOrder = isChildrenDrawingOrderEnabled();
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = children[childIndex];
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = childIndex;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
466,"<android.text.StaticLayout: void generate(CharSequence,int,int,TextPaint,int,TextDirectionHeuristic,float,float,boolean,boolean,float,TruncateAt)>",20,21,"<android.text.StaticLayout: void generate(CharSequence,int,int,TextPaint,int,TextDirectionHeuristic,float,float,boolean,boolean,float,TruncateAt)>","<android.text.StaticLayout: void generate(CharSequence,int,int,TextPaint,int,TextDirectionHeuristic,float,float,boolean,boolean,float,TruncateAt)>",0,"{
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    // XXX
    int DEFAULT_DIR = DIR_LEFT_TO_RIGHT;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // paragraph.
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = lmsFirstLine + lms2.getLeadingMarginLineCount();
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = new int[ArrayUtils.idealIntArraySize(chooseHt.length)];
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    // From the Unicode Line Breaking Algorithm (at least approximately)
                    boolean isLineBreak = isSpaceOrTab || // / is class SY and - is class HY, except when followed by a digit
                    ((c == CHAR_SLASH || c == CHAR_HYPHEN) && (j + 1 >= spanEnd || !Character.isDigit(chs[j + 1 - paraStart]))) || // (non-starters), which can be broken after but not before
                    (c >= CHAR_FIRST_CJK && isIdeographic(c, true) && j + 1 < spanEnd && isIdeographic(chs[j + 1 - paraStart], false));
                    if (isLineBreak) {
                        okWidth = w;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    final boolean moreChars = (j + 1 < spanEnd);
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                    } else {
                        endPos = here + 1;
                        above = fm.ascent;
                        below = fm.descent;
                        top = fm.top;
                        bottom = fm.bottom;
                        currentTextWidth = widths[here - paraStart];
                    }
                    v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        break;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e(""text"", ""output rest "" + here + "" to "" + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}","{
    int[] breakOpp = null;
    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
        int breakOppIndex = 0;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        // same as fitWidth but not including any trailing whitespace
        float fitWidthGraphing = w;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    if (!isSpaceOrTab) {
                        fitWidthGraphing = w;
                    }
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
                        breakOppIndex++;
                    }
                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                    if (isLineBreak) {
                        okWidth = fitWidthGraphing;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    final boolean moreChars;
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else {
                        // must make progress, so take next character
                        endPos = here + 1;
                        // take all zero width characters following that
                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
                            endPos++;
                        }
                        above = fmAscent;
                        below = fmDescent;
                        top = fmTop;
                        bottom = fmBottom;
                        currentTextWidth = widths[here - paraStart];
                        moreChars = (endPos < spanEnd);
                    }
                    v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitWidthGraphing = w;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        return;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e(""text"", ""output rest "" + here + "" to "" + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
467,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",20,21,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>","<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",0,"{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError();
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError();
        }
        return TextToSpeech.ERROR;
    }
}","{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
        }
        return TextToSpeech.ERROR;
    }
}",1,"/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
","/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only changes in the code involve the specific error dispatched via the `utterenceProgress.dispatchOnError()` method, as it now dispatches different error codes: `TextToSpeech.ERROR_INVALID_REQUEST` and `TextToSpeech.ERROR_SERVICE` in different situations. This change does not affect the method's return type or values, so it is categorized as type 4.","Although the error codes reported to `utterenceProgress` have changed, this does not affect the return value or exception behavior of the `enqueueSpeechItem` method itself. The method still returns `TextToSpeech.ERROR` or `TextToSpeech.SUCCESS` in both versions. Therefore, there is No Compatibility Issue (CI type 0) associated with the method's return values or exceptions thrown."
470,<android.os.MessageQueue: Message next()>,20,21,<android.os.MessageQueue: Message next()>,<android.os.MessageQueue: Message next()>,0,"{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        // We can assume mPtr != 0 because the loop is obviously still running.
        // The looper will not call this method after the loop quits.
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}","{
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(ptr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
471,<android.service.dreams.DreamService: void finish()>,20,21,<android.service.dreams.DreamService: void finish()>,<android.service.dreams.DreamService: void finish()>,0,"{
    if (mDebug)
        Slog.v(TAG, ""finish()"");
    finishInternal();
}","{
    if (mDebug)
        Slog.v(TAG, ""finish(): mFinished="" + mFinished);
    if (!mFinished) {
        mFinished = true;
        if (mWindowToken == null) {
            Slog.w(TAG, ""Finish was called before the dream was attached."");
        } else {
            try {
                mSandman.finishSelf(mWindowToken, true);
            } catch (RemoteException ex) {
            // system server died
            }
        }
        // if launched via any other means
        stopSelf();
    }
}",1,"/**
 * Stops the dream, detaches from the window, and wakes up.
 */
","/**
 * Stops the dream and detaches from the window.
 * <p>
 * When the dream ends, the system will be allowed to go to sleep fully unless there
 * is a reason for it to be awake such as recent user activity or wake locks being held.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","The late version introduces a new if condition (if (!mFinished)), assignments (mFinished = true), additional logging, and an expanded exception handling block compared to the early version. Hence, the code change types are 3 for the control dependency change and 4 for other statement changes.","The new if condition could potentially alter whether the methods stopSelf(), mSandman.finishSelf(), and the assignments are executed. The execution of these methods can change the behavior of `finish()` method. Hence, a CI could arise from a potential different return value (type 1) if the dream wasn't finished and the method stopSelf() is called, which wasn't present in the earlier version. There is also a potential different exception handling due to the try-catch block added to handle RemoteException, which can affect the method's behavior if such an exception occurs (type 2)."
472,<android.app.Activity: ActionMode onWindowStartingActionMode(Callback)>,20,21,<android.app.Activity: ActionMode onWindowStartingActionMode(Callback)>,<android.app.Activity: ActionMode onWindowStartingActionMode(Callback)>,0,"{
    initActionBar();
    if (mActionBar != null) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}","{
    initWindowDecorActionBar();
    if (mActionBar != null) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}",1,"/**
 * Give the Activity a chance to control the UI for an action mode requested
 * by the system.
 *
 * <p>Note: If you are looking for a notification callback that an action mode
 * has been started for this activity, see {@link #onActionModeStarted(ActionMode)}.</p>
 *
 * @param callback The callback that should control the new action mode
 * @return The new action mode, or <code>null</code> if the activity does not want to
 * provide special handling for this action mode. (It will be handled by the system.)
 */
","/**
 * Give the Activity a chance to control the UI for an action mode requested
 * by the system.
 *
 * <p>Note: If you are looking for a notification callback that an action mode
 * has been started for this activity, see {@link #onActionModeStarted(ActionMode)}.</p>
 *
 * @param callback The callback that should control the new action mode
 * @return The new action mode, or <code>null</code> if the activity does not want to
 * provide special handling for this action mode. (It will be handled by the system.)
 */
",-1,[@Override],"[@Nullable, @Override]",-1,-1,-1,-1,-1,-1,4,0,"The method initActionBar() has been changed to initWindowDecorActionBar(), so the code change type is 4.","There is no change in the control flow, return statements, or exception handling between the versions. The only change is an initialization method called before checking the mActionBar. As long as initWindowDecorActionBar() is an internal detail and does not affect the return value or exception handling, it doesn't cause a CI, so the CI type is 0."
473,<android.view.View: void invalidate(Rect)>,20,21,<android.view.View: void invalidate(Rect)>,<android.view.View: void invalidate(Rect)>,0,"{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED) {
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        mPrivateFlags |= PFLAG_INVALIDATED;
        mPrivateFlags |= PFLAG_DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect r = ai.mTmpInvalRect;
            r.set(dirty.left - scrollX, dirty.top - scrollY, dirty.right - scrollX, dirty.bottom - scrollY);
            mParent.invalidateChild(this, r);
        }
    }
}","{
    final int scrollX = mScrollX;
    final int scrollY = mScrollY;
    invalidateInternal(dirty.left - scrollX, dirty.top - scrollY, dirty.right - scrollX, dirty.bottom - scrollY, true, false);
}",1,"/**
 * Mark the area defined by dirty as needing to be drawn. If the view is
 * visible, {@link #onDraw(android.graphics.Canvas)} will be called at some point
 * in the future. This must be called from a UI thread. To call from a non-UI
 * thread, call {@link #postInvalidate()}.
 *
 * WARNING: This method is destructive to dirty.
 * @param dirty the rectangle representing the bounds of the dirty region
 */
","/**
 * Mark the area defined by dirty as needing to be drawn. If the view is
 * visible, {@link #onDraw(android.graphics.Canvas)} will be called at some
 * point in the future.
 * <p>
 * This must be called from a UI thread. To call from a non-UI thread, call
 * {@link #postInvalidate()}.
 * <p>
 * <b>WARNING:</b> In API 19 and below, this method may be destructive to
 * {@code dirty}.
 *
 * @param dirty the rectangle representing the bounds of the dirty region
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method's implementation has been entirely replaced with a call to invalidateInternal() with different parameters, and the logic that checks conditions and performs various operations before the invalidation has been removed. Additionally, the previous control flow, like the 'if' statements and the 'return' early exit mechanism, has been completely altered, so the code change type includes 1 (due to the removal of return statements), 3 (because the control flow changed), and 4 (since other statements are changed).","The changes made remove conditional checks and change the logic of how and when invalidation is performed. Since the early version sometimes skips invalidation based on conditions and also may potentially invalidate the whole view hierarchy differently, the new behavior in the late version might invalidate the view differently. This constitutes a potential Compatibility Issue due to potentially different return values or control flow outcomes, leading to CI type 1."
474,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,20,21,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_DISPATCH_SCREEN_STATE:
            return ""MSG_DISPATCH_SCREEN_STATE"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_FLUSH_LAYER_UPDATES:
            return ""MSG_FLUSH_LAYER_UPDATES"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The switch statement has been modified with an addition of new case handling 'MSG_SYNTHESIZE_INPUT_EVENT' in late implementation, meaning that a new return statement has been added for this constant which wasn't present in the early implementation, thus the change types are 1 and 3.","The late version of the API can return a new string ""MSG_SYNTHESIZE_INPUT_EVENT"" which wasn't possible in the early version, leading to a potential difference in behavior. This constitutes a compatibility issue of type 1."
475,<android.database.CursorWindow: String toString()>,20,21,<android.database.CursorWindow: String toString()>,<android.database.CursorWindow: String toString()>,0,"{
    return getName() + "" {"" + Integer.toHexString(mWindowPtr) + ""}"";
}","{
    return getName() + "" {"" + Long.toHexString(mWindowPtr) + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The implementation of the toString method has changed from Integer.toHexString(mWindowPtr) to Long.toHexString(mWindowPtr), altering how the mWindowPtr is converted to a hex string. This indicates a Return statement changed (code change type 1).","Since the toString method now returns a string based on the hex representation of mWindowPtr using Long instead of Integer, it could potentially return a different string value when the window pointer is beyond the range of an Integer type. Thus, it will cause a Compatibility Issue due to potential different return values (CI type 1)."
476,<android.content.res.TypedArray: boolean hasValue(int)>,20,21,<android.content.res.TypedArray: boolean hasValue(int)>,<android.content.res.TypedArray: boolean hasValue(int)>,0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}",1,"/**
 * Determines whether there is an attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 */
","/**
 * Determines whether there is an attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An exception handling statement is newly introduced at the beginning of the method ('if (mRecycled)'), so the code change types are 2 for the exception handling and 3 for the control dependency, as the entire method's processing is now dependent on the new control statement.",The introduction of new exception handling means that the late version of the API could potentially throw a new exception that the early version did not. This change will cause a Compatibility Issue where existing code that is not expecting an exception from this method might encounter one. This represents a Compatibility Issue of type 2.
477,<android.net.ConnectivityManager: int getNetworkPreference()>,20,21,<android.net.ConnectivityManager: int getNetworkPreference()>,<android.net.ConnectivityManager: int getNetworkPreference()>,0,"{
    try {
        return mService.getNetworkPreference();
    } catch (RemoteException e) {
        return -1;
    }
}","{
    return TYPE_NONE;
}",1,"/**
 * Retrieves the current preferred network type.
 * Note that this made sense when we only had 2 network types,
 * but with more and more default networks we need an array to list
 * their ordering.  This will be deprecated soon.
 *
 * @return an integer representing the preferred network type
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 */
","/**
 * Retrieves the current preferred network type.
 *
 * @return an integer representing the preferred network type
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 * @deprecated Functionality has been removed as it no longer makes sense,
 * with many more than two networks - we'd need an array to express
 * preference.  Instead we use dynamic network properties of
 * the networks to describe their precedence.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"There is a change in the return statement from trying to return a value from a method call to always returning a constant (TYPE_NONE). The try-catch block has been removed. Thus, the code changes include the removal of an exception handling block and changing the return type/value, which are types 1 and 4.","The removal of the try-catch block and change in the return value from a method call on a remote service to a constant value will potentially cause this API to return a different value than before. In the earlier version, the return value depended on the execution of the remote call, which could vary, but now it always returns a constant. This change will cause the API to behave differently, leading to a compatibility issue of type 1."
478,<android.os.Environment: String getExternalStorageState()>,20,21,<android.os.Environment: String getExternalStorageState()>,<android.os.Environment: String getExternalStorageState()>,0,"{
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return getStorageState(externalDir);
}","{
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return getExternalStorageState(externalDir);
}",1,"/**
 * Returns the current state of the primary ""external"" storage device.
 *
 * @see #getExternalStorageDirectory()
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */
","/**
 * Returns the current state of the primary ""external"" storage device.
 *
 * @see #getExternalStorageDirectory()
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getStorageState(externalDir) to getExternalStorageState(externalDir), which could potentially return a different value, so the code change type is 1,5.","Since the return statement has changed to call a different method, the API could potentially return different values or types, resulting in a CI type of 1."
481,<android.view.View: void draw(Canvas)>,20,21,<android.view.View: void draw(Canvas)>,<android.view.View: void draw(Canvas)>,0,"{
    if (mClipBounds != null) {
        canvas.clipRect(mClipBounds);
    }
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBackground;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
}","{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
482,"<android.view.View: void invalidate(int,int,int,int)>",20,21,"<android.view.View: void invalidate(int,int,int,int)>","<android.view.View: void invalidate(int,int,int,int)>",0,"{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED) {
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        mPrivateFlags |= PFLAG_INVALIDATED;
        mPrivateFlags |= PFLAG_DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null && l < r && t < b) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect tmpr = ai.mTmpInvalRect;
            tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
            p.invalidateChild(this, tmpr);
        }
    }
}","{
    final int scrollX = mScrollX;
    final int scrollY = mScrollY;
    invalidateInternal(l - scrollX, t - scrollY, r - scrollX, b - scrollY, true, false);
}",1,"/**
 * Mark the area defined by the rect (l,t,r,b) as needing to be drawn.
 * The coordinates of the dirty rect are relative to the view.
 * If the view is visible, {@link #onDraw(android.graphics.Canvas)}
 * will be called at some point in the future. This must be called from
 * a UI thread. To call from a non-UI thread, call {@link #postInvalidate()}.
 * @param l the left position of the dirty region
 * @param t the top position of the dirty region
 * @param r the right position of the dirty region
 * @param b the bottom position of the dirty region
 */
","/**
 * Mark the area defined by the rect (l,t,r,b) as needing to be drawn. The
 * coordinates of the dirty rect are relative to the view. If the view is
 * visible, {@link #onDraw(android.graphics.Canvas)} will be called at some
 * point in the future.
 * <p>
 * This must be called from a UI thread. To call from a non-UI thread, call
 * {@link #postInvalidate()}.
 *
 * @param l the left position of the dirty region
 * @param t the top position of the dirty region
 * @param r the right position of the dirty region
 * @param b the bottom position of the dirty region
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The early version of the method has checks for certain conditions (such as skipInvalidate()) and contains control logic (e.g., ""if"" statements), as well as direct modification of the flags (mPrivateFlags) and a call to invalidateChild(). The late version removes these condition checks and control structures and instead directly calls invalidateInternal(), indicating changes are made in return statements, control dependencies, and other statements. The method fundamentally changes its internal implementation, thus change types 1, 3, and 4.","The late version of the method does not have the same conditional checks, which means it will now go through the invalidation process even when the early version would have returned early (due to skipInvalidate() returning true). This change could lead to different return behavior (type 1 CI). Additionally, the potential for different exceptions exists because the removed try block and associated catches could have handled exceptions differently; therefore, there might be a difference in exception handling as well (type 2 CI)."
484,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,20,21,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,0,"{
    if (LOGD)
        Log.d(TAG, ""updateAppWidget called mOld="" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext(remoteViews);
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, ""was able to recycled existing layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, ""had to inflate new layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, ""updateAppWidget couldn't find any view, using error view"", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}","{
    if (LOGD)
        Log.d(TAG, ""updateAppWidget called mOld="" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext();
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, ""was able to recycled existing layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, ""had to inflate new layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, ""updateAppWidget couldn't find any view, using error view"", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}",1,"/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
","/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
485,<android.widget.DatePicker: int getMonth()>,20,21,<android.widget.DatePicker: int getMonth()>,<android.widget.DatePicker: int getMonth()>,0,"{
    return mCurrentDate.get(Calendar.MONTH);
}","{
    return mDelegate.getMonth();
}",1,"/**
 * @return The selected month.
 */
","/**
 * @return The selected month.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method called within the return statement has changed from `mCurrentDate.get(Calendar.MONTH)` to `mDelegate.getMonth()`. This change implies that there has been an alteration in the implementation of how the month is retrieved. Since the source of the returned value has changed, the code change types are 1 (Return statement changed) and 5 (Dependent API changed).","The change in the source of the returned month value could lead to a different return value if the implementation of `mDelegate.getMonth()` behaves differently from `mCurrentDate.get(Calendar.MONTH)`. Thus, this could potentially cause a compatibility issue due to a different return value, so the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
486,<android.content.RestrictionEntry: String[] getChoiceEntries()>,20,21,<android.content.RestrictionEntry: String[] getChoiceEntries()>,<android.content.RestrictionEntry: String[] getChoiceEntries()>,0,"{
    return choices;
}","{
    return mChoiceEntries;
}",1,"/**
 * Returns the list of strings, set earlier, that will be presented as choices to the user.
 * @return the list of choices presented to the user.
 */
","/**
 * Returns the list of strings, set earlier, that will be presented as choices to the user.
 * @return the list of choices presented to the user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The return statement has been changed from returning 'choices' to returning 'mChoiceEntries', which indicates that the variable containing the data has been renamed. This indicates an internal change of variable names and is categorized as Other statement changed.","There is no Compatibility Issue as the method still returns a String array and the type of the variable returned has not changed, just the internal name of the variable used to store the values. This change does not affect the behavior visible to the user of the API."
487,"<android.view.GLES20Canvas: void drawRect(float,float,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawRect(float,float,float,float,Paint)>","<android.view.GLES20Canvas: void drawRect(float,float,float,float,Paint)>",0,"{
    if (left == right || top == bottom)
        return;
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawRect(mRenderer, left, top, right, bottom, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (left == right || top == bottom)
        return;
    nDrawRect(mRenderer, left, top, right, bottom, paint.mNativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The modifiers handling (setupModifiers and nResetModifiers) have been removed from the implementation, resulting in changes to other statements, so the code change type is 1,4.","While there are changes to other statements around modifier handling, the method's signature, return type, and logic to draw the rectangle have not been altered. The method's functionality in terms of drawing the rectangle when the left is not equal to right and top is not equal to bottom remains consistent. There appears to be no introduced or deleted return or exception handling statement that would alter the method's external behavior or contract; thus, no compatibility issue is detected."
488,<android.app.Notification.Builder: Builder setSound(Uri)>,20,21,<android.app.Notification.Builder: Builder setSound(Uri)>,<android.app.Notification.Builder: Builder setSound(Uri)>,0,"{
    mSound = sound;
    mAudioStreamType = STREAM_DEFAULT;
    return this;
}","{
    mSound = sound;
    mAudioAttributes = AUDIO_ATTRIBUTES_DEFAULT;
    return this;
}",1,"/**
 * Set the sound to play.
 *
 * It will be played on the {@link #STREAM_DEFAULT default stream} for notifications.
 *
 * @see Notification#sound
 */
","/**
 * Set the sound to play.
 *
 * It will be played using the {@link #AUDIO_ATTRIBUTES_DEFAULT default audio attributes}
 * for notifications.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 *
 * @see Notification#sound
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,There is a change in the assignment of the audio attributes; the mAudioStreamType is no longer set to STREAM_DEFAULT but instead mAudioAttributes gets assigned to AUDIO_ATTRIBUTES_DEFAULT. This is classified as an 'other statement changed'.,"This change does not lead to a Compatibility Issue because the API still sets a default audio configuration when a sound is specified, and the intended behavior remains the same. The API does not return different values or throw different exceptions as a result of this change."
490,"<android.widget.TextView: ColorStateList getTextColors(Context,TypedArray)>",20,21,"<android.widget.TextView: ColorStateList getTextColors(Context,TypedArray)>","<android.widget.TextView: ColorStateList getTextColors(Context,TypedArray)>",0,"{
    ColorStateList colors;
    colors = attrs.getColorStateList(com.android.internal.R.styleable.TextView_textColor);
    if (colors == null) {
        int ap = attrs.getResourceId(com.android.internal.R.styleable.TextView_textAppearance, -1);
        if (ap != -1) {
            TypedArray appearance;
            appearance = context.obtainStyledAttributes(ap, com.android.internal.R.styleable.TextAppearance);
            colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColor);
            appearance.recycle();
        }
    }
    return colors;
}","{
    if (attrs == null) {
        // Preserve behavior prior to removal of this API.
        throw new NullPointerException();
    }
    // It's not safe to use this method from apps. The parameter 'attrs'
    // must have been obtained using the TextView filter array which is not
    // available to the SDK. As such, we grab a default TypedArray with the
    // right filter instead here.
    final TypedArray a = context.obtainStyledAttributes(R.styleable.TextView);
    ColorStateList colors = a.getColorStateList(R.styleable.TextView_textColor);
    if (colors == null) {
        final int ap = a.getResourceId(R.styleable.TextView_textAppearance, 0);
        if (ap != 0) {
            final TypedArray appearance = context.obtainStyledAttributes(ap, R.styleable.TextAppearance);
            colors = appearance.getColorStateList(R.styleable.TextAppearance_textColor);
            appearance.recycle();
        }
    }
    a.recycle();
    return colors;
}",1,"/**
 * Returns the TextView_textColor attribute from the
 * TypedArray, if set, or the TextAppearance_textColor
 * from the TextView_textAppearance attribute, if TextView_textColor
 * was not set directly.
 */
","/**
 * Returns the TextView_textColor attribute from the TypedArray, if set, or
 * the TextAppearance_textColor from the TextView_textAppearance attribute,
 * if TextView_textColor was not set directly.
 *
 * @removed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The late version introduces a new null check for 'attrs' and throws a NullPointerException, which is a different exception handling (2). It also replaces references to resource identifiers with a different set (R.styleable) instead of using com.android.internal.R.styleable, changing the method of obtaining the 'attrs' and 'appearance' TypedArray. Additionally, it changes the default value for the textAppearance from -1 to 0, and the logic for obtaining the 'colors' variable, so these are control dependency changes (3) and other statement changes (4). Moreover, the dependent API calls, like obtainStyledAttributes and getResourceId, now receive different arguments (5).","The changes introduce a new exception throwing condition if 'attrs' is null, leading to a different exception handling (2). Additionally, the late version could potentially return a different 'colors' value due to alterations in the way the TypedArray is obtained and processed, leading to a different return value or type (1)."
491,"<android.text.format.Time: int compare(Time,Time)>",20,21,"<android.text.format.Time: int compare(Time,Time)>","<android.text.format.Time: int compare(Time,Time)>",0,"{
    if (a == null) {
        throw new NullPointerException(""a == null"");
    } else if (b == null) {
        throw new NullPointerException(""b == null"");
    }
    return nativeCompare(a, b);
}","{
    if (a == null) {
        throw new NullPointerException(""a == null"");
    } else if (b == null) {
        throw new NullPointerException(""b == null"");
    }
    a.calculator.copyFieldsFromTime(a);
    b.calculator.copyFieldsFromTime(b);
    return TimeCalculator.compare(a.calculator, b.calculator);
}",1,"/**
 * Compare two {@code Time} objects and return a negative number if {@code
 * a} is less than {@code b}, a positive number if {@code a} is greater than
 * {@code b}, or 0 if they are equal.
 *
 * @param a first {@code Time} instance to compare
 * @param b second {@code Time} instance to compare
 * @throws NullPointerException if either argument is {@code null}
 * @throws IllegalArgumentException if {@link #allDay} is true but {@code
 * hour}, {@code minute}, and {@code second} are not 0.
 * @return a negative result if {@code a} is earlier, a positive result if
 * {@code a} is earlier, or 0 if they are equal.
 */
","/**
 * Compare two {@code Time} objects and return a negative number if {@code
 * a} is less than {@code b}, a positive number if {@code a} is greater than
 * {@code b}, or 0 if they are equal.
 *
 * @param a first {@code Time} instance to compare
 * @param b second {@code Time} instance to compare
 * @throws NullPointerException if either argument is {@code null}
 * @throws IllegalArgumentException if {@link #allDay} is true but {@code
 * hour}, {@code minute}, and {@code second} are not 0.
 * @return a negative result if {@code a} is earlier, a positive result if
 * {@code a} is earlier, or 0 if they are equal.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The late version of the implementation introduces two new method calls before the return statement. These methods are a.calculator.copyFieldsFromTime(a) and b.calculator.copyFieldsFromTime(b); and then the nativeCompare(a, b) call was replaced by TimeCalculator.compare(a.calculator, b.calculator). This is a change type 4 as it is an ""Other statement changed"" case and also a type 5 since the method that is ultimately called to perform the comparison has changed (Dependent API changed).","The introduction of the calls to copyFieldsFromTime and the change from nativeCompare to TimeCalculator.compare could potentially lead to a different return value, which justifies the CI type to be 1."
492,"<android.content.SyncRequest.Builder: Builder setSyncAdapter(Account,String)>",20,21,"<android.content.SyncRequest.Builder: Builder setSyncAdapter(Account,String)>","<android.content.SyncRequest.Builder: Builder setSyncAdapter(Account,String)>",0,"{
    if (mSyncTarget != SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException(""Sync target has already been defined."");
    }
    if (authority != null && authority.length() == 0) {
        throw new IllegalArgumentException(""Authority must be non-empty"");
    }
    mSyncTarget = SYNC_TARGET_ADAPTER;
    mAccount = account;
    mAuthority = authority;
    mComponentName = null;
    return this;
}","{
    if (mSyncTarget != SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException(""Sync target has already been defined."");
    }
    if (authority != null && authority.length() == 0) {
        throw new IllegalArgumentException(""Authority must be non-empty"");
    }
    mSyncTarget = SYNC_TARGET_ADAPTER;
    mAccount = account;
    mAuthority = authority;
    return this;
}",1,"/**
 * Specify an authority and account for this transfer.
 *
 * @param authority String identifying which content provider to sync.
 * @param account Account to sync. Can be null unless this is a periodic sync.
 */
","/**
 * Specify an authority and account for this transfer.
 *
 * @param authority A String identifying the content provider to be synced.
 * @param account Account to sync. Can be null unless this is a periodic
 * sync, for which verification by the ContentResolver will
 * fail. If a sync is performed without an account, the
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the Late_Implementation is the removal of the statement 'mComponentName = null;'. This is a removal of an initialization statement for a variable, not a return statement or exception handling statement, therefore, the change type is 4.","The removal of the 'mComponentName = null;' statement does not affect the method's return type or value, nor does it change exception throwing behavior. It is an internal state change that has no direct effect on the method's output or exception handling as far as the provided information indicates. Therefore, it is classified as no Compatibility Issue."
495,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,20,21,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,0,"{
    removeListeners();
    sPendingTransitions.remove(mSceneRoot);
    // Add to running list, handle end to remove it
    final ArrayMap<ViewGroup, ArrayList<Transition>> runningTransitions = getRunningTransitions();
    ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
    ArrayList<Transition> previousRunningTransitions = null;
    if (currentTransitions == null) {
        currentTransitions = new ArrayList<Transition>();
        runningTransitions.put(mSceneRoot, currentTransitions);
    } else if (currentTransitions.size() > 0) {
        previousRunningTransitions = new ArrayList<Transition>(currentTransitions);
    }
    currentTransitions.add(mTransition);
    mTransition.addListener(new Transition.TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
            currentTransitions.remove(transition);
        }
    });
    mTransition.captureValues(mSceneRoot, false);
    if (previousRunningTransitions != null) {
        for (Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume();
        }
    }
    mTransition.playTransition(mSceneRoot);
    return true;
}","{
    removeListeners();
    sPendingTransitions.remove(mSceneRoot);
    // Add to running list, handle end to remove it
    final ArrayMap<ViewGroup, ArrayList<Transition>> runningTransitions = getRunningTransitions();
    ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
    ArrayList<Transition> previousRunningTransitions = null;
    if (currentTransitions == null) {
        currentTransitions = new ArrayList<Transition>();
        runningTransitions.put(mSceneRoot, currentTransitions);
    } else if (currentTransitions.size() > 0) {
        previousRunningTransitions = new ArrayList<Transition>(currentTransitions);
    }
    currentTransitions.add(mTransition);
    mTransition.addListener(new Transition.TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
            currentTransitions.remove(transition);
        }
    });
    mTransition.captureValues(mSceneRoot, false);
    if (previousRunningTransitions != null) {
        for (Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(mSceneRoot);
        }
    }
    mTransition.playTransition(mSceneRoot);
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method runningTransition.resume() in the 'if' block has its signature changed to runningTransition.resume(mSceneRoot). This indicates a dependent API changed (Dependent API changed), so the code change type is 5.","The method runningTransition.resume(mSceneRoot) is an internal change and does not affect the values returned by the onPreDraw() method, neither does it affect the exceptions it might throw. Thus, this change does not constitute a compatibility issue, and hence the CI type is 0."
497,<android.os.Parcel: Object readValue(ClassLoader)>,20,21,<android.os.Parcel: Object readValue(ClassLoader)>,<android.os.Parcel: Object readValue(ClassLoader)>,0,"{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable();
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException(""Parcel "" + this + "": Unmarshalling unknown type code "" + type + "" at offset "" + off);
    }
}","{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable(loader);
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        case VAL_PERSISTABLEBUNDLE:
            return readPersistableBundle(loader);
        case VAL_SIZE:
            return readSize();
        case VAL_SIZEF:
            return readSizeF();
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException(""Parcel "" + this + "": Unmarshalling unknown type code "" + type + "" at offset "" + off);
    }
}",1,"/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */
","/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The implementation has additional case statements 'VAL_PERSISTABLEBUNDLE', 'VAL_SIZE', and 'VAL_SIZEF' in the switch statement that handle new types. These statements allow new data types to be unmarshalled. Additionally, there was a change in 'VAL_SERIALIZABLE' with readSerializable now taking 'loader' as an argument. These changes indicate that there has been a control dependency change because there are new cases in the control structure, as well as a dependent API change because a method signature changed for 'VAL_SERIALIZABLE' and new data types are handled which may involve calling new or modified methods, so the change type is 3,5.","The addition of new case statements for 'VAL_PERSISTABLEBUNDLE', 'VAL_SIZE', and 'VAL_SIZEF' and the change for 'VAL_SERIALIZABLE' can cause the API to return different values when these new types are encountered. Additionally, the original 'readSerializable()' method with no arguments that was presumably used is no longer called; instead, 'readSerializable(loader)' is used, which might return different values when deserializing objects with the given class loader. Therefore, the CI type is 1."
498,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",20,21,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>","<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",0,"{
    // that we need to fix this.
    if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {
        Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."");
        scheduleVsync();
        return;
    }
    // Post the vsync event to the Handler.
    // The idea is to prevent incoming vsync events from completely starving
    // the message queue.  If there are no messages in the queue with timestamps
    // earlier than the frame time, then the vsync event will be processed immediately.
    // Otherwise, messages that predate the vsync event will be handled first.
    long now = System.nanoTime();
    if (timestampNanos > now) {
        Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."");
        timestampNanos = now;
    }
    if (mHavePendingVsync) {
        Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time."");
    } else {
        mHavePendingVsync = true;
    }
    mTimestampNanos = timestampNanos;
    mFrame = frame;
    Message msg = Message.obtain(mHandler, this);
    msg.setAsynchronous(true);
    mHandler.sendMessageAtTime(msg, timestampNanos / NANOS_PER_MS);
}","{
    // that we need to fix this.
    if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {
        Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."");
        scheduleVsync();
        return;
    }
    // Post the vsync event to the Handler.
    // The idea is to prevent incoming vsync events from completely starving
    // the message queue.  If there are no messages in the queue with timestamps
    // earlier than the frame time, then the vsync event will be processed immediately.
    // Otherwise, messages that predate the vsync event will be handled first.
    long now = System.nanoTime();
    if (timestampNanos > now) {
        Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."");
        timestampNanos = now;
    }
    if (mHavePendingVsync) {
        Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time."");
    } else {
        mHavePendingVsync = true;
    }
    mTimestampNanos = timestampNanos;
    mFrame = frame;
    Message msg = Message.obtain(mHandler, this);
    msg.setAsynchronous(true);
    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change is in the constant used from NANOS_PER_MS to TimeUtils.NANOS_PER_MS. This does not change the actual behavior of the method as they should be referring to the same value; thus, the change type is 5.","As the change is just the replacement of a constant with presumably the same value (just managed in a potentially different class or with a different reference), it does not cause any compatibility issues. Hence, the CI type is 0."
499,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,20,21,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,0,"{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final View[] children = mChildren;
        final float x = event.getX();
        final float y = event.getY();
        final boolean customOrder = isChildrenDrawingOrderEnabled();
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
            final View child = children[childIndex];
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                return true;
            }
        }
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}","{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final float x = event.getX();
        final float y = event.getY();
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
            final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                if (preorderedList != null)
                    preorderedList.clear();
                return true;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The early version does not use a preordered list for the children views, while the late version does. The late version introduces the creation of the preorderedList and uses it if it's not null to determine the child to dispatch the event to. Also, there is a new if condition to clear the preorderedList after dispatching the event, as well as at the end of the for loop if it is not null. These changes are classified under control dependency change (3) and other statement changed (4).","While there are code changes in how the children views might be ordered and handled, these changes do not cause a compatibility issue, because they do not inherently change the behavior of the method from an external point of view. The method still tries to dispatch the event to its children and returns the super implementation if no child handles the event. Therefore, the API's externally observable behavior remains consistent before and after the change."
501,<android.view.SurfaceControl.PhysicalDisplayInfo: boolean equals(PhysicalDisplayInfo)>,20,21,<android.view.SurfaceControl.PhysicalDisplayInfo: boolean equals(PhysicalDisplayInfo)>,<android.view.SurfaceControl.PhysicalDisplayInfo: boolean equals(PhysicalDisplayInfo)>,0,"{
    return other != null && width == other.width && height == other.height && refreshRate == other.refreshRate && density == other.density && xDpi == other.xDpi && yDpi == other.yDpi && secure == other.secure;
}","{
    return other != null && width == other.width && height == other.height && refreshRate == other.refreshRate && density == other.density && xDpi == other.xDpi && yDpi == other.yDpi && secure == other.secure && appVsyncOffsetNanos == other.appVsyncOffsetNanos && presentationDeadlineNanos == other.presentationDeadlineNanos;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"There are added comparisons in the return statement to include 'appVsyncOffsetNanos' and 'presentationDeadlineNanos' in the equality check, which means the return statement has changed, so the code change type is 1,4.","The introduction of new fields to be checked in the equals method implies that instances of PhysicalDisplayInfo that would have previously been considered equal may now be considered non-equal if the values of 'appVsyncOffsetNanos' or 'presentationDeadlineNanos' differ. Therefore, there is a potential CI due to different return values, so the CI type is 1."
504,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>",20,21,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        int left, top, right, bottom;
        if (src == null) {
            left = top = 0;
            right = bitmap.getWidth();
            bottom = bitmap.getHeight();
        } else {
            left = src.left;
            right = src.right;
            top = src.top;
            bottom = src.bottom;
        }
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    int left, top, right, bottom;
    if (src == null) {
        left = top = 0;
        right = bitmap.getWidth();
        bottom = bitmap.getHeight();
    } else {
        left = src.left;
        right = src.right;
        top = src.top;
        bottom = src.bottom;
    }
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code has removed the modifiers logic (the setup and reset of painting modifiers) and changed the type of `nativePaint` from `int` to `long`. Because this is an internal detail and it does not affect the method signature or the return type, the change type is 4.","There is no potential Compatibility Issue, as the method's return type, thrown exceptions, and control flow have not been changed. The adjustments are internal optimizations that do not affect the API's contract, so the CI type is 0."
506,<android.view.accessibility.AccessibilityNodeInfo: int getActions()>,20,21,<android.view.accessibility.AccessibilityNodeInfo: int getActions()>,<android.view.accessibility.AccessibilityNodeInfo: int getActions()>,0,"{
    return mActions;
}","{
    int returnValue = 0;
    if (mActions == null) {
        return returnValue;
    }
    final int actionSize = mActions.size();
    for (int i = 0; i < actionSize; i++) {
        int actionId = mActions.get(i).getId();
        if (actionId <= LAST_LEGACY_STANDARD_ACTION) {
            returnValue |= actionId;
        }
    }
    return returnValue;
}",1,"/**
 * Gets the actions that can be performed on the node.
 *
 * @return The bit mask of with actions.
 *
 * @see AccessibilityNodeInfo#ACTION_FOCUS
 * @see AccessibilityNodeInfo#ACTION_CLEAR_FOCUS
 * @see AccessibilityNodeInfo#ACTION_SELECT
 * @see AccessibilityNodeInfo#ACTION_CLEAR_SELECTION
 * @see AccessibilityNodeInfo#ACTION_ACCESSIBILITY_FOCUS
 * @see AccessibilityNodeInfo#ACTION_CLEAR_ACCESSIBILITY_FOCUS
 * @see AccessibilityNodeInfo#ACTION_CLICK
 * @see AccessibilityNodeInfo#ACTION_LONG_CLICK
 * @see AccessibilityNodeInfo#ACTION_NEXT_AT_MOVEMENT_GRANULARITY
 * @see AccessibilityNodeInfo#ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY
 * @see AccessibilityNodeInfo#ACTION_NEXT_HTML_ELEMENT
 * @see AccessibilityNodeInfo#ACTION_PREVIOUS_HTML_ELEMENT
 * @see AccessibilityNodeInfo#ACTION_SCROLL_FORWARD
 * @see AccessibilityNodeInfo#ACTION_SCROLL_BACKWARD
 */
","/**
 * Gets the actions that can be performed on the node.
 *
 * @return The bit mask of with actions.
 *
 * @see AccessibilityNodeInfo#ACTION_FOCUS
 * @see AccessibilityNodeInfo#ACTION_CLEAR_FOCUS
 * @see AccessibilityNodeInfo#ACTION_SELECT
 * @see AccessibilityNodeInfo#ACTION_CLEAR_SELECTION
 * @see AccessibilityNodeInfo#ACTION_ACCESSIBILITY_FOCUS
 * @see AccessibilityNodeInfo#ACTION_CLEAR_ACCESSIBILITY_FOCUS
 * @see AccessibilityNodeInfo#ACTION_CLICK
 * @see AccessibilityNodeInfo#ACTION_LONG_CLICK
 * @see AccessibilityNodeInfo#ACTION_NEXT_AT_MOVEMENT_GRANULARITY
 * @see AccessibilityNodeInfo#ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY
 * @see AccessibilityNodeInfo#ACTION_NEXT_HTML_ELEMENT
 * @see AccessibilityNodeInfo#ACTION_PREVIOUS_HTML_ELEMENT
 * @see AccessibilityNodeInfo#ACTION_SCROLL_FORWARD
 * @see AccessibilityNodeInfo#ACTION_SCROLL_BACKWARD
 *
 * @deprecated Use {@link #getActionList()}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,4,1,"There is a significant change in the implementation of the method where the return variable calculation logic and the type of mActions has changed (previously just returned mActions, which suggests it was simply an int value, now mActions seems to be a collection from which action IDs are extracted and combined into an integer), so the code change type is 4.","The variable being returned is no longer the same, and due to the change in the way the return value is computed (combining action IDs bit-wise if they are less than or equal to LAST_LEGACY_STANDARD_ACTION), it's likely that this method will return different values than before. Therefore, the CI type is 1."
507,"<android.widget.ListPopupWindow.DropDownListView: boolean onForwardedEvent(MotionEvent,int)>",20,21,"<android.widget.ListPopupWindow.DropDownListView: boolean onForwardedEvent(MotionEvent,int)>","<android.widget.ListPopupWindow.DropDownListView: boolean onForwardedEvent(MotionEvent,int)>",0,"{
    boolean handledEvent = true;
    boolean clearPressedItem = false;
    final int actionMasked = event.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_CANCEL:
            handledEvent = false;
            break;
        case MotionEvent.ACTION_UP:
            handledEvent = false;
        // $FALL-THROUGH$
        case MotionEvent.ACTION_MOVE:
            final int activeIndex = event.findPointerIndex(activePointerId);
            if (activeIndex < 0) {
                handledEvent = false;
                break;
            }
            final int x = (int) event.getX(activeIndex);
            final int y = (int) event.getY(activeIndex);
            final int position = pointToPosition(x, y);
            if (position == INVALID_POSITION) {
                clearPressedItem = true;
                break;
            }
            final View child = getChildAt(position - getFirstVisiblePosition());
            setPressedItem(child, position);
            handledEvent = true;
            if (actionMasked == MotionEvent.ACTION_UP) {
                clickPressedItem(child, position);
            }
            break;
    }
    // Failure to handle the event cancels forwarding.
    if (!handledEvent || clearPressedItem) {
        clearPressedItem();
    }
    // Manage automatic scrolling.
    if (handledEvent) {
        if (mScrollHelper == null) {
            mScrollHelper = new AbsListViewAutoScroller(this);
        }
        mScrollHelper.setEnabled(true);
        mScrollHelper.onTouch(this, event);
    } else if (mScrollHelper != null) {
        mScrollHelper.setEnabled(false);
    }
    return handledEvent;
}","{
    boolean handledEvent = true;
    boolean clearPressedItem = false;
    final int actionMasked = event.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_CANCEL:
            handledEvent = false;
            break;
        case MotionEvent.ACTION_UP:
            handledEvent = false;
        // $FALL-THROUGH$
        case MotionEvent.ACTION_MOVE:
            final int activeIndex = event.findPointerIndex(activePointerId);
            if (activeIndex < 0) {
                handledEvent = false;
                break;
            }
            final int x = (int) event.getX(activeIndex);
            final int y = (int) event.getY(activeIndex);
            final int position = pointToPosition(x, y);
            if (position == INVALID_POSITION) {
                clearPressedItem = true;
                break;
            }
            final View child = getChildAt(position - getFirstVisiblePosition());
            setPressedItem(child, position, x, y);
            handledEvent = true;
            if (actionMasked == MotionEvent.ACTION_UP) {
                clickPressedItem(child, position);
            }
            break;
    }
    // Failure to handle the event cancels forwarding.
    if (!handledEvent || clearPressedItem) {
        clearPressedItem();
    }
    // Manage automatic scrolling.
    if (handledEvent) {
        if (mScrollHelper == null) {
            mScrollHelper = new AbsListViewAutoScroller(this);
        }
        mScrollHelper.setEnabled(true);
        mScrollHelper.onTouch(this, event);
    } else if (mScrollHelper != null) {
        mScrollHelper.setEnabled(false);
    }
    return handledEvent;
}",1,"/**
 * Handles forwarded events.
 *
 * @param activePointerId id of the pointer that activated forwarding
 * @return whether the event was handled
 */
","/**
 * Handles forwarded events.
 *
 * @param activePointerId id of the pointer that activated forwarding
 * @return whether the event was handled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The change is in the method setPressedItem() call, where two additional parameters, x and y, are being passed in the later version. This change in the parameter list is a dependent API change since it alters how setPressedItem() is invoked, so the code change type is 4,5.","The changed invocation of setPressedItem() could potentially affect the behavior of onForwardedEvent() by altering how the pressed item is processed depending on the x and y coordinates. This could lead to different return values in specific cases, so the CI type is 1."
508,"<android.content.res.TypedArray: boolean getValue(int,TypedValue)>",20,21,"<android.content.res.TypedArray: boolean getValue(int,TypedValue)>","<android.content.res.TypedArray: boolean getValue(int,TypedValue)>",0,"{
    return getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, outValue);
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, outValue);
}",1,"/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return Returns true if the value was retrieved, else false.
 */
","/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return Returns true if the value was retrieved, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"An `if` control dependency has been introduced for a throw statement, and the exception handling statement is new, so the code change types are 3,4.","A new exception handling statement that throws a `RuntimeException` if the `mRecycled` is true can lead to a different exception being thrown. Thus, the CI type is 2 due to the potential for a different exception handling behavior."
509,<android.text.Layout: boolean isRtlCharAt(int)>,20,21,<android.text.Layout: boolean isRtlCharAt(int)>,<android.text.Layout: boolean isRtlCharAt(int)>,0,"{
    int line = getLineForOffset(offset);
    Directions dirs = getLineDirections(line);
    if (dirs == DIRS_ALL_LEFT_TO_RIGHT) {
        return false;
    }
    if (dirs == DIRS_ALL_RIGHT_TO_LEFT) {
        return true;
    }
    int[] runs = dirs.mDirections;
    int lineStart = getLineStart(line);
    for (int i = 0; i < runs.length; i += 2) {
        int start = lineStart + (runs[i] & RUN_LENGTH_MASK);
        // corresponding of the last run
        if (offset >= start) {
            int level = (runs[i + 1] >>> RUN_LEVEL_SHIFT) & RUN_LEVEL_MASK;
            return ((level & 1) != 0);
        }
    }
    // Should happen only if the offset is ""out of bounds""
    return false;
}","{
    int line = getLineForOffset(offset);
    Directions dirs = getLineDirections(line);
    if (dirs == DIRS_ALL_LEFT_TO_RIGHT) {
        return false;
    }
    if (dirs == DIRS_ALL_RIGHT_TO_LEFT) {
        return true;
    }
    int[] runs = dirs.mDirections;
    int lineStart = getLineStart(line);
    for (int i = 0; i < runs.length; i += 2) {
        int start = lineStart + runs[i];
        int limit = start + (runs[i + 1] & RUN_LENGTH_MASK);
        if (offset >= start && offset < limit) {
            int level = (runs[i + 1] >>> RUN_LEVEL_SHIFT) & RUN_LEVEL_MASK;
            return ((level & 1) != 0);
        }
    }
    // Should happen only if the offset is ""out of bounds""
    return false;
}",1,"/**
 * Returns true if the character at offset is right to left (RTL).
 * @param offset the offset
 * @return true if the character is RTL, false if it is LTR
 */
","/**
 * Returns true if the character at offset is right to left (RTL).
 * @param offset the offset
 * @return true if the character is RTL, false if it is LTR
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The change occurs in a for loop's condition check. The early version only checks if the offset is greater or equal to the start, whereas the late version introduces an additional condition to check if the offset is less than the limit. Therefore, the control dependency has changed. This is classified as type 3.","As a result of the control dependency change, the conditions under which the loop operates are different, potentially leading to a different boolean value being returned. Therefore, there is a potential Compatibility Issue caused by different return values, which is classified as type 1."
510,"<android.app.ApplicationPackageManager: ApplicationInfo getApplicationInfo(String,int)>",20,21,"<android.app.ApplicationPackageManager: ApplicationInfo getApplicationInfo(String,int)>","<android.app.ApplicationPackageManager: ApplicationInfo getApplicationInfo(String,int)>",0,"{
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(packageName, flags, mContext.getUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}","{
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(packageName, flags, mContext.getUserId());
        if (ai != null) {
            // This is a temporary hack. Callers must use
            // createPackageContext(packageName).getApplicationInfo() to
            // get the right paths.
            maybeAdjustApplicationInfo(ai);
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A non-control statement 'maybeAdjustApplicationInfo(ai);' has been added before the return statement, which does not affect the exception handling or control flow construct, so the code change type is 4.","The addition of 'maybeAdjustApplicationInfo(ai);' does not alter the behavior of exceptions thrown or the return values (assuming the method properly adjusts the ApplicationInfo object without changing its ability to be returned or the conditions under which it is returned), and therefore does not lead to a compatibility issue. Hence, the CI type is 0."
511,"<android.preference.PreferenceFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>",20,21,"<android.preference.PreferenceFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>","<android.preference.PreferenceFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>",0,"{
    return inflater.inflate(com.android.internal.R.layout.preference_list_fragment, container, false);
}","{
    TypedArray a = getActivity().obtainStyledAttributes(null, com.android.internal.R.styleable.PreferenceFragment, com.android.internal.R.attr.preferenceFragmentStyle, 0);
    mLayoutResId = a.getResourceId(com.android.internal.R.styleable.PreferenceFragment_layout, mLayoutResId);
    a.recycle();
    return inflater.inflate(mLayoutResId, container, false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version adds new statements to obtain styled attributes and to recycle them, and a different layout resource ID might be used for inflation. These additional statements constitute an ""Other statement changed"" (type 4), and since 'mLayoutResId' is likely to differ, this impacts the return statement (type 1).","The change in how 'mLayoutResId' is determined can cause the late version to potentially return a different View (by inflating a different layout), which constitutes a ""Compatibility Issue caused by potential different return values or types"" (type 1)."
512,<android.widget.ShareActionProvider: View onCreateActionView()>,20,21,<android.widget.ShareActionProvider: View onCreateActionView()>,<android.widget.ShareActionProvider: View onCreateActionView()>,0,"{
    // Create the view and set its data model.
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    ActivityChooserView activityChooserView = new ActivityChooserView(mContext);
    activityChooserView.setActivityChooserModel(dataModel);
    // Lookup and set the expand action icon.
    TypedValue outTypedValue = new TypedValue();
    mContext.getTheme().resolveAttribute(R.attr.actionModeShareDrawable, outTypedValue, true);
    Drawable drawable = mContext.getResources().getDrawable(outTypedValue.resourceId);
    activityChooserView.setExpandActivityOverflowButtonDrawable(drawable);
    activityChooserView.setProvider(this);
    // Set content description.
    activityChooserView.setDefaultActionButtonContentDescription(R.string.shareactionprovider_share_with_application);
    activityChooserView.setExpandActivityOverflowButtonContentDescription(R.string.shareactionprovider_share_with);
    return activityChooserView;
}","{
    // Create the view and set its data model.
    ActivityChooserView activityChooserView = new ActivityChooserView(mContext);
    if (!activityChooserView.isInEditMode()) {
        ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
        activityChooserView.setActivityChooserModel(dataModel);
    }
    // Lookup and set the expand action icon.
    TypedValue outTypedValue = new TypedValue();
    mContext.getTheme().resolveAttribute(R.attr.actionModeShareDrawable, outTypedValue, true);
    Drawable drawable = mContext.getDrawable(outTypedValue.resourceId);
    activityChooserView.setExpandActivityOverflowButtonDrawable(drawable);
    activityChooserView.setProvider(this);
    // Set content description.
    activityChooserView.setDefaultActionButtonContentDescription(R.string.shareactionprovider_share_with_application);
    activityChooserView.setExpandActivityOverflowButtonContentDescription(R.string.shareactionprovider_share_with);
    return activityChooserView;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The code change includes a new if condition (if (!activityChooserView.isInEditMode())), a change in the way 'drawable' is retrieved (from 'mContext.getResources().getDrawable' to 'mContext.getDrawable'), and the removal of the ActivityChooserModel object instantiation outside the 'if' block, which leads to a change in control dependency (3), other statement changed (4), and dependent API changed (5).","Since the ActivityChooserModel dataModel initialization now only occurs when 'activityChooserView.isInEditMode()' is false, this could potentially lead to a different return value as the ' activityChooserView.setActivityChooserModel(dataModel)' might not be executed which might affect the behavior of the returned 'activityChooserView', hence a CI type 1."
515,<android.os.BatteryStats.HistoryItem: boolean same(HistoryItem)>,20,21,<android.os.BatteryStats.HistoryItem: boolean same(HistoryItem)>,<android.os.BatteryStats.HistoryItem: boolean same(HistoryItem)>,0,"{
    return batteryLevel == o.batteryLevel && batteryStatus == o.batteryStatus && batteryHealth == o.batteryHealth && batteryPlugType == o.batteryPlugType && batteryTemperature == o.batteryTemperature && batteryVoltage == o.batteryVoltage && states == o.states;
}","{
    if (!sameNonEvent(o) || eventCode != o.eventCode) {
        return false;
    }
    if (wakelockTag != o.wakelockTag) {
        if (wakelockTag == null || o.wakelockTag == null) {
            return false;
        }
        if (!wakelockTag.equals(o.wakelockTag)) {
            return false;
        }
    }
    if (wakeReasonTag != o.wakeReasonTag) {
        if (wakeReasonTag == null || o.wakeReasonTag == null) {
            return false;
        }
        if (!wakeReasonTag.equals(o.wakeReasonTag)) {
            return false;
        }
    }
    if (eventTag != o.eventTag) {
        if (eventTag == null || o.eventTag == null) {
            return false;
        }
        if (!eventTag.equals(o.eventTag)) {
            return false;
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The entire implementation has been replaced with a new one, including additional comparisons and method calls (e.g. sameNonEvent()). This is a significant refactor of the original logic that checks various fields for equality. The specific change types are 1 because the return value can be different as the conditions have changed, and 4 due to the introduction of new code statements like additional null checks and method calls.","The refactored code introduces more conditions which can lead to different outcomes for the return value. Therefore, a Compatibility Issue arises because of the potential different return values. The CI type is 1."
517,<android.widget.Scroller: boolean computeScrollOffset()>,20,21,<android.widget.Scroller: boolean computeScrollOffset()>,<android.widget.Scroller: boolean computeScrollOffset()>,0,"{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                float x = timePassed * mDurationReciprocal;
                if (mInterpolator == null)
                    x = viscousFluid(x);
                else
                    x = mInterpolator.getInterpolation(x);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                final float t = (float) timePassed / mDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;
                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}","{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                final float t = (float) timePassed / mDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;
                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}",1,"/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.
 */
","/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
518,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,20,21,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,0,"{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    ArrayList<Fragment> fragments = mFragments.retainNonConfig();
    boolean retainLoaders = false;
    if (mAllLoaderManagers != null) {
        // prune out any loader managers that were already stopped and so
        // have nothing useful to retain.
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = mAllLoaderManagers.valueAt(i);
        }
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            if (lm.mRetaining) {
                retainLoaders = true;
            } else {
                lm.doDestroy();
                mAllLoaderManagers.remove(lm.mWho);
            }
        }
    }
    if (activity == null && children == null && fragments == null && !retainLoaders) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = mAllLoaderManagers;
    return nci;
}","{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    ArrayList<Fragment> fragments = mFragments.retainNonConfig();
    boolean retainLoaders = false;
    if (mAllLoaderManagers != null) {
        // prune out any loader managers that were already stopped and so
        // have nothing useful to retain.
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = mAllLoaderManagers.valueAt(i);
        }
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            if (lm.mRetaining) {
                retainLoaders = true;
            } else {
                lm.doDestroy();
                mAllLoaderManagers.remove(lm.mWho);
            }
        }
    }
    if (activity == null && children == null && fragments == null && !retainLoaders && mVoiceInteractor == null) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = mAllLoaderManagers;
    nci.voiceInteractor = mVoiceInteractor;
    return nci;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency has changed with the addition of a new condition 'mVoiceInteractor == null' to the 'if' statement, and the new variable 'nci.voiceInteractor = mVoiceInteractor;' is set before the return statement. These modifications fall under control dependency change and other statement change, making the change type 3,4.","The additional condition in the 'if' statement and assignment of 'nci.voiceInteractor' could lead to the method returning a different value (an instance of `NonConfigurationInstances` with potentially non-null `voiceInteractor`), thus the CI type is 1."
519,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",20,21,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(uri, modeFlags);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}",1,"/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of this method has changed with a modification on the argument passed to `ActivityManagerNative.getDefault().takePersistableUriPermission(...)`. In the late version, the method now calls `ContentProvider.getUriWithoutUserId(uri)` and `resolveUserId(uri)` as part of the argument. These modifications relate to how the method processes the 'uri' parameter, affecting the method's internal behaviour; thus, the change type is 4,5.","Since the API now potentially processes the 'uri' differently because of the new processing steps introduced in the arguments, there might be a different outcome from the method's execution (for example, a different handling of URI permissions), so the CI type is 1."
520,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliableSocketPair()>,20,21,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliableSocketPair()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliableSocketPair()>,0,"{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
","/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call `Libcore.os.socketpair` was changed to `Os.socketpair`, which is considered as a Dependent API changed (type 5). There are no changes to the return statement, exception handling statement, or control dependencies; this is purely an internal change which may be a part of platform evolution requiring dependent API changes. There might be also another type of change, which is the Other statement changed (type 4), because the method invocation itself was changed.","Although there is an internal change to the method, as long as the new method (`Os.socketpair`) behaves identically to the old method (`Libcore.os.socketpair`) with respect to creating socket pairs, there would be no change in the behavior of the `createReliableSocketPair()` API from the perspective of the caller. Hence, there is no Compatibility Issue (CI type 0)."
521,"<android.util.LongSparseArray: void append(long,E)>",20,21,"<android.util.LongSparseArray: void append(long,E)>","<android.util.LongSparseArray: void append(long,E)>",0,"{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealLongArraySize(pos + 1);
        long[] nkeys = new long[n];
        Object[] nvalues = new Object[n];
        // Log.e(""SparseArray"", ""grow "" + mKeys.length + "" to "" + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}","{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}",1,"/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
","/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The method of expanding arrays and appending new elements has changed. Instead of manual array copy and reassignment, the late version uses the GrowingArrayUtils.append helper method. The actual statements and array operations inside the method have been altered but the behavior to the calling API remains unchanged, so the code change type includes 3 (because the control flow surrounding the array growth logic has been simplified by using the GrowingArrayUtils.append), 4 (the method of appending the new key and value has changed from a direct assignment to using a helper method), and 5 (due to a dependent API change, which in this case is the use of GrowingArrayUtils.append).","No Compatibility Issue is detected because the change doesn't alter the successful path behavior of the method. If the conditions for adding to the arrays are satisfied in the same way as they were earlier, the append operation's side effects remain the same (adding a new key-value pair to the arrays). The method's contract and the overall observable behavior from a caller's perspective are preserved, so there's no CI due to different return values or exception handlings (the method is void and doesn't throw checked exceptions)."
523,"<android.service.notification.NotificationListenerService: void cancelNotification(String,String,int)>",20,21,"<android.service.notification.NotificationListenerService: void cancelNotification(String,String,int)>","<android.service.notification.NotificationListenerService: void cancelNotification(String,String,int)>",0,"{
    try {
        getNotificationInterface().cancelNotificationFromListener(mWrapper, pkg, tag, id);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, ""Unable to contact notification manager"", ex);
    }
}","{
    if (!isBound())
        return;
    try {
        getNotificationInterface().cancelNotificationFromListener(mWrapper, pkg, tag, id);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, ""Unable to contact notification manager"", ex);
    }
}",1,"/**
 * Inform the notification manager about dismissal of a single notification.
 * <p>
 * Use this if your listener has a user interface that allows the user to dismiss individual
 * notifications, similar to the behavior of Android's status bar and notification panel.
 * It should be called after the user dismisses a single notification using your UI;
 * upon being informed, the notification manager will actually remove the notification
 * and you will get an {@link #onNotificationRemoved(StatusBarNotification)} callback.
 * <P>
 * <b>Note:</b> If your listener allows the user to fire a notification's
 * {@link android.app.Notification#contentIntent} by tapping/clicking/etc., you should call
 * this method at that time <i>if</i> the Notification in question has the
 * {@link android.app.Notification#FLAG_AUTO_CANCEL} flag set.
 *
 * @param pkg Package of the notifying app.
 * @param tag Tag of the notification as specified by the notifying app in
 * {@link android.app.NotificationManager#notify(String, int, android.app.Notification)}.
 * @param id  ID of the notification as specified by the notifying app in
 * {@link android.app.NotificationManager#notify(String, int, android.app.Notification)}.
 */
","/**
 * Inform the notification manager about dismissal of a single notification.
 * <p>
 * Use this if your listener has a user interface that allows the user to dismiss individual
 * notifications, similar to the behavior of Android's status bar and notification panel.
 * It should be called after the user dismisses a single notification using your UI;
 * upon being informed, the notification manager will actually remove the notification
 * and you will get an {@link #onNotificationRemoved(StatusBarNotification)} callback.
 * <P>
 * <b>Note:</b> If your listener allows the user to fire a notification's
 * {@link android.app.Notification#contentIntent} by tapping/clicking/etc., you should call
 * this method at that time <i>if</i> the Notification in question has the
 * {@link android.app.Notification#FLAG_AUTO_CANCEL} flag set.
 *
 * @param pkg Package of the notifying app.
 * @param tag Tag of the notification as specified by the notifying app in
 * {@link android.app.NotificationManager#notify(String, int, android.app.Notification)}.
 * @param id  ID of the notification as specified by the notifying app in
 * {@link android.app.NotificationManager#notify(String, int, android.app.Notification)}.
 * <p>
 * @deprecated Use {@link #cancelNotification(String key)}
 * instead. Beginning with {@link android.os.Build.VERSION_CODES#LOLLIPOP} this method will no longer
 * cancel the notification. It will continue to cancel the notification for applications
 * whose {@code targetSdkVersion} is earlier than {@link android.os.Build.VERSION_CODES#LOLLIPOP}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,A control dependency change has been introduced which is the 'if' check (if (!isBound()) return;) prior to the try block. So the code change type is 3.,"The newly added 'if' condition checks if the service is bound before attempting to cancel the notification. This check provides an early return if the service is not bound which does not change exception handling or modify the type or value of return, as the method's return type is void. Therefore, no potential Compatibility Issue arises, the CI type is 0."
524,"<android.content.res.TypedArray: float getFloat(int,float)>",20,21,"<android.content.res.TypedArray: float getFloat(int,float)>","<android.content.res.TypedArray: float getFloat(int,float)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to float: "" + v);
        CharSequence str = v.coerceToString();
        if (str != null) {
            return Float.parseFloat(str.toString());
        }
    }
    Log.w(Resources.TAG, ""getFloat of bad type: 0x"" + Integer.toHexString(type));
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to float: "" + v);
        CharSequence str = v.coerceToString();
        if (str != null) {
            return Float.parseFloat(str.toString());
        }
    }
    Log.w(Resources.TAG, ""getFloat of bad type: 0x"" + Integer.toHexString(type));
    return defValue;
}",1,"/**
 * Retrieve the float value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if not defined..
 */
","/**
 * Retrieve the float value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if not defined..
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement has been introduced at the beginning of the late implementation (`throw new RuntimeException`). There are no other changes within the control flow or the return statements, so this falls under change types 2 and 4.","The newly introduced exception handling statement could lead to a different exception being thrown in situations where `mRecycled` is `true`, which is a potential Compatibility Issue of type 2."
525,<android.view.textservice.TextInfo: String getText()>,20,21,<android.view.textservice.TextInfo: String getText()>,<android.view.textservice.TextInfo: String getText()>,0,"{
    return mText;
}","{
    if (mCharSequence == null) {
        return null;
    }
    return mCharSequence.toString();
}",1,"/**
 * @return the text which is an input of a text service
 */
","/**
 * @return the text which is an input of a text service
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late implementation introduced a control dependency change with the addition of an 'if' statement checking if the 'mCharSequence' is null. Furthermore, a new return path is added, returning 'null' if 'mCharSequence' is null, and there's a change in the variable that the value is returned from (from 'mText' to 'mCharSequence.toString()'). Therefore, the code change type is 1,3.","The inclusion of a conditional check which could return 'null', as well as a change from 'mText' to 'mCharSequence.toString()', means the method could return a different value than before. Therefore, it is considered a compatibility issue of type 1."
526,"<android.content.res.Resources: TypedArray obtainAttributes(AttributeSet,int[])>",20,21,"<android.content.res.Resources: TypedArray obtainAttributes(AttributeSet,int[])>","<android.content.res.Resources: TypedArray obtainAttributes(AttributeSet,int[])>",0,"{
    int len = attrs.length;
    TypedArray array = getCachedStyledAttributes(len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mAssets.retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
    array.mRsrcs = attrs;
    array.mXml = parser;
    return array;
}","{
    int len = attrs.length;
    TypedArray array = TypedArray.obtain(this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mAssets.retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
    array.mXml = parser;
    return array;
}",1,"/**
 * Retrieve a set of basic attribute values from an AttributeSet, not
 * performing styling of them using a theme and/or style resources.
 *
 * @param set The current attribute values to retrieve.
 * @param attrs The specific attributes to be retrieved.
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
 */
","/**
 * Retrieve a set of basic attribute values from an AttributeSet, not
 * performing styling of them using a theme and/or style resources.
 *
 * @param set The current attribute values to retrieve.
 * @param attrs The specific attributes to be retrieved.
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change only involves replacing `getCachedStyledAttributes(len)` with `TypedArray.obtain(this, len)` and the removal of the line `array.mRsrcs = attrs;`. These changes do not affect the method behavior in terms of what it returns or how it handles exceptions, so the code change type is 4.","There is no Compatibility Issue, since the return value and exception handling behavior of the method have not changed. The difference in acquiring the TypedArray doesn't inherently alter the returned TypedArray content, nor does the removal of the `array.mRsrcs = attrs;` line change the output to the caller, assuming that the implementation of `TypedArray.obtain(this, len)` properly initializes all necessary fields of TypedArray to maintain the same behavior as `getCachedStyledAttributes(len)`. Therefore, the CI type is 0."
527,"<android.util.LongSparseArray: void put(long,E)>",20,21,"<android.util.LongSparseArray: void put(long,E)>","<android.util.LongSparseArray: void put(long,E)>",0,"{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealLongArraySize(mSize + 1);
            long[] nkeys = new long[n];
            Object[] nvalues = new Object[n];
            // Log.e(""SparseArray"", ""grow "" + mKeys.length + "" to "" + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e(""SparseArray"", ""move "" + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}","{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}",1,"/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */
","/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes replacing several lines of code responsible for array resizing and element assignment with a call to the GrowingArrayUtils.insert method for both mKeys and mValues arrays. As GrowingArrayUtils.insert is a dependent API, this change is classified under category 4 and 5.","There's no Compatibility Issue because the changed code does not affect the outward behavior of the API; it only modifies the internal implementation to presumably make it more efficient or cleaner. The method signature remains the same, and as long as the GrowingArrayUtils.insert method performs the same action as the replaced code, i.e., correctly resizing the arrays and inserting the keys and values, the API should not behave differently from a caller's perspective. The change is internal refactoring."
528,<android.widget.TextView.Marquee: void start(int)>,20,21,<android.widget.TextView.Marquee: void start(int)>,<android.widget.TextView.Marquee: void start(int)>,0,"{
    if (repeatLimit == 0) {
        stop();
        return;
    }
    mRepeatLimit = repeatLimit;
    final TextView textView = mView.get();
    if (textView != null && textView.mLayout != null) {
        mStatus = MARQUEE_STARTING;
        mScroll = 0.0f;
        final int textWidth = textView.getWidth() - textView.getCompoundPaddingLeft() - textView.getCompoundPaddingRight();
        final float lineWidth = textView.mLayout.getLineWidth(0);
        final float gap = textWidth / 3.0f;
        mGhostStart = lineWidth - textWidth + gap;
        mMaxScroll = mGhostStart + textWidth;
        mGhostOffset = lineWidth + gap;
        mFadeStop = lineWidth + textWidth / 6.0f;
        mMaxFadeScroll = mGhostStart + lineWidth + lineWidth;
        textView.invalidate();
        sendEmptyMessageDelayed(MESSAGE_START, MARQUEE_DELAY);
    }
}","{
    if (repeatLimit == 0) {
        stop();
        return;
    }
    mRepeatLimit = repeatLimit;
    final TextView textView = mView.get();
    if (textView != null && textView.mLayout != null) {
        mStatus = MARQUEE_STARTING;
        mScroll = 0.0f;
        final int textWidth = textView.getWidth() - textView.getCompoundPaddingLeft() - textView.getCompoundPaddingRight();
        final float lineWidth = textView.mLayout.getLineWidth(0);
        final float gap = textWidth / 3.0f;
        mGhostStart = lineWidth - textWidth + gap;
        mMaxScroll = mGhostStart + textWidth;
        mGhostOffset = lineWidth + gap;
        mFadeStop = lineWidth + textWidth / 6.0f;
        mMaxFadeScroll = mGhostStart + lineWidth + lineWidth;
        textView.invalidate();
        mChoreographer.postFrameCallback(mStartCallback);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the method of scheduling a callback: from sendEmptyMessageDelayed() to mChoreographer.postFrameCallback(). This represents a change in the implementation detail, but it is not related to return statements or exception handling, and it doesn't change the control flow, so the code change type is 4.","Despite the method of scheduling the start of the marquee being altered, this will not directly cause a difference in the return values or the exceptions thrown by the API. The marquee will still start, just with a different internal scheduling mechanism. Therefore, no Compatibility Issue should arise, and the CI type is 0."
533,<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,20,21,<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,0,"{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
                result = session.restorePackage(mContext.getPackageName(), observer);
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""restoreSelf() unable to contact service"");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}","{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
                result = session.restorePackage(mContext.getPackageName(), observer);
            }
        } catch (RemoteException e) {
            Log.e(TAG, ""restoreSelf() unable to contact service"");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}",1,"/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */
","/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is within a logging statement, changing from ""Log.w"" to ""Log.e"", so the change type is 4.","There is no compatibility issue since the change does not affect the method's return value or the exceptions it throws. It's simply a change in the log level severity, which does not affect the API's behavior."
534,"<android.animation.PropertyValuesHolder: PropertyValuesHolder ofKeyframe(String,Keyframe)>",20,21,"<android.animation.PropertyValuesHolder: PropertyValuesHolder ofKeyframe(String,Keyframe)>","<android.animation.PropertyValuesHolder: PropertyValuesHolder ofKeyframe(String,Keyframe)>",0,"{
    KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
    if (keyframeSet instanceof IntKeyframeSet) {
        return new IntPropertyValuesHolder(propertyName, (IntKeyframeSet) keyframeSet);
    } else if (keyframeSet instanceof FloatKeyframeSet) {
        return new FloatPropertyValuesHolder(propertyName, (FloatKeyframeSet) keyframeSet);
    } else {
        PropertyValuesHolder pvh = new PropertyValuesHolder(propertyName);
        pvh.mKeyframeSet = keyframeSet;
        pvh.mValueType = ((Keyframe) values[0]).getType();
        return pvh;
    }
}","{
    KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
    return ofKeyframes(propertyName, keyframeSet);
}",1,"/**
 * Constructs and returns a PropertyValuesHolder object with the specified property name and set
 * of values. These values can be of any type, but the type should be consistent so that
 * an appropriate {@link android.animation.TypeEvaluator} can be found that matches
 * the common type.
 * <p>If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 * @param propertyName The name of the property associated with this set of values. This
 * can be the actual property name to be used when using a ObjectAnimator object, or
 * just a name used to get animated values, such as if this object is used with an
 * ValueAnimator object.
 * @param values The set of values to animate between.
 */
","/**
 * Constructs and returns a PropertyValuesHolder object with the specified property name and set
 * of values. These values can be of any type, but the type should be consistent so that
 * an appropriate {@link android.animation.TypeEvaluator} can be found that matches
 * the common type.
 * <p>If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 * @param propertyName The name of the property associated with this set of values. This
 * can be the actual property name to be used when using a ObjectAnimator object, or
 * just a name used to get animated values, such as if this object is used with an
 * ValueAnimator object.
 * @param values The set of values to animate between.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method changed completely from a conditional block creating different types of PropertyValuesHolder based on the type of KeyframeSet to a single line effectively delegating the process to another method (ofKeyframes(propertyName, keyframeSet)). This indicates that the dependent API has been changed (type 5). There's a change in the return statement as well because it no longer decides what kind of PropertyValuesHolder to return based on the instance type check in the early version (type 1).","As the implementation now delegates to a different method, the behaviour (and the returned value) could potentially change based on what the newly called method does, which is a change that can cause a different return value (CI type 1)."
536,<android.app.UiAutomation: Bitmap takeScreenshot()>,20,21,<android.app.UiAutomation: Bitmap takeScreenshot()>,<android.app.UiAutomation: Bitmap takeScreenshot()>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    final int displayWidth = displaySize.x;
    final int displayHeight = displaySize.y;
    final float screenshotWidth;
    final float screenshotHeight;
    final int rotation = display.getRotation();
    switch(rotation) {
        case ROTATION_FREEZE_0:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_90:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        case ROTATION_FREEZE_180:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_270:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Invalid rotation: "" + rotation);
            }
    }
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot((int) screenshotWidth, (int) screenshotHeight);
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while taking screnshot!"", re);
        return null;
    }
    // Rotate the screenshot to the current orientation
    if (rotation != ROTATION_FREEZE_0) {
        Bitmap unrotatedScreenShot = Bitmap.createBitmap(displayWidth, displayHeight, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(unrotatedScreenShot);
        canvas.translate(unrotatedScreenShot.getWidth() / 2, unrotatedScreenShot.getHeight() / 2);
        canvas.rotate(getDegreesForRotation(rotation));
        canvas.translate(-screenshotWidth / 2, -screenshotHeight / 2);
        canvas.drawBitmap(screenShot, 0, 0, null);
        canvas.setBitmap(null);
        screenShot = unrotatedScreenShot;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}","{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    final int displayWidth = displaySize.x;
    final int displayHeight = displaySize.y;
    final float screenshotWidth;
    final float screenshotHeight;
    final int rotation = display.getRotation();
    switch(rotation) {
        case ROTATION_FREEZE_0:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_90:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        case ROTATION_FREEZE_180:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_270:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Invalid rotation: "" + rotation);
            }
    }
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot((int) screenshotWidth, (int) screenshotHeight);
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while taking screnshot!"", re);
        return null;
    }
    // Rotate the screenshot to the current orientation
    if (rotation != ROTATION_FREEZE_0) {
        Bitmap unrotatedScreenShot = Bitmap.createBitmap(displayWidth, displayHeight, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(unrotatedScreenShot);
        canvas.translate(unrotatedScreenShot.getWidth() / 2, unrotatedScreenShot.getHeight() / 2);
        canvas.rotate(getDegreesForRotation(rotation));
        canvas.translate(-screenshotWidth / 2, -screenshotHeight / 2);
        canvas.drawBitmap(screenShot, 0, 0, null);
        canvas.setBitmap(null);
        screenShot.recycle();
        screenShot = unrotatedScreenShot;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}",1,"/**
 * Takes a screenshot.
 *
 * @return The screenshot bitmap on success, null otherwise.
 */
","/**
 * Takes a screenshot.
 *
 * @return The screenshot bitmap on success, null otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of `screenShot.recycle();` before creating a new `Bitmap`. This is a change that affects the internal operation (memory management) rather than the behavior seen by the user, hence it's an Other statement changed (4).","The method's contract and return behavior are unchanged, and since the screenshot is being returned after recycling the interim bitmap (which is an internal detail not affecting the output), there is no compatibility issue as long as the returned object meets the API's stated contract. Therefore, the CI type is 0 (No Compatibility Issue)."
537,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>",20,21,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>","<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadColorStateList"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException(""Resource is not a ColorStateList (color or path): "" + value);
    }
    String file = value.string.toString();
    if (file.endsWith("".xml"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
        try {
            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""colorstatelist"");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            NotFoundException rnf = new NotFoundException(""File "" + file + "" from color state list resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    } else {
        throw new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id) + "": .xml extension required"");
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        } else {
            synchronized (mAccessLock) {
                // Log.i(TAG, ""Saving cached color state list @ #"" +
                // Integer.toHexString(key.intValue())
                // + "" in "" + this + "": "" + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadColorStateList"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException(""Resource is not a ColorStateList (color or path): "" + value);
    }
    final String file = value.string.toString();
    if (file.endsWith("".xml"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
        try {
            final XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""colorstatelist"");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            NotFoundException rnf = new NotFoundException(""File "" + file + "" from color state list resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    } else {
        throw new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id) + "": .xml extension required"");
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        } else {
            synchronized (mAccessLock) {
                // Log.i(TAG, ""Saving cached color state list @ #"" +
                // Integer.toHexString(key.intValue())
                // + "" in "" + this + "": "" + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,,,,
538,<android.hardware.camera2.CaptureRequest: int hashCode()>,20,21,<android.hardware.camera2.CaptureRequest: int hashCode()>,<android.hardware.camera2.CaptureRequest: int hashCode()>,0,"{
    return mSettings.hashCode();
}","{
    return HashCodeHelpers.hashCode(mSettings, mSurfaceSet, mUserTag);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method's implementation to calculate the hash code has changed from using just 'mSettings.hashCode()' to using 'HashCodeHelpers.hashCode(mSettings, mSurfaceSet, mUserTag)'. Since HashCodeHelpers.hashCode() involves additional fields, the returned hash value could be different. This is a change in both return statement and an other statement (method used to calculate hash code).","The 'hashCode()' method will potentially return a different value due to the change in the way the hash code is being calculated. Therefore, the CI type is 1, indicating a potential different return value."
539,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",20,21,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>","<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",0,"{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException(""Locale should not be null if you don't refer"" + "" settings."");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String inputLocale = locale.toString();
            if (subtypeLocale.length() < 2 || inputLocale.length() < 2 || !subtypeLocale.substring(0, 2).equals(inputLocale.substring(0, 2))) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (localeStr.length() >= 2 && tempSubtypeLocale.length() >= 2 && localeStr.startsWith(tempSubtypeLocale)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener, subtypeInUse);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}","{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException(""Locale should not be null if you don't refer"" + "" settings."");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener, subtypeInUse);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}",1,"/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */
","/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"There are changes in the control dependency that affect how locale language is compared (`locale.toString().substring(0, 2).equals(inputLocale.substring(0, 2))` changed to `locale.getLanguage().equals(subtypeLanguage)`), and the dependent API `parseLanguageFromLocaleString` is introduced for parsing the language from the locale string, so the code change type is 3,5.","The modification in control dependency changes how languages are compared, which could lead to a change in the behavior of matching locales. Moreover, the introduction of the `parseLanguageFromLocaleString` dependent API could also alter the result of the method. Due to these changes, there is a potential that the API may return a different value (either return a different session or null) in different scenarios than the early version, leading to CI type 1."
540,<android.bluetooth.BluetoothSocket: void flush()>,20,21,<android.bluetooth.BluetoothSocket: void flush()>,<android.bluetooth.BluetoothSocket: void flush()>,0,"{
    if (VDBG)
        Log.d(TAG, ""flush: "" + mSocketOS);
    mSocketOS.flush();
}","{
    if (mSocketOS == null)
        throw new IOException(""flush is called on null OutputStream"");
    if (VDBG)
        Log.d(TAG, ""flush: "" + mSocketOS);
    mSocketOS.flush();
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The late implementation introduces a new null check for mSocketOS, leading to a potential IOException if mSocketOS is null, and control dependency on this variable, so the change type is 2,3,4.","The newly introduced null check and exception throwing mechanism for mSocketOS will cause the method to throw an IOException when mSocketOS is null, which is a behavior not present in the early version. Hence, it's a Compatibility Issue caused by potential different exception handlings (CI type 2)."
542,<android.transition.Transition: Transition clone()>,20,21,<android.transition.Transition: Transition clone()>,<android.transition.Transition: Transition clone()>,0,"{
    Transition clone = null;
    try {
        clone = (Transition) super.clone();
        clone.mAnimators = new ArrayList<Animator>();
        clone.mStartValues = new TransitionValuesMaps();
        clone.mEndValues = new TransitionValuesMaps();
    } catch (CloneNotSupportedException e) {
    }
    return clone;
}","{
    Transition clone = null;
    try {
        clone = (Transition) super.clone();
        clone.mAnimators = new ArrayList<Animator>();
        clone.mStartValues = new TransitionValuesMaps();
        clone.mEndValues = new TransitionValuesMaps();
        clone.mStartValuesList = null;
        clone.mEndValuesList = null;
    } catch (CloneNotSupportedException e) {
    }
    return clone;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Two new assignments `clone.mStartValuesList = null;` and `clone.mEndValuesList = null;` to the clone object have been added in the late version, so the code change type is 4.","The added assigments to null only reset the state of the cloned object but do not alter the control flow or exception handling of the method. As such, these changes will not cause the method to return a different value or throw a new exception. There is no Compatibility Issue, thus CI type is 0."
544,"<android.transition.Transition: Transition excludeChildren(int,boolean)>",20,21,"<android.transition.Transition: Transition excludeChildren(int,boolean)>","<android.transition.Transition: Transition excludeChildren(int,boolean)>",0,"{
    mTargetIdChildExcludes = excludeId(mTargetIdChildExcludes, targetId, exclude);
    return this;
}","{
    if (targetId >= 0) {
        mTargetIdChildExcludes = excludeObject(mTargetIdChildExcludes, targetId, exclude);
    }
    return this;
}",1,"/**
 * Whether to add the children of the given id to the list of targets to exclude
 * from this transition. The <code>exclude</code> parameter specifies whether
 * the children of the target should be added to or removed from the excluded list.
 * Excluding children in this way provides a simple mechanism for excluding all
 * children of specific targets, rather than individually excluding each
 * child individually.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeTarget(int, boolean)
 * @see #excludeChildren(View, boolean)
 * @see #excludeChildren(Class, boolean)
 *
 * @param targetId The id of a target whose children should be ignored when running
 * this transition.
 * @param exclude Whether to add the target to or remove the target from the
 * current list of excluded-child targets.
 * @return This transition object.
 */
","/**
 * Whether to add the children of the given id to the list of targets to exclude
 * from this transition. The <code>exclude</code> parameter specifies whether
 * the children of the target should be added to or removed from the excluded list.
 * Excluding children in this way provides a simple mechanism for excluding all
 * children of specific targets, rather than individually excluding each
 * child individually.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeTarget(int, boolean)
 * @see #excludeChildren(View, boolean)
 * @see #excludeChildren(Class, boolean)
 *
 * @param targetId The id of a target whose children should be ignored when running
 * this transition.
 * @param exclude Whether to add the target to or remove the target from the
 * current list of excluded-child targets.
 * @return This transition object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The condition check has been introduced before excluding the id, and the method name from excludeId to excludeObject also changed. So the code change type is 3,5.","Despite the change in how the targetId is handled, the late version of the method will still return 'this' and the exclusion is only updated if `targetId >= 0`, which adds a guard clause to prevent the method from performing an action on an invalid id. However, since this just prevents the action in more cases and the method still successfully returns 'this' (the same as before), no new behaviors are introduced that would affect the return type or exceptions thrown by the method: no Compatibility Issue arises."
547,<android.widget.AbsListView: boolean onInterceptHoverEvent(MotionEvent)>,20,21,<android.widget.AbsListView: boolean onInterceptHoverEvent(MotionEvent)>,<android.widget.AbsListView: boolean onInterceptHoverEvent(MotionEvent)>,0,"{
    if (mFastScroller != null && mFastScroller.onInterceptHoverEvent(event)) {
        return true;
    }
    return super.onInterceptHoverEvent(event);
}","{
    if (mFastScroll != null && mFastScroll.onInterceptHoverEvent(event)) {
        return true;
    }
    return super.onInterceptHoverEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API reference mFastScroller has been renamed to mFastScroll. This is a change in the name of the variable, not in the functionality or signature of the method itself. No other changes are present in the return statements or exception handling, so the code change type is 5.","Since only a variable has been renamed and it is internal to the implementation, assuming the renamed variable mFastScroll has the same type and behavior as mFastScroller, there is no compatibility issue arising from this change, and the functionality remains the same. Thus, there is no Compatibility Issue, and the CI type is 0."
548,<android.app.admin.DevicePolicyManager: List<ComponentName> getActiveAdmins()>,20,21,<android.app.admin.DevicePolicyManager: List<ComponentName> getActiveAdmins()>,<android.app.admin.DevicePolicyManager: List<ComponentName> getActiveAdmins()>,0,"{
    if (mService != null) {
        try {
            return mService.getActiveAdmins(UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return null;
}","{
    return getActiveAdminsAsUser(UserHandle.myUserId());
}",1,"/**
 * Return a list of all currently active device administrator's component
 * names.  Note that if there are no administrators than null may be
 * returned.
 */
","/**
 * Return a list of all currently active device administrator's component
 * names.  Note that if there are no administrators than null may be
 * returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method implementation has been changed to call a new method, getActiveAdminsAsUser(UserHandle.myUserId()). Since there is no internal implementation logic provided for the new method, we cannot determine if there are any changes in return statements or exception handling. The code change type is 5 because the implementation now relies on a different method.","Based on the provided information, we cannot determine any potential differences in return values, return types or exception handling between the two versions. The change seems to be a refactoring to use a more general method, and it is assumed that getActiveAdminsAsUser() behaves the same way as the original code. Thus, there is no Compatibility Issue detected."
550,<android.content.RestrictionEntry: int hashCode()>,20,21,<android.content.RestrictionEntry: int hashCode()>,<android.content.RestrictionEntry: int hashCode()>,0,"{
    int result = 17;
    result = 31 * result + key.hashCode();
    if (currentValue != null) {
        result = 31 * result + currentValue.hashCode();
    } else if (currentValues != null) {
        for (String value : currentValues) {
            if (value != null) {
                result = 31 * result + value.hashCode();
            }
        }
    }
    return result;
}","{
    int result = 17;
    result = 31 * result + mKey.hashCode();
    if (mCurrentValue != null) {
        result = 31 * result + mCurrentValue.hashCode();
    } else if (mCurrentValues != null) {
        for (String value : mCurrentValues) {
            if (value != null) {
                result = 31 * result + value.hashCode();
            }
        }
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change only consists of renaming the member variables from `key`, `currentValue`, and `currentValues` to `mKey`, `mCurrentValue`, and `mCurrentValues`, which does not affect the logic of the method. Therefore, the code change type is 4.","Since there is no change in behavior, logic, or return type, just renaming the variables, there is no Compatibility Issue as the renaming of internal variables does not change the contract of the method or its behavior when called by external code. The return value will remain the same for the same object state, hence no CI exists."
551,"<android.transition.Transition: Transition excludeChildren(View,boolean)>",20,21,"<android.transition.Transition: Transition excludeChildren(View,boolean)>","<android.transition.Transition: Transition excludeChildren(View,boolean)>",0,"{
    mTargetChildExcludes = excludeView(mTargetChildExcludes, target, exclude);
    return this;
}","{
    mTargetChildExcludes = excludeObject(mTargetChildExcludes, target, exclude);
    return this;
}",1,"/**
 * Whether to add the children of given target to the list of target children
 * to exclude from this transition. The <code>exclude</code> parameter specifies
 * whether the target should be added to or removed from the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeTarget(View, boolean)
 * @see #excludeChildren(int, boolean)
 * @see #excludeChildren(Class, boolean)
 *
 * @param target The target to ignore when running this transition.
 * @param exclude Whether to add the target to or remove the target from the
 * current list of excluded targets.
 * @return This transition object.
 */
","/**
 * Whether to add the children of given target to the list of target children
 * to exclude from this transition. The <code>exclude</code> parameter specifies
 * whether the target should be added to or removed from the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeTarget(View, boolean)
 * @see #excludeChildren(int, boolean)
 * @see #excludeChildren(Class, boolean)
 *
 * @param target The target to ignore when running this transition.
 * @param exclude Whether to add the target to or remove the target from the
 * current list of excluded targets.
 * @return This transition object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called has changed from excludeView to excludeObject. This indicates a change in the implementation details, but as long as excludeObject behaves identically to excludeView for the given parameters, it does not inherently lead to a CI. Therefore the changed code type is 4,5.","There is no Compatibility Issue as the object 'this' is being returned in both versions and the change in the method does not imply a difference in the object state that would be externally observable through the API, assuming excludeObject operates correctly as excludeView did in terms of the API's contract."
552,<android.os.CountDownTimer: CountDownTimer start()>,20,21,<android.os.CountDownTimer: CountDownTimer start()>,<android.os.CountDownTimer: CountDownTimer start()>,0,"{
    if (mMillisInFuture <= 0) {
        onFinish();
        return this;
    }
    mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;
    mHandler.sendMessage(mHandler.obtainMessage(MSG));
    return this;
}","{
    mCancelled = false;
    if (mMillisInFuture <= 0) {
        onFinish();
        return this;
    }
    mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;
    mHandler.sendMessage(mHandler.obtainMessage(MSG));
    return this;
}",1,"/**
 * Start the countdown.
 */
","/**
 * Start the countdown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new assignment statement `mCancelled = false;` has been added at the beginning of the late implementation, which does not affect the API's control flow or the values returned from the API calls. As such, the code change type is 4.","No Compatibility Issue is detected because the change does not influence the return values or the exceptions that might be thrown by the API method. The behavior with respect to the return value and exception handling remains consistent with the earlier version, so the CI type is 0."
553,<android.widget.DatePicker: int getYear()>,20,21,<android.widget.DatePicker: int getYear()>,<android.widget.DatePicker: int getYear()>,0,"{
    return mCurrentDate.get(Calendar.YEAR);
}","{
    return mDelegate.getYear();
}",1,"/**
 * @return The selected year.
 */
","/**
 * @return The selected year.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation of the method has changed from using `mCurrentDate.get(Calendar.YEAR)` to `mDelegate.getYear()`. The change here is a result of calling a different method of a potentially different object. This indicates a different dependent API is used in the late version, which is categorized as a type 5 change.","The behavior may differ based on what `mDelegate.getYear()` implements compared to `mCurrentDate.get(Calendar.YEAR)`. If `mDelegate` represents a different way of calculating or getting the year, the returned value could potentially differ. This is a type 1 compatibility issue due to the potential for the method to return different values."
554,"<android.view.GLES20Canvas: void drawText(String,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawText(String,float,float,Paint)>","<android.view.GLES20Canvas: void drawText(String,float,float,Paint)>",0,"{
    int modifiers = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, 0, text.length(), x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    nDrawText(mRenderer, text, 0, text.length(), x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"There are multiple statement changes between the two versions. The early implementation contains a try-finally block to handle modifiers, which is not present in the late implementation. The call to nDrawText in the late implementation includes an additional parameter, paint.mNativeTypeface. The method setupModifiers and if statement with the call to nResetModifiers are removed in the late version. These changes identify as a Return statement change (1) because they alter how the result is produced and an Other statement change (4) because of the removal of the try-finally block.","These changes do not constitute a Compatibility Issue, as the API's purpose—to draw text onto the canvas—remains functionally the same. The setup and reset of modifiers and the inclusion of the native typeface does not alter the expected behavior from the perspective of the API call, even if the internal workings of how the text drawing is performed have changed."
557,<android.bluetooth.BluetoothGatt: void abortReliableWrite()>,20,21,<android.bluetooth.BluetoothGatt: void abortReliableWrite()>,<android.bluetooth.BluetoothGatt: void abortReliableWrite()>,0,"{
    if (DBG)
        Log.d(TAG, ""abortReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return;
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), false);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    if (VDBG)
        Log.d(TAG, ""abortReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return;
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), false);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}",1,"/**
 * Cancels a reliable write transaction for a given device.
 *
 * <p>Calling this function will discard all queued characteristic write
 * operations for a given remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 */
","/**
 * Cancels a reliable write transaction for a given device.
 *
 * <p>Calling this function will discard all queued characteristic write
 * operations for a given remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the debug logging condition from DBG to VDBG, which falls under Other statement changed, so the code change type is 4.","This change will not affect the behavior of the API, as it is only related to the level of debugging detail and does not impact the execution flow, return values, or exception handling within the API. Therefore, there is no Compatibility Issue, and the CI type is 0."
558,"<android.view.View.MeasureSpec: int adjust(int,int)>",20,21,"<android.view.View.MeasureSpec: int adjust(int,int)>","<android.view.View.MeasureSpec: int adjust(int,int)>",0,"{
    return makeMeasureSpec(getSize(measureSpec + delta), getMode(measureSpec));
}","{
    final int mode = getMode(measureSpec);
    if (mode == UNSPECIFIED) {
        // No need to adjust size for UNSPECIFIED mode.
        return makeMeasureSpec(0, UNSPECIFIED);
    }
    int size = getSize(measureSpec) + delta;
    if (size < 0) {
        Log.e(VIEW_LOG_TAG, ""MeasureSpec.adjust: new size would be negative! ("" + size + "") spec: "" + toString(measureSpec) + "" delta: "" + delta);
        size = 0;
    }
    return makeMeasureSpec(size, mode);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency has changed (added 'if' conditional statement checking for UNSPECIFIED mode), and there's a new return statement inside the new condition for the UNSPECIFIED mode. Therefore, the code change type is 1,3.","Due to the new condition that checks whether the mode is UNSPECIFIED and returns a different value if it is, the late version of the API could return a different value than the early version, thus causing a compatibility issue. Therefore, the CI type is 1."
559,<android.view.View: float getTranslationX()>,20,21,<android.view.View: float getTranslationX()>,<android.view.View: float getTranslationX()>,0,"{
    return mTransformationInfo != null ? mTransformationInfo.mTranslationX : 0;
}","{
    return mRenderNode.getTranslationX();
}",1,"/**
 * The horizontal location of this view relative to its {@link #getLeft() left} position.
 * This position is post-layout, in addition to wherever the object's
 * layout placed it.
 *
 * @return The horizontal position of this view relative to its left position, in pixels.
 */
","/**
 * The horizontal location of this view relative to its {@link #getLeft() left} position.
 * This position is post-layout, in addition to wherever the object's
 * layout placed it.
 *
 * @return The horizontal position of this view relative to its left position, in pixels.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from accessing a field with a conditional check (mTransformationInfo != null ? mTransformationInfo.mTranslationX : 0) to invoking a method directly (mRenderNode.getTranslationX()). The dependent API used within the method has changed, thus the code change type is 1,5.","The change of return statement indicates the API potentially returns different values since it now relies on the mRenderNode.getTranslationX() rather than the previous field access logic, which is a CI type of 1."
561,"<android.app.TimePickerDialog: void onClick(DialogInterface,int)>",20,21,"<android.app.TimePickerDialog: void onClick(DialogInterface,int)>","<android.app.TimePickerDialog: void onClick(DialogInterface,int)>",0,"{
    tryNotifyTimeSet();
}","{
    switch(which) {
        case BUTTON_POSITIVE:
            if (mTimeSetCallback != null) {
                mTimeSetCallback.onTimeSet(mTimePicker, mTimePicker.getCurrentHour(), mTimePicker.getCurrentMinute());
            }
            break;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The implementation of the method has been entirely replaced with a new block of code, which includes a 'switch' control structure and a conditional 'if' within the case statement, resulting in a change of control dependency, as well as changes to the method's behavior in terms of which segment of code gets executed. Thus, the types are 1,3.","Given that the old implementation always calls tryNotifyTimeSet(), and the new implementation conditionally calls a method on an object (mTimeSetCallback.onTimeSet(mTimePicker, mTimePicker.getCurrentHour(), mTimePicker.getCurrentMinute())), there is a potential compatibility issue due to different behavior based on the button that was clicked (BUTTON_POSITIVE) and the condition of mTimeSetCallback being non-null. Consequently, the late version may not execute any time-setting behavior if a button other than BUTTON_POSITIVE is clicked, or if the mTimeSetCallback is null, resulting in different return behavior. The CI type is 1."
562,<android.print.PrintDocumentInfo.Builder: PrintDocumentInfo build()>,20,21,<android.print.PrintDocumentInfo.Builder: PrintDocumentInfo build()>,<android.print.PrintDocumentInfo.Builder: PrintDocumentInfo build()>,0,"{
    return new PrintDocumentInfo(mPrototype);
}","{
    // wiritten PDF file for the page count.
    if (mPrototype.mPageCount == 0) {
        mPrototype.mPageCount = PAGE_COUNT_UNKNOWN;
    }
    return new PrintDocumentInfo(mPrototype);
}",1,"/**
 * Creates a new {@link PrintDocumentInfo} instance.
 *
 * @return The new instance.
 */
","/**
 * Creates a new {@link PrintDocumentInfo} instance.
 *
 * @return The new instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The late version includes an extra if-statement that assigns PAGE_COUNT_UNKNOWN to mPrototype.mPageCount if the mPageCount is zero. This change constitutes a control dependency change (3) and also changes a field of mPrototype before it is used (4).,"However, this change does not result in a compatibility issue because it only sets mPageCount to a known constant (PAGE_COUNT_UNKNOWN) when mPageCount is zero. Since the new condition can only alter internal data but does not change the behavior of the method in a way that would affect how the method integrates with existing apps, it doesn't introduce a compatibility issue (0)."
563,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,20,21,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        return false;
    }
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            if (isPointInside(ev.getX(), ev.getY())) {
                // event.
                if (!mList.isInScrollingContainer()) {
                    beginDrag();
                    return true;
                }
                mInitialTouchY = ev.getY();
                startPendingDrag();
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (!isPointInside(ev.getX(), ev.getY())) {
                cancelPendingDrag();
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            cancelPendingDrag();
            break;
    }
    return false;
}","{
    if (!isEnabled()) {
        return false;
    }
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            if (isPointInside(ev.getX(), ev.getY())) {
                // event.
                if (!mList.isInScrollingContainer()) {
                    beginDrag();
                    return true;
                }
                mInitialTouchY = ev.getY();
                startPendingDrag();
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (!isPointInside(ev.getX(), ev.getY())) {
                cancelPendingDrag();
            } else if (mPendingDrag >= 0 && mPendingDrag <= SystemClock.uptimeMillis()) {
                beginDrag();
                final float pos = getPosFromMotionEvent(mInitialTouchY);
                scrollTo(pos);
                return onTouchEvent(ev);
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            cancelPendingDrag();
            break;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The late version introduces an 'else if' block within the MotionEvent.ACTION_MOVE case, adding additional behavior for initiating drag under specific conditions. This constitutes a change in control dependency.","There's no Compatibility Issue identified as the new else-if condition, and its block doesn't alter any existing code paths that would affect the return type or value for existing input. For new cases where mPendingDrag is between 0 and the current uptime in milliseconds, the method will now potentially return true (triggering onTouchEvent) instead of false, but this is an expected new behavior rather than an unintentional side effect. So, existing code that relies on the previous version's behaviors should not experience any issues due to these additional checks and actions."
566,"<android.content.res.TypedArray: float getFraction(int,int,int,float)>",20,21,"<android.content.res.TypedArray: float getFraction(int,int,int,float)>","<android.content.res.TypedArray: float getFraction(int,int,int,float)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    }
    throw new UnsupportedOperationException(""Can't convert to fraction: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to fraction: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 */
","/**
 * Retrieve a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"There's a new exception handling statement introduced at the beginning of the late implementation for checking the mRecycled state, and an extra control dependency on `type` has been added to check if the type equals TypedValue.TYPE_ATTRIBUTE.","The new exception handling statement introduces a new behavior that an exception can be thrown if the TypedArray has been recycled, which wasn't present in the early version. In addition, the new control dependency change introduces another potential exception that can be thrown if the type is TypedValue.TYPE_ATTRIBUTE. Both these changes lead to potential different exception handlings and therefore the CI type is 2."
568,<android.os.MessageQueue: void removeSyncBarrier(int)>,20,21,<android.os.MessageQueue: void removeSyncBarrier(int)>,<android.os.MessageQueue: void removeSyncBarrier(int)>,0,"{
    // If the queue is no longer stalled by a barrier then wake it.
    synchronized (this) {
        Message prev = null;
        Message p = mMessages;
        while (p != null && (p.target != null || p.arg1 != token)) {
            prev = p;
            p = p.next;
        }
        if (p == null) {
            throw new IllegalStateException(""The specified message queue synchronization "" + "" barrier token has not been posted or has already been removed."");
        }
        final boolean needWake;
        if (prev != null) {
            prev.next = p.next;
            needWake = false;
        } else {
            mMessages = p.next;
            needWake = mMessages == null || mMessages.target != null;
        }
        p.recycle();
        // We can assume mPtr != 0 when mQuitting is false.
        if (needWake && !mQuitting) {
            nativeWake(mPtr);
        }
    }
}","{
    // If the queue is no longer stalled by a barrier then wake it.
    synchronized (this) {
        Message prev = null;
        Message p = mMessages;
        while (p != null && (p.target != null || p.arg1 != token)) {
            prev = p;
            p = p.next;
        }
        if (p == null) {
            throw new IllegalStateException(""The specified message queue synchronization "" + "" barrier token has not been posted or has already been removed."");
        }
        final boolean needWake;
        if (prev != null) {
            prev.next = p.next;
            needWake = false;
        } else {
            mMessages = p.next;
            needWake = mMessages == null || mMessages.target != null;
        }
        p.recycleUnchecked();
        // We can assume mPtr != 0 when mQuitting is false.
        if (needWake && !mQuitting) {
            nativeWake(mPtr);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called on the variable `p` changed from `p.recycle()` to `p.recycleUnchecked()`, which indicates a change in the dependent API, hence the code change type is 4,5.","This change in the method called does not affect the return type or value (since the method is void and does not return anything), and does not throw a new or different type of exception. Therefore, it is not a Compatibility Issue, so the CI type is 0."
569,<android.content.res.ColorStateList: ColorStateList valueOf(int)>,20,21,<android.content.res.ColorStateList: ColorStateList valueOf(int)>,<android.content.res.ColorStateList: ColorStateList valueOf(int)>,0,"{
    // TODO: should we collect these eventually?
    synchronized (sCache) {
        WeakReference<ColorStateList> ref = sCache.get(color);
        ColorStateList csl = ref != null ? ref.get() : null;
        if (csl != null) {
            return csl;
        }
        csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<ColorStateList>(csl));
        return csl;
    }
}","{
    // TODO: should we collect these eventually?
    synchronized (sCache) {
        final WeakReference<ColorStateList> ref = sCache.get(color);
        ColorStateList csl = ref != null ? ref.get() : null;
        if (csl != null) {
            return csl;
        }
        csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<ColorStateList>(csl));
        return csl;
    }
}",1,"/**
 * Creates or retrieves a ColorStateList that always returns a single color.
 */
","/**
 * Creates or retrieves a ColorStateList that always returns a single color.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The only change in the implementation is the addition of the `final` keyword in the declaration of `ref`, which does not alter the behavior of the method—all control flow and return statements remain identical. Hence, there are no relevant code changes.","Since there is no meaningful alteration to the behavior of the method, no Compatibility Issue arises from this code change."
570,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,20,21,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    final int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            removeAllCallbacks();
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_UP:
            if (!mHasSelectorWheel) {
                break;
            }
            switch(event.getAction()) {
                case KeyEvent.ACTION_DOWN:
                    if (mWrapSelectorWheel || (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) ? getValue() < getMaxValue() : getValue() > getMinValue()) {
                        requestFocus();
                        mLastHandledDownDpadKeyCode = keyCode;
                        removeAllCallbacks();
                        if (mFlingScroller.isFinished()) {
                            changeValueByOne(keyCode == KeyEvent.KEYCODE_DPAD_DOWN);
                        }
                        return true;
                    }
                    break;
                case KeyEvent.ACTION_UP:
                    if (mLastHandledDownDpadKeyCode == keyCode) {
                        mLastHandledDownDpadKeyCode = -1;
                        return true;
                    }
                    break;
            }
    }
    return super.dispatchKeyEvent(event);
}","{
    final int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            removeAllCallbacks();
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_UP:
            if (!mHasSelectorWheel) {
                break;
            }
            switch(event.getAction()) {
                case KeyEvent.ACTION_DOWN:
                    if (mWrapSelectorWheel || ((keyCode == KeyEvent.KEYCODE_DPAD_DOWN) ? getValue() < getMaxValue() : getValue() > getMinValue())) {
                        requestFocus();
                        mLastHandledDownDpadKeyCode = keyCode;
                        removeAllCallbacks();
                        if (mFlingScroller.isFinished()) {
                            changeValueByOne(keyCode == KeyEvent.KEYCODE_DPAD_DOWN);
                        }
                        return true;
                    }
                    break;
                case KeyEvent.ACTION_UP:
                    if (mLastHandledDownDpadKeyCode == keyCode) {
                        mLastHandledDownDpadKeyCode = -1;
                        return true;
                    }
                    break;
            }
    }
    return super.dispatchKeyEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There's no change in the implementation or control flow of the method between the two versions.,There is no compatibility issue since the code did not change.
571,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,20,21,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,0,"{
    IntPropertyValuesHolder newPVH = (IntPropertyValuesHolder) super.clone();
    newPVH.mIntKeyframeSet = (IntKeyframeSet) newPVH.mKeyframeSet;
    return newPVH;
}","{
    IntPropertyValuesHolder newPVH = (IntPropertyValuesHolder) super.clone();
    newPVH.mIntKeyframes = (Keyframes.IntKeyframes) newPVH.mKeyframes;
    return newPVH;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The field being cast has changed from mIntKeyframeSet to mIntKeyframes, but since the assignment's effect is internal to the object being cloned and there is no change in the value type being returned, the change type is 4.",There are no Compatibility Issues as the returned object type remains the same and method signature is unchanged. The change does not affect the return value from an API consumer's perspective.
572,<android.widget.TextView: boolean canCopy()>,20,21,<android.widget.TextView: boolean canCopy()>,<android.widget.TextView: boolean canCopy()>,0,"{
    if (hasPasswordTransformationMethod()) {
        return false;
    }
    if (mText.length() > 0 && hasSelection()) {
        return true;
    }
    return false;
}","{
    if (hasPasswordTransformationMethod()) {
        return false;
    }
    if (mText.length() > 0 && hasSelection() && mEditor != null) {
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change is associated with a new condition added to an 'if' statement where an additional check is made (mEditor != null), so the code change type is 3.","Although there is a change in the control dependency, it will not lead to a Compatibility Issue as the API will still return either true or false depending on the same conditions, with an added check for mEditor not being null. If mEditor is null, the method returns false in both versions, and if mEditor is not null, the behavior is unchanged from the early version; thus no new behavior is introduced in terms of different return values or exception handling."
573,<android.os.Bundle: boolean getBoolean(String)>,20,21,<android.os.Bundle: boolean getBoolean(String)>,<android.os.Bundle: boolean getBoolean(String)>,0,"{
    unparcel();
    if (DEBUG)
        Log.d(TAG, ""Getting boolean in "" + Integer.toHexString(System.identityHashCode(this)));
    return getBoolean(key, false);
}","{
    return super.getBoolean(key);
}",1,"/**
 * Returns the value associated with the given key, or false if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a boolean value
 */
","/**
 * Returns the value associated with the given key, or false if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a boolean value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation changed from calling getBoolean(key, false) with a default value specified, to calling super.getBoolean(key) without specifying a default value. Additionally, the call to unparcel() and the log statement have been removed, which indicates that the method now relies on a parent class's implementation. Therefore, we have both a Return statement changed and Dependent API changed, so the code change types are 1 and 5.","Because the late version directly calls the parent class's getBoolean method, without specifying a default value and without making sure the Bundle is unparceled as it was in the early version, the API could potentially return different results. The expected default behavior for not found keys might differ, causing a Compatibility Issue of type 1, which is changes in return values or types."
574,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutCancelled()>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutCancelled()>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutCancelled()>,0,"{
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        clearLocked();
    }
}","{
    final ILayoutResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
    }
    // If the callback is null we are destroyed.
    if (callback == null) {
        Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"");
        return;
    }
    try {
        callback.onLayoutCanceled(mSequence);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error calling onLayoutFailed"", re);
    } finally {
        destroy();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The implementation has changed significantly. Previously, it only released resources after checking if not destroyed; now it also calls the remote `callback.onLayoutCanceled(mSequence)`, which could potentially throw a `RemoteException` that was not there before. Thus we have a change in exception handling, a control dependency change since the logic flow is altered, and an 'other' statement change because of the added try-finally block with a new ""destroy"" method call. So the change types are 1,2,3 and 4.","The late version has both a changed return statement and exception handling. In the early version, the method would simply return if 'mDestroyed' was true, while in the late version, it calls a remote method which can potentially fail and throw an exception, altering the flow. A 'RemoteException' is handled differently as well, which could lead to different behavior observable by the caller. Therefore, CI types are 1 (for the return value difference) and 2 (for the different exception handling)."
577,"<android.view.GLES20Canvas: void drawPoints(float[],int,int,Paint)>",20,21,"<android.view.GLES20Canvas: void drawPoints(float[],int,int,Paint)>","<android.view.GLES20Canvas: void drawPoints(float[],int,int,Paint)>",0,"{
    if (count < 2)
        return;
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawPoints(mRenderer, pts, offset, count, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (count < 2)
        return;
    nDrawPoints(mRenderer, pts, offset, count, paint.mNativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,"The code change includes the removal of modifier setup and cleanup, and the exception handling statement (try-finally) which are no longer present in the late version. These changes constitute removal of control dependency (the try-finally block), other statement changed (the code within the finally block and the setupModifiers call), and a return statement changed due to the potential removal of implicit return points within the try-finally block.","Despite these code changes, they do not lead to a compatibility issue as they do not affect the returned value or the thrown exceptions of the method. The early version and the late version will behave the same with respect to the API's functionality, since both versions do nothing and return immediately if count < 2, which is not affected by the change. For all other counts, they call the native method nDrawPoints with the same parameters. The removed code related to modifiers does not affect the return value of the function, hence there is no compatibility issue."
581,<android.view.accessibility.AccessibilityEvent: int getRecordCount()>,20,21,<android.view.accessibility.AccessibilityEvent: int getRecordCount()>,<android.view.accessibility.AccessibilityEvent: int getRecordCount()>,0,"{
    return mRecords.size();
}","{
    return mRecords == null ? 0 : mRecords.size();
}",1,"/**
 * Gets the number of records contained in the event.
 *
 * @return The number of records.
 */
","/**
 * Gets the number of records contained in the event.
 *
 * @return The number of records.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The statement for returning the size of mRecords has been conditionally modified to check for null. Therefore, the code change is classified under other statement changed (4).","The late version of the API introduces a null check before accessing the size of mRecords. If mRecords was null in the early version, it would have led to a NullPointerException, whereas in the late version it will return 0, which could lead to different behaviors in the API. Therefore, this is a Compatibility Issue caused by potential different return values (1)."
583,<android.widget.TimePicker: void setIs24HourView(Boolean)>,20,21,<android.widget.TimePicker: void setIs24HourView(Boolean)>,<android.widget.TimePicker: void setIs24HourView(Boolean)>,0,"{
    if (mIs24HourView == is24HourView) {
        return;
    }
    // cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!
    int currentHour = getCurrentHour();
    // Order is important here.
    mIs24HourView = is24HourView;
    getHourFormatData();
    updateHourControl();
    // set value after spinner range is updated - be aware that because mIs24HourView has
    // changed then getCurrentHour() is not equal to the currentHour we cached before so
    // explicitly ask for *not* propagating any onTimeChanged()
    setCurrentHour(currentHour, false);
    updateMinuteControl();
    updateAmPmControl();
}","{
    mDelegate.setIs24HourView(is24HourView);
}",1,"/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
","/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The entire implementation of the method has been replaced by a single call to mDelegate.setIs24HourView(is24HourView). There's a change in how the functionality is achieved, relying on mDelegate's implementation, indicating a change in the dependent API. So the code change is of type 4,5 due to implementation change and delegation to another API.","The new implementation delegates the method's functionality to another object, which could potentially behave differently from the old implementation. The implications of this change mean there could be differences in the return value or side effects that result from calling setIs24HourView. As such, this change could lead to a Compatibility Issue of type 1 due to potentially different return values or side effects."
584,<android.view.inputmethod.InputMethodInfo: int getSubtypeCount()>,20,21,<android.view.inputmethod.InputMethodInfo: int getSubtypeCount()>,<android.view.inputmethod.InputMethodInfo: int getSubtypeCount()>,0,"{
    return mSubtypes.size();
}","{
    return mSubtypes.getCount();
}",1,"/**
 * Return the count of the subtypes of Input Method.
 */
","/**
 * Return the count of the subtypes of Input Method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method to obtain the subtype count has changed from `size()` to `getCount()`. This change suggests that the implementation of how the count is retrieved has been updated through a different method, indicating the code change type is 5.","Despite the method change from `size()` to `getCount()`, as long as both methods are expected to return the count of subtypes, there is no indication that the returned value itself would differ. Therefore, no compatibility issue is expected, which is why the CI type is 0."
585,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,20,21,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    if (!mHasSelectorWheel || !isEnabled()) {
        return false;
    }
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                removeAllCallbacks();
                mInputText.setVisibility(View.INVISIBLE);
                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
                mLastDownEventTime = event.getEventTime();
                mIngonreMoveEvents = false;
                mShowSoftInputOnTap = false;
                // Handle pressed state before any state change.
                if (mLastDownEventY < mTopSelectionDividerTop) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_DECREMENT);
                    }
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_INCREMENT);
                    }
                }
                // Make sure we support flinging inside scrollables.
                getParent().requestDisallowInterceptTouchEvent(true);
                if (!mFlingScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                } else if (!mAdjustScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                } else if (mLastDownEventY < mTopSelectionDividerTop) {
                    hideSoftInput();
                    postChangeCurrentByOneFromLongPress(false, ViewConfiguration.getLongPressTimeout());
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    hideSoftInput();
                    postChangeCurrentByOneFromLongPress(true, ViewConfiguration.getLongPressTimeout());
                } else {
                    mShowSoftInputOnTap = true;
                    postBeginSoftInputOnLongPressCommand();
                }
                return true;
            }
    }
    return false;
}","{
    if (!mHasSelectorWheel || !isEnabled()) {
        return false;
    }
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                removeAllCallbacks();
                mInputText.setVisibility(View.INVISIBLE);
                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
                mLastDownEventTime = event.getEventTime();
                mIgnoreMoveEvents = false;
                mPerformClickOnTap = false;
                // Handle pressed state before any state change.
                if (mLastDownEventY < mTopSelectionDividerTop) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_DECREMENT);
                    }
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_INCREMENT);
                    }
                }
                // Make sure we support flinging inside scrollables.
                getParent().requestDisallowInterceptTouchEvent(true);
                if (!mFlingScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                } else if (!mAdjustScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                } else if (mLastDownEventY < mTopSelectionDividerTop) {
                    hideSoftInput();
                    postChangeCurrentByOneFromLongPress(false, ViewConfiguration.getLongPressTimeout());
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    hideSoftInput();
                    postChangeCurrentByOneFromLongPress(true, ViewConfiguration.getLongPressTimeout());
                } else {
                    mPerformClickOnTap = true;
                    postBeginSoftInputOnLongPressCommand();
                }
                return true;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the renaming of the variable from `mShowSoftInputOnTap` to `mPerformClickOnTap`, which implies a change in variable name but not in the program logic. Consequently, the change type is 4.","Renaming a variable does not alter the API's behavior, and because there are no other code changes affecting return values or exception handling, there is no compatibility issue. The CI type is 0."
586,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>",20,21,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>","<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>",0,"{
    if (!mIsConnecting) {
        try {
            RemoteViewsAdapter adapter;
            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
            if ((adapter = mAdapter.get()) != null) {
                checkInteractAcrossUsersPermission(context, adapter.mUserId);
                mgr.bindRemoteViewsService(appWidgetId, intent, asBinder(), new UserHandle(adapter.mUserId));
            } else {
                Slog.w(TAG, ""bind: adapter was null"");
            }
            mIsConnecting = true;
        } catch (Exception e) {
            Log.e(""RemoteViewsAdapterServiceConnection"", ""bind(): "" + e.getMessage());
            mIsConnecting = false;
            mIsConnected = false;
        }
    }
}","{
    if (!mIsConnecting) {
        try {
            RemoteViewsAdapter adapter;
            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
            if ((adapter = mAdapter.get()) != null) {
                mgr.bindRemoteViewsService(context.getOpPackageName(), appWidgetId, intent, asBinder());
            } else {
                Slog.w(TAG, ""bind: adapter was null"");
            }
            mIsConnecting = true;
        } catch (Exception e) {
            Log.e(""RemoteViewsAdapterServiceConnection"", ""bind(): "" + e.getMessage());
            mIsConnecting = false;
            mIsConnected = false;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change in the method invocation `mgr.bindRemoteViewsService` with different arguments replaced `mgr.bindRemoteViewsService(appWidgetId, intent, asBinder(), new UserHandle(adapter.mUserId))` with `mgr.bindRemoteViewsService(context.getOpPackageName(), appWidgetId, intent, asBinder())`, so the code change type is 4,5.","There is no change that would affect the return value or exception handling of the method, as the exception handling and assignment to variables remains the same, and the return type is void. The change in argument does not directly affect output or exception behavior—it is a change in dependent API usage that does not lead to an observable change in this API's behavior. Therefore, there is no Compatibility Issue, so the CI type is 0."
587,"<android.text.Selection: boolean moveUp(Spannable,Layout)>",20,21,"<android.text.Selection: boolean moveUp(Spannable,Layout)>","<android.text.Selection: boolean moveUp(Spannable,Layout)>",0,"{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, min);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line > 0) {
            int move;
            if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line - 1)) {
                float h = layout.getPrimaryHorizontal(end);
                move = layout.getOffsetForHorizontal(line - 1, h);
            } else {
                move = layout.getLineStart(line - 1);
            }
            setSelection(text, move);
            return true;
        }
    }
    return false;
}","{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, min);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line > 0) {
            int move;
            if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line - 1)) {
                float h = layout.getPrimaryHorizontal(end);
                move = layout.getOffsetForHorizontal(line - 1, h);
            } else {
                move = layout.getLineStart(line - 1);
            }
            setSelection(text, move);
            return true;
        } else if (end != 0) {
            setSelection(text, 0);
            return true;
        }
    }
    return false;
}",1,"/**
 * Move the cursor to the buffer offset physically above the current
 * offset, or return false if the cursor is already on the top line.
 */
","/**
 * Move the cursor to the buffer offset physically above the current
 * offset, to the beginning if it is on the top line but not at the
 * start, or return false if the cursor is already on the top line.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An else-if condition (`else if (end != 0)`) with a new block of code has been added to the late version of the implementation, which indicates a control dependency change.","The late version introduces a new behavior when `line <= 0` and `end != 0`, where it will set the selection to 0 and return true. This means that in certain situations, where the early version would return false, the late version could return true, causing a Compatibility Issue due to potentially different return values. Thus, the CI type is 1."
588,"<android.transition.Transition: Transition excludeTarget(View,boolean)>",20,21,"<android.transition.Transition: Transition excludeTarget(View,boolean)>","<android.transition.Transition: Transition excludeTarget(View,boolean)>",0,"{
    mTargetExcludes = excludeView(mTargetExcludes, target, exclude);
    return this;
}","{
    mTargetExcludes = excludeObject(mTargetExcludes, target, exclude);
    return this;
}",1,"/**
 * Whether to add the given target to the list of targets to exclude from this
 * transition. The <code>exclude</code> parameter specifies whether the target
 * should be added to or removed from the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeChildren(View, boolean)
 * @see #excludeTarget(int, boolean)
 * @see #excludeTarget(Class, boolean)
 *
 * @param target The target to ignore when running this transition.
 * @param exclude Whether to add the target to or remove the target from the
 * current list of excluded targets.
 * @return This transition object.
 */
","/**
 * Whether to add the given target to the list of targets to exclude from this
 * transition. The <code>exclude</code> parameter specifies whether the target
 * should be added to or removed from the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeChildren(View, boolean)
 * @see #excludeTarget(int, boolean)
 * @see #excludeTarget(Class, boolean)
 *
 * @param target The target to ignore when running this transition.
 * @param exclude Whether to add the target to or remove the target from the
 * current list of excluded targets.
 * @return This transition object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is a change in the internal API called: from excludeView() to excludeObject(). Therefore, the code change type is 5.","The change in the method that is used to update mTargetExcludes is internal to the API and does not affect the method's external behavior, as the method signature stays the same and it still returns 'this'. Consequently, there is no Compatibility Issue, which is type 0."
589,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,20,21,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,0,"{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return mResources.loadColorStateList(value, value.resourceId);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new RuntimeException(""Failed to resolve attribute at index "" + index);
        }
        return mResources.loadColorStateList(value, value.resourceId);
    }
    return null;
}",1,"/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */
","/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The changes include a new exception being thrown if the object is recycled, a check for the value type, and throwing another exception if the type is `TypedValue.TYPE_ATTRIBUTE`, so the change types are 2,3,4.","The newly introduced exception check for recycled instances and the additional exception throwing for `TypedValue.TYPE_ATTRIBUTE` could lead to a CI due to different behavior related to potential exceptions and previously non-existent return values or types in the case of recycled instances. Therefore, the CI types are 1,2."
590,<android.service.dreams.DreamService: boolean dispatchGenericMotionEvent(MotionEvent)>,20,21,<android.service.dreams.DreamService: boolean dispatchGenericMotionEvent(MotionEvent)>,<android.service.dreams.DreamService: boolean dispatchGenericMotionEvent(MotionEvent)>,0,"{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Finishing on genericMotionEvent"");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchGenericMotionEvent(event);
}","{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on genericMotionEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchGenericMotionEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The method implementation has changed with a different method being called within the 'if' condition: from 'safelyFinish()' to 'wakeUp()'. Also, the log message has changed. So, the code change types are 3 (the change in the control flow due to the new method call) and 4 (the change in the log message).","Even though there are method changes within the control flow, they do not modify the return value or the type returned by the API. The API return value remains true in both cases when 'mInteractive' is false, and the subsequent return statement is unchanged for cases when 'mInteractive' is true. Thus, these changes do not lead to a Compatibility Issue."
592,<android.os.Environment: String getStorageState(File)>,20,21,<android.os.Environment: String getStorageState(File)>,<android.os.Environment: String getStorageState(File)>,0,"{
    final String rawPath;
    try {
        rawPath = path.getCanonicalPath();
    } catch (IOException e) {
        Log.w(TAG, ""Failed to resolve target path: "" + e);
        return Environment.MEDIA_UNKNOWN;
    }
    try {
        final IMountService mountService = IMountService.Stub.asInterface(ServiceManager.getService(""mount""));
        final StorageVolume[] volumes = mountService.getVolumeList();
        for (StorageVolume volume : volumes) {
            if (rawPath.startsWith(volume.getPath())) {
                return mountService.getVolumeState(volume.getPath());
            }
        }
    } catch (RemoteException e) {
        Log.w(TAG, ""Failed to find external storage state: "" + e);
    }
    return Environment.MEDIA_UNKNOWN;
}","{
    return getExternalStorageState(path);
}",1,"/**
 * Returns the current state of the storage device that provides the given
 * path.
 *
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */
","/**
 * @deprecated use {@link #getExternalStorageState(File)}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation in the late version has been replaced with a single call to getExternalStorageState(path), indicating that the internal implementation details have changed and now rely on a different method (dependent API change), thus the code change type is 4,5.","The change to the implementation potentially returns a different value because it now relies on the implementation of getExternalStorageState(path) which might have a different behavior compared to the original multi-step process in the early version. Therefore, there may be a compatibility issue due to potential different return values, and the CI type is 1."
593,<android.content.RestrictionEntry: String getSelectedString()>,20,21,<android.content.RestrictionEntry: String getSelectedString()>,<android.content.RestrictionEntry: String getSelectedString()>,0,"{
    return currentValue;
}","{
    return mCurrentValue;
}",1,"/**
 * Returns the currently selected string value.
 * @return the currently selected value, which can be null for types that aren't for holding
 * single string values.
 */
","/**
 * Returns the currently selected string value.
 * @return the currently selected value, which can be null for types that aren't for holding
 * single string values.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable name has changed from currentValue to mCurrentValue, which is an internal change and does not affect the behavior of the method itself as long as mCurrentValue is the new name for the same value previously held in currentValue, so the code change type is 4.","There is no Compatibility Issue because the change of variable name does not affect the return value provided that mCurrentValue is correctly holding the value that was previously held by currentValue. Therefore, there is no potential for the method to return a different value or type, nor is there a change in exception handling."
594,"<android.util.SparseIntArray: void append(int,int)>",20,21,"<android.util.SparseIntArray: void append(int,int)>","<android.util.SparseIntArray: void append(int,int)>",0,"{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        int[] nvalues = new int[n];
        // Log.e(""SparseIntArray"", ""grow "" + mKeys.length + "" to "" + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}","{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}",1,"/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
","/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The change includes refactoring to use GrowingArrayUtils.append for array extension logic and incrementing mSize differently, so the code change types are 3, 4, and 5.","Although there are changes in how the array expansion and element assignment are handled, these changes do not result in a different behavior from the perspective of the method's contract. The method's purpose is to append a key-value pair, and it still appends the key-value pair, thus maintaining the same behavior. Therefore, there is no compatibility issue, and CI type is 0."
595,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",20,21,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>","<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",0,"{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
}","{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
    // Get the primary color and update the TaskDescription for this activity
    if (theme != null) {
        TypedArray a = theme.obtainStyledAttributes(com.android.internal.R.styleable.Theme);
        int colorPrimary = a.getColor(com.android.internal.R.styleable.Theme_colorPrimary, 0);
        a.recycle();
        if (colorPrimary != 0) {
            ActivityManager.TaskDescription v = new ActivityManager.TaskDescription(null, null, colorPrimary);
            setTaskDescription(v);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Code change type is 4 because new statements that update the TaskDescription for the activity has been added, but it doesn't affect the method signature, return type, or the exception handling.",There's no Compatibility Issue as these changes do not lead to a different return value or a different exception being thrown by the method. The method's execution flow and potential outcomes to calling code remain the same.
596,<android.bluetooth.BluetoothHeadset: boolean doBind()>,20,21,<android.bluetooth.BluetoothHeadset: boolean doBind()>,<android.bluetooth.BluetoothHeadset: boolean doBind()>,0,"{
    Intent intent = new Intent(IBluetoothHeadset.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindService(intent, mConnection, 0)) {
        Log.e(TAG, ""Could not bind to Bluetooth Headset Service with "" + intent);
        return false;
    }
    return true;
}","{
    Intent intent = new Intent(IBluetoothHeadset.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, android.os.Process.myUserHandle())) {
        Log.e(TAG, ""Could not bind to Bluetooth Headset Service with "" + intent);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the implementation is the replacement of the `mContext.bindService(...)` with `mContext.bindServiceAsUser(..., android.os.Process.myUserHandle())`. The different API is being used here which constitutes a 'Dependent API changed' code change type. How the service is bound may have changed, but it's not a change that affects the control flow or the return type/value, so it's also an 'Other statement changed'.","This change doesn't cause a Compatibility Issue since the method still returns the same values (true or false) based on the same conditions. The new method adds the user handle as a parameter to specify the user context, but this does not alter the method's behavior from the perspective of compatibility; it still handles the service binding process and returns a boolean indicating success or failure."
598,"<android.provider.DocumentsProvider: ParcelFileDescriptor openFile(Uri,String)>",20,21,"<android.provider.DocumentsProvider: ParcelFileDescriptor openFile(Uri,String)>","<android.provider.DocumentsProvider: ParcelFileDescriptor openFile(Uri,String)>",0,"{
    return openDocument(getDocumentId(uri), mode, null);
}","{
    enforceTree(uri);
    return openDocument(getDocumentId(uri), mode, null);
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocument(String, String, CancellationSignal)
 */
","/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocument(String, String, CancellationSignal)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version includes an additional method call (enforceTree(uri)) before the return statement, which means there is an introduction of both a new statement (4) and a control dependency change due to the addition of this new line of execution (3).","The introduction of enforceTree(uri) does not lead to a potential different return value or exception handling because the return statement and its value remain unchanged, and there is no alteration in the exception handling mechanism. EnforceTree(uri) might throw an exception, but since the method is supposed to open a file and return a descriptor, the core functionality (returning a ParcelFileDescriptor) stays consistent unless the additional call enforces security or access control on the given URI. However, as it's not explicitly stated that this method throws a new exception (which would prevent the file descriptor from being returned), we can consider that no compatibility issue arises from this addition given the available information. Thus, CI is 0."
600,<android.widget.DatePicker: int getDayOfMonth()>,20,21,<android.widget.DatePicker: int getDayOfMonth()>,<android.widget.DatePicker: int getDayOfMonth()>,0,"{
    return mCurrentDate.get(Calendar.DAY_OF_MONTH);
}","{
    return mDelegate.getDayOfMonth();
}",1,"/**
 * @return The selected day of month.
 */
","/**
 * @return The selected day of month.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method from which the return value is obtained has changed: from mCurrentDate.get(Calendar.DAY_OF_MONTH) to mDelegate.getDayOfMonth(), hence the change types are 1 for the return statement change, and 5 for a dependent API change.","Because the return value is now retrieved from a different method, this could potentially lead to a different returned value. Therefore, there is a Compatibility Issue of type 1, where the API could return a different value or type."
601,<android.text.Layout: float getLineWidth(int)>,20,21,<android.text.Layout: float getLineWidth(int)>,<android.text.Layout: float getLineWidth(int)>,0,"{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, true);
    return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
}","{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, true);
    return margin + (signedExtent >= 0 ? signedExtent : -signedExtent);
}",1,"/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent and trailing whitespace.
 */
","/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent and trailing whitespace.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The associativity of addition and the conditional operator has changed due to a change in parentheses placement, which affects the calculation order. Thus, the code change type is 4.","There is no Compatibility Issue since the actual calculation and return value have not changed. The final result of `getLineWidth(int line)` remains the same because regardless of the parentheses, `margin` is always added to the absolute value of `signedExtent`. Hence, there is no change in behavior between the two versions."
603,"<android.widget.GridLayout: Spec spec(int,int,Alignment)>",20,21,"<android.widget.GridLayout: Spec spec(int,int,Alignment)>","<android.widget.GridLayout: Spec spec(int,int,Alignment)>",0,"{
    return new Spec(start != UNDEFINED, start, size, alignment);
}","{
    return spec(start, size, alignment, Spec.DEFAULT_WEIGHT);
}",1,"/**
 * Return a Spec, {@code spec}, where:
 * <ul>
 * <li> {@code spec.span = [start, start + size]} </li>
 * <li> {@code spec.alignment = alignment} </li>
 * </ul>
 * <p>
 * To leave the start index undefined, use the value {@link #UNDEFINED}.
 *
 * @param start     the start
 * @param size      the size
 * @param alignment the alignment
 */
","/**
 * Equivalent to: {@code spec(start, size, alignment, 0f)}.
 *
 * @param start     the start
 * @param size      the size
 * @param alignment the alignment
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method signature for Spec constructor used in the return statement has changed from `Spec(boolean, int, int, Alignment)` to `Spec(int, int, Alignment, float)` which changes the way `Spec` is instantiated. This implies not only a change in the return statement but also that there might be a change in the `Spec` constructor itself, introducing an additional parameter. Thus, the code change types are 1 for the return statement changed and 5 for the dependent API changed.","The change in the way `Spec` is instantiated, especially with the addition of a new parameter with a `DEFAULT_WEIGHT`, indicates that the returned `Spec` object could potentially differ in behavior from the previous version. This is likely to lead to a CI by potentially returning a different object with different internal state, and thus the CI type is 1."
604,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,20,21,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,0,"{
    AppWidgetProviderInfo that = new AppWidgetProviderInfo();
    that.provider = this.provider == null ? null : this.provider.clone();
    that.minWidth = this.minWidth;
    that.minHeight = this.minHeight;
    that.minResizeWidth = this.minResizeHeight;
    that.minResizeHeight = this.minResizeHeight;
    that.updatePeriodMillis = this.updatePeriodMillis;
    that.initialLayout = this.initialLayout;
    that.initialKeyguardLayout = this.initialKeyguardLayout;
    that.configure = this.configure == null ? null : this.configure.clone();
    that.label = this.label == null ? null : this.label.substring(0);
    that.icon = this.icon;
    that.previewImage = this.previewImage;
    that.autoAdvanceViewId = this.autoAdvanceViewId;
    that.resizeMode = this.resizeMode;
    that.widgetCategory = this.widgetCategory;
    return that;
}","{
    AppWidgetProviderInfo that = new AppWidgetProviderInfo();
    that.provider = this.provider == null ? null : this.provider.clone();
    that.minWidth = this.minWidth;
    that.minHeight = this.minHeight;
    that.minResizeWidth = this.minResizeHeight;
    that.minResizeHeight = this.minResizeHeight;
    that.updatePeriodMillis = this.updatePeriodMillis;
    that.initialLayout = this.initialLayout;
    that.initialKeyguardLayout = this.initialKeyguardLayout;
    that.configure = this.configure == null ? null : this.configure.clone();
    that.label = this.label == null ? null : this.label.substring(0);
    that.icon = this.icon;
    that.previewImage = this.previewImage;
    that.autoAdvanceViewId = this.autoAdvanceViewId;
    that.resizeMode = this.resizeMode;
    that.widgetCategory = this.widgetCategory;
    that.providerInfo = this.providerInfo;
    return that;
}",1,,,-1,[@Override],"[@Override, @SuppressWarnings(""deprecation"")]",-1,-1,-1,-1,-1,-1,4,0,"There is a new assignment statement ""that.providerInfo = this.providerInfo;"" added in the late implementation, so the code change type is 4.","The added assignment statement does not affect the behavior of the existing API in terms of its return value or exception handling; it only adds additional state to the cloned object. Hence, there is no Compatibility Issue."
606,"<android.transition.Visibility: Animator onAppear(ViewGroup,TransitionValues,int,TransitionValues,int)>",20,21,"<android.transition.Visibility: Animator onAppear(ViewGroup,TransitionValues,int,TransitionValues,int)>","<android.transition.Visibility: Animator onAppear(ViewGroup,TransitionValues,int,TransitionValues,int)>",0,"{
    return null;
}","{
    if ((mMode & MODE_IN) != MODE_IN || endValues == null) {
        return null;
    }
    if (startValues == null) {
        VisibilityInfo parentVisibilityInfo = null;
        View endParent = (View) endValues.view.getParent();
        TransitionValues startParentValues = getMatchedTransitionValues(endParent, false);
        TransitionValues endParentValues = getTransitionValues(endParent, false);
        parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
        if (parentVisibilityInfo.visibilityChange) {
            return null;
        }
    }
    return onAppear(sceneRoot, endValues.view, startValues, endValues);
}",1,"/**
 * The default implementation of this method does nothing. Subclasses
 * should override if they need to create an Animator when targets appear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
","/**
 * The default implementation of this method calls
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * Subclasses should override this method or
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * if they need to create an Animator when targets appear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The early version of the method consists of a single return statement that always returns null, whereas the late version introduces new control dependency and logic that leads to different potential return values. Specifically, 'if' conditions are added, and there's also a call to another method 'onAppear' with arguments. So the code change type is 1,3.","Because the late version of the API can return either null or the result of another 'onAppear' method call, depending on the conditions, it may lead to different return values or types when compared to the old version, which only returned null. Consequently, the compatibility issue is of type 1."
607,<android.animation.ObjectAnimator: Object getTarget()>,20,21,<android.animation.ObjectAnimator: Object getTarget()>,<android.animation.ObjectAnimator: Object getTarget()>,0,"{
    return mTarget;
}","{
    return mTarget == null ? null : mTarget.get();
}",1,"/**
 * The target object whose property will be animated by this animation
 *
 * @return The object being animated
 */
","/**
 * The target object whose property will be animated by this animation
 *
 * @return The object being animated
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been modified to include a null check and use the get method. Before the change, it returned the value of mTarget directly; after the change, it checks if mTarget is null and returns null if it is, or calls the get method on mTarget if it's not null. So the code change type is 1.","The change of the return statement means that the API potentially returns a different value, particularly in cases where mTarget is a non-null weak reference. This could lead to a scenario where the old implementation would return a direct reference, but the new implementation would return null if the referenced object has been garbage collected. This constitutes a change in behavior and a potential compatibility issue, so the CI type is 1."
608,"<android.util.SparseBooleanArray: void append(int,boolean)>",20,21,"<android.util.SparseBooleanArray: void append(int,boolean)>","<android.util.SparseBooleanArray: void append(int,boolean)>",0,"{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        boolean[] nvalues = new boolean[n];
        // Log.e(""SparseBooleanArray"", ""grow "" + mKeys.length + "" to "" + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}","{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}",1,"/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
","/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The logic related to array growth and value insertion has changed, including the use of a helper class `GrowingArrayUtils` to append new elements, so the change types are 3,4,5.","There is no CI as the functionality provided by the new code appears to be operationally equivalent to the old one. The API still accepts the same parameters, and there are no new exceptions thrown or return statements added. The array growth and insertion operations now use a different mechanism, but the end result should be the same for clients of the API."
610,<android.speech.tts.FileSynthesisCallback: int done()>,20,21,<android.speech.tts.FileSynthesisCallback: int done()>,<android.speech.tts.FileSynthesisCallback: int done()>,0,"{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    synchronized (mStateLock) {
        if (mDone) {
            if (DBG)
                Log.d(TAG, ""Duplicate call to done()"");
            // we'd return ERROR because mFile == null and we'd add to logspam.
            return TextToSpeech.ERROR;
        }
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            // Write WAV header at start of file
            mFileChannel.position(0);
            int dataLength = (int) (mFileChannel.size() - WAV_HEADER_LENGTH);
            mFileChannel.write(makeWavHeader(mSampleRateInHz, mAudioFormat, mChannelCount, dataLength));
            closeFile();
            mDone = true;
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to output file descriptor"", ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}","{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    FileChannel fileChannel = null;
    int sampleRateInHz = 0;
    int audioFormat = 0;
    int channelCount = 0;
    synchronized (mStateLock) {
        if (mDone) {
            Log.w(TAG, ""Duplicate call to done()"");
            // setStatusCode is set.
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        if (mDispatcher != null && mStatusCode != TextToSpeech.SUCCESS && mStatusCode != TextToSpeech.STOPPED) {
            mDispatcher.dispatchOnError(mStatusCode);
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        mDone = true;
        fileChannel = mFileChannel;
        sampleRateInHz = mSampleRateInHz;
        audioFormat = mAudioFormat;
        channelCount = mChannelCount;
    }
    try {
        // Write WAV header at start of file
        fileChannel.position(0);
        int dataLength = (int) (fileChannel.size() - WAV_HEADER_LENGTH);
        fileChannel.write(makeWavHeader(sampleRateInHz, audioFormat, channelCount, dataLength));
        synchronized (mStateLock) {
            closeFile();
            if (mDispatcher != null) {
                mDispatcher.dispatchOnSuccess();
            }
            return TextToSpeech.SUCCESS;
        }
    } catch (IOException ex) {
        Log.e(TAG, ""Failed to write to output file descriptor"", ex);
        synchronized (mStateLock) {
            cleanUp();
        }
        return TextToSpeech.ERROR;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",The code has undergone multiple changes:,3. The error handling for stopping the synthesis and other errors has changed (invokes errorCodeOnStop() and dispatchOnError(mStatusCode)).
613,<android.os.Bundle: ClassLoader getClassLoader()>,20,21,<android.os.Bundle: ClassLoader getClassLoader()>,<android.os.Bundle: ClassLoader getClassLoader()>,0,"{
    return mClassLoader;
}","{
    return super.getClassLoader();
}",1,"/**
 * Return the ClassLoader currently associated with this Bundle.
 */
","/**
 * Return the ClassLoader currently associated with this Bundle.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning the member variable 'mClassLoader' to invoking 'super.getClassLoader()', plus, the API is now annotated with @Override, indicating adherence to a superclass or interface contract, so the change type is 1,5.","Since the method is now returning the result of 'super.getClassLoader()' instead of a member variable, the return value could potentially change, leading to different behaviors, so the CI type is 1."
614,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>",20,21,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, matrix.native_instance, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, matrix.native_instance, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The late version has removed the usage of modifiers, setupModifiers(), and nResetModifiers() to simplify the method. This is considered as an 'other statement changed', so the change type is 4.","Although the late implementation has removed some statements related to modifiers, it should not lead to a different return value (since the method is void) nor a different exception handling, as these were only used to modify a renderer state, which would not affect the core functionality (drawing a bitmap) of this method. Therefore, there is no compatibility issue, and the CI type is 0."
617,<android.net.LocalSocketImpl: void create(int)>,20,21,<android.net.LocalSocketImpl: void create(int)>,<android.net.LocalSocketImpl: void create(int)>,0,"{
    // need this for LocalServerSocket.accept()
    if (fd == null) {
        int osType;
        switch(sockType) {
            case LocalSocket.SOCKET_DGRAM:
                osType = OsConstants.SOCK_DGRAM;
                break;
            case LocalSocket.SOCKET_STREAM:
                osType = OsConstants.SOCK_STREAM;
                break;
            case LocalSocket.SOCKET_SEQPACKET:
                osType = OsConstants.SOCK_SEQPACKET;
                break;
            default:
                throw new IllegalStateException(""unknown sockType"");
        }
        try {
            fd = Libcore.os.socket(OsConstants.AF_UNIX, osType, 0);
            mFdCreatedInternally = true;
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
    }
}","{
    // need this for LocalServerSocket.accept()
    if (fd == null) {
        int osType;
        switch(sockType) {
            case LocalSocket.SOCKET_DGRAM:
                osType = OsConstants.SOCK_DGRAM;
                break;
            case LocalSocket.SOCKET_STREAM:
                osType = OsConstants.SOCK_STREAM;
                break;
            case LocalSocket.SOCKET_SEQPACKET:
                osType = OsConstants.SOCK_SEQPACKET;
                break;
            default:
                throw new IllegalStateException(""unknown sockType"");
        }
        try {
            fd = Os.socket(OsConstants.AF_UNIX, osType, 0);
            mFdCreatedInternally = true;
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
    }
}",1,"/**
 * Creates a socket in the underlying OS.
 *
 * @param sockType either {@link LocalSocket#SOCKET_DGRAM}, {@link LocalSocket#SOCKET_STREAM}
 * or {@link LocalSocket#SOCKET_SEQPACKET}
 * @throws IOException
 */
","/**
 * Creates a socket in the underlying OS.
 *
 * @param sockType either {@link LocalSocket#SOCKET_DGRAM}, {@link LocalSocket#SOCKET_STREAM}
 * or {@link LocalSocket#SOCKET_SEQPACKET}
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called to create socket changed from Libcore.os.socket() to Os.socket(). There's no other change in the control flow or exception throwing; therefore, the change type is 5.","Assuming Os.socket() is conceptually the same call as Libcore.os.socket() and just moved to a different class or namespace and the behavior remains consistent with the previous version, there would be no compatibility issue. However, without explicit information that the behavior of Os.socket() is identical to Libcore.os.socket(), there's a risk of assuming compatibility. For this strictly technical evaluation and the nature of the change, it's classified as no compatibility issue given the context and instructions provided."
618,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,20,21,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,0,"{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(appWidgetId, mContext.getUserId());
        } catch (RemoteException e) {
            throw new RuntimeException(""system server dead?"", e);
        }
    }
}","{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContext.getOpPackageName(), appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException(""system server dead?"", e);
        }
    }
}",1,"/**
 * Stop listening to changes for this AppWidget.
 */
","/**
 * Stop listening to changes for this AppWidget.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The order of the parameters in the dependent API method call sService.deleteAppWidgetId(...) has changed, and an additional parameter has been introduced, so the code change type is 5.","Despite the change in the dependent API method call, there is no indication of a change in behavior that would affect the return value or the exception handling of the `deleteAppWidgetId` method itself. Therefore, there is no Compatibility Issue, and the CI type is 0."
620,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,20,21,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,0,"{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    return l.isEmpty() ? null : l.get(0);
}","{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    boolean wakeUpSensor = false;
    // non_wake-up version.
    if (type == Sensor.TYPE_PROXIMITY || type == Sensor.TYPE_SIGNIFICANT_MOTION || type == Sensor.TYPE_TILT_DETECTOR || type == Sensor.TYPE_WAKE_GESTURE || type == Sensor.TYPE_GLANCE_GESTURE || type == Sensor.TYPE_PICK_UP_GESTURE) {
        wakeUpSensor = true;
    }
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUpSensor)
            return sensor;
    }
    return null;
}",1,"/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensors matching the asked type.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
","/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensor matching the requested type if one exists and the application
 * has the necessary permissions, or null otherwise.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version introduces new variable assignments, an if statement to set the boolean flag wakeUpSensor based on the sensor type, and a for loop with a condition based on the wakeUpSensor flag. These changes are control dependency and other statement changes. The condition of the for loop and the return statement within it are new compared to the early version.","Because the late version includes additional logic to return different Sensor objects based on whether the sensor is a wake-up sensor, the behavior of the API could be different, potentially leading to a different return value when the same sensor type is requested. This constitutes a compatibility issue of type 1."
621,<android.content.RestrictionEntry: boolean getSelectedState()>,20,21,<android.content.RestrictionEntry: boolean getSelectedState()>,<android.content.RestrictionEntry: boolean getSelectedState()>,0,"{
    return Boolean.parseBoolean(currentValue);
}","{
    return Boolean.parseBoolean(mCurrentValue);
}",1,"/**
 * Returns the current selected state for an entry of type {@link #TYPE_BOOLEAN}.
 * @return the current selected state of the entry.
 */
","/**
 * Returns the current selected state for an entry of type {@link #TYPE_BOOLEAN}.
 * @return the current selected state of the entry.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is related to an internal variable name change, from 'currentValue' to 'mCurrentValue'. The change type is 4 as it is neither a return statement, exception handling, control dependency, nor a dependent API change.","There is no Compatibility Issue as the behavior of the API does not change. The method still returns a boolean based on the parsed value of a string, regardless of the variable name change."
623,<android.widget.CalendarView: int getWeekNumberColor()>,20,21,<android.widget.CalendarView: int getWeekNumberColor()>,<android.widget.CalendarView: int getWeekNumberColor()>,0,"{
    return mWeekNumberColor;
}","{
    return mDelegate.getWeekNumberColor();
}",1,"/**
 * Gets the color for the week numbers.
 *
 * @return The week number color.
 *
 * @attr ref android.R.styleable#CalendarView_weekNumberColor
 */
","/**
 * Gets the color for the week numbers.
 *
 * @return The week number color.
 *
 * @attr ref android.R.styleable#CalendarView_weekNumberColor
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method used to obtain the week number color has changed from directly returning a member variable (mWeekNumberColor) to calling another method (mDelegate.getWeekNumberColor()), indicating that the dependency API getWeekNumberColor() of the delegate class is now being used, so the code change type is 5.","This change can potentially lead to a different return value, as mWeekNumberColor and mDelegate.getWeekNumberColor() may not necessarily refer to the same value. Therefore, this induces a CI type of 1 due to the potential for different return values."
624,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",20,21,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>","<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",0,"{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt(""sys.max_texture_size"", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
","/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version introduces a block that reads the maximum texture size from system property and adjusts the `minimumWidth` and `minimumHeight` accordingly before setting the dimension hints, which did not exist in the early version. This is a control dependency change (3) as well as another statement changed (4).","This change can cause the API to potentially return different values because the values of `minimumWidth` and `minimumHeight` may be altered based on the new logic introduced. Therefore, the API can have different behavior when it suggests the desired dimensions which could lead to a different result when the API is called in the context that depends on these dimensions, thus the CI type is 1."
625,<android.content.ContentResolver: void setMasterSyncAutomatically(boolean)>,20,21,<android.content.ContentResolver: void setMasterSyncAutomatically(boolean)>,<android.content.ContentResolver: void setMasterSyncAutomatically(boolean)>,0,"{
    try {
        getContentService().setMasterSyncAutomatically(sync);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}","{
    setMasterSyncAutomaticallyAsUser(sync, UserHandle.myUserId());
}",1,"/**
 * Sets the master auto-sync setting that applies to all the providers and accounts.
 * If this is false then the per-provider auto-sync setting is ignored.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param sync the master auto-sync setting that applies to all the providers and accounts
 */
","/**
 * Sets the master auto-sync setting that applies to all the providers and accounts.
 * If this is false then the per-provider auto-sync setting is ignored.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param sync the master auto-sync setting that applies to all the providers and accounts
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The late version of the method delegates the call to 'setMasterSyncAutomaticallyAsUser' with 'sync' and the current user's ID, instead of directly invoking 'getContentService().setMasterSyncAutomatically(sync)'. Therefore, the code change type is 5 (Dependent API changed).","Although there is a modification in the dependent method and it could be seen as a shift to a more specialized method of the same functionality with additional user context, there is no direct indication that this change leads to a Compatibility Issue because it doesn't inherently suggest a different behavior in the API's contract; it just uses the current user's ID as an additional parameter. Hence, it is deemed as no Compatibility Issue, CI type 0."
626,"<android.view.inputmethod.BaseInputConnection: boolean setComposingText(CharSequence,int)>",20,21,"<android.view.inputmethod.BaseInputConnection: boolean setComposingText(CharSequence,int)>","<android.view.inputmethod.BaseInputConnection: boolean setComposingText(CharSequence,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""setComposingText "" + text);
    replaceText(text, newCursorPosition, true);
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""setComposingText "" + text);
    replaceText(text, newCursorPosition, true);
    mIMM.notifyUserAction();
    return true;
}",1,"/**
 * The default implementation places the given text into the editable,
 * replacing any existing composing text.  The new text is marked as
 * in a composing state with the composing style.
 */
","/**
 * The default implementation places the given text into the editable,
 * replacing any existing composing text.  The new text is marked as
 * in a composing state with the composing style.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional method call (mIMM.notifyUserAction()) has been added which is not related to returning a different value or type, nor does it affect exception handling. Thus, the code change type is 4.","The added method call does not affect the return value or change the exceptions being thrown. Therefore, this change does not introduce a Compatibility Issue."
627,"<android.os.Bundle: char getChar(String,char)>",20,21,"<android.os.Bundle: char getChar(String,char)>","<android.os.Bundle: char getChar(String,char)>",0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (Character) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Character"", defaultValue, e);
        return defaultValue;
    }
}","{
    return super.getChar(key, defaultValue);
}",1,"/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a char value
 */
","/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a char value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method changed completely to call the superclass implementation 'super.getChar(key, defaultValue);'. This indicates a dependent API changed, which is the code change type 5.","The superclass method 'super.getChar(key, defaultValue)' is expected to perform the same functionality as the previous implementation. There is no indication that the superclass method behaves differently, hence there should not be a Compatibility Issue unless the superclass's method itself was changed in a way that would affect this. Based solely on the changed code in this subclass, we cannot assume a Compatibility Issue. Theoretically, this change could delegate to the same logic that existed before if the superclass has not been modified in an incompatible way."
628,<android.content.AsyncTaskLoader: void executePendingTask()>,20,21,<android.content.AsyncTaskLoader: void executePendingTask()>,<android.content.AsyncTaskLoader: void executePendingTask()>,0,"{
    if (mCancellingTask == null && mTask != null) {
        if (mTask.waiting) {
            mTask.waiting = false;
            mHandler.removeCallbacks(mTask);
        }
        if (mUpdateThrottle > 0) {
            long now = SystemClock.uptimeMillis();
            if (now < (mLastLoadCompleteTime + mUpdateThrottle)) {
                // Not yet time to do another load.
                if (DEBUG)
                    Slog.v(TAG, ""Waiting until "" + (mLastLoadCompleteTime + mUpdateThrottle) + "" to execute: "" + mTask);
                mTask.waiting = true;
                mHandler.postAtTime(mTask, mLastLoadCompleteTime + mUpdateThrottle);
                return;
            }
        }
        if (DEBUG)
            Slog.v(TAG, ""Executing: "" + mTask);
        mTask.executeOnExecutor(mExecutor, (Void[]) null);
    }
}","{
    if (mCancellingTask == null && mTask != null) {
        if (mTask.waiting) {
            mTask.waiting = false;
            mHandler.removeCallbacks(mTask);
        }
        if (mUpdateThrottle > 0) {
            long now = SystemClock.uptimeMillis();
            if (now < (mLastLoadCompleteTime + mUpdateThrottle)) {
                // Not yet time to do another load.
                if (DEBUG)
                    Log.v(TAG, ""Waiting until "" + (mLastLoadCompleteTime + mUpdateThrottle) + "" to execute: "" + mTask);
                mTask.waiting = true;
                mHandler.postAtTime(mTask, mLastLoadCompleteTime + mUpdateThrottle);
                return;
            }
        }
        if (DEBUG)
            Log.v(TAG, ""Executing: "" + mTask);
        mTask.executeOnExecutor(mExecutor, (Void[]) null);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is the logging class used from Slog.v to Log.v, which does not affect the functionality or behavior of the API, hence the code change type is 4.","There is no Compatibility Issue as the logging statements do not change the API's behavior and are not relevant to the functionality provided by the method to the callers. The output of the program remains the same regardless of the internal logging mechanism being used, so the CI type is 0."
629,<android.widget.EdgeEffect: void onRelease()>,20,21,<android.widget.EdgeEffect: void onRelease()>,<android.widget.EdgeEffect: void onRelease()>,0,"{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mEdgeAlphaStart = mEdgeAlpha;
    mEdgeScaleYStart = mEdgeScaleY;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mEdgeAlphaFinish = 0.f;
    mEdgeScaleYFinish = 0.f;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}","{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}",1,"/**
 * Call when the object is released after being pulled.
 * This will begin the ""decay"" phase of the effect. After calling this method
 * the host view should {@link android.view.View#invalidate()} and thereby
 * draw the results accordingly.
 */
","/**
 * Call when the object is released after being pulled.
 * This will begin the ""decay"" phase of the effect. After calling this method
 * the host view should {@link android.view.View#invalidate()} and thereby
 * draw the results accordingly.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change type is 4, where several assignment statements related to 'mEdgeAlphaStart', 'mEdgeScaleYStart', 'mEdgeAlphaFinish', and 'mEdgeScaleYFinish' have been removed from the late version of the method.","There is no Compatibility Issue as there is no change in the control flow, no change in exception handling, and no change in return values. The method in both versions does not return any value (void return type), and the removal of certain state update expressions does not affect the outward behavior of the method with respect to the caller."
630,<android.view.MotionEvent: String axisToString(int)>,20,21,<android.view.MotionEvent: String axisToString(int)>,<android.view.MotionEvent: String axisToString(int)>,0,"{
    String symbolicName = AXIS_SYMBOLIC_NAMES.get(axis);
    return symbolicName != null ? symbolicName : Integer.toString(axis);
}","{
    String symbolicName = nativeAxisToString(axis);
    return symbolicName != null ? LABEL_PREFIX + symbolicName : Integer.toString(axis);
}",1,"/**
 * Returns a string that represents the symbolic name of the specified axis
 * such as ""AXIS_X"" or an equivalent numeric constant such as ""42"" if unknown.
 *
 * @param axis The axis.
 * @return The symbolic name of the specified axis.
 */
","/**
 * Returns a string that represents the symbolic name of the specified axis
 * such as ""AXIS_X"" or an equivalent numeric constant such as ""42"" if unknown.
 *
 * @param axis The axis.
 * @return The symbolic name of the specified axis.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method used to obtain the symbolic name has changed from AXIS_SYMBOLIC_NAMES.get(axis) to nativeAxisToString(axis), and the return statement now concatenates a prefix LABEL_PREFIX if a symbolic name is found, whereas the earlier version did not concatenate any prefix. Therefore, the code change types are 1 and 5.","The change in how the symbolic name is obtained and the addition of a prefix if a symbolic name is found could lead to the API returning different values between the two versions, causing a compatibility issue of type 1."
631,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",20,21,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>","<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",0,"{
    try {
        return mService.startUsingNetworkFeature(networkType, feature, new Binder());
    } catch (RemoteException e) {
        return -1;
    }
}","{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy startUsingNetworkFeature for "" + networkType + "", "" + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        if (LEGACY_DBG) {
            Log.d(TAG, ""Looking for legacyRequest for netCap with hash: "" + netCap + "" ("" + netCap.hashCode() + "")"");
            Log.d(TAG, ""sLegacyRequests has:"");
            for (NetworkCapabilities nc : sLegacyRequests.keySet()) {
                Log.d(TAG, ""  "" + nc + "" ("" + nc.hashCode() + "")"");
            }
        }
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, ""renewing startUsingNetworkFeature request "" + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, ""starting startUsingNetworkFeature for request "" + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, "" request Failed"");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}",1,"/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 */
","/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The code change involves removing the try-catch structure, introducing new variables and control flow statements such as 'if' and 'synchronized', and changing the method by which the result is obtained. The old API implementation directly called a method on another object, while the new implementation performs a series of checks and only makes a request under certain conditions. Thus, we see changes in return statements, exception handling statement, control dependency, other statements, and dependent API usage. The classifications that apply are 1, 2, 3, 4, and 5.","The new implementation has different return paths and different potential exception handling due to the removal of the try-catch structure. Moreover, the conditions under which the method returns certain values have been altered significantly. The old implementation had a catch block that returned a specific error code (-1) if an exception occurred, whereas the new one propogates the exception; the new implementation has additional return paths that earlier did not exist. This could result in different return values or types compared to the old version, and due to the removal of the try-catch block, different exception behaviours. Hence, CI types 1 and 2 are applicable."
633,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,20,21,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,0,"{
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = mProperty.get(target);
            for (Keyframe kf : mKeyframeSet.mKeyframes) {
                if (!kf.hasValue()) {
                    kf.setValue(mProperty.get(target));
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w(""PropertyValuesHolder"", ""No such property ("" + mProperty.getName() + "") on target object "" + target + "". Trying reflection instead"");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    for (Keyframe kf : mKeyframeSet.mKeyframes) {
        if (!kf.hasValue()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                kf.setValue(mGetter.invoke(target));
            } catch (InvocationTargetException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            } catch (IllegalAccessException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            }
        }
    }
}","{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w(""PropertyValuesHolder"", ""No such property ("" + mProperty.getName() + "") on target object "" + target + "". Trying reflection instead"");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    int keyframeCount = keyframes == null ? 0 : keyframes.size();
    for (int i = 0; i < keyframeCount; i++) {
        Keyframe kf = keyframes.get(i);
        if (!kf.hasValue() || kf.valueWasSetOnStart()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                Object value = convertBack(mGetter.invoke(target));
                kf.setValue(value);
                kf.setValueWasSetOnStart(true);
            } catch (InvocationTargetException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            } catch (IllegalAccessException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            }
        }
    }
}",1,"/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
","/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The change includes altering how keyframes are accessed by creating new local variables for them and their counts, the introduction of the mKeyframes.invalidateCache() method invocation, changes to the for-loop such as additional conditions and the addition of new method calls (convertBack and setValueWasSetOnStart), and differences in how variable 'testValue' is initialized and used. These changes are categorized as 3 (Control dependency change) and 4 (Other statement changed).",
636,<android.widget.CalendarView: int getShownWeekCount()>,20,21,<android.widget.CalendarView: int getShownWeekCount()>,<android.widget.CalendarView: int getShownWeekCount()>,0,"{
    return mShownWeekCount;
}","{
    return mDelegate.getShownWeekCount();
}",1,"/**
 * Gets the number of weeks to be shown.
 *
 * @return The shown week count.
 *
 * @attr ref android.R.styleable#CalendarView_shownWeekCount
 */
","/**
 * Gets the number of weeks to be shown.
 *
 * @return The shown week count.
 *
 * @attr ref android.R.styleable#CalendarView_shownWeekCount
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The way the value is returned has changed from directly returning a member variable to calling a method on the delegate object, so the code change category is 1,5.","Because the late version involves invoking a method on another object to get the shown week count, whereas the early version returns a member variable value directly, the API potentially returns a different value depending on the implementation of the delegate. The CI type is 1."
638,<android.app.Activity: void finish()>,20,21,<android.app.Activity: void finish()>,<android.app.Activity: void finish()>,0,"{
    if (mParent == null) {
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (false)
            Log.v(TAG, ""Finishing self: token="" + mToken);
        try {
            if (resultData != null) {
                resultData.prepareToLeaveProcess();
            }
            if (ActivityManagerNative.getDefault().finishActivity(mToken, resultCode, resultData)) {
                mFinished = true;
            }
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishFromChild(this);
    }
}","{
    finish(false);
}",1,"/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */
","/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The late implementation of the method calls another method 'finish(boolean)' instead of directly implementing the logic. This is a change in the dependent API, so the code change type is 5.","Since the entire implementation is replaced with a call to another method and the implementation details of this new method are not provided, we cannot say for sure if this leads to a compatibility issue. We have no information on how the behavior has changed between versions. Assuming that the new 'finish(boolean)' method maintains the contract and expected behavior of the 'finish()' method, there should be no compatibility issue. Therefore, the CI type is 0."
639,<android.content.res.TypedArray: int getIndex(int)>,20,21,<android.content.res.TypedArray: int getIndex(int)>,<android.content.res.TypedArray: int getIndex(int)>,0,"{
    return mIndices[1 + at];
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return mIndices[1 + at];
}",1,"/**
 * Return an index in the array that has data.
 *
 * @param at The index you would like to returned, ranging from 0 to
 * {@link #getIndexCount()}.
 *
 * @return The index at the given offset, which can be used with
 * {@link #getValue} and related APIs.
 */
","/**
 * Return an index in the array that has data.
 *
 * @param at The index you would like to returned, ranging from 0 to
 * {@link #getIndexCount()}.
 *
 * @return The index at the given offset, which can be used with
 * {@link #getValue} and related APIs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The late version introduces a new exception handling statement (a check for `mRecycled` followed by an exception throw), so the code change type is 2, with control dependency change being 3 due to the newly added 'if' statement.","The newly added exception handling could potentially lead to a different exception being thrown when `mRecycled` is true, which means that the API's behavior has been modified. Therefore, the CI type is 2."
640,<android.widget.AbsListView: int getVerticalScrollbarWidth()>,20,21,<android.widget.AbsListView: int getVerticalScrollbarWidth()>,<android.widget.AbsListView: int getVerticalScrollbarWidth()>,0,"{
    if (mFastScroller != null && mFastScroller.isEnabled()) {
        return Math.max(super.getVerticalScrollbarWidth(), mFastScroller.getWidth());
    }
    return super.getVerticalScrollbarWidth();
}","{
    if (mFastScroll != null && mFastScroll.isEnabled()) {
        return Math.max(super.getVerticalScrollbarWidth(), mFastScroll.getWidth());
    }
    return super.getVerticalScrollbarWidth();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The code change is that the member variable name changed from mFastScroller to mFastScroll. There's no change to the logic or control flow of the code. This is a change in the dependent API, so the code change type is 5.","As only a member variable is renamed without changing the behavior of the API (the renamed member variable is assumed to have the same type and behavior), there is no Compatibility Issue. Therefore, the CI type is 0."
641,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createSocketPair()>,20,21,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createSocketPair()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createSocketPair()>,0,"{
    try {
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0), new ParcelFileDescriptor(fd1) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0), new ParcelFileDescriptor(fd1) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 */
","/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is from Libcore.os.socketpair(...) to Os.socketpair(...), which indicates a change in the dependent API (dependent API changed). The rest of the method structure, control flow, and exception handling are unchanged. This corresponds to code change type 4,5.","As the dependent API change doesn't affect the method signature and doesn't inherently alter the behavior of the API, it is unlikely to cause a compatibility issue unless the new Os.socketpair(...) method behaves differently from Libcore.os.socketpair(...). Based on the information provided, it is assumed that the replacement is a direct mapping and therefore does not cause a compatibility issue, hence CI type is 0."
642,<android.view.View.SendViewStateChangedAccessibilityEvent: void runOrPost(int)>,20,21,<android.view.View.SendViewStateChangedAccessibilityEvent: void runOrPost(int)>,<android.view.View.SendViewStateChangedAccessibilityEvent: void runOrPost(int)>,0,"{
    mChangeTypes |= changeType;
    // all events from this frame and send them on the next frame.
    if (inLiveRegion()) {
        // If we're already posted with a delay, remove that.
        if (mPostedWithDelay) {
            removeCallbacks(this);
            mPostedWithDelay = false;
        }
        // Only post if we're not already posted.
        if (!mPosted) {
            post(this);
            mPosted = true;
        }
        return;
    }
    if (mPosted) {
        return;
    }
    final long timeSinceLastMillis = SystemClock.uptimeMillis() - mLastEventTimeMillis;
    final long minEventIntevalMillis = ViewConfiguration.getSendRecurringAccessibilityEventsInterval();
    if (timeSinceLastMillis >= minEventIntevalMillis) {
        removeCallbacks(this);
        run();
    } else {
        postDelayed(this, minEventIntevalMillis - timeSinceLastMillis);
        mPosted = true;
        mPostedWithDelay = true;
    }
}","{
    mChangeTypes |= changeType;
    // all events from this frame and send them on the next frame.
    if (inLiveRegion()) {
        // If we're already posted with a delay, remove that.
        if (mPostedWithDelay) {
            removeCallbacks(this);
            mPostedWithDelay = false;
        }
        // Only post if we're not already posted.
        if (!mPosted) {
            post(this);
            mPosted = true;
        }
        return;
    }
    if (mPosted) {
        return;
    }
    final long timeSinceLastMillis = SystemClock.uptimeMillis() - mLastEventTimeMillis;
    final long minEventIntevalMillis = ViewConfiguration.getSendRecurringAccessibilityEventsInterval();
    if (timeSinceLastMillis >= minEventIntevalMillis) {
        removeCallbacks(this);
        run();
    } else {
        postDelayed(this, minEventIntevalMillis - timeSinceLastMillis);
        mPostedWithDelay = true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change occurred in the else block where `mPosted = true;` has been deleted in the late version. This change is not related to the return statement, exception handling, or control dependency. It is an instance of other statement changes, so the code change type is 4.","There is no Compatibility Issue detected because the change does not affect the method's return type or value nor the exception handling semantics. The method's behavior will potentially remain consistent regarding its return value and exception throwing; the change only affects an internal state flag, so the CI type is 0."
643,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)>",20,21,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, AppOpsManager.OP_NONE, true, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    sendOrderedBroadcastAsUser(intent, user, receiverPermission, AppOpsManager.OP_NONE, resultReceiver, scheduler, initialCode, initialData, initialExtras);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The early version of the implementation has been replaced by a single call to another method, sendOrderedBroadcastAsUser, with the same parameters in the late version, so the code change type is 5.","Since the actual behavior and logic have been internalized in a different method call that takes the same parameters, there should be no Compatibility Issue, assuming the sendOrderedBroadcastAsUser method called in the late version correctly encapsulates the behavior of the old implementation. Therefore, the CI type is 0."
644,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",20,21,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>","<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",0,"{
    return null;
}","{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            animator.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = -1;
        final boolean isForcedVisibility = mForcedStartVisibility != -1 || mForcedEndVisibility != -1;
        if (!isForcedVisibility) {
            originalVisibility = viewToKeep.getVisibility();
            viewToKeep.setVisibility(View.VISIBLE);
        }
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            final View finalViewToKeep = viewToKeep;
            animator.addListener(new AnimatorListenerAdapter() {

                boolean mCanceled = false;

                @Override
                public void onAnimationPause(Animator animation) {
                    if (!mCanceled && !isForcedVisibility) {
                        finalViewToKeep.setVisibility(finalVisibility);
                    }
                }

                @Override
                public void onAnimationResume(Animator animation) {
                    if (!mCanceled && !isForcedVisibility) {
                        finalViewToKeep.setVisibility(View.VISIBLE);
                    }
                }

                @Override
                public void onAnimationCancel(Animator animation) {
                    mCanceled = true;
                }

                @Override
                public void onAnimationEnd(Animator animation) {
                    if (!mCanceled) {
                        if (isForcedVisibility) {
                            finalViewToKeep.setTransitionAlpha(0);
                        } else {
                            finalViewToKeep.setVisibility(finalVisibility);
                        }
                    }
                }
            });
        } else if (!isForcedVisibility) {
            viewToKeep.setVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}",1,"/**
 * The default implementation of this method does nothing. Subclasses
 * should override if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
","/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
645,<android.bluetooth.BluetoothSocket: void connect()>,20,21,<android.bluetooth.BluetoothSocket: void connect()>,<android.bluetooth.BluetoothSocket: void connect()>,0,"{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException(""bt socket connect failed"");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""bt socket closed"");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
    }
}","{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException(""bt socket connect failed"");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""bt socket closed"");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException(""unable to send RPC: "" + e.getMessage());
    }
}",1,"/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
","/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has been added (`throw new IOException(""unable to send RPC: "" + e.getMessage());`) after the log statement within the `catch (RemoteException e)` block, making an addition to the exception handling logic. So the code change type is 2.","The addition of the `throw` statement in the `catch` block will cause a new `IOException` to be thrown in case of a `RemoteException` occurring, which wasn't thrown in the early version. This change affects how exceptions are handled, potentially causing different behavior when the method is called, so the CI type is 2."
646,"<android.content.ContentResolver: boolean isSyncPending(Account,String)>",20,21,"<android.content.ContentResolver: boolean isSyncPending(Account,String)>","<android.content.ContentResolver: boolean isSyncPending(Account,String)>",0,"{
    try {
        return getContentService().isSyncPending(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    return isSyncPendingAsUser(account, authority, UserHandle.myUserId());
}",1,"/**
 * Return true if the pending status is true of any matching authorities.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if there is a pending sync with the matching account and authority
 */
","/**
 * Return true if the pending status is true of any matching authorities.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if there is a pending sync with the matching account and authority
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within the return statement has been changed from `getContentService().isSyncPending(account, authority)` to `isSyncPendingAsUser(account, authority, UserHandle.myUserId())`, and the original exception handling code has been removed. Additionally, the new method call introduces a dependency on a different API method (`isSyncPendingAsUser`), constituting a change in the dependent API. Therefore, the code change types are 1 and 5.","Due to the replacement of the method call, the method may return different results, particularly if the two methods `isSyncPending` and `isSyncPendingAsUser` do not behave identically. Also, since the original version could throw a `RuntimeException` when catching a `RemoteException` and the new version does not have this behavior, this could result in different exception handling. The change can cause the API to return a different value or handle exceptions differently, leading to compatibility issues. Hence, the CI type is 1 for potential different return values and 2 for potential different exception handling."
647,<android.service.dreams.DreamService: boolean dispatchKeyShortcutEvent(KeyEvent)>,20,21,<android.service.dreams.DreamService: boolean dispatchKeyShortcutEvent(KeyEvent)>,<android.service.dreams.DreamService: boolean dispatchKeyShortcutEvent(KeyEvent)>,0,"{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Finishing on keyShortcutEvent"");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchKeyShortcutEvent(event);
}","{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on keyShortcutEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyShortcutEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation has changed the method called within the if block from safelyFinish() to wakeUp(), without modifying any return types or exceptions being thrown, so the code change type is 4.","There is no CI detected, as the return values are not changed, and no new exceptions are introduced or removed in the code. The changes in method behavior do not affect the contract of the method, as the returning values remain the same, hence the CI type is 0."
649,<android.widget.CalendarView: boolean getShowWeekNumber()>,20,21,<android.widget.CalendarView: boolean getShowWeekNumber()>,<android.widget.CalendarView: boolean getShowWeekNumber()>,0,"{
    return mShowWeekNumber;
}","{
    return mDelegate.getShowWeekNumber();
}",1,"/**
 * Gets whether to show the week number.
 *
 * @return True if showing the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */
","/**
 * Gets whether to show the week number.
 *
 * @return True if showing the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The source of the return value changed from directly returning a member variable (mShowWeekNumber) to calling a method on a delegate object (mDelegate.getShowWeekNumber()), which means both the return statement and the dependent API have changed, so the changes are 1 and 5.","Because the implementation now delegates to a different method potentially linked to a different logic to get the show week number value, it could return a different result than the previous direct field access. Therefore, the potential for different return values exists and the CI type is 1."
650,<android.hardware.camera2.CameraManager: String[] getCameraIdList()>,20,21,<android.hardware.camera2.CameraManager: String[] getCameraIdList()>,<android.hardware.camera2.CameraManager: String[] getCameraIdList()>,0,"{
    synchronized (mLock) {
        try {
            return getOrCreateDeviceIdListLocked().toArray(new String[0]);
        } catch (CameraAccessException e) {
            // this should almost never happen, except if mediaserver crashes
            throw new IllegalStateException(""Failed to query camera service for device ID list"", e);
        }
    }
}","{
    synchronized (mLock) {
        // exceptions it'll throw are unexpected, and should be propagated upward.
        return getOrCreateDeviceIdListLocked().toArray(new String[0]);
    }
}",1,"/**
 * Return the list of currently connected camera devices by
 * identifier.
 *
 * <p>Non-removable cameras use integers starting at 0 for their
 * identifiers, while removable cameras have a unique identifier for each
 * individual device, even if they are the same model.</p>
 *
 * @return The list of currently connected camera devices.
 */
","/**
 * Return the list of currently connected camera devices by
 * identifier.
 *
 * <p>Non-removable cameras use integers starting at 0 for their
 * identifiers, while removable cameras have a unique identifier for each
 * individual device, even if they are the same model.</p>
 *
 * @return The list of currently connected camera devices.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed; specifically, the catch block with the throw statement for the IllegalStateException is removed.","The removal of an exception handling block can result in different exceptions being thrown when the code is executed. Previously, a CameraAccessException would lead to an IllegalStateException, but now it will not be caught and handled, allowing the CameraAccessException or any other exception to propagate. This constitutes a Compatibility Issue due to potential different exception handlings, so the CI type is 2."
651,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>",20,21,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>","<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>",0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValueForDensity(id, density, value, true);
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = mMetrics.densityDpi;
            } else {
                value.density = (value.density * mMetrics.densityDpi) / density;
            }
        }
    }
    Drawable res = loadDrawable(value, id);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}","{
    return getDrawableForDensity(id, density, null);
}",1,"/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI. This will set the drawable's density to be
 * the device's density multiplied by the ratio of actual drawable density
 * to requested density. This allows the drawable to be scaled up to the
 * correct size if needed. Various types of objects will be returned
 * depending on the underlying resource -- for example, a solid color, PNG
 * image, scalable image, etc. The Drawable API hides these implementation
 * details.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density the desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @return Drawable An object that can be used to draw this resource.
 */
","/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI. This will set the drawable's density to be
 * the device's density multiplied by the ratio of actual drawable density
 * to requested density. This allows the drawable to be scaled up to the
 * correct size if needed. Various types of objects will be returned
 * depending on the underlying resource -- for example, a solid color, PNG
 * image, scalable image, etc. The Drawable API hides these implementation
 * details.
 *
 * <p class=""note""><strong>Note:</strong> To obtain a themed drawable, use
 * {@link android.content.Context#getDrawable(int) Context.getDrawable(int)}
 * or {@link #getDrawableForDensity(int, int, Theme)} passing the desired
 * theme.</p>
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density the desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @see #getDrawableForDensity(int, int, Theme)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has been completely changed from a detailed block of code that does various checks and density adjustments to a single return statement that calls another method getDrawableForDensity with a third parameter as null. The return type and the parameters of the method signature remain unchanged, but the internal implementation and the behavior of the API may have changed due to calling a different method. Therefore, the code change type is 1,5.","The entire implementation of the method has been replaced, which can potentially lead to different return values, especially since the previous implementation included density adjustments and a caching system for the TypedValue object that is no longer present. As a result, the return value (the Drawable object obtained) could differ even if the method signature is the same. This constitutes a Compatibility Issue of type 1."
652,<android.bluetooth.BluetoothGatt: boolean beginReliableWrite()>,20,21,<android.bluetooth.BluetoothGatt: boolean beginReliableWrite()>,<android.bluetooth.BluetoothGatt: boolean beginReliableWrite()>,0,"{
    if (DBG)
        Log.d(TAG, ""beginReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.beginReliableWrite(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""beginReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.beginReliableWrite(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Initiates a reliable write transaction for a given remote device.
 *
 * <p>Once a reliable write transaction has been initiated, all calls
 * to {@link #writeCharacteristic} are sent to the remote device for
 * verification and queued up for atomic execution. The application will
 * receive an {@link BluetoothGattCallback#onCharacteristicWrite} callback
 * in response to every {@link #writeCharacteristic} call and is responsible
 * for verifying if the value has been transmitted accurately.
 *
 * <p>After all characteristics have been queued up and verified,
 * {@link #executeReliableWrite} will execute all writes. If a characteristic
 * was not written correctly, calling {@link #abortReliableWrite} will
 * cancel the current transaction without commiting any values on the
 * remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the reliable write transaction has been initiated
 */
","/**
 * Initiates a reliable write transaction for a given remote device.
 *
 * <p>Once a reliable write transaction has been initiated, all calls
 * to {@link #writeCharacteristic} are sent to the remote device for
 * verification and queued up for atomic execution. The application will
 * receive an {@link BluetoothGattCallback#onCharacteristicWrite} callback
 * in response to every {@link #writeCharacteristic} call and is responsible
 * for verifying if the value has been transmitted accurately.
 *
 * <p>After all characteristics have been queued up and verified,
 * {@link #executeReliableWrite} will execute all writes. If a characteristic
 * was not written correctly, calling {@link #abortReliableWrite} will
 * cancel the current transaction without commiting any values on the
 * remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the reliable write transaction has been initiated
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is only in the condition that checks the debug flag (from DBG to VDBG). This is not related to the behaviour of the method itself but to logging, so the code change type is 4.","The change is related to logging and does not affect the API's functionality, output, or exception handling. Therefore, there is no compatibility issue."
653,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,20,21,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,0,"{
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        return sService.allocateAppWidgetId(mPackageName, mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        return sService.allocateAppWidgetId(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
","/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method signature for `allocateAppWidgetId`'s dependent API `sService.allocateAppWidgetId` has changed. In the early implementation, it takes three arguments: `mPackageName`, `mHostId`, and `mContext.getUserId()`, while in the late implementation, it only takes two: `mContext.getOpPackageName()` and `mHostId`. Additionally, the early implementation includes a conditional check to initialize `mPackageName` if it is `null`, which is absent in the late implementation. Hence, the code change types are 4 (for the initialization code change) and 5 (for the change in the dependent API).","Since the arguments passed to the dependent API `sService.allocateAppWidgetId` have changed, including the removal of `mContext.getUserId()` and the change from `mPackageName` to `mContext.getOpPackageName()`, this could potentially lead to the API returning a different value when invoked. Thus, the CI type is 1."
655,<android.appwidget.AppWidgetManager: int[] getAppWidgetIds(ComponentName)>,20,21,<android.appwidget.AppWidgetManager: int[] getAppWidgetIds(ComponentName)>,<android.appwidget.AppWidgetManager: int[] getAppWidgetIds(ComponentName)>,0,"{
    try {
        return sService.getAppWidgetIds(provider, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return new int[0];
    }
    try {
        return mService.getAppWidgetIds(provider);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */
","/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The exception handling statement changed from `sService.getAppWidgetIds(provider, mContext.getUserId())` to `mService.getAppWidgetIds(provider)`, indicating a removed parameter (mContext.getUserId()). Additionally, a new control statement (`if (mService == null)`) and a return statement returning `new int[0]` in case `mService` is `null` were introduced. So, the change type is 2,3,5.","The introduction of a conditional check for `mService == null` could lead to a different return value, which is potentially a new behavior where an empty array is returned instead of hitting the `RemoteException` catch block. Furthermore, the removal of the `mContext.getUserId()` parameter in the call to `mService.getAppWidgetIds(provider)` is also a change that could potentially affect the return value. Hence, this gives a CI type of 1 for the return value and 2 for the exception handling."
656,"<android.view.accessibility.AccessibilityNodeInfo.CollectionItemInfo: CollectionItemInfo obtain(int,int,int,int,boolean)>",20,21,"<android.view.accessibility.AccessibilityNodeInfo.CollectionItemInfo: CollectionItemInfo obtain(int,int,int,int,boolean)>","<android.view.accessibility.AccessibilityNodeInfo.CollectionItemInfo: CollectionItemInfo obtain(int,int,int,int,boolean)>",0,"{
    CollectionItemInfo info = sPool.acquire();
    return (info != null) ? info : new CollectionItemInfo(rowIndex, rowSpan, columnIndex, columnSpan, heading);
}","{
    return obtain(rowIndex, rowSpan, columnIndex, columnSpan, heading, false);
}",1,"/**
 * Obtains a pooled instance.
 *
 * @param rowIndex The row index at which the item is located.
 * @param rowSpan The number of rows the item spans.
 * @param columnIndex The column index at which the item is located.
 * @param columnSpan The number of columns the item spans.
 * @param heading Whether the item is a heading.
 */
","/**
 * Obtains a pooled instance.
 *
 * @param rowIndex The row index at which the item is located.
 * @param rowSpan The number of rows the item spans.
 * @param columnIndex The column index at which the item is located.
 * @param columnSpan The number of columns the item spans.
 * @param heading Whether the item is a heading.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation in the late version no longer uses the pool to acquire a CollectionItemInfo but instead, directly calls another overloaded method with an additional argument. This indicates a change in a dependent API, which is the internal redirection to another obtain method with different parameters.","While the dependent API has changed, the behavior perceived by the client of the API remains consistent. The client still receives a CollectionItemInfo object with the same characteristics as before. Therefore, no Compatibility Issue arises from this specific change as far as can be inferred from the provided information."
657,<android.os.Bundle: ArrayList<String> getStringArrayList(String)>,20,21,<android.os.Bundle: ArrayList<String> getStringArrayList(String)>,<android.os.Bundle: ArrayList<String> getStringArrayList(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<String>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""ArrayList<String>"", e);
        return null;
    }
}","{
    return super.getStringArrayList(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation of getStringArrayList now calls super.getStringArrayList(key) instead of containing its own logic to retrieve the string array list. Since getStringArrayList is not overridden in the ""Early_Version"", it implies that the method has been moved up in the inheritance hierarchy by the time ""Late_Version"" was released. This is a change in the dependent API, so the code change type is 5.","Since the late implementation delegates the task to its superclass's implementation instead of changing the logic itself, and given that there is no indication that the superclass's getStringArrayList(String) method has been modified between the versions, there's no direct compatibility issue. The behavior would remain consistent if the superclass method correctly implements the contract of getStringArrayList, so the CI type is 0."
658,"<android.text.TextUtils: boolean regionMatches(CharSequence,int,CharSequence,int,int)>",20,21,"<android.text.TextUtils: boolean regionMatches(CharSequence,int,CharSequence,int,int)>","<android.text.TextUtils: boolean regionMatches(CharSequence,int,CharSequence,int,int)>",0,"{
    char[] temp = obtain(2 * len);
    getChars(one, toffset, toffset + len, temp, 0);
    getChars(two, ooffset, ooffset + len, temp, len);
    boolean match = true;
    for (int i = 0; i < len; i++) {
        if (temp[i] != temp[i + len]) {
            match = false;
            break;
        }
    }
    recycle(temp);
    return match;
}","{
    int tempLen = 2 * len;
    if (tempLen < len) {
        // Integer overflow; len is unreasonably large
        throw new IndexOutOfBoundsException();
    }
    char[] temp = obtain(tempLen);
    getChars(one, toffset, toffset + len, temp, 0);
    getChars(two, ooffset, ooffset + len, temp, len);
    boolean match = true;
    for (int i = 0; i < len; i++) {
        if (temp[i] != temp[i + len]) {
            match = false;
            break;
        }
    }
    recycle(temp);
    return match;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,The introduction of an integer overflow check and subsequent throwing of `IndexOutOfBoundsException` in the late version represents a change to exception handling (type 2) as well as the insertion of other statements in the form of integer overflow check that did not exist in the early version (type 4).,"The newly introduced integer overflow check and throw statement could lead to a different exception being thrown in cases where `len` is unreasonably large, which constitutes a Compatibility Issue as the behavior when the exception condition is met will be different (type 2). The late version may throw an `IndexOutOfBoundsException` where the early version would have continued execution and likely resulted in an incorrect return value or an undetected overflow error."
659,<android.animation.Keyframe.IntKeyframe: IntKeyframe clone()>,20,21,<android.animation.Keyframe.IntKeyframe: IntKeyframe clone()>,<android.animation.Keyframe.IntKeyframe: IntKeyframe clone()>,0,"{
    IntKeyframe kfClone = mHasValue ? new IntKeyframe(getFraction(), mValue) : new IntKeyframe(getFraction());
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}","{
    IntKeyframe kfClone = mHasValue ? new IntKeyframe(getFraction(), mValue) : new IntKeyframe(getFraction());
    kfClone.setInterpolator(getInterpolator());
    kfClone.mValueWasSetOnStart = mValueWasSetOnStart;
    return kfClone;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The late implementation introduces a new line kfClone.mValueWasSetOnStart = mValueWasSetOnStart; which is considered an 'Other statement changed', so the change type is 4.","The new statement added does not alter the return type or value, nor does it change exception handling, hence there is no Compatibility Issue, and the CI type is 0."
660,<android.content.res.ColorStateList: ColorStateList withAlpha(int)>,20,21,<android.content.res.ColorStateList: ColorStateList withAlpha(int)>,<android.content.res.ColorStateList: ColorStateList withAlpha(int)>,0,"{
    int[] colors = new int[mColors.length];
    int len = colors.length;
    for (int i = 0; i < len; i++) {
        colors[i] = (mColors[i] & 0xFFFFFF) | (alpha << 24);
    }
    return new ColorStateList(mStateSpecs, colors);
}","{
    final int[] colors = new int[mColors.length];
    final int len = colors.length;
    for (int i = 0; i < len; i++) {
        colors[i] = (mColors[i] & 0xFFFFFF) | (alpha << 24);
    }
    return new ColorStateList(mStateSpecs, colors);
}",1,"/**
 * Creates a new ColorStateList that has the same states and
 * colors as this one but where each color has the specified alpha value
 * (0-255).
 */
","/**
 * Creates a new ColorStateList that has the same states and
 * colors as this one but where each color has the specified alpha value
 * (0-255).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The only modification in the code is the addition of the 'final' keyword for the 'colors' and 'len' variables. This change does not affect the behavior of the method but only makes these variables unmodifiable after their initialization.,There is no Compatibility Issue because the use of 'final' does not impact the method's return value or exception handling. The method's behavior remains identical across both versions.
662,"<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>",20,21,"<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>","<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>",0,"{
    try {
        return ActivityManagerNative.getDefault().checkUriPermission(uri, pid, uid, modeFlags);
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().checkUriPermission(ContentProvider.getUriWithoutUserId(uri), pid, uid, modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The parameter passed to the `checkUriPermission` method was changed from `uri` to `ContentProvider.getUriWithoutUserId(uri)`, and a new parameter `resolveUserId(uri)` was added to the method call, constituting a change in other statements (since the method signature of a called method is altered) and a change in the dependent API (due to the additional method call `resolveUserId`). Hence, the code change types are 4,5.","The change in the parameters of the method call `ActivityManagerNative.getDefault().checkUriPermission` could potentially lead to a different return value, because the method might behave differently with the modified and additional parameters. Therefore, a Compatibility Issue could arise due to a potential different return value, and the CI type is 1."
666,"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int,int)>",20,21,"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int,int)>","<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int,int)>",0,"{
    notifyAppWidgetViewDataChanged(new int[] { appWidgetId }, viewId);
}","{
    if (mService == null) {
        return;
    }
    notifyAppWidgetViewDataChanged(new int[] { appWidgetId }, viewId);
}",1,"/**
 * Notifies the specified collection view in the specified AppWidget instance
 * to invalidate its data.
 *
 * @param appWidgetId  The AppWidget instance to notify of view data changes.
 * @param viewId       The collection view id.
 */
","/**
 * Notifies the specified collection view in the specified AppWidget instance
 * to invalidate its data.
 *
 * @param appWidgetId  The AppWidget instance to notify of view data changes.
 * @param viewId       The collection view id.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A control dependency has been introduced with an if-check that returns directly from the function if mService is null, so the code change type is 3.","The change does not lead to a Compatibility Issue because if mService is null, the original method call to notifyAppWidgetViewDataChanged would fail to execute properly anyways, implying that the earlier implementation should've included this null check to handle the service being unavailable. Thus, the new check simply avoids an unnecessary call when the service isn't available without changing the observable behavior of the method when called under valid conditions. Therefore, there's no CI."
667,"<android.app.Activity: boolean onMenuOpened(int,Menu)>",20,21,"<android.app.Activity: boolean onMenuOpened(int,Menu)>","<android.app.Activity: boolean onMenuOpened(int,Menu)>",0,"{
    if (featureId == Window.FEATURE_ACTION_BAR) {
        initActionBar();
        if (mActionBar != null) {
            mActionBar.dispatchMenuVisibilityChanged(true);
        } else {
            Log.e(TAG, ""Tried to open action bar menu with no action bar"");
        }
    }
    return true;
}","{
    if (featureId == Window.FEATURE_ACTION_BAR) {
        initWindowDecorActionBar();
        if (mActionBar != null) {
            mActionBar.dispatchMenuVisibilityChanged(true);
        } else {
            Log.e(TAG, ""Tried to open action bar menu with no action bar"");
        }
    }
    return true;
}",1,"/**
 * {@inheritDoc}
 *
 * @return The default implementation returns true.
 */
","/**
 * {@inheritDoc}
 *
 * @return The default implementation returns true.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method name has changed from `initActionBar()` to `initWindowDecorActionBar()`, but this is the only change, and since there's no detail on what the new method does compared to the old one, it is still a change in a dependent API, so the code change type is 5.","Assuming `initWindowDecorActionBar()` is intended to replace `initActionBar()` with the same or compatible behavior, there is no indication that the change should affect the return value or exception handling of the `onMenuOpened` method. Therefore, there are no compatibility issues expected based on the information provided, and the CI type is 0."
668,<android.widget.GridView: void layoutChildren()>,20,21,<android.widget.GridView: void layoutChildren()>,<android.widget.GridView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                break;
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillSelection(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(mSelectedPosition, mSpecificTop);
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                // Move the selection relative to its old position
                sel = moveSelection(delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : 0);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int last = mItemCount - 1;
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : last);
                        sel = fillFromBottom(last, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            positionSelector(INVALID_POSITION, sel);
            mSelectedTop = sel.getTop();
        } else if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
            View child = getChildAt(mMotionPosition - mFirstPosition);
            if (child != null)
                positionSelector(mMotionPosition, child);
        } else {
            mSelectedTop = 0;
            mSelectorRect.setEmpty();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                break;
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        setSelectedPositionInt(mNextSelectedPosition);
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();
            if (focusHost != null) {
                final View focusChild = getAccessibilityFocusedChild(focusHost);
                if (focusChild != null) {
                    if (!dataChanged || focusChild.hasTransientState() || mAdapterHasStableIds) {
                        // The views won't be changing, so try to maintain
                        // focus on the current host and virtual view.
                        accessibilityFocusLayoutRestoreView = focusHost;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    }
                    // Try to maintain focus at the same position.
                    accessibilityFocusPosition = getPositionForView(focusChild);
                }
            }
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillSelection(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(mSelectedPosition, mSpecificTop);
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                // Move the selection relative to its old position
                sel = moveSelection(delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : 0);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int last = mItemCount - 1;
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : last);
                        sel = fillFromBottom(last, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            positionSelector(INVALID_POSITION, sel);
            mSelectedTop = sel.getTop();
        } else {
            final boolean inTouchMode = mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL;
            if (inTouchMode) {
                // If the user's finger is down, select the motion position.
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else if (mSelectedPosition != INVALID_POSITION) {
                // If we had previously positioned the selector somewhere,
                // put it back there. It might not match up with the data,
                // but it's transitioning out so it's not a big deal.
                final View child = getChildAt(mSelectorPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mSelectorPosition, child);
                }
            } else {
                // Otherwise, clear selection.
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
        }
        // Attempt to restore accessibility focus, if necessary.
        if (viewRootImpl != null) {
            final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (newAccessibilityFocusedView == null) {
                if (accessibilityFocusLayoutRestoreView != null && accessibilityFocusLayoutRestoreView.isAttachedToWindow()) {
                    final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
                    if (accessibilityFocusLayoutRestoreNode != null && provider != null) {
                        final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                        provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
                    } else {
                        accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
                    }
                } else if (accessibilityFocusPosition != INVALID_POSITION) {
                    // Bound the position within the visible children.
                    final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                    final View restoreView = getChildAt(position);
                    if (restoreView != null) {
                        restoreView.requestAccessibilityFocus();
                    }
                }
            }
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
669,"<android.accounts.AccountManager.BaseFutureTask.Response: void onError(int,String)>",20,21,"<android.accounts.AccountManager.BaseFutureTask.Response: void onError(int,String)>","<android.accounts.AccountManager.BaseFutureTask.Response: void onError(int,String)>",0,"{
    if (code == ERROR_CODE_CANCELED) {
        cancel(true);
        return;
    }
    setException(convertErrorToException(code, message));
}","{
    if (code == ERROR_CODE_CANCELED || code == ERROR_CODE_USER_RESTRICTED || code == ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {
        // the authenticator indicated that this request was canceled or we were
        // forbidden to fulfill; cancel now
        cancel(true);
        return;
    }
    setException(convertErrorToException(code, message));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The if condition statement has been augmented with two additional conditions (code == ERROR_CODE_USER_RESTRICTED || code == ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE), which classifies it as a control dependency change (type 3).","Despite the change in the if condition, this does not constitute a compatibility issue because it still leads to the same method behavior—calling cancel(true) and returning. In all cases where the additional conditions are true, the early version's behavior of setting an exception would have been incorrect. The late version corrects this by ensuring cancel(true) is called for more appropriate error codes, which seems to be a fix of previous incorrect behavior rather than an introduction of a compatibility issue. Therefore, the prediction is that there is no compatibility issue (type 0)."
670,"<android.provider.DocumentsContract: boolean isDocumentUri(Context,Uri)>",20,21,"<android.provider.DocumentsContract: boolean isDocumentUri(Context,Uri)>","<android.provider.DocumentsContract: boolean isDocumentUri(Context,Uri)>",0,"{
    final List<String> paths = uri.getPathSegments();
    if (paths.size() < 2) {
        return false;
    }
    if (!PATH_DOCUMENT.equals(paths.get(0))) {
        return false;
    }
    final Intent intent = new Intent(PROVIDER_INTERFACE);
    final List<ResolveInfo> infos = context.getPackageManager().queryIntentContentProviders(intent, 0);
    for (ResolveInfo info : infos) {
        if (uri.getAuthority().equals(info.providerInfo.authority)) {
            return true;
        }
    }
    return false;
}","{
    final List<String> paths = uri.getPathSegments();
    if (paths.size() == 2 && PATH_DOCUMENT.equals(paths.get(0))) {
        return isDocumentsProvider(context, uri.getAuthority());
    }
    if (paths.size() == 4 && PATH_TREE.equals(paths.get(0)) && PATH_DOCUMENT.equals(paths.get(2))) {
        return isDocumentsProvider(context, uri.getAuthority());
    }
    return false;
}",1,"/**
 * Test if the given URI represents a {@link Document} backed by a
 * {@link DocumentsProvider}.
 */
","/**
 * Test if the given URI represents a {@link Document} backed by a
 * {@link DocumentsProvider}.
 *
 * @see #buildDocumentUri(String, String)
 * @see #buildDocumentUriUsingTree(Uri, String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The method's control flow has been altered significantly. In the early implementation, the size of `paths` is checked to be less than 2 and the first path segment is checked against `PATH_DOCUMENT`. If those checks pass, it iterates over providers to check if the URI's authority matches. In the late version, the method now uses specific size checks (`paths.size() == 2` and `paths.size() == 4`) and path segment checks (`PATH_TREE.equals(paths.get(0))` and `PATH_DOCUMENT.equals(paths.get(2))`) which were not present in the early version. Then, it uses a new method `isDocumentsProvider()` to determine the result based on the authority. These changes are classified as return statement changed and control dependency changed.","The potential behaviors of the API could lead to different return values due to the changes in the control dependency that affect the return value (e.g., the checks for the size and the order of the path segments). Also, the use of a different method to determine the provider introduces potential variations in the result. This results in a Compatibility Issue due to potential different return values, type 1."
672,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFinished(PageRange[])>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFinished(PageRange[])>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFinished(PageRange[])>,0,"{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        callback = mCallback;
        clearLocked();
    }
    if (pages == null) {
        throw new IllegalArgumentException(""pages cannot be null"");
    }
    if (pages.length == 0) {
        throw new IllegalArgumentException(""pages cannot be empty"");
    }
    if (callback != null) {
        try {
            callback.onWriteFinished(pages, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onWriteFinished"", re);
        }
    }
}","{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
    }
    // If the callback is null we are destroyed.
    if (callback == null) {
        Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"");
        return;
    }
    try {
        if (pages == null) {
            throw new IllegalArgumentException(""pages cannot be null"");
        }
        if (pages.length == 0) {
            throw new IllegalArgumentException(""pages cannot be empty"");
        }
        try {
            callback.onWriteFinished(pages, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onWriteFinished"", re);
        }
    } finally {
        destroy();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The 'mDestroyed' checking logic and the subsequent 'return' statement in the synchronized block have been moved and refactored outside the block in the late version. Additionally, there's a new 'finally' block which calls destroy(). These result in changes in control dependencies and other statements, so the code change type is 3,4.","The late version of the implementation added a new 'finally' block to ensure 'destroy()' is called, but the conditions under which the method exits early or throws exceptions remain the same. Given that the method completes its core functionality (calling 'callback.onWriteFinished()') under the same preconditions as before, and that the additional 'destroy()' call at the end does not alter the return behavior or exceptions thrown, there's no Compatibility Issue; thus, CI type is 0."
674,"<android.view.GLES20Canvas: void drawPatch(NinePatch,RectF,Paint)>",20,21,<android.content.AsyncTaskLoader.LoadTask: D doInBackground(Void)>,"<android.view.GLES20Canvas: void drawPatch(NinePatch,RectF,Paint)>",0,"{
    if (DEBUG)
        Slog.v(TAG, this + "" >>> doInBackground"");
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG)
            Slog.v(TAG, this + ""  <<< doInBackground"");
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG)
            Slog.v(TAG, this + ""  <<< doInBackground (was canceled)"", ex);
        return null;
    }
}","{
    Bitmap bitmap = patch.getBitmap();
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawPatch(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, patch.mNativeChunk, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}",1,"/* Runs on a worker thread */
",,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The changes involve a complete rewrite of the implementation with no similarities to the previous version. It seems like it's reusing the signature of an unrelated method for a new purpose. However, given that these implementations appear to be entirely different and there's a risk that the correct implementation may have been mismatched with the signature during the analysis, without more context this has to be classified under 4 (Other statement changed).","Despite the complete change in the implementation, one could assume that this is an entirely different method now and should not be treated as a modification of the previous one. If that assumption is correct, it is not appropriate to compare the behaviors of the two as they are not intended to be the same API, which means there should be no Compatibility Issue. However, it's important to note that such a drastic change would typically be a clear compatibility issue, but due to the potential context error, the classification is made conservatively assuming no CI."
675,<android.content.AsyncTaskLoader.LoadTask: D doInBackground(Void)>,20,21,"<android.view.GLES20Canvas: void drawPatch(NinePatch,RectF,Paint)>",<android.content.AsyncTaskLoader.LoadTask: D doInBackground(Void)>,0,"{
    Bitmap bitmap = patch.getBitmap();
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing patches
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawPatch(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, patch.mNativeChunk, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
}","{
    if (DEBUG)
        Log.v(TAG, this + "" >>> doInBackground"");
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG)
            Log.v(TAG, this + ""  <<< doInBackground"");
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG)
            Log.v(TAG, this + ""  <<< doInBackground (was canceled)"", ex);
        return null;
    }
}",1,,"/* Runs on a worker thread */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The early and late implementations of the method are completely different, not only in the contents returned and the exception handling but also in the general logic and method calls. Therefore, the change type is 1 and 4 (Return statement changed and Other statement changed).","Considering the nature of the change, the method's behavior is inherently altered in the late version—as it is executing completely different logic and returning different data, a Compatibility Issue due to potentially different return values is present. Therefore, the CI type is 1."
679,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",20,21,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
    }
}","{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The switch statement has been augmented with additional cases (BluetoothProfile.A2DP_SINK, BluetoothProfile.AVRCP_CONTROLLER, and BluetoothProfile.HEADSET_CLIENT), and these new cases make use of new dependent APIs (BluetoothA2dpSink, BluetoothAvrcpController, BluetoothHeadsetClient), so the code change type is both 3 and 5.","With the introduction of new cases in the switch statement and the introduction of calls to new close() methods on additional classes, the behavior of the API can now change depending on the profile parameter passed. Consequently, it's possible that the method will behave differently with the same input if the profile corresponds to one of the newly added cases, thus potentially leading to a different behavior, which is a compatibility issue of type 1."
680,<android.text.TextUtils: char[] obtain(int)>,20,21,<android.text.TextUtils: char[] obtain(int)>,<android.text.TextUtils: char[] obtain(int)>,0,"{
    char[] buf;
    synchronized (sLock) {
        buf = sTemp;
        sTemp = null;
    }
    if (buf == null || buf.length < len)
        buf = new char[ArrayUtils.idealCharArraySize(len)];
    return buf;
}","{
    char[] buf;
    synchronized (sLock) {
        buf = sTemp;
        sTemp = null;
    }
    if (buf == null || buf.length < len)
        buf = ArrayUtils.newUnpaddedCharArray(len);
    return buf;
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The statement for allocating a new character array has been changed from using an ideal size with `ArrayUtils.idealCharArraySize(len)` to using an unpadded size with `ArrayUtils.newUnpaddedCharArray(len)`, and apart from that, the behavior of obtaining the array differs. This affects the allocation size of a new character array; therefore, the change types are 1 (return statement changed), 4 (other statement changed), and 5 (dependent API changed since the method `idealCharArraySize` or `newUnpaddedCharArray` may have different implementations).","Since there is a change in how the new character array is allocated and because this could potentially return arrays of different sizes between the two versions, it is classified as a compatibility issue caused by potential different return values, hence the CI type is 1."
683,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,20,21,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,0,"{
    try {
        AppWidgetProviderInfo info = sService.getAppWidgetInfo(appWidgetId, mContext.getUserId());
        if (info != null) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
            info.minResizeWidth = TypedValue.complexToDimensionPixelSize(info.minResizeWidth, mDisplayMetrics);
            info.minResizeHeight = TypedValue.complexToDimensionPixelSize(info.minResizeHeight, mDisplayMetrics);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            convertSizesToPixels(info);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
","/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The code change involves changes in a control statement (the addition of ""if (mService == null)""), changes in exceptions or return statements since a new return null is introduced when mService is null. Additionally, there is a dependent API change because the parameters for mService.getAppWidgetInfo have changed (the late version uses mPackageName instead of mContext.getUserId()) and a separate conversion method convertSizesToPixels(info) is used instead of individual calls to TypedValue.complexToDimensionPixelSize. So the code change types are 1,3,4,5.","- The early version does not have a null check on the service object which could potentially lead to a NullPointerException, while the late version returns null if the service object is not initialized. "
684,<android.app.WallpaperManager: Intent getCropAndSetWallpaperIntent(Uri)>,20,21,<android.app.WallpaperManager: Intent getCropAndSetWallpaperIntent(Uri)>,<android.app.WallpaperManager: Intent getCropAndSetWallpaperIntent(Uri)>,0,"{
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException(""Image URI must be of the "" + ContentResolver.SCHEME_CONTENT + "" scheme type"");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    cropAndSetWallpaperIntent.setPackage(""com.android.wallpapercropper"");
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException(""Cannot use passed URI to set wallpaper; "" + ""check that the type returned by ContentProvider matches image/*"");
}","{
    if (imageUri == null) {
        throw new IllegalArgumentException(""Image URI must not be null"");
    }
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException(""Image URI must be of the "" + ContentResolver.SCHEME_CONTENT + "" scheme type"");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    cropAndSetWallpaperIntent.setPackage(""com.android.wallpapercropper"");
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException(""Cannot use passed URI to set wallpaper; "" + ""check that the type returned by ContentProvider matches image/*"");
}",1,"/**
 * Gets an Intent that will launch an activity that crops the given
 * image and sets the device's wallpaper. If there is a default HOME activity
 * that supports cropping wallpapers, it will be preferred as the default.
 * Use this method instead of directly creating a {@link #ACTION_CROP_AND_SET_WALLPAPER}
 * intent.
 *
 * @param imageUri The image URI that will be set in the intent. The must be a content
 * URI and its provider must resolve its type to ""image/*""
 *
 * @throws IllegalArgumentException if the URI is not a content URI or its MIME type is
 * not ""image/*""
 */
","/**
 * Gets an Intent that will launch an activity that crops the given
 * image and sets the device's wallpaper. If there is a default HOME activity
 * that supports cropping wallpapers, it will be preferred as the default.
 * Use this method instead of directly creating a {@link #ACTION_CROP_AND_SET_WALLPAPER}
 * intent.
 *
 * @param imageUri The image URI that will be set in the intent. The must be a content
 * URI and its provider must resolve its type to ""image/*""
 *
 * @throws IllegalArgumentException if the URI is not a content URI or its MIME type is
 * not ""image/*""
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","An additional exception check for null input has been added at the beginning (throw new IllegalArgumentException(""Image URI must not be null"")), which modifies exception handling logic. Therefore, the code change type is 2 for the addition of a new exception, and type 3 for the control dependency change (additional 'if' condition).","The new exception check can lead to a new behavior because it now throws an IllegalArgumentException when the imageUri is null. This was not previously checked in the early version. Therefore, the CI type is 1 for the potential return value change (by not proceeding to the later part of the method and not returning an Intent when the URI is null), and 2 for the potential different exception handling with the newly introduced IllegalArgumentException for null URIs."
685,<android.view.View: boolean fitSystemWindows(Rect)>,20,21,<android.view.View: boolean fitSystemWindows(Rect)>,<android.view.View: boolean fitSystemWindows(Rect)>,0,"{
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mUserPaddingStart = UNDEFINED_PADDING;
        mUserPaddingEnd = UNDEFINED_PADDING;
        Rect localInsets = sThreadLocal.get();
        if (localInsets == null) {
            localInsets = new Rect();
            sThreadLocal.set(localInsets);
        }
        boolean res = computeFitSystemWindows(insets, localInsets);
        mUserPaddingLeftInitial = localInsets.left;
        mUserPaddingRightInitial = localInsets.right;
        internalSetPadding(localInsets.left, localInsets.top, localInsets.right, localInsets.bottom);
        return res;
    }
    return false;
}","{
    if ((mPrivateFlags3 & PFLAG3_APPLYING_INSETS) == 0) {
        if (insets == null) {
            // so return false.
            return false;
        }
        // apply insets path and take things from there.
        try {
            mPrivateFlags3 |= PFLAG3_FITTING_SYSTEM_WINDOWS;
            return dispatchApplyWindowInsets(new WindowInsets(insets)).isConsumed();
        } finally {
            mPrivateFlags3 &= ~PFLAG3_FITTING_SYSTEM_WINDOWS;
        }
    } else {
        // Perform the standard fallback behavior.
        return fitSystemWindowsInt(insets);
    }
}",1,"/**
 * Called by the view hierarchy when the content insets for a window have
 * changed, to allow it to adjust its content to fit within those windows.
 * The content insets tell you the space that the status bar, input method,
 * and other system windows infringe on the application's window.
 *
 * <p>You do not normally need to deal with this function, since the default
 * window decoration given to applications takes care of applying it to the
 * content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
 * or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,
 * and your content can be placed under those system elements.  You can then
 * use this method within your view hierarchy if you have parts of your UI
 * which you would like to ensure are not being covered.
 *
 * <p>The default implementation of this method simply applies the content
 * insets to the view's padding, consuming that content (modifying the
 * insets to be 0), and returning true.  This behavior is off by default, but can
 * be enabled through {@link #setFitsSystemWindows(boolean)}.
 *
 * <p>This function's traversal down the hierarchy is depth-first.  The same content
 * insets object is propagated down the hierarchy, so any changes made to it will
 * be seen by all following views (including potentially ones above in
 * the hierarchy since this is a depth-first traversal).  The first view
 * that returns true will abort the entire traversal.
 *
 * <p>The default implementation works well for a situation where it is
 * used with a container that covers the entire window, allowing it to
 * apply the appropriate insets to its content on all edges.  If you need
 * a more complicated layout (such as two different views fitting system
 * windows, one on the top of the window, and one on the bottom),
 * you can override the method and handle the insets however you would like.
 * Note that the insets provided by the framework are always relative to the
 * far edges of the window, not accounting for the location of the called view
 * within that window.  (In fact when this method is called you do not yet know
 * where the layout will place the view, as it is done before layout happens.)
 *
 * <p>Note: unlike many View methods, there is no dispatch phase to this
 * call.  If you are overriding it in a ViewGroup and want to allow the
 * call to continue to your children, you must be sure to call the super
 * implementation.
 *
 * <p>Here is a sample layout that makes use of fitting system windows
 * to have controls for a video view placed inside of the window decorations
 * that it hides and shows.  This can be used with code like the second
 * sample (video player) shown in {@link #setSystemUiVisibility(int)}.
 *
 * {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 *
 * @param insets Current content insets of the window.  Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify
 * the insets or else you and Android will be unhappy.
 *
 * @return {@code true} if this view applied the insets and it should not
 * continue propagating further down the hierarchy, {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 */
","/**
 * Called by the view hierarchy when the content insets for a window have
 * changed, to allow it to adjust its content to fit within those windows.
 * The content insets tell you the space that the status bar, input method,
 * and other system windows infringe on the application's window.
 *
 * <p>You do not normally need to deal with this function, since the default
 * window decoration given to applications takes care of applying it to the
 * content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
 * or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,
 * and your content can be placed under those system elements.  You can then
 * use this method within your view hierarchy if you have parts of your UI
 * which you would like to ensure are not being covered.
 *
 * <p>The default implementation of this method simply applies the content
 * insets to the view's padding, consuming that content (modifying the
 * insets to be 0), and returning true.  This behavior is off by default, but can
 * be enabled through {@link #setFitsSystemWindows(boolean)}.
 *
 * <p>This function's traversal down the hierarchy is depth-first.  The same content
 * insets object is propagated down the hierarchy, so any changes made to it will
 * be seen by all following views (including potentially ones above in
 * the hierarchy since this is a depth-first traversal).  The first view
 * that returns true will abort the entire traversal.
 *
 * <p>The default implementation works well for a situation where it is
 * used with a container that covers the entire window, allowing it to
 * apply the appropriate insets to its content on all edges.  If you need
 * a more complicated layout (such as two different views fitting system
 * windows, one on the top of the window, and one on the bottom),
 * you can override the method and handle the insets however you would like.
 * Note that the insets provided by the framework are always relative to the
 * far edges of the window, not accounting for the location of the called view
 * within that window.  (In fact when this method is called you do not yet know
 * where the layout will place the view, as it is done before layout happens.)
 *
 * <p>Note: unlike many View methods, there is no dispatch phase to this
 * call.  If you are overriding it in a ViewGroup and want to allow the
 * call to continue to your children, you must be sure to call the super
 * implementation.
 *
 * <p>Here is a sample layout that makes use of fitting system windows
 * to have controls for a video view placed inside of the window decorations
 * that it hides and shows.  This can be used with code like the second
 * sample (video player) shown in {@link #setSystemUiVisibility(int)}.
 *
 * {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 *
 * @param insets Current content insets of the window.  Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify
 * the insets or else you and Android will be unhappy.
 *
 * @return {@code true} if this view applied the insets and it should not
 * continue propagating further down the hierarchy, {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 *
 * @deprecated As of API 20 use {@link #dispatchApplyWindowInsets(WindowInsets)} to apply
 * insets to views. Views should override {@link #onApplyWindowInsets(WindowInsets)} or use
 * {@link #setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)}
 * to implement handling their own insets.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The whole method body has changed, including adjustments in control flow, removal of certain statements, modifications in return expressions, and dependent API changes (for example `computeFitSystemWindows` is not used in the late version). There is a new API `dispatchApplyWindowInsets` and a new control flow in the late version that calls `fitSystemWindowsInt`. The change type is, therefore, 1,3,4,5 due to structural changes, altered return statements, and changes in dependent APIs.","As the initial 'if' condition and return values have changed, there's a CI due to different return values or types. Also, there's a change in exception handling (in the new version, exceptions might be thrown by `dispatchApplyWindowInsets`, followed by a `finally` block that isn't present in the early version), so the CI type is 1,2."
687,<android.text.style.ImageSpan: Drawable getDrawable()>,20,21,<android.text.style.ImageSpan: Drawable getDrawable()>,<android.text.style.ImageSpan: Drawable getDrawable()>,0,"{
    Drawable drawable = null;
    if (mDrawable != null) {
        drawable = mDrawable;
    } else if (mContentUri != null) {
        Bitmap bitmap = null;
        try {
            InputStream is = mContext.getContentResolver().openInputStream(mContentUri);
            bitmap = BitmapFactory.decodeStream(is);
            drawable = new BitmapDrawable(mContext.getResources(), bitmap);
            drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
            is.close();
        } catch (Exception e) {
            Log.e(""sms"", ""Failed to loaded content "" + mContentUri, e);
        }
    } else {
        try {
            drawable = mContext.getResources().getDrawable(mResourceId);
            drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
        } catch (Exception e) {
            Log.e(""sms"", ""Unable to find resource: "" + mResourceId);
        }
    }
    return drawable;
}","{
    Drawable drawable = null;
    if (mDrawable != null) {
        drawable = mDrawable;
    } else if (mContentUri != null) {
        Bitmap bitmap = null;
        try {
            InputStream is = mContext.getContentResolver().openInputStream(mContentUri);
            bitmap = BitmapFactory.decodeStream(is);
            drawable = new BitmapDrawable(mContext.getResources(), bitmap);
            drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
            is.close();
        } catch (Exception e) {
            Log.e(""sms"", ""Failed to loaded content "" + mContentUri, e);
        }
    } else {
        try {
            drawable = mContext.getDrawable(mResourceId);
            drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
        } catch (Exception e) {
            Log.e(""sms"", ""Unable to find resource: "" + mResourceId);
        }
    }
    return drawable;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,The statement to acquire a drawable from a resource id has changed from mContext.getResources().getDrawable(mResourceId) in the early version to mContext.getDrawable(mResourceId) in the late version. This is considered an Other statement change (type 4) as well as a Dependent API changed (type 5) since the method getDrawable() on mContext is used directly instead.,"The change in the method used to acquire a drawable from a resource ID could result in a different drawable being returned if the implementations of getResources().getDrawable(mResourceId) and mContext.getDrawable(mResourceId) behave differently, which could lead to Compatibility Issue because the API potentially returns different value or type (type 1)."
689,<android.widget.TimePicker: void setCurrentMinute(Integer)>,20,21,<android.widget.TimePicker: void setCurrentMinute(Integer)>,<android.widget.TimePicker: void setCurrentMinute(Integer)>,0,"{
    if (currentMinute == getCurrentMinute()) {
        return;
    }
    mMinuteSpinner.setValue(currentMinute);
    onTimeChanged();
}","{
    mDelegate.setCurrentMinute(currentMinute);
}",1,"/**
 * Set the current minute (0-59).
 */
","/**
 * Set the current minute (0-59).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method implementation has changed completely, removing the conditional check and the direct calls to mMinuteSpinner.setValue(currentMinute) and onTimeChanged(). It is replaced with a call to mDelegate.setCurrentMinute(currentMinute), thus this indicates a change in return statement, other statements, and a dependent API change; so the change type is 1,4,5.","Since the original implementation had a conditional return based on a comparison between the current and new value, and this has been removed, it could potentially change the behavior of the method by having it always set the current minute regardless of its previous state. Additionally, the removal of direct calls to UI update methods and delegation to another method can lead to different runtime behaviors. Therefore, the CI is of type 1."
690,<android.content.res.TypedArray: Resources getResources()>,20,21,<android.content.res.TypedArray: Resources getResources()>,<android.content.res.TypedArray: Resources getResources()>,0,"{
    return mResources;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return mResources;
}",1,"/**
 * Return the Resources object this array was loaded from.
 */
","/**
 * Return the Resources object this array was loaded from.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"There is a new control dependency added with an if statement checking for 'mRecycled' and throwing a RuntimeException if true. So, the change types are 2 (since there is a new exception that may be thrown) and 3 (because of the control dependency change introduced by the new if statement).","There is a potential Compatibility Issue caused by the new exception handling, because after the change, the method can throw a new RuntimeException if 'mRecycled' is true, an exception which wouldn't have been thrown in the early version. This could cause the late version of the API to throw a different exception under some circumstances. Thus, the CI type is 2."
691,<android.content.Intent: Intent getIntentOld(String)>,20,21,<android.content.Intent: Intent getIntentOld(String)>,<android.content.Intent: Intent getIntentOld(String)>,0,"{
    Intent intent;
    int i = uri.lastIndexOf('#');
    if (i >= 0) {
        String action = null;
        final int intentFragmentStart = i;
        boolean isIntentFragment = false;
        i++;
        if (uri.regionMatches(i, ""action("", 0, 7)) {
            isIntentFragment = true;
            i += 7;
            int j = uri.indexOf(')', i);
            action = uri.substring(i, j);
            i = j + 1;
        }
        intent = new Intent(action);
        if (uri.regionMatches(i, ""categories("", 0, 11)) {
            isIntentFragment = true;
            i += 11;
            int j = uri.indexOf(')', i);
            while (i < j) {
                int sep = uri.indexOf('!', i);
                if (sep < 0)
                    sep = j;
                if (i < sep) {
                    intent.addCategory(uri.substring(i, sep));
                }
                i = sep + 1;
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""type("", 0, 5)) {
            isIntentFragment = true;
            i += 5;
            int j = uri.indexOf(')', i);
            intent.mType = uri.substring(i, j);
            i = j + 1;
        }
        if (uri.regionMatches(i, ""launchFlags("", 0, 12)) {
            isIntentFragment = true;
            i += 12;
            int j = uri.indexOf(')', i);
            intent.mFlags = Integer.decode(uri.substring(i, j)).intValue();
            i = j + 1;
        }
        if (uri.regionMatches(i, ""component("", 0, 10)) {
            isIntentFragment = true;
            i += 10;
            int j = uri.indexOf(')', i);
            int sep = uri.indexOf('!', i);
            if (sep >= 0 && sep < j) {
                String pkg = uri.substring(i, sep);
                String cls = uri.substring(sep + 1, j);
                intent.mComponent = new ComponentName(pkg, cls);
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""extras("", 0, 7)) {
            isIntentFragment = true;
            i += 7;
            final int closeParen = uri.indexOf(')', i);
            if (closeParen == -1)
                throw new URISyntaxException(uri, ""EXTRA missing trailing ')'"", i);
            while (i < closeParen) {
                // fetch the key value
                int j = uri.indexOf('=', i);
                if (j <= i + 1 || i >= closeParen) {
                    throw new URISyntaxException(uri, ""EXTRA missing '='"", i);
                }
                char type = uri.charAt(i);
                i++;
                String key = uri.substring(i, j);
                i = j + 1;
                // get type-value
                j = uri.indexOf('!', i);
                if (j == -1 || j >= closeParen)
                    j = closeParen;
                if (i >= j)
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                String value = uri.substring(i, j);
                i = j;
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                // add item to bundle
                try {
                    switch(type) {
                        case 'S':
                            intent.mExtras.putString(key, Uri.decode(value));
                            break;
                        case 'B':
                            intent.mExtras.putBoolean(key, Boolean.parseBoolean(value));
                            break;
                        case 'b':
                            intent.mExtras.putByte(key, Byte.parseByte(value));
                            break;
                        case 'c':
                            intent.mExtras.putChar(key, Uri.decode(value).charAt(0));
                            break;
                        case 'd':
                            intent.mExtras.putDouble(key, Double.parseDouble(value));
                            break;
                        case 'f':
                            intent.mExtras.putFloat(key, Float.parseFloat(value));
                            break;
                        case 'i':
                            intent.mExtras.putInt(key, Integer.parseInt(value));
                            break;
                        case 'l':
                            intent.mExtras.putLong(key, Long.parseLong(value));
                            break;
                        case 's':
                            intent.mExtras.putShort(key, Short.parseShort(value));
                            break;
                        default:
                            throw new URISyntaxException(uri, ""EXTRA has unknown type"", i);
                    }
                } catch (NumberFormatException e) {
                    throw new URISyntaxException(uri, ""EXTRA value can't be parsed"", i);
                }
                char ch = uri.charAt(i);
                if (ch == ')')
                    break;
                if (ch != '!')
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                i++;
            }
        }
        if (isIntentFragment) {
            intent.mData = Uri.parse(uri.substring(0, intentFragmentStart));
        } else {
            intent.mData = Uri.parse(uri);
        }
        if (intent.mAction == null) {
            // By default, if no action is specified, then use VIEW.
            intent.mAction = ACTION_VIEW;
        }
    } else {
        intent = new Intent(ACTION_VIEW, Uri.parse(uri));
    }
    return intent;
}","{
    Intent intent;
    int i = uri.lastIndexOf('#');
    if (i >= 0) {
        String action = null;
        final int intentFragmentStart = i;
        boolean isIntentFragment = false;
        i++;
        if (uri.regionMatches(i, ""action("", 0, 7)) {
            isIntentFragment = true;
            i += 7;
            int j = uri.indexOf(')', i);
            action = uri.substring(i, j);
            i = j + 1;
        }
        intent = new Intent(action);
        if (uri.regionMatches(i, ""categories("", 0, 11)) {
            isIntentFragment = true;
            i += 11;
            int j = uri.indexOf(')', i);
            while (i < j) {
                int sep = uri.indexOf('!', i);
                if (sep < 0 || sep > j)
                    sep = j;
                if (i < sep) {
                    intent.addCategory(uri.substring(i, sep));
                }
                i = sep + 1;
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""type("", 0, 5)) {
            isIntentFragment = true;
            i += 5;
            int j = uri.indexOf(')', i);
            intent.mType = uri.substring(i, j);
            i = j + 1;
        }
        if (uri.regionMatches(i, ""launchFlags("", 0, 12)) {
            isIntentFragment = true;
            i += 12;
            int j = uri.indexOf(')', i);
            intent.mFlags = Integer.decode(uri.substring(i, j)).intValue();
            i = j + 1;
        }
        if (uri.regionMatches(i, ""component("", 0, 10)) {
            isIntentFragment = true;
            i += 10;
            int j = uri.indexOf(')', i);
            int sep = uri.indexOf('!', i);
            if (sep >= 0 && sep < j) {
                String pkg = uri.substring(i, sep);
                String cls = uri.substring(sep + 1, j);
                intent.mComponent = new ComponentName(pkg, cls);
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""extras("", 0, 7)) {
            isIntentFragment = true;
            i += 7;
            final int closeParen = uri.indexOf(')', i);
            if (closeParen == -1)
                throw new URISyntaxException(uri, ""EXTRA missing trailing ')'"", i);
            while (i < closeParen) {
                // fetch the key value
                int j = uri.indexOf('=', i);
                if (j <= i + 1 || i >= closeParen) {
                    throw new URISyntaxException(uri, ""EXTRA missing '='"", i);
                }
                char type = uri.charAt(i);
                i++;
                String key = uri.substring(i, j);
                i = j + 1;
                // get type-value
                j = uri.indexOf('!', i);
                if (j == -1 || j >= closeParen)
                    j = closeParen;
                if (i >= j)
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                String value = uri.substring(i, j);
                i = j;
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                // add item to bundle
                try {
                    switch(type) {
                        case 'S':
                            intent.mExtras.putString(key, Uri.decode(value));
                            break;
                        case 'B':
                            intent.mExtras.putBoolean(key, Boolean.parseBoolean(value));
                            break;
                        case 'b':
                            intent.mExtras.putByte(key, Byte.parseByte(value));
                            break;
                        case 'c':
                            intent.mExtras.putChar(key, Uri.decode(value).charAt(0));
                            break;
                        case 'd':
                            intent.mExtras.putDouble(key, Double.parseDouble(value));
                            break;
                        case 'f':
                            intent.mExtras.putFloat(key, Float.parseFloat(value));
                            break;
                        case 'i':
                            intent.mExtras.putInt(key, Integer.parseInt(value));
                            break;
                        case 'l':
                            intent.mExtras.putLong(key, Long.parseLong(value));
                            break;
                        case 's':
                            intent.mExtras.putShort(key, Short.parseShort(value));
                            break;
                        default:
                            throw new URISyntaxException(uri, ""EXTRA has unknown type"", i);
                    }
                } catch (NumberFormatException e) {
                    throw new URISyntaxException(uri, ""EXTRA value can't be parsed"", i);
                }
                char ch = uri.charAt(i);
                if (ch == ')')
                    break;
                if (ch != '!')
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                i++;
            }
        }
        if (isIntentFragment) {
            intent.mData = Uri.parse(uri.substring(0, intentFragmentStart));
        } else {
            intent.mData = Uri.parse(uri);
        }
        if (intent.mAction == null) {
            // By default, if no action is specified, then use VIEW.
            intent.mAction = ACTION_VIEW;
        }
    } else {
        intent = new Intent(ACTION_VIEW, Uri.parse(uri));
    }
    return intent;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
692,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,20,21,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(TAG, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                return FINISH_NOT_HANDLED;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}","{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(TAG, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                // The IME could not handle it, so skip along to the next InputStage
                return FORWARD;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement for one of the conditional paths has changed. Previously, if `result` was `InputMethodManager.DISPATCH_NOT_HANDLED`, it would return `FINISH_NOT_HANDLED`, but in the late version it now returns `FORWARD`.","This change in the return value for one of the branches of the conditional statement could cause the API to behave differently when the `InputMethodManager.DISPATCH_NOT_HANDLED` event occurs. Therefore, this represents a compatibility issue of type 1, indicating a potential difference in return values."
694,"<android.text.Selection: boolean moveDown(Spannable,Layout)>",20,21,"<android.text.Selection: boolean moveDown(Spannable,Layout)>","<android.text.Selection: boolean moveDown(Spannable,Layout)>",0,"{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, max);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line < layout.getLineCount() - 1) {
            int move;
            if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line + 1)) {
                float h = layout.getPrimaryHorizontal(end);
                move = layout.getOffsetForHorizontal(line + 1, h);
            } else {
                move = layout.getLineStart(line + 1);
            }
            setSelection(text, move);
            return true;
        }
    }
    return false;
}","{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, max);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line < layout.getLineCount() - 1) {
            int move;
            if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line + 1)) {
                float h = layout.getPrimaryHorizontal(end);
                move = layout.getOffsetForHorizontal(line + 1, h);
            } else {
                move = layout.getLineStart(line + 1);
            }
            setSelection(text, move);
            return true;
        } else if (end != text.length()) {
            setSelection(text, text.length());
            return true;
        }
    }
    return false;
}",1,"/**
 * Move the cursor to the buffer offset physically below the current
 * offset, or return false if the cursor is already on the bottom line.
 */
","/**
 * Move the cursor to the buffer offset physically below the current
 * offset, to the end of the buffer if it is on the bottom line but
 * not at the end, or return false if the cursor is already at the
 * end of the buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The addition of an else-if block after the existing if block inside the else statement constitutes a control dependency change. Moreover, a new return statement is introduced within that else-if block, resulting in a return statement change. Therefore, the code change types are 1 and 3.","With the newly introduced else-if block, there is a potential for the method to return a different value when the condition (end != text.length()) is met at the end of the text, which did not happen in the earlier version. This implies that the method could behave differently for cases where 'end' is not equal to the text length, leading to the possibility of different return values. Consequently, the Compatibility Issue is of type 1."
698,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,20,21,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (DBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The introduction of the 'synchronized' block and check (if (mDeviceBusy) return false;) and changing the debug log flag from DBG to VDBG indicates changes types 3 and 4. In addition, a new assignment (mDeviceBusy = false;) is made in the exception handling, which is an other statement changed (type 4).","The newly introduced synchronization check on 'mDeviceBusy' and the modification in exception handling where 'mDeviceBusy' is set to false when a RemoteException occurs, do not modify the nature of the return values or the exception being thrown. RemoteException is still caught and handled with the same effect (returning false) and the return true statement remains unaffected if all checks pass. Thus, there is no compatibility issue identified (type 0)."
699,<android.view.textservice.TextInfo: int getSequence()>,20,21,<android.view.textservice.TextInfo: int getSequence()>,<android.view.textservice.TextInfo: int getSequence()>,0,"{
    return mSequence;
}","{
    return mSequenceNumber;
}",1,"/**
 * @return the sequence of TextInfo
 */
","/**
 * @return the sequence of TextInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The internal variable from which the return value is fetched has changed: from mSequence to mSequenceNumber. This means the field accessed by the method has been modified, indicating a code change type of 4.","Changing the field from which the method returns its value could lead to the API potentially returning a different value. Thus, the CI type is 1."
700,"<android.transition.Transition: Transition excludeTarget(int,boolean)>",20,21,"<android.transition.Transition: Transition excludeTarget(int,boolean)>","<android.transition.Transition: Transition excludeTarget(int,boolean)>",0,"{
    mTargetIdExcludes = excludeId(mTargetIdExcludes, targetId, exclude);
    return this;
}","{
    if (targetId >= 0) {
        mTargetIdExcludes = excludeObject(mTargetIdExcludes, targetId, exclude);
    }
    return this;
}",1,"/**
 * Whether to add the given id to the list of target ids to exclude from this
 * transition. The <code>exclude</code> parameter specifies whether the target
 * should be added to or removed from the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeChildren(int, boolean)
 * @see #excludeTarget(View, boolean)
 * @see #excludeTarget(Class, boolean)
 *
 * @param targetId The id of a target to ignore when running this transition.
 * @param exclude Whether to add the target to or remove the target from the
 * current list of excluded targets.
 * @return This transition object.
 */
","/**
 * Whether to add the given id to the list of target ids to exclude from this
 * transition. The <code>exclude</code> parameter specifies whether the target
 * should be added to or removed from the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeChildren(int, boolean)
 * @see #excludeTarget(View, boolean)
 * @see #excludeTarget(Class, boolean)
 *
 * @param targetId The id of a target to ignore when running this transition.
 * @param exclude Whether to add the target to or remove the target from the
 * current list of excluded targets.
 * @return This transition object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a control dependency change with the addition of a new 'if' statement and an alteration within the method body, which is the replacement of excludeId() with excludeObject(), so the code change types are 3 and 4.","Despite the changes, there is no Compatibility Issue caused by potential different return values or types as the method still returns 'this', meaning the return type and value remains the same across versions. The method does not throw any exceptions in either version, so there is no Compatibility Issue caused by potential different exception handlings. Therefore, the CI type is 0."
701,<android.view.ViewRootImpl.SyntheticInputStage: int onProcess(QueuedInputEvent)>,20,21,<android.view.ViewRootImpl.SyntheticInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.SyntheticInputStage: int onProcess(QueuedInputEvent)>,0,"{
    q.mFlags |= QueuedInputEvent.FLAG_RESYNTHESIZED;
    if (q.mEvent instanceof MotionEvent) {
        final MotionEvent event = (MotionEvent) q.mEvent;
        final int source = event.getSource();
        if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            mTrackball.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
            mJoystick.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_TOUCH_NAVIGATION) == InputDevice.SOURCE_TOUCH_NAVIGATION) {
            mTouchNavigation.process(event);
            return FINISH_HANDLED;
        }
    }
    return FORWARD;
}","{
    q.mFlags |= QueuedInputEvent.FLAG_RESYNTHESIZED;
    if (q.mEvent instanceof MotionEvent) {
        final MotionEvent event = (MotionEvent) q.mEvent;
        final int source = event.getSource();
        if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            mTrackball.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
            mJoystick.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_TOUCH_NAVIGATION) == InputDevice.SOURCE_TOUCH_NAVIGATION) {
            mTouchNavigation.process(event);
            return FINISH_HANDLED;
        }
    } else if ((q.mFlags & QueuedInputEvent.FLAG_UNHANDLED) != 0) {
        mKeyboard.process((KeyEvent) q.mEvent);
        return FINISH_HANDLED;
    }
    return FORWARD;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control structure has been extended to include a new 'else if' condition that processes keyboard events, so the change type is 3.","There is no difference in the behavior for inputs that were already handled by the previous version of the method. The new 'else if' block only affects 'KeyEvent' objects marked with 'FLAG_UNHANDLED', which were not handled explicitly in the early version. Therefore, there's no compatibility issue as the change does not impact the behavior for cases that were previously handled by the method."
703,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,20,21,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    int action = ev.getAction();
    View v;
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded(y)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}","{
    final int actionMasked = ev.getActionMasked();
    View v;
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (mIsDetaching || !isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    if (mFastScroll != null && mFastScroll.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                mNestedYOffset = 0;
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded((int) ev.getX(pointerIndex), y, null)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                stopNestedScroll();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
708,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",20,21,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>","<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",0,"{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mActivity = mActivity;
                f.mParentFragment = mParent;
                f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mActivity.mFragments;
                f.mCalled = false;
                f.onAttach(mActivity);
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                if (f.mParentFragment == null) {
                    mActivity.onAttachFragment(f);
                }
                if (!f.mRetaining) {
                    f.performCreate(f.mSavedFragmentState);
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mContainer.findViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + f.getResources().getResourceName(f.mContainerId) + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mResumed = true;
                    f.performResume();
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (!mActivity.isFinishing() && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mActivity = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    f.mState = newState;
}","{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mActivity = mActivity;
                f.mParentFragment = mParent;
                f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mActivity.mFragments;
                f.mCalled = false;
                f.onAttach(mActivity);
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                if (f.mParentFragment == null) {
                    mActivity.onAttachFragment(f);
                }
                if (!f.mRetaining) {
                    f.performCreate(f.mSavedFragmentState);
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mContainer.findViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + f.getResources().getResourceName(f.mContainerId) + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mResumed = true;
                    f.performResume();
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (!mActivity.isFinishing() && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mActivity = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                                f.mChildFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    f.mState = newState;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
711,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>",20,21,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>","<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>",0,"{
    try {
        RemoteViewsAdapter adapter;
        final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
        if ((adapter = mAdapter.get()) != null) {
            checkInteractAcrossUsersPermission(context, adapter.mUserId);
            mgr.unbindRemoteViewsService(appWidgetId, intent, new UserHandle(adapter.mUserId));
        } else {
            Slog.w(TAG, ""unbind: adapter was null"");
        }
        mIsConnecting = false;
    } catch (Exception e) {
        Log.e(""RemoteViewsAdapterServiceConnection"", ""unbind(): "" + e.getMessage());
        mIsConnecting = false;
        mIsConnected = false;
    }
}","{
    try {
        RemoteViewsAdapter adapter;
        final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
        if ((adapter = mAdapter.get()) != null) {
            mgr.unbindRemoteViewsService(context.getOpPackageName(), appWidgetId, intent);
        } else {
            Slog.w(TAG, ""unbind: adapter was null"");
        }
        mIsConnecting = false;
    } catch (Exception e) {
        Log.e(""RemoteViewsAdapterServiceConnection"", ""unbind(): "" + e.getMessage());
        mIsConnecting = false;
        mIsConnected = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The call to mgr.unbindRemoteViewsService has changed by removing one parameter and changing the first parameter. The late version does not use checkInteractAcrossUsersPermission or new UserHandle(adapter.mUserId). Instead, it uses context.getOpPackageName(), reflecting a change in the dependent API. Therefore, the code change types are 4 and 5.","There is no compatibility issue, because although the method signature and the dependent API invocation have changed, the change in invocation does not have an impact on the behavior in the context of this method's execution that would lead to a different return value or change in exceptions thrown by this method. Thus, the CI type is 0."
712,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,20,21,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,0,"{
    if (mInputMethodSession == null) {
        // The session has been finished.
        return;
    }
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    if (mInputMethodSession == null) {
        // for cases below.
        switch(msg.what) {
            case DO_UPDATE_SELECTION:
            case DO_APP_PRIVATE_COMMAND:
                {
                    SomeArgs args = (SomeArgs) msg.obj;
                    args.recycle();
                }
        }
        return;
    }
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_UPDATE_CURSOR_ANCHOR_INFO:
            {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The late implementation has introduced some new control structure (additional 'switch' statement inside the if condition) and added handling for DO_UPDATE_CURSOR_ANCHOR_INFO. Additionally, it recycles SomeArgs for cases like DO_UPDATE_SELECTION and DO_APP_PRIVATE_COMMAND before returning in the mInputMethodSession == null check, which wasn't there in the early version. So, the code change type is 1 (due to the additional handling for a message case), 3 (control dependency change due to additional switch case), and 4 (new statements were introduced for recycling objects).","The new switch-case block inside the if condition that checks for mInputMethodSession being null introduces a behavior where some args would be recycled even if mInputMethodSession is null; before, there was a simple return. This could lead to a different return value as the function now does more than it used to in such a situation. In the late version, messages of type DO_UPDATE_CURSOR_ANCHOR_INFO will now cause a new method to be called on mInputMethodSession that was not present in the early version. This change can lead to both a different return value or type (CI type 1) and could also potentially introduce new exceptions to be thrown if there are issues in the execution of the newly added method call (CI type 2)."
713,<android.text.format.Time: boolean parse(String)>,20,21,<android.text.format.Time: boolean parse(String)>,<android.text.format.Time: boolean parse(String)>,0,"{
    if (s == null) {
        throw new NullPointerException(""time string is null"");
    }
    if (nativeParse(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}","{
    if (s == null) {
        throw new NullPointerException(""time string is null"");
    }
    if (parseInternal(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}",1,"/**
 * Parses a date-time string in either the RFC 2445 format or an abbreviated
 * format that does not include the ""time"" field.  For example, all of the
 * following strings are valid:
 *
 * <ul>
 * <li>""20081013T160000Z""</li>
 * <li>""20081013T160000""</li>
 * <li>""20081013""</li>
 * </ul>
 *
 * Returns whether or not the time is in UTC (ends with Z).  If the string
 * ends with ""Z"" then the timezone is set to UTC.  If the date-time string
 * included only a date and no time field, then the <code>allDay</code>
 * field of this Time class is set to true and the <code>hour</code>,
 * <code>minute</code>, and <code>second</code> fields are set to zero;
 * otherwise (a time field was included in the date-time string)
 * <code>allDay</code> is set to false. The fields <code>weekDay</code>,
 * <code>yearDay</code>, and <code>gmtoff</code> are always set to zero,
 * and the field <code>isDst</code> is set to -1 (unknown).  To set those
 * fields, call {@link #normalize(boolean)} after parsing.
 *
 * To parse a date-time string and convert it to UTC milliseconds, do
 * something like this:
 *
 * <pre>
 * Time time = new Time();
 * String date = ""20081013T160000Z"";
 * time.parse(date);
 * long millis = time.normalize(false);
 * </pre>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */
","/**
 * Parses a date-time string in either the RFC 2445 format or an abbreviated
 * format that does not include the ""time"" field.  For example, all of the
 * following strings are valid:
 *
 * <ul>
 * <li>""20081013T160000Z""</li>
 * <li>""20081013T160000""</li>
 * <li>""20081013""</li>
 * </ul>
 *
 * Returns whether or not the time is in UTC (ends with Z).  If the string
 * ends with ""Z"" then the timezone is set to UTC.  If the date-time string
 * included only a date and no time field, then the <code>allDay</code>
 * field of this Time class is set to true and the <code>hour</code>,
 * <code>minute</code>, and <code>second</code> fields are set to zero;
 * otherwise (a time field was included in the date-time string)
 * <code>allDay</code> is set to false. The fields <code>weekDay</code>,
 * <code>yearDay</code>, and <code>gmtoff</code> are always set to zero,
 * and the field <code>isDst</code> is set to -1 (unknown).  To set those
 * fields, call {@link #normalize(boolean)} after parsing.
 *
 * To parse a date-time string and convert it to UTC milliseconds, do
 * something like this:
 *
 * <pre>
 * Time time = new Time();
 * String date = ""20081013T160000Z"";
 * time.parse(date);
 * long millis = time.normalize(false);
 * </pre>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The internal method has changed from nativeParse(s) to parseInternal(s), which means that the implementation of the dependent API has changed. This is a change of the type 5.","There is no compatibility issue if the new internal method parseInternal(s) behaves identically to nativeParse(s) from the perspective of the API's contract. The change does not inherently lead to different return values or exception handlings in the context of this specific API's usage, so the CI type is 0."
715,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",20,21,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>","<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",0,"{
    if (VDBG)
        Log.d(TAG, ""write: "" + mSocketOS + "" length: "" + length);
    mSocketOS.write(b, offset, length);
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, ""write out: "" + mSocketOS + "" length: "" + length);
    return length;
}","{
    if (mSocketOS == null)
        throw new IOException(""write is called on null OutputStream"");
    if (VDBG)
        Log.d(TAG, ""write: "" + mSocketOS + "" length: "" + length);
    mSocketOS.write(b, offset, length);
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, ""write out: "" + mSocketOS + "" length: "" + length);
    return length;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new ""if"" statement that throws an IOException when mSocketOS is null was added, and a new exception handling was introduced, so the code changes are 2 for exception handling and 3 for control dependency.","With the introduction of new exception handling code, there is the potential to throw a new exception (`IOException`) when `mSocketOS` is null. This constitutes a Compatibility Issue of type 2, as this change in exception handling could cause the method to behave differently across versions when `mSocketOS` is null."
717,<android.os.Bundle: short getShort(String)>,20,21,<android.os.Bundle: short getShort(String)>,<android.os.Bundle: short getShort(String)>,0,"{
    unparcel();
    return getShort(key, (short) 0);
}","{
    return super.getShort(key);
}",1,"/**
 * Returns the value associated with the given key, or (short) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a short value
 */
","/**
 * Returns the value associated with the given key, or (short) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a short value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,1,"The implementation of the getShort method is changed to call the superclass implementation instead of its own code, which means there is a dependency on the superclass method that could have a different implementation. Therefore, the change class is 5.","Since the method now relies on the superclass implementation of getShort, if the superclass has different logic for handling the get, this could lead to the API returning a different value. Hence, there is a potential for Compatibility Issue caused by possible different return values or types, categorized as type 1."
718,<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,20,21,<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,0,"{
    if (resid != 0 && resid == mCheckMarkResource) {
        return;
    }
    mCheckMarkResource = resid;
    Drawable d = null;
    if (mCheckMarkResource != 0) {
        d = getResources().getDrawable(mCheckMarkResource);
    }
    setCheckMarkDrawable(d);
}","{
    if (resid != 0 && resid == mCheckMarkResource) {
        return;
    }
    mCheckMarkResource = resid;
    Drawable d = null;
    if (mCheckMarkResource != 0) {
        d = getContext().getDrawable(mCheckMarkResource);
    }
    setCheckMarkDrawable(d);
}",1,"/**
 * Set the checkmark to a given Drawable, identified by its resourece id. This will be drawn
 * when {@link #isChecked()} is true.
 *
 * @param resid The Drawable to use for the checkmark.
 *
 * @see #setCheckMarkDrawable(Drawable)
 * @see #getCheckMarkDrawable()
 *
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 */
","/**
 * Set the checkmark to a given Drawable, identified by its resourece id. This will be drawn
 * when {@link #isChecked()} is true.
 *
 * @param resid The Drawable to use for the checkmark.
 *
 * @see #setCheckMarkDrawable(Drawable)
 * @see #getCheckMarkDrawable()
 *
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change is in the way of how the Drawable is retrieved, from getResources().getDrawable(mCheckMarkResource) to getContext().getDrawable(mCheckMarkResource). This represents an 'Other statement changed' (4), and since it alters the way a dependent resource is fetched, it is also a 'Dependent API changed' (5).","This modification does not lead to a Compatibility Issue, because the behaviour of fetching a Drawable resource by resourceId is expected to remain the same—it merely uses a different method to accomplish it. The API's return value and exception handling are the same before and after the change. Hence, no CI (0)."
720,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,20,21,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth(), 1.f - ev.getY(activePointerIndex) / getHeight());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth(), ev.getY(activePointerIndex) / getHeight());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
721,<android.widget.AbsListView: boolean isFastScrollAlwaysVisible()>,20,21,<android.widget.AbsListView: boolean isFastScrollAlwaysVisible()>,<android.widget.AbsListView: boolean isFastScrollAlwaysVisible()>,0,"{
    if (mFastScroller == null) {
        return mFastScrollEnabled && mFastScrollAlwaysVisible;
    } else {
        return mFastScroller.isEnabled() && mFastScroller.isAlwaysShowEnabled();
    }
}","{
    if (mFastScroll == null) {
        return mFastScrollEnabled && mFastScrollAlwaysVisible;
    } else {
        return mFastScroll.isEnabled() && mFastScroll.isAlwaysShowEnabled();
    }
}",1,"/**
 * Returns true if the fast scroller is set to always show on this view.
 *
 * @return true if the fast scroller will always show
 * @see #setFastScrollAlwaysVisible(boolean)
 */
","/**
 * Returns true if the fast scroller is set to always show on this view.
 *
 * @return true if the fast scroller will always show
 * @see #setFastScrollAlwaysVisible(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation of the method between the two versions.,There is no compatibility issue as there is no change in the code.
722,"<android.preference.PreferenceActivity: void loadHeadersFromResource(int,List<Header>)>",20,21,"<android.preference.PreferenceActivity: void loadHeadersFromResource(int,List<Header>)>","<android.preference.PreferenceActivity: void loadHeadersFromResource(int,List<Header>)>",0,"{
    XmlResourceParser parser = null;
    try {
        parser = getResources().getXml(resid);
        AttributeSet attrs = Xml.asAttributeSet(parser);
        int type;
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
        // Parse next until start tag is found
        }
        String nodeName = parser.getName();
        if (!""preference-headers"".equals(nodeName)) {
            throw new RuntimeException(""XML document must start with <preference-headers> tag; found"" + nodeName + "" at "" + parser.getPositionDescription());
        }
        Bundle curBundle = null;
        final int outerDepth = parser.getDepth();
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                continue;
            }
            nodeName = parser.getName();
            if (""header"".equals(nodeName)) {
                Header header = new Header();
                TypedArray sa = getResources().obtainAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
                header.id = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_id, (int) HEADER_ID_UNDEFINED);
                TypedValue tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_title);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.titleRes = tv.resourceId;
                    } else {
                        header.title = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_summary);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.summaryRes = tv.resourceId;
                    } else {
                        header.summary = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbTitle = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbShortTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbShortTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbShortTitle = tv.string;
                    }
                }
                header.iconRes = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_icon, 0);
                header.fragment = sa.getString(com.android.internal.R.styleable.PreferenceHeader_fragment);
                sa.recycle();
                if (curBundle == null) {
                    curBundle = new Bundle();
                }
                final int innerDepth = parser.getDepth();
                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
                    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                        continue;
                    }
                    String innerNodeName = parser.getName();
                    if (innerNodeName.equals(""extra"")) {
                        getResources().parseBundleExtra(""extra"", attrs, curBundle);
                        XmlUtils.skipCurrentTag(parser);
                    } else if (innerNodeName.equals(""intent"")) {
                        header.intent = Intent.parseIntent(getResources(), parser, attrs);
                    } else {
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                if (curBundle.size() > 0) {
                    header.fragmentArguments = curBundle;
                    curBundle = null;
                }
                target.add(header);
            } else {
                XmlUtils.skipCurrentTag(parser);
            }
        }
    } catch (XmlPullParserException e) {
        throw new RuntimeException(""Error parsing headers"", e);
    } catch (IOException e) {
        throw new RuntimeException(""Error parsing headers"", e);
    } finally {
        if (parser != null)
            parser.close();
    }
}","{
    XmlResourceParser parser = null;
    try {
        parser = getResources().getXml(resid);
        AttributeSet attrs = Xml.asAttributeSet(parser);
        int type;
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
        // Parse next until start tag is found
        }
        String nodeName = parser.getName();
        if (!""preference-headers"".equals(nodeName)) {
            throw new RuntimeException(""XML document must start with <preference-headers> tag; found"" + nodeName + "" at "" + parser.getPositionDescription());
        }
        Bundle curBundle = null;
        final int outerDepth = parser.getDepth();
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                continue;
            }
            nodeName = parser.getName();
            if (""header"".equals(nodeName)) {
                Header header = new Header();
                TypedArray sa = obtainStyledAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
                header.id = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_id, (int) HEADER_ID_UNDEFINED);
                TypedValue tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_title);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.titleRes = tv.resourceId;
                    } else {
                        header.title = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_summary);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.summaryRes = tv.resourceId;
                    } else {
                        header.summary = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbTitle = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbShortTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbShortTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbShortTitle = tv.string;
                    }
                }
                header.iconRes = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_icon, 0);
                header.fragment = sa.getString(com.android.internal.R.styleable.PreferenceHeader_fragment);
                sa.recycle();
                if (curBundle == null) {
                    curBundle = new Bundle();
                }
                final int innerDepth = parser.getDepth();
                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
                    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                        continue;
                    }
                    String innerNodeName = parser.getName();
                    if (innerNodeName.equals(""extra"")) {
                        getResources().parseBundleExtra(""extra"", attrs, curBundle);
                        XmlUtils.skipCurrentTag(parser);
                    } else if (innerNodeName.equals(""intent"")) {
                        header.intent = Intent.parseIntent(getResources(), parser, attrs);
                    } else {
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                if (curBundle.size() > 0) {
                    header.fragmentArguments = curBundle;
                    curBundle = null;
                }
                target.add(header);
            } else {
                XmlUtils.skipCurrentTag(parser);
            }
        }
    } catch (XmlPullParserException e) {
        throw new RuntimeException(""Error parsing headers"", e);
    } catch (IOException e) {
        throw new RuntimeException(""Error parsing headers"", e);
    } finally {
        if (parser != null)
            parser.close();
    }
}",1,"/**
 * Parse the given XML file as a header description, adding each
 * parsed Header into the target list.
 *
 * @param resid The XML resource to load and parse.
 * @param target The list in which the parsed headers should be placed.
 */
","/**
 * Parse the given XML file as a header description, adding each
 * parsed Header into the target list.
 *
 * @param resid The XML resource to load and parse.
 * @param target The list in which the parsed headers should be placed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
723,<android.content.res.TypedArray: Drawable getDrawable(int)>,20,21,<android.content.res.TypedArray: Drawable getDrawable(int)>,<android.content.res.TypedArray: Drawable getDrawable(int)>,0,"{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (false) {
            System.out.println(""******************************************************************"");
            System.out.println(""Got drawable resource: type="" + value.type + "" str="" + value.string + "" int=0x"" + Integer.toHexString(value.data) + "" cookie="" + value.assetCookie);
            System.out.println(""******************************************************************"");
        }
        return mResources.loadDrawable(value, value.resourceId);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new RuntimeException(""Failed to resolve attribute at index "" + index);
        }
        return mResources.loadDrawable(value, value.resourceId, mTheme);
    }
    return null;
}",1,"/**
 * Retrieve the Drawable for the attribute at <var>index</var>.  This
 * gets the resource ID of the selected attribute, and uses
 * {@link Resources#getDrawable Resources.getDrawable} of the owning
 * Resources object to retrieve its Drawable.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or null if not defined.
 */
","/**
 * Retrieve the Drawable for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or null if not defined.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"2,3",2,"The late version adds a new exception handling block to check if the TypedArray has been recycled and a new condition to check if the value type is an attribute, throwing RuntimeException if these conditions are met. This represents a code change type of 2,3 due to the addition of new exception handling and control dependency changes.","The new checks for recycled instances and attribute types in the late version can cause RuntimeExceptions to be thrown in cases where the early version would not, which indicates a potential compatibility issue arising from different exception handlings. Therefore, the CI type is 2."
725,<android.net.NetworkInfo: String toString()>,20,21,<android.net.NetworkInfo: String toString()>,<android.net.NetworkInfo: String toString()>,0,"{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""NetworkInfo: "");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", roaming: "").append(mIsRoaming).append("", failover: "").append(mIsFailover).append("", isAvailable: "").append(mIsAvailable).append("", isConnectedToProvisioningNetwork: "").append(mIsConnectedToProvisioningNetwork);
        return builder.toString();
    }
}","{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""["");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", roaming: "").append(mIsRoaming).append("", failover: "").append(mIsFailover).append("", isAvailable: "").append(mIsAvailable).append("", isConnectedToProvisioningNetwork: "").append(mIsConnectedToProvisioningNetwork).append(""]"");
        return builder.toString();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is in the string literal within the StringBuilder which alters the format of the output string. The beginning and end of the string is modified from ""NetworkInfo: "" to ""["" and a ""]"" is added at the end. This is a change in an 'Other statement', so the change type is 4.","The modification only changes the format of the returned string without affecting the actual functionality or the behavior of the method. The information contained within the string remains the same, so there is no Compatibility Issue, and the CI type is 0."
727,<android.widget.TextView: boolean onPreDraw()>,20,21,<android.widget.TextView: boolean onPreDraw()>,<android.widget.TextView: boolean onPreDraw()>,0,"{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    getViewTreeObserver().removeOnPreDrawListener(this);
    mPreDrawRegistered = false;
    return true;
}","{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    unregisterForPreDraw();
    return true;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The method ""getViewTreeObserver().removeOnPreDrawListener(this);"" has been replaced with ""unregisterForPreDraw();"", which is a change in an other statement (code change type 4), and this probably corresponds to a change in control dependency (code change type 3) internally where a control dependency like obtaining the ViewTreeObserver and removing the listener is encapsulated within the unregisterForPreDraw(); method.","Although there is a change in the method call used to unregister the pre-draw listener, this does not impact the output or external behavior of onPreDraw() method itself. The method still returns true in all code execution paths, hence there is no Compatibility Issue (CI type 0)."
729,<android.view.View: void buildDrawingCache(boolean)>,20,21,<android.view.View: void buildDrawingCache(boolean)>,<android.view.View: void buildDrawingCache(boolean)>,0,"{
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        final long projectedBitmapSize = width * height * (opaque && !use32BitCache ? 2 : 4);
        final long drawingCacheSize = ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();
        if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
            if (width > 0 && height > 0) {
                Log.w(VIEW_LOG_TAG, ""View too large to fit into drawing cache, needs "" + projectedBitmapSize + "" bytes, only "" + drawingCacheSize + "" available"");
            }
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                    case DRAWING_CACHE_QUALITY_LOW:
                    case DRAWING_CACHE_QUALITY_HIGH:
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= PFLAG_DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
            if (mOverlay != null && !mOverlay.isEmpty()) {
                mOverlay.getOverlayView().draw(canvas);
            }
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}","{
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        final long projectedBitmapSize = width * height * (opaque && !use32BitCache ? 2 : 4);
        final long drawingCacheSize = ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();
        if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
            if (width > 0 && height > 0) {
                Log.w(VIEW_LOG_TAG, ""View too large to fit into drawing cache, needs "" + projectedBitmapSize + "" bytes, only "" + drawingCacheSize + "" available"");
            }
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                    case DRAWING_CACHE_QUALITY_LOW:
                    case DRAWING_CACHE_QUALITY_HIGH:
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= PFLAG_DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
            if (mOverlay != null && !mOverlay.isEmpty()) {
                mOverlay.getOverlayView().draw(canvas);
            }
        } else {
            draw(canvas);
        }
        drawAccessibilityFocus(canvas);
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
730,"<android.view.ViewDebug: Object resolveId(Context,int)>",20,21,"<android.view.ViewDebug: Object resolveId(Context,int)>","<android.view.ViewDebug: Object resolveId(Context,int)>",0,"{
    Object fieldValue;
    final Resources resources = context.getResources();
    if (id >= 0) {
        try {
            fieldValue = resources.getResourceTypeName(id) + '/' + resources.getResourceEntryName(id);
        } catch (Resources.NotFoundException e) {
            fieldValue = ""id/0x"" + Integer.toHexString(id);
        }
    } else {
        fieldValue = ""NO_ID"";
    }
    return fieldValue;
}","{
    Object fieldValue;
    final Resources resources = context.getResources();
    if (id >= 0) {
        try {
            fieldValue = resources.getResourceTypeName(id) + '/' + resources.getResourceEntryName(id);
        } catch (Resources.NotFoundException e) {
            fieldValue = ""id/"" + formatIntToHexString(id);
        }
    } else {
        fieldValue = ""NO_ID"";
    }
    return fieldValue;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is the replacement of ""0x"" + Integer.toHexString(id) with a call to a new method formatIntToHexString(id) within the catch block. This is categorized as other statement changed (4).","There is no Compatibility Issue because the change does not affect the actual behavior or the outcome of the method; it merely changes the way the same hexadecimal string is formatted. The API still returns a string representation of the resource id in hexadecimal format, which means the external behavior of the method is consistent between the versions."
732,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>",20,21,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>","<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>",0,"{
    if (mContext == null) {
        return false;
    }
    try {
        return sService.bindAppWidgetIdIfAllowed(mContext.getPackageName(), appWidgetId, provider, null, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return false;
    }
    return bindAppWidgetIdIfAllowed(appWidgetId, UserHandle.myUserId(), provider, null);
}",1,"/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId     The AppWidget instance for which to set the RemoteViews.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @return true if this component has permission to bind the AppWidget
 */
","/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId   The AppWidget id under which to bind the provider.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @return true if this component has permission to bind the AppWidget
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The early implementation has a null check for mContext, which is changed to a null check for mService in the late implementation; a RemoteException try-catch block is removed, and the way the method is called has altered by directly calling another overloaded method bindAppWidgetIdIfAllowed(int, int, ComponentName, Bundle) instead of reaching out to a potentially remote service through sService. These changes incorporate a returned value change, control dependency change, other statement change, and dependent API change, hence the change types are 1,3,4,5.","Since the implementation changed from using a remote service to an internal method call with different parameters and removed the exception handling code that could throw a RuntimeException, these changes could lead to both different return values or types and different exception handlings, which means a CI might arise for both reasons, so the CI types are 1,2."
735,"<android.net.ConnectivityManager: boolean requestRouteToHost(int,int)>",20,21,"<android.net.ConnectivityManager: boolean requestRouteToHost(int,int)>","<android.net.ConnectivityManager: boolean requestRouteToHost(int,int)>",0,"{
    InetAddress inetAddress = NetworkUtils.intToInetAddress(hostAddress);
    if (inetAddress == null) {
        return false;
    }
    return requestRouteToHostAddress(networkType, inetAddress);
}","{
    return requestRouteToHostAddress(networkType, NetworkUtils.intToInetAddress(hostAddress));
}",1,"/**
 * Ensure that a network route exists to deliver traffic to the specified
 * host via the specified network interface. An attempt to add a route that
 * already exists is ignored, but treated as successful.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType the type of the network over which traffic to the specified
 * host is to be routed
 * @param hostAddress the IP address of the host to which the route is desired
 * @return {@code true} on success, {@code false} on failure
 */
","/**
 * Ensure that a network route exists to deliver traffic to the specified
 * host via the specified network interface. An attempt to add a route that
 * already exists is ignored, but treated as successful.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType the type of the network over which traffic to the specified
 * host is to be routed
 * @param hostAddress the IP address of the host to which the route is desired
 * @return {@code true} on success, {@code false} on failure
 *
 * @deprecated Deprecated in favor of the {@link #requestNetwork},
 * {@link #setProcessDefaultNetwork} and {@link Network#getSocketFactory} api.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The code has been refactored to remove an intermediate assignment and the null check has been eliminated. This change is a control dependency change (3), since we removed an 'if' check. Moreover, this change also affects the dependent API since the implementation now always calls requestRouteToHostAddress directly, which is a change (5).","Despite the refactor, there's no potential Compatibility Issue because the behavior of the method does not change: it now unconditionally calls another method that indicates it would handle any necessary checks internally (either the null check is performed within or is unnecessary due to internals of requestRouteToHostAddress). Therefore, from an API consumer's perspective, there would be no observable difference in behavior, leading to pred_CI being 0."
736,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>",20,21,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>","<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>",0,"{
    return mGlobal.createVirtualDisplay(mContext, name, width, height, densityDpi, surface, flags);
}","{
    return createVirtualDisplay(name, width, height, densityDpi, surface, flags, null, null);
}",1,"/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, must be non-null.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION}
 * or {@link #VIRTUAL_DISPLAY_FLAG_SECURE}.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
","/**
 * Creates a virtual display.
 *
 * @see #createVirtualDisplay(String, int, int, int, Surface, int, VirtualDisplay.Callback)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change involves calling an overload of the createVirtualDisplay method with additional parameters (null, null), which does not exist in the early version, so the code change type is 5.","Since the actual logic and behavior of createVirtualDisplay seem unaffected due to the introduction of extra null parameters, which are likely default parameters for this overloaded method, no compatibility issue should be expected as the method signature remains the same and it logically executes the same underlying operation. Therefore, the CI type is 0."
737,<android.service.dreams.DreamService: boolean dispatchKeyEvent(KeyEvent)>,20,21,<android.service.dreams.DreamService: boolean dispatchKeyEvent(KeyEvent)>,<android.service.dreams.DreamService: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Finishing on keyEvent"");
        safelyFinish();
        return true;
    } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (mDebug)
            Slog.v(TAG, ""Finishing on back key"");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchKeyEvent(event);
}","{
    // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on keyEvent"");
        wakeUp();
        return true;
    } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on back key"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method called within the 'if' block has been changed from safelyFinish() to wakeUp(), without altering the method signature or the structure of the 'if' blocks. So, the code change type is 4.","The change of the method from safelyFinish() to wakeUp() doesn't constitute a compatibility issue in terms of the API signature but could affect the behavior of the class if the methods have different effects. However, since there is no direct impact on the API's contract (i.e., its input or output), there is no compatibility issue from a client's perspective calling the API. The returned value (boolean) and the conditions under which it is returned are unchanged."
740,<android.speech.tts.AudioPlaybackQueueItem: void run()>,20,21,<android.speech.tts.AudioPlaybackQueueItem: void run()>,<android.speech.tts.AudioPlaybackQueueItem: void run()>,0,"{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    mPlayer = MediaPlayer.create(mContext, mUri);
    if (mPlayer == null) {
        dispatcher.dispatchOnError();
        return;
    }
    try {
        mPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() {

            @Override
            public boolean onError(MediaPlayer mp, int what, int extra) {
                Log.w(TAG, ""Audio playback error: "" + what + "", "" + extra);
                mDone.open();
                return true;
            }
        });
        mPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {

            @Override
            public void onCompletion(MediaPlayer mp) {
                mFinished = true;
                mDone.open();
            }
        });
        mPlayer.setAudioStreamType(mStreamType);
        mPlayer.start();
        mDone.block();
        finish();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, ""MediaPlayer failed"", ex);
        mDone.open();
    }
    if (mFinished) {
        dispatcher.dispatchOnDone();
    } else {
        dispatcher.dispatchOnError();
    }
}","{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    int sessionId = mAudioParams.mSessionId;
    mPlayer = MediaPlayer.create(mContext, mUri, null, mAudioParams.mAudioAttributes, sessionId > 0 ? sessionId : AudioSystem.AUDIO_SESSION_ALLOCATE);
    if (mPlayer == null) {
        dispatcher.dispatchOnError(TextToSpeech.ERROR_OUTPUT);
        return;
    }
    try {
        mPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() {

            @Override
            public boolean onError(MediaPlayer mp, int what, int extra) {
                Log.w(TAG, ""Audio playback error: "" + what + "", "" + extra);
                mDone.open();
                return true;
            }
        });
        mPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {

            @Override
            public void onCompletion(MediaPlayer mp) {
                mFinished = true;
                mDone.open();
            }
        });
        setupVolume(mPlayer, mAudioParams.mVolume, mAudioParams.mPan);
        mPlayer.start();
        mDone.block();
        finish();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, ""MediaPlayer failed"", ex);
        mDone.open();
    }
    if (mFinished) {
        dispatcher.dispatchOnSuccess();
    } else {
        dispatcher.dispatchOnStop();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,The code changes include:,3. The introduction of the setupVolume method invocation.
741,"<android.content.res.TypedArray: int getInteger(int,int)>",20,21,"<android.content.res.TypedArray: int getInteger(int,int)>","<android.content.res.TypedArray: int getInteger(int,int)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    throw new UnsupportedOperationException(""Can't convert to integer: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to integer: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 */
","/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The change includes the addition of a recycled instance check and a new exception handling for the 'TYPE_ATTRIBUTE' case. Thus, the code changes include: Exception handling statement changed (code 2), Control dependency changed due to the addition of 'if (mRecycled)' (code 3), and Other statement changed because of the addition of the new exception handling (code 4).","The added check for a recycled instance directly throws an exception where the previous version did not, thus potentially causing a different behavior (CI type 2). Furthermore, the addition of the new exception handling for 'TYPE_ATTRIBUTE' means that the method could now throw an exception in a case where it previously would not have, which is another possibility of a different behavior (also CI type 2). Lastly, any of these changes can lead the method to return a different value, causing a CI type 1."
744,<android.view.accessibility.AccessibilityManager: List<ServiceInfo> getAccessibilityServiceList()>,20,21,<android.view.accessibility.AccessibilityManager: List<ServiceInfo> getAccessibilityServiceList()>,<android.view.accessibility.AccessibilityManager: List<ServiceInfo> getAccessibilityServiceList()>,0,"{
    List<AccessibilityServiceInfo> infos = getInstalledAccessibilityServiceList();
    List<ServiceInfo> services = new ArrayList<ServiceInfo>();
    final int infoCount = infos.size();
    for (int i = 0; i < infoCount; i++) {
        AccessibilityServiceInfo info = infos.get(i);
        services.add(info.getResolveInfo().serviceInfo);
    }
    return Collections.unmodifiableList(services);
}","{
    List<AccessibilityServiceInfo> infos = getInstalledAccessibilityServiceList();
    List<ServiceInfo> services = new ArrayList<>();
    final int infoCount = infos.size();
    for (int i = 0; i < infoCount; i++) {
        AccessibilityServiceInfo info = infos.get(i);
        services.add(info.getResolveInfo().serviceInfo);
    }
    return Collections.unmodifiableList(services);
}",1,"/**
 * Returns the {@link ServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link ServiceInfo}s.
 *
 * @deprecated Use {@link #getInstalledAccessibilityServiceList()}
 */
","/**
 * Returns the {@link ServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link ServiceInfo}s.
 *
 * @deprecated Use {@link #getInstalledAccessibilityServiceList()}
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,0,0,There are no differences in the implementation of the method between the early and late versions except for the removal of explicit generic type declaration (ServiceInfo) in the new ArrayList instantiation which does not affect the method's behavior due to type inference. Annotations have not changed and remain the same (@Deprecated).,There are no compatibility issues as there are no changes in behavior or output between the two versions of the method.
745,"<android.app.ApplicationPackageManager: void replacePreferredActivity(IntentFilter,int,ComponentName[],ComponentName)>",20,21,"<android.app.ApplicationPackageManager: void replacePreferredActivity(IntentFilter,int,ComponentName[],ComponentName)>","<android.app.ApplicationPackageManager: void replacePreferredActivity(IntentFilter,int,ComponentName[],ComponentName)>",0,"{
    try {
        mPM.replacePreferredActivity(filter, match, set, activity);
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.replacePreferredActivity(filter, match, set, activity, UserHandle.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method mPM.replacePreferredActivity called within the try block now includes an additional argument (UserHandle.myUserId()), so the code change type is 5 due to the dependent API change.","Since the catch block remains unchanged and is designed to catch all RemoteExceptions without throwing further, and the internal implementation change doesn't affect how exceptions are caught or handled, no Compatibility Issue related to exception handling arises. The addition of a user ID argument does not result in changes to return values (since it's a void method) or exception throwing behavior. Therefore, there's no Compatibility Issue (0)."
746,"<android.bluetooth.BluetoothManager: BluetoothGattServer openGattServer(Context,BluetoothGattServerCallback)>",20,21,"<android.bluetooth.BluetoothManager: BluetoothGattServer openGattServer(Context,BluetoothGattServerCallback)>","<android.bluetooth.BluetoothManager: BluetoothGattServer openGattServer(Context,BluetoothGattServerCallback)>",0,"{
    if (context == null || callback == null) {
        throw new IllegalArgumentException(""null parameter: "" + context + "" "" + callback);
    }
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            Log.e(TAG, ""Fail to get GATT Server connection"");
            return null;
        }
        BluetoothGattServer mGattServer = new BluetoothGattServer(context, iGatt);
        Boolean regStatus = mGattServer.registerCallback(callback);
        return regStatus ? mGattServer : null;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return null;
    }
}","{
    return (openGattServer(context, callback, BluetoothDevice.TRANSPORT_AUTO));
}",1,"/**
 * Open a GATT Server
 * The callback is used to deliver results to Caller, such as connection status as well
 * as the results of any other GATT server operations.
 * The method returns a BluetoothGattServer instance. You can use BluetoothGattServer
 * to conduct GATT server operations.
 * @param context App context
 * @param callback GATT server callback handler that will receive asynchronous callbacks.
 * @return BluetoothGattServer instance
 */
","/**
 * Open a GATT Server
 * The callback is used to deliver results to Caller, such as connection status as well
 * as the results of any other GATT server operations.
 * The method returns a BluetoothGattServer instance. You can use BluetoothGattServer
 * to conduct GATT server operations.
 * @param context App context
 * @param callback GATT server callback handler that will receive asynchronous callbacks.
 * @return BluetoothGattServer instance
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The late version implementation returns the result of a call to a different method, openGattServer with an extra parameter, suggesting the internal implementation has been delegated. There has been a change to the dependent API, as the work has been offloaded to a method that accepts different parameters, so the change type is 1,5.","Since the late version of the API delegates to another method, it's reasonable to assume that the behavior could be different from the earlier version, potentially generating different return values. Thus, the CI type is 1."
748,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName,Bundle)>",20,21,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName,Bundle)>","<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName,Bundle)>",0,"{
    if (mContext == null) {
        return false;
    }
    try {
        return sService.bindAppWidgetIdIfAllowed(mContext.getPackageName(), appWidgetId, provider, options, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return false;
    }
    return bindAppWidgetIdIfAllowed(appWidgetId, UserHandle.myUserId(), provider, options);
}",1,"/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId     The AppWidget instance for which to set the RemoteViews.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @param options       Bundle containing options for the AppWidget. See also
 * {@link #updateAppWidgetOptions(int, Bundle)}
 *
 * @return true if this component has permission to bind the AppWidget
 */
","/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId The AppWidget id under which to bind the provider.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @param options       Bundle containing options for the AppWidget. See also
 * {@link #updateAppWidgetOptions(int, Bundle)}
 *
 * @return true if this component has permission to bind the AppWidget
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,The code changes include: ,"- The method call is changed from the five-parameter version to the four-parameter `bindAppWidgetIdIfAllowed` method, which suggests a dependent API change. "
749,<android.webkit.CookieSyncManager: void syncFromRamToFlash()>,20,21,<android.webkit.CookieSyncManager: void syncFromRamToFlash()>,<android.webkit.CookieSyncManager: void syncFromRamToFlash()>,0,"{
    if (DebugFlags.COOKIE_SYNC_MANAGER) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash STARTS"");
    }
    CookieManager manager = CookieManager.getInstance();
    if (!manager.acceptCookie()) {
        return;
    }
    manager.flushCookieStore();
    if (DebugFlags.COOKIE_SYNC_MANAGER) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash DONE"");
    }
}","{
    CookieManager.getInstance().flush();
}",1,,"/**
 * @deprecated Use {@link CookieManager#flush} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The late version of the method has removed the debug logging, acceptance check for the cookies and changed the method called on the CookieManager from flushCookieStore() to flush(). This constitutes changes in the other statements (debug logs removed) and dependent API changed (changed from flushCookieStore() to flush()), so the code change types are 1, 4, and 5.","Removing the check for manager.acceptCookie() could lead to the API behaving differently by not bailing out early, which could be a CI type 1 due to potential different return behavior. Also, changing from flushCookieStore() to flush() could potentially be considered as a different exception handling in the API's dependent method, leading to a possible difference in exceptions thrown from the CookieManager; therefore, CI type 2 is also applicable."
751,"<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFinished(PrintDocumentInfo,boolean)>",20,21,"<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFinished(PrintDocumentInfo,boolean)>","<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFinished(PrintDocumentInfo,boolean)>",0,"{
    if (info == null) {
        throw new NullPointerException(""document info cannot be null"");
    }
    final ILayoutResultCallback callback;
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        callback = mCallback;
        clearLocked();
    }
    if (callback != null) {
        try {
            callback.onLayoutFinished(info, changed, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onLayoutFinished"", re);
        }
    }
}","{
    final ILayoutResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
    }
    // If the callback is null we are destroyed.
    if (callback == null) {
        Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"");
        return;
    }
    try {
        if (info == null) {
            throw new NullPointerException(""document info cannot be null"");
        }
        try {
            callback.onLayoutFinished(info, changed, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onLayoutFinished"", re);
        }
    } finally {
        destroy();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The code change includes the deletion of an exception handling before `synchronized` block and introducing a new control statement around the `try` block. The `synchronized` block has been modified by removing the check `mDestroyed` and the invocation of a `clearLocked()` method within the `synchronized` block. A `finally` block with a new method call `destroy()` has also been added. These changes account for exception handling statement changed, control dependency changed, and other statement changed. So the change types are 1,2,3,4.","The changes to the exception handling logic, control flow, and introduction of the unlinking in the `finally` block could lead to different exception handling behavior and data state after the API call. The movement of the null check for `info` from the beginning of the method might change when the NullPointerException is thrown, which could represent a different exception handling behavior as well. Thus, there could be a Compatibility Issue due to the potential different return values or types and potential different exception handlings, and the CI types are 1,2."
752,"<android.os.Parcel: void readException(int,String)>",20,21,"<android.os.Parcel: void readException(int,String)>","<android.os.Parcel: void readException(int,String)>",0,"{
    switch(code) {
        case EX_SECURITY:
            throw new SecurityException(msg);
        case EX_BAD_PARCELABLE:
            throw new BadParcelableException(msg);
        case EX_ILLEGAL_ARGUMENT:
            throw new IllegalArgumentException(msg);
        case EX_NULL_POINTER:
            throw new NullPointerException(msg);
        case EX_ILLEGAL_STATE:
            throw new IllegalStateException(msg);
        case EX_NETWORK_MAIN_THREAD:
            throw new NetworkOnMainThreadException();
    }
    throw new RuntimeException(""Unknown exception code: "" + code + "" msg "" + msg);
}","{
    switch(code) {
        case EX_SECURITY:
            throw new SecurityException(msg);
        case EX_BAD_PARCELABLE:
            throw new BadParcelableException(msg);
        case EX_ILLEGAL_ARGUMENT:
            throw new IllegalArgumentException(msg);
        case EX_NULL_POINTER:
            throw new NullPointerException(msg);
        case EX_ILLEGAL_STATE:
            throw new IllegalStateException(msg);
        case EX_NETWORK_MAIN_THREAD:
            throw new NetworkOnMainThreadException();
        case EX_UNSUPPORTED_OPERATION:
            throw new UnsupportedOperationException(msg);
    }
    throw new RuntimeException(""Unknown exception code: "" + code + "" msg "" + msg);
}",1,"/**
 * Use this function for customized exception handling.
 * customized method call this method for all unknown case
 * @param code exception code
 * @param msg exception message
 */
","/**
 * Throw an exception with the given message. Not intended for use
 * outside the Parcel class.
 *
 * @param code Used to determine which exception class to throw.
 * @param msg The exception message.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"There is a new case condition 'case EX_UNSUPPORTED_OPERATION:' with a corresponding exception handling statement added in the switch statement, so the code change type is 2,3.","The introduction of a new case condition for throwing UnsupportedOperationException constitutes a change in exception handling, as it adds a new type of exception that was not thrown in the previous version. Therefore, the CI type is 2."
753,<android.widget.DatePicker: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,20,21,<android.widget.DatePicker: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,<android.widget.DatePicker: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,0,"{
    onPopulateAccessibilityEvent(event);
    return true;
}","{
    return mDelegate.dispatchPopulateAccessibilityEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed from an unconditional return of 'true' to a conditional return based on the result of a method call 'mDelegate.dispatchPopulateAccessibilityEvent(event)', which implies a dependent API change as well. Therefore, the code change type is 1,5.","This change could lead to different return values depending on the result of 'mDelegate.dispatchPopulateAccessibilityEvent(event)', so the CI type is 1."
755,<android.app.ActivityOptions: Bundle toBundle()>,20,21,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_START_WIDTH, mStartWidth);
            b.putInt(KEY_ANIM_START_HEIGHT, mStartHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
    }
    return b;
}","{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","There appears to be several changes in the code. A conditional check for `mAnimationType == ANIM_DEFAULT` with a return of `null` was introduced, so this modification affects the return statement. The `putInt` calls relating to `mAnimationType` have been moved outside of the switch statement, which had been inside switch cases in the early version, falls under control dependency changed. Moreover, new cases in the switch statement (`ANIM_THUMBNAIL_ASPECT_SCALE_UP`, `ANIM_THUMBNAIL_ASPECT_SCALE_DOWN`, and `ANIM_SCENE_TRANSITION`) have been added, and the keys for some Bundle data (`KEY_ANIM_START_WIDTH`, `KEY_ANIM_START_HEIGHT`) changed to `KEY_ANIM_WIDTH` and `KEY_ANIM_HEIGHT`. These are other statement changes. The overall change type is 1,3,4 due to new return pathway, control flow modification, and other changes.","Due to the introduction of a possible return of `null` at the beginning of the method and the changes within the switch case which alter the structure of the returned `Bundle` object, there is a potential compatibility issue due to different return types or values. The refactoring of `putInt` for `KEY_ANIM_TYPE` outside the switch and removal of two bundle keys could lead to a scenario where `KEY_ANIM_WIDTH` and `KEY_ANIM_HEIGHT` do not have equivalent values in the `Bundle` compared to `KEY_ANIM_START_WIDTH` and `KEY_ANIM_START_HEIGHT` from the early version. This constitutes a compatibility issue caused by potential different return values or types, thus the CI type is 1. Additionally, the late version can potentially throw a `NullPointerException` if methods are called on a `null` value of `b` when `mAnimationType` is `ANIM_DEFAULT`, thus leading to a different exception throwing behavior, so another CI type is 2."
759,<android.widget.CalendarView: Drawable getSelectedDateVerticalBar()>,20,21,<android.widget.CalendarView: Drawable getSelectedDateVerticalBar()>,<android.widget.CalendarView: Drawable getSelectedDateVerticalBar()>,0,"{
    return mSelectedDateVerticalBar;
}","{
    return mDelegate.getSelectedDateVerticalBar();
}",1,"/**
 * Gets the drawable for the vertical bar shown at the beginning and at
 * the end of the selected date.
 *
 * @return The vertical bar drawable.
 */
","/**
 * Gets the drawable for the vertical bar shown at the beginning and at
 * the end of the selected date.
 *
 * @return The vertical bar drawable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method body has changed from returning a member variable (mSelectedDateVerticalBar) to calling a method on another object (mDelegate.getSelectedDateVerticalBar()), which indicates a change in the mechanism of how the drawable is retrieved; thus, it involves a change in other statement and a dependent API change. The code change type is 4,5.","The API now depends on a method call to another object, which could return a different drawable than the earlier member field access. As such, there is potential for a different value to be returned by the API, which means a CI type of 1."
760,<android.widget.CalendarView: boolean isEnabled()>,20,21,<android.widget.CalendarView: boolean isEnabled()>,<android.widget.CalendarView: boolean isEnabled()>,0,"{
    return mListView.isEnabled();
}","{
    return mDelegate.isEnabled();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation has changed from returning the result of mListView.isEnabled() to mDelegate.isEnabled(). This change involves a different object/method being called, so the code change types are 4 and 5.","Since the method is now calling isEnabled() on a different object, it can potentially return a different value. Thus the CI type is 1."
761,<android.view.View: boolean onTouchEvent(MotionEvent)>,20,21,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true);
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true);
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
762,"<android.content.res.TypedArray: int getColor(int,int)>",20,21,"<android.content.res.TypedArray: int getColor(int,int)>","<android.content.res.TypedArray: int getColor(int,int)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            ColorStateList csl = mResources.loadColorStateList(value, value.resourceId);
            return csl.getDefaultColor();
        }
        return defValue;
    }
    throw new UnsupportedOperationException(""Can't convert to color: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            ColorStateList csl = mResources.loadColorStateList(value, value.resourceId);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to color: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 */
","/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","An exception handling statement has been added at the beginning of the late implementation to throw a RuntimeException if mRecycled is true. There is also a control dependency change since a new 'else if' branch has been added to throw a RuntimeException when the type is TypedValue.TYPE_ATTRIBUTE. So the change type is 2,3.","The addition of the exception handling at the beginning potentially changes the exception that could be thrown from UnsupportedOperationException to RuntimeException, which is a new behavior, so the CI type is 2. Also, the new 'else if' branch for TypedValue.TYPE_ATTRIBUTE changes the method's behavior by throwing an exception instead of falling through to the UnsupportedOperationException. This means the method potentially returns a different value or throws a different exception, so the CI type is 1,2."
763,<android.app.Notification: String toString()>,20,21,<android.app.Notification: String toString()>,<android.app.Notification: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    // TODO(dsandler): defaults take precedence over local values, so reorder the branches below
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append("" kind=["");
    if (this.kind == null) {
        sb.append(""null"");
    } else {
        for (int i = 0; i < this.kind.length; i++) {
            if (i > 0)
                sb.append("","");
            sb.append(this.kind[i]);
        }
    }
    sb.append(""]"");
    if (actions != null) {
        sb.append("" "");
        sb.append(actions.length);
        sb.append("" action"");
        if (actions.length > 1)
            sb.append(""s"");
    }
    sb.append("")"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append(String.format("" color=0x%08x"", this.color));
    if (this.category != null) {
        sb.append("" category="");
        sb.append(this.category);
    }
    if (this.mGroupKey != null) {
        sb.append("" groupKey="");
        sb.append(this.mGroupKey);
    }
    if (this.mSortKey != null) {
        sb.append("" sortKey="");
        sb.append(this.mSortKey);
    }
    if (actions != null) {
        sb.append("" actions="");
        sb.append(actions.length);
    }
    sb.append("" vis="");
    sb.append(visibilityToString(this.visibility));
    if (this.publicVersion != null) {
        sb.append("" publicVersion="");
        sb.append(publicVersion.toString());
    }
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The late implementation adds new string concatenations to the StringBuilder `sb` for color, category, groupKey, sortKey, and visibility, as well as a change in the presentation of actions. Therefore, the change type is 4, which reflects changes other than return statement, exception handling, control dependency, or dependent API change.","There is no Compatibility Issue. The method still returns a String. The changes enhance the detail of the representation without altering the method's expected outcome of a string representation. While the output of the method will contain more information in the late version, this does not represent a behavior change that would cause issues from the perspective of backward compatibility. Clients expecting a string representation of the notification object will still receive a valid string."
765,<android.nfc.cardemulation.CardEmulation: int getSelectionModeForCategory(String)>,20,21,<android.nfc.cardemulation.CardEmulation: int getSelectionModeForCategory(String)>,<android.nfc.cardemulation.CardEmulation: int getSelectionModeForCategory(String)>,0,"{
    if (CATEGORY_PAYMENT.equals(category)) {
        String defaultComponent = Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.NFC_PAYMENT_DEFAULT_COMPONENT);
        if (defaultComponent != null) {
            return SELECTION_MODE_PREFER_DEFAULT;
        } else {
            return SELECTION_MODE_ALWAYS_ASK;
        }
    } else {
        // All other categories are in ""only ask if conflict"" mode
        return SELECTION_MODE_ASK_IF_CONFLICT;
    }
}","{
    if (CATEGORY_PAYMENT.equals(category)) {
        String defaultComponent = Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.NFC_PAYMENT_DEFAULT_COMPONENT);
        if (defaultComponent != null) {
            return SELECTION_MODE_PREFER_DEFAULT;
        } else {
            return SELECTION_MODE_ALWAYS_ASK;
        }
    } else {
        return SELECTION_MODE_ASK_IF_CONFLICT;
    }
}",1,"/**
 * Returns the service selection mode for the passed in category.
 * Valid return values are:
 * <p>{@link #SELECTION_MODE_PREFER_DEFAULT} the user has requested a default
 * service for this category, which will be preferred.
 * <p>{@link #SELECTION_MODE_ALWAYS_ASK} the user has requested to be asked
 * every time what service he would like to use in this category.
 * <p>{@link #SELECTION_MODE_ASK_IF_CONFLICT} the user will only be asked
 * to pick a service if there is a conflict.
 * @param category The category, for example {@link #CATEGORY_PAYMENT}
 * @return the selection mode for the passed in category
 */
","/**
 * Returns the service selection mode for the passed in category.
 * Valid return values are:
 * <p>{@link #SELECTION_MODE_PREFER_DEFAULT} the user has requested a default
 * service for this category, which will be preferred.
 * <p>{@link #SELECTION_MODE_ALWAYS_ASK} the user has requested to be asked
 * every time what service he would like to use in this category.
 * <p>{@link #SELECTION_MODE_ASK_IF_CONFLICT} the user will only be asked
 * to pick a service if there is a conflict.
 * @param category The category, for example {@link #CATEGORY_PAYMENT}
 * @return the selection mode for the passed in category
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no changes in the method implementation between the early and late versions.,There is no Compatibility Issue since there is no change in the implementation.
766,<android.widget.DatePicker: CalendarView getCalendarView()>,20,21,<android.widget.DatePicker: CalendarView getCalendarView()>,<android.widget.DatePicker: CalendarView getCalendarView()>,0,"{
    return mCalendarView;
}","{
    return mDelegate.getCalendarView();
}",1,"/**
 * Gets the {@link CalendarView}.
 *
 * @return The calendar view.
 * @see #getCalendarViewShown()
 */
","/**
 * Gets the {@link CalendarView}.
 *
 * @return The calendar view.
 * @see #getCalendarViewShown()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation has changed from returning a direct member variable mCalendarView to calling a method on the delegate mDelegate.getCalendarView(). This suggests a change in how the value is retrieved, so the change type is 5.","Since the late version of the API retrieves the CalendarView through a potentially different mechanism (via a delegate), it could lead to a different CalendarView being returned if the delegate's getCalendarView() behaves differently than just accessing the member variable directly, thus constituting a potential Compatibility Issue of type 1."
767,<android.view.View: String toString()>,20,21,<android.view.View: String toString()>,<android.view.View: String toString()>,0,"{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE_MASK) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (id != 0 && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    out.append(""}"");
    return out.toString();
}","{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE_MASK) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    out.append(""}"");
    return out.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
768,"<android.app.ActivityOptions: ActivityOptions makeScaleUpAnimation(View,int,int,int,int)>",20,21,"<android.app.ActivityOptions: ActivityOptions makeScaleUpAnimation(View,int,int,int,int)>","<android.app.ActivityOptions: ActivityOptions makeScaleUpAnimation(View,int,int,int,int)>",0,"{
    ActivityOptions opts = new ActivityOptions();
    opts.mPackageName = source.getContext().getPackageName();
    opts.mAnimationType = ANIM_SCALE_UP;
    int[] pts = new int[2];
    source.getLocationOnScreen(pts);
    opts.mStartX = pts[0] + startX;
    opts.mStartY = pts[1] + startY;
    opts.mStartWidth = startWidth;
    opts.mStartHeight = startHeight;
    return opts;
}","{
    ActivityOptions opts = new ActivityOptions();
    opts.mPackageName = source.getContext().getPackageName();
    opts.mAnimationType = ANIM_SCALE_UP;
    int[] pts = new int[2];
    source.getLocationOnScreen(pts);
    opts.mStartX = pts[0] + startX;
    opts.mStartY = pts[1] + startY;
    opts.mWidth = width;
    opts.mHeight = height;
    return opts;
}",1,"/**
 * Create an ActivityOptions specifying an animation where the new
 * activity is scaled from a small originating area of the screen to
 * its final full representation.
 *
 * <p>If the Intent this is being used with has not set its
 * {@link android.content.Intent#setSourceBounds Intent.setSourceBounds},
 * those bounds will be filled in for you based on the initial
 * bounds passed in here.
 *
 * @param source The View that the new activity is animating from.  This
 * defines the coordinate space for <var>startX</var> and <var>startY</var>.
 * @param startX The x starting location of the new activity, relative to <var>source</var>.
 * @param startY The y starting location of the activity, relative to <var>source</var>.
 * @param startWidth The initial width of the new activity.
 * @param startHeight The initial height of the new activity.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 */
","/**
 * Create an ActivityOptions specifying an animation where the new
 * activity is scaled from a small originating area of the screen to
 * its final full representation.
 *
 * <p>If the Intent this is being used with has not set its
 * {@link android.content.Intent#setSourceBounds Intent.setSourceBounds},
 * those bounds will be filled in for you based on the initial
 * bounds passed in here.
 *
 * @param source The View that the new activity is animating from.  This
 * defines the coordinate space for <var>startX</var> and <var>startY</var>.
 * @param startX The x starting location of the new activity, relative to <var>source</var>.
 * @param startY The y starting location of the activity, relative to <var>source</var>.
 * @param width The initial width of the new activity.
 * @param height The initial height of the new activity.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"There are changes in assignment statements where 'startWidth' and 'startHeight' variables from the early version have been changed to 'width' and 'height' in the late version. So, the change type is 4.","Since the late version uses different variables ('width', 'height') compared to the early version ('startWidth', 'startHeight'), the returned 'ActivityOptions' object will have different 'mWidth' and 'mHeight' values. Thus, this leads to a potential change in return values, and the CI type is 1."
769,"<android.content.res.TypedArray: int getInt(int,int)>",20,21,"<android.content.res.TypedArray: int getInt(int,int)>","<android.content.res.TypedArray: int getInt(int,int)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to int: "" + v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, ""getInt of bad type: 0x"" + Integer.toHexString(type));
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to int: "" + v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, ""getInt of bad type: 0x"" + Integer.toHexString(type));
    return defValue;
}",1,"/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */
","/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The change includes the introduction of an exception handling statement for recycled instances at the beginning of the method, so the change types are 2 and 3 (exception handling statement change and control dependency change).","The introduction of an exception being thrown if `mRecycled` is `true` can alter the behavior of the API by potentially throwing a new RuntimeException when the instance has been recycled, which did not happen in the early version. This is a significant change that could lead to a Compatibility Issue of type 2, specific to different exception handlings."
770,<android.content.res.TypedArray: int length()>,20,21,<android.content.res.TypedArray: int length()>,<android.content.res.TypedArray: int length()>,0,"{
    return mLength;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return mLength;
}",1,"/**
 * Return the number of values in this array.
 */
","/**
 * Return the number of values in this array.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The late version includes a new 'if' control statement that throws an exception, so the code change types are 2 (Exception handling statement changed) and 3 (Control dependency changed).","The addition of a condition that throws an exception creates a CI due to a potential difference in exception handling. If 'mRecycled' is true, an exception will be thrown before reaching the return statement, which is different from the earlier version where no exception was thrown. Therefore, the CI type is 2."
771,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,20,21,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        return false;
    }
    switch(me.getActionMasked()) {
        case MotionEvent.ACTION_UP:
            {
                if (mHasPendingDrag) {
                    // Allow a tap to scroll.
                    beginDrag();
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    scrollTo(pos);
                    cancelPendingDrag();
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    if (mList != null) {
                        // ViewGroup does the right thing already, but there might
                        // be other classes that don't properly reset on touch-up,
                        // so do this explicitly just in case.
                        mList.requestDisallowInterceptTouchEvent(false);
                        mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                    setState(STATE_VISIBLE);
                    postAutoHide();
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_MOVE:
            {
                if (mHasPendingDrag && Math.abs(me.getY() - mInitialTouchY) > mScaledTouchSlop) {
                    setState(STATE_DRAGGING);
                    if (mListAdapter == null && mList != null) {
                        getSectionsFromIndexer();
                    }
                    if (mList != null) {
                        mList.requestDisallowInterceptTouchEvent(true);
                        mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    }
                    cancelFling();
                    cancelPendingDrag();
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    // TODO: Ignore jitter.
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    // If the previous scrollTo is still pending
                    if (mScrollCompleted) {
                        scrollTo(pos);
                    }
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            {
                cancelPendingDrag();
            }
            break;
    }
    return false;
}","{
    if (!isEnabled()) {
        return false;
    }
    switch(me.getActionMasked()) {
        case MotionEvent.ACTION_UP:
            {
                if (mPendingDrag >= 0) {
                    // Allow a tap to scroll.
                    beginDrag();
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    scrollTo(pos);
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    if (mList != null) {
                        // ViewGroup does the right thing already, but there might
                        // be other classes that don't properly reset on touch-up,
                        // so do this explicitly just in case.
                        mList.requestDisallowInterceptTouchEvent(false);
                        mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                    setState(STATE_VISIBLE);
                    postAutoHide();
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_MOVE:
            {
                if (mPendingDrag >= 0 && Math.abs(me.getY() - mInitialTouchY) > mScaledTouchSlop) {
                    beginDrag();
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    // TODO: Ignore jitter.
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    // If the previous scrollTo is still pending
                    if (mScrollCompleted) {
                        scrollTo(pos);
                    }
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            {
                cancelPendingDrag();
            }
            break;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The boolean member variable `mHasPendingDrag` was replaced with the integer member variable `mPendingDrag`. In the `MotionEvent.ACTION_UP` case, a condition was reduced from `if (mHasPendingDrag)` to `if (mPendingDrag >= 0)`, indicating a change in condition logic. In the `MotionEvent.ACTION_MOVE` case, a similar condition `if (mHasPendingDrag && ...)` was replaced with `if (mPendingDrag >= 0 && ...)`. Outside of the condition, the ""cancelPendingDrag()"" and ""setState(STATE_DRAGGING)"" calls are also removed. These changes represent both a control dependency change (3), as the conditions under which procedural code executes have changed, and an other statement changed (4), due to the removal of the method calls inside the condition.","There is no Compatibility Issue because all the code paths that lead to different responses (returns or exceptions) are not altered in ways that would modify the behavior observed by the calling code. The conditions of returning a value have not been modified in the API, nor has exception handling. The internal state may change differently, but the observable behavior from an API standpoint remains consistent. Therefore, the changes do not lead to a Compatibility Issue."
772,"<android.widget.RemoteViews.SetDrawableParameters: void apply(View,ViewGroup,OnClickHandler)>",20,21,"<android.widget.RemoteViews.SetDrawableParameters: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetDrawableParameters: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Pick the correct drawable to modify for this view
    Drawable targetDrawable = null;
    if (targetBackground) {
        targetDrawable = target.getBackground();
    } else if (target instanceof ImageView) {
        ImageView imageView = (ImageView) target;
        targetDrawable = imageView.getDrawable();
    }
    if (targetDrawable != null) {
        // Perform modifications only if values are set correctly
        if (alpha != -1) {
            targetDrawable.setAlpha(alpha);
        }
        if (colorFilter != -1 && filterMode != null) {
            targetDrawable.setColorFilter(colorFilter, filterMode);
        }
        if (level != -1) {
            targetDrawable.setLevel(level);
        }
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Pick the correct drawable to modify for this view
    Drawable targetDrawable = null;
    if (targetBackground) {
        targetDrawable = target.getBackground();
    } else if (target instanceof ImageView) {
        ImageView imageView = (ImageView) target;
        targetDrawable = imageView.getDrawable();
    }
    if (targetDrawable != null) {
        // Perform modifications only if values are set correctly
        if (alpha != -1) {
            targetDrawable.setAlpha(alpha);
        }
        if (filterMode != null) {
            targetDrawable.setColorFilter(colorFilter, filterMode);
        }
        if (level != -1) {
            targetDrawable.setLevel(level);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The only change is the removal of the condition check for colorFilter != -1 in the 'if' statement, which means that setColorFilter will now be applied regardless of the value of colorFilter. This change can be considered a control dependency change, thus the code change type is 3.","However, the behavior when colorFilter is -1 has not been specified as an invalid state previously, and setColorFilter would have accepted it as a valid argument anyway, so calling it with -1 does not inherently lead to incorrect behavior. This leads to the conclusion that the behavior of the method is unchanged even though the condition under which setColorFilter is called is broader. Therefore, this change does not introduce a Compatibility Issue, which is 0."
774,<android.view.accessibility.AccessibilityNodeInfo: int getChildCount()>,20,21,<android.view.accessibility.AccessibilityNodeInfo: int getChildCount()>,<android.view.accessibility.AccessibilityNodeInfo: int getChildCount()>,0,"{
    return mChildNodeIds.size();
}","{
    return mChildNodeIds == null ? 0 : mChildNodeIds.size();
}",1,"/**
 * Gets the number of children.
 *
 * @return The child count.
 */
","/**
 * Gets the number of children.
 *
 * @return The child count.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement was altered to include a null check for `mChildNodeIds`. Previously, the size of `mChildNodeIds` was returned directly; in the late version, it checks for null and returns 0 if null or the size of `mChildNodeIds` otherwise, so the code change type is 1.","The inclusion of the null check for `mChildNodeIds` could result in a situation where the early version would throw a `NullPointerException` if `mChildNodeIds` were null, whereas the late version will return 0. This represents a behavioral change in how the method handles a null `mChildNodeIds`, leading to a potential difference in return value, so the CI type is 1."
776,"<android.appwidget.AppWidgetManager: void updateAppWidget(int[],RemoteViews)>",20,21,"<android.appwidget.AppWidgetManager: void updateAppWidget(int[],RemoteViews)>","<android.appwidget.AppWidgetManager: void updateAppWidget(int[],RemoteViews)>",0,"{
    try {
        sService.updateAppWidgetIds(appWidgetIds, views, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetIds(mPackageName, appWidgetIds, views);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Set the RemoteViews to use for the specified appWidgetIds.
 *
 * Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
 * contain a complete representation of the widget. For performing partial widget updates, see
 * {@link #partiallyUpdateAppWidget(int[], RemoteViews)}.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * The total Bitmap memory used by the RemoteViews object cannot exceed that required to
 * fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views         The RemoteViews object to show.
 */
","/**
 * Set the RemoteViews to use for the specified appWidgetIds.
 * <p>
 * Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
 * contain a complete representation of the widget. For performing partial widget updates, see
 * {@link #partiallyUpdateAppWidget(int[], RemoteViews)}.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * The total Bitmap memory used by the RemoteViews object cannot exceed that required to
 * fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
 *
 * @param appWidgetIds The AppWidget instances for which to set the RemoteViews.
 * @param views The RemoteViews object to show.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version of the implementation has introduced a null check for `mService`, which can cause an early return, and changes have also been made in the try block, altering the method called on the service object. These account for the control dependency changed type (3) and other statement changed type (4).","While there is a change in control flow and some method call on a service object, neither of these changes should cause different behavior with existing, correct input, as they do not affect the return type/values or exception handling of the method. The method signature remains void, and the exception thrown in both versions is the same. Therefore, there is no compatibility issue (pred_CI should be 0)."
777,"<android.content.AsyncTaskLoader: void dispatchOnLoadComplete(LoadTask,D)>",20,21,"<android.content.AsyncTaskLoader: void dispatchOnLoadComplete(LoadTask,D)>","<android.content.AsyncTaskLoader: void dispatchOnLoadComplete(LoadTask,D)>",0,"{
    if (mTask != task) {
        if (DEBUG)
            Slog.v(TAG, ""Load complete of old task, trying to cancel"");
        dispatchOnCancelled(task, data);
    } else {
        if (isAbandoned()) {
            // This cursor has been abandoned; just cancel the new data.
            onCanceled(data);
        } else {
            commitContentChanged();
            mLastLoadCompleteTime = SystemClock.uptimeMillis();
            mTask = null;
            if (DEBUG)
                Slog.v(TAG, ""Delivering result"");
            deliverResult(data);
        }
    }
}","{
    if (mTask != task) {
        if (DEBUG)
            Log.v(TAG, ""Load complete of old task, trying to cancel"");
        dispatchOnCancelled(task, data);
    } else {
        if (isAbandoned()) {
            // This cursor has been abandoned; just cancel the new data.
            onCanceled(data);
        } else {
            commitContentChanged();
            mLastLoadCompleteTime = SystemClock.uptimeMillis();
            mTask = null;
            if (DEBUG)
                Log.v(TAG, ""Delivering result"");
            deliverResult(data);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change observed is the use of Log.v instead of Slog.v. This does not affect the control flow nor the data flow of the method, hence the code change is only logging-related, which counts as an 'other statement changed', type 4.","The change from Slog.v to Log.v is merely a change in the logging mechanism and does not affect the return value or exception handling of the method. Therefore, there is no Compatibility Issue, CI type is 0."
778,"<android.webkit.WebView: void loadUrl(String,Map<String, String>)>",20,21,"<android.webkit.WebView: void loadUrl(String,Map<String, String>)>","<android.webkit.WebView: void loadUrl(String,Map<String, String>)>",0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""loadUrl(extra headers)="" + url);
    mProvider.loadUrl(url, additionalHttpHeaders);
}","{
    checkThread();
    if (DebugFlags.TRACE_API) {
        StringBuilder headers = new StringBuilder();
        if (additionalHttpHeaders != null) {
            for (Map.Entry<String, String> entry : additionalHttpHeaders.entrySet()) {
                headers.append(entry.getKey() + "":"" + entry.getValue() + ""\n"");
            }
        }
        Log.d(LOGTAG, ""loadUrl(extra headers)="" + url + ""\n"" + headers);
    }
    mProvider.loadUrl(url, additionalHttpHeaders);
}",1,"/**
 * Loads the given URL with the specified additional HTTP headers.
 *
 * @param url the URL of the resource to load
 * @param additionalHttpHeaders the additional headers to be used in the
 * HTTP request for this URL, specified as a map from name to
 * value. Note that if this map contains any of the headers
 * that are set by default by this WebView, such as those
 * controlling caching, accept types or the User-Agent, their
 * values may be overriden by this WebView's defaults.
 */
","/**
 * Loads the given URL with the specified additional HTTP headers.
 *
 * @param url the URL of the resource to load
 * @param additionalHttpHeaders the additional headers to be used in the
 * HTTP request for this URL, specified as a map from name to
 * value. Note that if this map contains any of the headers
 * that are set by default by this WebView, such as those
 * controlling caching, accept types or the User-Agent, their
 * values may be overriden by this WebView's defaults.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes in the method are limited to logging functionality with additional detail about the headers when the TRACE_API is true. No change has been made to the functional behaviour of the method. Therefore, the code change type is 4.","There are no changes in the return value, thrown exceptions, or the control flow of the method that could lead to compatibility issues. The modification is strictly for additional logging purposes and does not affect the method's outward contract or behaviour. Thus, there is no compatibility issue."
779,<android.widget.MediaController: boolean onTouchEvent(MotionEvent)>,20,21,<android.widget.MediaController: boolean onTouchEvent(MotionEvent)>,<android.widget.MediaController: boolean onTouchEvent(MotionEvent)>,0,"{
    show(sDefaultTimeout);
    return true;
}","{
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            // show until hide is called
            show(0);
            break;
        case MotionEvent.ACTION_UP:
            // start timeout
            show(sDefaultTimeout);
            break;
        case MotionEvent.ACTION_CANCEL:
            hide();
            break;
        default:
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The method's control flow has been altered to include a switch statement based on the action of the MotionEvent. This change is a control dependency change, so the code change type is 3.","The return value of the method has not been changed despite the addition of a control structure because the method always returns true regardless of the MotionEvent action processed. Consequently, there is no Compatibility Issue, and the CI type is 0."
780,<android.print.PrintManager: void restartPrintJob(PrintJobId)>,20,21,<android.print.PrintManager: void restartPrintJob(PrintJobId)>,<android.print.PrintManager: void restartPrintJob(PrintJobId)>,0,"{
    try {
        mService.restartPrintJob(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error restarting a print job: "" + printJobId, re);
    }
}","{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return;
    }
    try {
        mService.restartPrintJob(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error restarting a print job: "" + printJobId, re);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"An 'if' statement is added to check if mService is null before proceeding with the attempt to restart the print job, which is a change in control dependency, so the code change type is 3.","The introduction of the 'if' statement with a return does not lead to a Compatibility Issue, as this change would only prevent a method call on a null object and report a warning, which would improve robustness without modifying the observable behaviour for valid cases; hence, there is no change in potential exception throwing or return values in valid scenarios where mService is non-null. Thus, the CI type is 0."
782,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(ApplicationInfo)>,20,21,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(ApplicationInfo)>,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(ApplicationInfo)>,0,"{
    if (app.packageName.equals(""system"")) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    Resources r = mContext.mMainThread.getTopLevelResources(app.uid == Process.myUid() ? app.sourceDir : app.publicSourceDir, Display.DEFAULT_DISPLAY, null, mContext.mPackageInfo);
    if (r != null) {
        return r;
    }
    throw new NameNotFoundException(""Unable to open "" + app.publicSourceDir);
}","{
    if (app.packageName.equals(""system"")) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    final boolean sameUid = (app.uid == Process.myUid());
    Resources r = mContext.mMainThread.getTopLevelResources(sameUid ? app.sourceDir : app.publicSourceDir, sameUid ? app.splitSourceDirs : app.splitPublicSourceDirs, app.resourceDirs, app.sharedLibraryFiles, Display.DEFAULT_DISPLAY, null, mContext.mPackageInfo);
    if (r != null) {
        return r;
    }
    throw new NameNotFoundException(""Unable to open "" + app.publicSourceDir);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method implementation has changed to use an additional condition for determining the resource directories (sameUid ? app.splitSourceDirs : app.splitPublicSourceDirs, app.resourceDirs) and introduced a new local boolean variable `sameUid`, so the change types are 1, 4, and 5 due to both the assignment statements and the method signature changes in the `getTopLevelResources` call.","The API's return value is potentially different because of the new conditional logic introduced for the resource directories and the addition of new parameters to the `getTopLevelResources` method, resulting in CI type 1."
784,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,20,21,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,0,"{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean useDisplayListProperties = mView.mDisplayList != null;
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!useDisplayListProperties) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(false, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.mTransformationInfo.mMatrixDirty = true;
        if (!useDisplayListProperties) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}","{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}",1,"/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
","/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,The variable `useDisplayListProperties` was replaced by `hardwareAccelerated` and the parameter in the call `mView.invalidateViewProperty()` was altered accordingly. This represents changes in other statements (4) as well as a control dependency change due to the fact that `hardwareAccelerated` is used in a conditional check for invalidation (3).,"Despite the changes in variable naming and the conditions, the overall logic of the method remains consistent. The flow of the method and the conditions under which operations (like invalidations) happen are equivalent; they're just predicated on the new `hardwareAccelerated` condition. No change leads to a different return value or different exceptions being thrown since these conditions only affect internal state modifications and call parameters to other methods. Therefore, this should not lead to Compatibility Issues (0)."
785,"<android.preference.PreferenceActivity.HeaderAdapter: View getView(int,View,ViewGroup)>",20,21,"<android.preference.PreferenceActivity.HeaderAdapter: View getView(int,View,ViewGroup)>","<android.preference.PreferenceActivity.HeaderAdapter: View getView(int,View,ViewGroup)>",0,"{
    HeaderViewHolder holder;
    View view;
    if (convertView == null) {
        view = mInflater.inflate(com.android.internal.R.layout.preference_header_item, parent, false);
        holder = new HeaderViewHolder();
        holder.icon = (ImageView) view.findViewById(com.android.internal.R.id.icon);
        holder.title = (TextView) view.findViewById(com.android.internal.R.id.title);
        holder.summary = (TextView) view.findViewById(com.android.internal.R.id.summary);
        view.setTag(holder);
    } else {
        view = convertView;
        holder = (HeaderViewHolder) view.getTag();
    }
    // All view fields must be updated every time, because the view may be recycled
    Header header = getItem(position);
    holder.icon.setImageResource(header.iconRes);
    holder.title.setText(header.getTitle(getContext().getResources()));
    CharSequence summary = header.getSummary(getContext().getResources());
    if (!TextUtils.isEmpty(summary)) {
        holder.summary.setVisibility(View.VISIBLE);
        holder.summary.setText(summary);
    } else {
        holder.summary.setVisibility(View.GONE);
    }
    return view;
}","{
    HeaderViewHolder holder;
    View view;
    if (convertView == null) {
        view = mInflater.inflate(mLayoutResId, parent, false);
        holder = new HeaderViewHolder();
        holder.icon = (ImageView) view.findViewById(com.android.internal.R.id.icon);
        holder.title = (TextView) view.findViewById(com.android.internal.R.id.title);
        holder.summary = (TextView) view.findViewById(com.android.internal.R.id.summary);
        view.setTag(holder);
    } else {
        view = convertView;
        holder = (HeaderViewHolder) view.getTag();
    }
    // All view fields must be updated every time, because the view may be recycled
    Header header = getItem(position);
    if (mRemoveIconIfEmpty) {
        if (header.iconRes == 0) {
            holder.icon.setVisibility(View.GONE);
        } else {
            holder.icon.setVisibility(View.VISIBLE);
            holder.icon.setImageResource(header.iconRes);
        }
    } else {
        holder.icon.setImageResource(header.iconRes);
    }
    holder.title.setText(header.getTitle(getContext().getResources()));
    CharSequence summary = header.getSummary(getContext().getResources());
    if (!TextUtils.isEmpty(summary)) {
        holder.summary.setVisibility(View.VISIBLE);
        holder.summary.setText(summary);
    } else {
        holder.summary.setVisibility(View.GONE);
    }
    return view;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,There are changes to control dependencies (`if (mRemoveIconIfEmpty)`) and other statements (changing from inflate using `com.android.internal.R.layout.preference_header_item` to `mLayoutResId`). The code change types involved are 3 and 4.,"While the late version introduces additional control to check if the icon should be removed or made visible based on a new condition `mRemoveIconIfEmpty` and `header.iconRes`, (which is a control dependency change), and replaces a hardcoded resource ID with `mLayoutResId` (which is an other statement change), these changes do not alter the type or values returned by the method. Every code path still produces a `View` object, and additions are only modifying the view's properties (visibility and resources). Therefore, they don't lead to a Compatibility Issue."
790,"<android.os.Bundle: Byte getByte(String,byte)>",20,21,"<android.os.Bundle: Byte getByte(String,byte)>","<android.os.Bundle: Byte getByte(String,byte)>",0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (Byte) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Byte"", defaultValue, e);
        return defaultValue;
    }
}","{
    return super.getByte(key, defaultValue);
}",1,"/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a byte value
 */
","/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a byte value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The early version has a concrete implementation of the getByte method while the late version simply calls a superclass's getByte method. This represents a change in the method body which is not a control dependency change, return statement, or exception handling change, so this is an ""other statement"" change. It is also a dependent API change since it relies on the superclass's implementation now.","No Compatibility Issue is detected. Even though the implementation has changed to call the superclass method, the behavior of the method, in terms of what it returns (the byte value associated with a given key or the default value) and what exceptions it might throw, should remain consistent."
791,"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int[],int)>",20,21,"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int[],int)>","<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int[],int)>",0,"{
    try {
        sService.notifyAppWidgetViewDataChanged(appWidgetIds, viewId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.notifyAppWidgetViewDataChanged(mPackageName, appWidgetIds, viewId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Notifies the specified collection view in all the specified AppWidget instances
 * to invalidate their data.
 *
 * @param appWidgetIds  The AppWidget instances to notify of view data changes.
 * @param viewId        The collection view id.
 */
","/**
 * Notifies the specified collection view in all the specified AppWidget instances
 * to invalidate their data.
 *
 * @param appWidgetIds  The AppWidget instances to notify of view data changes.
 * @param viewId        The collection view id.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The late version introduces a new control statement, and the try block invokes a different method (mService.notifyAppWidgetViewDataChanged(mPackageName, appWidgetIds, viewId) instead of sService.notifyAppWidgetViewDataChanged(appWidgetIds, viewId, mContext.getUserId())), with different parameters. The catch block remains the same. The changes include an early return statement, a new control dependency (the new 'if' statement), and a change in dependent API; therefore, the change type is 1, 2, 3, 5.","Due to the introduction of a new return statement when mService is null, and a change in the dependent API that now requires a different set of parameters, this will likely lead to a different behavior. There might be cases where the early version threw an exception which now instead results in an early return, and the use of a different method with different parameters could affect the functionality. Both return values and exception handling have the potential to change, so the CI type is 1, 2."
793,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireExistingProvider(Context,String)>",20,21,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireExistingProvider(Context,String)>","<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireExistingProvider(Context,String)>",0,"{
    return mMainThread.acquireExistingProvider(context, auth, mUser.getIdentifier(), true);
}","{
    return mMainThread.acquireExistingProvider(context, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change involves passing different parameters to the `acquireExistingProvider` method: the `auth` parameter has been altered by introducing `getAuthorityWithoutUserId(auth)` and `resolveUserIdFromAuthority(auth)` in the late version. This indicates an altered way to process the 'auth' argument and resolve the user ID, considering these are utility method calls. The dependent API `acquireExistingProvider` remained the same, but the way parameters are prepared for the call changed, so the changes are classified as 4,5.","There is no Compatibility Issue detected because the return type and exception handling did not change. The change in how parameters are derived does not directly affect the output type or the exceptions thrown by this method, assuming that both `getAuthorityWithoutUserId(auth)` and `resolveUserIdFromAuthority(auth)` are backward-compatible helper methods intended to extract different parts of the 'auth' string for the same purpose as the original code."
796,<android.appwidget.AppWidgetHost: void startListening()>,20,21,<android.appwidget.AppWidgetHost: void startListening()>,<android.appwidget.AppWidgetHost: void startListening()>,0,"{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    final int userId = mContext.getUserId();
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        updatedIds = sService.startListening(mCallbacks, mPackageName, mHostId, updatedViews, userId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        if (updatedViews.get(i) != null) {
            updatedViews.get(i).setUser(new UserHandle(userId));
        }
        updateAppWidgetView(updatedIds[i], updatedViews.get(i), userId);
    }
}","{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContext.getOpPackageName(), mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}",1,"/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
","/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"There are several changes. The variable 'userId' and the setting of the user in updated views are removed. Instead of 'mContext.getUserId()' and 'mPackageName = mContext.getPackageName()', the late version uses 'mContext.getOpPackageName()' directly in the call to sService.startListening. Moreover, the parameters passed to 'sService.startListening' and 'updateAppWidgetView' have changed, which indicates API has been changed. But since they are correctly handled within the method itself and do not affect the method's contract, they are considered Other statement changed and Dependent API changed. There's control dependency change as well because the 'for' loop no longer includes a conditional check on whether each RemoteViews instance is null.",There should be no Compatibility Issue as the modifications within 'startListening' have been handled internally and the method signature remains the same without affecting the calling code. The for loop's behavior changed is not expected to cause a CI since it just removes a redundant check (RemoteViews should not be null after listening) and simplifies the user handling to an internal implementation detail with 'mContext.getOpPackageName()' which would not cause a different behavior observable to the callers of the API method.
799,"<android.os.Message: void writeToParcel(Parcel,int)>",20,21,"<android.os.Message: void writeToParcel(Parcel,int)>","<android.os.Message: void writeToParcel(Parcel,int)>",0,"{
    if (callback != null) {
        throw new RuntimeException(""Can't marshal callbacks across processes."");
    }
    dest.writeInt(what);
    dest.writeInt(arg1);
    dest.writeInt(arg2);
    if (obj != null) {
        try {
            Parcelable p = (Parcelable) obj;
            dest.writeInt(1);
            dest.writeParcelable(p, flags);
        } catch (ClassCastException e) {
            throw new RuntimeException(""Can't marshal non-Parcelable objects across processes."");
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeLong(when);
    dest.writeBundle(data);
    Messenger.writeMessengerOrNullToParcel(replyTo, dest);
}","{
    if (callback != null) {
        throw new RuntimeException(""Can't marshal callbacks across processes."");
    }
    dest.writeInt(what);
    dest.writeInt(arg1);
    dest.writeInt(arg2);
    if (obj != null) {
        try {
            Parcelable p = (Parcelable) obj;
            dest.writeInt(1);
            dest.writeParcelable(p, flags);
        } catch (ClassCastException e) {
            throw new RuntimeException(""Can't marshal non-Parcelable objects across processes."");
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeLong(when);
    dest.writeBundle(data);
    Messenger.writeMessengerOrNullToParcel(replyTo, dest);
    dest.writeInt(sendingUid);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The late version of the implementation includes an additional line of code, ""dest.writeInt(sendingUid);"", that writes an integer to the destination parcel. This is an 'Other statement changed' as it neither modifies return statements nor exception handling statements, nor does it introduce any change to control dependencies, so the code change type is 4.","The addition of writing an additional integer to the parcel means that the structure of the written data in the parcel has changed, which leads to a potential compatibility issue as the receiving end might expect the data to be in the previous format. This is a compatibility issue caused by potential different return values as the parcel being returned will contain different data, so the CI type is 1."
800,<android.widget.RemoteViews: RemoteViews clone()>,20,21,<android.widget.RemoteViews: RemoteViews clone()>,<android.widget.RemoteViews: RemoteViews clone()>,0,"{
    Parcel p = Parcel.obtain();
    writeToParcel(p, 0);
    p.setDataPosition(0);
    return new RemoteViews(p);
}","{
    Parcel p = Parcel.obtain();
    writeToParcel(p, 0);
    p.setDataPosition(0);
    RemoteViews rv = new RemoteViews(p);
    p.recycle();
    return rv;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call `p.recycle()` is added after creating the `RemoteViews` object but before returning it, so the change type is 4.","The addition of `p.recycle()` does not affect the returned value or change the exception handling. It's simply a good practice to clean up the `Parcel` object after it's been used. Hence, there's no Compatibility Issue, as the behavior of `clone()` method in terms of what it returns or any exceptions it might throw remains the same; so, the CI type is 0."
801,<android.preference.PreferenceActivity: void onCreate(Bundle)>,20,21,<android.preference.PreferenceActivity: void onCreate(Bundle)>,<android.preference.PreferenceActivity: void onCreate(Bundle)>,0,"{
    super.onCreate(savedInstanceState);
    setContentView(com.android.internal.R.layout.preference_list_content);
    mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
    mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs_frame);
    boolean hidingHeaders = onIsHidingHeaders();
    mSinglePane = hidingHeaders || !onIsMultiPane();
    String initialFragment = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT);
    Bundle initialArguments = getIntent().getBundleExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS);
    int initialTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_TITLE, 0);
    int initialShortTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_SHORT_TITLE, 0);
    if (savedInstanceState != null) {
        // We are restarting from a previous saved state; used that to
        // initialize, instead of starting fresh.
        ArrayList<Header> headers = savedInstanceState.getParcelableArrayList(HEADERS_TAG);
        if (headers != null) {
            mHeaders.addAll(headers);
            int curHeader = savedInstanceState.getInt(CUR_HEADER_TAG, (int) HEADER_ID_UNDEFINED);
            if (curHeader >= 0 && curHeader < mHeaders.size()) {
                setSelectedHeader(mHeaders.get(curHeader));
            }
        }
    } else {
        if (initialFragment != null && mSinglePane) {
            // If we are just showing a fragment, we want to run in
            // new fragment mode, but don't need to compute and show
            // the headers.
            switchToHeader(initialFragment, initialArguments);
            if (initialTitle != 0) {
                CharSequence initialTitleStr = getText(initialTitle);
                CharSequence initialShortTitleStr = initialShortTitle != 0 ? getText(initialShortTitle) : null;
                showBreadCrumbs(initialTitleStr, initialShortTitleStr);
            }
        } else {
            // We need to try to build the headers.
            onBuildHeaders(mHeaders);
            // the currently selected preference fragment.
            if (mHeaders.size() > 0) {
                if (!mSinglePane) {
                    if (initialFragment == null) {
                        Header h = onGetInitialHeader();
                        switchToHeader(h);
                    } else {
                        switchToHeader(initialFragment, initialArguments);
                    }
                }
            }
        }
    }
    // visibility for other configurations.
    if (initialFragment != null && mSinglePane) {
        // Single pane, showing just a prefs fragment.
        findViewById(com.android.internal.R.id.headers).setVisibility(View.GONE);
        mPrefsContainer.setVisibility(View.VISIBLE);
        if (initialTitle != 0) {
            CharSequence initialTitleStr = getText(initialTitle);
            CharSequence initialShortTitleStr = initialShortTitle != 0 ? getText(initialShortTitle) : null;
            showBreadCrumbs(initialTitleStr, initialShortTitleStr);
        }
    } else if (mHeaders.size() > 0) {
        setListAdapter(new HeaderAdapter(this, mHeaders));
        if (!mSinglePane) {
            // Multi-pane.
            getListView().setChoiceMode(AbsListView.CHOICE_MODE_SINGLE);
            if (mCurHeader != null) {
                setSelectedHeader(mCurHeader);
            }
            mPrefsContainer.setVisibility(View.VISIBLE);
        }
    } else {
        // If there are no headers, we are in the old ""just show a screen
        // of preferences"" mode.
        setContentView(com.android.internal.R.layout.preference_list_content_single);
        mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
        mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs);
        mPreferenceManager = new PreferenceManager(this, FIRST_REQUEST_CODE);
        mPreferenceManager.setOnPreferenceTreeClickListener(this);
    }
    // see if we should show Back/Next buttons
    Intent intent = getIntent();
    if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_BUTTON_BAR, false)) {
        findViewById(com.android.internal.R.id.button_bar).setVisibility(View.VISIBLE);
        Button backButton = (Button) findViewById(com.android.internal.R.id.back_button);
        backButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_CANCELED);
                finish();
            }
        });
        Button skipButton = (Button) findViewById(com.android.internal.R.id.skip_button);
        skipButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        mNextButton = (Button) findViewById(com.android.internal.R.id.next_button);
        mNextButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        // set our various button parameters
        if (intent.hasExtra(EXTRA_PREFS_SET_NEXT_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_NEXT_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                mNextButton.setVisibility(View.GONE);
            } else {
                mNextButton.setText(buttonText);
            }
        }
        if (intent.hasExtra(EXTRA_PREFS_SET_BACK_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_BACK_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                backButton.setVisibility(View.GONE);
            } else {
                backButton.setText(buttonText);
            }
        }
        if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_SKIP, false)) {
            skipButton.setVisibility(View.VISIBLE);
        }
    }
}","{
    super.onCreate(savedInstanceState);
    // Theming for the PreferenceActivity layout and for the Preference Header(s) layout
    TypedArray sa = obtainStyledAttributes(null, com.android.internal.R.styleable.PreferenceActivity, com.android.internal.R.attr.preferenceActivityStyle, 0);
    final int layoutResId = sa.getResourceId(com.android.internal.R.styleable.PreferenceActivity_layout, com.android.internal.R.layout.preference_list_content);
    mPreferenceHeaderItemResId = sa.getResourceId(com.android.internal.R.styleable.PreferenceActivity_headerLayout, com.android.internal.R.layout.preference_header_item);
    mPreferenceHeaderRemoveEmptyIcon = sa.getBoolean(com.android.internal.R.styleable.PreferenceActivity_headerRemoveIconIfEmpty, false);
    sa.recycle();
    setContentView(layoutResId);
    mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
    mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs_frame);
    boolean hidingHeaders = onIsHidingHeaders();
    mSinglePane = hidingHeaders || !onIsMultiPane();
    String initialFragment = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT);
    Bundle initialArguments = getIntent().getBundleExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS);
    int initialTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_TITLE, 0);
    int initialShortTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_SHORT_TITLE, 0);
    if (savedInstanceState != null) {
        // We are restarting from a previous saved state; used that to
        // initialize, instead of starting fresh.
        ArrayList<Header> headers = savedInstanceState.getParcelableArrayList(HEADERS_TAG);
        if (headers != null) {
            mHeaders.addAll(headers);
            int curHeader = savedInstanceState.getInt(CUR_HEADER_TAG, (int) HEADER_ID_UNDEFINED);
            if (curHeader >= 0 && curHeader < mHeaders.size()) {
                setSelectedHeader(mHeaders.get(curHeader));
            }
        }
    } else {
        if (initialFragment != null && mSinglePane) {
            // If we are just showing a fragment, we want to run in
            // new fragment mode, but don't need to compute and show
            // the headers.
            switchToHeader(initialFragment, initialArguments);
            if (initialTitle != 0) {
                CharSequence initialTitleStr = getText(initialTitle);
                CharSequence initialShortTitleStr = initialShortTitle != 0 ? getText(initialShortTitle) : null;
                showBreadCrumbs(initialTitleStr, initialShortTitleStr);
            }
        } else {
            // We need to try to build the headers.
            onBuildHeaders(mHeaders);
            // the currently selected preference fragment.
            if (mHeaders.size() > 0) {
                if (!mSinglePane) {
                    if (initialFragment == null) {
                        Header h = onGetInitialHeader();
                        switchToHeader(h);
                    } else {
                        switchToHeader(initialFragment, initialArguments);
                    }
                }
            }
        }
    }
    // visibility for other configurations.
    if (initialFragment != null && mSinglePane) {
        // Single pane, showing just a prefs fragment.
        findViewById(com.android.internal.R.id.headers).setVisibility(View.GONE);
        mPrefsContainer.setVisibility(View.VISIBLE);
        if (initialTitle != 0) {
            CharSequence initialTitleStr = getText(initialTitle);
            CharSequence initialShortTitleStr = initialShortTitle != 0 ? getText(initialShortTitle) : null;
            showBreadCrumbs(initialTitleStr, initialShortTitleStr);
        }
    } else if (mHeaders.size() > 0) {
        setListAdapter(new HeaderAdapter(this, mHeaders, mPreferenceHeaderItemResId, mPreferenceHeaderRemoveEmptyIcon));
        if (!mSinglePane) {
            // Multi-pane.
            getListView().setChoiceMode(AbsListView.CHOICE_MODE_SINGLE);
            if (mCurHeader != null) {
                setSelectedHeader(mCurHeader);
            }
            mPrefsContainer.setVisibility(View.VISIBLE);
        }
    } else {
        // If there are no headers, we are in the old ""just show a screen
        // of preferences"" mode.
        setContentView(com.android.internal.R.layout.preference_list_content_single);
        mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
        mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs);
        mPreferenceManager = new PreferenceManager(this, FIRST_REQUEST_CODE);
        mPreferenceManager.setOnPreferenceTreeClickListener(this);
    }
    // see if we should show Back/Next buttons
    Intent intent = getIntent();
    if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_BUTTON_BAR, false)) {
        findViewById(com.android.internal.R.id.button_bar).setVisibility(View.VISIBLE);
        Button backButton = (Button) findViewById(com.android.internal.R.id.back_button);
        backButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_CANCELED);
                finish();
            }
        });
        Button skipButton = (Button) findViewById(com.android.internal.R.id.skip_button);
        skipButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        mNextButton = (Button) findViewById(com.android.internal.R.id.next_button);
        mNextButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        // set our various button parameters
        if (intent.hasExtra(EXTRA_PREFS_SET_NEXT_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_NEXT_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                mNextButton.setVisibility(View.GONE);
            } else {
                mNextButton.setText(buttonText);
            }
        }
        if (intent.hasExtra(EXTRA_PREFS_SET_BACK_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_BACK_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                backButton.setVisibility(View.GONE);
            } else {
                backButton.setText(buttonText);
            }
        }
        if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_SKIP, false)) {
            skipButton.setVisibility(View.VISIBLE);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
804,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",20,21,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",0,"{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    if ((flags & GET_SIGNATURES) != 0) {
        packageParser.collectCertificates(pkg, 0);
    }
    PackageUserState state = new PackageUserState();
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
}","{
    final PackageParser parser = new PackageParser();
    final File apkFile = new File(archiveFilePath);
    try {
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            parser.collectCertificates(pkg, 0);
            parser.collectManifestDigest(pkg);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}",1,"/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
","/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"Method implementations have changed: the way the parser is created (new PackageParser(archiveFilePath) vs new PackageParser()), the method used for parsing the package (parsePackage() vs parseMonolithicPackage()), the way certificates are collected (additionally collecting manifest digest in the late version), and added exception handling for PackageParserException. These changes correspond to control dependency changes (3), other statement changes (4), and changes in dependent APIs (PackageParser and its methods) (5).","The late version introduces exception handling for `PackageParserException` which isn't present in the early version. If this exception is thrown, the method would now catch it and return null, while previously it would have propagated the exception, representing a change in behavior. Also, different parsing methods and additional certificate and manifest digest collection potentially change the returned `PackageInfo` value. Therefore, a CI could arise from potentially different return values or types (1)."
807,<android.content.pm.ResolveInfo: String toString()>,20,21,<android.content.pm.ResolveInfo: String toString()>,<android.content.pm.ResolveInfo: String toString()>,0,"{
    final ComponentInfo ci = getComponentInfo();
    StringBuilder sb = new StringBuilder(128);
    sb.append(""ResolveInfo{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append(' ');
    ComponentName.appendShortString(sb, ci.packageName, ci.name);
    if (priority != 0) {
        sb.append("" p="");
        sb.append(priority);
    }
    if (preferredOrder != 0) {
        sb.append("" o="");
        sb.append(preferredOrder);
    }
    sb.append("" m=0x"");
    sb.append(Integer.toHexString(match));
    sb.append('}');
    return sb.toString();
}","{
    final ComponentInfo ci = getComponentInfo();
    StringBuilder sb = new StringBuilder(128);
    sb.append(""ResolveInfo{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append(' ');
    ComponentName.appendShortString(sb, ci.packageName, ci.name);
    if (priority != 0) {
        sb.append("" p="");
        sb.append(priority);
    }
    if (preferredOrder != 0) {
        sb.append("" o="");
        sb.append(preferredOrder);
    }
    sb.append("" m=0x"");
    sb.append(Integer.toHexString(match));
    if (targetUserId != UserHandle.USER_CURRENT) {
        sb.append("" targetUserId="");
        sb.append(targetUserId);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A conditional block has been added to include `targetUserId` in the `StringBuilder` output only if it is not equal to `UserHandle.USER_CURRENT`. There is no other change observed, so the code change type is 4.","The change only affects the string representation of `ResolveInfo` but does not affect any behaviors related to the logic, the return type, or cause the method to throw a new exception. Since `toString` methods are typically used for debugging rather than logic, this should not affect code compatibility, hence no Compatibility Issue detected, CI type is 0."
808,"<android.widget.AdapterView: boolean performItemClick(View,int,long)>",20,21,"<android.widget.AdapterView: boolean performItemClick(View,int,long)>","<android.widget.AdapterView: boolean performItemClick(View,int,long)>",0,"{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        if (view != null) {
            view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        }
        mOnItemClickListener.onItemClick(this, view, position, id);
        return true;
    }
    return false;
}","{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        mOnItemClickListener.onItemClick(this, view, position, id);
        if (view != null) {
            view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        }
        return true;
    }
    return false;
}",1,"/**
 * Call the OnItemClickListener, if it is defined. Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */
","/**
 * Call the OnItemClickListener, if it is defined. Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The position of the statement `view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);` has changed, resulting in a change to the control dependency.","Despite the change in the order of statements within the method, there is no impact on the return value or the exceptions thrown by the method. The method's contract remains the same, and it will always return `true` when `mOnItemClickListener` is not `null` and `false` otherwise, regardless of the order in which `view.sendAccessibilityEvent` is called. Hence, there is no Compatibility Issue."
811,<android.animation.ObjectAnimator: String toString()>,20,21,<android.animation.ObjectAnimator: String toString()>,<android.animation.ObjectAnimator: String toString()>,0,"{
    String returnVal = ""ObjectAnimator@"" + Integer.toHexString(hashCode()) + "", target "" + mTarget;
    if (mValues != null) {
        for (int i = 0; i < mValues.length; ++i) {
            returnVal += ""\n    "" + mValues[i].toString();
        }
    }
    return returnVal;
}","{
    String returnVal = ""ObjectAnimator@"" + Integer.toHexString(hashCode()) + "", target "" + getTarget();
    if (mValues != null) {
        for (int i = 0; i < mValues.length; ++i) {
            returnVal += ""\n    "" + mValues[i].toString();
        }
    }
    return returnVal;
}",1,,,-1,[@Override],"[@Override, @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation has changed from using the field ""mTarget"" to calling method getTarget(). This is considered as a change in the implementation involving a dependent API, hence the change types are 4 and 5.","The use of a getter method (getTarget()) instead of direct field access could lead to a different return value if the getter method is overridden or behaves differently from just returning the field, which constitutes a compatibility issue of type 1."
812,"<android.content.res.TypedArray: int getResourceId(int,int)>",20,21,"<android.content.res.TypedArray: int getResourceId(int,int)>","<android.content.res.TypedArray: int getResourceId(int,int)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + AssetManager.STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + AssetManager.STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}",1,"/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */
","/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new control statement 'if (mRecycled)' and a new exception throwing statement 'throw new RuntimeException' have been introduced, so the code change type is 2,3.","The introduced 'if' statement with the 'throw new RuntimeException' constitutes a new exception handling mechanism which wasn't present in the early version. As a result, the late version API can throw a new exception that would not have been thrown in the early version. This results in a potential different exception handling, making the CI type as 2."
815,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",20,21,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",0,"{
    final int userId = mContext.getUserId();
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setUserId(userId);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(appWidgetId, userId);
        if (views != null) {
            views.setUser(new UserHandle(mContext.getUserId()));
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}","{
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContext.getOpPackageName(), appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}",1,"/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
","/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,The following changes have been made in the late implementation:,- `views.setUser(new UserHandle(mContext.getUserId()));` line has been removed which previously was setting the user for the `views`.
817,<android.content.res.TypedArray: CharSequence getText(int)>,20,21,<android.content.res.TypedArray: CharSequence getText(int)>,<android.content.res.TypedArray: CharSequence getText(int)>,0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to string: "" + v);
        return v.coerceToString();
    }
    Log.w(Resources.TAG, ""getString of bad type: 0x"" + Integer.toHexString(type));
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to string: "" + v);
        return v.coerceToString();
    }
    Log.w(Resources.TAG, ""getString of bad type: 0x"" + Integer.toHexString(type));
    return null;
}",1,"/**
 * Retrieve the styled string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data.  May be styled.  Returns
 * null if the attribute is not defined.
 */
","/**
 * Retrieve the styled string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data.  May be styled.  Returns
 * null if the attribute is not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An exception handling statement has been added to check if the instance has been recycled before proceeding. Additionally, there is a control dependency change, as the introduced exception handling is within its own if block, affecting subsequent execution. Thus, the code change types are 2,3.","The newly introduced throw statement could result in different exception handling, potentially leading to a RuntimeException being thrown when the instance is recycled, which would not have occurred in the earlier version. Hence, a CI is present, of type 2."
818,<android.view.accessibility.AccessibilityManager: boolean addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,20,21,<android.view.accessibility.AccessibilityManager: boolean addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,0,"{
    return mTouchExplorationStateChangeListeners.add(listener);
}","{
    // Final CopyOnArrayList - no lock needed.
    return mTouchExplorationStateChangeListeners.add(listener);
}",1,"/**
 * Registers a {@link TouchExplorationStateChangeListener} for changes in
 * the global touch exploration state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
","/**
 * Registers a {@link TouchExplorationStateChangeListener} for changes in
 * the global touch exploration state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The logic of the method has not changed; only a comment has been added. Therefore, the code change is categorized as 4 (comment changes are typically considered as 'Other statement changed').","The addition of a comment does not alter the function's behavior, return values, or types, nor does it affect exception handling. Thus, there is no Compatibility Issue."
819,"<android.app.FragmentManagerImpl: Fragment getFragment(Bundle,String)>",20,21,"<android.app.FragmentManagerImpl: Fragment getFragment(Bundle,String)>","<android.app.FragmentManagerImpl: Fragment getFragment(Bundle,String)>",0,"{
    int index = bundle.getInt(key, -1);
    if (index == -1) {
        return null;
    }
    if (index >= mActive.size()) {
        throwException(new IllegalStateException(""Fragement no longer exists for key "" + key + "": index "" + index));
    }
    Fragment f = mActive.get(index);
    if (f == null) {
        throwException(new IllegalStateException(""Fragement no longer exists for key "" + key + "": index "" + index));
    }
    return f;
}","{
    int index = bundle.getInt(key, -1);
    if (index == -1) {
        return null;
    }
    if (index >= mActive.size()) {
        throwException(new IllegalStateException(""Fragment no longer exists for key "" + key + "": index "" + index));
    }
    Fragment f = mActive.get(index);
    if (f == null) {
        throwException(new IllegalStateException(""Fragment no longer exists for key "" + key + "": index "" + index));
    }
    return f;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no change in the actual implementation code between the two versions. The only difference is in the spelling of the word ""Fragement"" which is corrected to ""Fragment"" in the exception message text, but this does not affect the behavior of the method.","Since there is no functional code change, there is no Compatibility Issue between the two versions."
821,<android.widget.RemoteViewsAdapter.RemoteViewsCacheKey: boolean equals(Object)>,20,21,<android.widget.RemoteViewsAdapter.RemoteViewsCacheKey: boolean equals(Object)>,<android.widget.RemoteViewsAdapter.RemoteViewsCacheKey: boolean equals(Object)>,0,"{
    if (!(o instanceof RemoteViewsCacheKey)) {
        return false;
    }
    RemoteViewsCacheKey other = (RemoteViewsCacheKey) o;
    return other.filter.equals(filter) && other.widgetId == widgetId && other.userId == userId;
}","{
    if (!(o instanceof RemoteViewsCacheKey)) {
        return false;
    }
    RemoteViewsCacheKey other = (RemoteViewsCacheKey) o;
    return other.filter.equals(filter) && other.widgetId == widgetId;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The equals method has been changed to no longer consider the userId field for equality. Therefore, the method could return a different value in the late version which makes the change type 1.","Given that the implementation no longer compares the userId field, the equals() method could potentially return true for objects that would have returned false previously when the userIds are different, which may lead to unexpected behavior in client code. Thus, this is a Compatibility Issue of type 1 caused by potential different return values."
822,<android.provider.DocumentsContract: String getDocumentId(Uri)>,20,21,<android.provider.DocumentsContract: String getDocumentId(Uri)>,<android.provider.DocumentsContract: String getDocumentId(Uri)>,0,"{
    final List<String> paths = documentUri.getPathSegments();
    if (paths.size() < 2) {
        throw new IllegalArgumentException(""Not a document: "" + documentUri);
    }
    if (!PATH_DOCUMENT.equals(paths.get(0))) {
        throw new IllegalArgumentException(""Not a document: "" + documentUri);
    }
    return paths.get(1);
}","{
    final List<String> paths = documentUri.getPathSegments();
    if (paths.size() >= 2 && PATH_DOCUMENT.equals(paths.get(0))) {
        return paths.get(1);
    }
    if (paths.size() >= 4 && PATH_TREE.equals(paths.get(0)) && PATH_DOCUMENT.equals(paths.get(2))) {
        return paths.get(3);
    }
    throw new IllegalArgumentException(""Invalid URI: "" + documentUri);
}",1,"/**
 * Extract the {@link Document#COLUMN_DOCUMENT_ID} from the given URI.
 */
","/**
 * Extract the {@link Document#COLUMN_DOCUMENT_ID} from the given URI.
 *
 * @see #isDocumentUri(Context, Uri)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3","1,2","The return statement and control dependency have changed. In the early implementation, there are two conditions that could throw exceptions, and if none are met, the method returns a value. In the late implementation, the structure has changed to return inside the conditions and throw an exception at the end if neither condition is met. This structural change in control flow (adding additional return conditions) is therefore both a change in control dependency (3) as well as a change in return statement (1).","The changes can lead to different behaviors. In the late version, an additional conditional check allows for another potential return statement. Since the logic to throw exceptions has also been altered, where previously a condition was checked individually and an exception was thrown, the late version introduces a different exception message thrown if neither condition is met, leading to both a potential different return value or type (1) and different exception handling (2)."
823,<android.view.ContextThemeWrapper: Object getSystemService(String)>,20,21,<android.view.ContextThemeWrapper: Object getSystemService(String)>,<android.view.ContextThemeWrapper: Object getSystemService(String)>,0,"{
    if (LAYOUT_INFLATER_SERVICE.equals(name)) {
        if (mInflater == null) {
            mInflater = LayoutInflater.from(mBase).cloneInContext(this);
        }
        return mInflater;
    }
    return mBase.getSystemService(name);
}","{
    if (LAYOUT_INFLATER_SERVICE.equals(name)) {
        if (mInflater == null) {
            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);
        }
        return mInflater;
    }
    return getBaseContext().getSystemService(name);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes replacing `mBase` with the method `getBaseContext()` for both the LayoutInflater creation and the final return statement. This is a change in the implementation details where the API for getting the context base is updated, so the types of changes are 4 and 5.","There is no Compatibility Issue as the object being returned is still the same type and the method behavior remains consistent. The replacement of `mBase` with `getBaseContext()` does not inherently affect the return type or values, nor does it change exception handling. Hence there is no potential different return values or exception handlings caused by this refactoring, and it does not lead to a CI."
824,"<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>",20,21,"<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>","<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>",0,"{
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
}","{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    int total = dest.dataPosition() - start;
    if (total > 20 * 1024) {
        Slog.d(""Error"", ""ERR: exClass="" + exceptionClassName);
        Slog.d(""Error"", ""ERR: exMsg="" + exceptionMessage);
        Slog.d(""Error"", ""ERR: file="" + throwFileName);
        Slog.d(""Error"", ""ERR: class="" + throwClassName);
        Slog.d(""Error"", ""ERR: method="" + throwMethodName + "" line="" + throwLineNumber);
        Slog.d(""Error"", ""ERR: stack="" + stackTrace);
        Slog.d(""Error"", ""ERR: TOTAL BYTES WRITTEN: "" + (dest.dataPosition() - start));
    }
}",1,"/**
 * Save a CrashInfo instance to a parcel.
 */
","/**
 * Save a CrashInfo instance to a parcel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces an additional calculation for total bytes written to the `Parcel` object and logging if the total exceeds a certain size. This logging does not modify the behavior of `writeToParcel` method in terms of the data written to the destination Parcel, but it does add additional control dependency on the size of the data written. Therefore, the changes include ""Other statement changed"" 4, as well as ""Control dependency changed"" 3 because of the newly introduced if condition.","There is no Compatibility Issue, because the method's functionality (writing data to the Parcel) remains unchanged. The added code only performs additional logging and does not affect the data being sent via the Parcel. Therefore, any code relying on the `writeToParcel` method will continue to operate as before without any changes in the API's external behavior. Thus, there is no impact on compatibility, and the CI is classified as 0."
825,<android.widget.NumberPicker: void onDraw(Canvas)>,20,21,<android.widget.NumberPicker: void onDraw(Canvas)>,<android.widget.NumberPicker: void onDraw(Canvas)>,0,"{
    if (!mHasSelectorWheel) {
        super.onDraw(canvas);
        return;
    }
    float x = (mRight - mLeft) / 2;
    float y = mCurrentScrollOffset;
    // draw the virtual buttons pressed state if needed
    if (mVirtualButtonPressedDrawable != null && mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
        if (mDecrementVirtualButtonPressed) {
            mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
            mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop);
            mVirtualButtonPressedDrawable.draw(canvas);
        }
        if (mIncrementVirtualButtonPressed) {
            mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
            mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight, mBottom);
            mVirtualButtonPressedDrawable.draw(canvas);
        }
    }
    // draw the selector wheel
    int[] selectorIndices = mSelectorIndices;
    for (int i = 0; i < selectorIndices.length; i++) {
        int selectorIndex = selectorIndices[i];
        String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
        // with the new one.
        if (i != SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() != VISIBLE) {
            canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
        }
        y += mSelectorElementHeight;
    }
    // draw the selection dividers
    if (mSelectionDivider != null) {
        // draw the top divider
        int topOfTopDivider = mTopSelectionDividerTop;
        int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
        mSelectionDivider.draw(canvas);
        // draw the bottom divider
        int bottomOfBottomDivider = mBottomSelectionDividerBottom;
        int topOfBottomDivider = bottomOfBottomDivider - mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
        mSelectionDivider.draw(canvas);
    }
}","{
    if (!mHasSelectorWheel) {
        super.onDraw(canvas);
        return;
    }
    final boolean showSelectorWheel = mHideWheelUntilFocused ? hasFocus() : true;
    float x = (mRight - mLeft) / 2;
    float y = mCurrentScrollOffset;
    // draw the virtual buttons pressed state if needed
    if (showSelectorWheel && mVirtualButtonPressedDrawable != null && mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
        if (mDecrementVirtualButtonPressed) {
            mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
            mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop);
            mVirtualButtonPressedDrawable.draw(canvas);
        }
        if (mIncrementVirtualButtonPressed) {
            mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
            mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight, mBottom);
            mVirtualButtonPressedDrawable.draw(canvas);
        }
    }
    // draw the selector wheel
    int[] selectorIndices = mSelectorIndices;
    for (int i = 0; i < selectorIndices.length; i++) {
        int selectorIndex = selectorIndices[i];
        String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
        // with the new one.
        if ((showSelectorWheel && i != SELECTOR_MIDDLE_ITEM_INDEX) || (i == SELECTOR_MIDDLE_ITEM_INDEX && mInputText.getVisibility() != VISIBLE)) {
            canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
        }
        y += mSelectorElementHeight;
    }
    // draw the selection dividers
    if (showSelectorWheel && mSelectionDivider != null) {
        // draw the top divider
        int topOfTopDivider = mTopSelectionDividerTop;
        int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
        mSelectionDivider.draw(canvas);
        // draw the bottom divider
        int bottomOfBottomDivider = mBottomSelectionDividerBottom;
        int topOfBottomDivider = bottomOfBottomDivider - mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
        mSelectionDivider.draw(canvas);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed by adding a new local boolean variable `showSelectorWheel` to determine if the selector wheel should be shown. This variable is involved in the condition within the existing `if` statement and new `if` statements. Therefore, the code change type is 3.","The introduction of the `showSelectorWheel` variable only affects the display logic based on whether the view should show the selector wheel or not, which depends on the focus state of the view. Since `onDraw` is a void method, there is no change in the return type or value and no exceptions are thrown or handled differently as a result of this change. As the changes do not affect the API's behavior in a way that would produce different outcomes for the method's execution, there is no Compatibility Issue."
827,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,20,21,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,0,"{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, ""WARNING: Surface's mNativeObject (0x"" + Integer.toHexString(mNativeObject) + "") != mLockedObject (0x"" + Integer.toHexString(mLockedObject) + "")"");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException(""Surface was not locked"");
        }
        nativeUnlockCanvasAndPost(mLockedObject, canvas);
        nativeRelease(mLockedObject);
        mLockedObject = 0;
    }
}","{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, ""WARNING: Surface's mNativeObject (0x"" + Long.toHexString(mNativeObject) + "") != mLockedObject (0x"" + Long.toHexString(mLockedObject) + "")"");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException(""Surface was not locked"");
        }
        try {
            nativeUnlockCanvasAndPost(mLockedObject, canvas);
        } finally {
            nativeRelease(mLockedObject);
            mLockedObject = 0;
        }
    }
}",1,"/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */
","/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"An ""Integer.toHexString()"" method has been changed to ""Long.toHexString()"" and a try-finally block has been added around ""nativeUnlockCanvasAndPost()"" method call, so the code change types are 3,4.","The addition of a try-finally block and the change from ""Integer.toHexString()"" to ""Long.toHexString()"" do not alter the API's behavior in terms of return values or exceptions that could be thrown by the API, as all paths leading to a thrown exception or a return are unchanged. These alterations merely deal with the implementation details to ensure the proper release of the resource and format the log message correctly. Hence, there is no Compatibility Issue."
828,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,20,21,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,0,"{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, ""strict mode violation stacks read from binder call.  i="" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        info.crashInfo.stackTrace += ""# via Binder call with stack:\n"" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}","{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, ""strict mode violation stacks read from binder call.  i="" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
            String front = info.crashInfo.stackTrace.substring(256);
            // First, drain the remaining violations from the parcel.
            while (i < numViolations) {
                info = new ViolationInfo(p, !currentlyGathering);
                i++;
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, ""Stack is too large: numViolations="" + numViolations + "" policy=#"" + Integer.toHexString(policyMask) + "" front="" + front);
            return;
        }
        info.crashInfo.stackTrace += ""# via Binder call with stack:\n"" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The late version introduces new control flow with an if-statement that checks the length of `info.crashInfo.stackTrace`, including a new piece of logic that involves string manipulation, iterating over the remaining violations, clearing out all gathered violations, and a new early exit from the method with a return statement. Therefore, the change includes a new control dependency, an other statement changed due to the additional string operation and a logic change in how violations are handled, and a new return statement, which accounts for the changes 1,3,4.","With the addition of the new if-statement and early return, there's a possibility for a different return path which was not present previously, potentially leading to a different return value or type, and the new exception (`Slog.wtfStack`) that wasn't there before also introduces a potential different exception handling. Hence, the potential CI caused would be of type 1,2."
829,<android.content.res.TypedArray: String getNonResourceString(int)>,20,21,<android.content.res.TypedArray: String getNonResourceString(int)>,<android.content.res.TypedArray: String getNonResourceString(int)>,0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + AssetManager.STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + AssetManager.STYLE_DATA]).toString();
        }
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + AssetManager.STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + AssetManager.STYLE_DATA]).toString();
        }
    }
    return null;
}",1,"/**
 * Retrieve the string value for the attribute at <var>index</var>, but
 * only if that string comes from an immediate value in an XML file.  That
 * is, this does not allow references to string resources, string
 * attributes, or conversions from other types.  As such, this method
 * will only return strings for TypedArray objects that come from
 * attributes in an XML file.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined or is not
 * an immediate string value.
 */
","/**
 * Retrieve the string value for the attribute at <var>index</var>, but
 * only if that string comes from an immediate value in an XML file.  That
 * is, this does not allow references to string resources, string
 * attributes, or conversions from other types.  As such, this method
 * will only return strings for TypedArray objects that come from
 * attributes in an XML file.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined or is not
 * an immediate string value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The early implementation does not check if the TypedArray has been recycled, while the late implementation does check and potentially throws a RuntimeException if mRecycled is true. A new exception handling statement ""throw new RuntimeException"" is introduced, constituting a code change type 2. Additionally, since this check for mRecycled is at the start of the method, it adds a new control flow dependency, leading to code change type 3.","The addition of a RuntimeException being thrown if mRecycled is true can lead to a change in behavior from the previous version, where such an exception was not thrown. Therefore, the code changes could cause a different exception to be thrown compared to the earlier version, which is CI type 2."
831,<android.content.res.TypedArray: String getString(int)>,20,21,<android.content.res.TypedArray: String getString(int)>,<android.content.res.TypedArray: String getString(int)>,0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to string: "" + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, ""getString of bad type: 0x"" + Integer.toHexString(type));
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to string: "" + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, ""getString of bad type: 0x"" + Integer.toHexString(type));
    return null;
}",1,"/**
 * Retrieve the string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */
","/**
 * Retrieve the string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The change is the added 'if' condition block which checks mRecycled and throws a RuntimeException if true. Because this block is at the beginning of the method, it does not change any existing return statements, hence it isn't categorized under return statement change. However, it does introduce a new exception handling statement that wasn't present in the early version; so the code change types are 2 (exception handling statement changed) and 4 (other statement changed because the conditional block was introduced that is not related to any of the other change types specified).","Given that the late implementation has a new conditional that could potentially throw a RuntimeException, this represents a change in exception handling behavior between the two versions. Because of this new possibility of an exception being thrown where it was not before, the compatibility issue type is 2 (Compatibility Issue caused by potential different exception handlings)."
832,<android.widget.OverScroller: boolean computeScrollOffset()>,20,21,<android.widget.OverScroller: boolean computeScrollOffset()>,<android.widget.OverScroller: boolean computeScrollOffset()>,0,"{
    if (isFinished()) {
        return false;
    }
    switch(mMode) {
        case SCROLL_MODE:
            long time = AnimationUtils.currentAnimationTimeMillis();
            // Any scroller can be used for time, since they were started
            // together in scroll mode. We use X here.
            final long elapsedTime = time - mScrollerX.mStartTime;
            final int duration = mScrollerX.mDuration;
            if (elapsedTime < duration) {
                float q = (float) (elapsedTime) / duration;
                if (mInterpolator == null) {
                    q = Scroller.viscousFluid(q);
                } else {
                    q = mInterpolator.getInterpolation(q);
                }
                mScrollerX.updateScroll(q);
                mScrollerY.updateScroll(q);
            } else {
                abortAnimation();
            }
            break;
        case FLING_MODE:
            if (!mScrollerX.mFinished) {
                if (!mScrollerX.update()) {
                    if (!mScrollerX.continueWhenFinished()) {
                        mScrollerX.finish();
                    }
                }
            }
            if (!mScrollerY.mFinished) {
                if (!mScrollerY.update()) {
                    if (!mScrollerY.continueWhenFinished()) {
                        mScrollerY.finish();
                    }
                }
            }
            break;
    }
    return true;
}","{
    if (isFinished()) {
        return false;
    }
    switch(mMode) {
        case SCROLL_MODE:
            long time = AnimationUtils.currentAnimationTimeMillis();
            // Any scroller can be used for time, since they were started
            // together in scroll mode. We use X here.
            final long elapsedTime = time - mScrollerX.mStartTime;
            final int duration = mScrollerX.mDuration;
            if (elapsedTime < duration) {
                final float q = mInterpolator.getInterpolation(elapsedTime / (float) duration);
                mScrollerX.updateScroll(q);
                mScrollerY.updateScroll(q);
            } else {
                abortAnimation();
            }
            break;
        case FLING_MODE:
            if (!mScrollerX.mFinished) {
                if (!mScrollerX.update()) {
                    if (!mScrollerX.continueWhenFinished()) {
                        mScrollerX.finish();
                    }
                }
            }
            if (!mScrollerY.mFinished) {
                if (!mScrollerY.update()) {
                    if (!mScrollerY.continueWhenFinished()) {
                        mScrollerY.finish();
                    }
                }
            }
            break;
    }
    return true;
}",1,"/**
 * Call this when you want to know the new location. If it returns true, the
 * animation is not yet finished.
 */
","/**
 * Call this when you want to know the new location. If it returns true, the
 * animation is not yet finished.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The calculation of the q variable and the check for null interpolator have been removed. Rather than checking if mInterpolator is null and using Scroller.viscousFluid(q) if it is, the late version always uses mInterpolator.getInterpolation(). This means there’s a control dependency change (since the if statement for the null check has been removed) as well as another statement changed (the calculation of q). The code change type is 3,4.","There is no Compatibility Issue detected because the behavior when mInterpolator is not null remains unchanged. Before, if mInterpolator was null, Scroller.viscousFluid(q) would be called, and if it wasn't, mInterpolator.getInterpolation(q) would be called. Now, only mInterpolator.getInterpolation(elapsedTime / (float) duration) is called, meaning the behavior only changes for the case where mInterpolator is null, but this does not lead to a different return value or type, or exception handling from the API since both scenarios return true, and no exceptions are thrown or handled differently."
834,<android.bluetooth.BluetoothSocket: void close()>,20,21,<android.bluetooth.BluetoothSocket: void close()>,<android.bluetooth.BluetoothSocket: void close()>,0,"{
    if (VDBG)
        Log.d(TAG, ""close() in, this: "" + this + "", channel: "" + mPort + "", state: "" + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (VDBG)
                Log.d(TAG, ""close() this: "" + this + "", channel: "" + mPort + "", mSocketIS: "" + mSocketIS + "", mSocketOS: "" + mSocketOS + ""mSocket: "" + mSocket);
            if (mSocket != null) {
                if (VDBG)
                    Log.d(TAG, ""Closing mSocket: "" + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null)
                mPfd.detachFd();
        }
    }
}","{
    if (DBG)
        Log.d(TAG, ""close() in, this: "" + this + "", channel: "" + mPort + "", state: "" + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (DBG)
                Log.d(TAG, ""close() this: "" + this + "", channel: "" + mPort + "", mSocketIS: "" + mSocketIS + "", mSocketOS: "" + mSocketOS + ""mSocket: "" + mSocket);
            if (mSocket != null) {
                if (DBG)
                    Log.d(TAG, ""Closing mSocket: "" + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null) {
                mPfd.close();
                mPfd = null;
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",0,"The logging-related statements have minor changes, modifying VDBG to DBG. A method call mPfd.detachFd() in the early version is replaced with mPfd.close() followed by setting mPfd to null in the late version. This constitutes an exception handling statement change and other statement change.","Despite the changes, there is no Compatibility Issue with respect to different return values or thrown exceptions because the close() method's behavior, in terms of functionality (releasing resources), remains the same. However, the method no longer detaches the file descriptor but instead closes the ParcelFileDescriptor directly, which could affect resource management without altering the API's external behavior. Since this is internal behavior and exception-specific, it does not affect the method's signature or expected use."
836,<android.app.ApplicationPackageManager: Drawable getActivityLogo(ComponentName)>,20,21,<android.app.ApplicationPackageManager: Drawable getActivityLogo(ComponentName)>,<android.app.ApplicationPackageManager: Drawable getActivityLogo(ComponentName)>,0,"{
    return getActivityInfo(activityName, 0).loadLogo(this);
}","{
    return getActivityInfo(activityName, sDefaultFlags).loadLogo(this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change is in the argument passed to the method getActivityInfo from a literal 0 to variable sDefaultFlags, which indicates that there is a dependency change, hence the code change type is 5.","Since the method getActivityInfo is not part of the given code and assuming the variable sDefaultFlags does not alter the behavior of getActivityInfo in a way that would cause it to return a different ActivityInfo object that would lead to a different logo being loaded, there is no Compatibility Issue due to this change, so the CI type is 0. However, if the sDefaultFlags changes the obtained ActivityInfo in a way that affects the logo, this would be a CI of type 1, but based on provided information there's no indication for that."
837,"<android.util.TimeUtils: TimeZone getTimeZone(int,boolean,long,String)>",20,21,"<android.util.TimeUtils: TimeZone getTimeZone(int,boolean,long,String)>","<android.util.TimeUtils: TimeZone getTimeZone(int,boolean,long,String)>",0,"{
    TimeZone best = null;
    Resources r = Resources.getSystem();
    XmlResourceParser parser = r.getXml(com.android.internal.R.xml.time_zones_by_country);
    Date d = new Date(when);
    TimeZone current = TimeZone.getDefault();
    String currentName = current.getID();
    int currentOffset = current.getOffset(when);
    boolean currentDst = current.inDaylightTime(d);
    for (TimeZone tz : getTimeZones(country)) {
        if (tz.getID().equals(currentName)) {
            if (currentOffset == offset && currentDst == dst) {
                return current;
            }
        }
        if (best == null) {
            if (tz.getOffset(when) == offset && tz.inDaylightTime(d) == dst) {
                best = tz;
            }
        }
    }
    return best;
}","{
    TimeZone best = null;
    final Date d = new Date(when);
    TimeZone current = TimeZone.getDefault();
    String currentName = current.getID();
    int currentOffset = current.getOffset(when);
    boolean currentDst = current.inDaylightTime(d);
    for (TimeZone tz : getTimeZones(country)) {
        if (tz.getID().equals(currentName)) {
            if (currentOffset == offset && currentDst == dst) {
                return current;
            }
        }
        if (best == null) {
            if (tz.getOffset(when) == offset && tz.inDaylightTime(d) == dst) {
                best = tz;
            }
        }
    }
    return best;
}",1,"/**
 * Tries to return a time zone that would have had the specified offset
 * and DST value at the specified moment in the specified country.
 * Returns null if no suitable zone could be found.
 */
","/**
 * Tries to return a time zone that would have had the specified offset
 * and DST value at the specified moment in the specified country.
 * Returns null if no suitable zone could be found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no code changes between the early and late versions, as the implementations are identical.","Since there is no code change, no compatibility issue could arise from this comparison."
838,"<android.os.Bundle: CharSequence getCharSequence(String,CharSequence)>",20,21,"<android.os.Bundle: CharSequence getCharSequence(String,CharSequence)>","<android.os.Bundle: CharSequence getCharSequence(String,CharSequence)>",0,"{
    final CharSequence cs = getCharSequence(key);
    return (cs == null) ? defaultValue : cs;
}","{
    return super.getCharSequence(key, defaultValue);
}",1,"/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String, or null
 * @param defaultValue Value to return if key does not exist
 * @return the CharSequence value associated with the given key, or defaultValue
 * if no valid CharSequence object is currently mapped to that key.
 */
","/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key or if a null
 * value is explicitly associatd with the given key.
 *
 * @param key a String, or null
 * @param defaultValue Value to return if key does not exist or if a null
 * value is associated with the given key.
 * @return the CharSequence value associated with the given key, or defaultValue
 * if no valid CharSequence object is currently mapped to that key.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation is changed from a direct method body to a call to the superclass's method with the same functionality, so the code change type is 5.","Assuming the superclass's method implementation is correct and has the same behavior for the given parameters, there should be no compatibility issue. Therefore, the CI type is 0."
839,"<android.transition.Transition: TransitionValues getTransitionValues(View,boolean)>",20,21,"<android.transition.Transition: TransitionValues getTransitionValues(View,boolean)>","<android.transition.Transition: TransitionValues getTransitionValues(View,boolean)>",0,"{
    if (mParent != null) {
        return mParent.getTransitionValues(view, start);
    }
    TransitionValuesMaps valuesMaps = start ? mStartValues : mEndValues;
    TransitionValues values = valuesMaps.viewValues.get(view);
    if (values == null) {
        int id = view.getId();
        if (id >= 0) {
            values = valuesMaps.idValues.get(id);
        }
        if (values == null && view.getParent() instanceof ListView) {
            ListView listview = (ListView) view.getParent();
            int position = listview.getPositionForView(view);
            long itemId = listview.getItemIdAtPosition(position);
            values = valuesMaps.itemIdValues.get(itemId);
        }
    // TODO: Doesn't handle the case where a view was parented to a
    // ListView (with an itemId), but no longer is
    }
    return values;
}","{
    if (mParent != null) {
        return mParent.getTransitionValues(view, start);
    }
    TransitionValuesMaps valuesMaps = start ? mStartValues : mEndValues;
    return valuesMaps.viewValues.get(view);
}",1,"/**
 * This method can be called by transitions to get the TransitionValues for
 * any particular view during the transition-playing process. This might be
 * necessary, for example, to query the before/after state of related views
 * for a given transition.
 */
","/**
 * This method can be called by transitions to get the TransitionValues for
 * any particular view during the transition-playing process. This might be
 * necessary, for example, to query the before/after state of related views
 * for a given transition.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version of the API implementation has deleted the code that handles the scenario when `values == null`. It directly returns the result of `valuesMap.viewValues.get(view)` without checking for the view's ID or its parent's type (such as ListView). The control dependency concerning the view ID and ListView has been removed; thus, the code change types are 1 and 3.","The change to the return statement and the removal of conditions that would provide alternative TransitionValues could lead to the API returning different TransitionValues from the two versions; hence, the CI type is 1."
840,<android.os.PowerManager: boolean isScreenOn()>,20,21,<android.os.PowerManager: boolean isScreenOn()>,<android.os.PowerManager: boolean isScreenOn()>,0,"{
    try {
        return mService.isScreenOn();
    } catch (RemoteException e) {
        return false;
    }
}","{
    return isInteractive();
}",1,"/**
 * Returns whether the screen is currently on.
 * <p>
 * Only indicates whether the screen is on.  The screen could be either bright or dim.
 * </p><p>
 * {@samplecode
 * PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
 * boolean isScreenOn = pm.isScreenOn();
 * }
 * </p>
 *
 * @return whether the screen is on (bright or dim).
 */
","/**
 * Returns true if the device is in an interactive state.
 * <p>
 * For historical reasons, the name of this method refers to the power state of
 * the screen but it actually describes the overall interactive state of
 * the device.  This method has been replaced by {@link #isInteractive}.
 * </p><p>
 * The value returned by this method only indicates whether the device is
 * in an interactive state which may have nothing to do with the screen being
 * on or off.  To determine the actual state of the screen,
 * use {@link android.view.Display#getState}.
 * </p>
 *
 * @return True if the device is in an interactive state.
 *
 * @deprecated Use {@link #isInteractive} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has changed from calling mService.isScreenOn() and handling RemoteException to just calling isInteractive(), indicating that a dependent API isScreenOn() is replaced by isInteractive(). Therefore, the code has changed in types 1 and 5.","Since the method now relies on a different API call isInteractive() instead of mService.isScreenOn(), it may behave differently which may cause a different return value or type. Hence, there's a potential Compatibility Issue of type 1."
842,<android.view.accessibility.AccessibilityManager: boolean isEnabled()>,20,21,<android.view.accessibility.AccessibilityManager: boolean isEnabled()>,<android.view.accessibility.AccessibilityManager: boolean isEnabled()>,0,"{
    synchronized (mHandler) {
        return mIsEnabled;
    }
}","{
    synchronized (mLock) {
        IAccessibilityManager service = getServiceLocked();
        if (service == null) {
            return false;
        }
        return mIsEnabled;
    }
}",1,"/**
 * Returns if the accessibility in the system is enabled.
 *
 * @return True if accessibility is enabled, false otherwise.
 */
","/**
 * Returns if the accessibility in the system is enabled.
 *
 * @return True if accessibility is enabled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code change includes synchronization on a different object (`mHandler` to `mLock`), the introduction of new control statements (`if` condition), and the retrieval of a service (`service == null` check). Thus, the code change type is 3,4.","With the introduction of a new `null` check on the service object, there is a new code path that returns `false` directly. This early exit can lead to potentially different return values when `service` is `null`. Hence, the CI type is 1."
844,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,20,21,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,0,"{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = mService.sendAccessibilityEvent(event, mUserId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
        }
        userId = mUserId;
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = service.sendAccessibilityEvent(event, userId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}",1,"/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
","/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The structure of the code has significantly changed with the introduction of synchronization on `mLock` and moving the instantiation of `service` and assignment of `userId` inside the synchronized block. Additionally, the dependent API called `mService.sendAccessibilityEvent(event, mUserId)` has been changed to `service.sendAccessibilityEvent(event, userId)`. Given these changes, the code change type is 3,5.","There is no Compatibility Issue detected because the behavior exposed to the client does not change. However, the method's internal mechanism for obtaining the service instance and user ID is synchronized, which ensures that the state accessed is consistent, but this does not affect the API's functionality from a caller's perspective. The method's contract and the way the exception is thrown remain unchanged. Therefore, no CI is present."
845,"<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>",20,21,"<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>","<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","There is an introduction of a new condition at the start of the method to check if the TypedArray is recycled, with a corresponding throw statement for a RuntimeException. In addition, a new else-if block is added to handle the case where the type is TypedValue.TYPE_ATTRIBUTE, throwing a different RuntimeException. Also, the use of mMetrics has changed from mResources.mMetrics to mMetrics. Thus, the changes are 2,3,5.","The added check for 'mRecycled' could result in a new exception being thrown which wasn't thrown in the early version, and also a new kind of RuntimeException could be thrown in case of TYPE_ATTRIBUTE, where previously a different exception was thrown. Hence, there could be a CI due to different exceptions potentially being thrown, which means that both return values and exception handlings could be affected, making the CI types 1,2."
846,"<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>",20,21,"<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>","<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>",0,"{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, ""getThumbnail: origId=""+origId+"", kind=""+kind+"", isVideo=""+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, ""couldn't decode byte array."");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? ""video_id="" : ""image_id="";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter(""blocking"", ""1"").appendQueryParameter(""orig_id"", String.valueOf(origId)).appendQueryParameter(""group_id"", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, ""couldn't decode byte array."");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException(""Unsupported kind: "" + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, ""Create the thumbnail in memory: origId="" + origId + "", kind="" + kind + "", isVideo="" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst(""thumbnails"", ""media""));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}","{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, ""getThumbnail: origId=""+origId+"", kind=""+kind+"", isVideo=""+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, ""couldn't decode byte array."");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? ""video_id="" : ""image_id="";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter(""blocking"", ""1"").appendQueryParameter(""orig_id"", String.valueOf(origId)).appendQueryParameter(""group_id"", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, ""couldn't decode byte array."");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException(""Unsupported kind: "" + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, ""Create the thumbnail in memory: origId="" + origId + "", kind="" + kind + "", isVideo="" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst(""thumbnails"", ""media""));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}",1,"/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */
","/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
847,<android.widget.DatePicker: long getMaxDate()>,20,21,<android.widget.DatePicker: long getMaxDate()>,<android.widget.DatePicker: long getMaxDate()>,0,"{
    return mCalendarView.getMaxDate();
}","{
    return mDelegate.getMaxDate().getTimeInMillis();
}",1,"/**
 * Gets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default maximal date is 12/31/2100.
 * <p>
 *
 * @return The maximal supported date.
 */
","/**
 * Gets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default maximal date is 12/31/2100.
 * <p>
 *
 * @return The maximal supported date.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method that is called to obtain the maximum date has changed from mCalendarView.getMaxDate() to mDelegate.getMaxDate().getTimeInMillis(). This implies a change in the dependent object and possibly the method invoked to get the maximum date, so the code change type is 1,5.","The change of the method used to obtain the value can result in different return values or types because mDelegate.getMaxDate() returns a different type of object (presumably a Calendar) compared to mCalendarView.getMaxDate() which is likely directly returning a long value. By calling getTimeInMillis() on the returned Calendar object, the code change is clearly altering the method of obtaining the time in milliseconds, thus the CI type is 1."
850,<android.text.Layout: float getLineMax(int)>,20,21,<android.text.Layout: float getLineMax(int)>,<android.text.Layout: float getLineMax(int)>,0,"{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, false);
    return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
}","{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, false);
    return margin + (signedExtent >= 0 ? signedExtent : -signedExtent);
}",1,"/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent, but excluding trailing whitespace.
 */
","/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent, but excluding trailing whitespace.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the implementation where the order of operations in the return statement is modified. The parentheses have been added around the ternary operation result rather than being used with margin, but it doesn't affect the result of the expression. Therefore, the code change type is 4 (Other statement changed).","Although the parentheses have been added, the logic of calculating the return value is the same. The calculation of signedExtent and its condition (signedExtent >= 0) remain unchanged. The margin is added to the final result of the ternary operation in both cases, so there is no change to the value being returned. As there are no potential changes in the return values or the exception handling, there is no compatibility issue, so the CI type is 0 (No Compatibility Issue)."
853,<android.hardware.camera2.CaptureResult: T get(Key<T>)>,20,21,<android.hardware.camera2.CaptureResult: T get(Key<T>)>,<android.hardware.camera2.CaptureResult: T get(Key<T>)>,0,"{
    return mResults.get(key);
}","{
    T value = mResults.get(key);
    if (VERBOSE)
        Log.v(TAG, ""#get for Key = "" + key.getName() + "", returned value = "" + value);
    return value;
}",1,,"/**
 * Get a capture result field value.
 *
 * <p>The field definitions can be found in {@link CaptureResult}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The result field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
",-1,[@Override],,-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of a logging statement that does not affect the functional behavior of the method, so the code change type is 4.","Since the return value and the method’s behavior in terms of exception handling has not changed, there is no Compatibility Issue; the addition of a logging statement does not affect the API contract."
856,<android.view.View: float getPivotX()>,20,21,<android.view.View: float getPivotX()>,<android.view.View: float getPivotX()>,0,"{
    return mTransformationInfo != null ? mTransformationInfo.mPivotX : 0;
}","{
    return mRenderNode.getPivotX();
}",1,"/**
 * The x location of the point around which the view is {@link #setRotation(float) rotated}
 * and {@link #setScaleX(float) scaled}.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotY()
 * @return The x location of the pivot point.
 *
 * @attr ref android.R.styleable#View_transformPivotX
 */
","/**
 * The x location of the point around which the view is {@link #setRotation(float) rotated}
 * and {@link #setScaleX(float) scaled}.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotY()
 * @return The x location of the pivot point.
 *
 * @attr ref android.R.styleable#View_transformPivotX
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"4,5",1,"The method of obtaining pivotX has changed from using a ternary operator checking mTransformationInfo and returning its member mPivotX or 0, to directly calling mRenderNode.getPivotX(). This implies a change in how the value is retrieved, meaning there's a change in the other statement and it relies on a dependent API, so the change type is 4,5.","Because the source of the pivotX value has changed from one mechanism to another, the API could potentially return different values depending on the implementation of mRenderNode.getPivotX(). Therefore, the CI type is 1."
858,<android.service.notification.NotificationListenerService: void cancelAllNotifications()>,20,21,<android.service.notification.NotificationListenerService: void cancelAllNotifications()>,<android.service.notification.NotificationListenerService: void cancelAllNotifications()>,0,"{
    try {
        getNotificationInterface().cancelAllNotificationsFromListener(mWrapper);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, ""Unable to contact notification manager"", ex);
    }
}","{
    cancelNotifications(null);
}",1,"/**
 * Inform the notification manager about dismissal of all notifications.
 * <p>
 * Use this if your listener has a user interface that allows the user to dismiss all
 * notifications, similar to the behavior of Android's status bar and notification panel.
 * It should be called after the user invokes the ""dismiss all"" function of your UI;
 * upon being informed, the notification manager will actually remove all active notifications
 * and you will get multiple {@link #onNotificationRemoved(StatusBarNotification)} callbacks.
 *
 * {@see #cancelNotification(String, String, int)}
 */
","/**
 * Inform the notification manager about dismissal of all notifications.
 * <p>
 * Use this if your listener has a user interface that allows the user to dismiss all
 * notifications, similar to the behavior of Android's status bar and notification panel.
 * It should be called after the user invokes the ""dismiss all"" function of your UI;
 * upon being informed, the notification manager will actually remove all active notifications
 * and you will get multiple {@link #onNotificationRemoved(StatusBarNotification)} callbacks.
 *
 * {@see #cancelNotification(String, String, int)}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The previous direct call to getNotificationInterface().cancelAllNotificationsFromListener(mWrapper) within a try-catch block has been replaced with a call to cancelNotifications(null). This is a change in the body of the method (other statement changed) which does not directly affect control flow or exception handling. Also, a dependent API cancelNotifications() is now being used instead of the getNotificationInterface().cancelAllNotificationsFromListener(), indicating a dependent API change.","There is no compatibility issue detected since there is no indication that the behavior of the new dependent API cancelNotifications(null) should be different from the old implementation. The old implementation was handling the RemoteException but now that logic has been encapsulated within the cancelNotifications method. Assuming that method appropriately handles exceptions or has equivalent behavior, the change should not cause a compatibility issue."
859,<android.app.ActivityThread.Profiler: void startProfiling()>,20,21,<android.app.ActivityThread.Profiler: void startProfiling()>,<android.app.ActivityThread.Profiler: void startProfiling()>,0,"{
    if (profileFd == null || profiling) {
        return;
    }
    try {
        Debug.startMethodTracing(profileFile, profileFd.getFileDescriptor(), 8 * 1024 * 1024, 0);
        profiling = true;
    } catch (RuntimeException e) {
        Slog.w(TAG, ""Profiling failed on path "" + profileFile);
        try {
            profileFd.close();
            profileFd = null;
        } catch (IOException e2) {
            Slog.w(TAG, ""Failure closing profile fd"", e2);
        }
    }
}","{
    if (profileFd == null || profiling) {
        return;
    }
    try {
        VMDebug.startMethodTracing(profileFile, profileFd.getFileDescriptor(), 8 * 1024 * 1024, 0, samplingInterval != 0, samplingInterval);
        profiling = true;
    } catch (RuntimeException e) {
        Slog.w(TAG, ""Profiling failed on path "" + profileFile);
        try {
            profileFd.close();
            profileFd = null;
        } catch (IOException e2) {
            Slog.w(TAG, ""Failure closing profile fd"", e2);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the profiling start method changed from Debug.startMethodTracing() to VMDebug.startMethodTracing() and the number of parameters has increased, including a new parameter 'samplingInterval'. Hence, the code change types are 4 and 5.","Due to the change in the underlying method used for starting the profiling and the additional parameter, the behaviour of startProfiling() could potentially change, which could lead to a different impact on the profiling results. Therefore, the CI type is 1, indicating a Compatibility Issue caused by potential different return values or types, though in this context it's more about the behavior than the actual return type/value."
860,<android.bluetooth.BluetoothSocket: int bindListen()>,20,21,<android.bluetooth.BluetoothSocket: int bindListen()>,<android.bluetooth.BluetoothSocket: int bindListen()>,0,"{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (VDBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (VDBG)
                Log.d(TAG, ""bindListen(), new LocalSocket "");
            mSocket = new LocalSocket(fd);
            if (VDBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream() "");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (VDBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (VDBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}","{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket "");
            mSocket = new LocalSocket(fd);
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream() "");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, ""bindListen, close mPfd: "" + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The implementation has changed to include an additional catch block for IOException that closes mPfd and sets it to null, which is an exception handling statement change. Additionally, the condition checked within the 'if' logging statements has changed from VDBG to DBG, which can be considered as another statement changed. There's also a control dependency change due to the addition of a new 'if' condition inside the catch block for IOException.","Introducing a new exception handling which includes closing the ParcelFileDescriptor (mPfd) and setting to null can potentially change the behavior of the method by affecting subsequent operations that might depend on mPfd being open. The change can lead to a different execution flow, which might not have occurred in the previous version; the flow is altered when the IOException is caught, resulting in a different exception handling path. Moreover, changing the debug logging condition from VDBG to DBG does not directly cause a compatibility issue as it is related to the logging mechanism and not to the method's return value or exception throwing behavior. Hence, this potentially leads to different return values and exception handling paths, indicating compatibility issues of types 1 and 2."
861,<android.widget.CalendarView: void setMinDate(long)>,20,21,<android.widget.CalendarView: void setMinDate(long)>,<android.widget.CalendarView: void setMinDate(long)>,0,"{
    mTempDate.setTimeInMillis(minDate);
    if (isSameDate(mTempDate, mMinDate)) {
        return;
    }
    mMinDate.setTimeInMillis(minDate);
    // make sure the current date is not earlier than
    // the new min date since the latter is used for
    // calculating the indices in the adapter thus
    // avoiding out of bounds error
    Calendar date = mAdapter.mSelectedDate;
    if (date.before(mMinDate)) {
        mAdapter.setSelectedDay(mMinDate);
    }
    // reinitialize the adapter since its range depends on min date
    mAdapter.init();
    if (date.before(mMinDate)) {
        setDate(mTempDate.getTimeInMillis());
    } else {
        // we go to the current date to force the ListView to query its
        // adapter for the shown views since we have changed the adapter
        // range and the base from which the later calculates item indices
        // note that calling setDate will not work since the date is the same
        goTo(date, false, true, false);
    }
}","{
    mDelegate.setMinDate(minDate);
}",1,"/**
 * Sets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param minDate The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */
","/**
 * Sets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param minDate The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire implementation of setMinDate(long minDate) was altered. In the early version, custom logic is implemented which checks if the new minimum date differs from the old one, updates the minimum date, adjusts the selected day if necessary, and finally updates the UI by initializing the adapter and either setting the date or navigating to it if it's altered. On the other hand, the late version delegates all functionality to mDelegate.setMinDate(minDate). This is a complete method body replacement and dependent API change which suggests the entire logic for handling setting the minimum date has been offloaded to a separate delegate (possibly encapsulating changes in behavior, validation, and UI update mechanisms). The code change type is 1,4,5.","The potential behavior of the API could differ substantially due to the rewritten code. The original implementation had checks and adjustments for the selected date within certain conditions, as well as UI update mechanisms. With these being replaced by a single method call to an entirely separate delegate object, the behavior of these internal mechanisms might change, which could potentially lead to different return values or types due to removed return statement (i.e., removal of the early 'return;' which would short-circuit the method). A delegate might also handle internal conditions and UI updates differently. Therefore, there is a Compatibility Issue caused by potential different return values or types, so the CI type is 1."
865,<android.hardware.usb.UsbInterface: String toString()>,20,21,<android.hardware.usb.UsbInterface: String toString()>,<android.hardware.usb.UsbInterface: String toString()>,0,"{
    return ""UsbInterface[mId="" + mId + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mEndpoints="" + mEndpoints + ""]"";
}","{
    StringBuilder builder = new StringBuilder(""UsbInterface[mId="" + mId + "",mAlternateSetting="" + mAlternateSetting + "",mName="" + mName + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mEndpoints=["");
    for (int i = 0; i < mEndpoints.length; i++) {
        builder.append(""\n"");
        builder.append(mEndpoints[i].toString());
    }
    builder.append(""]"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,Several code changes have occurred here: ,- A for-loop is added to iterate over 'mEndpoints'.
867,<android.app.ContextImpl: File getCacheDir()>,20,21,<android.app.ContextImpl: File getCacheDir()>,<android.app.ContextImpl: File getCacheDir()>,0,"{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDirFile(), ""cache"");
        }
        if (!mCacheDir.exists()) {
            if (!mCacheDir.mkdirs()) {
                if (mCacheDir.exists()) {
                    // spurious failure; probably racing with another process for this app
                    return mCacheDir;
                }
                Log.w(TAG, ""Unable to create cache directory "" + mCacheDir.getAbsolutePath());
                return null;
            }
            FileUtils.setPermissions(mCacheDir.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        }
    }
    return mCacheDir;
}","{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDirFile(), ""cache"");
        }
        return createFilesDirLocked(mCacheDir);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The entire block handling the case where the mCacheDir does not exist and creation of it has been removed and replaced with a return statement calling createFilesDirLocked(mCacheDir). This results in changes to exception handling (as there is no longer a check for if mCacheDir.mkdirs() fails), the control flow (changing from an if statement to a single return statement), and other statements (removal of log and permission setting), so the code change type is 1,3,4,5.","The removal of check for mCacheDir.exists() and mCacheDir.mkdirs() could lead to different behavior in the case of the directory being unable to be created, as the earlier version returns null when the directory cannot be created or already exists due to a race condition, and the later version always calls createFilesDirLocked, which is assumed to handle these cases internally. This potentially leads to the API returning a different value, hence the CI type is 1."
868,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,20,21,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,0,"{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return !ActivityManagerNative.getDefault().targetTaskAffinityMatchesActivity(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}","{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return ActivityManagerNative.getDefault().shouldUpRecreateTask(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}",1,"/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */
","/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The code changes include a change in the return statement from `!ActivityManagerNative.getDefault().targetTaskAffinityMatchesActivity(mToken, info.taskAffinity)` to `ActivityManagerNative.getDefault().shouldUpRecreateTask(mToken, info.taskAffinity)`, which means the method called and its purpose have changed, so the change types are 1 and 5.","Because the return statement now invokes a different method of `ActivityManagerNative`, this change could potentially lead to a different return value, which indicates a Compatibility Issue of type 1."
870,<android.app.Activity: boolean onSearchRequested()>,20,21,<android.app.Activity: boolean onSearchRequested()>,<android.app.Activity: boolean onSearchRequested()>,0,"{
    startSearch(null, false, null, false);
    return true;
}","{
    if ((getResources().getConfiguration().uiMode & Configuration.UI_MODE_TYPE_MASK) != Configuration.UI_MODE_TYPE_TELEVISION) {
        startSearch(null, false, null, false);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * This hook is called when the user signals the desire to start a search.
 *
 * <p>You can use this function as a simple way to launch the search UI, in response to a
 * menu item, search button, or other widgets within your activity. Unless overidden,
 * calling this function is the same as calling
 * {@link #startSearch startSearch(null, false, null, false)}, which launches
 * search for the current activity as specified in its manifest, see {@link SearchManager}.
 *
 * <p>You can override this function to force global search, e.g. in response to a dedicated
 * search key, or to block search entirely (by simply returning false).
 *
 * @return Returns {@code true} if search launched, and {@code false} if activity blocks it.
 * The default implementation always returns {@code true}.
 *
 * @see android.app.SearchManager
 */
","/**
 * This hook is called when the user signals the desire to start a search.
 *
 * <p>You can use this function as a simple way to launch the search UI, in response to a
 * menu item, search button, or other widgets within your activity. Unless overidden,
 * calling this function is the same as calling
 * {@link #startSearch startSearch(null, false, null, false)}, which launches
 * search for the current activity as specified in its manifest, see {@link SearchManager}.
 *
 * <p>You can override this function to force global search, e.g. in response to a dedicated
 * search key, or to block search entirely (by simply returning false).
 *
 * <p>Note: when running in a {@link Configuration#UI_MODE_TYPE_TELEVISION}, the default
 * implementation changes to simply return false and you must supply your own custom
 * implementation if you want to support search.</p>
 *
 * @return Returns {@code true} if search launched, and {@code false} if the activity does
 * not respond to search.  The default implementation always returns {@code true}, except
 * when in {@link Configuration#UI_MODE_TYPE_TELEVISION} mode where it returns false.
 *
 * @see android.app.SearchManager
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version includes a new 'if' condition that checks the UI mode type before calling 'startSearch' and returning the result, plus it includes a different return value in an 'else' block. Thus, the change in the conditional block represents a control dependency change (3), and since there is a new code path with a direct return statement, it also falls under other statement changed (4).","Since the late version adds a condition that did not exist before and this condition can affect whether 'startSearch' is called or not, and also affects the return value (possibly returning false instead of always returning true), there is a potential Compatibility Issue due to different return values (1)."
872,<android.print.PrintManager.PrintDocumentAdapterDelegate: void onActivityDestroyed(Activity)>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate: void onActivityDestroyed(Activity)>,<android.print.PrintManager.PrintDocumentAdapterDelegate: void onActivityDestroyed(Activity)>,0,"{
    // We really care only if the activity is being destroyed to
    // notify the the print spooler so it can close the print dialog.
    // Note the the spooler has a death recipient that observes if
    // this process gets killed so we cover the case of onDestroy not
    // being called due to this process being killed to reclaim memory.
    final IPrintDocumentAdapterObserver observer;
    synchronized (mLock) {
        if (activity == mActivity) {
            mDestroyed = true;
            observer = mObserver;
            clearLocked();
        } else {
            observer = null;
            activity = null;
        }
    }
    if (observer != null) {
        activity.getApplication().unregisterActivityLifecycleCallbacks(PrintDocumentAdapterDelegate.this);
        try {
            observer.onDestroy();
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error announcing destroyed state"", re);
        }
    }
}","{
    // We really care only if the activity is being destroyed to
    // notify the the print spooler so it can close the print dialog.
    // Note the the spooler has a death recipient that observes if
    // this process gets killed so we cover the case of onDestroy not
    // being called due to this process being killed to reclaim memory.
    IPrintDocumentAdapterObserver observer = null;
    synchronized (mLock) {
        if (activity == mActivity) {
            observer = mObserver;
            destroyLocked();
        }
    }
    if (observer != null) {
        try {
            observer.onDestroy();
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error announcing destroyed state"", re);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The assignment of `observer` has been moved out of the synchronized block and no longer sets it to null in the else condition. The method `clearLocked()` has been replaced with `destroyLocked()` within the synchronized block. Additionally, the call to `activity.getApplication().unregisterActivityLifecycleCallbacks(PrintDocumentAdapterDelegate.this);` is removed. So, there are changes in other statements and a change in the return statement.","Although the implementation changed, there is no indication that this change would lead to a different value being returned or different exception handling. There's a change in the internal logic (code refactoring and simplification), but the end result should still be the same, causing the state of `observer` to reflect whether `activity` equals `mActivity`. As no new return statements or exception handling were introduced and none were deleted, and the method logic still aims to achieve the same outcomes as before, there are no Compatibility Issues detected."
873,<android.app.AlertDialog.Builder: Builder setView(View)>,20,21,<android.app.AlertDialog.Builder: Builder setView(View)>,<android.app.AlertDialog.Builder: Builder setView(View)>,0,"{
    P.mView = view;
    P.mViewSpacingSpecified = false;
    return this;
}","{
    P.mView = view;
    P.mViewLayoutResId = 0;
    P.mViewSpacingSpecified = false;
    return this;
}",1,"/**
 * Set a custom view to be the contents of the Dialog. If the supplied view is an instance
 * of a {@link ListView} the light background will be used.
 *
 * @param view The view to use as the contents of the Dialog.
 *
 * @return This Builder object to allow for chaining of calls to set methods
 */
","/**
 * Set a custom view to be the contents of the Dialog. If the supplied view is an instance
 * of a {@link ListView} the light background will be used.
 *
 * @param view The view to use as the contents of the Dialog.
 *
 * @return This Builder object to allow for chaining of calls to set methods
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional assignment statement (P.mViewLayoutResId = 0) has been inserted with no changes in return type, exceptions, parameters or control flow structures, so the change type is 4.","The additional assignment statement does not alter the method's behavior regarding the return value or the exceptions it might throw. Therefore, there is no Compatibility Issue, so the CI type is 0."
874,<android.net.VpnService: boolean protect(int)>,20,21,<android.net.VpnService: boolean protect(int)>,<android.net.VpnService: boolean protect(int)>,0,"{
    ParcelFileDescriptor dup = null;
    try {
        dup = ParcelFileDescriptor.fromFd(socket);
        return getService().protectVpn(dup);
    } catch (Exception e) {
        return false;
    } finally {
        try {
            dup.close();
        } catch (Exception e) {
        // ignore
        }
    }
}","{
    return NetworkUtils.protectFromVpn(socket);
}",1,"/**
 * Protect a socket from VPN connections. After protecting, data sent
 * through this socket will go directly to the underlying network,
 * so its traffic will not be forwarded through the VPN.
 * This method is useful if some connections need to be kept
 * outside of VPN. For example, a VPN tunnel should protect itself if its
 * destination is covered by VPN routes. Otherwise its outgoing packets
 * will be sent back to the VPN interface and cause an infinite loop. This
 * method will fail if the application is not prepared or is revoked.
 *
 * <p class=""note"">The socket is NOT closed by this method.
 *
 * @return {@code true} on success.
 */
","/**
 * Protect a socket from VPN connections. After protecting, data sent
 * through this socket will go directly to the underlying network,
 * so its traffic will not be forwarded through the VPN.
 * This method is useful if some connections need to be kept
 * outside of VPN. For example, a VPN tunnel should protect itself if its
 * destination is covered by VPN routes. Otherwise its outgoing packets
 * will be sent back to the VPN interface and cause an infinite loop. This
 * method will fail if the application is not prepared or is revoked.
 *
 * <p class=""note"">The socket is NOT closed by this method.
 *
 * @return {@code true} on success.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the method has entirely changed. The dependence on ParcelFileDescriptor and getService().protectVpn(dup) statements in the early implementation has been replaced with a single call to NetworkUtils.protectFromVpn(socket), which indicates a potential dependent API change. Furthermore, exception handling has been removed, and the early version closes the ParcelFileDescriptor in a finally block, which is omitted from the late version. ","This change could lead to a Compatibility Issue because the behavior of the API depends on the implementation of NetworkUtils.protectFromVpn(socket) instead of getService().protectVpn(dup) now. The new implementation also no longer returns false on exception but might throw an uncaught exception from NetworkUtils.protectFromVpn(socket), leading potentially to a different exception handling behavior as well as different return values or types. Therefore, the CI type is 1."
875,<android.widget.TimePicker: int getBaseline()>,20,21,<android.widget.TimePicker: int getBaseline()>,<android.widget.TimePicker: int getBaseline()>,0,"{
    return mHourSpinner.getBaseline();
}","{
    return mDelegate.getBaseline();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from invoking getBaseline() on mHourSpinner to invoking it on mDelegate. Furthermore, the object on which getBaseline() is called has also changed, so the code change type is 1,5.","Since the return statement is changed to call the getBaseline() method on a different object, it indicates that the delegation for getting the baseline has been changed. This can result in a different return value if the implementation of getBaseline() in mDelegate is different from that in mHourSpinner, constituting a Compatibility Issue. Hence, the CI type is 1."
877,"<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>",20,21,"<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>","<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late version introduces new exception handling (RuntimeException checks if mRecycled is true), new control dependency (additional `else if` block checking for TypedValue.TYPE_ATTRIBUTE), and changes in other statements (mResources.mMetrics has changed to mMetrics, removing the mResources reference).","A new RuntimeException can be thrown if mRecycled is true, and an additional RuntimeException may be thrown for TYPE_ATTRIBUTE. These changes constitute both return values/variables type change (due to the potential new path execution leading to a different return) and the potential different exception handlings. Hence, the CI types are 1,2."
879,<android.view.View: boolean performClick()>,20,21,<android.view.View: boolean performClick()>,<android.view.View: boolean performClick()>,0,"{
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        return true;
    }
    return false;
}","{
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    return result;
}",1,"/**
 * Call this view's OnClickListener, if it is defined.  Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @return True there was an assigned OnClickListener that was called, false
 * otherwise is returned.
 */
","/**
 * Call this view's OnClickListener, if it is defined.  Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @return True there was an assigned OnClickListener that was called, false
 * otherwise is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The logic for the return value has been moved inside conditional blocks and a variable 'result' has been introduced to store the return value. Additionally, the 'sendAccessibilityEvent' method call moved to the end of the method. So, the change types are 1 (changed the logic related to the return statement), 3 (changed the control flow due to the new variable assignment and new block scope), and 4 (reorder of method calls).","Although the implementation has changes in the ordering and structure of the code, the actual behavior of the method in terms of what it returns and under what conditions is preserved between versions. The relocation of the 'sendAccessibilityEvent' call is not supposed to affect the boolean return value of 'performClick'. Therefore, there's no compatibility issue in terms of the return value or the exceptions that might be thrown, so the CI type is 0."
880,<android.app.DatePickerDialog: Bundle onSaveInstanceState()>,20,21,<android.app.DatePickerDialog: Bundle onSaveInstanceState()>,<android.app.DatePickerDialog: Bundle onSaveInstanceState()>,0,"{
    Bundle state = super.onSaveInstanceState();
    state.putInt(YEAR, mDatePicker.getYear());
    state.putInt(MONTH, mDatePicker.getMonth());
    state.putInt(DAY, mDatePicker.getDayOfMonth());
    return state;
}","{
    final Bundle state = super.onSaveInstanceState();
    state.putInt(YEAR, mDatePicker.getYear());
    state.putInt(MONTH, mDatePicker.getMonth());
    state.putInt(DAY, mDatePicker.getDayOfMonth());
    return state;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no difference in the implementations of the method besides making the 'state' variable final in the Late_Version. This does not affect the behavior of the code since 'state' is not modified after its assignment, and thus there is no change.",No Compatibility Issue could arise from this change since the behavior of the method remains unchanged.
881,"<android.provider.DocumentsProvider: void attachInfo(Context,ProviderInfo)>",20,21,"<android.provider.DocumentsProvider: void attachInfo(Context,ProviderInfo)>","<android.provider.DocumentsProvider: void attachInfo(Context,ProviderInfo)>",0,"{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, ""root"", MATCH_ROOTS);
    mMatcher.addURI(mAuthority, ""root/*"", MATCH_ROOT);
    mMatcher.addURI(mAuthority, ""root/*/recent"", MATCH_RECENT);
    mMatcher.addURI(mAuthority, ""root/*/search"", MATCH_SEARCH);
    mMatcher.addURI(mAuthority, ""document/*"", MATCH_DOCUMENT);
    mMatcher.addURI(mAuthority, ""document/*/children"", MATCH_CHILDREN);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException(""Provider must be exported"");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException(""Provider must grantUriPermissions"");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException(""Provider must be protected by MANAGE_DOCUMENTS"");
    }
    super.attachInfo(context, info);
}","{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, ""root"", MATCH_ROOTS);
    mMatcher.addURI(mAuthority, ""root/*"", MATCH_ROOT);
    mMatcher.addURI(mAuthority, ""root/*/recent"", MATCH_RECENT);
    mMatcher.addURI(mAuthority, ""root/*/search"", MATCH_SEARCH);
    mMatcher.addURI(mAuthority, ""document/*"", MATCH_DOCUMENT);
    mMatcher.addURI(mAuthority, ""document/*/children"", MATCH_CHILDREN);
    mMatcher.addURI(mAuthority, ""tree/*/document/*"", MATCH_DOCUMENT_TREE);
    mMatcher.addURI(mAuthority, ""tree/*/document/*/children"", MATCH_CHILDREN_TREE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException(""Provider must be exported"");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException(""Provider must grantUriPermissions"");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException(""Provider must be protected by MANAGE_DOCUMENTS"");
    }
    super.attachInfo(context, info);
}",1,"/**
 * Implementation is provided by the parent class.
 */
","/**
 * Implementation is provided by the parent class.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the late version is the addition of two lines which add new URI patterns to the UriMatcher. This modification doesn't change any return values or exception handlings, so the change type is 4.","This addition of URI patterns does not constitute a compatibility issue, as it neither changes the function's return value nor the exceptions it might throw. Existing behavior and method contracts remain unchanged for the previously matched URIs; it merely extends support to additional URIs. Therefore, there is no compatibility issue."
882,<android.speech.tts.PlaybackSynthesisCallback: void stop()>,20,21,<android.speech.tts.PlaybackSynthesisCallback: void stop()>,<android.speech.tts.PlaybackSynthesisCallback: void stop()>,0,"{
    stopImpl(false);
}","{
    if (DBG)
        Log.d(TAG, ""stop()"");
    SynthesisPlaybackQueueItem item;
    synchronized (mStateLock) {
        if (mDone) {
            return;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            Log.w(TAG, ""stop() called twice"");
            return;
        }
        item = mItem;
        mStatusCode = TextToSpeech.STOPPED;
    }
    if (item != null) {
        // This might result in the synthesis thread being woken up, at which
        // point it will write an additional buffer to the item - but we
        // won't worry about that because the audio playback queue will be cleared
        // soon after (see SynthHandler#stop(String).
        item.stop(TextToSpeech.STOPPED);
    } else {
        // This happens when stop() or error() were called before start() was.
        // In all other cases, mAudioTrackHandler.stop() will
        // result in onSynthesisDone being called, and we will
        // write data there.
        mLogger.onCompleted(TextToSpeech.STOPPED);
        mDispatcher.dispatchOnStop();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The late implementation introduces additional control flow with an `if` statement including an early `return`, a new `synchronized` block with a check for the value of `mDone`, and changes to the value of `mStatusCode`. Additionally, it introduces logging, conditional execution with another `if` statement, and new calls not present in the early version within the `synchronized` block or after it. This includes a call to `item.stop` and calls to `mLogger.onCompleted` and `mDispatcher.dispatchOnStop`. Hence, the change includes alterations in the return statement, control dependencies, and other statements not falling into the previous categories, which is why the code change types are 1, 3, and 4.","With these changes, there is now a possibility that the method will return early without calling `stopImpl(false)`. Additionally, there are changes to the behavior of the method when `mDone` is true or when `mStatusCode` is already `TextToSpeech.STOPPED`. The introduction of different behavior based on the `mStatusCode` also indicates potential differences in the exceptions thrown as there is a check that was not previously present. There are new calls outside the `synchronized` block that may throw an exception or modify the state, and these calls were not in the early version. This could lead to different return values, types, or exceptions thrown, so the CI types are 1 and 2."
883,"<android.text.SpannableStringInternal: void setSpan(Object,int,int,int)>",20,21,"<android.text.SpannableStringInternal: void setSpan(Object,int,int,int)>","<android.text.SpannableStringInternal: void setSpan(Object,int,int,int)>",0,"{
    int nstart = start;
    int nend = end;
    checkRange(""setSpan"", start, end);
    if ((flags & Spannable.SPAN_PARAGRAPH) == Spannable.SPAN_PARAGRAPH) {
        if (start != 0 && start != length()) {
            char c = charAt(start - 1);
            if (c != '\n')
                throw new RuntimeException(""PARAGRAPH span must start at paragraph boundary"" + "" ("" + start + "" follows "" + c + "")"");
        }
        if (end != 0 && end != length()) {
            char c = charAt(end - 1);
            if (c != '\n')
                throw new RuntimeException(""PARAGRAPH span must end at paragraph boundary"" + "" ("" + end + "" follows "" + c + "")"");
        }
    }
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    for (int i = 0; i < count; i++) {
        if (spans[i] == what) {
            int ostart = data[i * COLUMNS + START];
            int oend = data[i * COLUMNS + END];
            data[i * COLUMNS + START] = start;
            data[i * COLUMNS + END] = end;
            data[i * COLUMNS + FLAGS] = flags;
            sendSpanChanged(what, ostart, oend, nstart, nend);
            return;
        }
    }
    if (mSpanCount + 1 >= mSpans.length) {
        int newsize = ArrayUtils.idealIntArraySize(mSpanCount + 1);
        Object[] newtags = new Object[newsize];
        int[] newdata = new int[newsize * 3];
        System.arraycopy(mSpans, 0, newtags, 0, mSpanCount);
        System.arraycopy(mSpanData, 0, newdata, 0, mSpanCount * 3);
        mSpans = newtags;
        mSpanData = newdata;
    }
    mSpans[mSpanCount] = what;
    mSpanData[mSpanCount * COLUMNS + START] = start;
    mSpanData[mSpanCount * COLUMNS + END] = end;
    mSpanData[mSpanCount * COLUMNS + FLAGS] = flags;
    mSpanCount++;
    if (this instanceof Spannable)
        sendSpanAdded(what, nstart, nend);
}","{
    int nstart = start;
    int nend = end;
    checkRange(""setSpan"", start, end);
    if ((flags & Spannable.SPAN_PARAGRAPH) == Spannable.SPAN_PARAGRAPH) {
        if (start != 0 && start != length()) {
            char c = charAt(start - 1);
            if (c != '\n')
                throw new RuntimeException(""PARAGRAPH span must start at paragraph boundary"" + "" ("" + start + "" follows "" + c + "")"");
        }
        if (end != 0 && end != length()) {
            char c = charAt(end - 1);
            if (c != '\n')
                throw new RuntimeException(""PARAGRAPH span must end at paragraph boundary"" + "" ("" + end + "" follows "" + c + "")"");
        }
    }
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    for (int i = 0; i < count; i++) {
        if (spans[i] == what) {
            int ostart = data[i * COLUMNS + START];
            int oend = data[i * COLUMNS + END];
            data[i * COLUMNS + START] = start;
            data[i * COLUMNS + END] = end;
            data[i * COLUMNS + FLAGS] = flags;
            sendSpanChanged(what, ostart, oend, nstart, nend);
            return;
        }
    }
    if (mSpanCount + 1 >= mSpans.length) {
        Object[] newtags = ArrayUtils.newUnpaddedObjectArray(GrowingArrayUtils.growSize(mSpanCount));
        int[] newdata = new int[newtags.length * 3];
        System.arraycopy(mSpans, 0, newtags, 0, mSpanCount);
        System.arraycopy(mSpanData, 0, newdata, 0, mSpanCount * 3);
        mSpans = newtags;
        mSpanData = newdata;
    }
    mSpans[mSpanCount] = what;
    mSpanData[mSpanCount * COLUMNS + START] = start;
    mSpanData[mSpanCount * COLUMNS + END] = end;
    mSpanData[mSpanCount * COLUMNS + FLAGS] = flags;
    mSpanCount++;
    if (this instanceof Spannable)
        sendSpanAdded(what, nstart, nend);
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
884,"<android.view.GLES20Canvas: int saveLayer(float,float,float,float,Paint,int)>",20,21,"<android.view.GLES20Canvas: int saveLayer(float,float,float,float,Paint,int)>","<android.view.GLES20Canvas: int saveLayer(float,float,float,float,Paint,int)>",0,"{
    if (left < right && top < bottom) {
        int count;
        int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
        try {
            final int nativePaint = paint == null ? 0 : paint.mNativePaint;
            count = nSaveLayer(mRenderer, left, top, right, bottom, nativePaint, saveFlags);
        } finally {
            if (modifier != MODIFIER_NONE)
                nResetModifiers(mRenderer, modifier);
        }
        return count;
    }
    return save(saveFlags);
}","{
    if (left < right && top < bottom) {
        final long nativePaint = paint == null ? 0 : paint.mNativePaint;
        return nSaveLayer(mRenderer, left, top, right, bottom, nativePaint, saveFlags);
    }
    return save(saveFlags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The early version contains additional control flow for setting up a color filter, represented by a modifier, and a finally block to reset modifiers. These control statements and the corresponding setup and reset modifier calls have been removed. The type of paint's native representation has also been updated from an int to a long, so the code change is a combination of Return statement changed (1) due to the adjustment of how the native paint is retrieved and Control dependency changed (3) due to the removal of the try-finally block, though this does not specifically affect the control flow of the return statement itself.","There is a potential Compatibility Issue because of the method change that omits the color filter setup and reset modifier code. This could result in different behavior when the method is executed without the paint-related color filter modifications that exist in the early version but not in the late version. The CI type is 1, since different return values might occur due to the omitted modifier logic."
887,"<android.app.NotificationManager: void notify(String,int,Notification)>",20,21,"<android.app.NotificationManager: void notify(String,int,Notification)>","<android.app.NotificationManager: void notify(String,int,Notification)>",0,"{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed(""Notification.sound"");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, notification, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}","{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed(""Notification.sound"");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    Notification stripped = notification.clone();
    Builder.stripForDelivery(stripped);
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, stripped, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}",1,"/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
","/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code introduces a new Notification object 'stripped' that is a clone of 'notification' followed by a call to `stripForDelivery(stripped)`, which are not control-flow or exception handling statements nor do they affect the return type of the method (as the method is void). Thus, the change is classified as type 4.","There is not a Compatibility Issue because the modified statements do not affect the control flow, exception handling, or dependent API functionalities, nor does it change the return type or value (since the method returns void). Therefore, the change does not affect how the method behaves from the caller’s perspective."
888,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup(FileDescriptor)>,20,21,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup(FileDescriptor)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup(FileDescriptor)>,0,"{
    try {
        final FileDescriptor fd = Libcore.os.dup(orig);
        return new ParcelFileDescriptor(fd);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor fd = Os.dup(orig);
        return new ParcelFileDescriptor(fd);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create a new ParcelFileDescriptor that is a dup of an existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */
","/**
 * Create a new ParcelFileDescriptor that is a dup of an existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within the try block has changed from Libcore.os.dup(orig) to Os.dup(orig); this indicates that a different dependent API is being used, which is classified as code change type 5.","There's no indication that the change in the dependent API (from Libcore.os.dup to Os.dup) causes the method to behave differently, as the surrounding code and exception handling has remained the same. The new implementation is expected to return a ParcelFileDescriptor in the same way as the previous version upon successful duplication of the FileDescriptor, and throw an IOException if an ErrnoException occurs; this indicates no Compatibility Issue."
891,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>",20,21,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>","<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>",0,"{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            FragmentState fs = fms.mActive[f.mIndex];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mActivity.getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new ArrayList<Fragment>(fms.mActive.length);
    if (mAvailIndices != null) {
        mAvailIndices.clear();
    }
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            Fragment f = fs.instantiate(mActivity, mParent);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f);
            mActive.add(f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        } else {
            mActive.add(null);
            if (mAvailIndices == null) {
                mAvailIndices = new ArrayList<Integer>();
            }
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: avail #"" + i);
            mAvailIndices.add(i);
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (f.mTargetIndex >= 0) {
                if (f.mTargetIndex < mActive.size()) {
                    f.mTarget = mActive.get(f.mTargetIndex);
                } else {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throwException(new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: added #"" + i + "": "" + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException(""Already added!"");
            }
            mAdded.add(f);
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, ""restoreAllState: back stack #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
                LogWriter logw = new LogWriter(Log.VERBOSE, TAG);
                PrintWriter pw = new FastPrintWriter(logw, false, 1024);
                bse.dump(""  "", pw, false);
                pw.flush();
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
}","{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            FragmentState fs = fms.mActive[f.mIndex];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mActivity.getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                f.mSavedFragmentState = fs.mSavedFragmentState;
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new ArrayList<Fragment>(fms.mActive.length);
    if (mAvailIndices != null) {
        mAvailIndices.clear();
    }
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            Fragment f = fs.instantiate(mActivity, mParent);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f);
            mActive.add(f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        } else {
            mActive.add(null);
            if (mAvailIndices == null) {
                mAvailIndices = new ArrayList<Integer>();
            }
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: avail #"" + i);
            mAvailIndices.add(i);
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (f.mTargetIndex >= 0) {
                if (f.mTargetIndex < mActive.size()) {
                    f.mTarget = mActive.get(f.mTargetIndex);
                } else {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throwException(new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: added #"" + i + "": "" + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException(""Already added!"");
            }
            mAdded.add(f);
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, ""restoreAllState: back stack #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
                LogWriter logw = new LogWriter(Log.VERBOSE, TAG);
                PrintWriter pw = new FastPrintWriter(logw, false, 1024);
                bse.dump(""  "", pw, false);
                pw.flush();
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
892,<android.animation.ObjectAnimator: void setTarget(Object)>,20,21,<android.animation.ObjectAnimator: void setTarget(Object)>,<android.animation.ObjectAnimator: void setTarget(Object)>,0,"{
    if (mTarget != target) {
        final Object oldTarget = mTarget;
        mTarget = target;
        if (oldTarget != null && target != null && oldTarget.getClass() == target.getClass()) {
            return;
        }
        // New target type should cause re-initialization prior to starting
        mInitialized = false;
    }
}","{
    final Object oldTarget = getTarget();
    if (oldTarget != target) {
        mTarget = target == null ? null : new WeakReference<Object>(target);
        // New target should cause re-initialization prior to starting
        mInitialized = false;
    }
}",1,"/**
 * Sets the target object whose property will be animated by this animation
 *
 * @param target The object being animated
 */
","/**
 * Sets the target object whose property will be animated by this animation
 *
 * @param target The object being animated
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"The method's internal logic and the storage way of `mTarget` have changed. In the early version, mTarget is directly assigned the target object, while in the late version, mTarget is assigned a WeakReference of the target object. Also, in the early implementation, there is a return statement which exits the method early under certain conditions, and it is removed in the late implementation. Besides, the late version uses the getTarget() method to obtain the current target rather than directly accessing mTarget. The return statement is removed, a dependency on another method (getTarget()) is introduced, and there are other statement changes. Therefore the changes types are 1,3,4,5.","Despite the fact that behavior internally is changed due to using WeakReference and the removal of early return condition, there is no difference in observable behavior from an API consumer's point of view. The same input will result in the object reference being stored, albeit as a WeakReference in the late version, and the method will still not return any value (void return type). Thus, there is no Compatibility Issue as the method behavior from the caller's perspective is consistent between the versions."
895,"<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>",20,21,"<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>","<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>",0,"{
    check(address, prefixLength);
    if (address.isAnyLocalAddress()) {
        throw new IllegalArgumentException(""Bad address"");
    }
    mAddresses.add(new LinkAddress(address, prefixLength));
    return this;
}","{
    check(address, prefixLength);
    if (address.isAnyLocalAddress()) {
        throw new IllegalArgumentException(""Bad address"");
    }
    mAddresses.add(new LinkAddress(address, prefixLength));
    mConfig.updateAllowedFamilies(address);
    return this;
}",1,"/**
 * Add a network address to the VPN interface. Both IPv4 and IPv6
 * addresses are supported. At least one address must be set before
 * calling {@link #establish}.
 *
 * @throws IllegalArgumentException if the address is invalid.
 */
","/**
 * Add a network address to the VPN interface. Both IPv4 and IPv6
 * addresses are supported. At least one address must be set before
 * calling {@link #establish}.
 *
 * Adding an address implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the address is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement 'mConfig.updateAllowedFamilies(address);' is added to the late implementation, which is not a control dependency, return, or exception handling statement, so the code change type is 4.","The added statement is a configuration update and does not appear to change the behavior related to what is being returned or the exceptions that are thrown by the method since it happens after the argument check and before the method returns 'this'. Therefore, it does not cause a Compatibility Issue, and the CI type is 0."
897,<android.animation.PropertyValuesHolder: PropertyValuesHolder clone()>,20,21,<android.animation.PropertyValuesHolder: PropertyValuesHolder clone()>,<android.animation.PropertyValuesHolder: PropertyValuesHolder clone()>,0,"{
    try {
        PropertyValuesHolder newPVH = (PropertyValuesHolder) super.clone();
        newPVH.mPropertyName = mPropertyName;
        newPVH.mProperty = mProperty;
        newPVH.mKeyframeSet = mKeyframeSet.clone();
        newPVH.mEvaluator = mEvaluator;
        return newPVH;
    } catch (CloneNotSupportedException e) {
        // won't reach here
        return null;
    }
}","{
    try {
        PropertyValuesHolder newPVH = (PropertyValuesHolder) super.clone();
        newPVH.mPropertyName = mPropertyName;
        newPVH.mProperty = mProperty;
        newPVH.mKeyframes = mKeyframes.clone();
        newPVH.mEvaluator = mEvaluator;
        return newPVH;
    } catch (CloneNotSupportedException e) {
        // won't reach here
        return null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The code change is that 'mKeyframeSet.clone()' has been replaced with 'mKeyframes.clone()' in the cloning process. This indicates that the internal field has changed as part of the cloning process, which could potentially affect the behavior of the clone method due to the change in the cloned data. Hence, the code change involves Other statement changed (4) and the cloned instance's state will be affected due to Dependent API changed (5).","Since the state of the cloned object may differ due to the changes in which internal fields are cloned, there is a potential Compatibility Issue caused by potential different return values or types, hence CI type is 1."
899,<android.appwidget.AppWidgetHost: void deleteAllHosts()>,20,21,<android.appwidget.AppWidgetHost: void deleteAllHosts()>,<android.appwidget.AppWidgetHost: void deleteAllHosts()>,0,"{
    deleteAllHosts(UserHandle.myUserId());
}","{
    try {
        sService.deleteAllHosts();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Remove all records about all hosts for your package.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
","/**
 * Remove all records about all hosts for your package.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The implementation method for deleting all hosts has completely changed. The early version calls deleteAllHosts(int) with a parameter, while the late version directly calls a method on sService without parameters. Moreover, there's a change in exception handling - the early version does not have a try-catch block, but the late version introduces this, catching RemoteException and throwing a new RuntimeException. This involves changes to the return statements, the exception handling statements, and the dependent API. Therefore, the change type is 1,2,5.","Since the late version of the API includes a different execution flow (different method on sService is called) and a new exception handling mechanism, the behavior of the API could potentially lead to both a different return value (or no return type as the method is void, but the method that it depends on could behave differently) and a different exception being thrown. Hence, the CI type is 1,2."
900,<android.widget.EdgeEffect: void onPull(float)>,20,21,<android.widget.EdgeEffect: void onPull(float)>,<android.widget.EdgeEffect: void onPull(float)>,0,"{
    final long now = AnimationUtils.currentAnimationTimeMillis();
    if (mState == STATE_PULL_DECAY && now - mStartTime < mDuration) {
        return;
    }
    if (mState != STATE_PULL) {
        mGlowScaleY = PULL_GLOW_BEGIN;
    }
    mState = STATE_PULL;
    mStartTime = now;
    mDuration = PULL_TIME;
    mPullDistance += deltaDistance;
    float distance = Math.abs(mPullDistance);
    mEdgeAlpha = mEdgeAlphaStart = Math.max(PULL_EDGE_BEGIN, Math.min(distance, MAX_ALPHA));
    mEdgeScaleY = mEdgeScaleYStart = Math.max(HELD_EDGE_SCALE_Y, Math.min(distance * PULL_DISTANCE_EDGE_FACTOR, 1.f));
    mGlowAlpha = mGlowAlphaStart = Math.min(MAX_ALPHA, mGlowAlpha + (Math.abs(deltaDistance) * PULL_DISTANCE_ALPHA_GLOW_FACTOR));
    float glowChange = Math.abs(deltaDistance);
    if (deltaDistance > 0 && mPullDistance < 0) {
        glowChange = -glowChange;
    }
    if (mPullDistance == 0) {
        mGlowScaleY = 0;
    }
    // Do not allow glow to get larger than MAX_GLOW_HEIGHT.
    mGlowScaleY = mGlowScaleYStart = Math.min(MAX_GLOW_HEIGHT, Math.max(0, mGlowScaleY + glowChange * PULL_DISTANCE_GLOW_FACTOR));
    mEdgeAlphaFinish = mEdgeAlpha;
    mEdgeScaleYFinish = mEdgeScaleY;
    mGlowAlphaFinish = mGlowAlpha;
    mGlowScaleYFinish = mGlowScaleY;
}","{
    onPull(deltaDistance, 0.5f);
}",1,"/**
 * A view should call this when content is pulled away from an edge by the user.
 * This will update the state of the current visual effect and its associated animation.
 * The host view should always {@link android.view.View#invalidate()} after this
 * and draw the results accordingly.
 *
 * @param deltaDistance Change in distance since the last call. Values may be 0 (no change) to
 * 1.f (full length of the view) or negative values to express change
 * back toward the edge reached to initiate the effect.
 */
","/**
 * A view should call this when content is pulled away from an edge by the user.
 * This will update the state of the current visual effect and its associated animation.
 * The host view should always {@link android.view.View#invalidate()} after this
 * and draw the results accordingly.
 *
 * <p>Views using EdgeEffect should favor {@link #onPull(float, float)} when the displacement
 * of the pull point is known.</p>
 *
 * @param deltaDistance Change in distance since the last call. Values may be 0 (no change) to
 * 1.f (full length of the view) or negative values to express change
 * back toward the edge reached to initiate the effect.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early implementation of the method directly includes detailed logic, whereas the late implementation calls ""onPull(deltaDistance, 0.5f);"", which suggests an overload of the method that takes an additional parameter. This represents a return statement change as the previous logic has been replaced with a new method call, which could return a different value due to different internal logic. Additionally, the introduction of a new dependent API constitutes change types 1 and 5.","This change is likely to cause a Compatibility Issue due to potential different return values, as the method now delegates the logic to a different implementation which may have different behavior, thus the CI type is 1."
901,<android.widget.TimePicker: Integer getCurrentHour()>,20,21,<android.widget.TimePicker: Integer getCurrentHour()>,<android.widget.TimePicker: Integer getCurrentHour()>,0,"{
    int currentHour = mHourSpinner.getValue();
    if (is24HourView()) {
        return currentHour;
    } else if (mIsAm) {
        return currentHour % HOURS_IN_HALF_DAY;
    } else {
        return (currentHour % HOURS_IN_HALF_DAY) + HOURS_IN_HALF_DAY;
    }
}","{
    return mDelegate.getCurrentHour();
}",1,"/**
 * @return The current hour in the range (0-23).
 */
","/**
 * @return The current hour in the range (0-23).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has been completely changed from a block of logic inside the method to a delegation pattern by calling mDelegate.getCurrentHour(). This represents both a change in the return statement and a dependent API change, so the code change types are 1 and 5.","Given that the implementation of the method has shifted from an internal calculation to a call to another API, this could potentially return different values if the implementation of mDelegate.getCurrentHour() differs from the original logic. Therefore, the CI type is 1."
902,"<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>",20,21,"<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>","<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>",0,"{
    try {
        sService.updateAppWidgetOptions(appWidgetId, options, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetOptions(mPackageName, appWidgetId, options);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Update the extras for a given widget instance.
 *
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #getAppWidgetOptions(int)
 *
 * @param appWidgetId    The AppWidget instances for which to set the RemoteViews.
 * @param options         The options to associate with this widget
 */
","/**
 * Update the extras for a given widget instance.
 * <p>
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #getAppWidgetOptions(int)
 *
 * @param appWidgetId The AppWidget instances for which to set the RemoteViews.
 * @param options The options to associate with this widget
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",2,"An 'if' control statement and return statement were added to check if 'mService' is null, and early termination of the method if that is the case. This added control dependency can change the execution flow. Moreover, the parameters of the method call inside the 'try' block have been changed, removing the use of 'mContext.getUserId()' and adding 'mPackageName'. These are changes in control dependency, return statements, and dependent API, hence the code change type is 1,3,5.","The method now potentially exits early without performing any action if 'mService' is null, which changes the exception behavior by not throwing an exception that would have occurred by calling 'updateAppWidgetOptions()' on a null 'mService'. Considering that the method is void and any change to the flow or exception handling would directly affect the outcomes, this is classified as compatibility issue 2 caused by potential different exception handlings."
904,<android.app.Activity: void onBackPressed()>,20,21,<android.app.Activity: void onBackPressed()>,<android.app.Activity: void onBackPressed()>,0,"{
    if (!mFragments.popBackStackImmediate()) {
        finish();
    }
}","{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    if (!mFragments.popBackStackImmediate()) {
        finishAfterTransition();
    }
}",1,"/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
","/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation introduces a new block of code that checks the collapse state of `mActionBar` and potentially returns early, the finish() method is replaced with finishAfterTransition(), and an if block was added, so the change type is control dependency change (3), other statement changed (4), and return statement changed (1).","The added if condition changes the control flow which can lead to a different return behavior (i.e., the method may now return without calling finish() or finishAfterTransition()). This represents a potential different return value from the method, leading to CI type 1. The change from finish() to finishAfterTransition() could also lead to altered behavior, indicating a potential different return value or behavior, thus CI type 1 is confirmed as well."
906,"<android.util.Log: int wtf(String,Throwable)>",20,21,"<android.util.Log: int wtf(String,Throwable)>","<android.util.Log: int wtf(String,Throwable)>",0,"{
    return wtf(LOG_ID_MAIN, tag, tr.getMessage(), tr, false);
}","{
    return wtf(LOG_ID_MAIN, tag, tr.getMessage(), tr, false, false);
}",1,"/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, String)}, with an exception to log.
 * @param tag Used to identify the source of a log message.
 * @param tr An exception to log.
 */
","/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, String)}, with an exception to log.
 * @param tag Used to identify the source of a log message.
 * @param tr An exception to log.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change in the method wtf() is the addition of one more parameter in the method call. The number of parameters went from 5 to 6, therefore the change type is 5.","There is no compatibility issue detected because the internal implementation details of the method wtf() are not clear. Adding an additional parameter will not affect the API's behavior from the perspective of external entities calling it, as long as the method signature for the public API (in this case, the number of parameters and their types in the public method) remains unchanged. It looks like an overload of the wtf() method is being used internally, but the caller of this public API is not affected by this change."
907,<android.view.View: boolean setAlphaNoInvalidation(float)>,20,21,<android.view.View: boolean setAlphaNoInvalidation(float)>,<android.view.View: boolean setAlphaNoInvalidation(float)>,0,"{
    ensureTransformationInfo();
    if (mTransformationInfo.mAlpha != alpha) {
        mTransformationInfo.mAlpha = alpha;
        boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
        if (subclassHandlesAlpha) {
            mPrivateFlags |= PFLAG_ALPHA_SET;
            return true;
        } else {
            mPrivateFlags &= ~PFLAG_ALPHA_SET;
            if (mDisplayList != null) {
                mDisplayList.setAlpha(getFinalAlpha());
            }
        }
    }
    return false;
}","{
    ensureTransformationInfo();
    if (mTransformationInfo.mAlpha != alpha) {
        mTransformationInfo.mAlpha = alpha;
        boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
        if (subclassHandlesAlpha) {
            mPrivateFlags |= PFLAG_ALPHA_SET;
            return true;
        } else {
            mPrivateFlags &= ~PFLAG_ALPHA_SET;
            mRenderNode.setAlpha(getFinalAlpha());
        }
    }
    return false;
}",1,"/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha()) and
 * the new value for the alpha property is different from the old value
 */
","/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha()) and
 * the new value for the alpha property is different from the old value
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The statement ""if (mDisplayList != null) { mDisplayList.setAlpha(getFinalAlpha()); }"" has been replaced with ""mRenderNode.setAlpha(getFinalAlpha());"", signaling a change in the dependent object on which the method is called. The use of mRenderNode instead of mDisplayList represents both a change in the implementation details (type 4) and a potential change in the dependent API (type 5), since mRenderNode may represent a different class with a different implementation for setAlpha().","There is no Compatibility Issue detected because the return values and control flow of the method have not changed. The condition that influences the return statement remains the same, and the replaced line of code does not impact what is returned by the function, nor does it introduce any new exceptions."
908,<android.os.Bundle: float getFloat(String)>,20,21,<android.os.Bundle: float getFloat(String)>,<android.os.Bundle: float getFloat(String)>,0,"{
    unparcel();
    return getFloat(key, 0.0f);
}","{
    return super.getFloat(key);
}",1,"/**
 * Returns the value associated with the given key, or 0.0f if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a float value
 */
","/**
 * Returns the value associated with the given key, or 0.0f if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a float value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of getFloat(String) has changed from calling an internal method after unparceling to directly calling the superclass implementation, thus the code change type is 4,5.","There is no Compatibility Issue because the superclass implementation is assumed to behave the same as the previous internal method call (unless the internal method or the superclass behavior are significantly undocumented or modified, which we cannot infer from the provided details). The default value provided in the early implementation is not impacting the final behavior because it mirrors the typical behavior of such getters when a key is not found."
909,<android.content.AsyncTaskLoader.LoadTask: void onCancelled(D)>,20,21,<android.content.AsyncTaskLoader.LoadTask: void onCancelled(D)>,<android.content.AsyncTaskLoader.LoadTask: void onCancelled(D)>,0,"{
    if (DEBUG)
        Slog.v(TAG, this + "" onCancelled"");
    try {
        AsyncTaskLoader.this.dispatchOnCancelled(this, data);
    } finally {
        mDone.countDown();
    }
}","{
    if (DEBUG)
        Log.v(TAG, this + "" onCancelled"");
    try {
        AsyncTaskLoader.this.dispatchOnCancelled(this, data);
    } finally {
        mDone.countDown();
    }
}",1,"/* Runs on the UI thread */
","/* Runs on the UI thread */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is in a logging statement, where 'Slog.v' has been replaced with 'Log.v'. This is not a functional change, so the code change type is 4, which represents an ""Other statement changed"".","Since the change is only in a logging statement and not in the return value or exception handling, it does not affect the behavior of the API from a client's perspective. Therefore, there is no Compatibility Issue, and the CI type is 0."
910,<android.widget.TimePicker: boolean is24HourView()>,20,21,<android.widget.TimePicker: boolean is24HourView()>,<android.widget.TimePicker: boolean is24HourView()>,0,"{
    return mIs24HourView;
}","{
    return mDelegate.is24HourView();
}",1,"/**
 * @return true if this is in 24 hour view else false.
 */
","/**
 * @return true if this is in 24 hour view else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning a field directly (mIs24HourView) to invoking a method on the delegate (mDelegate.is24HourView()), and the value returned is now determined by the method's implementation, so the code change types are 1,5.","The change in the source of the returned value (from a direct field access to a method call) implies that the API could return a different value if the implementation of 'is24HourView()' in 'mDelegate' differs from the original field 'mIs24HourView'. This constitutes a change that could potentially cause a different behavior, so the CI type is 1."
911,"<android.content.res.AssetManager: InputStream open(String,int)>",20,21,"<android.content.res.AssetManager: InputStream open(String,int)>","<android.content.res.AssetManager: InputStream open(String,int)>",0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        int asset = openAsset(fileName, accessMode);
        if (asset != 0) {
            AssetInputStream res = new AssetInputStream(asset);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException(""Asset file: "" + fileName);
}","{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        long asset = openAsset(fileName, accessMode);
        if (asset != 0) {
            AssetInputStream res = new AssetInputStream(asset);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException(""Asset file: "" + fileName);
}",1,"/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * ""assets"" directory.
 *
 * @param fileName The name of the asset to open.  This name can be
 * hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
","/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * ""assets"" directory.
 *
 * @param fileName The name of the asset to open.  This name can be
 * hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The 'int asset' declaration has been changed to 'long asset', which signifies a change from 32-bit to 64-bit integer handling within the method. Since this is not directly impacting the logic of the method, nor the signature or behavior externally, it is classified as type 4, an Other statement changed.","No Compatibility Issue occurs because the change from 'int' to 'long' within the code doesn't affect the method's external contract or the values it returns. The caller of the method would not be able to see any difference, as the change doesn't modify the input parameters, return type, or exception handling of the API. Hence, it is type 0, No Compatibility Issue."
915,"<android.view.inputmethod.BaseInputConnection: boolean setSelection(int,int)>",20,21,"<android.view.inputmethod.BaseInputConnection: boolean setSelection(int,int)>","<android.view.inputmethod.BaseInputConnection: boolean setSelection(int,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""setSelection "" + start + "", "" + end);
    final Editable content = getEditable();
    if (content == null)
        return false;
    int len = content.length();
    if (start > len || end > len) {
        // anyway.
        return true;
    }
    if (start == end && MetaKeyKeyListener.getMetaState(content, MetaKeyKeyListener.META_SELECTING) != 0) {
        // If we are in selection mode, then we want to extend the
        // selection instead of replacing it.
        Selection.extendSelection(content, start);
    } else {
        Selection.setSelection(content, start, end);
    }
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""setSelection "" + start + "", "" + end);
    final Editable content = getEditable();
    if (content == null)
        return false;
    int len = content.length();
    if (start > len || end > len || start < 0 || end < 0) {
        // anyway.
        return true;
    }
    if (start == end && MetaKeyKeyListener.getMetaState(content, MetaKeyKeyListener.META_SELECTING) != 0) {
        // If we are in selection mode, then we want to extend the
        // selection instead of replacing it.
        Selection.extendSelection(content, start);
    } else {
        Selection.setSelection(content, start, end);
    }
    return true;
}",1,"/**
 * The default implementation changes the selection position in the
 * current editable text.
 */
","/**
 * The default implementation changes the selection position in the
 * current editable text.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The change comes from the addition of a new condition in the if-statement (start < 0 || end < 0). This is a control dependency change, so the code change type is 3.","This change could affect the outcome of the method. With the additional boundary check, the method could now potentially return true for cases where start or end are negative, which wouldn't have been the case earlier. This introduces a new behavior that depends on the added conditions, and hence the CI type is 1."
918,<android.widget.TextView.Marquee: void tick()>,20,21,<android.widget.TextView.Marquee: void tick()>,<android.widget.TextView.Marquee: void tick()>,0,"{
    if (mStatus != MARQUEE_RUNNING) {
        return;
    }
    removeMessages(MESSAGE_TICK);
    final TextView textView = mView.get();
    if (textView != null && (textView.isFocused() || textView.isSelected())) {
        mScroll += mScrollUnit;
        if (mScroll > mMaxScroll) {
            mScroll = mMaxScroll;
            sendEmptyMessageDelayed(MESSAGE_RESTART, MARQUEE_RESTART_DELAY);
        } else {
            sendEmptyMessageDelayed(MESSAGE_TICK, MARQUEE_RESOLUTION);
        }
        textView.invalidate();
    }
}","{
    if (mStatus != MARQUEE_RUNNING) {
        return;
    }
    mChoreographer.removeFrameCallback(mTickCallback);
    final TextView textView = mView.get();
    if (textView != null && (textView.isFocused() || textView.isSelected())) {
        long currentMs = mChoreographer.getFrameTime();
        long deltaMs = currentMs - mLastAnimationMs;
        mLastAnimationMs = currentMs;
        float deltaPx = deltaMs / 1000f * mPixelsPerSecond;
        mScroll += deltaPx;
        if (mScroll > mMaxScroll) {
            mScroll = mMaxScroll;
            mChoreographer.postFrameCallbackDelayed(mRestartCallback, MARQUEE_DELAY);
        } else {
            mChoreographer.postFrameCallback(mTickCallback);
        }
        textView.invalidate();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code changes involve the replacement of message sending with Choreographer's frame callback mechanism, and recalculating the scroll value with a new time-based approach involving `mChoreographer.getFrameTime()`. This is classified as both a control dependency change, because it changes the timing of the animation (3), and an other statement changed, because it alters the implementation details but doesn't fall under the other specified change types (4).","These modifications could lead to differences in when the `tick()` method affects animations, potentially causing different animation behavior and thus different visual representation on the screen. Therefore, a CI could arise due to potential different values being returned in the form of the changed visual state of the TextView; the CI type is 1."
921,<android.widget.DatePicker: boolean getSpinnersShown()>,20,21,<android.widget.DatePicker: boolean getSpinnersShown()>,<android.widget.DatePicker: boolean getSpinnersShown()>,0,"{
    return mSpinners.isShown();
}","{
    return mDelegate.getSpinnersShown();
}",1,"/**
 * Gets whether the spinners are shown.
 *
 * @return True if the spinners are shown.
 */
","/**
 * Gets whether the spinners are shown.
 *
 * @return True if the spinners are shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation calls a different method on a potentially different object, changing from mSpinners.isShown() to mDelegate.getSpinnersShown(), so there is a change in the return statement and the dependent API, therefore the code change type is both 1 and 5.","Since the called method has changed, this could potentially lead to a different return value. Therefore, there is a Compatibility Issue caused by potential different return values, and the CI type is 1."
922,<android.content.res.Resources: Drawable getDrawable(int)>,20,21,<android.content.res.Resources: Drawable getDrawable(int)>,<android.content.res.Resources: Drawable getDrawable(int)>,0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValue(id, value, true);
    }
    Drawable res = loadDrawable(value, id);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}","{
    final Drawable d = getDrawable(id, null);
    if (d.canApplyTheme()) {
        Log.w(TAG, ""Drawable "" + getResourceName(id) + "" has unresolved theme "" + ""attributes! Consider using Resources.getDrawable(int, Theme) or "" + ""Context.getDrawable(int)."", new RuntimeException());
    }
    return d;
}",1,"/**
 * Return a drawable object associated with a particular resource ID.
 * Various types of objects will be returned depending on the underlying
 * resource -- for example, a solid color, PNG image, scalable image, etc.
 * The Drawable API hides these implementation details.
 *
 * <p class=""note""><strong>Note:</strong> Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, this function
 * would not correctly retrieve the final configuration density when
 * the resource ID passed here is an alias to another Drawable resource.
 * This means that if the density configuration of the alias resource
 * is different than the actual resource, the density of the returned
 * Drawable would be incorrect, resulting in bad scaling.  To work
 * around this, you can instead retrieve the Drawable through
 * {@link TypedArray#getDrawable TypedArray.getDrawable}.  Use
 * {@link android.content.Context#obtainStyledAttributes(int[])
 * Context.obtainStyledAttributes} with
 * an array containing the resource ID of interest to create the TypedArray.</p>
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Drawable An object that can be used to draw this resource.
 */
","/**
 * Return a drawable object associated with a particular resource ID.
 * Various types of objects will be returned depending on the underlying
 * resource -- for example, a solid color, PNG image, scalable image, etc.
 * The Drawable API hides these implementation details.
 *
 * <p class=""note""><strong>Note:</strong> Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, this function
 * would not correctly retrieve the final configuration density when
 * the resource ID passed here is an alias to another Drawable resource.
 * This means that if the density configuration of the alias resource
 * is different than the actual resource, the density of the returned
 * Drawable would be incorrect, resulting in bad scaling.  To work
 * around this, you can instead retrieve the Drawable through
 * {@link TypedArray#getDrawable TypedArray.getDrawable}.  Use
 * {@link android.content.Context#obtainStyledAttributes(int[])
 * Context.obtainStyledAttributes} with
 * an array containing the resource ID of interest to create the TypedArray.</p>
 *
 * <p class=""note""><strong>Note:</strong> To obtain a themed drawable, use
 * {@link android.content.Context#getDrawable(int) Context.getDrawable(int)}
 * or {@link #getDrawable(int, Theme)} passing the desired theme.</p>
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @see #getDrawable(int, Theme)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early implementation involves retrieving value and loading the drawable through a series of steps, while the late implementation simplifies this by directly calling `getDrawable(id, null)` and adding some checks on the drawable's theme attributes, which indicates the entire implementation logic has been altered, hence causing change type 4. Also, the return statement changed as it is now directly returning the result of a different method `getDrawable(id, null)`, which is change type 1. The late implementation also relies on an entirely different API, `getDrawable(int, Theme)`, even though it is called with `null`, which makes it a change type 5.","Since the early and late versions of the API use different internal mechanisms to retrieve the drawable, this could potentially cause the API to return different draawable resources. Especially because the new version has an added theme resolution check that did not exist before, this could affect the final drawable returned or even add additional logging messages that were not present before, leading to a compatibility issue type 1."
923,"<android.content.res.TypedArray: float getDimension(int,float)>",20,21,"<android.content.res.TypedArray: float getDimension(int,float)>","<android.content.res.TypedArray: float getDimension(int,float)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var>.  Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var>.  Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late implementation introduces a new check for 'mRecycled' and throws an exception if it's true. The exception handling statement has been changed to add a new type check 'TypedValue.TYPE_ATTRIBUTE' and throw a different exception. Also there is a statement change from 'mResources.mMetrics' to 'mMetrics' within the method body. Thus, the change type is 2,3,4.","The introduction of a new exception for the recycled check and a new check for 'TypedValue.TYPE_ATTRIBUTE' can lead to different exceptions being thrown. The change of 'mResources.mMetrics' to 'mMetrics' could also lead to a different return value if the 'mMetrics' does not refer to the same object as 'mResources.mMetrics'. As a result, there are potential CIs due to different return values or types and different exception handlings, marking the CI types as 1,2."
925,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",20,21,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>","<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",0,"{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, null, getUserId());
    } catch (RemoteException e) {
    // System has crashed, nothing we can do.
    }
    return false;
}","{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, null, getUserId(), null);
    } catch (RemoteException e) {
    // System has crashed, nothing we can do.
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The invocation of method startInstrumentation on ActivityManagerNative.getDefault() includes an additional parameter in the late version, which indicates that the dependent API (ActivityManagerNative.getDefault().startInstrumentation()) has changed its parameter list. Therefore, the change type is 5.","Although the dependent API startInstrumentation changed, it does not necessarily cause a compatibility issue considering the method's usage because the existing parameters and return type remain unchanged, and the catch block for RemoteException is handling it the same way as before. Therefore, there is no compatibility issue."
926,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",20,21,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>","<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",0,"{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    activity.attach(context, aThread, this, token, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration());
    return activity;
}","{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    activity.attach(context, aThread, this, token, 0, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null);
    return activity;
}",1,"/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the sytem.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
","/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the sytem.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method `activity.attach` has an additional parameter `null` in the late version, which is a code change in the category 4 (Other statement changed) and 5 (Dependent API changed) because it involves a change to the argument list that is passed to a method invocation which is different from the arguments passed in the early version.","The new parameter being passed to the `activity.attach` method is `null`, which should not alter the behavior of the method assuming that the called method is correctly handling the new argument. This change alone does not constitute a change that could potentially cause different behavior from a client's perspective in regards to return values or exception handling, thus there is no Compatibility Issue (0)."
927,"<android.accounts.AccountManager.AmsTask.Response: void onError(int,String)>",20,21,"<android.accounts.AccountManager.AmsTask.Response: void onError(int,String)>","<android.accounts.AccountManager.AmsTask.Response: void onError(int,String)>",0,"{
    if (code == ERROR_CODE_CANCELED || code == ERROR_CODE_USER_RESTRICTED) {
        // the authenticator indicated that this request was canceled, do so now
        cancel(true);
        return;
    }
    setException(convertErrorToException(code, message));
}","{
    if (code == ERROR_CODE_CANCELED || code == ERROR_CODE_USER_RESTRICTED || code == ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {
        // the authenticator indicated that this request was canceled or we were
        // forbidden to fulfill; cancel now
        cancel(true);
        return;
    }
    setException(convertErrorToException(code, message));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"An additional condition is added to the 'if' statement (ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE), so the code change type is 3.","Even though there is an additional condition added to the 'if' statement causing a control dependency change, it does not lead to a Compatibility Issue because the execution flow and potential outcome (cancellation and setting an exception) remain consistent with the previous behavior for other error codes. The additional condition simply expands the cases in which the method will cancel the task, which is in line with the existing cancellation behavior. No new behaviors or outcomes have been introduced that would cause existing client code to break. Therefore, the CI type is 0."
928,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",20,21,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>","<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (isEnabled()) {
        int progress = getProgress();
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
                if (progress <= 0)
                    break;
                setProgress(progress - mKeyProgressIncrement, true);
                onKeyChange();
                return true;
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                if (progress >= getMax())
                    break;
                setProgress(progress + mKeyProgressIncrement, true);
                onKeyChange();
                return true;
        }
    }
    return super.onKeyDown(keyCode, event);
}","{
    if (isEnabled()) {
        int progress = getProgress();
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
                if (progress <= 0)
                    break;
                animateSetProgress(progress - mKeyProgressIncrement);
                onKeyChange();
                return true;
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                if (progress >= getMax())
                    break;
                animateSetProgress(progress + mKeyProgressIncrement);
                onKeyChange();
                return true;
        }
    }
    return super.onKeyDown(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The method setProgress(progress - mKeyProgressIncrement, true) has been replaced with animateSetProgress(progress - mKeyProgressIncrement) and setProgress(progress + mKeyProgressIncrement, true) with animateSetProgress(progress + mKeyProgressIncrement). There is also a control dependency change in the implementations (inside the 'if' and 'switch' statements), and those changes in the implementation of the event handling represent a modification to internal logic but not to the method signature, so the code change type is a combination of 3, 4, and 5.","The change in the implementation from setProgress to animateSetProgress could lead to different behavior because animateSetProgress might change the way progress is updated, possibly including animations or additional callbacks not present in setProgress. Given that a different method is invoked on the same object with possibly different side-effects, it could result in a different program state as observed by the user or other parts of the program, which classifies as a Compatibility Issue of type 1."
929,<android.content.res.TypedArray: void recycle()>,20,21,<android.content.res.TypedArray: void recycle()>,<android.content.res.TypedArray: void recycle()>,0,"{
    synchronized (mResources.mAccessLock) {
        TypedArray cached = mResources.mCachedStyledAttributes;
        if (cached == null || cached.mData.length < mData.length) {
            mXml = null;
            mResources.mCachedStyledAttributes = this;
        }
    }
}","{
    if (mRecycled) {
        throw new RuntimeException(toString() + "" recycled twice!"");
    }
    mRecycled = true;
    // These may have been set by the client.
    mXml = null;
    mTheme = null;
    mResources.mTypedArrayPool.release(this);
}",1,"/**
 * Give back a previously retrieved array, for later re-use.
 */
","/**
 * Recycle the TypedArray, to be re-used by a later caller. After calling
 * this function you must not ever touch the typed array again.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late implementation adds a new check for whether the object is already recycled (if (mRecycled) throw new RuntimeException()), sets mRecycled to true, and releases the TypedArray back to the pool with mResources.mTypedArrayPool.release(this). These are significant changes, including a new throw statement, changes to the control flow, and other statements (object state changes), so the change types are 2,3,4.","The new throw statement can cause the API to throw an exception when the TypedArray is recycled twice, which is a new behavior (CI type 2), and the introduction of the statement 'mResources.mTypedArrayPool.release(this)' could change the behavior of how the TypedArray object is reused, leading to a potential different return value (even though the method is void, the state of the object is returned through the object's fields), which is classified as CI type 1."
933,<android.widget.Switch: boolean onTouchEvent(MotionEvent)>,20,21,<android.widget.Switch: boolean onTouchEvent(MotionEvent)>,<android.widget.Switch: boolean onTouchEvent(MotionEvent)>,0,"{
    mVelocityTracker.addMovement(ev);
    final int action = ev.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                final float y = ev.getY();
                if (isEnabled() && hitThumb(x, y)) {
                    mTouchMode = TOUCH_MODE_DOWN;
                    mTouchX = x;
                    mTouchY = y;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_IDLE:
                        // Didn't target the thumb, treat normally.
                        break;
                    case TOUCH_MODE_DOWN:
                        {
                            final float x = ev.getX();
                            final float y = ev.getY();
                            if (Math.abs(x - mTouchX) > mTouchSlop || Math.abs(y - mTouchY) > mTouchSlop) {
                                mTouchMode = TOUCH_MODE_DRAGGING;
                                getParent().requestDisallowInterceptTouchEvent(true);
                                mTouchX = x;
                                mTouchY = y;
                                return true;
                            }
                            break;
                        }
                    case TOUCH_MODE_DRAGGING:
                        {
                            final float x = ev.getX();
                            final float dx = x - mTouchX;
                            float newPos = Math.max(0, Math.min(mThumbPosition + dx, getThumbScrollRange()));
                            if (newPos != mThumbPosition) {
                                mThumbPosition = newPos;
                                mTouchX = x;
                                invalidate();
                            }
                            return true;
                        }
                }
                break;
            }
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            {
                if (mTouchMode == TOUCH_MODE_DRAGGING) {
                    stopDrag(ev);
                    return true;
                }
                mTouchMode = TOUCH_MODE_IDLE;
                mVelocityTracker.clear();
                break;
            }
    }
    return super.onTouchEvent(ev);
}","{
    mVelocityTracker.addMovement(ev);
    final int action = ev.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                final float y = ev.getY();
                if (isEnabled() && hitThumb(x, y)) {
                    mTouchMode = TOUCH_MODE_DOWN;
                    mTouchX = x;
                    mTouchY = y;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_IDLE:
                        // Didn't target the thumb, treat normally.
                        break;
                    case TOUCH_MODE_DOWN:
                        {
                            final float x = ev.getX();
                            final float y = ev.getY();
                            if (Math.abs(x - mTouchX) > mTouchSlop || Math.abs(y - mTouchY) > mTouchSlop) {
                                mTouchMode = TOUCH_MODE_DRAGGING;
                                getParent().requestDisallowInterceptTouchEvent(true);
                                mTouchX = x;
                                mTouchY = y;
                                return true;
                            }
                            break;
                        }
                    case TOUCH_MODE_DRAGGING:
                        {
                            final float x = ev.getX();
                            final int thumbScrollRange = getThumbScrollRange();
                            final float thumbScrollOffset = x - mTouchX;
                            float dPos;
                            if (thumbScrollRange != 0) {
                                dPos = thumbScrollOffset / thumbScrollRange;
                            } else {
                                // If the thumb scroll range is empty, just use the
                                // movement direction to snap on or off.
                                dPos = thumbScrollOffset > 0 ? 1 : -1;
                            }
                            if (isLayoutRtl()) {
                                dPos = -dPos;
                            }
                            final float newPos = MathUtils.constrain(mThumbPosition + dPos, 0, 1);
                            if (newPos != mThumbPosition) {
                                mTouchX = x;
                                setThumbPosition(newPos);
                            }
                            return true;
                        }
                }
                break;
            }
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            {
                if (mTouchMode == TOUCH_MODE_DRAGGING) {
                    stopDrag(ev);
                    // Allow super class to handle pressed state, etc.
                    super.onTouchEvent(ev);
                    return true;
                }
                mTouchMode = TOUCH_MODE_IDLE;
                mVelocityTracker.clear();
                break;
            }
    }
    return super.onTouchEvent(ev);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The handling calculations within the `TOUCH_MODE_DRAGGING` case block have changed (e.g., introduction of `thumbScrollRange`, `thumbScrollOffset`, calculation of `dPos`, etc.), and there is a change on how `newPos` is calculated and then how it is set (`setThumbPosition(newPos)` instead of `mThumbPosition = newPos`). Additionally, the call to `invalidate()` in the early version has been removed. Hence, the modification represents a change in other statements (4), but also a control dependency change (3) since it affects the math and state changes during the gesture.","Though there are considerable code changes within the `TOUCH_MODE_DRAGGING` case, they are all related to how the internal values used to track and perform the switch's dragging behavior are calculated. The return value of the method is still consistently `true` upon dragging, and the method's contract appears intact because it still returns `super.onTouchEvent(ev)` at the end of execution, just like in the previous version. Additionally, the `ACTION_UP` and `ACTION_CANCEL` cases, despite the introduction of the call to `super.onTouchEvent(ev)`, keep returning `true` when `mTouchMode` is `TOUCH_MODE_DRAGGING`, which aligns with the old behavior. Therefore, even though the implementation details have changed, the outward behavior of the method with regards to its return value or exception throwing has not been altered in a way that would constitute a compatibility issue."
934,"<android.os.Bundle: void writeToParcel(Parcel,int)>",20,21,"<android.os.Bundle: void writeToParcel(Parcel,int)>","<android.os.Bundle: void writeToParcel(Parcel,int)>",0,"{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        if (mParcelledData != null) {
            if (mParcelledData == EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
        } else {
            // Special case for empty bundles.
            if (mMap == null || mMap.size() <= 0) {
                parcel.writeInt(0);
                return;
            }
            int lengthPos = parcel.dataPosition();
            // dummy, will hold length
            parcel.writeInt(-1);
            parcel.writeInt(BUNDLE_MAGIC);
            int startPos = parcel.dataPosition();
            parcel.writeArrayMapInternal(mMap);
            int endPos = parcel.dataPosition();
            // Backpatch length
            parcel.setDataPosition(lengthPos);
            int length = endPos - startPos;
            parcel.writeInt(length);
            parcel.setDataPosition(endPos);
        }
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}","{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        super.writeToParcelInner(parcel, flags);
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the method has significantly changed. It went from explicit logic using Parcel operations to a single call to super.writeToParcelInner(parcel, flags). Both the return statement has been changed (no more 'return' in the late version), and the statements that write data to the parcel have been removed. Also, there's a change in dependent API, which is from self-contained logic to a call to a method in the superclass, so the changes are of type 1, 4, and 5.","The method has changed how it writes to the Parcel, by delegating to the superclass with different parcel-writing logic, so the Parcelable representation of the Bundle will be different between the versions, resulting in a Compatibility Issue of type 1."
938,<android.app.Notification.Style: RemoteViews getStandardView(int)>,20,21,<android.app.Notification.Style: RemoteViews getStandardView(int)>,<android.app.Notification.Style: RemoteViews getStandardView(int)>,0,"{
    checkBuilder();
    if (mBigContentTitle != null) {
        mBuilder.setContentTitle(mBigContentTitle);
    }
    RemoteViews contentView = mBuilder.applyStandardTemplateWithActions(layoutId);
    if (mBigContentTitle != null && mBigContentTitle.equals("""")) {
        contentView.setViewVisibility(R.id.line1, View.GONE);
    } else {
        contentView.setViewVisibility(R.id.line1, View.VISIBLE);
    }
    // The last line defaults to the subtext, but can be replaced by mSummaryText
    final CharSequence overflowText = mSummaryTextSet ? mSummaryText : mBuilder.mSubText;
    if (overflowText != null) {
        contentView.setTextViewText(R.id.text, overflowText);
        contentView.setViewVisibility(R.id.overflow_divider, View.VISIBLE);
        contentView.setViewVisibility(R.id.line3, View.VISIBLE);
    } else {
        contentView.setViewVisibility(R.id.overflow_divider, View.GONE);
        contentView.setViewVisibility(R.id.line3, View.GONE);
    }
    return contentView;
}","{
    checkBuilder();
    // Nasty.
    CharSequence oldBuilderContentTitle = mBuilder.mContentTitle;
    if (mBigContentTitle != null) {
        mBuilder.setContentTitle(mBigContentTitle);
    }
    RemoteViews contentView = mBuilder.applyStandardTemplateWithActions(layoutId);
    mBuilder.mContentTitle = oldBuilderContentTitle;
    if (mBigContentTitle != null && mBigContentTitle.equals("""")) {
        contentView.setViewVisibility(R.id.line1, View.GONE);
    } else {
        contentView.setViewVisibility(R.id.line1, View.VISIBLE);
    }
    // The last line defaults to the subtext, but can be replaced by mSummaryText
    final CharSequence overflowText = mSummaryTextSet ? mSummaryText : mBuilder.mSubText;
    if (overflowText != null) {
        contentView.setTextViewText(R.id.text, mBuilder.processLegacyText(overflowText));
        contentView.setViewVisibility(R.id.overflow_divider, View.VISIBLE);
        contentView.setViewVisibility(R.id.line3, View.VISIBLE);
    } else {
        // Clear text in case we use the line to show the profile badge.
        contentView.setTextViewText(R.id.text, """");
        contentView.setViewVisibility(R.id.overflow_divider, View.GONE);
        contentView.setViewVisibility(R.id.line3, View.GONE);
    }
    return contentView;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation introduces a new statement to store the old content title, some changes within the if-else blocks such as calling mBuilder.processLegacyText(overflowText) instead of only setting the overflowText, and it sets the text to an empty string when overflowText is null. These changes do not affect control dependencies but do involve other statement changes and a change to the return statement since the text set into the contentView might differ. Thus, the changes are categorized as 1,4.","Given that the contentView's text is set differently (with mBuilder.processLegacyText in the late version), the API could potentially return a RemoteViews object with different text content. Therefore, the CI type is 1."
939,<android.widget.CalendarView: int getFocusedMonthDateColor()>,20,21,<android.widget.CalendarView: int getFocusedMonthDateColor()>,<android.widget.CalendarView: int getFocusedMonthDateColor()>,0,"{
    return mFocusedMonthDateColor;
}","{
    return mDelegate.getFocusedMonthDateColor();
}",1,"/**
 * Gets the color for the dates in the focused month.
 *
 * @return The focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_focusedMonthDateColor
 */
","/**
 * Gets the color for the dates in the focused month.
 *
 * @return The focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_focusedMonthDateColor
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation has changed to call a method on mDelegate to retrieve the color value instead of directly returning a member variable, indicating a Dependent API changed (5).","This change in method invocation to retrieve the color potentially results in a different value being returned due to the behavior of mDelegate.getFocusedMonthDateColor(), leading to a Compatibility Issue regarding potential different return values (1)."
940,<android.view.View: float getScaleX()>,20,21,<android.view.View: float getScaleX()>,<android.view.View: float getScaleX()>,0,"{
    return mTransformationInfo != null ? mTransformationInfo.mScaleX : 1;
}","{
    return mRenderNode.getScaleX();
}",1,"/**
 * The amount that the view is scaled in x around the pivot point, as a proportion of
 * the view's unscaled width. A value of 1, the default, means that no scaling is applied.
 *
 * <p>By default, this is 1.0f.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The scaling factor.
 */
","/**
 * The amount that the view is scaled in x around the pivot point, as a proportion of
 * the view's unscaled width. A value of 1, the default, means that no scaling is applied.
 *
 * <p>By default, this is 1.0f.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The scaling factor.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has completely changed from directly accessing a field with a conditional operator to calling a method (getScaleX) on a different object (mRenderNode), resulting in both a return statement change and a change in the dependent API, so the code change type is 1,5.","This change alters the source of the returned scale value; the early version uses `mTransformationInfo.mScaleX` or defaults to 1, while the late version relies upon `mRenderNode.getScaleX()`. Since the value comes from a different place, this can potentially return a different value, hence the CI type is 1."
942,<android.os.Bundle: CharSequence getCharSequence(String)>,20,21,<android.os.Bundle: CharSequence getCharSequence(String)>,<android.os.Bundle: CharSequence getCharSequence(String)>,0,"{
    unparcel();
    final Object o = mMap.get(key);
    try {
        return (CharSequence) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""CharSequence"", e);
        return null;
    }
}","{
    return super.getCharSequence(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a CharSequence value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a CharSequence value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The code has changed from a direct implementation that gets the value from a map and handles potential ClassCastException to calling a superclass method with the same functionality. Since `super.getCharSequence(key)` is now being used and the specific implementation details are hidden, we can deduce that this is using a dependent API which might have its own implementation, hence change type 1,5.","If the superclass method `getCharSequence` has a different implementation compared to the explicit casting and error handling that took place in the early version, the returned value could be different, so the CI type is 1."
943,"<android.animation.RectEvaluator: Rect evaluate(float,Rect,Rect)>",20,21,"<android.animation.RectEvaluator: Rect evaluate(float,Rect,Rect)>","<android.animation.RectEvaluator: Rect evaluate(float,Rect,Rect)>",0,"{
    return new Rect(startValue.left + (int) ((endValue.left - startValue.left) * fraction), startValue.top + (int) ((endValue.top - startValue.top) * fraction), startValue.right + (int) ((endValue.right - startValue.right) * fraction), startValue.bottom + (int) ((endValue.bottom - startValue.bottom) * fraction));
}","{
    int left = startValue.left + (int) ((endValue.left - startValue.left) * fraction);
    int top = startValue.top + (int) ((endValue.top - startValue.top) * fraction);
    int right = startValue.right + (int) ((endValue.right - startValue.right) * fraction);
    int bottom = startValue.bottom + (int) ((endValue.bottom - startValue.bottom) * fraction);
    if (mRect == null) {
        return new Rect(left, top, right, bottom);
    } else {
        mRect.set(left, top, right, bottom);
        return mRect;
    }
}",1,"/**
 * This function returns the result of linearly interpolating the start and
 * end Rect values, with <code>fraction</code> representing the proportion
 * between the start and end values. The calculation is a simple parametric
 * calculation on each of the separate components in the Rect objects
 * (left, top, right, and bottom).
 *
 * @param fraction   The fraction from the starting to the ending values
 * @param startValue The start Rect
 * @param endValue   The end Rect
 * @return A linear interpolation between the start and end values, given the
 * <code>fraction</code> parameter.
 */
","/**
 * This function returns the result of linearly interpolating the start and
 * end Rect values, with <code>fraction</code> representing the proportion
 * between the start and end values. The calculation is a simple parametric
 * calculation on each of the separate components in the Rect objects
 * (left, top, right, and bottom).
 *
 * <p>If {@link #RectEvaluator(android.graphics.Rect)} was used to construct
 * this RectEvaluator, the object returned will be the <code>reuseRect</code>
 * passed into the constructor.</p>
 *
 * @param fraction   The fraction from the starting to the ending values
 * @param startValue The start Rect
 * @param endValue   The end Rect
 * @return A linear interpolation between the start and end values, given the
 * <code>fraction</code> parameter.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,The late version of the implementation has introduced local variables for the calculations and added a conditional structure to decide whether to create a new Rect or update an existing one (mRect). The change types include a control dependency change (3) and also a change in return statement (1) as it possibly introduces a return of an existing 'mRect' object instead of always creating a new one.,"There is a change in the return value. In the early version, a new Rect object is always returned, whereas, in the late version, it might return a previously existing 'mRect' object if it's not null, changing the behavior and thus leading to a potential compatibility issue of type 1."
945,"<android.view.LayoutInflater: View inflate(int,ViewGroup,boolean)>",20,21,"<android.view.LayoutInflater: View inflate(int,ViewGroup,boolean)>","<android.view.LayoutInflater: View inflate(int,ViewGroup,boolean)>",0,"{
    if (DEBUG)
        System.out.println(""INFLATING from resource: "" + resource);
    XmlResourceParser parser = getContext().getResources().getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}","{
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, ""INFLATING from resource: \"""" + res.getResourceName(resource) + ""\"" ("" + Integer.toHexString(resource) + "")"");
    }
    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}",1,"/**
 * Inflate a new view hierarchy from the specified xml resource. Throws
 * {@link InflateException} if there is an error.
 *
 * @param resource ID for an XML layout resource to load (e.g.,
 * <code>R.layout.main_page</code>)
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
","/**
 * Inflate a new view hierarchy from the specified xml resource. Throws
 * {@link InflateException} if there is an error.
 *
 * @param resource ID for an XML layout resource to load (e.g.,
 * <code>R.layout.main_page</code>)
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The behavior of logging during debug mode has been modified, where the logging method and the message that is being logged are changed. The functionality of this API is not affected by the change in the log statement as the important part of the implementation, which is inflating the XML parser, remains the same. Therefore, the change type is 4.","Since the changes made only affect debug logging and not the execution flow of the method or functionality, there are no Compatibility Issues in this scenario. The method's behavior from an external perspective remains unchanged."
946,<android.view.SurfaceControl.PhysicalDisplayInfo: String toString()>,20,21,<android.view.SurfaceControl.PhysicalDisplayInfo: String toString()>,<android.view.SurfaceControl.PhysicalDisplayInfo: String toString()>,0,"{
    return ""PhysicalDisplayInfo{"" + width + "" x "" + height + "", "" + refreshRate + "" fps, "" + ""density "" + density + "", "" + xDpi + "" x "" + yDpi + "" dpi, secure "" + secure + ""}"";
}","{
    return ""PhysicalDisplayInfo{"" + width + "" x "" + height + "", "" + refreshRate + "" fps, "" + ""density "" + density + "", "" + xDpi + "" x "" + yDpi + "" dpi, secure "" + secure + "", appVsyncOffset "" + appVsyncOffsetNanos + "", bufferDeadline "" + presentationDeadlineNanos + ""}"";
}",1,"// For debugging purposes
","// For debugging purposes
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There are additions to the string being returned, namely ""appVsyncOffset "" + appVsyncOffsetNanos + "", bufferDeadline "" + presentationDeadlineNanos. These additions represent a change in the structure of the string returned by the toString method, so the code change type is 4.","The change to the method's return statement, which includes additional information about appVsyncOffset and presentationDeadline, indicates that the return value has been altered. Therefore, a potential Compatibility Issue due to different return values exists, and the CI type is 1."
948,<android.os.MessageQueue: int enqueueSyncBarrier(long)>,20,21,<android.os.MessageQueue: int enqueueSyncBarrier(long)>,<android.os.MessageQueue: int enqueueSyncBarrier(long)>,0,"{
    // We don't need to wake the queue because the purpose of a barrier is to stall it.
    synchronized (this) {
        final int token = mNextBarrierToken++;
        final Message msg = Message.obtain();
        msg.when = when;
        msg.arg1 = token;
        Message prev = null;
        Message p = mMessages;
        if (when != 0) {
            while (p != null && p.when <= when) {
                prev = p;
                p = p.next;
            }
        }
        if (prev != null) {
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        } else {
            msg.next = p;
            mMessages = msg;
        }
        return token;
    }
}","{
    // We don't need to wake the queue because the purpose of a barrier is to stall it.
    synchronized (this) {
        final int token = mNextBarrierToken++;
        final Message msg = Message.obtain();
        msg.markInUse();
        msg.when = when;
        msg.arg1 = token;
        Message prev = null;
        Message p = mMessages;
        if (when != 0) {
            while (p != null && p.when <= when) {
                prev = p;
                p = p.next;
            }
        }
        if (prev != null) {
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        } else {
            msg.next = p;
            mMessages = msg;
        }
        return token;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of the statement msg.markInUse() in the late implementation, which is an internal state change and does not affect the return value or exception throwing, so the code change type is 4.","This additional call to markInUse() does not alter the behavior of enqueueSyncBarrier() in terms of the returned value or the thrown exceptions. Therefore, there is no Compatibility Issue, which is represented as 0."
949,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,20,21,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,0,"{
    try {
        return mService.getAuthenticatorTypes();
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}","{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
","/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,The `getAuthenticatorTypes()` method now includes a new parameter `UserHandle.getCallingUserId()` in the late version. It's an other statement that has changed and it also constitutes a dependent API changed because a different version of `getAuthenticatorTypes()` is being called.,"Although an additional parameter is being passed to the `getAuthenticatorTypes()` method, the type and the number of exceptions the method can throw have not changed, and the return type remains the same. Therefore, there's no Compatibility Issue concerning different return values or exception handlings."
950,<android.view.View: float getRotationX()>,20,21,<android.view.View: float getRotationX()>,<android.view.View: float getRotationX()>,0,"{
    return mTransformationInfo != null ? mTransformationInfo.mRotationX : 0;
}","{
    return mRenderNode.getRotationX();
}",1,"/**
 * The degrees that the view is rotated around the horizontal axis through the pivot point.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @see #setRotationX(float)
 *
 * @return The degrees of X rotation.
 */
","/**
 * The degrees that the view is rotated around the horizontal axis through the pivot point.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @see #setRotationX(float)
 *
 * @return The degrees of X rotation.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from using a conditional operator and member field (mTransformationInfo.mRotationX) to calling a method on mRenderNode (mRenderNode.getRotationX()), and there is no local fallback value of 0 as in the early version. This is a return statement change and also a dependent API change, since it is now depending on mRenderNode's getRotationX() method, so the code change type is 1,5.","Since the method of obtaining the rotationX value has completely changed, this could lead to the API returning a different value. As there isn't a 1:1 guarantee that `mTransformationInfo.mRotationX` and `mRenderNode.getRotationX()` will return identical values for all cases, there's a potential compatibility issue due to a possible different return value, making the CI type 1."
951,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,20,21,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    MotionEvent vtev = MotionEvent.obtain(ev);
    final int actionMasked = ev.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        mNestedYOffset = 0;
    }
    vtev.offsetLocation(0, mNestedYOffset);
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {
                deltaY -= mScrollConsumed[1];
                vtev.offsetLocation(0, mScrollOffset[1]);
                mNestedYOffset += mScrollOffset[1];
            }
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y - mScrollOffset[1];
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true) && !hasNestedScrollingParent()) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                final int scrolledDeltaY = mScrollY - oldY;
                final int unconsumedY = deltaY - scrolledDeltaY;
                if (dispatchNestedScroll(0, scrolledDeltaY, 0, unconsumedY, mScrollOffset)) {
                    mLastMotionY -= mScrollOffset[1];
                    vtev.offsetLocation(0, mScrollOffset[1]);
                    mNestedYOffset += mScrollOffset[1];
                } else if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight(), ev.getX(activePointerIndex) / getWidth());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight(), 1.f - ev.getX(activePointerIndex) / getWidth());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                    flingWithNestedDispatch(-initialVelocity);
                } else if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    if (mVelocityTracker != null) {
        mVelocityTracker.addMovement(vtev);
    }
    vtev.recycle();
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
952,<android.animation.ObjectAnimator: void animateValue(float)>,20,21,<android.animation.ObjectAnimator: void animateValue(float)>,<android.animation.ObjectAnimator: void animateValue(float)>,0,"{
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(mTarget);
    }
}","{
    final Object target = getTarget();
    if (mTarget != null && target == null) {
        // We lost the target reference, cancel and clean up.
        cancel();
        return;
    }
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(target);
    }
}",1,"/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */
","/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version introduces a new block that involves a new local variable `target`, a condition check, a call to `cancel()`, and a `return` statement. The `for` loop uses `target` instead of `mTarget`, however, it doesn't constitute a dependent API change as it is a local variable assignment within the method itself. Since a new control statement (`if`) has been added, along with an additional call to `cancel()` and `return` statement, the changes are 1,3,4.","There is now a potential for the method to exit early if the target is lost, which wasn't possible in the early version. Additionally, the `animateValue` method now potentially operates on a different object (local `target` vs. member `mTarget`). Both changes affect the observable behavior of the method, thus there is the potential for different return values (early exit), and CI type is 1."
954,<android.widget.TimePicker: boolean isEnabled()>,20,21,<android.widget.TimePicker: boolean isEnabled()>,<android.widget.TimePicker: boolean isEnabled()>,0,"{
    return mIsEnabled;
}","{
    return mDelegate.isEnabled();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method implementation has changed from directly accessing a field (return mIsEnabled;) to calling a method on a delegate object (return mDelegate.isEnabled();), and this method call is an example of a Dependent API change, so the code change type is 4,5.","This change could potentially return a different value if the isEnabled implementation in the Delegate behaves differently than the direct field access previously used. Consequently, there is a change in the potential behavior of the API, leading to a CI of type 1."
955,<android.view.KeyEvent: String keyCodeToString(int)>,20,21,<android.view.KeyEvent: String keyCodeToString(int)>,<android.view.KeyEvent: String keyCodeToString(int)>,0,"{
    String symbolicName = KEYCODE_SYMBOLIC_NAMES.get(keyCode);
    return symbolicName != null ? symbolicName : Integer.toString(keyCode);
}","{
    String symbolicName = nativeKeyCodeToString(keyCode);
    return symbolicName != null ? LABEL_PREFIX + symbolicName : Integer.toString(keyCode);
}",1,"/**
 * Returns a string that represents the symbolic name of the specified keycode
 * such as ""KEYCODE_A"", ""KEYCODE_DPAD_UP"", or an equivalent numeric constant
 * such as ""1001"" if unknown.
 *
 * @param keyCode The key code.
 * @return The symbolic name of the specified keycode.
 *
 * @see KeyCharacterMap#getDisplayLabel
 */
","/**
 * Returns a string that represents the symbolic name of the specified keycode
 * such as ""KEYCODE_A"", ""KEYCODE_DPAD_UP"", or an equivalent numeric constant
 * such as ""1001"" if unknown.
 *
 * @param keyCode The key code.
 * @return The symbolic name of the specified keycode.
 *
 * @see KeyCharacterMap#getDisplayLabel
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation changed from using KEYCODE_SYMBOLIC_NAMES.get(keyCode) to nativeKeyCodeToString(keyCode), which alters the method that is being used to get the string representation of the keyCode. In addition, it now prepends LABEL_PREFIX to the symbolic name if it's not null. The change in the dependant method and string construction logic makes this both an 'Other statement changed' and 'Dependent API changed', so the code change type is 1,4,5.","The changes could potentially return a different string value because a different method is being used to obtain the keyCode's string representation and the formatting of the result has been altered by appending a prefix. Therefore, it's a Compatibility Issue caused by potential different return values, and the CI type is 1."
957,<android.appwidget.AppWidgetHostView: View getDefaultView()>,20,21,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContextAsUser(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED, mUser);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The `PackageManager.NameNotFoundException` catch block has been removed from the late version, which is a change in the exception handling statement (change type 2). Additionally, the method call to `mContext.createPackageContextAsUser` has been replaced with a call to `getRemoteContext()` in the try block, which indicates a change in the dependent API (change type 5).","By removing the catch block for `PackageManager.NameNotFoundException`, the late version will no longer catch and handle this exception and can throw it up to the caller, which could lead to a different exception handling behavior (CI type 2)."
958,<android.content.pm.PackageItemInfo: Drawable loadIcon(PackageManager)>,20,21,<android.content.pm.PackageItemInfo: Drawable loadIcon(PackageManager)>,<android.content.pm.PackageItemInfo: Drawable loadIcon(PackageManager)>,0,"{
    if (icon != 0) {
        Drawable dr = pm.getDrawable(packageName, icon, getApplicationInfo());
        if (dr != null) {
            return dr;
        }
    }
    return loadDefaultIcon(pm);
}","{
    return pm.loadItemIcon(this, getApplicationInfo());
}",1,"/**
 * Retrieve the current graphical icon associated with this item.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the item's icon.  If the
 * item does not have an icon, the item's default icon is returned
 * such as the default activity icon.
 */
","/**
 * Retrieve the current graphical icon associated with this item.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the item's icon.  If the
 * item does not have an icon, the item's default icon is returned
 * such as the default activity icon.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has completely changed from one that includes a conditional check and possible return of a default icon to a direct call to pm.loadItemIcon with the current object and application info, so the code change type is 1,5.","The API now potentially returns a different drawable because the method of obtaining the icon has changed from using internal logic to a direct function call on PackageManager, thus the CI type is 1."
959,<android.util.ArrayMap: V remove(Object)>,20,21,<android.util.ArrayMap: V remove(Object)>,<android.util.ArrayMap: V remove(Object)>,0,"{
    int index = key == null ? indexOfNull() : indexOf(key, key.hashCode());
    if (index >= 0) {
        return removeAt(index);
    }
    return null;
}","{
    final int index = indexOfKey(key);
    if (index >= 0) {
        return removeAt(index);
    }
    return null;
}",1,"/**
 * Remove an existing key from the array map.
 * @param key The key of the mapping to remove.
 * @return Returns the value that was stored under the key, or null if there
 * was no such key.
 */
","/**
 * Remove an existing key from the array map.
 * @param key The key of the mapping to remove.
 * @return Returns the value that was stored under the key, or null if there
 * was no such key.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method used to find the index has changed from using key == null ? indexOfNull() : indexOf(key, key.hashCode()) to indexOfKey(key). The dependent API used for finding the index has changed, so the code change type is 1,5.","Since the method used to find the index of the key has been altered, it could potentially affect the return value of remove(Object) due to different index calculation. Consequently, this modification is classified as a CI type 1."
961,"<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,String)>",20,21,"<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,String)>","<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,String)>",0,"{
    try {
        return mService.stopUsingNetworkFeature(networkType, feature);
    } catch (RemoteException e) {
        return -1;
    }
}","{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy stopUsingNetworkFeature for "" + networkType + "", "" + feature);
        return -1;
    }
    NetworkCallback networkCallback = removeRequestForFeature(netCap);
    if (networkCallback != null) {
        Log.d(TAG, ""stopUsingNetworkFeature for "" + networkType + "", "" + feature);
        unregisterNetworkCallback(networkCallback);
    }
    return 1;
}",1,"/**
 * Tells the underlying networking system that the caller is finished
 * using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature that is no longer needed
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 */
","/**
 * Tells the underlying networking system that the caller is finished
 * using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature that is no longer needed
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The late version entirely changes the implementation, introduces control statements (if conditions), removes a try-catch block, modifies the return statements, and uses new methods such as `networkCapabilitiesForFeature`, `removeRequestForFeature`, and `unregisterNetworkCallback` which do not exist in the early version. Therefore, it includes changes of types 1, 3, 4, and 5.","The late version changes the logic of the method and the returned value, including the removal of RemoteException handling which could have returned -1, and also introduces new if-conditions affecting the flow and return value. Now the method always returns 1 upon success, which is a different behavior from returning a value from the `mService.stopUsingNetworkFeature` in the early version. This can also result in a different exception handling because RemoteException is no longer caught. Thus, there is a Compatibility Issue of types 1."
962,"<android.content.res.XmlBlock.Parser: int getAttributeResourceValue(int,int)>",20,21,"<android.content.res.XmlBlock.Parser: int getAttributeResourceValue(int,int)>","<android.content.res.XmlBlock.Parser: int getAttributeResourceValue(int,int)>",0,"{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on appt doing the conversion for us.
    if (t == TypedValue.TYPE_REFERENCE) {
        return nativeGetAttributeData(mParseState, idx);
    }
    return defaultValue;
}","{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on aapt doing the conversion for us.
    if (t == TypedValue.TYPE_REFERENCE) {
        return nativeGetAttributeData(mParseState, idx);
    }
    return defaultValue;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the implementation between the early version and the late version, except for the spelling correction in the comment which does not affect functionality. The method signature, parameters, and body are identical in both versions.","Since there is no functional change in the implementation between the versions, there is no potential for compatibility issues."
965,<android.app.ActivityThread.StopInfo: void run()>,20,21,<android.app.ActivityThread.StopInfo: void run()>,<android.app.ActivityThread.StopInfo: void run()>,0,"{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + activity);
        ActivityManagerNative.getDefault().activityStopped(activity.token, state, thumbnail, description);
    } catch (RemoteException ex) {
    }
}","{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + activity);
        ActivityManagerNative.getDefault().activityStopped(activity.token, state, persistentState, description);
    } catch (RemoteException ex) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The parameter passed to the method ActivityManagerNative.getDefault().activityStopped has changed from thumbnail to persistentState, hence this is a change in the dependent API call, which is change type 5. Although we see a parameter change in the ActivityManagerNative.getDefault().activityStopped method call, there is no new or removed return statement or exception handling logic. Therefore, there is also a type 4 for other statement changed.","Even though the dependent API call signature has changed, given the information provided here, there is no indication that this would cause the method run() to behave differently from the perspective of return values or thrown exceptions. Thus, no compatibility issue is expected, which is type 0."
966,<android.widget.Toast.TN: void handleShow()>,20,21,<android.widget.Toast.TN: void handleShow()>,<android.widget.Toast.TN: void handleShow()>,0,"{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        Context context = mView.getContext().getApplicationContext();
        if (context == null) {
            context = mView.getContext();
        }
        mWM = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        // We can resolve the Gravity here by using the Locale for getting
        // the layout direction
        final Configuration config = mView.getContext().getResources().getConfiguration();
        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
        mParams.gravity = gravity;
        if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
            mParams.horizontalWeight = 1.0f;
        }
        if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
            mParams.verticalWeight = 1.0f;
        }
        mParams.x = mX;
        mParams.y = mY;
        mParams.verticalMargin = mVerticalMargin;
        mParams.horizontalMargin = mHorizontalMargin;
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        if (localLOGV)
            Log.v(TAG, ""ADD! "" + mView + "" in "" + this);
        mWM.addView(mView, mParams);
        trySendAccessibilityEvent();
    }
}","{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        Context context = mView.getContext().getApplicationContext();
        String packageName = mView.getContext().getOpPackageName();
        if (context == null) {
            context = mView.getContext();
        }
        mWM = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        // We can resolve the Gravity here by using the Locale for getting
        // the layout direction
        final Configuration config = mView.getContext().getResources().getConfiguration();
        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
        mParams.gravity = gravity;
        if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
            mParams.horizontalWeight = 1.0f;
        }
        if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
            mParams.verticalWeight = 1.0f;
        }
        mParams.x = mX;
        mParams.y = mY;
        mParams.verticalMargin = mVerticalMargin;
        mParams.horizontalMargin = mHorizontalMargin;
        mParams.packageName = packageName;
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        if (localLOGV)
            Log.v(TAG, ""ADD! "" + mView + "" in "" + this);
        mWM.addView(mView, mParams);
        trySendAccessibilityEvent();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A local variable `packageName` is introduced, and its value is assigned to `mParams.packageName`. This change does not affect the returned value or thrown exceptions; it's an internal change. So, the code change type is 4.","There is no Compatibility Issue here since no return values, types, or exceptions that are thrown are affected by this change. The change is purely internal and does not modify the API contract."
968,<android.os.Bundle: byte[] getByteArray(String)>,20,21,<android.os.Bundle: byte[] getByteArray(String)>,<android.os.Bundle: byte[] getByteArray(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (byte[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""byte[]"", e);
        return null;
    }
}","{
    return super.getByteArray(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a byte[] value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a byte[] value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation change from a specific logic to a direct call to the superclass method `super.getByteArray(key)`, which indicates a change in the dependent API being used, so the code change type is 5.","Even though the method now delegates to the superclass with 'super.getByteArray(key)', if the superclass method has the same logic as the old implementation, there should be no compatibility issue. The superclass method implementation is not visible here, but if it adheres to the contract of the 'getByteArray' method, it should be functionally equivalent and thus cause no compatibility issue. Hence, the CI type is 0."
969,"<android.print.PrintManager.PrintDocumentAdapterDelegate: void write(PageRange[],ParcelFileDescriptor,IWriteResultCallback,int)>",20,21,"<android.print.PrintManager.PrintDocumentAdapterDelegate: void write(PageRange[],ParcelFileDescriptor,IWriteResultCallback,int)>","<android.print.PrintManager.PrintDocumentAdapterDelegate: void write(PageRange[],ParcelFileDescriptor,IWriteResultCallback,int)>",0,"{
    final boolean destroyed;
    synchronized (mLock) {
        destroyed = mDestroyed;
        // If start called and not finished called and not destroyed - do some work.
        if (mStartReqeusted && !mFinishRequested && !mDestroyed) {
            // Write cancels previous writes.
            if (mLastWriteSpec != null) {
                IoUtils.closeQuietly(mLastWriteSpec.fd);
                mLastWriteSpec = null;
            }
            mLastWriteSpec = new WriteSpec();
            mLastWriteSpec.callback = callback;
            mLastWriteSpec.pages = pages;
            mLastWriteSpec.fd = fd;
            mLastWriteSpec.sequence = sequence;
            // cancellation completes we will do the pending work.
            if (cancelPreviousCancellableOperationLocked()) {
                return;
            }
            doPendingWorkLocked();
        }
    }
    if (destroyed) {
        try {
            callback.onWriteFailed(null, sequence);
        } catch (RemoteException re) {
            Log.i(LOG_TAG, ""Error notifying for cancelled write"", re);
        }
    }
}","{
    ICancellationSignal cancellationTransport = CancellationSignal.createTransport();
    try {
        callback.onWriteStarted(cancellationTransport, sequence);
    } catch (RemoteException re) {
        // The spooler is dead - can't recover.
        Log.e(LOG_TAG, ""Error notifying for write start"", re);
        return;
    }
    synchronized (mLock) {
        // If destroyed the handler is null.
        if (isDestroyedLocked()) {
            return;
        }
        CancellationSignal cancellationSignal = CancellationSignal.fromTransport(cancellationTransport);
        SomeArgs args = SomeArgs.obtain();
        args.arg1 = mDocumentAdapter;
        args.arg2 = pages;
        args.arg3 = fd;
        args.arg4 = cancellationSignal;
        args.arg5 = new MyWriteResultCallback(callback, fd, sequence);
        mHandler.obtainMessage(MyHandler.MSG_ON_WRITE, args).sendToTarget();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The previous implementation's control flow and exception handling logic have been completely refactored. The return statement changed, exception handling statement changed, control dependency changed, and the dependent APIs (Inner methods and classes might be considered as dependent APIs) used have also changed.","There are Compatibility Issues both in terms of different return values or types and different exception handlings. This is due to the removal of the previous exception handling for the `callback.onWriteFailed` case and the related return logic, as well as the introduction of new behavior (calling `callback.onWriteStarted`). This could lead to different return variables/types, and because earlier the method potentially caught a RemoteException and logged an error while in the later version it does not, the exceptions that are thrown are different."
970,<android.widget.CalendarView: int getUnfocusedMonthDateColor()>,20,21,<android.widget.CalendarView: int getUnfocusedMonthDateColor()>,<android.widget.CalendarView: int getUnfocusedMonthDateColor()>,0,"{
    return mFocusedMonthDateColor;
}","{
    return mDelegate.getUnfocusedMonthDateColor();
}",1,"/**
 * Gets the color for the dates in a not focused month.
 *
 * @return A not focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_unfocusedMonthDateColor
 */
","/**
 * Gets the color for the dates in a not focused month.
 *
 * @return A not focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_unfocusedMonthDateColor
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return value has changed from returning a direct member variable (mFocusedMonthDateColor) to invoking a method on the delegate object (mDelegate.getUnfocusedMonthDateColor()), so the change type is 1.","Since the return statement now calls a different method, it could potentially lead to a different return value, thus there is a possibility of a CI arising, so the CI type is 1."
971,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",20,21,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>","<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",0,"{
    final boolean restricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, user, restricted, mDisplay, mOverrideConfiguration);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, user, restricted, mDisplay, mOverrideConfiguration);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    final boolean restricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, user, restricted, mDisplay, mOverrideConfiguration);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, user, restricted, mDisplay, mOverrideConfiguration);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change made in the late implementation is the addition of CONTEXT_REGISTER_PACKAGE to the 'flags' variable during the call to 'getPackageInfo'. Since all other parts of the method remain the same, the change type is 4 (Other statement changed).","The change in the 'flags' variable won't cause a Compatibility Issue as the method's behavior remains consistent with the original contract. It will still return a Context object or throw a NameNotFoundException if the application package is not found. The change does not alter the method's control flow, exception handling, return statements, or dependencies that would lead to a different behavior observable to the client code. Thus, the CI type is 0 (No Compatibility Issue)."
972,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,20,21,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mHolder.getSurface());
                            } catch (OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    setAccessibilityFocus(null, null);
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_DISPATCH_SCREEN_STATE:
            {
                if (mView != null) {
                    handleScreenStateChange(msg.arg1 == 1);
                }
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_FLUSH_LAYER_UPDATES:
            {
                flushHardwareLayerUpdates();
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
973,<android.os.ParcelFileDescriptor: long getStatSize()>,20,21,<android.os.ParcelFileDescriptor: long getStatSize()>,<android.os.ParcelFileDescriptor: long getStatSize()>,0,"{
    if (mWrapped != null) {
        return mWrapped.getStatSize();
    } else {
        try {
            final StructStat st = Libcore.os.fstat(mFd);
            if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
                return st.st_size;
            } else {
                return -1;
            }
        } catch (ErrnoException e) {
            Log.w(TAG, ""fstat() failed: "" + e);
            return -1;
        }
    }
}","{
    if (mWrapped != null) {
        return mWrapped.getStatSize();
    } else {
        try {
            final StructStat st = Os.fstat(mFd);
            if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
                return st.st_size;
            } else {
                return -1;
            }
        } catch (ErrnoException e) {
            Log.w(TAG, ""fstat() failed: "" + e);
            return -1;
        }
    }
}",1,"/**
 * Return the total size of the file representing this fd, as determined by
 * {@code stat()}. Returns -1 if the fd is not a file.
 */
","/**
 * Return the total size of the file representing this fd, as determined by
 * {@code stat()}. Returns -1 if the fd is not a file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change from `Libcore.os.fstat(mFd)` to `Os.fstat(mFd)` implies there was a change in the dependent API used to obtain the file statistics, so the code change type is 5.","Despite the change in the dependent API, the method signature, return type, and exception handling remain unchanged. The functional behavior seems identical because the replacement API `Os.fstat` is most likely a direct substitute for `Libcore.os.fstat` in this context. As a result, no compatibility issue is expected from this specific change."
975,<android.content.res.TypedArray: String getPositionDescription()>,20,21,<android.content.res.TypedArray: String getPositionDescription()>,<android.content.res.TypedArray: String getPositionDescription()>,0,"{
    return mXml != null ? mXml.getPositionDescription() : ""<internal>"";
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return mXml != null ? mXml.getPositionDescription() : ""<internal>"";
}",1,"/**
 * Returns a message about the parser state suitable for printing error messages.
 */
","/**
 * Returns a message about the parser state suitable for printing error messages.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The late implementation introduces a new 'if' statement which throws a 'RuntimeException' when 'mRecycled' is true, representing both a control dependency change (3) and an exception handling statement change (2).","With the introduction of a new exception that could be thrown if 'mRecycled' is true, this change may cause a potential different exception handling, leading to a Compatibility Issue of type 2."
976,<android.speech.tts.FileSynthesisCallback: void stop()>,20,21,<android.speech.tts.FileSynthesisCallback: void stop()>,<android.speech.tts.FileSynthesisCallback: void stop()>,0,"{
    synchronized (mStateLock) {
        mStopped = true;
        cleanUp();
    }
}","{
    synchronized (mStateLock) {
        if (mDone) {
            return;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            return;
        }
        mStatusCode = TextToSpeech.STOPPED;
        cleanUp();
        if (mDispatcher != null) {
            mDispatcher.dispatchOnStop();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version adds new control flow with conditions that check for 'mDone' and 'mStatusCode', and updates 'mStatusCode', as well as a new block that dispatches an onStop event through 'mDispatcher'. This results in multiple control dependencies being changed, as well as return statements being introduced, so the code change type is 1,3.","The newly introduced conditional return statements indicate situations where the method execution would stop prematurely compared to the early version. This could result in the 'cleanUp()' method not being called or 'mDispatcher.dispatchOnStop()' not being executed, depending on the states of 'mDone' and 'mStatusCode'. Therefore, the method's behavior is altered, potentially leading to different outcomes, and the CI type is 1."
977,"<android.util.SparseArray: void append(int,E)>",20,21,"<android.util.SparseArray: void append(int,E)>","<android.util.SparseArray: void append(int,E)>",0,"{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        Object[] nvalues = new Object[n];
        // Log.e(""SparseArray"", ""grow "" + mKeys.length + "" to "" + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}","{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}",1,"/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
","/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method of resizing the array and appending the new element has been replaced with a call to GrowingArrayUtils.append in the late version, which indicates that there is a change in how the internal array management is handled. The method signature and basic behavior (appending an element) stay the same, so the change type is 4,5.","There's no Compatibility Issue since the general contract of the method doesn't change. It still appends an element to the sparse array, and aside from internal resizing, the observable behavior should remain the same. Thus, CI type is 0."
978,<android.view.KeyEvent: boolean isSystem()>,20,21,<android.view.KeyEvent: boolean isSystem()>,<android.view.KeyEvent: boolean isSystem()>,0,"{
    return native_isSystemKey(mKeyCode);
}","{
    return isSystemKey(mKeyCode);
}",1,"/**
 * Is this a system key?  System keys can not be used for menu shortcuts.
 *
 * TODO: this information should come from a table somewhere.
 * TODO: should the dpad keys be here?  arguably, because they also shouldn't be menu shortcuts
 */
","/**
 * Is this a system key?  System keys can not be used for menu shortcuts.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within the return statement has changed from `native_isSystemKey(mKeyCode)` to `isSystemKey(mKeyCode)`, indicating the code change type is 5.","There is no indication of the behavior of `native_isSystemKey` versus `isSystemKey`. Without further information, we cannot assume that `isSystemKey` will behave differently or return different results compared to `native_isSystemKey`. Therefore, there is no compatibility issue detected based purely on the change in method name. The presence of a potential CI would depend on the implementation of `isSystemKey` and whether it differs in functionality from `native_isSystemKey`. Since we do not have this information, we cannot assume a CI. Hence, the CI type is 0."
981,<android.bluetooth.BluetoothA2dp: boolean doBind()>,20,21,<android.bluetooth.BluetoothA2dp: boolean doBind()>,<android.bluetooth.BluetoothA2dp: boolean doBind()>,0,"{
    Intent intent = new Intent(IBluetoothA2dp.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindService(intent, mConnection, 0)) {
        Log.e(TAG, ""Could not bind to Bluetooth A2DP Service with "" + intent);
        return false;
    }
    return true;
}","{
    Intent intent = new Intent(IBluetoothA2dp.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, android.os.Process.myUserHandle())) {
        Log.e(TAG, ""Could not bind to Bluetooth A2DP Service with "" + intent);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The API mContext.bindService() has been changed to mContext.bindServiceAsUser() with an additional parameter, which indicates that a dependent API has been modified. This is identified as change type 5.","Even though the method used to bind the service has changed from bindService to bindServiceAsUser, this modification is intended to bind the service for a specific user handle but does not imply a behavior change from the perspective of the API's contract—it still attempts to bind the service and returns true if the binding is successful, false if it is not. Therefore, there is no Compatibility Issue in terms of return value or exception handling, so the CI type is 0."
983,<android.app.Dialog: void show()>,20,21,<android.app.Dialog: void show()>,<android.app.Dialog: void show()>,0,"{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new ActionBarImpl(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}","{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new WindowDecorActionBar(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}",1,"/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
","/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is in the instantiation of mActionBar, from new ActionBarImpl(this) to new WindowDecorActionBar(this). This indicates that the dependent API, specifically the constructor of ActionBar implementation, has changed, so the code change type is 5.","The change from ActionBarImpl to WindowDecorActionBar does not directly affect the return type or throw a new exception as the method's return type is void and the code change does not affect the exception handling mechanism; hence, there's no Compatibility Issue, corresponding to 0."
984,"<android.app.DatePickerDialog: void onClick(DialogInterface,int)>",20,21,"<android.app.DatePickerDialog: void onClick(DialogInterface,int)>","<android.app.DatePickerDialog: void onClick(DialogInterface,int)>",0,"{
    tryNotifyDateSet();
}","{
    switch(which) {
        case BUTTON_POSITIVE:
            if (mDateSetListener != null) {
                mDateSetListener.onDateSet(mDatePicker, mDatePicker.getYear(), mDatePicker.getMonth(), mDatePicker.getDayOfMonth());
            }
            break;
        case BUTTON_NEGATIVE:
            cancel();
            break;
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version implementation introduces a switch control structure and multiple distinct behaviors based on the 'which' value provided (Button positive and button negative). The body of the onClick handler is entirely different; thus, the changes belong to the categories 1 (for introducing new execution paths and return behaviors) and 3 (for introducing new control flow dependencies with the switch statement).","The early version implementation always calls tryNotifyDateSet(), meaning it had a single behavior. The late version's behavior varies depending on the 'which' argument; it may call onDateSet() on the listener, perform a cancel, or do nothing at all. This introduces potential difference in the executed code, and hence, a different behavior (CI type 1)."
985,<android.service.notification.StatusBarNotification: String toString()>,20,21,<android.service.notification.StatusBarNotification: String toString()>,<android.service.notification.StatusBarNotification: String toString()>,0,"{
    return String.format(""StatusBarNotification(pkg=%s user=%s id=%d tag=%s score=%d: %s)"", this.pkg, this.user, this.id, this.tag, this.score, this.notification);
}","{
    return String.format(""StatusBarNotification(pkg=%s user=%s id=%d tag=%s score=%d key=%s: %s)"", this.pkg, this.user, this.id, this.tag, this.score, this.key, this.notification);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"There is an additional format specifier `%s` added for `this.key` in the return statement of the method `toString`, thus the return string will contain additional information in the late version. Hence the change type is 1.","The additional information (`this.key`) included in the result of the `toString` method may result in different return values between the early version and the late version, causing a CI of type 1."
987,<android.preference.TwoStatePreference: void onClick()>,20,21,<android.preference.TwoStatePreference: void onClick()>,<android.preference.TwoStatePreference: void onClick()>,0,"{
    super.onClick();
    boolean newValue = !isChecked();
    mSendClickAccessibilityEvent = true;
    if (!callChangeListener(newValue)) {
        return;
    }
    setChecked(newValue);
}","{
    super.onClick();
    final boolean newValue = !isChecked();
    if (callChangeListener(newValue)) {
        setChecked(newValue);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The declaration of the newValue variable changed from non-final to final and the mSendClickAccessibilityEvent assignment has been removed. A return statement and its surrounding if condition has been removed, and the control flow has been simplified with inverting the if condition.","Since the logic remains essentially the same and no new behavior has been introduced that would affect the return value or exception handling, there are no Compatibility Issues in this change. The API will still perform the super.onClick(), determine the new value, call the change listener, and if the change is accepted, set the checked state accordingly. The removal of the mSendClickAccessibilityEvent does not affect compatibility because it relates to accessibility behavior rather than the functional behavior of the method, which remains unaffected according to the given information."
988,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,20,21,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,0,"{
    if (DEBUG)
        Slog.v(TAG, this + "" onPostExecute"");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        mDone.countDown();
    }
}","{
    if (DEBUG)
        Log.v(TAG, this + "" onPostExecute"");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        mDone.countDown();
    }
}",1,"/* Runs on the UI thread */
","/* Runs on the UI thread */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is in a logging statement, which switched from Slog.v to Log.v. This is classified as an 'Other statement changed' and does not affect the API's behavior in terms of return values or thrown exceptions.",There is no Compatibility Issue associated with this change since the modification does not impact the functional behavior of the API; it merely relates to the logging mechanism.
989,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",20,21,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>","<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), uri, modeFlags);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method call revokeUriPermission has different parameters, adding ContentProvider.getUriWithoutUserId(uri) and resolveUserId(uri) in its argument list while executing the call. Changes have been made to the arguments of the method call, and not to the return statements or exception handling statements. Therefore, the code change type is Dependent API changed (5) and Other statement changed (4).","Despite the modification in the method call arguments, this does not lead to any Compatibility Issues. The method's signature and return type remain unchanged, and there are no new or modified throw statements, nor anything that could lead to an exception being thrown differently or potentially changed return values. Hence, no Compatibility Issue is detected."
991,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: FloatPropertyValuesHolder clone()>,20,21,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: FloatPropertyValuesHolder clone()>,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: FloatPropertyValuesHolder clone()>,0,"{
    FloatPropertyValuesHolder newPVH = (FloatPropertyValuesHolder) super.clone();
    newPVH.mFloatKeyframeSet = (FloatKeyframeSet) newPVH.mKeyframeSet;
    return newPVH;
}","{
    FloatPropertyValuesHolder newPVH = (FloatPropertyValuesHolder) super.clone();
    newPVH.mFloatKeyframes = (Keyframes.FloatKeyframes) newPVH.mKeyframes;
    return newPVH;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The assignment statement within the method implementation changed from newPVH.mFloatKeyframeSet = (FloatKeyframeSet) newPVH.mKeyframeSet to newPVH.mFloatKeyframes = (Keyframes.FloatKeyframes) newPVH.mKeyframes, which means there was an update in variable name and casts. These changes fall into the category of ""Other statement changed"" (4). It's also a change of the dependent API (since the cast type has changed, suggesting the underlying API has changed as well), thus, it is category (5).","There is no indication that the new variable newPVH.mFloatKeyframes and the old variable newPVH.mFloatKeyframeSet behave differently, as they seem to be functionally equivalent but simply renamed. As such, there does not appear to be a Compatibility Issue, because the method still returns an object of the same type and presumably with the same behavior."
992,<android.view.View: void buildLayer()>,20,21,<android.view.View: void buildLayer()>,<android.view.View: void buildLayer()>,0,"{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            if (attachInfo.mHardwareRenderer != null && attachInfo.mHardwareRenderer.isEnabled() && attachInfo.mHardwareRenderer.validate()) {
                getHardwareLayer();
                // current frame
                if (!attachInfo.mTreeObserver.hasOnPreDrawListeners()) {
                    attachInfo.mViewRootImpl.dispatchFlushHardwareLayerUpdates();
                }
            }
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}","{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    if (getWidth() == 0 || getHeight() == 0) {
        return;
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            updateDisplayListIfDirty();
            if (attachInfo.mHardwareRenderer != null && mRenderNode.isValid()) {
                attachInfo.mHardwareRenderer.buildLayer(mRenderNode);
            }
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}",1,"/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
","/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","0,1","The late version introduces a new condition check (if getWidth() == 0 || getHeight() == 0) and also changes a statement inside the LAYER_TYPE_HARDWARE case from getHardwareLayer() and related logic to updateDisplayListIfDirty() and attachInfo.mHardwareRenderer.buildLayer(mRenderNode). This affects both control dependencies and other statements, so the change type is 3,4.","The introduction of the new condition (if getWidth() == 0 || getHeight() == 0) could result in the method returning early without performing any layer building, which could be a situation where the method behaves differently compared to the early version; this indicates a potential Compatibility Issue of type 1. However, the changes inside the LAYER_TYPE_HARDWARE case, such as the removal of getHardwareLayer() and dispatchFlushHardwareLayerUpdates(), alongside the introduction of updateDisplayListIfDirty() and buildLayer, do not straightforwardly indicate a change in the return type or exception thrown, and this may rather be a reflection of internal implementation changes. Without further context on the nature of these methods, whether these changes would cause a behavior that's observable from outside the method (e.g., a different return type or value) is not clear, potentially leading to a CI. Without such context, it is safe to say there is No Compatibility Issue on this aspect until further information is provided."
993,<android.widget.ShareActionProvider.ShareMenuItemOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,20,21,<android.widget.ShareActionProvider.ShareMenuItemOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,<android.widget.ShareActionProvider.ShareMenuItemOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,0,"{
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    final int itemId = item.getItemId();
    Intent launchIntent = dataModel.chooseActivity(itemId);
    if (launchIntent != null) {
        launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        mContext.startActivity(launchIntent);
    }
    return true;
}","{
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    final int itemId = item.getItemId();
    Intent launchIntent = dataModel.chooseActivity(itemId);
    if (launchIntent != null) {
        final String action = launchIntent.getAction();
        if (Intent.ACTION_SEND.equals(action) || Intent.ACTION_SEND_MULTIPLE.equals(action)) {
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
        }
        mContext.startActivity(launchIntent);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 4",0,"The code change includes adding a new control structure (an 'if' statement with a condition to check the action of the Intent) and an associated other statement change (setting flags on the Intent). Therefore, the change types are 3 and 4.","There is no compatibility issue because the return value is always `true` for both versions of the implementation. The modification only affects the flags added to the Intent based on the condition, which does not change the return type or value, nor does it introduce new or modified behavior that could lead to an Exception being thrown or handled differently."
994,<android.content.RestrictionEntry: String[] getChoiceValues()>,20,21,<android.content.RestrictionEntry: String[] getChoiceValues()>,<android.content.RestrictionEntry: String[] getChoiceValues()>,0,"{
    return values;
}","{
    return mChoiceValues;
}",1,"/**
 * Returns the list of possible string values set earlier.
 * @return the list of possible values.
 */
","/**
 * Returns the list of possible string values set earlier.
 * @return the list of possible values.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The variable returned by the method has changed from 'values' to 'mChoiceValues', which is an 'Other statement changed' type change.","Since the method is returning a different variable, there is a Compatibility Issue of type 1 caused by the potential difference in return values between the two versions."
995,<android.service.dreams.DreamService: boolean dispatchTrackballEvent(MotionEvent)>,20,21,<android.service.dreams.DreamService: boolean dispatchTrackballEvent(MotionEvent)>,<android.service.dreams.DreamService: boolean dispatchTrackballEvent(MotionEvent)>,0,"{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Finishing on trackballEvent"");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchTrackballEvent(event);
}","{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on trackballEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTrackballEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The method called inside the 'if' block changed from safelyFinish() to wakeUp() and the log message also changed, which are other statements changed, so the code change type is 3,4.","Although the method called when 'mInteractive' is false has changed, it does not lead to a different return type or value as both code versions return true after the method call. The different methods executed inside the 'if' block do not affect the returning value or type of the API, so there is no compatibility issue. Therefore, the CI type is 0."
996,"<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int[],RemoteViews)>",20,21,"<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int[],RemoteViews)>","<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int[],RemoteViews)>",0,"{
    try {
        sService.partiallyUpdateAppWidgetIds(appWidgetIds, views, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.partiallyUpdateAppWidgetIds(mPackageName, appWidgetIds, views);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Perform an incremental update or command on the widget(s) specified by appWidgetIds.
 *
 * This update  differs from {@link #updateAppWidget(int[], RemoteViews)} in that the
 * RemoteViews object which is passed is understood to be an incomplete representation of the
 * widget, and hence does not replace the cached representation of the widget. As of API
 * level 17, the new properties set within the views objects will be appended to the cached
 * representation of the widget, and hence will persist.
 *
 * Use with {@link RemoteViews#showNext(int)}, {@link RemoteViews#showPrevious(int)},
 * {@link RemoteViews#setScrollPosition(int, int)} and similar commands.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * This method will be ignored if a widget has not received a full update via
 * {@link #updateAppWidget(int[], RemoteViews)}.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views            The RemoteViews object containing the incremental update / command.
 */
","/**
 * Perform an incremental update or command on the widget(s) specified by appWidgetIds.
 * <p>
 * This update  differs from {@link #updateAppWidget(int[], RemoteViews)} in that the
 * RemoteViews object which is passed is understood to be an incomplete representation of the
 * widget, and hence does not replace the cached representation of the widget. As of API
 * level 17, the new properties set within the views objects will be appended to the cached
 * representation of the widget, and hence will persist.
 *
 * Use with {@link RemoteViews#showNext(int)}, {@link RemoteViews#showPrevious(int)},
 * {@link RemoteViews#setScrollPosition(int, int)} and similar commands.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * This method will be ignored if a widget has not received a full update via
 * {@link #updateAppWidget(int[], RemoteViews)}.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views            The RemoteViews object containing the incremental update / command.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"New control dependency (if statement) has been introduced in the late version, which checks if 'mService' is null or not, along with the statements inside the try block have been changed, where 'sService' has been replaced by 'mService', 'mContext.getUserId()' removed and 'mPackageName' added as a parameter to the method 'partiallyUpdateAppWidgetIds'. Additionally, there's an introduction of the variable 'mService' and possibly a change of service object from 'sService' to 'mService'. Finally, since no new exceptions or return types have been introduced and the existing ones remain unchanged, there is no potential compatibility issue from these factors. Thus, the code change type is 1 (return statement changed due to early return in new condition check), 3 (introduction of new control statement), 4 (change in the try block's method call), and 5 (change in dependency with introduction/use of 'mService' instead of 'sService').","While there are significant changes, none of them introduce a compatibility issue that would lead to different return types/values or exception handling. The added control dependency introduces a new early return for a specific case (when 'mService' is null), which effectively would return void instead of throwing a RuntimeException as it would in the early version, this is not considered a compatibility issue since this method is void and this change prevents an error in a case that was not previously handled. Other changes maintain the original flow and exception, which does not alter the compatibility with existing client code expecting a RuntimeException. Thus, CI type is 0 (No Compatibility Issue)."
997,<android.print.PrintManager.PrintDocumentAdapterDelegate: void start()>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate: void start()>,<android.print.PrintManager.PrintDocumentAdapterDelegate: void start()>,0,"{
    synchronized (mLock) {
        // Started called or finish called or destroyed - nothing to do.
        if (mStartReqeusted || mFinishRequested || mDestroyed) {
            return;
        }
        mStartReqeusted = true;
        doPendingWorkLocked();
    }
}","{
    synchronized (mLock) {
        // If destroyed the handler is null.
        if (!isDestroyedLocked()) {
            mHandler.obtainMessage(MyHandler.MSG_ON_START, mDocumentAdapter).sendToTarget();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early version has a return statement combined with multiple conditions inside the synchronized block, while the late version removes this conditional return and uses a single condition with a message sent to a handler. Hence, the changed parts include a control dependency changed because of the altered condition and other statements, so the change type is 1,3,4.","The early version might not execute any further action within the synchronized block under certain conditions and immediately returns, whereas the late version always sends a message as long as it's not destroyed. This behavior alteration means the method can lead to different outcomes, particularly performing actions that wouldn't have taken place in the previous version. Thus, the potential for a different return behavior is present, and the CI type is 1."
1000,<android.os.Bundle: CharSequence[] getCharSequenceArray(String)>,20,21,<android.os.Bundle: CharSequence[] getCharSequenceArray(String)>,<android.os.Bundle: CharSequence[] getCharSequenceArray(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (CharSequence[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""CharSequence[]"", e);
        return null;
    }
}","{
    return super.getCharSequenceArray(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a CharSequence[] value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a CharSequence[] value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The late implementation of the method is changed to invoke a method from its superclass rather than containing its own logic, so the change type is 4,5 (Other statement changed and Dependent API changed).","There is no Compatibility Issue introduced by this change as the behavior of the API is expected to remain the same, given that it now relies on its superclass implementation. The superclass method is assumed to perform the same function and return the same results. Therefore, the CI type is 0."
1001,"<android.view.ViewRootImpl.AccessibilityInteractionConnection: void performAccessibilityAction(long,int,Bundle,int,IAccessibilityInteractionConnectionCallback,int,int,long)>",20,21,"<android.view.ViewRootImpl.AccessibilityInteractionConnection: void performAccessibilityAction(long,int,Bundle,int,IAccessibilityInteractionConnectionCallback,int,int,long)>","<android.view.ViewRootImpl.AccessibilityInteractionConnection: void performAccessibilityAction(long,int,Bundle,int,IAccessibilityInteractionConnectionCallback,int,int,long)>",0,"{
    ViewRootImpl viewRootImpl = mViewRootImpl.get();
    if (viewRootImpl != null && viewRootImpl.mView != null) {
        viewRootImpl.getAccessibilityInteractionController().performAccessibilityActionClientThread(accessibilityNodeId, action, arguments, interactionId, callback, flags, interogatingPid, interrogatingTid);
    } else {
        // We cannot make the call and notify the caller so it does not wait.
        try {
            callback.setPerformAccessibilityActionResult(false, interactionId);
        } catch (RemoteException re) {
        /* best effort - ignore */
        }
    }
}","{
    ViewRootImpl viewRootImpl = mViewRootImpl.get();
    if (viewRootImpl != null && viewRootImpl.mView != null) {
        viewRootImpl.getAccessibilityInteractionController().performAccessibilityActionClientThread(accessibilityNodeId, action, arguments, interactionId, callback, flags, interrogatingPid, interrogatingTid);
    } else {
        // We cannot make the call and notify the caller so it does not wait.
        try {
            callback.setPerformAccessibilityActionResult(false, interactionId);
        } catch (RemoteException re) {
        /* best effort - ignore */
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation between the two versions of the API.,"Since there is no code change, there is no Compatibility Issue."
1005,<android.os.Environment: boolean isExternalStorageRemovable()>,20,21,<android.os.Environment: boolean isExternalStorageRemovable()>,<android.os.Environment: boolean isExternalStorageRemovable()>,0,"{
    final StorageVolume primary = getPrimaryVolume();
    return (primary != null && primary.isRemovable());
}","{
    if (isStorageDisabled())
        return false;
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return isExternalStorageRemovable(externalDir);
}",1,"/**
 * Returns whether the primary ""external"" storage device is removable.
 * If true is returned, this device is for example an SD card that the
 * user can remove.  If false is returned, the storage is built into
 * the device and can not be physically removed.
 *
 * <p>See {@link #getExternalStorageDirectory()} for more information.
 */
","/**
 * Returns whether the primary ""external"" storage device is removable.
 *
 * @return true if the storage device can be removed (such as an SD card),
 * or false if the storage device is built in and cannot be
 * physically removed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The late version introduces a new control flow (if condition) and uses a different dependent API function (isExternalStorageRemovable with an argument), as well as includes the ""isStorageDisabled()"" check which wasn't present in the early version. The return statement is changed because the value it depends on comes from a different method and the logic has additional checks. The dependent API is also used differently. Hence, the code change types are 1, 3, 5.","The introduction of a new conditional check that could return false before executing the main logic changes the potential return value, hence potentially causing a different behavior. The call ""isExternalStorageRemovable(externalDir)"" potentially evaluates differently from ""primary.isRemovable()"" due to the different parameter and the modified code path. Therefore, the CI type is 1."
1007,<android.util.EventLog.Event: Object getData()>,20,21,<android.util.EventLog.Event: Object getData()>,<android.util.EventLog.Event: Object getData()>,0,"{
    try {
        mBuffer.limit(PAYLOAD_START + mBuffer.getShort(LENGTH_OFFSET));
        // Just after the tag.
        mBuffer.position(DATA_START);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, ""Illegal entry payload: tag="" + getTag(), e);
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, ""Truncated entry payload: tag="" + getTag(), e);
        return null;
    }
}","{
    try {
        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
        if (offset == 0) {
            offset = V1_PAYLOAD_START;
        }
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        // Just after the tag.
        mBuffer.position(offset + DATA_OFFSET);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, ""Illegal entry payload: tag="" + getTag(), e);
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, ""Truncated entry payload: tag="" + getTag(), e);
        return null;
    }
}",1,"/**
 * @return one of Integer, Long, String, null, or Object[] of same.
 */
","/**
 * @return one of Integer, Long, String, null, or Object[] of same.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code has introduced new variables to calculate the 'offset' which leads to a control dependency change. Also, addition and retrieval of offset have been added within try block which are changes to other statements, so the code change types are 3 and 4.","These changes in how the offset is calculated and how the buffer position is set can potentially lead to a different return value because the position in the buffer from which the data is decoded might be different. Therefore, the CI type is 1."
1011,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,20,21,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,0,"{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetIntMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // Couldn't find it via JNI - try reflection next. Probably means the method
    // doesn't exist, or the type is wrong. An error will be logged later if
    // reflection fails as well.
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}","{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Long jniSetter = propertyMap.get(mPropertyName);
            if (jniSetter != null) {
                mJniSetter = jniSetter;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetIntMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Long>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // Couldn't find it via JNI - try reflection next. Probably means the method
    // doesn't exist, or the type is wrong. An error will be logged later if
    // reflection fails as well.
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The type of hashmap value has changed from Integer to Long. Besides, the variable type of ""mJniSetterInteger"" has been changed to ""jniSetter"". These both are classified as ""Other statement changed"". Since variable ""mJniSetter"" is still of type long and the logic remains the same, these changes won't lead to a CI, and hence, it is ""Dependent API changed"" because the HashMap's value type is part of the API contract and is now changed from Integer to Long.",There is no compatibility issue detected because the logic of the method has not changed. The method's functionality remains consistent with respect to finding and setting up the setter. The change in hashmap does not impact the method's contract or externally observable behaviour regarding the values it's expected to return or exceptions it may throw.
1014,<android.content.AsyncTaskLoader: boolean onCancelLoad()>,20,21,<android.content.AsyncTaskLoader: boolean onCancelLoad()>,<android.content.AsyncTaskLoader: boolean onCancelLoad()>,0,"{
    if (DEBUG)
        Slog.v(TAG, ""onCancelLoad: mTask="" + mTask);
    if (mTask != null) {
        if (mCancellingTask != null) {
            // one being canceled; just drop it.
            if (DEBUG)
                Slog.v(TAG, ""cancelLoad: still waiting for cancelled task; dropping next"");
            if (mTask.waiting) {
                mTask.waiting = false;
                mHandler.removeCallbacks(mTask);
            }
            mTask = null;
            return false;
        } else if (mTask.waiting) {
            // execute.  We can just toss it.
            if (DEBUG)
                Slog.v(TAG, ""cancelLoad: task is waiting, dropping it"");
            mTask.waiting = false;
            mHandler.removeCallbacks(mTask);
            mTask = null;
            return false;
        } else {
            boolean cancelled = mTask.cancel(false);
            if (DEBUG)
                Slog.v(TAG, ""cancelLoad: cancelled="" + cancelled);
            if (cancelled) {
                mCancellingTask = mTask;
                cancelLoadInBackground();
            }
            mTask = null;
            return cancelled;
        }
    }
    return false;
}","{
    if (DEBUG)
        Log.v(TAG, ""onCancelLoad: mTask="" + mTask);
    if (mTask != null) {
        if (mCancellingTask != null) {
            // one being canceled; just drop it.
            if (DEBUG)
                Log.v(TAG, ""cancelLoad: still waiting for cancelled task; dropping next"");
            if (mTask.waiting) {
                mTask.waiting = false;
                mHandler.removeCallbacks(mTask);
            }
            mTask = null;
            return false;
        } else if (mTask.waiting) {
            // execute.  We can just toss it.
            if (DEBUG)
                Log.v(TAG, ""cancelLoad: task is waiting, dropping it"");
            mTask.waiting = false;
            mHandler.removeCallbacks(mTask);
            mTask = null;
            return false;
        } else {
            boolean cancelled = mTask.cancel(false);
            if (DEBUG)
                Log.v(TAG, ""cancelLoad: cancelled="" + cancelled);
            if (cancelled) {
                mCancellingTask = mTask;
                cancelLoadInBackground();
            }
            mTask = null;
            return cancelled;
        }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The logging method name was changed from 'Slog.v' to 'Log.v', which is an Other statement changed (type 4), as it's a simple renaming of the log utility being used.","There is no Compatibility Issue, because the change from 'Slog.v' to 'Log.v' does not affect the functional behavior of the method. Both calls are used for logging purposes, and changing the log method should not cause any differences in how the method behaves from a caller's perspective."
1015,"<android.view.GLES20Canvas: void drawCircle(float,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawCircle(float,float,float,Paint)>","<android.view.GLES20Canvas: void drawCircle(float,float,float,Paint)>",0,"{
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawCircle(mRenderer, cx, cy, radius, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    nDrawCircle(mRenderer, cx, cy, radius, paint.mNativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The early version of the implementation uses a try-finally block with additional logic related to modifiers which is not found in the late version. In the late version, this logic and the try-finally block have been removed, resulting in a straightforward invocation of nDrawCircle without modifier setup or reset. This is an ""Other statement changed"" situation.","The removal of the modifier setup and reset code does not inherently cause the method to return a different value or throw a different exception since the core functionality (drawing a circle using nDrawCircle) remains unchanged. Thus, there is no Compatibility Issue in terms of behavior; the function's output or exception throwing behavior should remain consistent despite the internal code cleanup."
1016,"<android.content.Intent: Intent createChooser(Intent,CharSequence)>",20,21,"<android.content.Intent: Intent createChooser(Intent,CharSequence)>","<android.content.Intent: Intent createChooser(Intent,CharSequence)>",0,"{
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.putExtra(EXTRA_INTENT, target);
    if (title != null) {
        intent.putExtra(EXTRA_TITLE, title);
    }
    // Migrate any clip data and flags from target.
    int permFlags = target.getFlags() & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);
    if (permFlags != 0) {
        ClipData targetClipData = target.getClipData();
        if (targetClipData == null && target.getData() != null) {
            ClipData.Item item = new ClipData.Item(target.getData());
            String[] mimeTypes;
            if (target.getType() != null) {
                mimeTypes = new String[] { target.getType() };
            } else {
                mimeTypes = new String[] {};
            }
            targetClipData = new ClipData(null, mimeTypes, item);
        }
        if (targetClipData != null) {
            intent.setClipData(targetClipData);
            intent.addFlags(permFlags);
        }
    }
    return intent;
}","{
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.putExtra(EXTRA_INTENT, target);
    if (title != null) {
        intent.putExtra(EXTRA_TITLE, title);
    }
    // Migrate any clip data and flags from target.
    int permFlags = target.getFlags() & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION | FLAG_GRANT_PERSISTABLE_URI_PERMISSION | FLAG_GRANT_PREFIX_URI_PERMISSION);
    if (permFlags != 0) {
        ClipData targetClipData = target.getClipData();
        if (targetClipData == null && target.getData() != null) {
            ClipData.Item item = new ClipData.Item(target.getData());
            String[] mimeTypes;
            if (target.getType() != null) {
                mimeTypes = new String[] { target.getType() };
            } else {
                mimeTypes = new String[] {};
            }
            targetClipData = new ClipData(null, mimeTypes, item);
        }
        if (targetClipData != null) {
            intent.setClipData(targetClipData);
            intent.addFlags(permFlags);
        }
    }
    return intent;
}",1,"/**
 * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
 *
 * <p>Builds a new {@link #ACTION_CHOOSER} Intent that wraps the given
 * target intent, also optionally supplying a title.  If the target
 * intent has specified {@link #FLAG_GRANT_READ_URI_PERMISSION} or
 * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, then these flags will also be
 * set in the returned chooser intent, with its ClipData set appropriately:
 * either a direct reflection of {@link #getClipData()} if that is non-null,
 * or a new ClipData build from {@link #getData()}.
 *
 * @param target The Intent that the user will be selecting an activity
 * to perform.
 * @param title Optional title that will be displayed in the chooser.
 * @return Return a new Intent object that you can hand to
 * {@link Context#startActivity(Intent) Context.startActivity()} and
 * related methods.
 */
","/**
 * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
 *
 * <p>Builds a new {@link #ACTION_CHOOSER} Intent that wraps the given
 * target intent, also optionally supplying a title.  If the target
 * intent has specified {@link #FLAG_GRANT_READ_URI_PERMISSION} or
 * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, then these flags will also be
 * set in the returned chooser intent, with its ClipData set appropriately:
 * either a direct reflection of {@link #getClipData()} if that is non-null,
 * or a new ClipData built from {@link #getData()}.
 *
 * @param target The Intent that the user will be selecting an activity
 * to perform.
 * @param title Optional title that will be displayed in the chooser.
 * @return Return a new Intent object that you can hand to
 * {@link Context#startActivity(Intent) Context.startActivity()} and
 * related methods.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change in the code is the addition of flags to `permFlags`. The OR operation includes two extra flags (`FLAG_GRANT_PERSISTABLE_URI_PERMISSION` and `FLAG_GRANT_PREFIX_URI_PERMISSION`). This change is neither a return statement nor an exception handling statement, but rather a change in the value of a variable (`permFlags`) due to the assignment operation. As a result, it is classified as an 'Other statement changed'. However, it also impacts the statement `if (permFlags != 0)`, which is a control dependency change (since the outcome of this condition could differ based on the new flags), making it both 3 and 4.","Despite the change in `permFlags`, the set of permissions potentially being granted, the structure of the code and the final `return intent;` statement have not changed. The functionality encapsulated in the `intent` object being returned remains the same regarding its construction and the information it is meant to contain. Therefore, there is no Compatibility Issue, and the type is 0."
1017,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createPipe()>,20,21,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createPipe()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createPipe()>,0,"{
    try {
        final FileDescriptor[] fds = Libcore.os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */
","/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method name being called has changed from Libcore.os.pipe() to Os.pipe(), which is a change in the dependent API, so the change type is 5.","No new return statements or exception handling statements have been introduced, and no existing ones have been deleted or modified. There's no change in the control flow and only the API on which the method depends has changed. Provided that Os.pipe() returns the same result as Libcore.os.pipe(), the behavior should be consistent, therefore no Compatibility Issue due to potential different return values or types, or due to potential different exception handlings."
1018,"<android.content.ContentResolver: boolean isSyncActive(Account,String)>",20,21,"<android.content.ContentResolver: boolean isSyncActive(Account,String)>","<android.content.ContentResolver: boolean isSyncActive(Account,String)>",0,"{
    try {
        return getContentService().isSyncActive(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    if (account == null) {
        throw new IllegalArgumentException(""account must not be null"");
    }
    if (authority == null) {
        throw new IllegalArgumentException(""authority must not be null"");
    }
    try {
        return getContentService().isSyncActive(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}",1,"/**
 * Returns true if there is currently a sync operation for the given
 * account or authority in the pending list, or actively being processed.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if a sync is active for the given account or authority.
 */
","/**
 * Returns true if there is currently a sync operation for the given account or authority
 * actively being processed.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if a sync is active for the given account or authority.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The late implementation includes new argument checks with corresponding 'throw' statements, changes in control dependency (introduction of 'if' conditions), other statements are also added (checks for 'null' arguments), and a new parameter is passed to 'getContentService().isSyncActive()'. Therefore, the relevant change types are 2, 3, 4, and 5.","The newly introduced 'if' conditions check for 'null' arguments, which can cause the method to throw a new type of exception (`IllegalArgumentException`), representing a CI caused by potential different exception handling (type 2). Additionally, the method now adds `null` as a third parameter to the 'isSyncActive' call. If the overload with three parameters behaves differently from the overload with two, this could lead to a different return value, and thus a CI related to return values (type 1)."
1019,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,20,21,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,0,"{
    if (DBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The addition of synchronized block to check mDeviceBusy, and setting mDeviceBusy = true indicates a control dependency change (3). The logging flag change from DBG to VDBG is an other statement change (4), but does not affect the behavior of the method.","The introduction of the synchronized block that checks and sets mDeviceBusy introduces a new return condition when mDeviceBusy is true. This can potentially cause the method to return a different value (`false` when the device is busy), resulting in a Compatibility Issue because of potential different return values (1)."
1021,"<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>",20,21,"<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>","<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>",0,"{
    if (DBG)
        Log.d(TAG, ""startLeScan(): "" + serviceUuids);
    if (callback == null) {
        if (DBG)
            Log.e(TAG, ""startLeScan: null callback"");
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG)
                Log.e(TAG, ""LE Scan has already started"");
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            UUID uuid = UUID.randomUUID();
            GattCallbackWrapper wrapper = new GattCallbackWrapper(this, callback, serviceUuids);
            iGatt.registerClient(new ParcelUuid(uuid), wrapper);
            if (wrapper.scanStarted()) {
                mLeScanClients.put(callback, wrapper);
                return true;
            }
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    return false;
}","{
    if (DBG)
        Log.d(TAG, ""startLeScan(): "" + serviceUuids);
    if (callback == null) {
        if (DBG)
            Log.e(TAG, ""startLeScan: null callback"");
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG)
            Log.e(TAG, ""startLeScan: cannot get BluetoothLeScanner"");
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG)
                Log.e(TAG, ""LE Scan has already started"");
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, ""LE Scan has already started"");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG)
                                Log.d(TAG, ""uuids does not match"");
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    return false;
}",1,"/**
 * Starts a scan for Bluetooth LE devices, looking for devices that
 * advertise given services.
 *
 * <p>Devices which advertise all specified services are reported using the
 * {@link LeScanCallback#onLeScan} callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param serviceUuids Array of services to look for
 * @param callback the callback LE scan results are delivered
 * @return true, if the scan was started successfully
 */
","/**
 * Starts a scan for Bluetooth LE devices, looking for devices that
 * advertise given services.
 *
 * <p>Devices which advertise all specified services are reported using the
 * {@link LeScanCallback#onLeScan} callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param serviceUuids Array of services to look for
 * @param callback the callback LE scan results are delivered
 * @return true, if the scan was started successfully
 * @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}
 * instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The control dependency has changed due to addition of new control statements related to `BluetoothLeScanner`. Other statements regarding constructing `ScanSettings` and `ScanFilter` and starting the scan using `scanner.startScan` have changed. There are changes in the method's implementation regarding the way the Bluetooth LE scan is started and the callback is handled. Additionally, the new API 'getBluetoothLeScanner()' is now used instead of 'mManagerService.getBluetoothGatt()', indicating a dependent API change, so the change type is 3,4,5.","The change to how the scanning process is initiated and callbacks are used could potentially lead to the API behaving differently (different return values or types), so the CI type is 1."
1023,<android.appwidget.AppWidgetHost: void deleteHost()>,20,21,<android.appwidget.AppWidgetHost: void deleteHost()>,<android.appwidget.AppWidgetHost: void deleteHost()>,0,"{
    try {
        sService.deleteHost(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        sService.deleteHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
","/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",5,"The parameter order and types of the method sService.deleteHost have changed (the context method call has been changed from mContext.getUserId() to mContext.getOpPackageName()), so the code change type is 4,5.","The modification in the dependent API call could lead to an effect on the behavior of the current API function due to potential changes in the processing of the parameters, so the CI type is 5."
1024,"<android.util.SparseLongArray: void append(int,long)>",20,21,"<android.util.SparseLongArray: void append(int,long)>","<android.util.SparseLongArray: void append(int,long)>",0,"{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        growKeyAndValueArrays(pos + 1);
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}","{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}",1,"/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
","/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The method append has undergone changes in the way it grows the key and value arrays, and appends elements to them. The older implementation manually handled the array growth and the assignment of new key-value pairs, while the later version uses GrowingArrayUtils.append for these purposes. Additionally, the mSize increment logic has changed, so the code change includes control dependency (3), other statements (4), and dependent API (5) changes.","However, these changes do not result in a compatibility issue because they do not alter the external behavior of the append method. The method's contract remains the same—to append the key and value at the end of the array—and therefore, the changes do not affect how users of the API would interact with it or the results they would expect from it. Thus, there is no compatibility issue (0)."
1025,<android.widget.CompoundButton: void setButtonDrawable(int)>,20,21,<android.widget.CompoundButton: void setButtonDrawable(int)>,<android.widget.CompoundButton: void setButtonDrawable(int)>,0,"{
    if (resid != 0 && resid == mButtonResource) {
        return;
    }
    mButtonResource = resid;
    Drawable d = null;
    if (mButtonResource != 0) {
        d = getResources().getDrawable(mButtonResource);
    }
    setButtonDrawable(d);
}","{
    if (resid != 0 && resid == mButtonResource) {
        return;
    }
    mButtonResource = resid;
    Drawable d = null;
    if (mButtonResource != 0) {
        d = getContext().getDrawable(mButtonResource);
    }
    setButtonDrawable(d);
}",1,"/**
 * Set the background to a given Drawable, identified by its resource id.
 *
 * @param resid the resource id of the drawable to use as the background
 */
","/**
 * Set the button graphic to a given Drawable, identified by its resource
 * id.
 *
 * @param resid the resource id of the drawable to use as the button
 * graphic
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes a change from getResources().getDrawable(mButtonResource) to getContext().getDrawable(mButtonResource), so this is a change in a method called on an object, which is classified as dependent API changed (5). Additionally, the actual line of code has been altered which is also classified as other statement changed (4).","Although there is a change in the method call to obtain the drawable, this change does not affect the method's behavior in the sense of returning a different result or throwing a different exception as long as the context returns the correct resource. The Drawable that is being set is determined by the same resource identifier (resid), so there should be no compatibility issue caused by different return values or types, nor by different exception handlings. Thus, there is no compatibility issue (0)."
1026,<android.widget.AbsListView: boolean isFastScrollEnabled()>,20,21,<android.widget.AbsListView: boolean isFastScrollEnabled()>,<android.widget.AbsListView: boolean isFastScrollEnabled()>,0,"{
    if (mFastScroller == null) {
        return mFastScrollEnabled;
    } else {
        return mFastScroller.isEnabled();
    }
}","{
    if (mFastScroll == null) {
        return mFastScrollEnabled;
    } else {
        return mFastScroll.isEnabled();
    }
}",1,"/**
 * Returns true if the fast scroller is enabled.
 *
 * @see #setFastScrollEnabled(boolean)
 * @return true if fast scroll is enabled, false otherwise
 */
","/**
 * Returns true if the fast scroller is enabled.
 *
 * @see #setFastScrollEnabled(boolean)
 * @return true if fast scroll is enabled, false otherwise
 */
",-1,[@ViewDebug.ExportedProperty],[@ViewDebug.ExportedProperty],-1,-1,-1,-1,-1,-1,0,0,There is no change in the code between the two versions. Both the method signature and the implementation remain the same.,"Since there is no change in the implementation, no Compatibility Issue could arise between the two versions of the API."
1027,<android.bluetooth.BluetoothDevice: boolean createBond()>,20,21,<android.bluetooth.BluetoothDevice: boolean createBond()>,<android.bluetooth.BluetoothDevice: boolean createBond()>,0,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot create bond to Remote Device"");
        return false;
    }
    try {
        return sService.createBond(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot create bond to Remote Device"");
        return false;
    }
    try {
        return sService.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return false on immediate error, true if bonding will begin
 */
","/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return false on immediate error, true if bonding will begin
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block changed from sService.createBond(this) to sService.createBond(this, TRANSPORT_AUTO), indicating that the dependent API createBond() now takes an additional parameter, so the code change type is 5.","Although the dependent API createBond() has changed with an additional parameter, the method's purpose remains the same, and it returns a boolean in both cases. Moreover, there are no changes to return statements or exception handling that would affect the outcome of the method. Therefore, no Compatibility Issue is expected here; the CI type is 0."
1028,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,20,21,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,0,"{
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            return;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            return;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, ""Channel lost"");
            return;
        default:
            break;
    }
    Object listener = getListener(message.arg2);
    if (listener == null) {
        Log.d(TAG, ""Stale key "" + message.arg2);
        return;
    }
    boolean listenerRemove = true;
    NsdServiceInfo ns = getNsdService(message.arg2);
    switch(message.what) {
        case DISCOVER_SERVICES_STARTED:
            String s = getNsdServiceInfoType((NsdServiceInfo) message.obj);
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            // Keep listener until stop discovery
            listenerRemove = false;
            break;
        case DISCOVER_SERVICES_FAILED:
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            // Keep listener until stop discovery
            listenerRemove = false;
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            // Keep listener until stop discovery
            listenerRemove = false;
            break;
        case STOP_DISCOVERY_FAILED:
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdServiceInfoType(ns));
            break;
        case REGISTER_SERVICE_FAILED:
            ((RegistrationListener) listener).onRegistrationFailed(ns, message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            // Keep listener until unregister
            listenerRemove = false;
            break;
        case UNREGISTER_SERVICE_FAILED:
            ((RegistrationListener) listener).onUnregistrationFailed(ns, message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceUnregistered(ns);
            break;
        case RESOLVE_SERVICE_FAILED:
            ((ResolveListener) listener).onResolveFailed(ns, message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, ""Ignored "" + message);
            break;
    }
    if (listenerRemove) {
        removeListener(message.arg2);
    }
}","{
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            return;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            return;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, ""Channel lost"");
            return;
        default:
            break;
    }
    Object listener = getListener(message.arg2);
    if (listener == null) {
        Log.d(TAG, ""Stale key "" + message.arg2);
        return;
    }
    NsdServiceInfo ns = getNsdService(message.arg2);
    switch(message.what) {
        case DISCOVER_SERVICES_STARTED:
            String s = getNsdServiceInfoType((NsdServiceInfo) message.obj);
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            break;
        case DISCOVER_SERVICES_FAILED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            break;
        case STOP_DISCOVERY_FAILED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdServiceInfoType(ns));
            break;
        case REGISTER_SERVICE_FAILED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onRegistrationFailed(ns, message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            break;
        case UNREGISTER_SERVICE_FAILED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onUnregistrationFailed(ns, message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onServiceUnregistered(ns);
            break;
        case RESOLVE_SERVICE_FAILED:
            removeListener(message.arg2);
            ((ResolveListener) listener).onResolveFailed(ns, message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            removeListener(message.arg2);
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, ""Ignored "" + message);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1029,"<android.print.PrintManager: PrintJob print(String,PrintDocumentAdapter,PrintAttributes)>",20,21,"<android.print.PrintManager: PrintJob print(String,PrintDocumentAdapter,PrintAttributes)>","<android.print.PrintManager: PrintJob print(String,PrintDocumentAdapter,PrintAttributes)>",0,"{
    if (!(mContext instanceof Activity)) {
        throw new IllegalStateException(""Can print only from an activity"");
    }
    if (TextUtils.isEmpty(printJobName)) {
        throw new IllegalArgumentException(""printJobName cannot be empty"");
    }
    if (documentAdapter == null) {
        throw new IllegalArgumentException(""documentAdapter cannot be null"");
    }
    PrintDocumentAdapterDelegate delegate = new PrintDocumentAdapterDelegate((Activity) mContext, documentAdapter);
    try {
        Bundle result = mService.print(printJobName, delegate, attributes, mContext.getPackageName(), mAppId, mUserId);
        if (result != null) {
            PrintJobInfo printJob = result.getParcelable(EXTRA_PRINT_JOB);
            IntentSender intent = result.getParcelable(EXTRA_PRINT_DIALOG_INTENT);
            if (printJob == null || intent == null) {
                return null;
            }
            try {
                mContext.startIntentSender(intent, null, 0, 0, 0);
                return new PrintJob(printJob, this);
            } catch (SendIntentException sie) {
                Log.e(LOG_TAG, ""Couldn't start print job config activity."", sie);
            }
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error creating a print job"", re);
    }
    return null;
}","{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return null;
    }
    if (!(mContext instanceof Activity)) {
        throw new IllegalStateException(""Can print only from an activity"");
    }
    if (TextUtils.isEmpty(printJobName)) {
        throw new IllegalArgumentException(""printJobName cannot be empty"");
    }
    if (documentAdapter == null) {
        throw new IllegalArgumentException(""documentAdapter cannot be null"");
    }
    PrintDocumentAdapterDelegate delegate = new PrintDocumentAdapterDelegate((Activity) mContext, documentAdapter);
    try {
        Bundle result = mService.print(printJobName, delegate, attributes, mContext.getPackageName(), mAppId, mUserId);
        if (result != null) {
            PrintJobInfo printJob = result.getParcelable(EXTRA_PRINT_JOB);
            IntentSender intent = result.getParcelable(EXTRA_PRINT_DIALOG_INTENT);
            if (printJob == null || intent == null) {
                return null;
            }
            try {
                mContext.startIntentSender(intent, null, 0, 0, 0);
                return new PrintJob(printJob, this);
            } catch (SendIntentException sie) {
                Log.e(LOG_TAG, ""Couldn't start print job config activity."", sie);
            }
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error creating a print job"", re);
    }
    return null;
}",1,"/**
 * Creates a print job for printing a {@link PrintDocumentAdapter} with
 * default print attributes.
 * <p>
 * Calling this method brings the print UI allowing the user to customize
 * the print job and returns a {@link PrintJob} object without waiting for the
 * user to customize or confirm the print job. The returned print job instance
 * is in a {@link PrintJobInfo#STATE_CREATED created} state.
 * <p>
 * This method can be called only from an {@link Activity}. The rationale is that
 * printing from a service will create an inconsistent user experience as the print
 * UI would appear without any context.
 * </p>
 * <p>
 * Also the passed in {@link PrintDocumentAdapter} will be considered invalid if
 * your activity is finished. The rationale is that once the activity that
 * initiated printing is finished, the provided adapter may be in an inconsistent
 * state as it may depend on the UI presented by the activity.
 * </p>
 * <p>
 * The default print attributes are a hint to the system how the data is to
 * be printed. For example, a photo editor may look at the photo aspect ratio
 * to determine the default orientation and provide a hint whether the printing
 * should be in portrait or landscape. The system will do a best effort to
 * selected the hinted options in the print dialog, given the current printer
 * supports them.
 * </p>
 *
 * @param printJobName A name for the new print job which is shown to the user.
 * @param documentAdapter An adapter that emits the document to print.
 * @param attributes The default print job attributes or <code>null</code>.
 * @return The created print job on success or null on failure.
 * @throws IllegalStateException If not called from an {@link Activity}.
 * @throws IllegalArgumentException If the print job name is empty or the
 * document adapter is null.
 *
 * @see PrintJob
 */
","/**
 * Creates a print job for printing a {@link PrintDocumentAdapter} with
 * default print attributes.
 * <p>
 * Calling this method brings the print UI allowing the user to customize
 * the print job and returns a {@link PrintJob} object without waiting for the
 * user to customize or confirm the print job. The returned print job instance
 * is in a {@link PrintJobInfo#STATE_CREATED created} state.
 * <p>
 * This method can be called only from an {@link Activity}. The rationale is that
 * printing from a service will create an inconsistent user experience as the print
 * UI would appear without any context.
 * </p>
 * <p>
 * Also the passed in {@link PrintDocumentAdapter} will be considered invalid if
 * your activity is finished. The rationale is that once the activity that
 * initiated printing is finished, the provided adapter may be in an inconsistent
 * state as it may depend on the UI presented by the activity.
 * </p>
 * <p>
 * The default print attributes are a hint to the system how the data is to
 * be printed. For example, a photo editor may look at the photo aspect ratio
 * to determine the default orientation and provide a hint whether the printing
 * should be in portrait or landscape. The system will do a best effort to
 * selected the hinted options in the print dialog, given the current printer
 * supports them.
 * </p>
 * <p>
 * <strong>Note:</strong> Calling this method will bring the print dialog and
 * the system will connect to the provided {@link PrintDocumentAdapter}. If a
 * configuration change occurs that you application does not handle, for example
 * a rotation change, the system will drop the connection to the adapter as the
 * activity has to be recreated and the old adapter may be invalid in this context,
 * hence a new adapter instance is required. As a consequence, if your activity
 * does not handle configuration changes (default behavior), you have to save the
 * state that you were printing and call this method again when your activity
 * is recreated.
 * </p>
 *
 * @param printJobName A name for the new print job which is shown to the user.
 * @param documentAdapter An adapter that emits the document to print.
 * @param attributes The default print job attributes or <code>null</code>.
 * @return The created print job on success or null on failure.
 * @throws IllegalStateException If not called from an {@link Activity}.
 * @throws IllegalArgumentException If the print job name is empty or the
 * document adapter is null.
 *
 * @see PrintJob
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The if statement checking for the nullity of mService and the associated log message are introduced. This is a control dependency change, so it falls under code change type 3. Additionally, a return statement inside the newly introduced if block has been added, which is a change regarding the return statement, so it is also type 1.","Due to the newly introduced if statement, the method can now potentially return null earlier in the execution flow if mService is null. This condition was not present in the early version, so this change can lead to different return values, which is a compatibility issue of type 1."
1030,<android.os.Parcel: void writeValue(Object)>,20,21,<android.os.Parcel: void writeValue(Object)>,<android.os.Parcel: void writeValue(Object)>,0,"{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof Parcelable) {
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof Object[]) {
        writeInt(VAL_OBJECTARRAY);
        writeArray((Object[]) v);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof Serializable) {
        // Must be last
        writeInt(VAL_SERIALIZABLE);
        writeSerializable((Serializable) v);
    } else {
        throw new RuntimeException(""Parcel: unable to marshal value "" + v);
    }
}","{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof Parcelable) {
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof PersistableBundle) {
        writeInt(VAL_PERSISTABLEBUNDLE);
        writePersistableBundle((PersistableBundle) v);
    } else if (v instanceof Size) {
        writeInt(VAL_SIZE);
        writeSize((Size) v);
    } else if (v instanceof SizeF) {
        writeInt(VAL_SIZEF);
        writeSizeF((SizeF) v);
    } else {
        Class<?> clazz = v.getClass();
        if (clazz.isArray() && clazz.getComponentType() == Object.class) {
            // Only pure Object[] are written here, Other arrays of non-primitive types are
            // handled by serialization as this does not record the component type.
            writeInt(VAL_OBJECTARRAY);
            writeArray((Object[]) v);
        } else if (v instanceof Serializable) {
            // Must be last
            writeInt(VAL_SERIALIZABLE);
            writeSerializable((Serializable) v);
        } else {
            throw new RuntimeException(""Parcel: unable to marshal value "" + v);
        }
    }
}",1,"/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 *
 * <p class=""caution"">{@link Parcelable} objects are written with
 * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
 * serializing objects containing {@link ParcelFileDescriptor}s,
 * this may result in file descriptor leaks when they are returned from
 * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
 * should be used).</p>
 */
","/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 *
 * <p class=""caution"">{@link Parcelable} objects are written with
 * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
 * serializing objects containing {@link ParcelFileDescriptor}s,
 * this may result in file descriptor leaks when they are returned from
 * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
 * should be used).</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1031,<android.view.KeyEvent: int keyCodeFromString(String)>,20,21,<android.view.KeyEvent: int keyCodeFromString(String)>,<android.view.KeyEvent: int keyCodeFromString(String)>,0,"{
    if (symbolicName == null) {
        throw new IllegalArgumentException(""symbolicName must not be null"");
    }
    final int count = KEYCODE_SYMBOLIC_NAMES.size();
    for (int i = 0; i < count; i++) {
        if (symbolicName.equals(KEYCODE_SYMBOLIC_NAMES.valueAt(i))) {
            return i;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return KEYCODE_UNKNOWN;
    }
}","{
    if (symbolicName.startsWith(LABEL_PREFIX)) {
        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
        int keyCode = nativeKeyCodeFromString(symbolicName);
        if (keyCode > 0) {
            return keyCode;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return KEYCODE_UNKNOWN;
    }
}",1,"/**
 * Gets a keycode by its symbolic name such as ""KEYCODE_A"" or an equivalent
 * numeric constant such as ""1001"".
 *
 * @param symbolicName The symbolic name of the keycode.
 * @return The keycode or {@link #KEYCODE_UNKNOWN} if not found.
 * @see #keycodeToString(int)
 */
","/**
 * Gets a keycode by its symbolic name such as ""KEYCODE_A"" or an equivalent
 * numeric constant such as ""1001"".
 *
 * @param symbolicName The symbolic name of the keycode.
 * @return The keycode or {@link #KEYCODE_UNKNOWN} if not found.
 * @see #keycodeToString(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The early implementation iterates through `KEYCODE_SYMBOLIC_NAMES` to find a match, while the late implementation first checks if `symbolicName` starts with `LABEL_PREFIX`, then uses `nativeKeyCodeFromString`. These are a return statement change, a control dependency change because of the introduction of a condition relying on `LABEL_PREFIX`, and a dependent API change since now `nativeKeyCodeFromString(symbolicName)` is being used instead of the iteration mechanism. ","There is a Compatibility Issue due to the fact that the mechanism for translating `symbolicName` into a keycode has fundamentally changed. In the early version, the method iterates through a predefined list, and in the late version, it uses a native method call if the `symbolicName` follows a certain pattern. Therefore, the API can return different key codes for the same input string between versions, especially for symbolic names that start with the label prefix defined by `LABEL_PREFIX`, so the CI type is 1."
1033,"<android.content.res.XmlBlock.Parser: float getAttributeFloatValue(int,float)>",20,21,"<android.content.res.XmlBlock.Parser: float getAttributeFloatValue(int,float)>","<android.content.res.XmlBlock.Parser: float getAttributeFloatValue(int,float)>",0,"{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on appt doing the conversion for us.
    if (t == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(nativeGetAttributeData(mParseState, idx));
    }
    throw new RuntimeException(""not a float!"");
}","{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on aapt doing the conversion for us.
    if (t == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(nativeGetAttributeData(mParseState, idx));
    }
    throw new RuntimeException(""not a float!"");
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementation of the method between the two versions. The comment has been slightly altered (from 'appt' to 'aapt'), but it doesn't affect the code's functionality.","As there is no actual code change, there is no Compatibility Issue between the two versions of the API."
1036,<android.content.res.TypedArray: TypedValue peekValue(int)>,20,21,<android.content.res.TypedArray: TypedValue peekValue(int)>,<android.content.res.TypedArray: TypedValue peekValue(int)>,0,"{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}",1,"/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>
 * and return a temporary object holding its data.  This object is only
 * valid until the next call on to {@link TypedArray}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Returns a TypedValue object if the attribute is defined,
 * containing its data; otherwise returns null.  (You will not
 * receive a TypedValue whose type is TYPE_NULL.)
 */
","/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>
 * and return a temporary object holding its data.  This object is only
 * valid until the next call on to {@link TypedArray}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Returns a TypedValue object if the attribute is defined,
 * containing its data; otherwise returns null.  (You will not
 * receive a TypedValue whose type is TYPE_NULL.)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An exception handling statement `throw new RuntimeException(""Cannot make calls to a recycled instance!"");` is added and a condition check for `mRecycled` is introduced before the existing code, so the code change type is 2,3.","The introduction of a new exception handling for the `mRecycled` state will potentially cause the method to throw a new exception that was not thrown in the early version, leading to a different behavior. Thus, the CI type is 2."
1037,<android.view.View: float getTranslationY()>,20,21,<android.view.View: float getTranslationY()>,<android.view.View: float getTranslationY()>,0,"{
    return mTransformationInfo != null ? mTransformationInfo.mTranslationY : 0;
}","{
    return mRenderNode.getTranslationY();
}",1,"/**
 * The horizontal location of this view relative to its {@link #getTop() top} position.
 * This position is post-layout, in addition to wherever the object's
 * layout placed it.
 *
 * @return The vertical position of this view relative to its top position,
 * in pixels.
 */
","/**
 * The vertical location of this view relative to its {@link #getTop() top} position.
 * This position is post-layout, in addition to wherever the object's
 * layout placed it.
 *
 * @return The vertical position of this view relative to its top position,
 * in pixels.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has changed from a ternary operation involving mTransformationInfo to a direct call to mRenderNode.getTranslationY(), and thus the method that this API depends on to compute the translation has changed. The code change type is therefore classified as 1,5.","The change in the underlying method call means the API could potentially return a different value for the translation Y coordinate, which could be due to changes in how mRenderNode computes the value compared to the previous mTransformationInfo. This is a Compatibility Issue of type 1."
1038,<android.widget.DatePicker: long getMinDate()>,20,21,<android.widget.DatePicker: long getMinDate()>,<android.widget.DatePicker: long getMinDate()>,0,"{
    return mCalendarView.getMinDate();
}","{
    return mDelegate.getMinDate().getTimeInMillis();
}",1,"/**
 * Gets the minimal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 */
","/**
 * Gets the minimal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method being called to obtain the minimum date value has changed from mCalendarView.getMinDate() to mDelegate.getMinDate().getTimeInMillis(), indicating a change in the dependent API, so the code change type is 5.","Due to the change in the dependent API, the method may now return a different value, as it's not only calling a different method but also accessing a field (getTimeInMillis) of the returned object. This is a CI type 1."
1040,<android.provider.Browser: void truncateHistory(ContentResolver)>,20,21,<android.provider.Browser: void truncateHistory(ContentResolver)>,<android.provider.Browser: void truncateHistory(ContentResolver)>,0,"{
    // TODO make a single request to the provider to do this in a single transaction
    Cursor cursor = null;
    try {
        // Select non-bookmark history, ordered by date
        cursor = cr.query(History.CONTENT_URI, new String[] { History._ID, History.URL, History.DATE_LAST_VISITED }, null, null, History.DATE_LAST_VISITED + "" ASC"");
        if (cursor.moveToFirst() && cursor.getCount() >= MAX_HISTORY_COUNT) {
            final WebIconDatabase iconDb = WebIconDatabase.getInstance();
            /* eliminate oldest history items */
            for (int i = 0; i < TRUNCATE_N_OLDEST; i++) {
                cr.delete(ContentUris.withAppendedId(History.CONTENT_URI, cursor.getLong(0)), null, null);
                iconDb.releaseIconForPageUrl(cursor.getString(1));
                if (!cursor.moveToNext())
                    break;
            }
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""truncateHistory"", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
}","{
    // TODO make a single request to the provider to do this in a single transaction
    Cursor cursor = null;
    try {
        // Select non-bookmark history, ordered by date
        cursor = cr.query(History.CONTENT_URI, new String[] { History._ID, History.URL, History.DATE_LAST_VISITED }, null, null, History.DATE_LAST_VISITED + "" ASC"");
        if (cursor.moveToFirst() && cursor.getCount() >= MAX_HISTORY_COUNT) {
            /* eliminate oldest history items */
            for (int i = 0; i < TRUNCATE_N_OLDEST; i++) {
                cr.delete(ContentUris.withAppendedId(History.CONTENT_URI, cursor.getLong(0)), null, null);
                if (!cursor.moveToNext())
                    break;
            }
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""truncateHistory"", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
}",1,"/**
 * If there are more than MAX_HISTORY_COUNT non-bookmark history
 * items in the bookmark/history table, delete TRUNCATE_N_OLDEST
 * of them.  This is used to keep our history table to a
 * reasonable size.  Note: it does not prune bookmarks.  If the
 * user wants 1000 bookmarks, the user gets 1000 bookmarks.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr The ContentResolver used to access the database.
 */
","/**
 * If there are more than MAX_HISTORY_COUNT non-bookmark history
 * items in the bookmark/history table, delete TRUNCATE_N_OLDEST
 * of them.  This is used to keep our history table to a
 * reasonable size.  Note: it does not prune bookmarks.  If the
 * user wants 1000 bookmarks, the user gets 1000 bookmarks.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr The ContentResolver used to access the database.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The statement `iconDb.releaseIconForPageUrl(cursor.getString(1));` has been removed, which is neither a return statement, exception handling statement, nor a statement under a control dependency. Therefore, the code change type is 4. Additionally, since `WebIconDatabase.getInstance();` is no longer being used, the change also relates to a dependent API, so the change type is 5 as well.","The removal of `iconDb.releaseIconForPageUrl(cursor.getString(1));` does not impact the return type or value, nor does it alter exception handling. As such, this change will not cause the API to return a different value or to throw a different exception, therefore, there is no Compatibility Issue."
1042,"<android.content.res.XmlBlock.Parser: int getAttributeUnsignedIntValue(int,int)>",20,21,"<android.content.res.XmlBlock.Parser: int getAttributeUnsignedIntValue(int,int)>","<android.content.res.XmlBlock.Parser: int getAttributeUnsignedIntValue(int,int)>",0,"{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on appt doing the conversion for us.
    if (t >= TypedValue.TYPE_FIRST_INT && t <= TypedValue.TYPE_LAST_INT) {
        return nativeGetAttributeData(mParseState, idx);
    }
    return defaultValue;
}","{
    int t = nativeGetAttributeDataType(mParseState, idx);
    // we want to count on aapt doing the conversion for us.
    if (t >= TypedValue.TYPE_FIRST_INT && t <= TypedValue.TYPE_LAST_INT) {
        return nativeGetAttributeData(mParseState, idx);
    }
    return defaultValue;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation code between the early version and the late version.,"Since there is no change, there is no compatibility issue."
1043,"<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>",20,21,"<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>","<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mStarted) {
            cleanUp();
            throw new IllegalArgumentException(""FileSynthesisRequest.start() called twice"");
        }
        mStarted = true;
        mSampleRateInHz = sampleRateInHz;
        mAudioFormat = audioFormat;
        mChannelCount = channelCount;
        try {
            mFileChannel.write(ByteBuffer.allocate(WAV_HEADER_LENGTH));
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write wav header to output file descriptor"" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}","{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    FileChannel fileChannel = null;
    synchronized (mStateLock) {
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mStarted) {
            Log.e(TAG, ""Start called twice"");
            return TextToSpeech.ERROR;
        }
        mStarted = true;
        mSampleRateInHz = sampleRateInHz;
        mAudioFormat = audioFormat;
        mChannelCount = channelCount;
        if (mDispatcher != null) {
            mDispatcher.dispatchOnStart();
        }
        fileChannel = mFileChannel;
    }
    try {
        fileChannel.write(ByteBuffer.allocate(WAV_HEADER_LENGTH));
        return TextToSpeech.SUCCESS;
    } catch (IOException ex) {
        Log.e(TAG, ""Failed to write wav header to output file descriptor"", ex);
        synchronized (mStateLock) {
            cleanUp();
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
        }
        return TextToSpeech.ERROR;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3","1,2","There is a change in return statements, the exception handling statement and control dependency. The check for `mStopped` has been replaced with a check for `mStatusCode == TextToSpeech.STOPPED` and the subsequent logic. Also, `fileChannel` creation moved outside of the `synchronized` block, and an additional status code check `mStatusCode != TextToSpeech.SUCCESS` added, which changes the control flow. The exception handling now sets `mStatusCode` within a synchronized block, which is different from the early version that only calls `cleanUp()`. These constitute return statement changes (type 1), exception handling statement changes (type 2), and control dependency changes (type 3).","The modifications can potentially change the return value of the function, causing a CI (type 1), as the conditions under which `TextToSpeech.ERROR` or `TextToSpeech.SUCCESS` are returned are different. The way how exceptions are handled has changed, now affecting the `mStatusCode` state within a synchronized block, which can also cause CI due to potential differences in exception handling (type 2)."
1044,<android.app.ActivityManager: int getLauncherLargeIconSize()>,20,21,<android.app.ActivityManager: int getLauncherLargeIconSize()>,<android.app.ActivityManager: int getLauncherLargeIconSize()>,0,"{
    final Resources res = mContext.getResources();
    final int size = res.getDimensionPixelSize(android.R.dimen.app_icon_size);
    final int sw = res.getConfiguration().smallestScreenWidthDp;
    if (sw < 600) {
        // Smaller than approx 7"" tablets, use the regular icon size.
        return size;
    }
    final int density = res.getDisplayMetrics().densityDpi;
    switch(density) {
        case DisplayMetrics.DENSITY_LOW:
            return (size * DisplayMetrics.DENSITY_MEDIUM) / DisplayMetrics.DENSITY_LOW;
        case DisplayMetrics.DENSITY_MEDIUM:
            return (size * DisplayMetrics.DENSITY_HIGH) / DisplayMetrics.DENSITY_MEDIUM;
        case DisplayMetrics.DENSITY_TV:
            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_HIGH:
            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_XHIGH:
            return (size * DisplayMetrics.DENSITY_XXHIGH) / DisplayMetrics.DENSITY_XHIGH;
        case DisplayMetrics.DENSITY_XXHIGH:
            return (size * DisplayMetrics.DENSITY_XHIGH * 2) / DisplayMetrics.DENSITY_XXHIGH;
        default:
            // abnormal value that is a reasonable scaling of it.
            return (int) ((size * 1.5f) + .5f);
    }
}","{
    return getLauncherLargeIconSizeInner(mContext);
}",1,"/**
 * Get the preferred launcher icon size. This is used when custom drawables
 * are created (e.g., for shortcuts).
 *
 * @return dimensions of square icons in terms of pixels
 */
","/**
 * Get the preferred launcher icon size. This is used when custom drawables
 * are created (e.g., for shortcuts).
 *
 * @return dimensions of square icons in terms of pixels
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the function has been completely replaced by a call to a new method getLauncherLargeIconSizeInner(mContext), so there is a dependent API change, which is the 5th type of code change.","There is no compatibility issue introduced as long as the new method getLauncherLargeIconSizeInner(mContext) maintains the same contract and behavior as the original implementation. Without further information on the behavior of the new method, it cannot be determined if there's a compatibility issue. Therefore, as per the details provided, no compatibility issue (0) is detected."
1046,"<android.widget.LinearLayout: void measureVertical(int,int)>",20,21,"<android.widget.LinearLayout: void measureVertical(int,int)>","<android.widget.LinearLayout: void measureVertical(int,int)>",0,"{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = heightSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}","{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = heightSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}",1,"/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
","/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1047,"<android.os.Bundle: float getFloat(String,float)>",20,21,"<android.os.Bundle: float getFloat(String,float)>","<android.os.Bundle: float getFloat(String,float)>",0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (Float) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Float"", defaultValue, e);
        return defaultValue;
    }
}","{
    return super.getFloat(key, defaultValue);
}",1,"/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a float value
 */
","/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a float value
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from providing the logic handling the retrieval and casting of a value from a map, to simply calling a super class method super.getFloat(key, defaultValue), which indicates that the functionality has been moved to the super class. This is classified as a dependent API changed, thus the code change type is 5.","Despite the API implementation changing to call the super method, as long as the super.getFloat() method is correctly overriding the functionality that was previously provided in this method's early version, there should be no compatibility issue with respect to behavior - the API is expected to return the same results with the same inputs. Therefore, the CI type is 0."
1048,<android.bluetooth.BluetoothGatt: boolean executeReliableWrite()>,20,21,<android.bluetooth.BluetoothGatt: boolean executeReliableWrite()>,<android.bluetooth.BluetoothGatt: boolean executeReliableWrite()>,0,"{
    if (DBG)
        Log.d(TAG, ""executeReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""executeReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the request to execute the transaction has been sent
 */
","/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the request to execute the transaction has been sent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The variable DBG has been changed to VDBG which is an 'Other statement changed.' Furthermore, there is a new control dependency with the addition and modification of synchronized block that checks and sets mDeviceBusy, so the change type is 3,4.","The newly introduced 'if' condition inside the synchronized block can cause the method to return false, where it previously would have returned true, thus it is a CI caused by potential different return values and the CI type is 1."
1049,<android.content.res.Configuration: String toString()>,20,21,<android.content.res.Configuration: String toString()>,<android.content.res.Configuration: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    if (locale != null) {
        sb.append("" "");
        sb.append(locale);
    } else {
        sb.append("" ?locale"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    if (locale != null) {
        sb.append("" "");
        sb.append(locale);
    } else {
        sb.append("" ?locale"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        case UI_MODE_TYPE_WATCH:
            sb.append("" watch"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
1050,<android.view.View: float getX()>,20,21,<android.view.View: float getX()>,<android.view.View: float getX()>,0,"{
    return mLeft + (mTransformationInfo != null ? mTransformationInfo.mTranslationX : 0);
}","{
    return mLeft + getTranslationX();
}",1,"/**
 * The visual x position of this view, in pixels. This is equivalent to the
 * {@link #setTranslationX(float) translationX} property plus the current
 * {@link #getLeft() left} property.
 *
 * @return The visual x position of this view, in pixels.
 */
","/**
 * The visual x position of this view, in pixels. This is equivalent to the
 * {@link #setTranslationX(float) translationX} property plus the current
 * {@link #getLeft() left} property.
 *
 * @return The visual x position of this view, in pixels.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,5,0,"The method call getTranslationX() is being used in place of a direct reference to mTransformationInfo.mTranslationX in the late implementation, this change does not introduce a new return type or value, assuming getTranslationX() encapsulates the same access and returns the same value. So, only the code change type is 5 because a dependent API is used in the late implementation.","There is no Compatibility Issue because getTranslationX() should return the exact same value as mTransformationInfo.mTranslationX which is what the previous implementation was effectively doing manually, there is no change to the logic of return value."
1051,<android.database.sqlite.SQLiteConnection.PreparedStatementCache: void dump(Printer)>,20,21,<android.database.sqlite.SQLiteConnection.PreparedStatementCache: void dump(Printer)>,<android.database.sqlite.SQLiteConnection.PreparedStatementCache: void dump(Printer)>,0,"{
    printer.println(""  Prepared statement cache:"");
    Map<String, PreparedStatement> cache = snapshot();
    if (!cache.isEmpty()) {
        int i = 0;
        for (Map.Entry<String, PreparedStatement> entry : cache.entrySet()) {
            PreparedStatement statement = entry.getValue();
            if (statement.mInCache) {
                // might be false due to a race with entryRemoved
                String sql = entry.getKey();
                printer.println(""    "" + i + "": statementPtr=0x"" + Integer.toHexString(statement.mStatementPtr) + "", numParameters="" + statement.mNumParameters + "", type="" + statement.mType + "", readOnly="" + statement.mReadOnly + "", sql=\"""" + trimSqlForDisplay(sql) + ""\"""");
            }
            i += 1;
        }
    } else {
        printer.println(""    <none>"");
    }
}","{
    printer.println(""  Prepared statement cache:"");
    Map<String, PreparedStatement> cache = snapshot();
    if (!cache.isEmpty()) {
        int i = 0;
        for (Map.Entry<String, PreparedStatement> entry : cache.entrySet()) {
            PreparedStatement statement = entry.getValue();
            if (statement.mInCache) {
                // might be false due to a race with entryRemoved
                String sql = entry.getKey();
                printer.println(""    "" + i + "": statementPtr=0x"" + Long.toHexString(statement.mStatementPtr) + "", numParameters="" + statement.mNumParameters + "", type="" + statement.mType + "", readOnly="" + statement.mReadOnly + "", sql=\"""" + trimSqlForDisplay(sql) + ""\"""");
            }
            i += 1;
        }
    } else {
        printer.println(""    <none>"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change between the two versions is in the method used to convert the `statement.mStatementPtr` to a hexadecimal string; `Integer.toHexString()` is changed to `Long.toHexString()`, which affects the content of the printed string but not the behavior of the method itself. Therefore, the code change type is 4 (Other statement changed).",There is no Compatibility Issue because the method's functionality and contract are preserved. The method still performs its duty to print information about the prepared statements in the cache without changing its behavior or output structure; only the internal detail of the conversion method is different.
1052,<android.widget.TimePicker: Integer getCurrentMinute()>,20,21,<android.widget.TimePicker: Integer getCurrentMinute()>,<android.widget.TimePicker: Integer getCurrentMinute()>,0,"{
    return mMinuteSpinner.getValue();
}","{
    return mDelegate.getCurrentMinute();
}",1,"/**
 * @return The current minute.
 */
","/**
 * @return The current minute.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, and the method called to obtain the value has changed from `mMinuteSpinner.getValue()` to `mDelegate.getCurrentMinute()`, so the change type is 1,5.","The method used to return the current minute has changed to a different implementation in the delegate class. This change could lead to different return values depending on the implementation of `getCurrentMinute()` in the delegate, so the CI type is 1."
1053,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",20,21,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>","<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        int xmlBlock = openXmlAssetNative(cookie, fileName);
        if (xmlBlock != 0) {
            XmlBlock res = new XmlBlock(this, xmlBlock);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException(""Asset XML file: "" + fileName);
}","{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        long xmlBlock = openXmlAssetNative(cookie, fileName);
        if (xmlBlock != 0) {
            XmlBlock res = new XmlBlock(this, xmlBlock);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException(""Asset XML file: "" + fileName);
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The type of the variable `xmlBlock` has changed from `int` to `long`. This is a change in a local variable's type and does not directly affect the return type or the exception thrown, so the code change type is 4.","Since the local variable `xmlBlock` type change from `int` to `long` does not affect the method's return type (`XmlBlock`), which remains unchanged, and the thrown exceptions (both `RuntimeException` and `FileNotFoundException`) remain the same, there is no Compatibility Issue, so the CI type is 0."
1056,"<android.speech.tts.TextToSpeech: int playSilence(long,int,HashMap<String, String>)>",20,21,"<android.speech.tts.TextToSpeech: int playSilence(long,int,HashMap<String, String>)>","<android.speech.tts.TextToSpeech: int playSilence(long,int,HashMap<String, String>)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.playSilence(getCallerIdentity(), durationInMs, queueMode, getParams(params));
        }
    }, ERROR, ""playSilence"");
}","{
    return playSilentUtterance(durationInMs, queueMode, params == null ? null : params.get(Engine.KEY_PARAM_UTTERANCE_ID));
}",1,"/**
 * Plays silence for the specified amount of time using the specified
 * queue mode.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param durationInMs The duration of the silence.
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playSilence operation.
 */
","/**
 * Plays silence for the specified amount of time using the specified
 * queue mode.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param durationInMs The duration of the silence.
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the playSilence operation.
 * @deprecated As of API level 21, replaced by
 * {@link #playSilentUtterance(long, int, String)}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the late version no longer uses an anonymous Action class or makes a call to the ITextToSpeechService, instead it is calling a different method playSilentUtterance directly. Thus, we have a change in the return statement (class 1) and it is also calling a different method which can be considered a dependency change (class 5).","With the introduction of a direct method call to playSilentUtterance instead of the anonymous class, and the indirect call through ITextToSpeechService, the late version could behave differently, potentially returning different results because of the change in the method invocation pattern. Thus, the CI type is 1."
1058,"<android.app.Notification.Builder: Builder setTicker(CharSequence,RemoteViews)>",20,21,"<android.app.Notification.Builder: Builder setTicker(CharSequence,RemoteViews)>","<android.app.Notification.Builder: Builder setTicker(CharSequence,RemoteViews)>",0,"{
    mTickerText = safeCharSequence(tickerText);
    mTickerView = views;
    return this;
}","{
    mTickerText = safeCharSequence(tickerText);
    // we'll save it for you anyway
    mTickerView = views;
    return this;
}",1,"/**
 * Set the text that is displayed in the status bar when the notification first
 * arrives, and also a RemoteViews object that may be displayed instead on some
 * devices.
 *
 * @see Notification#tickerText
 * @see Notification#tickerView
 */
","/**
 * Obsolete version of {@link #setTicker(CharSequence)}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The only change is the introduction of a comment, which does not affect the behavior of the code. Thus, this is classified under ""Other statement changed"" which is type 4.","Since the code change is only a comment, it does not lead to any potential different return values, types, or exceptions. Therefore, there is no Compatibility Issue, which is type 0."
1059,"<android.content.res.TypedArray: int getLayoutDimension(int,int)>",20,21,"<android.content.res.TypedArray: int getLayoutDimension(int,int)>","<android.content.res.TypedArray: int getLayoutDimension(int,int)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    }
    return defValue;
}",1,"/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 *
 * @param index Index of the attribute to retrieve.
 * @param defValue The default value to return if this attribute is not
 * default or contains the wrong type of data.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 */
","/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 *
 * @param index Index of the attribute to retrieve.
 * @param defValue The default value to return if this attribute is not
 * default or contains the wrong type of data.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5",2,"The early version does not check if `mRecycled` is true, but the late version does and throws a `RuntimeException` if it is. An additional check has been added at the start of the method, which  alters the control flow of the API. There is also a change in the member reference from `mResources.mMetrics` to `mMetrics`, indicating a potential change in a dependent API, although without more context it is uncertain if this reference means a change in the accessed API. Regarding the exception, since the early version does not throw an exception in this case, but the late version might, this introduces a compatibility issue. So, the change types are 2 for the exception handling change, 3 for the change in the control flow due to the check on `mRecycled`, and 5 for the possible change in a dependent API.","The introduction of a new exception handling in the late version where the method could throw a `RuntimeException` if `mRecycled` is true, which was not present in the early version, could lead to a different exception being thrown and therefore, there is a compatibility issue type 2."
1060,"<android.view.GLES20Canvas: void drawBitmap(int[],int,int,float,float,int,int,boolean,Paint)>",20,21,"<android.view.GLES20Canvas: void drawBitmap(int[],int,int,float,float,int,int,boolean,Paint)>","<android.view.GLES20Canvas: void drawBitmap(int[],int,int,float,float,int,int,boolean,Paint)>",0,"{
    if (width < 0) {
        throw new IllegalArgumentException(""width must be >= 0"");
    }
    if (height < 0) {
        throw new IllegalArgumentException(""height must be >= 0"");
    }
    if (Math.abs(stride) < width) {
        throw new IllegalArgumentException(""abs(stride) must be >= width"");
    }
    int lastScanline = offset + (height - 1) * stride;
    int length = colors.length;
    if (offset < 0 || (offset + width > length) || lastScanline < 0 || (lastScanline + width > length)) {
        throw new ArrayIndexOutOfBoundsException();
    }
    // Shaders are ignored when drawing bitmaps
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, colors, offset, stride, x, y, width, height, hasAlpha, nativePaint);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
}","{
    if (width < 0) {
        throw new IllegalArgumentException(""width must be >= 0"");
    }
    if (height < 0) {
        throw new IllegalArgumentException(""height must be >= 0"");
    }
    if (Math.abs(stride) < width) {
        throw new IllegalArgumentException(""abs(stride) must be >= width"");
    }
    int lastScanline = offset + (height - 1) * stride;
    int length = colors.length;
    if (offset < 0 || (offset + width > length) || lastScanline < 0 || (lastScanline + width > length)) {
        throw new ArrayIndexOutOfBoundsException();
    }
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, colors, offset, stride, x, y, width, height, hasAlpha, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is related to removing the code responsible for setting up and resetting color filters around the nDrawBitmap call. The type and value of variables returned remain unchanged across versions as does the exception handling, so the code change type is 4.","This change does not introduce potential compatibility issues because there is no modification to the return type, value, exception handling or control flow that would affect the API's behavior from the caller's perspective. Hence, the CI type is 0."
1064,<android.widget.EdgeEffect: boolean draw(Canvas)>,20,21,<android.widget.EdgeEffect: boolean draw(Canvas)>,<android.widget.EdgeEffect: boolean draw(Canvas)>,0,"{
    update();
    mGlow.setAlpha((int) (Math.max(0, Math.min(mGlowAlpha, 1)) * 255));
    int glowBottom = (int) Math.min(mGlowHeight * mGlowScaleY * mGlowHeight / mGlowWidth * 0.6f, mGlowHeight * MAX_GLOW_HEIGHT);
    if (mWidth < mMinWidth) {
        // Center the glow and clip it.
        int glowLeft = (mWidth - mMinWidth) / 2;
        mGlow.setBounds(glowLeft, 0, mWidth - glowLeft, glowBottom);
    } else {
        // Stretch the glow to fit.
        mGlow.setBounds(0, 0, mWidth, glowBottom);
    }
    mGlow.draw(canvas);
    mEdge.setAlpha((int) (Math.max(0, Math.min(mEdgeAlpha, 1)) * 255));
    int edgeBottom = (int) (mEdgeHeight * mEdgeScaleY);
    if (mWidth < mMinWidth) {
        // Center the edge and clip it.
        int edgeLeft = (mWidth - mMinWidth) / 2;
        mEdge.setBounds(edgeLeft, 0, mWidth - edgeLeft, edgeBottom);
    } else {
        // Stretch the edge to fit.
        mEdge.setBounds(0, 0, mWidth, edgeBottom);
    }
    mEdge.draw(canvas);
    if (mState == STATE_RECEDE && glowBottom == 0 && edgeBottom == 0) {
        mState = STATE_IDLE;
    }
    return mState != STATE_IDLE;
}","{
    update();
    final int count = canvas.save();
    final float centerX = mBounds.centerX();
    final float centerY = mBounds.height() - mRadius;
    canvas.scale(1.f, Math.min(mGlowScaleY, 1.f) * mBaseGlowScale, centerX, 0);
    final float displacement = Math.max(0, Math.min(mDisplacement, 1.f)) - 0.5f;
    float translateX = mBounds.width() * displacement / 2;
    canvas.clipRect(mBounds);
    canvas.translate(translateX, 0);
    mPaint.setAlpha((int) (0xff * mGlowAlpha));
    canvas.drawCircle(centerX, centerY, mRadius, mPaint);
    canvas.restoreToCount(count);
    boolean oneLastFrame = false;
    if (mState == STATE_RECEDE && mGlowScaleY == 0) {
        mState = STATE_IDLE;
        oneLastFrame = true;
    }
    return mState != STATE_IDLE || oneLastFrame;
}",1,"/**
 * Draw into the provided canvas. Assumes that the canvas has been rotated
 * accordingly and the size has been set. The effect will be drawn the full
 * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
 * 1.f of height.
 *
 * @param canvas Canvas to draw into
 * @return true if drawing should continue beyond this frame to continue the
 * animation
 */
","/**
 * Draw into the provided canvas. Assumes that the canvas has been rotated
 * accordingly and the size has been set. The effect will be drawn the full
 * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
 * 1.f of height.
 *
 * @param canvas Canvas to draw into
 * @return true if drawing should continue beyond this frame to continue the
 * animation
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation has a completely different drawing logic compared to the early version, including changes in the manipulation of the alpha channel, bounds setting, and drawing method being used. Additionally, there is a change in the control dependency, specifically the if condition determining when to transition to the STATE_IDLE state. Therefore, the code change type includes 1, 3, and 4.","Due to the significant refactoring of the drawing code and control flow, these changes could lead to different visual outputs (return values) when the draw method is called. As a result, the method is likely to return a different value, especially since the oneLastFrame variable is introduced to control the return value in the case where the state transitions to STATE_IDLE from STATE_RECEDE. Hence, the CI type is 1."
1067,<android.os.MessageQueue: void quit(boolean)>,20,21,<android.os.MessageQueue: void quit(boolean)>,<android.os.MessageQueue: void quit(boolean)>,0,"{
    if (!mQuitAllowed) {
        throw new RuntimeException(""Main thread not allowed to quit."");
    }
    synchronized (this) {
        if (mQuitting) {
            return;
        }
        mQuitting = true;
        if (safe) {
            removeAllFutureMessagesLocked();
        } else {
            removeAllMessagesLocked();
        }
        // We can assume mPtr != 0 because mQuitting was previously false.
        nativeWake(mPtr);
    }
}","{
    if (!mQuitAllowed) {
        throw new IllegalStateException(""Main thread not allowed to quit."");
    }
    synchronized (this) {
        if (mQuitting) {
            return;
        }
        mQuitting = true;
        if (safe) {
            removeAllFutureMessagesLocked();
        } else {
            removeAllMessagesLocked();
        }
        // We can assume mPtr != 0 because mQuitting was previously false.
        nativeWake(mPtr);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception thrown within the if statement has been changed from RuntimeException to IllegalStateException, so the code change type is 2.","Since the type of exception thrown has changed, this could potentially lead to different exception handling when this method is used. If code catching RuntimeException but not the more specific IllegalStateException is present, then this would be a behavioral change, hence the CI type is 2."
1069,<android.os.Bundle: ArrayList<CharSequence> getCharSequenceArrayList(String)>,20,21,<android.os.Bundle: ArrayList<CharSequence> getCharSequenceArrayList(String)>,<android.os.Bundle: ArrayList<CharSequence> getCharSequenceArrayList(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<CharSequence>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""ArrayList<CharSequence>"", e);
        return null;
    }
}","{
    return super.getCharSequenceArrayList(key);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<CharSequence> value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<CharSequence> value, or null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method's implementation has been fully replaced with a call to `super.getCharSequenceArrayList(key);`. Therefore, the previous logic involving unparcel, the checking, casting, and catching of a ClassCastException is completely removed. This type of change is classified as 4. Additionally, because this method now delegates its execution to a method in its superclass, there is a change in the dependent API, classified as 5.","There is no compatibility issue here because the late version of the method delegates the call to its superclass, which presumably preserves the logic that existed in the early version. The contract of the method appears to be the same, and it should function identically from the perspective of a user of this API, hence it's classified as 0 for no compatibility issue."
1070,"<android.os.Parcel: void writeArrayMapInternal(ArrayMap<String, Object>)>",20,21,"<android.os.Parcel: void writeArrayMapInternal(ArrayMap<String, Object>)>","<android.os.Parcel: void writeArrayMapInternal(ArrayMap<String, Object>)>",0,"{
    if (val == null) {
        writeInt(-1);
        return;
    }
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException(""here"");
        here.fillInStackTrace();
        Log.d(TAG, ""Writing "" + N + "" ArrayMap entries"", here);
    }
    int startPos;
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            startPos = dataPosition();
        writeValue(val.keyAt(i));
        writeValue(val.valueAt(i));
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, ""  Write #"" + i + "" "" + (dataPosition() - startPos) + "" bytes: key=0x"" + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + "" "" + val.keyAt(i));
    }
}","{
    if (val == null) {
        writeInt(-1);
        return;
    }
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException(""here"");
        here.fillInStackTrace();
        Log.d(TAG, ""Writing "" + N + "" ArrayMap entries"", here);
    }
    int startPos;
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            startPos = dataPosition();
        writeString(val.keyAt(i));
        writeValue(val.valueAt(i));
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, ""  Write #"" + i + "" "" + (dataPosition() - startPos) + "" bytes: key=0x"" + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + "" "" + val.keyAt(i));
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is from writeValue(val.keyAt(i)) to writeString(val.keyAt(i)) for writing keys in the Map, which does not affect control flow, nor does it alter exception handling. The code does not directly return any value that could be affected by this change. Thus, the code change type is 4 (Other statement changed).","This change does not lead to a Compatibility Issue. Although the method for writing keys into a Parcel is changed, this does not affect the behavior presented to the user of the method as the method itself doesn't return a value to the caller and is designed to write into a Parcel which can accept String inputs. The data value written by writeString() can still represent the key. Hence, there is no CI."
1071,<android.view.View: void setBackgroundDrawable(Drawable)>,20,21,<android.view.View: void setBackgroundDrawable(Drawable)>,<android.view.View: void setBackgroundDrawable(Drawable)>,0,"{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawables();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPadding();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~PFLAG_ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}","{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawables();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPadding();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        applyBackgroundTint();
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~PFLAG_ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}",1,"/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
","/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,,,,
1072,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",20,21,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>","<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",0,"{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // always use ourselves when inflating ViewStub later
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(this);
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}","{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        constructor.setAccessible(true);
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}",1,"/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
","/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1073,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,20,21,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,0,"{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    if (!mAudioTrack.init()) {
        dispatcher.dispatchOnError();
        return;
    }
    try {
        byte[] buffer = null;
        // OR (c) done() is called in which case it will return null.
        while ((buffer = take()) != null) {
            mAudioTrack.write(buffer);
            mLogger.onAudioDataWritten();
        }
    } catch (InterruptedException ie) {
        if (DBG)
            Log.d(TAG, ""Interrupted waiting for buffers, cleaning up."");
    }
    mAudioTrack.waitAndRelease();
    if (mIsError) {
        dispatcher.dispatchOnError();
    } else {
        dispatcher.dispatchOnDone();
    }
    mLogger.onWriteData();
}","{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    if (!mAudioTrack.init()) {
        dispatcher.dispatchOnError(TextToSpeech.ERROR_OUTPUT);
        return;
    }
    try {
        byte[] buffer = null;
        // OR (c) done() is called in which case it will return null.
        while ((buffer = take()) != null) {
            mAudioTrack.write(buffer);
            mLogger.onAudioDataWritten();
        }
    } catch (InterruptedException ie) {
        if (DBG)
            Log.d(TAG, ""Interrupted waiting for buffers, cleaning up."");
    }
    mAudioTrack.waitAndRelease();
    if (mStatusCode == TextToSpeech.SUCCESS) {
        dispatcher.dispatchOnSuccess();
    } else if (mStatusCode == TextToSpeech.STOPPED) {
        dispatcher.dispatchOnStop();
    } else {
        dispatcher.dispatchOnError(mStatusCode);
    }
    mLogger.onCompleted(mStatusCode);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","There are changes in the return value for an error case (dispatchOnError now receives a specific error code), exception handling (although the code block contents for the catch block remains the same, the surrounding context affects its reach), control flow (new conditions added for checking mStatusCode), and other statements (call to dispatchOnSuccess/dispatchOnStop and argument to mLogger.onCompleted). This results in a multi-category change of types 1,2,3,4.",The changes made could lead to different behaviors in the new version of the API. Specifically:
1074,<android.widget.NumberPicker: boolean onTouchEvent(MotionEvent)>,20,21,<android.widget.NumberPicker: boolean onTouchEvent(MotionEvent)>,<android.widget.NumberPicker: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled() || !mHasSelectorWheel) {
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(event);
    int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            {
                if (mIngonreMoveEvents) {
                    break;
                }
                float currentMoveY = event.getY();
                if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                    int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
                    if (deltaDownY > mTouchSlop) {
                        removeAllCallbacks();
                        onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    }
                } else {
                    int deltaMoveY = (int) ((currentMoveY - mLastDownOrMoveEventY));
                    scrollBy(0, deltaMoveY);
                    invalidate();
                }
                mLastDownOrMoveEventY = currentMoveY;
            }
            break;
        case MotionEvent.ACTION_UP:
            {
                removeBeginSoftInputCommand();
                removeChangeCurrentByOneFromLongPress();
                mPressedStateHelper.cancel();
                VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity();
                if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
                    fling(initialVelocity);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                } else {
                    int eventY = (int) event.getY();
                    int deltaMoveY = (int) Math.abs(eventY - mLastDownEventY);
                    long deltaTime = event.getEventTime() - mLastDownEventTime;
                    if (deltaMoveY <= mTouchSlop && deltaTime < ViewConfiguration.getTapTimeout()) {
                        if (mShowSoftInputOnTap) {
                            mShowSoftInputOnTap = false;
                            showSoftInput();
                        } else {
                            int selectorIndexOffset = (eventY / mSelectorElementHeight) - SELECTOR_MIDDLE_ITEM_INDEX;
                            if (selectorIndexOffset > 0) {
                                changeValueByOne(true);
                                mPressedStateHelper.buttonTapped(PressedStateHelper.BUTTON_INCREMENT);
                            } else if (selectorIndexOffset < 0) {
                                changeValueByOne(false);
                                mPressedStateHelper.buttonTapped(PressedStateHelper.BUTTON_DECREMENT);
                            }
                        }
                    } else {
                        ensureScrollWheelAdjusted();
                    }
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                }
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            break;
    }
    return true;
}","{
    if (!isEnabled() || !mHasSelectorWheel) {
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(event);
    int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            {
                if (mIgnoreMoveEvents) {
                    break;
                }
                float currentMoveY = event.getY();
                if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                    int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
                    if (deltaDownY > mTouchSlop) {
                        removeAllCallbacks();
                        onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    }
                } else {
                    int deltaMoveY = (int) ((currentMoveY - mLastDownOrMoveEventY));
                    scrollBy(0, deltaMoveY);
                    invalidate();
                }
                mLastDownOrMoveEventY = currentMoveY;
            }
            break;
        case MotionEvent.ACTION_UP:
            {
                removeBeginSoftInputCommand();
                removeChangeCurrentByOneFromLongPress();
                mPressedStateHelper.cancel();
                VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity();
                if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
                    fling(initialVelocity);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                } else {
                    int eventY = (int) event.getY();
                    int deltaMoveY = (int) Math.abs(eventY - mLastDownEventY);
                    long deltaTime = event.getEventTime() - mLastDownEventTime;
                    if (deltaMoveY <= mTouchSlop && deltaTime < ViewConfiguration.getTapTimeout()) {
                        if (mPerformClickOnTap) {
                            mPerformClickOnTap = false;
                            performClick();
                        } else {
                            int selectorIndexOffset = (eventY / mSelectorElementHeight) - SELECTOR_MIDDLE_ITEM_INDEX;
                            if (selectorIndexOffset > 0) {
                                changeValueByOne(true);
                                mPressedStateHelper.buttonTapped(PressedStateHelper.BUTTON_INCREMENT);
                            } else if (selectorIndexOffset < 0) {
                                changeValueByOne(false);
                                mPressedStateHelper.buttonTapped(PressedStateHelper.BUTTON_DECREMENT);
                            }
                        }
                    } else {
                        ensureScrollWheelAdjusted();
                    }
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                }
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1075,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,20,21,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence);
                }
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                        // handling this message.
                        if (mServedView != null && mServedView.hasWindowFocus()) {
                            // mServedInputConnection.finishComposingText.
                            if (checkFocusNoStartInput(mHasBeenInactive, false)) {
                                startInputInner(null, 0, 0, 0);
                            }
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence);
                }
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                        // handling this message.
                        if (mServedView != null && mServedView.hasWindowFocus()) {
                            // mServedInputConnection.finishComposingText.
                            if (checkFocusNoStartInput(mHasBeenInactive, false)) {
                                startInputInner(null, 0, 0, 0);
                            }
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1076,"<android.transition.Transition: Transition excludeTarget(Class,boolean)>",20,21,"<android.transition.Transition: Transition excludeTarget(Class,boolean)>","<android.transition.Transition: Transition excludeTarget(Class,boolean)>",0,"{
    mTargetTypeExcludes = excludeType(mTargetTypeExcludes, type, exclude);
    return this;
}","{
    mTargetTypeExcludes = excludeObject(mTargetTypeExcludes, type, exclude);
    return this;
}",1,"/**
 * Whether to add the given type to the list of types to exclude from this
 * transition. The <code>exclude</code> parameter specifies whether the target
 * type should be added to or removed from the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeChildren(Class, boolean)
 * @see #excludeTarget(int, boolean)
 * @see #excludeTarget(View, boolean)
 *
 * @param type The type to ignore when running this transition.
 * @param exclude Whether to add the target type to or remove it from the
 * current list of excluded target types.
 * @return This transition object.
 */
","/**
 * Whether to add the given type to the list of types to exclude from this
 * transition. The <code>exclude</code> parameter specifies whether the target
 * type should be added to or removed from the excluded list.
 *
 * <p>Excluding targets is a general mechanism for allowing transitions to run on
 * a view hierarchy while skipping target views that should not be part of
 * the transition. For example, you may want to avoid animating children
 * of a specific ListView or Spinner. Views can be excluded either by their
 * id, or by their instance reference, or by the Class of that view
 * (eg, {@link Spinner}).</p>
 *
 * @see #excludeChildren(Class, boolean)
 * @see #excludeTarget(int, boolean)
 * @see #excludeTarget(View, boolean)
 *
 * @param type The type to ignore when running this transition.
 * @param exclude Whether to add the target type to or remove it from the
 * current list of excluded target types.
 * @return This transition object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent method called within the function has changed from excludeType to excludeObject, and since it's part of an assignment to mTargetTypeExcludes, the change type is 4,5.","There is no change in return type or value, and no change in the exceptions that could be thrown. The change is internal to how the target types are excluded, which, based solely on the names of the methods, implies a change in implementation detail rather than a change in the method's external contract. Therefore, based on the provided information, there is no CI."
1079,<android.view.accessibility.AccessibilityManager: boolean removeTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,20,21,<android.view.accessibility.AccessibilityManager: boolean removeTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean removeTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,0,"{
    return mTouchExplorationStateChangeListeners.remove(listener);
}","{
    // Final CopyOnArrayList - no lock needed.
    return mTouchExplorationStateChangeListeners.remove(listener);
}",1,"/**
 * Unregisters a {@link TouchExplorationStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
","/**
 * Unregisters a {@link TouchExplorationStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is only a comment added in the late version, which does not change the logic or behavior of the code.","Since no actual code change occurred (only a comment was added), there's no Compatibility Issue. Comments do not affect the execution of the method."
1081,"<android.animation.AnimatorInflater: Animator loadAnimator(Context,int)>",20,21,"<android.animation.AnimatorInflater: Animator loadAnimator(Context,int)>","<android.animation.AnimatorInflater: Animator loadAnimator(Context,int)>",0,"{
    XmlResourceParser parser = null;
    try {
        parser = context.getResources().getAnimation(id);
        return createAnimatorFromXml(context, parser);
    } catch (XmlPullParserException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load animation resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load animation resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null)
            parser.close();
    }
}","{
    return loadAnimator(context.getResources(), context.getTheme(), id);
}",1,"/**
 * Loads an {@link Animator} object from a resource
 *
 * @param context Application context used to access resources
 * @param id The resource id of the animation to load
 * @return The animator object reference by the specified id
 * @throws android.content.res.Resources.NotFoundException when the animation cannot be loaded
 */
","/**
 * Loads an {@link Animator} object from a resource
 *
 * @param context Application context used to access resources
 * @param id The resource id of the animation to load
 * @return The animator object reference by the specified id
 * @throws android.content.res.Resources.NotFoundException when the animation cannot be loaded
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed completely, a new method loadAnimator() with different parameters is called and the exception handling code is removed, so the code change type is 1,5.","The early version throws a Resources.NotFoundException with specifics about XmlPullParserException or IOException. While the late version potentially throws exceptions handled inside the loadAnimator() method, which might not include the detailed cause. Thus, the API behavior in terms of exception handling and return value would differ between versions, and the CI type is 1."
1082,<android.animation.AnimatorSet.Builder: Builder after(Animator)>,20,21,<android.animation.AnimatorSet.Builder: Builder after(Animator)>,<android.animation.AnimatorSet.Builder: Builder after(Animator)>,0,"{
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(node, Dependency.AFTER);
    mCurrentNode.addDependency(dependency);
    return this;
}","{
    mReversible = false;
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(node, Dependency.AFTER);
    mCurrentNode.addDependency(dependency);
    return this;
}",1,"/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to start when the animation supplied in this method call ends.
 *
 * @param anim The animation whose end will cause the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method to play.
 */
","/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to start when the animation supplied in this method call ends.
 *
 * @param anim The animation whose end will cause the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method to play.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of `mReversible = false;`, which is not a return statement, exception handling, control dependency, nor a dependent API change. It is an assignment statement, thus the code change type is 4.","The addition of `mReversible = false;` does not affect the return value or the exception handling of the method, so it doesn't lead to a Compatibility Issue as per the provided rules. Hence, there is no Compatibility Issue."
1085,<android.print.PrintManager: void cancelPrintJob(PrintJobId)>,20,21,<android.print.PrintManager: void cancelPrintJob(PrintJobId)>,<android.print.PrintManager: void cancelPrintJob(PrintJobId)>,0,"{
    try {
        mService.cancelPrintJob(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error cancleing a print job: "" + printJobId, re);
    }
}","{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return;
    }
    try {
        mService.cancelPrintJob(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error canceling a print job: "" + printJobId, re);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,A new guard check with a log statement and a return statement are introduced outside of the existing try-catch block. So there is a control dependency change (3) with another statement added (4).,"The introduced guard check for 'mService == null' will prevent the method from proceeding if 'mService' is null, this only affects the flow but does not introduce a different return type or value, nor does it introduce any different exception handling regarding the execution path within the existing control structures. So, there is no Compatibility Issue as per the definitions provided."
1086,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,0,"{
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        clearLocked();
    }
}","{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
    }
    // If the callback is null we are destroyed.
    if (callback == null) {
        Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"");
        return;
    }
    try {
        callback.onWriteCanceled(mSequence);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error calling onWriteCanceled"", re);
    } finally {
        destroy();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The early version simply logs a message and returns if 'mDestroyed' is true within a synchronized block. On the other hand, the late version introduces several changes: the callback fetching is now outside the synchronized block, the null check for callback is done, a new try-catch block has been introduced that calls 'callback.onWriteCanceled', an 'onWriteCanceled' invocation of the callback and 'destroy' method have been added inside the try-finally block, and there's also handling of the RemoteException. Thus, there are changes in return statement (1), exception handling (2), control dependency change (3), and other changes in the code (4).","The late version can invoke a callback method and potentially throw a RemoteException, which can affect the behaviour of the method. These differences can lead to different return values (since the early version does not call 'callback.onWriteCanceled' and does not have the 'destroy' call) as well as different exception handlings (since the late version can log and handle RemoteException while the early version does not), thus causing potential Compatibility Issues in both return values or types (1) and exception handlings (2)."
1087,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList()>,20,21,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList()>,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList()>,0,"{
    List<AccessibilityServiceInfo> services = null;
    try {
        services = mService.getInstalledAccessibilityServiceList(mUserId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    return Collections.unmodifiableList(services);
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getInstalledAccessibilityServiceList(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}",1,"/**
 * Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 */
","/**
 * Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation introduces additional control flow with synchronized block and a conditional return statement that checks `service == null`, returning `Collections.emptyList()`. There is also an additional null check for the `services` variable before returning the unmodifiable list, so the change type includes 1, 3, and 4.","The new code may return `Collections.emptyList()` if `getServiceLocked()` returns null or if `services` is null after the `try-catch` block, instead of returning `Collections.unmodifiableList(services)` as in the earlier version (which could have been null). This can lead to different return values and thus constitutes a Compatibility Issue of type 1."
1091,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFailed(CharSequence)>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFailed(CharSequence)>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFailed(CharSequence)>,0,"{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        callback = mCallback;
        clearLocked();
    }
    if (callback != null) {
        try {
            callback.onWriteFailed(error, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onWriteFailed"", re);
        }
    }
}","{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
    }
    // If the callback is null we are destroyed.
    if (callback == null) {
        Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"");
        return;
    }
    try {
        callback.onWriteFailed(error, mSequence);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error calling onWriteFailed"", re);
    } finally {
        destroy();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control structure changed as the destruction check position and log condition after the synchronized block were modified, a new finally block with destroy() method call was added, and the scope of try-catch block was altered (now encapsulating the entire callback.onWriteFailed call), thus the code change types are 1, 3, 4.","Given that an early return statement was moved after the synchronized block and the finally block was added, these could potentially affect the normal flow and how exceptions are handled, which could lead to a different behavior. Thus, a Compatibility Issue of type 1 might arise due to potentially different return value as a consequence of reordering and new destruction logic."
1092,"<android.view.View: void setFlags(int,int)>",20,21,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, newVisibility);
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
                mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE_MASK) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}","{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, newVisibility);
        notifySubtreeAccessibilityStateChangedIfNeeded();
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
                mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE_MASK) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1093,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFailed(CharSequence)>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFailed(CharSequence)>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFailed(CharSequence)>,0,"{
    final ILayoutResultCallback callback;
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        callback = mCallback;
        clearLocked();
    }
    if (callback != null) {
        try {
            callback.onLayoutFailed(error, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onLayoutFailed"", re);
        }
    }
}","{
    final ILayoutResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
    }
    // If the callback is null we are destroyed.
    if (callback == null) {
        Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"");
        return;
    }
    try {
        callback.onLayoutFailed(error, mSequence);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error calling onLayoutFailed"", re);
    } finally {
        destroy();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The early version checks for `mDestroyed`, logs an error, and returns if true inside of the synchronized block and then calls `clearLocked()`. The late version removes the `mDestroyed` check and the `clearLocked()` call from within the synchronized block and instead checks if `callback` is null outside the synchronized block, logging an error and returning if it's null. Also, in the late version, `destroy()` is called inside a finally block, changes both the sequence of operations and the set of operations performed. Thus, the changes are classified as both control dependency change (3) and other statement changed (4).","There is no Compatibility Issue (CI), because the overall functionality remains the same – it checks a condition (either `mDestroyed` or if `callback` is null, which also indicates that the object might be destroyed) and logs an error before returning early. The result of `onLayoutFailed` method invocation hasn't fundamentally changed, as it still calls `callback.onLayoutFailed` if the object is not destroyed, and the same catch for `RemoteException` is still in place. Therefore, despite the changes in the implementation details, these do not lead to a different behaviour concerning returned values or thrown exceptions from the standpoint of the API's contract. Hence, the compatibility issue situation is classified as 0 (No Compatibility Issue)."
1095,<android.util.EventLog.Event: int getTag()>,20,21,<android.util.EventLog.Event: int getTag()>,<android.util.EventLog.Event: int getTag()>,0,"{
    return mBuffer.getInt(TAG_OFFSET);
}","{
    int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
    if (offset == 0) {
        offset = V1_PAYLOAD_START;
    }
    return mBuffer.getInt(offset);
}",1,"/**
 * @return the type tag code of the entry
 */
","/**
 * @return the type tag code of the entry
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the method has changed by adding new statements to calculate the `offset` and by using a different parameter inside the `getInt` call of `mBuffer`. This change in the control flow introduces a different method of computing the return value, so the code change types are 1 and 4.","The logic to determine the offset has been added, which will potentially change the actual value returned by the method, and no corresponding logic is present in the early version. This addition can lead to a different return value, therefore the CI type is 1."
1096,<android.speech.SpeechRecognizer: void destroy()>,20,21,<android.speech.SpeechRecognizer: void destroy()>,<android.speech.SpeechRecognizer: void destroy()>,0,"{
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}","{
    if (mService != null) {
        try {
            mService.cancel(mListener);
        } catch (final RemoteException e) {
        // Not important
        }
    }
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}",1,"/**
 * Destroys the {@code SpeechRecognizer} object.
 */
","/**
 * Destroys the {@code SpeechRecognizer} object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version implementation added a new block that invokes mService.cancel(mListener) surrounded by a try-catch for RemoteException. This is a new operation that does not affect the return type or exception handling because the catch block is empty. So, the change here is an Other statement change, assigned the code 4.","There is no Compatibility Issue since the return value and exception handling has not been changed even though a new operation is being performed; it won't affect the existing functionality of the API from an external perspective as the try-catch block will handle the RemoteException internally without propagating it further. Thus, the type for CI is 0."
1098,"<android.content.Intent: int fillIn(Intent,int)>",20,21,"<android.content.Intent: int fillIn(Intent,int)>","<android.content.Intent: int fillIn(Intent,int)>",0,"{
    int changes = 0;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new ArraySet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        // Only do this if mSelector is not set.
        if (mSelector == null) {
            mPackage = other.mPackage;
            changes |= FILL_IN_PACKAGE;
        }
    }
    // for the same reason as the component name.
    if (other.mSelector != null && (flags & FILL_IN_SELECTOR) != 0) {
        if (mPackage == null) {
            mSelector = new Intent(other.mSelector);
            mPackage = null;
            changes |= FILL_IN_SELECTOR;
        }
    }
    if (other.mClipData != null && (mClipData == null || (flags & FILL_IN_CLIP_DATA) != 0)) {
        mClipData = other.mClipData;
        changes |= FILL_IN_CLIP_DATA;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    return changes;
}","{
    int changes = 0;
    boolean mayHaveCopiedUris = false;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
        mayHaveCopiedUris = true;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new ArraySet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        // Only do this if mSelector is not set.
        if (mSelector == null) {
            mPackage = other.mPackage;
            changes |= FILL_IN_PACKAGE;
        }
    }
    // for the same reason as the component name.
    if (other.mSelector != null && (flags & FILL_IN_SELECTOR) != 0) {
        if (mPackage == null) {
            mSelector = new Intent(other.mSelector);
            mPackage = null;
            changes |= FILL_IN_SELECTOR;
        }
    }
    if (other.mClipData != null && (mClipData == null || (flags & FILL_IN_CLIP_DATA) != 0)) {
        mClipData = other.mClipData;
        changes |= FILL_IN_CLIP_DATA;
        mayHaveCopiedUris = true;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
            mayHaveCopiedUris = true;
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
            mayHaveCopiedUris = true;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    if (mayHaveCopiedUris && mContentUserHint == UserHandle.USER_CURRENT && other.mContentUserHint != UserHandle.USER_CURRENT) {
        mContentUserHint = other.mContentUserHint;
    }
    return changes;
}",1,"/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}.
 * <li> selector, as set by {@link #setSelector(Intent)}.
 * <li> clip data, as set by {@link #setClipData(ClipData)}.
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
 * the restriction where the corresponding field will not be replaced if
 * it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
 * is explicitly specified.  The selector will only be copied if
 * {@link #FILL_IN_SELECTOR} is explicitly specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
 * {@link #FILL_IN_SELECTOR} indicating which fields were changed.
 */
","/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}.
 * <li> selector, as set by {@link #setSelector(Intent)}.
 * <li> clip data, as set by {@link #setClipData(ClipData)}.
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
 * the restriction where the corresponding field will not be replaced if
 * it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
 * is explicitly specified.  The selector will only be copied if
 * {@link #FILL_IN_SELECTOR} is explicitly specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR} and {@link #FILL_IN_CLIP_DATA indicating which fields were
 * changed.
 */
",-1,,[@FillInFlags],-1,-1,-1,-1,-1,-1,,,,
1099,<android.app.Notification.Action: Action clone()>,20,21,<android.app.Notification.Action: Action clone()>,<android.app.Notification.Action: Action clone()>,0,"{
    return new Action(this.icon, this.title, // safe to alias
    this.actionIntent);
}","{
    return new Action(icon, title, // safe to alias
    actionIntent, new Bundle(mExtras), getRemoteInputs());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor call for `Action` class now includes additional parameters (`new Bundle(mExtras)` and `getRemoteInputs()`), and these additional parameters change the attributes of the object being returned. This indicates that the implementation of the `Action` class has been changed as well, which is why the dependent API change is also considered (5).","Because the constructor of `Action` is being called with different parameters, resulting in an object that has additional initialized fields compared to the early version, there is a potential difference in the returned object, and thus, the potential CI is related to different return values or types (1)."
1100,<android.widget.DatePicker: boolean getCalendarViewShown()>,20,21,<android.widget.DatePicker: boolean getCalendarViewShown()>,<android.widget.DatePicker: boolean getCalendarViewShown()>,0,"{
    return (mCalendarView.getVisibility() == View.VISIBLE);
}","{
    return mDelegate.getCalendarViewShown();
}",1,"/**
 * Gets whether the {@link CalendarView} is shown.
 *
 * @return True if the calendar view is shown.
 * @see #getCalendarView()
 */
","/**
 * Gets whether the {@link CalendarView} is shown.
 *
 * @return True if the calendar view is shown.
 * @see #getCalendarView()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method used to determine the return value has changed from mCalendarView.getVisibility() == View.VISIBLE to mDelegate.getCalendarViewShown(), indicating that the dependent API used has changed, so the code change type is 1,5.","Since the implementation switched from directly checking visibility to calling a delegate method that could potentially behave differently, this could lead to a different return value. Therefore, the CI type is 1."
1101,<android.app.Notification.Builder: Builder setExtras(Bundle)>,20,21,<android.app.Notification.Builder: Builder setExtras(Bundle)>,<android.app.Notification.Builder: Builder setExtras(Bundle)>,0,"{
    mExtras = bag;
    return this;
}","{
    mExtras = extras;
    return this;
}",1,"/**
 * Add metadata to this notification.
 *
 * A reference to the Bundle is held for the lifetime of this Builder, and the Bundle's
 * current contents are copied into the Notification each time {@link #build()} is
 * called.
 *
 * @see Notification#extras
 */
","/**
 * Set metadata for this notification.
 *
 * <p>A reference to the Bundle is held for the lifetime of this Builder, and the Bundle's
 * current contents are copied into the Notification each time {@link #build()} is
 * called.
 *
 * <p>Replaces any existing extras values with those from the provided Bundle.
 * Use {@link #addExtras} to merge in metadata instead.
 *
 * @see Notification#extras
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the parameter name within the method from 'bag' to 'extras'. This change doesn't alter the method's behavior; it's merely a renaming of a parameter variable, which does not affect the method's execution as variable names are not significant in terms of the logic they carry.",There is no Compatibility Issue introduced with this change since it does not affect the API's functionality or the interaction with the API's clients. The method still sets the extras and returns the same Builder object.
1103,<android.content.res.TypedArray: CharSequence[] getTextArray(int)>,20,21,<android.content.res.TypedArray: CharSequence[] getTextArray(int)>,<android.content.res.TypedArray: CharSequence[] getTextArray(int)>,0,"{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (false) {
            System.out.println(""******************************************************************"");
            System.out.println(""Got drawable resource: type="" + value.type + "" str="" + value.string + "" int=0x"" + Integer.toHexString(value.data) + "" cookie="" + value.assetCookie);
            System.out.println(""******************************************************************"");
        }
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}",1,"/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */
","/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","An early return is introduced to check for the 'mRecycled' state and to throw a RuntimeException if true; moreover, an if statement containing only debug output and no side-effects was removed. Therefore, the change types are 2 (exception handling statement changed) and 3 (control dependency change).","The addition of the early return checking 'mRecycled' introduces a new condition under which an exception is thrown. This means that clients relying on the previous behavior, which did not check this condition, may face a RuntimeException they are not expecting in version 21. Hence, CI is caused by different exception handlings (CI type 2) as well as by potentially different return values since it might never reach the end of the method and return a value (CI type 1)."
1104,<android.net.SSLCertificateSocketFactory: String[] getDefaultCipherSuites()>,20,21,<android.net.SSLCertificateSocketFactory: String[] getDefaultCipherSuites()>,<android.net.SSLCertificateSocketFactory: String[] getDefaultCipherSuites()>,0,"{
    return getDelegate().getSupportedCipherSuites();
}","{
    return getDelegate().getDefaultCipherSuites();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called on the object returned by getDelegate() has changed from getSupportedCipherSuites() to getDefaultCipherSuites(), which means that the behavior of the API could be different as it may return a different set of cipher suites. Therefore, the code change types are 1 (Return statement changed) and 5 (Dependent API changed).","There is a possibility that the two methods getSupportedCipherSuites() and getDefaultCipherSuites() could return different arrays of String, hence the API could lead to different return values depending on the underlying implementation of these methods. Thus, the CI type is 1 (Compatibility Issue caused by potential different return values)."
1105,"<android.util.SparseArray: void put(int,E)>",20,21,"<android.util.SparseArray: void put(int,E)>","<android.util.SparseArray: void put(int,E)>",0,"{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealIntArraySize(mSize + 1);
            int[] nkeys = new int[n];
            Object[] nvalues = new Object[n];
            // Log.e(""SparseArray"", ""grow "" + mKeys.length + "" to "" + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e(""SparseArray"", ""move "" + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}","{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}",1,"/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */
","/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation changes from using System.arraycopy and manual array resizing to using a helper class GrowingArrayUtils with its insert method for both mKeys and mValues. This indicates both an ""Other statement changed"" and a ""Dependent API changed"", so the code change type is 4,5.","Even though the fundamental logic of adding elements into the arrays has not changed, the refactoring to use GrowingArrayUtils methods could imply different behavior in the edge case scenarios not visible in the provided code (for example, the insert method might have additional logic which affects the end result). Therefore, there is the potential for the method to now return different outcomes, which means the CI type is 1."
1106,<android.transition.TransitionSet: TransitionSet setDuration(long)>,20,21,<android.transition.TransitionSet: TransitionSet setDuration(long)>,<android.transition.TransitionSet: TransitionSet setDuration(long)>,0,"{
    super.setDuration(duration);
    if (mDuration >= 0) {
        int numTransitions = mTransitions.size();
        for (int i = 0; i < numTransitions; ++i) {
            mTransitions.get(i).setDuration(duration);
        }
    }
    return this;
}","{
    super.setDuration(duration);
    if (mDuration >= 0 && mTransitions != null) {
        int numTransitions = mTransitions.size();
        for (int i = 0; i < numTransitions; ++i) {
            mTransitions.get(i).setDuration(duration);
        }
    }
    return this;
}",1,"/**
 * Setting a non-negative duration on a TransitionSet causes all of the child
 * transitions (current and future) to inherit this duration.
 *
 * @param duration The length of the animation, in milliseconds.
 * @return This transitionSet object.
 */
","/**
 * Setting a non-negative duration on a TransitionSet causes all of the child
 * transitions (current and future) to inherit this duration.
 *
 * @param duration The length of the animation, in milliseconds.
 * @return This transitionSet object.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The only change is the addition of null-checking (`mTransitions != null`) in the control dependency, which is type 3.","The additional null-check for `mTransitions` only adds a safety check and does not change the behavior of the API as the rest of the method implementation remains the same. Hence, no CI would arise due to this change."
1107,<android.content.SyncRequest.Builder: Builder setIgnoreSettings(boolean)>,20,21,<android.content.SyncRequest.Builder: Builder setIgnoreSettings(boolean)>,<android.content.SyncRequest.Builder: Builder setIgnoreSettings(boolean)>,0,"{
    mIgnoreSettings = ignoreSettings;
    return this;
}","{
    if (mDisallowMetered && ignoreSettings) {
        throw new IllegalArgumentException(""setIgnoreSettings(true) after having specified"" + "" sync settings with this builder."");
    }
    mIgnoreSettings = ignoreSettings;
    return this;
}",1,"/**
 * Convenience function for setting {@link ContentResolver#SYNC_EXTRAS_IGNORE_SETTINGS}.
 *
 * A sync can specify that system sync settings be ignored (user has turned sync off). Not
 * valid for periodic sync and will throw an <code>IllegalArgumentException</code> in
 * {@link #build()}.
 *
 * @param ignoreSettings true to ignore the sync automatically settings. Default false.
 */
","/**
 * Convenience function for setting {@link ContentResolver#SYNC_EXTRAS_IGNORE_SETTINGS}.
 *
 * Not valid for periodic sync and will throw an <code>IllegalArgumentException</code> in
 * {@link #build()}.
 * <p>Throws <code>IllegalArgumentException</code> if called and
 * {@link #setDisallowMetered(boolean)} has been set.
 *
 * @param ignoreSettings true to ignore the sync automatically settings. Default false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"There's an addition of a control dependency 'if' statement that throws a new exception. So the code change type is 2,3.","The late version introduces a possible new exception ('IllegalArgumentException') that wasn't present earlier, resulting in a different exception being potentially thrown when the condition is met. Hence the CI type is 2."
1108,"<android.app.ApplicationPackageManager: XmlResourceParser getXml(String,int,ApplicationInfo)>",20,21,"<android.app.ApplicationPackageManager: XmlResourceParser getXml(String,int,ApplicationInfo)>","<android.app.ApplicationPackageManager: XmlResourceParser getXml(String,int,ApplicationInfo)>",0,"{
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, 0);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    try {
        Resources r = getResourcesForApplication(appInfo);
        return r.getXml(resid);
    } catch (RuntimeException e) {
        // If an exception was thrown, fall through to return
        // default icon.
        Log.w(""PackageManager"", ""Failure retrieving xml 0x"" + Integer.toHexString(resid) + "" in package "" + packageName, e);
    } catch (NameNotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for "" + appInfo.packageName);
    }
    return null;
}","{
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, sDefaultFlags);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    try {
        Resources r = getResourcesForApplication(appInfo);
        return r.getXml(resid);
    } catch (RuntimeException e) {
        // If an exception was thrown, fall through to return
        // default icon.
        Log.w(""PackageManager"", ""Failure retrieving xml 0x"" + Integer.toHexString(resid) + "" in package "" + packageName, e);
    } catch (NameNotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for "" + appInfo.packageName);
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method call getApplicationInfo(packageName, 0) has been changed to getApplicationInfo(packageName, sDefaultFlags). Since the parameter to this dependent API call has changed, the change type is 5.","However, changing the flags for retrieving application info does not necessarily indicate a compatibility issue. The rest of the method's behavior remains the same, including the handling of the NameNotFoundException and the return values. Therefore, unless the difference in flags changes the behavior of getApplicationInfo in a way that would cause this method to return a different XmlResourceParser or throw a different exception than before, there is no compatibility issue. There's no indication in the given context that the behavior of getApplicationInfo has been altered in such a way, so CI is classified as 0."
1110,"<android.os.MessageQueue: void removeMessages(Handler,int,Object)>",20,21,"<android.os.MessageQueue: void removeMessages(Handler,int,Object)>","<android.os.MessageQueue: void removeMessages(Handler,int,Object)>",0,"{
    if (h == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && p.what == what && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycle();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && n.what == what && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycle();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}","{
    if (h == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && p.what == what && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycleUnchecked();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && n.what == what && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycleUnchecked();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method ""recycle()"" has been replaced with ""recycleUnchecked()"" inside the while loops, indicating a change in the dependent API being used, so the code change type is 4,5.","The change from ""recycle()"" to ""recycleUnchecked()"" in itself doesn’t suggest a behavior change that would affect what values are returned or what exceptions might be thrown by the ""removeMessages"" method. Therefore, the CI type is 0, implying there is no compatibility issue related to return values or exception handling."
1111,"<android.util.Log: int wtf(String,String)>",20,21,"<android.util.Log: int wtf(String,String)>","<android.util.Log: int wtf(String,String)>",0,"{
    return wtf(LOG_ID_MAIN, tag, msg, null, false);
}","{
    return wtf(LOG_ID_MAIN, tag, msg, null, false, false);
}",1,"/**
 * What a Terrible Failure: Report a condition that should never happen.
 * The error will always be logged at level ASSERT with the call stack.
 * Depending on system configuration, a report may be added to the
 * {@link android.os.DropBoxManager} and/or the process may be terminated
 * immediately with an error dialog.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 */
","/**
 * What a Terrible Failure: Report a condition that should never happen.
 * The error will always be logged at level ASSERT with the call stack.
 * Depending on system configuration, a report may be added to the
 * {@link android.os.DropBoxManager} and/or the process may be terminated
 * immediately with an error dialog.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The call to the wtf() function has been changed to include an additional parameter, which indicates that a dependent API has changed, hence the code change type is 5.","Although the dependent API wtf() has an additional parameter in its signature, this does not inherently suggest a potential Compatibility Issue, as the change does not indicate that the behavior of the API will differ in terms of its return value or exception handling. Therefore, the CI type is 0."
1113,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,20,21,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,0,"{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSE(request);
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleSPSE(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (DEBUG)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSEOrSPSE(request, ""Method"");
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleMPSEOrSPSE(request, ""Sample"");
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There's a condition checking change from 'if (false)' to 'if (DEBUG)', and the handling for CHUNK_MPSE has been updated to use handleMPSEOrSPSE(request, ""Method"") instead of handleMPSE(request). The CHUNK_SPSE also calls a shared implementation with a different argument (""Sample""). These are changes under control statements and other statement changes, so the change type is 3,4.","Since logging changes and adding an argument to a method call (while not changing the method signature) do not affect the behavior visible to the API consumers, and the exception thrown for unrecognized request types remains the same, there is no Compatibility Issue that would affect the API caller. The method still returns a Chunk object based on the request type, and the conditions for method selection are still the same. The underlying implementation details changed, but not in a way that would introduce a Compatibility Issue. Thus, the CI type is 0."
1115,"<android.content.res.TypedArray: boolean getBoolean(int,boolean)>",20,21,"<android.content.res.TypedArray: boolean getBoolean(int,boolean)>","<android.content.res.TypedArray: boolean getBoolean(int,boolean)>",0,"{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to boolean: "" + v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, ""getBoolean of bad type: 0x"" + Integer.toHexString(type));
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to boolean: "" + v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, ""getBoolean of bad type: 0x"" + Integer.toHexString(type));
    return defValue;
}",1,"/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute boolean value, or defValue if not defined.
 */
","/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute boolean value, or defValue if not defined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The addition of a new exception handling statement that throws `RuntimeException` if `mRecycled` is true, and the new condition check of `mRecycled` before the rest of the method logic are the changes in the code, so the change type is 2,3.","The introduction of a check that throws an exception could lead to different exception handling behavior because earlier implementations would not have thrown this exception. Thus, the CI type is 2."
1116,<android.app.Activity: MenuInflater getMenuInflater()>,20,21,<android.app.Activity: MenuInflater getMenuInflater()>,<android.app.Activity: MenuInflater getMenuInflater()>,0,"{
    // Make sure that action views can get an appropriate theme.
    if (mMenuInflater == null) {
        initActionBar();
        if (mActionBar != null) {
            mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
        } else {
            mMenuInflater = new MenuInflater(this);
        }
    }
    return mMenuInflater;
}","{
    // Make sure that action views can get an appropriate theme.
    if (mMenuInflater == null) {
        initWindowDecorActionBar();
        if (mActionBar != null) {
            mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
        } else {
            mMenuInflater = new MenuInflater(this);
        }
    }
    return mMenuInflater;
}",1,"/**
 * Returns a {@link MenuInflater} with this context.
 */
","/**
 * Returns a {@link MenuInflater} with this context.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method name changed from 'initActionBar()' to 'initWindowDecorActionBar()'. There is also a change from no annotation to ""@NonNull"" annotation. The code change is 4 due to the method name change and 5 because it relies on a different (potentially changed) method.","The return statement has not changed, and the exception handling has not changed. Neither of these changes affects what the getMenuInflater() method returns nor the exceptions it may throw. The behavior of the method will be the same if 'initWindowDecorActionBar()' has the same side effects as 'initActionBar()’. Therefore, there is no compatibility issue, hence pred_CI is 0."
1117,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",20,21,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>","<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",0,"{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}","{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }
            return mParent;
        }
    }
    return null;
}",1,"/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
","/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement `mLocalDirtyRect.union(dirty);` has been removed in the late version, so the change type is 4.","The removal of `mLocalDirtyRect.union(dirty);` does not cause a compatibility issue because the method's return type, the exceptions it may throw, the return values, and the conditions under which they're returned have not changed. It seems to be a modification in internal state management which does not impact the API's external behavior, hence, no compatibility issue is expected."
1119,<android.view.accessibility.AccessibilityEvent: String toString()>,20,21,<android.view.accessibility.AccessibilityEvent: String toString()>,<android.view.accessibility.AccessibilityEvent: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; ContentChangeTypes: "").append(mContentChangeTypes);
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; mSourceNodeId: "").append(mSourceNodeId);
        for (int i = 0; i < mRecords.size(); i++) {
            AccessibilityRecord record = mRecords.get(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; ContentChangeTypes: "").append(mContentChangeTypes);
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; mSourceNodeId: "").append(mSourceNodeId);
        for (int i = 0; i < getRecordCount(); i++) {
            final AccessibilityRecord record = getRecord(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,There are two changes in the late version implementation:,"These imply a change in how record count and record retrieval are performed, points to a change in dependent API, and fall under Other statement changed."
1121,<android.widget.RemoteViewsAdapter.RemoteViewsCacheKey: int hashCode()>,20,21,<android.widget.RemoteViewsAdapter.RemoteViewsCacheKey: int hashCode()>,<android.widget.RemoteViewsAdapter.RemoteViewsCacheKey: int hashCode()>,0,"{
    return (filter == null ? 0 : filter.hashCode()) ^ (widgetId << 2) ^ (userId << 10);
}","{
    return (filter == null ? 0 : filter.hashCode()) ^ (widgetId << 2);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has lost the part where userId is shifted left by 10 and XORed, so there's a change in the calculation of the hash code, which is the type 1 change.","The change in the hash code computation means that the API will potentially return different values between versions 20 and 21, thus there's a Compatibility Issue of type 1 due to potential different return values."
1122,<android.text.format.Time: boolean parse3339(String)>,20,21,<android.text.format.Time: boolean parse3339(String)>,<android.text.format.Time: boolean parse3339(String)>,0,"{
    if (s == null) {
        throw new NullPointerException(""time string is null"");
    }
    if (nativeParse3339(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}","{
    if (s == null) {
        throw new NullPointerException(""time string is null"");
    }
    if (parse3339Internal(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}",1,"/**
 * Parse a time in RFC 3339 format.  This method also parses simple dates
 * (that is, strings that contain no time or time offset).  For example,
 * all of the following strings are valid:
 *
 * <ul>
 * <li>""2008-10-13T16:00:00.000Z""</li>
 * <li>""2008-10-13T16:00:00.000+07:00""</li>
 * <li>""2008-10-13T16:00:00.000-07:00""</li>
 * <li>""2008-10-13""</li>
 * </ul>
 *
 * <p>
 * If the string contains a time and time offset, then the time offset will
 * be used to convert the time value to UTC.
 * </p>
 *
 * <p>
 * If the given string contains just a date (with no time field), then
 * the {@link #allDay} field is set to true and the {@link #hour},
 * {@link #minute}, and  {@link #second} fields are set to zero.
 * </p>
 *
 * <p>
 * Returns true if the resulting time value is in UTC time.
 * </p>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */
","/**
 * Parse a time in RFC 3339 format.  This method also parses simple dates
 * (that is, strings that contain no time or time offset).  For example,
 * all of the following strings are valid:
 *
 * <ul>
 * <li>""2008-10-13T16:00:00.000Z""</li>
 * <li>""2008-10-13T16:00:00.000+07:00""</li>
 * <li>""2008-10-13T16:00:00.000-07:00""</li>
 * <li>""2008-10-13""</li>
 * </ul>
 *
 * <p>
 * If the string contains a time and time offset, then the time offset will
 * be used to convert the time value to UTC.
 * </p>
 *
 * <p>
 * If the given string contains just a date (with no time field), then
 * the {@link #allDay} field is set to true and the {@link #hour},
 * {@link #minute}, and  {@link #second} fields are set to zero.
 * </p>
 *
 * <p>
 * Returns true if the resulting time value is in UTC time.
 * </p>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has been changed from calling nativeParse3339(s) to parse3339Internal(s) which reflects a change in a dependent API, it's also a change in other statements since the actual method being called has changed. Therefore, the code change types are 4 and 5.","Since the method parse3339Internal is an internal method and the logic of the function is not provided for us to analyze whether the behavior of parsing has changed, we cannot assume it leads to a compatibility issue based only on the method's name. As the exception handling and return statements remain the same and without the explicit evidence of behavioral change, we classify it as no compatibility issue (0)."
1123,<android.view.ViewGroup.ViewLocationHolder: int compareTo(ViewLocationHolder)>,20,21,<android.view.ViewGroup.ViewLocationHolder: int compareTo(ViewLocationHolder)>,<android.view.ViewGroup.ViewLocationHolder: int compareTo(ViewLocationHolder)>,0,"{
    // This instance is greater than an invalid argument.
    if (another == null) {
        return 1;
    }
    if (getClass() != another.getClass()) {
        return 1;
    }
    // First is above second.
    if (mLocation.bottom - another.mLocation.top <= 0) {
        return -1;
    }
    // First is below second.
    if (mLocation.top - another.mLocation.bottom >= 0) {
        return 1;
    }
    // LTR
    if (mLayoutDirection == LAYOUT_DIRECTION_LTR) {
        final int leftDifference = mLocation.left - another.mLocation.left;
        // First more to the left than second.
        if (leftDifference != 0) {
            return leftDifference;
        }
    } else {
        // RTL
        final int rightDifference = mLocation.right - another.mLocation.right;
        // First more to the right than second.
        if (rightDifference != 0) {
            return -rightDifference;
        }
    }
    // Break tie by top.
    final int topDiference = mLocation.top - another.mLocation.top;
    if (topDiference != 0) {
        return topDiference;
    }
    // Break tie by height.
    final int heightDiference = mLocation.height() - another.mLocation.height();
    if (heightDiference != 0) {
        return -heightDiference;
    }
    // Break tie by width.
    final int widthDiference = mLocation.width() - another.mLocation.width();
    if (widthDiference != 0) {
        return -widthDiference;
    }
    // and stable, hence this is deterministic tie breaking.
    return mView.getAccessibilityViewId() - another.mView.getAccessibilityViewId();
}","{
    // This instance is greater than an invalid argument.
    if (another == null) {
        return 1;
    }
    if (sComparisonStrategy == COMPARISON_STRATEGY_STRIPE) {
        // First is above second.
        if (mLocation.bottom - another.mLocation.top <= 0) {
            return -1;
        }
        // First is below second.
        if (mLocation.top - another.mLocation.bottom >= 0) {
            return 1;
        }
    }
    // We are ordering left-to-right, top-to-bottom.
    if (mLayoutDirection == LAYOUT_DIRECTION_LTR) {
        final int leftDifference = mLocation.left - another.mLocation.left;
        if (leftDifference != 0) {
            return leftDifference;
        }
    } else {
        // RTL
        final int rightDifference = mLocation.right - another.mLocation.right;
        if (rightDifference != 0) {
            return -rightDifference;
        }
    }
    // We are ordering left-to-right, top-to-bottom.
    final int topDifference = mLocation.top - another.mLocation.top;
    if (topDifference != 0) {
        return topDifference;
    }
    // Break tie by height.
    final int heightDiference = mLocation.height() - another.mLocation.height();
    if (heightDiference != 0) {
        return -heightDiference;
    }
    // Break tie by width.
    final int widthDiference = mLocation.width() - another.mLocation.width();
    if (widthDiference != 0) {
        return -widthDiference;
    }
    // and stable, hence this is deterministic tie breaking.
    return mView.getAccessibilityViewId() - another.mView.getAccessibilityViewId();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The condition statement checking `getClass() != another.getClass()` has been removed, and the control dependency based on the new static field `sComparisonStrategy == COMPARISON_STRATEGY_STRIPE` has been added. So, the change types are 3 and 4.","Since a class type check has been removed, instances of different classes that were previously considered incomparable could now potentially be compared, possibly resulting in a different value being returned by the `compareTo` method. Additionally, the comparison strategy based on a new static field could alter the behavior of the method when comparing objects, thus the CI type is 1."
1125,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,20,21,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,0,"{
    return getInstalledProviders(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);
}","{
    if (mService == null) {
        return Collections.emptyList();
    }
    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, null);
}",1,"/**
 * Return a list of the AppWidget providers that are currently installed.
 */
","/**
 * Return a list of the AppWidget providers that are currently installed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method now includes a control dependency change as it introduces an 'if' condition which results in a new return statement, `return Collections.emptyList()`. Moreover, the late version code calls a new API `getInstalledProvidersForProfile()` instead of `getInstalledProviders()` from the early version. Hence, the code change types are 1,3,5.","The presence of new control logic and a new return statement when `mService` is null could lead the method to return an empty list, which is a different behavior from the earlier version that always returned a result from `getInstalledProviders()`. Furthermore, the change from `getInstalledProviders()` to `getInstalledProvidersForProfile()` could result in a different return value as well. Therefore, the CI type due to different return values is 1."
1126,<android.app.ActivityOptions: void update(ActivityOptions)>,20,21,<android.app.ActivityOptions: void update(ActivityOptions)>,<android.app.ActivityOptions: void update(ActivityOptions)>,0,"{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mAnimationType = otherOptions.mAnimationType;
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mAnimationType = otherOptions.mAnimationType;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mStartWidth = otherOptions.mStartWidth;
            mStartHeight = otherOptions.mStartHeight;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
            mAnimationType = otherOptions.mAnimationType;
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
    }
}","{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}",1,"/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
","/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late implementation introduces new assignments before the switch statement and within the switch branches (e.g., mWidth, mHeight). Additionally, cases 'ANIM_THUMBNAIL_ASPECT_SCALE_UP' and 'ANIM_THUMBNAIL_ASPECT_SCALE_DOWN' have been added to the switch, and 'ANIM_SCENE_TRANSITION' has new assignments. Despite these changes, there is no return statement or exception handling alteration, so the change types are 3 and 4.","No Compatibility Issue arises from these changes because the method return type is void and the method's implementation change does not affect the type of value that would be returned (which is none in this case). Thus, there is no difference in exceptions thrown or return values/types."
1127,<android.widget.RemoteViews: String getPackage()>,20,21,<android.widget.RemoteViews: String getPackage()>,<android.widget.RemoteViews: String getPackage()>,0,"{
    return mPackage;
}","{
    return (mApplication != null) ? mApplication.packageName : null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has been altered to return the package name from a different source (mApplication.packageName instead of directly from mPackage), and this may involve accessing a different field and object reference; thus the code change types are 1 and 5.","Since the method now retrieves the package name from a different object (mApplication) and thus potentially from a different source, this can lead to a different return value. Particularly, if mApplication is null, the previous version would return the value of mPackage while the new version would return null. This change in the source of the returned value could result in a different behavior for clients depending on this API; hence, the CI type is 1."
1129,"<android.speech.tts.FileSynthesisCallback: int audioAvailable(byte[],int,int)>",20,21,"<android.speech.tts.FileSynthesisCallback: int audioAvailable(byte[],int,int)>","<android.speech.tts.FileSynthesisCallback: int audioAvailable(byte[],int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.audioAvailable("" + buffer + "","" + offset + "","" + length + "")"");
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            mFileChannel.write(ByteBuffer.wrap(buffer, offset, length));
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to output file descriptor"", ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}","{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.audioAvailable("" + buffer + "","" + offset + "","" + length + "")"");
    }
    FileChannel fileChannel = null;
    synchronized (mStateLock) {
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (!mStarted) {
            Log.e(TAG, ""Start method was not called"");
            return TextToSpeech.ERROR;
        }
        fileChannel = mFileChannel;
    }
    try {
        fileChannel.write(ByteBuffer.wrap(buffer, offset, length));
        return TextToSpeech.SUCCESS;
    } catch (IOException ex) {
        Log.e(TAG, ""Failed to write to output file descriptor"", ex);
        synchronized (mStateLock) {
            cleanUp();
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
        }
        return TextToSpeech.ERROR;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",Changes in the implementation include:,"- Additional error checking (if `mStarted` is false, return `TextToSpeech.ERROR`), which results in altered control dependencies."
1130,<android.view.View: float getCameraDistance()>,20,21,<android.view.View: float getCameraDistance()>,<android.view.View: float getCameraDistance()>,0,"{
    ensureTransformationInfo();
    final float dpi = mResources.getDisplayMetrics().densityDpi;
    final TransformationInfo info = mTransformationInfo;
    if (info.mCamera == null) {
        info.mCamera = new Camera();
        info.matrix3D = new Matrix();
    }
    return -(info.mCamera.getLocationZ() * dpi);
}","{
    final float dpi = mResources.getDisplayMetrics().densityDpi;
    return -(mRenderNode.getCameraDistance() * dpi);
}",1,"/**
 * Gets the distance along the Z axis from the camera to this view.
 *
 * @see #setCameraDistance(float)
 *
 * @return The distance along the Z axis.
 */
","/**
 * Gets the distance along the Z axis from the camera to this view.
 *
 * @see #setCameraDistance(float)
 *
 * @return The distance along the Z axis.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The return statement has changed from using a custom camera calculation to using mRenderNode.getCameraDistance(). This constitutes a change in the return statement (1) and also in the dependent API (5).,"As the method now relies on mRenderNode.getCameraDistance() instead of the previous custom camera ""info.mCamera"", the returned value may be different, leading to a Compatibility Issue of type 1 (different return values or types)."
1131,<android.widget.TimePicker: void setEnabled(boolean)>,20,21,<android.widget.TimePicker: void setEnabled(boolean)>,<android.widget.TimePicker: void setEnabled(boolean)>,0,"{
    if (mIsEnabled == enabled) {
        return;
    }
    super.setEnabled(enabled);
    mMinuteSpinner.setEnabled(enabled);
    if (mDivider != null) {
        mDivider.setEnabled(enabled);
    }
    mHourSpinner.setEnabled(enabled);
    if (mAmPmSpinner != null) {
        mAmPmSpinner.setEnabled(enabled);
    } else {
        mAmPmButton.setEnabled(enabled);
    }
    mIsEnabled = enabled;
}","{
    super.setEnabled(enabled);
    mDelegate.setEnabled(enabled);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change involved removing multiple conditional checks and function calls on internal members, replacing them with a single call to a delegate's setEnabled method. Therefore, the change is of type 4.","However, despite the significant simplification of the code, if the mDelegate.setEnabled(enabled) internally also sets the state of the same UI elements that were individually listed in the early version, then from an external behavior standpoint, this change would not necessarily cause a compatibility issue. Thus, the CI type is 0."
1132,<android.view.View: boolean onHoverEvent(MotionEvent)>,20,21,<android.view.View: boolean onHoverEvent(MotionEvent)>,<android.view.View: boolean onHoverEvent(MotionEvent)>,0,"{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
            // focus as soon as the user stop hovering over the view.
            if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
                getViewRootImpl().setAccessibilityFocus(null, null);
            }
        }
    }
    if (isHoverable()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        // return true.
        return true;
    }
    return false;
}","{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
        }
    }
    if (isHoverable()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        // return true.
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
","/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The change in code is the deletion of the following block:,if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
1133,<android.animation.Keyframe.ObjectKeyframe: ObjectKeyframe clone()>,20,21,<android.animation.Keyframe.ObjectKeyframe: ObjectKeyframe clone()>,<android.animation.Keyframe.ObjectKeyframe: ObjectKeyframe clone()>,0,"{
    ObjectKeyframe kfClone = new ObjectKeyframe(getFraction(), mHasValue ? mValue : null);
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}","{
    ObjectKeyframe kfClone = new ObjectKeyframe(getFraction(), hasValue() ? mValue : null);
    kfClone.mValueWasSetOnStart = mValueWasSetOnStart;
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An assignment statement has been added in the late version (kfClone.mValueWasSetOnStart = mValueWasSetOnStart), which is not related to the return statement or exception handling, and no control structures have been modified in a way that would affect the behavior. Therefore, the change type is 4.","The assignment added to the late version does not alter the return value or exception handling of the method, so there is no Compatibility Issue; the type is 0."
1134,<android.net.LocalSocketImpl: void close()>,20,21,<android.net.LocalSocketImpl: void close()>,<android.net.LocalSocketImpl: void close()>,0,"{
    synchronized (LocalSocketImpl.this) {
        if ((fd == null) || (mFdCreatedInternally == false)) {
            fd = null;
            return;
        }
        try {
            Libcore.os.close(fd);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        fd = null;
    }
}","{
    synchronized (LocalSocketImpl.this) {
        if ((fd == null) || (mFdCreatedInternally == false)) {
            fd = null;
            return;
        }
        try {
            Os.close(fd);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        fd = null;
    }
}",1,"/**
 * Closes the socket.
 *
 * @throws IOException
 */
","/**
 * Closes the socket.
 *
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed in the way it calls the close method on the file descriptor: it uses Os.close(fd) instead of Libcore.os.close(fd). The Os class is probably a wrapper or an alias for the functionality in Libcore.os, so the code change is of type 5 (Dependent API changed).","There is no Compatibility Issue because the change from Libcore.os.close(fd) to Os.close(fd) does not inherently affect the behavior of the close() method. The functionality should remain the same as long as the Os.close method performs the same action as Libcore.os.close used to perform. Therefore, the change does not lead to different values being returned or exceptions being thrown, given the same inputs."
1136,"<android.widget.CalendarView: void setDate(long,boolean,boolean)>",20,21,"<android.widget.CalendarView: void setDate(long,boolean,boolean)>","<android.widget.CalendarView: void setDate(long,boolean,boolean)>",0,"{
    mTempDate.setTimeInMillis(date);
    if (isSameDate(mTempDate, mAdapter.mSelectedDate)) {
        return;
    }
    goTo(mTempDate, animate, true, center);
}","{
    mDelegate.setDate(date, animate, center);
}",1,"/**
 * Sets the selected date in milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param date The date.
 * @param animate Whether to animate the scroll to the current date.
 * @param center Whether to center the current date even if it is already visible.
 *
 * @throws IllegalArgumentException of the provided date is before the
 * minimal or after the maximal date.
 *
 * @see #setMinDate(long)
 * @see #setMaxDate(long)
 */
","/**
 * Sets the selected date in milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param date The date.
 * @param animate Whether to animate the scroll to the current date.
 * @param center Whether to center the current date even if it is already visible.
 *
 * @throws IllegalArgumentException of the provided date is before the
 * minimal or after the maximal date.
 *
 * @see #setMinDate(long)
 * @see #setMaxDate(long)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The internal implementation of the method has been entirely changed from direct internal logic to delegation to another component via mDelegate.setDate(date, animate, center); Also, there is no direct correspondence to the previous logic, which suggests a Dependent API change. Therefore, the code change type is 4,5.","Since the entire method implementation has changed and it now delegates the action to a different API, there is a potential for different return behavior or side effects. This could result in a Compatibility Issue of type 1, where the method potentially returns different results or behaves differently due to the internal logic change."
1138,"<android.text.SpannableStringBuilder: int getTextRunCursor(int,int,int,int,int,Paint)>",20,21,"<android.text.SpannableStringBuilder: int getTextRunCursor(int,int,int,int,int,Paint)>","<android.text.SpannableStringBuilder: int getTextRunCursor(int,int,int,int,int,Paint)>",0,"{
    int ret;
    int contextLen = contextEnd - contextStart;
    if (contextEnd <= mGapStart) {
        ret = p.getTextRunCursor(mText, contextStart, contextLen, flags, offset, cursorOpt);
    } else if (contextStart >= mGapStart) {
        ret = p.getTextRunCursor(mText, contextStart + mGapLength, contextLen, flags, offset + mGapLength, cursorOpt) - mGapLength;
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        ret = p.getTextRunCursor(buf, 0, contextLen, flags, offset - contextStart, cursorOpt) + contextStart;
        TextUtils.recycle(buf);
    }
    return ret;
}","{
    int ret;
    int contextLen = contextEnd - contextStart;
    if (contextEnd <= mGapStart) {
        ret = p.getTextRunCursor(mText, contextStart, contextLen, dir, offset, cursorOpt);
    } else if (contextStart >= mGapStart) {
        ret = p.getTextRunCursor(mText, contextStart + mGapLength, contextLen, dir, offset + mGapLength, cursorOpt) - mGapLength;
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        ret = p.getTextRunCursor(buf, 0, contextLen, dir, offset - contextStart, cursorOpt) + contextStart;
        TextUtils.recycle(buf);
    }
    return ret;
}",1,"/**
 * Returns the next cursor position in the run.  This avoids placing the cursor between
 * surrogates, between characters that form conjuncts, between base characters and combining
 * marks, or within a reordering cluster.
 *
 * <p>The context is the shaping context for cursor movement, generally the bounds of the metric
 * span enclosing the cursor in the direction of movement.
 * <code>contextStart</code>, <code>contextEnd</code> and <code>offset</code> are relative to
 * the start of the string.</p>
 *
 * <p>If cursorOpt is CURSOR_AT and the offset is not a valid cursor position,
 * this returns -1.  Otherwise this will never return a value before contextStart or after
 * contextEnd.</p>
 *
 * @param contextStart the start index of the context
 * @param contextEnd the (non-inclusive) end index of the context
 * @param flags either DIRECTION_RTL or DIRECTION_LTR
 * @param offset the cursor position to move from
 * @param cursorOpt how to move the cursor, one of CURSOR_AFTER,
 * CURSOR_AT_OR_AFTER, CURSOR_BEFORE,
 * CURSOR_AT_OR_BEFORE, or CURSOR_AT
 * @param p the Paint object that is requesting this information
 * @return the offset of the next position, or -1
 * @deprecated This is an internal method, refrain from using it in your code
 */
","/**
 * Returns the next cursor position in the run.  This avoids placing the cursor between
 * surrogates, between characters that form conjuncts, between base characters and combining
 * marks, or within a reordering cluster.
 *
 * <p>The context is the shaping context for cursor movement, generally the bounds of the metric
 * span enclosing the cursor in the direction of movement.
 * <code>contextStart</code>, <code>contextEnd</code> and <code>offset</code> are relative to
 * the start of the string.</p>
 *
 * <p>If cursorOpt is CURSOR_AT and the offset is not a valid cursor position,
 * this returns -1.  Otherwise this will never return a value before contextStart or after
 * contextEnd.</p>
 *
 * @param contextStart the start index of the context
 * @param contextEnd the (non-inclusive) end index of the context
 * @param dir either DIRECTION_RTL or DIRECTION_LTR
 * @param offset the cursor position to move from
 * @param cursorOpt how to move the cursor, one of CURSOR_AFTER,
 * CURSOR_AT_OR_AFTER, CURSOR_BEFORE,
 * CURSOR_AT_OR_BEFORE, or CURSOR_AT
 * @param p the Paint object that is requesting this information
 * @return the offset of the next position, or -1
 * @deprecated This is an internal method, refrain from using it in your code
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the replacement of the variable 'flags' with 'dir' in the parameter list of the method getTextRunCursor. Since 'flags' and 'dir' are simply parameter names, this change seems to denote a variable rename rather than a change in behavior of the method itself. Additionally, since there is no definition change of getTextRunCursor method in the dependent API indicating that the semantics of these parameters have changed, this should not affect the way the method operates or the values it returns.",There is no Compatibility Issue as the change is a simple rename of a variable that does not affect the external behavior of the API. The method's logic and return value remain unaffected by such an internal change.
1140,<android.app.Fragment: void instantiateChildFragmentManager()>,20,21,<android.app.Fragment: void instantiateChildFragmentManager()>,<android.app.Fragment: void instantiateChildFragmentManager()>,0,"{
    mChildFragmentManager = new FragmentManagerImpl();
    mChildFragmentManager.attachActivity(mActivity, new FragmentContainer() {

        @Override
        public View findViewById(int id) {
            if (mView == null) {
                throw new IllegalStateException(""Fragment does not have a view"");
            }
            return mView.findViewById(id);
        }
    }, this);
}","{
    mChildFragmentManager = new FragmentManagerImpl();
    mChildFragmentManager.attachActivity(mActivity, new FragmentContainer() {

        @Override
        public View findViewById(int id) {
            if (mView == null) {
                throw new IllegalStateException(""Fragment does not have a view"");
            }
            return mView.findViewById(id);
        }

        @Override
        public boolean hasView() {
            return (mView != null);
        }
    }, this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is a new method `hasView` added inside the anonymous `FragmentContainer` class, which does not alter the existing method's execution or outcome. Thus the code change type is 4 (Other statement changed).","The added method `hasView` within the `FragmentContainer` does not change the behavior of the `instantiateChildFragmentManager` method nor affects its control flow, hence there is no compatibility issue arising from this change."
1143,<android.widget.ProgressBar: void onDraw(Canvas)>,20,21,<android.widget.ProgressBar: void onDraw(Canvas)>,<android.widget.ProgressBar: void onDraw(Canvas)>,0,"{
    super.onDraw(canvas);
    Drawable d = mCurrentDrawable;
    if (d != null) {
        // Translate canvas so a indeterminate circular progress bar with padding
        // rotates properly in its animation
        canvas.save();
        if (isLayoutRtl() && mMirrorForRtl) {
            canvas.translate(getWidth() - mPaddingRight, mPaddingTop);
            canvas.scale(-1.0f, 1.0f);
        } else {
            canvas.translate(mPaddingLeft, mPaddingTop);
        }
        long time = getDrawingTime();
        if (mHasAnimation) {
            mAnimation.getTransformation(time, mTransformation);
            float scale = mTransformation.getAlpha();
            try {
                mInDrawing = true;
                d.setLevel((int) (scale * MAX_LEVEL));
            } finally {
                mInDrawing = false;
            }
            postInvalidateOnAnimation();
        }
        d.draw(canvas);
        canvas.restore();
        if (mShouldStartAnimationDrawable && d instanceof Animatable) {
            ((Animatable) d).start();
            mShouldStartAnimationDrawable = false;
        }
    }
}","{
    super.onDraw(canvas);
    drawTrack(canvas);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The whole body of the method has changed significantly. The early implementation includes a lot of logic, conditionals, and calls to other methods and classes like Drawable, Canvas, etc., but the late implementation has been reduced to just two method calls: super.onDraw(canvas) and drawTrack(canvas). So, the code change types are 1 for the complete change in logic and return statements and 4 for other statements changed as the majority of the codebase has been refactored.","The new implementation of the method does not retain the previous functionality, such as drawing handling, scaling, animation, and invalidation logic, which means that the method will have a significantly different behavior that can lead to different visuals rendered on the screen. Therefore, the CI type is 1 due to potential different return values as the method affects the output rendered onto the canvas."
1144,<android.view.View: void sendAccessibilityEvent(int)>,20,21,<android.view.View: void sendAccessibilityEvent(int)>,<android.view.View: void sendAccessibilityEvent(int)>,0,"{
    // Excluded views do not send accessibility events.
    if (!includeForAccessibility()) {
        return;
    }
    if (mAccessibilityDelegate != null) {
        mAccessibilityDelegate.sendAccessibilityEvent(this, eventType);
    } else {
        sendAccessibilityEventInternal(eventType);
    }
}","{
    if (mAccessibilityDelegate != null) {
        mAccessibilityDelegate.sendAccessibilityEvent(this, eventType);
    } else {
        sendAccessibilityEventInternal(eventType);
    }
}",1,"/**
 * Sends an accessibility event of the given type. If accessibility is
 * not enabled this method has no effect. The default implementation calls
 * {@link #onInitializeAccessibilityEvent(AccessibilityEvent)} first
 * to populate information about the event source (this View), then calls
 * {@link #dispatchPopulateAccessibilityEvent(AccessibilityEvent)} to
 * populate the text content of the event source including its descendants,
 * and last calls
 * {@link ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * on its parent to resuest sending of the event to interested parties.
 * <p>
 * If an {@link AccessibilityDelegate} has been specified via calling
 * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
 * {@link AccessibilityDelegate#sendAccessibilityEvent(View, int)} is
 * responsible for handling this call.
 * </p>
 *
 * @param eventType The type of the event to send, as defined by several types from
 * {@link android.view.accessibility.AccessibilityEvent}, such as
 * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_CLICKED} or
 * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_HOVER_ENTER}.
 *
 * @see #onInitializeAccessibilityEvent(AccessibilityEvent)
 * @see #dispatchPopulateAccessibilityEvent(AccessibilityEvent)
 * @see ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)
 * @see AccessibilityDelegate
 */
","/**
 * Sends an accessibility event of the given type. If accessibility is
 * not enabled this method has no effect. The default implementation calls
 * {@link #onInitializeAccessibilityEvent(AccessibilityEvent)} first
 * to populate information about the event source (this View), then calls
 * {@link #dispatchPopulateAccessibilityEvent(AccessibilityEvent)} to
 * populate the text content of the event source including its descendants,
 * and last calls
 * {@link ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * on its parent to resuest sending of the event to interested parties.
 * <p>
 * If an {@link AccessibilityDelegate} has been specified via calling
 * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
 * {@link AccessibilityDelegate#sendAccessibilityEvent(View, int)} is
 * responsible for handling this call.
 * </p>
 *
 * @param eventType The type of the event to send, as defined by several types from
 * {@link android.view.accessibility.AccessibilityEvent}, such as
 * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_CLICKED} or
 * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_HOVER_ENTER}.
 *
 * @see #onInitializeAccessibilityEvent(AccessibilityEvent)
 * @see #dispatchPopulateAccessibilityEvent(AccessibilityEvent)
 * @see ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)
 * @see AccessibilityDelegate
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition check `if (!includeForAccessibility())` has been removed, so there is a control dependency change (3).","Although there is a control change, the removal of this condition does not result in a CI as it only affects whether to proceed further with the method execution or not; it does not change the resulting behavior if the view is included for accessibility. The method still delegates to `mAccessibilityDelegate.sendAccessibilityEvent` or `sendAccessibilityEventInternal` in the same way. Hence, there is no compatibility issue caused by potentially different values or exception handlings (0)."
1145,"<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>",20,21,"<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>","<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri utteranceUri = mUtterances.get(text);
            if (utteranceUri != null) {
                return service.playAudio(getCallerIdentity(), utteranceUri, queueMode, getParams(params));
            } else {
                return service.speak(getCallerIdentity(), text, queueMode, getParams(params));
            }
        }
    }, ERROR, ""speak"");
}","{
    return speak(text, queueMode, convertParamsHashMaptoBundle(params), params == null ? null : params.get(Engine.KEY_PARAM_UTTERANCE_ID));
}",1,"/**
 * Speaks the string using the specified queuing strategy and speech parameters.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param text The string of text to be spoken. No longer than
 * {@link #getMaxSpeechInputLength()} characters.
 * @param queueMode The queuing strategy to use, {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID},
 * {@link Engine#KEY_PARAM_VOLUME},
 * {@link Engine#KEY_PARAM_PAN}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the speak operation.
 */
","/**
 * Speaks the string using the specified queuing strategy and speech parameters.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param text The string of text to be spoken. No longer than
 * {@link #getMaxSpeechInputLength()} characters.
 * @param queueMode The queuing strategy to use, {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID},
 * {@link Engine#KEY_PARAM_VOLUME},
 * {@link Engine#KEY_PARAM_PAN}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the speak operation.
 * @deprecated As of API level 21, replaced by
 * {@link #speak(CharSequence, int, Bundle, String)}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,1,"The late implementation of the method does not use the `runAction` anonymous inner class and has a completely different set of called methods; it uses speak directly with different parameters. The 'convertParamsHashMaptoBundle()' method and the fourth parameter 'params.get(Engine.KEY_PARAM_UTTERANCE_ID)' in the 'speak' call are not present in the early version, which indicates a change in the dependent API, so the code change type is 5.","The change in the method's implementation suggests that the behavior of the method could be different, possibly leading to different return values depending on what 'convertParamsHashMaptoBundle' and 'params.get(Engine.KEY_PARAM_UTTERANCE_ID)' return compared to the old implementation. Consequently, we have different potential return values, and the CI type is 1."
1146,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,20,21,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}",1,"/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
","/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement which includes the method findAccessibilityNodeInfoByAccessibilityId has changed, because the flags passed as parameters have changed from FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS to FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS. This implies a change in functionality as an additional flag is introduced, affecting which nodes are prefetched.","The change in the flags passed to the method call could lead to a different result being returned (additional nodes being prefetched or different nodes being prefetched), which is a potential different return value. Thus the CI type is 1."
1147,"<android.os.MessageQueue: void removeCallbacksAndMessages(Handler,Object)>",20,21,"<android.os.MessageQueue: void removeCallbacksAndMessages(Handler,Object)>","<android.os.MessageQueue: void removeCallbacksAndMessages(Handler,Object)>",0,"{
    if (h == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycle();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycle();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}","{
    if (h == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycleUnchecked();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycleUnchecked();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implemented method changed from p.recycle() to p.recycleUnchecked() for both conditions where messages are being removed. This is an internal implementation detail, so the code change type is 4.","This change is a refactoring of how a message is recycled but does not affect the public-facing behavior of the method. Therefore, this change does not introduce a potential compatibility issue; hence, the CI type is 0."
1148,<android.view.TextureView: HardwareLayer getHardwareLayer()>,20,21,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"{
    // NOTE: Maintain these two lines very carefully (see View.java)
    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque);
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer);
        }
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mUpdateListener = new SurfaceTexture.OnFrameAvailableListener() {

            @Override
            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
                // Per SurfaceTexture's documentation, the callback may be invoked
                // from an arbitrary thread
                updateLayer();
                if (Looper.myLooper() == Looper.getMainLooper()) {
                    invalidate();
                } else {
                    postInvalidate();
                }
            }
        };
        mSurface.setOnFrameAvailableListener(mUpdateListener);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mAttachInfo.mHardwareRenderer.setSurfaceTexture(mLayer, mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}","{
    // NOTE: Maintain these two lines very carefully (see View.java)
    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createTextureLayer();
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = new SurfaceTexture(false);
            mLayer.setSurfaceTexture(mSurface);
        }
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,Several changes are observed: ,- The `setSurfaceTexture()` method is invoked on the `mLayer` object directly instead of setting the `SurfaceTexture` via the renderer.
1149,<android.widget.CalendarView: long getMaxDate()>,20,21,<android.widget.CalendarView: long getMaxDate()>,<android.widget.CalendarView: long getMaxDate()>,0,"{
    return mMaxDate.getTimeInMillis();
}","{
    return mDelegate.getMaxDate();
}",1,"/**
 * Gets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default maximal date is 01/01/2100.
 * <p>
 *
 * @return The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */
","/**
 * Gets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default maximal date is 01/01/2100.
 * <p>
 *
 * @return The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method used to obtain the max date has changed from 'mMaxDate.getTimeInMillis()' to 'mDelegate.getMaxDate()', indicating that the source from which the max date value is retrieved has been altered. In addition, since 'mDelegate.getMaxDate()' indicates reliance on a potentially different implementation, the code change types are 1,5.","The change in the method used to obtain the max date value could lead to a different return value, particularly if 'mDelegate.getMaxDate()' behaves differently from 'mMaxDate.getTimeInMillis()'. Therefore, the CI type is 1."
