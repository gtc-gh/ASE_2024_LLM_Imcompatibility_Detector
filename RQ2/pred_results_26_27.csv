Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_Change_Type,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,"<android.bluetooth.BluetoothHeadset: boolean sendVendorSpecificResultCode(BluetoothDevice,String,String)>",26,27,,,,"{
    if (DBG) {
        log(""sendVendorSpecificResultCode()"");
    }
    if (command == null) {
        throw new IllegalArgumentException(""command is null"");
    }
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.sendVendorSpecificResultCode(device, command, arg);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null) {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return false;
}","{
    if (DBG) {
        log(""sendVendorSpecificResultCode()"");
    }
    if (command == null) {
        throw new IllegalArgumentException(""command is null"");
    }
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendVendorSpecificResultCode(device, command, arg);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null) {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return false;
}",1,"/**
 * Sends a vendor-specific unsolicited result code to the headset.
 *
 * <p>The actual string to be sent is <code>command + "": "" + arg</code>.
 * For example, if {@code command} is {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} and {@code arg}
 * is {@code ""0""}, the string <code>""+ANDROID: 0""</code> will be sent.
 *
 * <p>Currently only {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} is allowed as {@code command}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset.
 * @param command A vendor-specific command.
 * @param arg The argument that will be attached to the command.
 * @return {@code false} if there is no headset connected, or if the command is not an allowed
 * vendor-specific unsolicited result code, or on error. {@code true} otherwise.
 * @throws IllegalArgumentException if {@code command} is {@code null}.
 */
","/**
 * Sends a vendor-specific unsolicited result code to the headset.
 *
 * <p>The actual string to be sent is <code>command + "": "" + arg</code>.
 * For example, if {@code command} is {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} and {@code arg}
 * is {@code ""0""}, the string <code>""+ANDROID: 0""</code> will be sent.
 *
 * <p>Currently only {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} is allowed as {@code command}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset.
 * @param command A vendor-specific command.
 * @param arg The argument that will be attached to the command.
 * @return {@code false} if there is no headset connected, or if the command is not an allowed
 * vendor-specific unsolicited result code, or on error. {@code true} otherwise.
 * @throws IllegalArgumentException if {@code command} is {@code null}.
 */
",0,,,0,,,,,,,4,0,"The only change in the code is the introduction of a local variable `service` to hold the `mService` reference before using it. This doesn't change the control flow or the logic of the method. Therefore, the code change type is 4.","Since there's no behavioral change in the method's logic or the return values, and exception handling remains unchanged, there is no Compatibility Issue. The only modification is the internal reference handling which does not affect the API's external behavior."
3,<android.widget.DatePicker: AutofillValue getAutofillValue()>,26,27,,,,"{
    return isEnabled() ? AutofillValue.forDate(mDelegate.getDate()) : null;
}","{
    return isEnabled() ? mDelegate.getAutofillValue() : null;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,5",1,"The method for obtaining the AutofillValue has changed from AutofillValue.forDate(mDelegate.getDate()) to mDelegate.getAutofillValue(), which indicates a dependent API change and also suggests there might be a difference in the returned AutofillValue. Hence, the change type is 1,5.","The fact that the method of obtaining the AutofillValue has been modified could potentially lead to the method returning a different AutofillValue object, causing a change in behavior. Consequently, the CI type is 1."
4,<android.bluetooth.BluetoothHealth: List<BluetoothDevice> getConnectedDevices()>,26,27,,,,"{
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedHealthDevices();
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedHealthDevices();
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * Get connected devices for the health profile.
 *
 * <p> Return the set of devices which are in state {@link #STATE_CONNECTED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 * @return List of devices. The list will be empty on error.
 */
","/**
 * Get connected devices for the health profile.
 *
 * <p> Return the set of devices which are in state {@link #STATE_CONNECTED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 * @return List of devices. The list will be empty on error.
 */
",0,[@Override],[@Override],0,,,,,,,0,0,There is no functional code change between the two versions; the only difference is the assignment of the service instance to a local variable before it is used.,"Since there is no actual change in the behavior of the API, no Compatibility Issue could arise from this modification."
5,<android.app.Notification.StandardTemplateParams: StandardTemplateParams fillTextsFrom(Builder)>,26,27,,,,"{
    Bundle extras = b.mN.extras;
    title = b.processLegacyText(extras.getCharSequence(EXTRA_TITLE), ambient);
    text = b.processLegacyText(extras.getCharSequence(EXTRA_TEXT), ambient);
    return this;
}","{
    Bundle extras = b.mN.extras;
    this.title = b.processLegacyText(extras.getCharSequence(EXTRA_TITLE), ambient);
    // Big text notifications should contain their content when viewed in ambient mode.
    CharSequence text = extras.getCharSequence(EXTRA_BIG_TEXT);
    if (!ambient || TextUtils.isEmpty(text)) {
        text = extras.getCharSequence(EXTRA_TEXT);
    }
    this.text = b.processLegacyText(text, ambient);
    return this;
}",1,,,0,,,0,,,,,,,"1,3",1,"The late implementation introduces an additional local variable initialization, a conditional statement to handle big text notifications, and an assignment statement with a different logic (based on the value of `text`). These changes reflect a control dependency change as well as a change in return statement logic, thus the code change type is 1,3.","The introduction of this new logic in handling text content could lead to the API returning a different value in its 'text' field when ambient mode is active, and `EXTRA_BIG_TEXT` is not empty. Hence, it's a CI type 1."
6,"<android.bluetooth.BluetoothHealth: boolean connectChannelToSource(BluetoothDevice,BluetoothHealthAppConfiguration)>",26,27,,,,"{
    if (mService != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return mService.connectChannelToSource(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}","{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.connectChannelToSource(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}",1,"/**
 * Connect to a health device which has the {@link #SOURCE_ROLE}.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using
 * {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @return If true, the callback associated with the application config will be called.
 */
","/**
 * Connect to a health device which has the {@link #SOURCE_ROLE}.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using
 * {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @return If true, the callback associated with the application config will be called.
 */
",0,,,0,,,,,,,0,0,"There are no changes in the return statement, exception handling, or control flow. The only difference is the introduction of a local variable `service` in the late version, which points to the same object as `mService`. This is analogous to inlining the variable and does not result in any executable difference.","No Compatibility Issue is present because the behavior of the method has not changed between versions. The method signature is the same, and the local variable change does not affect the method's external behavior."
7,<android.app.Fragment: void performCreate(Bundle)>,26,27,,,,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
    }
    mState = CREATED;
    mCalled = false;
    onCreate(savedInstanceState);
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onCreate()"");
    }
    final Context context = getContext();
    final int version = context != null ? context.getApplicationInfo().targetSdkVersion : 0;
    if (version < Build.VERSION_CODES.N) {
        restoreChildFragmentState(savedInstanceState, false);
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
    }
    mState = CREATED;
    mCalled = false;
    onCreate(savedInstanceState);
    mIsCreated = true;
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onCreate()"");
    }
    final Context context = getContext();
    final int version = context != null ? context.getApplicationInfo().targetSdkVersion : 0;
    if (version < Build.VERSION_CODES.N) {
        restoreChildFragmentState(savedInstanceState, false);
    }
}",1,,,0,,,0,,,,,,,4,0,"A new field assignment (mIsCreated = true;) has been introduced, but it does not change the control flow or the method's return type/value (since the method's return type is void), and it does not affect exception handling. Hence, the only change type is 4.","As this new field assignment does not affect the API's behavior in terms of the method signature and does not introduce different return values or exception handlings, there are no potential Compatibility Issues introduced by this change."
9,"<android.app.FragmentManagerImpl: boolean dispatchCreateOptionsMenu(Menu,MenuInflater)>",26,27,,,,"{
    boolean show = false;
    ArrayList<Fragment> newMenus = null;
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null) {
                if (f.performCreateOptionsMenu(menu, inflater)) {
                    show = true;
                    if (newMenus == null) {
                        newMenus = new ArrayList<Fragment>();
                    }
                    newMenus.add(f);
                }
            }
        }
    }
    if (mCreatedMenus != null) {
        for (int i = 0; i < mCreatedMenus.size(); i++) {
            Fragment f = mCreatedMenus.get(i);
            if (newMenus == null || !newMenus.contains(f)) {
                f.onDestroyOptionsMenu();
            }
        }
    }
    mCreatedMenus = newMenus;
    return show;
}","{
    if (mCurState < Fragment.CREATED) {
        return false;
    }
    boolean show = false;
    ArrayList<Fragment> newMenus = null;
    for (int i = 0; i < mAdded.size(); i++) {
        Fragment f = mAdded.get(i);
        if (f != null) {
            if (f.performCreateOptionsMenu(menu, inflater)) {
                show = true;
                if (newMenus == null) {
                    newMenus = new ArrayList<Fragment>();
                }
                newMenus.add(f);
            }
        }
    }
    if (mCreatedMenus != null) {
        for (int i = 0; i < mCreatedMenus.size(); i++) {
            Fragment f = mCreatedMenus.get(i);
            if (newMenus == null || !newMenus.contains(f)) {
                f.onDestroyOptionsMenu();
            }
        }
    }
    mCreatedMenus = newMenus;
    return show;
}",1,,,0,,,0,,,,,,,3,1,"The control dependency has changed with the addition of a new 'if' statement checking 'mCurState < Fragment.CREATED' before proceeding with the existing code, so the code change type is 3.","The newly inserted 'if' statement could result in an early 'return false;' before the rest of the method is executed, which is a change in behavior as the early version would not have returned early. This constitutes a potential Compatibility Issue where the API could return a different value (false instead of possibly true), and hence the CI type is 1."
12,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,26,27,,,,"{
    // Make sure all pending operations have now been executed to get
    // our state update-to-date.
    forcePostponedTransactions();
    endAnimatingAwayFragments();
    execPendingActions();
    mStateSaved = true;
    mSavedNonConfig = null;
    if (mActive == null || mActive.size() <= 0) {
        return null;
    }
    // First collect all active fragments.
    int N = mActive.size();
    FragmentState[] active = new FragmentState[N];
    boolean haveFragments = false;
    for (int i = 0; i < N; i++) {
        Fragment f = mActive.valueAt(i);
        if (f != null) {
            if (f.mIndex < 0) {
                throwException(new IllegalStateException(""Failure saving state: active "" + f + "" has cleared index: "" + f.mIndex));
            }
            haveFragments = true;
            FragmentState fs = new FragmentState(f);
            active[i] = fs;
            if (f.mState > Fragment.INITIALIZING && fs.mSavedFragmentState == null) {
                fs.mSavedFragmentState = saveFragmentBasicState(f);
                if (f.mTarget != null) {
                    if (f.mTarget.mIndex < 0) {
                        throwException(new IllegalStateException(""Failure saving state: "" + f + "" has target not in fragment manager: "" + f.mTarget));
                    }
                    if (fs.mSavedFragmentState == null) {
                        fs.mSavedFragmentState = new Bundle();
                    }
                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);
                    if (f.mTargetRequestCode != 0) {
                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);
                    }
                }
            } else {
                fs.mSavedFragmentState = f.mSavedFragmentState;
            }
            if (DEBUG)
                Log.v(TAG, ""Saved state of "" + f + "": "" + fs.mSavedFragmentState);
        }
    }
    if (!haveFragments) {
        if (DEBUG)
            Log.v(TAG, ""saveAllState: no fragments!"");
        return null;
    }
    int[] added = null;
    BackStackState[] backStack = null;
    // Build list of currently added fragments.
    if (mAdded != null) {
        N = mAdded.size();
        if (N > 0) {
            added = new int[N];
            for (int i = 0; i < N; i++) {
                added[i] = mAdded.get(i).mIndex;
                if (added[i] < 0) {
                    throwException(new IllegalStateException(""Failure saving state: active "" + mAdded.get(i) + "" has cleared index: "" + added[i]));
                }
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding fragment #"" + i + "": "" + mAdded.get(i));
            }
        }
    }
    // Now save back stack.
    if (mBackStack != null) {
        N = mBackStack.size();
        if (N > 0) {
            backStack = new BackStackState[N];
            for (int i = 0; i < N; i++) {
                backStack[i] = new BackStackState(this, mBackStack.get(i));
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding back stack #"" + i + "": "" + mBackStack.get(i));
            }
        }
    }
    FragmentManagerState fms = new FragmentManagerState();
    fms.mActive = active;
    fms.mAdded = added;
    fms.mBackStack = backStack;
    fms.mNextFragmentIndex = mNextFragmentIndex;
    if (mPrimaryNav != null) {
        fms.mPrimaryNavActiveIndex = mPrimaryNav.mIndex;
    }
    saveNonConfig();
    return fms;
}","{
    // Make sure all pending operations have now been executed to get
    // our state update-to-date.
    forcePostponedTransactions();
    endAnimatingAwayFragments();
    execPendingActions();
    mStateSaved = true;
    mSavedNonConfig = null;
    if (mActive == null || mActive.size() <= 0) {
        return null;
    }
    // First collect all active fragments.
    int N = mActive.size();
    FragmentState[] active = new FragmentState[N];
    boolean haveFragments = false;
    for (int i = 0; i < N; i++) {
        Fragment f = mActive.valueAt(i);
        if (f != null) {
            if (f.mIndex < 0) {
                throwException(new IllegalStateException(""Failure saving state: active "" + f + "" has cleared index: "" + f.mIndex));
            }
            haveFragments = true;
            FragmentState fs = new FragmentState(f);
            active[i] = fs;
            if (f.mState > Fragment.INITIALIZING && fs.mSavedFragmentState == null) {
                fs.mSavedFragmentState = saveFragmentBasicState(f);
                if (f.mTarget != null) {
                    if (f.mTarget.mIndex < 0) {
                        throwException(new IllegalStateException(""Failure saving state: "" + f + "" has target not in fragment manager: "" + f.mTarget));
                    }
                    if (fs.mSavedFragmentState == null) {
                        fs.mSavedFragmentState = new Bundle();
                    }
                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);
                    if (f.mTargetRequestCode != 0) {
                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);
                    }
                }
            } else {
                fs.mSavedFragmentState = f.mSavedFragmentState;
            }
            if (DEBUG)
                Log.v(TAG, ""Saved state of "" + f + "": "" + fs.mSavedFragmentState);
        }
    }
    if (!haveFragments) {
        if (DEBUG)
            Log.v(TAG, ""saveAllState: no fragments!"");
        return null;
    }
    int[] added = null;
    BackStackState[] backStack = null;
    // Build list of currently added fragments.
    N = mAdded.size();
    if (N > 0) {
        added = new int[N];
        for (int i = 0; i < N; i++) {
            added[i] = mAdded.get(i).mIndex;
            if (added[i] < 0) {
                throwException(new IllegalStateException(""Failure saving state: active "" + mAdded.get(i) + "" has cleared index: "" + added[i]));
            }
            if (DEBUG)
                Log.v(TAG, ""saveAllState: adding fragment #"" + i + "": "" + mAdded.get(i));
        }
    }
    // Now save back stack.
    if (mBackStack != null) {
        N = mBackStack.size();
        if (N > 0) {
            backStack = new BackStackState[N];
            for (int i = 0; i < N; i++) {
                backStack[i] = new BackStackState(this, mBackStack.get(i));
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding back stack #"" + i + "": "" + mBackStack.get(i));
            }
        }
    }
    FragmentManagerState fms = new FragmentManagerState();
    fms.mActive = active;
    fms.mAdded = added;
    fms.mBackStack = backStack;
    fms.mNextFragmentIndex = mNextFragmentIndex;
    if (mPrimaryNav != null) {
        fms.mPrimaryNavActiveIndex = mPrimaryNav.mIndex;
    }
    saveNonConfig();
    return fms;
}",1,,,0,,,0,,,,,,,,,,
13,<android.hardware.camera2.impl.CameraCaptureSessionImpl: StateCallbackKK getDeviceStateCallback()>,26,27,,,,"{
    final CameraCaptureSession session = this;
    return new CameraDeviceImpl.StateCallbackKK() {

        private boolean mBusy = false;

        private boolean mActive = false;

        @Override
        public void onOpened(CameraDevice camera) {
            throw new AssertionError(""Camera must already be open before creating a session"");
        }

        @Override
        public void onDisconnected(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onDisconnected"");
            close();
        }

        @Override
        public void onError(CameraDevice camera, int error) {
            // Should not be reached, handled by device code
            Log.wtf(TAG, mIdString + ""Got device error "" + error);
        }

        @Override
        public void onActive(CameraDevice camera) {
            mIdleDrainer.taskStarted();
            mActive = true;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onActive"");
            mStateCallback.onActive(session);
        }

        @Override
        public void onIdle(CameraDevice camera) {
            boolean isAborting;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onIdle"");
            synchronized (session) {
                isAborting = mAborting;
            }
            /*
                 * Check which states we transitioned through:
                 *
                 * (ACTIVE -> IDLE)
                 * (BUSY -> IDLE)
                 *
                 * Note that this is also legal:
                 * (ACTIVE -> BUSY -> IDLE)
                 *
                 * and mark those tasks as finished
                 */
            if (mBusy && isAborting) {
                mAbortDrainer.taskFinished();
                synchronized (session) {
                    mAborting = false;
                }
            }
            if (mActive) {
                mIdleDrainer.taskFinished();
            }
            mBusy = false;
            mActive = false;
            mStateCallback.onReady(session);
        }

        @Override
        public void onBusy(CameraDevice camera) {
            mBusy = true;
            // Don't signal the application since there's no clean mapping here
            if (DEBUG)
                Log.v(TAG, mIdString + ""onBusy"");
        }

        @Override
        public void onUnconfigured(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onUnconfigured"");
        }

        @Override
        public void onRequestQueueEmpty() {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onRequestQueueEmpty"");
            mStateCallback.onCaptureQueueEmpty(session);
        }

        @Override
        public void onSurfacePrepared(Surface surface) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onSurfacePrepared"");
            mStateCallback.onSurfacePrepared(session, surface);
        }
    };
}","{
    final CameraCaptureSession session = this;
    final Object interfaceLock = mDeviceImpl.mInterfaceLock;
    return new CameraDeviceImpl.StateCallbackKK() {

        private boolean mBusy = false;

        private boolean mActive = false;

        @Override
        public void onOpened(CameraDevice camera) {
            throw new AssertionError(""Camera must already be open before creating a session"");
        }

        @Override
        public void onDisconnected(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onDisconnected"");
            close();
        }

        @Override
        public void onError(CameraDevice camera, int error) {
            // Should not be reached, handled by device code
            Log.wtf(TAG, mIdString + ""Got device error "" + error);
        }

        @Override
        public void onActive(CameraDevice camera) {
            mIdleDrainer.taskStarted();
            mActive = true;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onActive"");
            mStateCallback.onActive(session);
        }

        @Override
        public void onIdle(CameraDevice camera) {
            boolean isAborting;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onIdle"");
            synchronized (interfaceLock) {
                isAborting = mAborting;
            }
            /*
                 * Check which states we transitioned through:
                 *
                 * (ACTIVE -> IDLE)
                 * (BUSY -> IDLE)
                 *
                 * Note that this is also legal:
                 * (ACTIVE -> BUSY -> IDLE)
                 *
                 * and mark those tasks as finished
                 */
            if (mBusy && isAborting) {
                mAbortDrainer.taskFinished();
                synchronized (interfaceLock) {
                    mAborting = false;
                }
            }
            if (mActive) {
                mIdleDrainer.taskFinished();
            }
            mBusy = false;
            mActive = false;
            mStateCallback.onReady(session);
        }

        @Override
        public void onBusy(CameraDevice camera) {
            mBusy = true;
            // Don't signal the application since there's no clean mapping here
            if (DEBUG)
                Log.v(TAG, mIdString + ""onBusy"");
        }

        @Override
        public void onUnconfigured(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onUnconfigured"");
        }

        @Override
        public void onRequestQueueEmpty() {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onRequestQueueEmpty"");
            mStateCallback.onCaptureQueueEmpty(session);
        }

        @Override
        public void onSurfacePrepared(Surface surface) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onSurfacePrepared"");
            mStateCallback.onSurfacePrepared(session, surface);
        }
    };
}",1,"/**
 * Create an internal state callback, to be invoked on the mDeviceHandler
 *
 * <p>It has a few behaviors:
 * <ul>
 * <li>Convert device state changes into session state changes.
 * <li>Keep track of async tasks that the session began (idle, abort).
 * </ul>
 * </p>
 */
","/**
 * Create an internal state callback, to be invoked on the mDeviceHandler
 *
 * <p>It has a few behaviors:
 * <ul>
 * <li>Convert device state changes into session state changes.
 * <li>Keep track of async tasks that the session began (idle, abort).
 * </ul>
 * </p>
 */
",0,[@Override],[@Override],0,,,,,,,,,,
14,<android.hardware.camera2.params.StreamConfigurationMap: int depthFormatToPublic(int)>,26,27,,,,"{
    switch(format) {
        case HAL_PIXEL_FORMAT_BLOB:
            return ImageFormat.DEPTH_POINT_CLOUD;
        case HAL_PIXEL_FORMAT_Y16:
            return ImageFormat.DEPTH16;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException(""ImageFormat.JPEG is an unknown internal format"");
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
            throw new IllegalArgumentException(""IMPLEMENTATION_DEFINED must not leak to public API"");
        default:
            throw new IllegalArgumentException(""Unknown DATASPACE_DEPTH format "" + format);
    }
}","{
    switch(format) {
        case HAL_PIXEL_FORMAT_BLOB:
            return ImageFormat.DEPTH_POINT_CLOUD;
        case HAL_PIXEL_FORMAT_Y16:
            return ImageFormat.DEPTH16;
        case HAL_PIXEL_FORMAT_RAW16:
            return ImageFormat.RAW_DEPTH;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException(""ImageFormat.JPEG is an unknown internal format"");
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
            throw new IllegalArgumentException(""IMPLEMENTATION_DEFINED must not leak to public API"");
        default:
            throw new IllegalArgumentException(""Unknown DATASPACE_DEPTH format "" + format);
    }
}",1,"/**
 * Convert an internal format compatible with {@code graphics.h} into public-visible
 * {@code ImageFormat}. This assumes the dataspace of the format is HAL_DATASPACE_DEPTH.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>HAL_PIXEL_FORMAT_BLOB => ImageFormat.DEPTH_POINT_CLOUD
 * <li>HAL_PIXEL_FORMAT_Y16 => ImageFormat.DEPTH16
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format which has no public equivalent will fail;
 * as will passing in a public format which has a different internal format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no further invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToInternal} for formats associated with
 * HAL_DATASPACE_DEPTH.</p>
 *
 * @param format image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @throws IllegalArgumentException
 * if {@code format} is {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED} or
 * {@link ImageFormat#JPEG}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see #checkArgumentFormat
 */
","/**
 * Convert an internal format compatible with {@code graphics.h} into public-visible
 * {@code ImageFormat}. This assumes the dataspace of the format is HAL_DATASPACE_DEPTH.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>HAL_PIXEL_FORMAT_BLOB => ImageFormat.DEPTH_POINT_CLOUD
 * <li>HAL_PIXEL_FORMAT_Y16 => ImageFormat.DEPTH16
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format which has no public equivalent will fail;
 * as will passing in a public format which has a different internal format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no further invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToInternal} for formats associated with
 * HAL_DATASPACE_DEPTH.</p>
 *
 * @param format image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @throws IllegalArgumentException
 * if {@code format} is {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED} or
 * {@link ImageFormat#JPEG}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see #checkArgumentFormat
 */
",0,,,0,,,,,,,"1,3",1,"A new case in the switch statement has been added for HAL_PIXEL_FORMAT_RAW16 with a return statement returning ImageFormat.RAW_DEPTH. This is a change in the control dependency and the return statement, thus the change type is 1,3.","The addition of a new return statement for a specific case implies a potential change in the output returned by the method depending on the input value of 'format'. If 'format' is HAL_PIXEL_FORMAT_RAW16, the method now returns a newly introduced value, ImageFormat.RAW_DEPTH. This means there is a CI due to a potentially different return value, thus the CI type is 1."
15,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,26,27,,,,"{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        case MSG_PREPARE_FOR_EXTRA_DATA_REQUEST:
            return ""MSG_PREPARE_FOR_EXTRA_DATA_REQUEST"";
        case MSG_APP_PREPARATION_FINISHED:
            return ""MSG_APP_PREPARATION_FINISHED"";
        case MSG_APP_PREPARATION_TIMEOUT:
            return ""MSG_APP_PREPARATION_TIMEOUT"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,1,0,"New cases have been introduced to the switch statement, but there are no changes to the existing cases or default behavior. Hence, the change type is only 1.","No new behavior has been introduced for the existing message types; only new types have been added. For all message types valid in both the early and late versions, the behavior remains the same. The added message types do not change the behavior of the existing code and thus do not introduce compatibility issues; thereby, the result is 0 for CI."
16,<android.hardware.radio.RadioManager.ProgramInfo: int getSubChannel()>,26,27,,,,"{
    return mSubChannel;
}","{
    try {
        return (int) mSelector.getFirstId(ProgramSelector.IDENTIFIER_TYPE_HD_SUBCHANNEL) + 1;
    } catch (IllegalArgumentException ex) {
        // this is a normal behavior for analog AM/FM selector
        return 0;
    }
}",1,"/**
 * Sub channel ID. E.g 1 for HD radio HD1
 * @return the program sub channel
 */
","/**
 * Sub channel ID. E.g 1 for HD radio HD1
 * @return the program sub channel
 * @deprecated Use {@link getSelector()} instead.
 */
",1,,[@Deprecated],1,,,,,,,"1,2,5","1,2","The implementation has completely changed, from returning a straight member variable 'mSubChannel' to using a method call 'getFirstId' and associated logic to determine the return value, as well as a new exception being caught, so the code change types are 1,2,5.","The late version introduces a fundamentally different return mechanism which may result in different values being returned compared to the early version, and a new exception handling statement is introduced. This can lead to a CI where the returned value or the exception handling is different, so the CI types are 1,2."
17,<android.widget.TabHost: void setup()>,26,27,,,,"{
    mTabWidget = findViewById(com.android.internal.R.id.tabs);
    if (mTabWidget == null) {
        throw new RuntimeException(""Your TabHost must have a TabWidget whose id attribute is 'android.R.id.tabs'"");
    }
    // KeyListener to attach to all tabs. Detects non-navigation keys
    // and relays them to the tab content.
    mTabKeyListener = new OnKeyListener() {

        public boolean onKey(View v, int keyCode, KeyEvent event) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_CENTER:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                case KeyEvent.KEYCODE_DPAD_UP:
                case KeyEvent.KEYCODE_DPAD_DOWN:
                case KeyEvent.KEYCODE_ENTER:
                    return false;
            }
            mTabContent.requestFocus(View.FOCUS_FORWARD);
            return mTabContent.dispatchKeyEvent(event);
        }
    };
    mTabWidget.setTabSelectionListener(new TabWidget.OnTabSelectionChanged() {

        public void onTabSelectionChanged(int tabIndex, boolean clicked) {
            setCurrentTab(tabIndex);
            if (clicked) {
                mTabContent.requestFocus(View.FOCUS_FORWARD);
            }
        }
    });
    mTabContent = findViewById(com.android.internal.R.id.tabcontent);
    if (mTabContent == null) {
        throw new RuntimeException(""Your TabHost must have a FrameLayout whose id attribute is "" + ""'android.R.id.tabcontent'"");
    }
}","{
    mTabWidget = findViewById(com.android.internal.R.id.tabs);
    if (mTabWidget == null) {
        throw new RuntimeException(""Your TabHost must have a TabWidget whose id attribute is 'android.R.id.tabs'"");
    }
    // KeyListener to attach to all tabs. Detects non-navigation keys
    // and relays them to the tab content.
    mTabKeyListener = new OnKeyListener() {

        public boolean onKey(View v, int keyCode, KeyEvent event) {
            if (KeyEvent.isModifierKey(keyCode)) {
                return false;
            }
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_CENTER:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                case KeyEvent.KEYCODE_DPAD_UP:
                case KeyEvent.KEYCODE_DPAD_DOWN:
                case KeyEvent.KEYCODE_TAB:
                case KeyEvent.KEYCODE_SPACE:
                case KeyEvent.KEYCODE_ENTER:
                    return false;
            }
            mTabContent.requestFocus(View.FOCUS_FORWARD);
            return mTabContent.dispatchKeyEvent(event);
        }
    };
    mTabWidget.setTabSelectionListener(new TabWidget.OnTabSelectionChanged() {

        public void onTabSelectionChanged(int tabIndex, boolean clicked) {
            setCurrentTab(tabIndex);
            if (clicked) {
                mTabContent.requestFocus(View.FOCUS_FORWARD);
            }
        }
    });
    mTabContent = findViewById(com.android.internal.R.id.tabcontent);
    if (mTabContent == null) {
        throw new RuntimeException(""Your TabHost must have a FrameLayout whose id attribute is "" + ""'android.R.id.tabcontent'"");
    }
}",1,"/**
 * <p>Call setup() before adding tabs if loading TabHost using findViewById().
 * <i><b>However</i></b>: You do not need to call setup() after getTabHost()
 * in {@link android.app.TabActivity TabActivity}.
 * Example:</p>
 * <pre>mTabHost = (TabHost)findViewById(R.id.tabhost);
 * mTabHost.setup();
 * mTabHost.addTab(TAB_TAG_1, ""Hello, world!"", ""Tab 1"");
 */
","/**
 * <p>Call setup() before adding tabs if loading TabHost using findViewById().
 * <i><b>However</i></b>: You do not need to call setup() after getTabHost()
 * in {@link android.app.TabActivity TabActivity}.
 * Example:</p>
 * <pre>mTabHost = (TabHost)findViewById(R.id.tabhost);
 * mTabHost.setup();
 * mTabHost.addTab(TAB_TAG_1, ""Hello, world!"", ""Tab 1"");
 */
",0,,,0,,,,,,,4,0,"The implementation modification is within the `OnKeyListener` for the `mTabKeyListener`, specifically the addition of `if (KeyEvent.isModifierKey(keyCode))` check and the handling of two more key codes (`KeyEvent.KEYCODE_TAB` and `KeyEvent.KEYCODE_SPACE`). These changes do not affect the lifecycle of the method setup() itself since none of the changes are related to the main control flow or exception throwing. Hence, the change type is 4.","The change within the `OnKeyListener` does not introduce a change in the method's return type or its exception handling. Even though the behavior of the key listener has been changed, the setup() method's execution path and outcome remain unaffected. Therefore, there is no compatibility issue, and the CI type is 0."
18,"<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>",26,27,,,,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled || mSessionId == NO_SESSION) {
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled || !isActiveLocked()) {
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}",1,"/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
","/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
",0,,,0,,,,,,,"3,5",0,"The conditional statement in the late implementation has changed from `mSessionId == NO_SESSION` to `!isActiveLocked()`. This change is within the control flow, which is a change type 3. Since `isActiveLocked()` is being called instead of directly checking the value of `mSessionId`, this also indicates that a dependent API has changed, which is a change type 5.","Despite the changes in the control flow and the dependent API, the behavior in terms of API's contract remains the same. If the checks fail, it returns without doing anything—in both implementations—so there is no potential difference in return values or exception handlings introduced by the late version. Therefore, there is no Compatibility Issue, which is indicated by 0."
19,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,26,27,,,,"{
    super.dispatchProvideStructure(structure);
    if (isAssistBlocked() || structure.getChildCount() != 0) {
        return;
    }
    final int childrenCount = mChildrenCount;
    if (childrenCount <= 0) {
        return;
    }
    structure.setChildCount(childrenCount);
    ArrayList<View> preorderedList = buildOrderedChildList();
    boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        int childIndex;
        try {
            childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        } catch (IndexOutOfBoundsException e) {
            childIndex = i;
            if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                // At least one app is failing when we call getChildDrawingOrder
                // at this point, so deal semi-gracefully with it by falling back
                // on the basic order.
                customOrder = false;
                if (i > 0) {
                    // If we failed at the first index, there really isn't
                    // anything to do -- we will just proceed with the simple
                    // sequence order.
                    // Otherwise, we failed in the middle, so need to come up
                    // with an order for the remaining indices and use that.
                    // Failed at the first one, easy peasy.
                    int[] permutation = new int[childrenCount];
                    SparseBooleanArray usedIndices = new SparseBooleanArray();
                    // Go back and collected the indices we have done so far.
                    for (int j = 0; j < i; j++) {
                        permutation[j] = getChildDrawingOrder(childrenCount, j);
                        usedIndices.put(permutation[j], true);
                    }
                    // Fill in the remaining indices with indices that have not
                    // yet been used.
                    int nextIndex = 0;
                    for (int j = i; j < childrenCount; j++) {
                        while (usedIndices.get(nextIndex, false)) {
                            nextIndex++;
                        }
                        permutation[j] = nextIndex;
                        nextIndex++;
                    }
                    // Build the final view list.
                    preorderedList = new ArrayList<>(childrenCount);
                    for (int j = 0; j < childrenCount; j++) {
                        final int index = permutation[j];
                        final View child = mChildren[index];
                        preorderedList.add(child);
                    }
                }
            } else {
                throw e;
            }
        }
        final View child = getAndVerifyPreorderedView(preorderedList, mChildren, childIndex);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideStructure(cstructure);
    }
    if (preorderedList != null) {
        preorderedList.clear();
    }
}","{
    super.dispatchProvideStructure(structure);
    if (isAssistBlocked() || structure.getChildCount() != 0) {
        return;
    }
    final int childrenCount = mChildrenCount;
    if (childrenCount <= 0) {
        return;
    }
    if (!isLaidOut()) {
        Log.v(VIEW_LOG_TAG, ""dispatchProvideStructure(): not laid out, ignoring "" + childrenCount + "" children of "" + getAccessibilityViewId());
        return;
    }
    structure.setChildCount(childrenCount);
    ArrayList<View> preorderedList = buildOrderedChildList();
    boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        int childIndex;
        try {
            childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        } catch (IndexOutOfBoundsException e) {
            childIndex = i;
            if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                // At least one app is failing when we call getChildDrawingOrder
                // at this point, so deal semi-gracefully with it by falling back
                // on the basic order.
                customOrder = false;
                if (i > 0) {
                    // If we failed at the first index, there really isn't
                    // anything to do -- we will just proceed with the simple
                    // sequence order.
                    // Otherwise, we failed in the middle, so need to come up
                    // with an order for the remaining indices and use that.
                    // Failed at the first one, easy peasy.
                    int[] permutation = new int[childrenCount];
                    SparseBooleanArray usedIndices = new SparseBooleanArray();
                    // Go back and collected the indices we have done so far.
                    for (int j = 0; j < i; j++) {
                        permutation[j] = getChildDrawingOrder(childrenCount, j);
                        usedIndices.put(permutation[j], true);
                    }
                    // Fill in the remaining indices with indices that have not
                    // yet been used.
                    int nextIndex = 0;
                    for (int j = i; j < childrenCount; j++) {
                        while (usedIndices.get(nextIndex, false)) {
                            nextIndex++;
                        }
                        permutation[j] = nextIndex;
                        nextIndex++;
                    }
                    // Build the final view list.
                    preorderedList = new ArrayList<>(childrenCount);
                    for (int j = 0; j < childrenCount; j++) {
                        final int index = permutation[j];
                        final View child = mChildren[index];
                        preorderedList.add(child);
                    }
                }
            } else {
                throw e;
            }
        }
        final View child = getAndVerifyPreorderedView(preorderedList, mChildren, childIndex);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideStructure(cstructure);
    }
    if (preorderedList != null) {
        preorderedList.clear();
    }
}",1,"/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
","/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
",0,[@Override],[@Override],0,,,,,,,,,,
21,<android.view.autofill.AutofillManager: void cancel()>,26,27,,,,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled && mSessionId == NO_SESSION) {
            return;
        }
        cancelSessionLocked();
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled && !isActiveLocked()) {
            return;
        }
        cancelSessionLocked();
    }
}",1,"/**
 * Called to indicate the current autofill context should be cancelled.
 *
 * <p>For example, when a virtual view is rendering an {@code HTML} page with a form, it should
 * call this method if the user does not post the form but moves to another form in this page.
 */
","/**
 * Called to indicate the current autofill context should be cancelled.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method if the user does not post the
 * form but moves to another form in this page.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
",1,,,0,,,,,,,3,0,"The control dependency has changed within the 'synchronized' block. The condition has changed from checking 'mSessionId == NO_SESSION' to '!isActiveLocked()', so the code change type is 3.","Despite the change in control dependency, it does not lead to a Compatibility Issue because the behavior of the API in terms of what it does remains consistent: it cancels the autofill session if certain conditions are met. If 'isActiveLocked()' is a direct replacement for checking 'mSessionId == NO_SESSION' (i.e., they yield the same result in similar conditions), then the outcome of the API stays the same, which means there is no Compatibility Issue. However, without clear documentation or understanding of the internal logic behind 'isActiveLocked()', one cannot conclusively determine a behavioral change. Given this circumstance, we default to assuming maintaining behavior equivalence unless proven otherwise."
22,<android.service.autofill.SaveInfo: String toString()>,26,27,,,,"{
    if (!sDebug)
        return super.toString();
    return new StringBuilder(""SaveInfo: [type="").append(DebugUtils.flagsToString(SaveInfo.class, ""SAVE_DATA_TYPE_"", mType)).append("", requiredIds="").append(Arrays.toString(mRequiredIds)).append("", optionalIds="").append(Arrays.toString(mOptionalIds)).append("", description="").append(mDescription).append(DebugUtils.flagsToString(SaveInfo.class, ""NEGATIVE_BUTTON_STYLE_"", mNegativeButtonStyle)).append("", mFlags="").append(mFlags).append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    return new StringBuilder(""SaveInfo: [type="").append(DebugUtils.flagsToString(SaveInfo.class, ""SAVE_DATA_TYPE_"", mType)).append("", requiredIds="").append(Arrays.toString(mRequiredIds)).append("", optionalIds="").append(Arrays.toString(mOptionalIds)).append("", description="").append(mDescription).append(DebugUtils.flagsToString(SaveInfo.class, ""NEGATIVE_BUTTON_STYLE_"", mNegativeButtonStyle)).append("", mFlags="").append(mFlags).append("", mCustomDescription="").append(mCustomDescription).append("", validation="").append(mValidator).append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",0,[@Override],[@Override],0,,,,,,,4,0,"The implementation of the `toString` method has been extended to include two additional members (`mCustomDescription` and `mValidator`) in the `StringBuilder`. These are just appended to the existing `StringBuilder` sequence and don't affect the control flow or the method's signature, so the change is classified as 4, which stands for Other statement changed.","There's no Compatibility Issue as the changes are limited to the string representation provided by `toString`, which doesn't affect the API's logic or control flow but merely provides more information for debugging purposes. Typically, the `toString` method is used for informative or debugging purposes and is not expected to impact the compatibility or behavior of the class's core functionalities."
23,<android.bluetooth.BluetoothHealth: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,26,27,,,,"{
    if (mService != null && isEnabled()) {
        try {
            return mService.getHealthDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getHealthDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * Get a list of devices that match any of the given connection
 * states.
 *
 * <p> If none of the devices match any of the given states,
 * an empty list will be returned.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param states Array of states. States can be one of
 * {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
 * {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING},
 * @return List of devices. The list will be empty on error.
 */
","/**
 * Get a list of devices that match any of the given connection
 * states.
 *
 * <p> If none of the devices match any of the given states,
 * an empty list will be returned.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param states Array of states. States can be one of
 * {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
 * {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING},
 * @return List of devices. The list will be empty on error.
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"The only change is the local variable service assignment using mService before the if condition. This change does not affect the return value, exception handling, control flow, or method signature. The rest of the implementation remains the same. ",There is no Compatibility Issue because there is no change in behavior between versions; the method still performs the same operations and returns the same values under the same conditions.
24,"<android.content.AbstractThreadedSyncAdapter.ISyncAdapterImpl: void startSync(ISyncContext,String,Account,Bundle)>",26,27,,,,"{
    final SyncContext syncContextClient = new SyncContext(syncContext);
    boolean alreadyInProgress;
    // synchronize to make sure that mSyncThreads doesn't change between when we
    // check it and when we use it
    final Account threadsKey = toSyncKey(account);
    synchronized (mSyncThreadLock) {
        if (!mSyncThreads.containsKey(threadsKey)) {
            if (mAutoInitialize && extras != null && extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE, false)) {
                try {
                    if (ContentResolver.getIsSyncable(account, authority) < 0) {
                        ContentResolver.setIsSyncable(account, authority, 1);
                    }
                } finally {
                    syncContextClient.onFinished(new SyncResult());
                }
                return;
            }
            SyncThread syncThread = new SyncThread(""SyncAdapterThread-"" + mNumSyncStarts.incrementAndGet(), syncContextClient, authority, account, extras);
            mSyncThreads.put(threadsKey, syncThread);
            syncThread.start();
            alreadyInProgress = false;
        } else {
            alreadyInProgress = true;
        }
    }
    // holding the synchronization lock
    if (alreadyInProgress) {
        syncContextClient.onFinished(SyncResult.ALREADY_IN_PROGRESS);
    }
}","{
    if (ENABLE_LOG) {
        if (extras != null) {
            // Unparcel so its toString() will show the contents.
            extras.size();
        }
        Log.d(TAG, ""startSync() start "" + authority + "" "" + account + "" "" + extras);
    }
    try {
        final SyncContext syncContextClient = new SyncContext(syncContext);
        boolean alreadyInProgress;
        // synchronize to make sure that mSyncThreads doesn't change between when we
        // check it and when we use it
        final Account threadsKey = toSyncKey(account);
        synchronized (mSyncThreadLock) {
            if (!mSyncThreads.containsKey(threadsKey)) {
                if (mAutoInitialize && extras != null && extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE, false)) {
                    try {
                        if (ContentResolver.getIsSyncable(account, authority) < 0) {
                            ContentResolver.setIsSyncable(account, authority, 1);
                        }
                    } finally {
                        syncContextClient.onFinished(new SyncResult());
                    }
                    return;
                }
                SyncThread syncThread = new SyncThread(""SyncAdapterThread-"" + mNumSyncStarts.incrementAndGet(), syncContextClient, authority, account, extras);
                mSyncThreads.put(threadsKey, syncThread);
                syncThread.start();
                alreadyInProgress = false;
            } else {
                if (ENABLE_LOG) {
                    Log.d(TAG, ""  alreadyInProgress"");
                }
                alreadyInProgress = true;
            }
        }
        // holding the synchronization lock
        if (alreadyInProgress) {
            syncContextClient.onFinished(SyncResult.ALREADY_IN_PROGRESS);
        }
    } catch (RuntimeException | Error th) {
        if (ENABLE_LOG) {
            Log.d(TAG, ""startSync() caught exception"", th);
        }
        throw th;
    } finally {
        if (ENABLE_LOG) {
            Log.d(TAG, ""startSync() finishing"");
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,3,4","1,2",- New logging code has been added (other statement changed - type 4).,
25,<android.widget.TextView: boolean performLongClick()>,26,27,,,,"{
    boolean handled = false;
    if (mEditor != null) {
        mEditor.mIsBeingLongClicked = true;
    }
    if (super.performLongClick()) {
        handled = true;
    }
    if (mEditor != null) {
        handled |= mEditor.performLongClick(handled);
        mEditor.mIsBeingLongClicked = false;
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        if (mEditor != null)
            mEditor.mDiscardNextActionUp = true;
    } else {
        MetricsLogger.action(mContext, MetricsEvent.TEXT_LONGPRESS, TextViewMetrics.SUBTYPE_LONG_PRESS_OTHER);
    }
    return handled;
}","{
    boolean handled = false;
    boolean performedHapticFeedback = false;
    if (mEditor != null) {
        mEditor.mIsBeingLongClicked = true;
    }
    if (super.performLongClick()) {
        handled = true;
        performedHapticFeedback = true;
    }
    if (mEditor != null) {
        handled |= mEditor.performLongClick(handled);
        mEditor.mIsBeingLongClicked = false;
    }
    if (handled) {
        if (!performedHapticFeedback) {
            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        }
        if (mEditor != null)
            mEditor.mDiscardNextActionUp = true;
    } else {
        MetricsLogger.action(mContext, MetricsEvent.TEXT_LONGPRESS, TextViewMetrics.SUBTYPE_LONG_PRESS_OTHER);
    }
    return handled;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"A new variable `boolean performedHapticFeedback = false;` was introduced and a corresponding condition `if (!performedHapticFeedback)` was added before `performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);` to avoid performing haptic feedback twice. These changes are not related to return statements, exception handling, or control dependencies that control the main logic flow for return values or exceptions, so the code change type is 4.","There is no Compatibility Issue because the behavioral logic of the method has not changed. The return value `handled` remains determined by the same conditions as before, and no new exceptions are thrown. The change is related to an internal state flag `performedHapticFeedback` that ensures haptic feedback is not performed twice, but it does not affect the API's external behavior or output. Thus, the functionality from an API consumer's perspective remains the same, meaning no CI exists here, which corresponds to 0."
26,<android.bluetooth.BluetoothDevice: boolean setPin(byte[])>,26,27,,,,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot set Remote Device pin"");
        return false;
    }
    try {
        return sService.setPin(this, true, pin.length, pin);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot set Remote Device pin"");
        return false;
    }
    try {
        return service.setPin(this, true, pin.length, pin);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true pin has been set
 * false for error
 */
","/**
 * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true pin has been set
 * false for error
 */
",0,,,0,,,,,,,0,0,No change in the functional code logic; only a local variable 'service' has been introduced to hold 'sService'.,"No Compatibility Issue; there is no alteration in functionality, return values, or exception handling."
27,<android.widget.TimePicker: void autofill(AutofillValue)>,26,27,,,,"{
    if (!isEnabled())
        return;
    if (!value.isDate()) {
        Log.w(LOG_TAG, value + "" could not be autofilled into "" + this);
        return;
    }
    mDelegate.setDate(value.getDateValue());
}","{
    if (!isEnabled())
        return;
    mDelegate.autofill(value);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",1,"The check for value.isDate() and associated logging when the condition is not met has been removed; A new method call on mDelegate has been used (mDelegate.autofill(value) replaced mDelegate.setDate(value.getDateValue())), and an if condition has been removed, constituting types 1 (a return statement is removed) and 4 (an if condition is removed and a different method on the delegate is called). The removal of the isDate() check and the conditional log statement also constitutes a change type 3.","Because the check to ensure the AutofillValue is a date has been removed and a different method is now being called on mDelegate, this could lead to the API accepting values for autofill that it previously would have rejected and also potentially performing different actions when autofilling. This can lead to different behavior and is thus a CI type 1."
28,<android.os.Parcel: void readByteArray(byte[])>,26,27,,,,"{
    // TODO: make this a native method to avoid the extra copy.
    byte[] ba = createByteArray();
    if (ba.length == val.length) {
        System.arraycopy(ba, 0, val, 0, ba.length);
    } else {
        throw new RuntimeException(""bad array lengths"");
    }
}","{
    boolean valid = nativeReadByteArray(mNativePtr, val, (val != null) ? val.length : 0);
    if (!valid) {
        throw new RuntimeException(""bad array lengths"");
    }
}",1,"/**
 * Read a byte[] object from the parcel and copy it into the
 * given byte array.
 */
","/**
 * Read a byte[] object from the parcel and copy it into the
 * given byte array.
 */
",0,,,0,,,,,,,"4,5","1,2","The early version of the method contains a TODO comment suggesting that the operation should be made into a native method. In the late version, this change has been implemented with the introduction of the nativeReadByteArray method, which now handles reading the byte array. This is a significant change from the Java array copy in the early version, and it alters how the read operation's validity is checked. As a result, the code change includes an 'Other statement changed' because of the introduction of new logic to read the byte array, and the 'Dependent API changed' because the new native method is now a dependency.","The implementation has been changed to a native method which could potentially alter the behavior when reading byte arrays, hence a 'Compatibility Issue caused by potential different return values or types' is possible. Moreover, because the exception is now thrown based on the result of the native method, which also represents a different exception handling strategy, a 'Compatibility Issue caused by potential different exception handlings' is also possible."
29,<android.hardware.usb.UsbDeviceConnection: void finalize()>,26,27,,,,"{
    try {
        mCloseGuard.warnIfOpen();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"The change involved adding a null check for the mCloseGuard variable before calling warnIfOpen(), which is a control dependency change, hence the code change type is 3.","The modification simply adds a safeguard against potential null pointer exceptions by checking mCloseGuard for null. This does not affect the public contract of the API, as it's an internal safety check, and the external behavior of the method finalize() remains unchanged. Therefore, there is no Compatibility Issue; the CI type is 0."
30,<android.widget.TimePicker: AutofillValue getAutofillValue()>,26,27,,,,"{
    return isEnabled() ? AutofillValue.forDate(mDelegate.getDate()) : null;
}","{
    return isEnabled() ? mDelegate.getAutofillValue() : null;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,5",1,"The implementation of the method called inside the return statement has been changed from 'AutofillValue.forDate(mDelegate.getDate())' to 'mDelegate.getAutofillValue()', which means a dependent API has changed. Hence the code change type is 1,5.","The change of the method inside the return statement could potentially lead to a different return value. For example, if 'mDelegate.getAutofillValue()' behaves differently from 'AutofillValue.forDate(mDelegate.getDate())', which is very likely since they seem to be completely different method calls, the end result when 'isEnabled()' is true would be different. Therefore, the CI type is 1."
31,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",26,27,,,,"{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency, // TODO: Support more justification mode, e.g. letter spacing, stretching.
        b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}","{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    b.setLocales(paint.getTextLocales());
    mLineCount = 0;
    mEllipsized = false;
    mMaxLineHeight = mMaximumVisibleLineCount < 1 ? 0 : DEFAULT_MAX_LINE_HEIGHT;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency, // TODO: Support more justification mode, e.g. letter spacing, stretching.
        b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,,,,
32,"<android.hardware.radio.RadioMetadata.Builder: Builder putInt(String,int)>",26,27,,,,"{
    if (!METADATA_KEYS_TYPE.containsKey(key) || METADATA_KEYS_TYPE.get(key) != METADATA_TYPE_INT) {
        throw new IllegalArgumentException(""The "" + key + "" key cannot be used to put a long"");
    }
    mBundle.putInt(key, value);
    return this;
}","{
    RadioMetadata.putInt(mBundle, key, value);
    return this;
}",1,"/**
 * Put an int value into the meta data. Custom keys may be used, but if
 * the METADATA_KEYs defined in this class are used they may only be one
 * of the following:
 * <ul>
 * <li>{@link #METADATA_KEY_RDS_PTY}</li>
 * <li>{@link #METADATA_KEY_RBDS_PTY}</li>
 * </ul>
 *
 * @param key The key for referencing this value
 * @param value The int value to store
 * @return the same Builder instance
 */
","/**
 * Put an int value into the meta data. Custom keys may be used, but if
 * the METADATA_KEYs defined in this class are used they may only be one
 * of the following:
 * <ul>
 * <li>{@link #METADATA_KEY_RDS_PI}</li>
 * <li>{@link #METADATA_KEY_RDS_PTY}</li>
 * <li>{@link #METADATA_KEY_RBDS_PTY}</li>
 * </ul>
 * or any bitmap represented by its identifier.
 *
 * @param key The key for referencing this value
 * @param value The int value to store
 * @return the same Builder instance
 */
",1,,,0,,,,,,,"2,4,5","1,2",The following code changes have been made between the early and late versions:,- Whole control dependency and exception check codes have been removed. 
33,<android.bluetooth.BluetoothGatt: boolean connect()>,26,27,,,,"{
    try {
        mService.clientConnect(mClientIf, mDevice.getAddress(), false, mTransport, // autoConnect is inverse of ""isDirect""
        mPhy);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
}","{
    try {
        mService.clientConnect(mClientIf, mDevice.getAddress(), false, mTransport, mOpportunistic, // autoConnect is inverse of ""isDirect""
        mPhy);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
}",1,"/**
 * Connect back to remote device.
 *
 * <p>This method is used to re-connect to a remote device after the
 * connection has been dropped. If the device is not in range, the
 * re-connection will be triggered once the device is back in range.
 *
 * @return true, if the connection attempt was initiated successfully
 */
","/**
 * Connect back to remote device.
 *
 * <p>This method is used to re-connect to a remote device after the
 * connection has been dropped. If the device is not in range, the
 * re-connection will be triggered once the device is back in range.
 *
 * @return true, if the connection attempt was initiated successfully
 */
",0,,,0,,,,,,,5,0,The method implementation changed with an additional parameter (mOpportunistic) being passed to mService.clientConnect(). No other changes were made. This corresponds to a change in a dependent API.,"There are no changes in the return statements or exception handling statements, and since the extra parameter does not change the method's behavior in a way that would lead to different values returned or different exceptions thrown (the method always returns true if no exception is thrown and false if an exception is caught), there is no compatibility issue in terms of return values or exception handling. Therefore, there is no compatibility issue that would arise from this particular change."
34,<android.os.PowerManager.WakeLock: String toString()>,26,27,,,,"{
    synchronized (mToken) {
        return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held="" + mHeld + "", refCount="" + mCount + ""}"";
    }
}","{
    synchronized (mToken) {
        return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held="" + mHeld + "", refCount="" + mInternalCount + ""}"";
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change in the return statement is only related to an internal field name change from mCount to mInternalCount, without changing the behavior of the API as long as the fields mCount and mInternalCount are conceptually the same. Therefore, the type is 4.","There is no compatibility issue since the toString method still returns a String representation of the WakeLock object and there was no change in the format or the data conveyed in that representation, assuming mInternalCount serves the same purpose as mCount and just represents an internal change in naming."
35,"<android.view.accessibility.AccessibilityNodeInfo: void writeToParcel(Parcel,int)>",26,27,,,,"{
    parcel.writeInt(isSealed() ? 1 : 0);
    parcel.writeLong(mSourceNodeId);
    parcel.writeInt(mWindowId);
    parcel.writeLong(mParentNodeId);
    parcel.writeLong(mLabelForId);
    parcel.writeLong(mLabeledById);
    parcel.writeLong(mTraversalBefore);
    parcel.writeLong(mTraversalAfter);
    parcel.writeInt(mConnectionId);
    final LongArray childIds = mChildNodeIds;
    if (childIds == null) {
        parcel.writeInt(0);
    } else {
        final int childIdsSize = childIds.size();
        parcel.writeInt(childIdsSize);
        for (int i = 0; i < childIdsSize; i++) {
            parcel.writeLong(childIds.get(i));
        }
    }
    parcel.writeInt(mBoundsInParent.top);
    parcel.writeInt(mBoundsInParent.bottom);
    parcel.writeInt(mBoundsInParent.left);
    parcel.writeInt(mBoundsInParent.right);
    parcel.writeInt(mBoundsInScreen.top);
    parcel.writeInt(mBoundsInScreen.bottom);
    parcel.writeInt(mBoundsInScreen.left);
    parcel.writeInt(mBoundsInScreen.right);
    if (mActions != null && !mActions.isEmpty()) {
        final int actionCount = mActions.size();
        int nonLegacyActionCount = 0;
        int defaultLegacyStandardActions = 0;
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (isDefaultLegacyStandardAction(action)) {
                defaultLegacyStandardActions |= action.getId();
            } else {
                nonLegacyActionCount++;
            }
        }
        parcel.writeInt(defaultLegacyStandardActions);
        parcel.writeInt(nonLegacyActionCount);
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (!isDefaultLegacyStandardAction(action)) {
                parcel.writeInt(action.getId());
                parcel.writeCharSequence(action.getLabel());
            }
        }
    } else {
        parcel.writeInt(0);
        parcel.writeInt(0);
    }
    parcel.writeInt(mMaxTextLength);
    parcel.writeInt(mMovementGranularities);
    parcel.writeInt(mBooleanProperties);
    parcel.writeCharSequence(mPackageName);
    parcel.writeCharSequence(mClassName);
    parcel.writeCharSequence(mText);
    parcel.writeCharSequence(mHintText);
    parcel.writeCharSequence(mError);
    parcel.writeCharSequence(mContentDescription);
    parcel.writeString(mViewIdResourceName);
    parcel.writeInt(mTextSelectionStart);
    parcel.writeInt(mTextSelectionEnd);
    parcel.writeInt(mInputType);
    parcel.writeInt(mLiveRegion);
    parcel.writeInt(mDrawingOrderInParent);
    if (mExtraDataKeys != null) {
        parcel.writeInt(1);
        parcel.writeStringList(mExtraDataKeys);
    } else {
        parcel.writeInt(0);
    }
    if (mExtras != null) {
        parcel.writeInt(1);
        parcel.writeBundle(mExtras);
    } else {
        parcel.writeInt(0);
    }
    if (mRangeInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
        parcel.writeInt(mCollectionInfo.getSelectionMode());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionItemInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}","{
    // Write bit set of indices of fields with values differing from default
    long nonDefaultFields = 0;
    // index of the current field
    int fieldIndex = 0;
    if (isSealed() != DEFAULT.isSealed())
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mSourceNodeId != DEFAULT.mSourceNodeId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mWindowId != DEFAULT.mWindowId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mParentNodeId != DEFAULT.mParentNodeId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mLabelForId != DEFAULT.mLabelForId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mLabeledById != DEFAULT.mLabeledById)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mTraversalBefore != DEFAULT.mTraversalBefore)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mTraversalAfter != DEFAULT.mTraversalAfter)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mConnectionId != DEFAULT.mConnectionId)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mChildNodeIds, DEFAULT.mChildNodeIds)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mBoundsInParent, DEFAULT.mBoundsInParent)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mBoundsInScreen, DEFAULT.mBoundsInScreen)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mActions, DEFAULT.mActions))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mMaxTextLength != DEFAULT.mMaxTextLength)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mMovementGranularities != DEFAULT.mMovementGranularities) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (mBooleanProperties != DEFAULT.mBooleanProperties)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mPackageName, DEFAULT.mPackageName)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mClassName, DEFAULT.mClassName))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mText, DEFAULT.mText))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mHintText, DEFAULT.mHintText)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mError, DEFAULT.mError))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mContentDescription, DEFAULT.mContentDescription)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mViewIdResourceName, DEFAULT.mViewIdResourceName)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (mTextSelectionStart != DEFAULT.mTextSelectionStart) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (mTextSelectionEnd != DEFAULT.mTextSelectionEnd) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (mInputType != DEFAULT.mInputType)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mLiveRegion != DEFAULT.mLiveRegion)
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (mDrawingOrderInParent != DEFAULT.mDrawingOrderInParent) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mExtraDataKeys, DEFAULT.mExtraDataKeys)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mExtras, DEFAULT.mExtras))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mRangeInfo, DEFAULT.mRangeInfo))
        nonDefaultFields |= bitAt(fieldIndex);
    fieldIndex++;
    if (!Objects.equals(mCollectionInfo, DEFAULT.mCollectionInfo)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    fieldIndex++;
    if (!Objects.equals(mCollectionItemInfo, DEFAULT.mCollectionItemInfo)) {
        nonDefaultFields |= bitAt(fieldIndex);
    }
    int totalFields = fieldIndex;
    parcel.writeLong(nonDefaultFields);
    fieldIndex = 0;
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(isSealed() ? 1 : 0);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mSourceNodeId);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mWindowId);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mParentNodeId);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mLabelForId);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mLabeledById);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mTraversalBefore);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeLong(mTraversalAfter);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mConnectionId);
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        final LongArray childIds = mChildNodeIds;
        if (childIds == null) {
            parcel.writeInt(0);
        } else {
            final int childIdsSize = childIds.size();
            parcel.writeInt(childIdsSize);
            for (int i = 0; i < childIdsSize; i++) {
                parcel.writeLong(childIds.get(i));
            }
        }
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mBoundsInParent.top);
        parcel.writeInt(mBoundsInParent.bottom);
        parcel.writeInt(mBoundsInParent.left);
        parcel.writeInt(mBoundsInParent.right);
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mBoundsInScreen.top);
        parcel.writeInt(mBoundsInScreen.bottom);
        parcel.writeInt(mBoundsInScreen.left);
        parcel.writeInt(mBoundsInScreen.right);
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        if (mActions != null && !mActions.isEmpty()) {
            final int actionCount = mActions.size();
            int nonStandardActionCount = 0;
            int defaultStandardActions = 0;
            for (int i = 0; i < actionCount; i++) {
                AccessibilityAction action = mActions.get(i);
                if (isDefaultStandardAction(action)) {
                    defaultStandardActions |= action.mSerializationFlag;
                } else {
                    nonStandardActionCount++;
                }
            }
            parcel.writeInt(defaultStandardActions);
            parcel.writeInt(nonStandardActionCount);
            for (int i = 0; i < actionCount; i++) {
                AccessibilityAction action = mActions.get(i);
                if (!isDefaultStandardAction(action)) {
                    parcel.writeInt(action.getId());
                    parcel.writeCharSequence(action.getLabel());
                }
            }
        } else {
            parcel.writeInt(0);
            parcel.writeInt(0);
        }
    }
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mMaxTextLength);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mMovementGranularities);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mBooleanProperties);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mPackageName);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mClassName);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mText);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mHintText);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeCharSequence(mError);
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeCharSequence(mContentDescription);
    }
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeString(mViewIdResourceName);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mTextSelectionStart);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mTextSelectionEnd);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mInputType);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mLiveRegion);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeInt(mDrawingOrderInParent);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeStringList(mExtraDataKeys);
    if (isBitSet(nonDefaultFields, fieldIndex++))
        parcel.writeBundle(mExtras);
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
        parcel.writeInt(mCollectionInfo.getSelectionMode());
    }
    if (isBitSet(nonDefaultFields, fieldIndex++)) {
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
    }
    if (DEBUG) {
        fieldIndex--;
        if (totalFields != fieldIndex) {
            throw new IllegalStateException(""Number of fields mismatch: "" + totalFields + "" vs "" + fieldIndex);
        }
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}",1,"/**
 * {@inheritDoc}
 * <p>
 * <strong>Note:</strong> After the instance is written to a parcel it
 * is recycled. You must not touch the object after calling this function.
 * </p>
 */
","/**
 * {@inheritDoc}
 * <p>
 * <strong>Note:</strong> After the instance is written to a parcel it
 * is recycled. You must not touch the object after calling this function.
 * </p>
 */
",0,[@Override],[@Override],0,,,,,,,,,,
37,"<android.net.nsd.NsdManager: void discoverServices(String,int,DiscoveryListener)>",26,27,,,,"{
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    if (TextUtils.isEmpty(serviceType)) {
        throw new IllegalArgumentException(""Service type cannot be empty"");
    }
    if (protocolType != PROTOCOL_DNS_SD) {
        throw new IllegalArgumentException(""Unsupported protocol"");
    }
    NsdServiceInfo s = new NsdServiceInfo();
    s.setServiceType(serviceType);
    int key = putListener(listener, s);
    if (key == BUSY_LISTENER_KEY) {
        throw new IllegalArgumentException(""listener already in use"");
    }
    mAsyncChannel.sendMessage(DISCOVER_SERVICES, 0, key, s);
}","{
    checkStringNotEmpty(serviceType, ""Service type cannot be empty"");
    checkProtocol(protocolType);
    NsdServiceInfo s = new NsdServiceInfo();
    s.setServiceType(serviceType);
    int key = putListener(listener, s);
    mAsyncChannel.sendMessage(DISCOVER_SERVICES, 0, key, s);
}",1,"/**
 * Initiate service discovery to browse for instances of a service type. Service discovery
 * consumes network bandwidth and will continue until the application calls
 * {@link #stopServiceDiscovery}.
 *
 * <p> The function call immediately returns after sending a request to start service
 * discovery to the framework. The application is notified of a success to initiate
 * discovery through the callback {@link DiscoveryListener#onDiscoveryStarted} or a failure
 * through {@link DiscoveryListener#onStartDiscoveryFailed}.
 *
 * <p> Upon successful start, application is notified when a service is found with
 * {@link DiscoveryListener#onServiceFound} or when a service is lost with
 * {@link DiscoveryListener#onServiceLost}.
 *
 * <p> Upon failure to start, service discovery is not active and application does
 * not need to invoke {@link #stopServiceDiscovery}
 *
 * <p> The application should call {@link #stopServiceDiscovery} when discovery of this
 * service type is no longer required, and/or whenever the application is paused or
 * stopped.
 *
 * @param serviceType The service type being discovered. Examples include ""_http._tcp"" for
 * http services or ""_ipp._tcp"" for printers
 * @param protocolType The service discovery protocol
 * @param listener  The listener notifies of a successful discovery and is used
 * to stop discovery on this serviceType through a call on {@link #stopServiceDiscovery}.
 * Cannot be null. Cannot be in use for an active service discovery.
 */
","/**
 * Initiate service discovery to browse for instances of a service type. Service discovery
 * consumes network bandwidth and will continue until the application calls
 * {@link #stopServiceDiscovery}.
 *
 * <p> The function call immediately returns after sending a request to start service
 * discovery to the framework. The application is notified of a success to initiate
 * discovery through the callback {@link DiscoveryListener#onDiscoveryStarted} or a failure
 * through {@link DiscoveryListener#onStartDiscoveryFailed}.
 *
 * <p> Upon successful start, application is notified when a service is found with
 * {@link DiscoveryListener#onServiceFound} or when a service is lost with
 * {@link DiscoveryListener#onServiceLost}.
 *
 * <p> Upon failure to start, service discovery is not active and application does
 * not need to invoke {@link #stopServiceDiscovery}
 *
 * <p> The application should call {@link #stopServiceDiscovery} when discovery of this
 * service type is no longer required, and/or whenever the application is paused or
 * stopped.
 *
 * @param serviceType The service type being discovered. Examples include ""_http._tcp"" for
 * http services or ""_ipp._tcp"" for printers
 * @param protocolType The service discovery protocol
 * @param listener  The listener notifies of a successful discovery and is used
 * to stop discovery on this serviceType through a call on {@link #stopServiceDiscovery}.
 * Cannot be null. Cannot be in use for an active service discovery.
 */
",0,,,0,,,,,,,"2,3,4,5",2,"The early implementation directly contains checks and throws IllegalArgumentException while the late implementation uses helper methods (checkStringNotEmpty and checkProtocol), indicating changes in exception handling statements and control dependency. Also, the removal of the check for listener being null and protocolType having specific value involves other statements and dependent API changes as helper methods were not present before. So the code change type is 2,3,4,5.","The changes in exception handling, where checks have been moved to helper methods and removal of null listener check, may result in different exceptions being thrown under the same conditions, leading to a compatibility issue of type 2."
38,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,26,27,,,,"{
    return new TextClassification(mText, mIcon, mLabel, mIntent, mOnClickListener, mEntityConfidence, mLogType);
}","{
    return new TextClassification(mText, mIcon, mLabel, mIntent, mOnClickListener, mEntityConfidence, mLogType, mVersionInfo);
}",1,"/**
 * Builds and returns a {@link TextClassification} object.
 */
","/**
 * Builds and returns a {@link TextClassification} object.
 */
",0,,,0,,,,,,,"1,5",1,"The constructor call for TextClassification in the return statement has an additional parameter (mVersionInfo) in the late version, indicating that a dependent API (constructor of TextClassification) has changed. This results in the code change types 1 and 5.","Since the constructor call now includes an additional parameter, it leads to a potential different return value. The additional parameter might carry new information or change the behavior of the created TextClassification object. Therefore, the CI type is 1."
39,<android.app.ActivityThread.H: String codeToString(int)>,26,27,,,,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case ACTIVITY_MOVED_TO_DISPLAY:
                return ""ACTIVITY_MOVED_TO_DISPLAY"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case CANCEL_VISIBLE_BEHIND:
                return ""CANCEL_VISIBLE_BEHIND"";
            case BACKGROUND_VISIBLE_BEHIND_CHANGED:
                return ""BACKGROUND_VISIBLE_BEHIND_CHANGED"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case MULTI_WINDOW_MODE_CHANGED:
                return ""MULTI_WINDOW_MODE_CHANGED"";
            case PICTURE_IN_PICTURE_MODE_CHANGED:
                return ""PICTURE_IN_PICTURE_MODE_CHANGED"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case ACTIVITY_MOVED_TO_DISPLAY:
                return ""ACTIVITY_MOVED_TO_DISPLAY"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case MULTI_WINDOW_MODE_CHANGED:
                return ""MULTI_WINDOW_MODE_CHANGED"";
            case PICTURE_IN_PICTURE_MODE_CHANGED:
                return ""PICTURE_IN_PICTURE_MODE_CHANGED"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
        }
    }
    return Integer.toString(code);
}",1,,,0,,,0,,,,,,,,,,
41,<android.app.FragmentManagerImpl: void attachFragment(Fragment)>,26,27,,,,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + fragment);
    if (fragment.mDetached) {
        fragment.mDetached = false;
        if (!fragment.mAdded) {
            if (mAdded == null) {
                mAdded = new ArrayList<Fragment>();
            }
            if (mAdded.contains(fragment)) {
                throw new IllegalStateException(""Fragment already added: "" + fragment);
            }
            if (DEBUG)
                Log.v(TAG, ""add from attach: "" + fragment);
            synchronized (mAdded) {
                mAdded.add(fragment);
            }
            fragment.mAdded = true;
            if (fragment.mHasMenu && fragment.mMenuVisible) {
                mNeedMenuInvalidate = true;
            }
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + fragment);
    if (fragment.mDetached) {
        fragment.mDetached = false;
        if (!fragment.mAdded) {
            if (mAdded.contains(fragment)) {
                throw new IllegalStateException(""Fragment already added: "" + fragment);
            }
            if (DEBUG)
                Log.v(TAG, ""add from attach: "" + fragment);
            synchronized (mAdded) {
                mAdded.add(fragment);
            }
            fragment.mAdded = true;
            if (fragment.mHasMenu && fragment.mMenuVisible) {
                mNeedMenuInvalidate = true;
            }
        }
    }
}",1,,,0,,,0,,,,,,,0,0,"There is no change between the early version and the late version of the method's implementation, so the code change type is 0.","As there are no changes in the method's implementation, there's no potential for Compatibility Issues, so the CI type is 0."
42,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,26,27,,,,"{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    final String datePattern = DateFormat.getBestDateTimePattern(locale, ""EMMMd"");
    mMonthDayFormat = new SimpleDateFormat(datePattern, locale);
    mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);
    mYearFormat = new SimpleDateFormat(""y"", locale);
    // Update the header text.
    onCurrentDateChanged(false);
}","{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    mMonthDayFormat = DateFormat.getInstanceForSkeleton(""EMMMd"", locale);
    mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);
    mYearFormat = DateFormat.getInstanceForSkeleton(""y"", locale);
    // Update the header text.
    onCurrentDateChanged(false);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,5",0,"The implementation of the date formatter initialization has changed from using `new SimpleDateFormat` to using `DateFormat.getInstanceForSkeleton`. Additionally, the dependent API being called has changed from `DateFormat.getBestDateTimePattern` and `new SimpleDateFormat` to `DateFormat.getInstanceForSkeleton`. Thus, the change types are 1 and 5.","Although the formatter's creation method has changed, the change is internal and does not affect the API's overall outward behavior or how exceptions are thrown. The method signature has not changed, and the formatter's purpose remains the same, so there is no Compatibility Issue as the returned values should stay consistent based on the locale provided."
43,<android.app.Activity: void onCreate(Bundle)>,26,27,,,,"{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, ""onCreate "" + this + "": "" + savedInstanceState);
    if (getApplicationInfo().targetSdkVersion > O && mActivityInfo.isFixedOrientation()) {
        final TypedArray ta = obtainStyledAttributes(com.android.internal.R.styleable.Window);
        final boolean isTranslucentOrFloating = ActivityInfo.isTranslucentOrFloating(ta);
        ta.recycle();
        if (isTranslucentOrFloating) {
            throw new IllegalStateException(""Only fullscreen opaque activities can request orientation"");
        }
    }
    if (mLastNonConfigurationInstances != null) {
        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);
    }
    if (mActivityInfo.parentActivityName != null) {
        if (mActionBar == null) {
            mEnableDefaultActionBarUp = true;
        } else {
            mActionBar.setDefaultDisplayHomeAsUpEnabled(true);
        }
    }
    if (savedInstanceState != null) {
        mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, false);
        mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID, View.LAST_APP_AUTOFILL_ID);
        if (mAutoFillResetNeeded) {
            getAutofillManager().onCreate(savedInstanceState);
        }
        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
        mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null);
    }
    mFragments.dispatchCreate();
    getApplication().dispatchActivityCreated(this, savedInstanceState);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.attachActivity(this);
    }
    mCalled = true;
}","{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, ""onCreate "" + this + "": "" + savedInstanceState);
    if (mLastNonConfigurationInstances != null) {
        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);
    }
    if (mActivityInfo.parentActivityName != null) {
        if (mActionBar == null) {
            mEnableDefaultActionBarUp = true;
        } else {
            mActionBar.setDefaultDisplayHomeAsUpEnabled(true);
        }
    }
    if (savedInstanceState != null) {
        mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, false);
        mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID, View.LAST_APP_AUTOFILL_ID);
        if (mAutoFillResetNeeded) {
            getAutofillManager().onCreate(savedInstanceState);
        }
        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
        mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null);
    }
    mFragments.dispatchCreate();
    getApplication().dispatchActivityCreated(this, savedInstanceState);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.attachActivity(this);
    }
    mRestoredFromBundle = savedInstanceState != null;
    mCalled = true;
}",1,"/**
 * Called when the activity is starting.  This is where most initialization
 * should go: calling {@link #setContentView(int)} to inflate the
 * activity's UI, using {@link #findViewById} to programmatically interact
 * with widgets in the UI, calling
 * {@link #managedQuery(android.net.Uri , String[], String, String[], String)} to retrieve
 * cursors for data being displayed, etc.
 *
 * <p>You can call {@link #finish} from within this function, in
 * which case onDestroy() will be immediately called without any of the rest
 * of the activity lifecycle ({@link #onStart}, {@link #onResume},
 * {@link #onPause}, etc) executing.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @param savedInstanceState If the activity is being re-initialized after
 * previously being shut down then this Bundle contains the data it most
 * recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
 *
 * @see #onStart
 * @see #onSaveInstanceState
 * @see #onRestoreInstanceState
 * @see #onPostCreate
 */
","/**
 * Called when the activity is starting.  This is where most initialization
 * should go: calling {@link #setContentView(int)} to inflate the
 * activity's UI, using {@link #findViewById} to programmatically interact
 * with widgets in the UI, calling
 * {@link #managedQuery(android.net.Uri , String[], String, String[], String)} to retrieve
 * cursors for data being displayed, etc.
 *
 * <p>You can call {@link #finish} from within this function, in
 * which case onDestroy() will be immediately called without any of the rest
 * of the activity lifecycle ({@link #onStart}, {@link #onResume},
 * {@link #onPause}, etc) executing.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @param savedInstanceState If the activity is being re-initialized after
 * previously being shut down then this Bundle contains the data it most
 * recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
 *
 * @see #onStart
 * @see #onSaveInstanceState
 * @see #onRestoreInstanceState
 * @see #onPostCreate
 */
",0,"[@MainThread, @CallSuper]","[@MainThread, @CallSuper]",0,,,,,,,"1,2,3,4","1,2","The code block that checked the targetSdkVersion and threw an IllegalStateException has been removed, along with its related control dependency and exception handling. Additionally, the statement that sets 'mRestoredFromBundle' has been added. The change type is a combination of return statement change (due to removed throw), exception handling statement change (due to removed catch), control dependency change (because the if statement and its block have been removed), and other statement changed (the addition of mRestoredFromBundle assignment). ","The removal of the IllegalStateException throw potentially leads to a different exception being thrown in the case where this condition was previously met, and the addition of 'mRestoredFromBundle = savedInstanceState != null;' introduces a new variable assignment behavior when savedInstanceState is not null. Therefore, both the return values (through the absence of an exception) and the exception handling behaviors can differ, leading to CI type 1 (for the return value) and 2 (for the exception handling)."
45,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",26,27,,,,"{
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    synchronized (this) {
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }
    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    // dummy, will hold length
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos = parcel.dataPosition();
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();
    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}","{
    // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first.
    if (parcel.hasReadWriteHelper()) {
        unparcel();
    }
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    synchronized (this) {
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }
    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    // dummy, will hold length
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos = parcel.dataPosition();
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();
    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",0,,,0,,,,,,,4,0,"The only code change is the addition of a check for `parcel.hasReadWriteHelper()` and a call to `unparcel()`, which is an implementation detail and not directly related to the logical control flow of the data being written to the parcel, so the change type is 4.","This change should not cause a Compatibility Issue, as the underlying data structure written to the parcel remains unchanged. The logic affects the internal representation and how the data is obtained before writing but not the actual content written to the parcel. Thus, the API's behavioral contract remains consistent between the versions, and there is no CI."
47,"<android.view.ViewRootImpl.SendWindowContentChangedAccessibilityEvent: void runOrPost(View,int)>",26,27,,,,"{
    if (mSource != null) {
        // If there is no common predecessor, then mSource points to
        // a removed view, hence in this case always prefer the source.
        View predecessor = getCommonPredecessor(mSource, source);
        mSource = (predecessor != null) ? predecessor : source;
        mChangeTypes |= changeType;
        return;
    }
    mSource = source;
    mChangeTypes = changeType;
    final long timeSinceLastMillis = SystemClock.uptimeMillis() - mLastEventTimeMillis;
    final long minEventIntevalMillis = ViewConfiguration.getSendRecurringAccessibilityEventsInterval();
    if (timeSinceLastMillis >= minEventIntevalMillis) {
        mSource.removeCallbacks(this);
        run();
    } else {
        mSource.postDelayed(this, minEventIntevalMillis - timeSinceLastMillis);
    }
}","{
    if (mHandler.getLooper() != Looper.myLooper()) {
        CalledFromWrongThreadException e = new CalledFromWrongThreadException(""Only the "" + ""original thread that created a view hierarchy can touch its views."");
        // TODO: Throw the exception
        Log.e(TAG, ""Accessibility content change on non-UI thread. Future Android "" + ""versions will throw an exception."", e);
        // Attempt to recover. This code does not eliminate the thread safety issue, but
        // it should force any issues to happen near the above log.
        mHandler.removeCallbacks(this);
        if (mSource != null) {
            // Dispatch whatever was pending. It's still possible that the runnable started
            // just before we removed the callbacks, and bad things will happen, but at
            // least they should happen very close to the logged error.
            run();
        }
    }
    if (mSource != null) {
        // If there is no common predecessor, then mSource points to
        // a removed view, hence in this case always prefer the source.
        View predecessor = getCommonPredecessor(mSource, source);
        mSource = (predecessor != null) ? predecessor : source;
        mChangeTypes |= changeType;
        return;
    }
    mSource = source;
    mChangeTypes = changeType;
    final long timeSinceLastMillis = SystemClock.uptimeMillis() - mLastEventTimeMillis;
    final long minEventIntevalMillis = ViewConfiguration.getSendRecurringAccessibilityEventsInterval();
    if (timeSinceLastMillis >= minEventIntevalMillis) {
        removeCallbacksAndRun();
    } else {
        mHandler.postDelayed(this, minEventIntevalMillis - timeSinceLastMillis);
    }
}",1,,,0,,,0,,,,,,,"2,3,4",2,"There is a new control structure (if statement) added, which performs a check on the thread looper, an other statement related to logging an error, and a new exception handling statement is prepared but not thrown. Thus, the change types are 2 for exception handling, 3 for the control dependency change (new if statement), and 4 for the new log statement.","In the late implementation, an error is logged if a non-UI thread attempts to post an accessibility content change, which might lead to a different behavior (exception thrown) in future versions of Android. This introduces a different exception handling mechanism, but since the exception is not actually thrown, it does not lead to an immediate CI. However, the log statement and the potential for a different exception in the future indicate that there is a potential for an exception handling difference, hence a CI of type 2 is present."
50,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>",26,27,,,,"{
    Log.d(TAG, ""onScannerRegistered() - status="" + status + "" scannerId="" + scannerId + "" mScannerId="" + mScannerId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mScannerId == -1) {
                    // Registration succeeds after timeout, unregister client.
                    mBluetoothGatt.unregisterClient(scannerId);
                } else {
                    mScannerId = scannerId;
                    mBluetoothGatt.startScan(mScannerId, mSettings, mFilters, mResultStorages, ActivityThread.currentOpPackageName());
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mScannerId = -1;
            }
        } else {
            // registration failed
            mScannerId = -1;
        }
        notifyAll();
    }
}","{
    Log.d(TAG, ""onScannerRegistered() - status="" + status + "" scannerId="" + scannerId + "" mScannerId="" + mScannerId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mScannerId == -1) {
                    // Registration succeeds after timeout, unregister client.
                    mBluetoothGatt.unregisterClient(scannerId);
                } else {
                    mScannerId = scannerId;
                    mBluetoothGatt.startScan(mScannerId, mSettings, mFilters, mResultStorages, ActivityThread.currentOpPackageName());
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mScannerId = -1;
            }
        } else if (status == ScanCallback.SCAN_FAILED_SCANNING_TOO_FREQUENTLY) {
            // applicaiton was scanning too frequently
            mScannerId = -2;
        } else {
            // registration failed
            mScannerId = -1;
        }
        notifyAll();
    }
}",1,"/**
 * Application interface registered - app is ready to go
 */
","/**
 * Application interface registered - app is ready to go
 */
",0,[@Override],[@Override],0,,,,,,,3,1,"The change includes the introduction of a new 'else if' branch in the late implementation to check for a specific status value (ScanCallback.SCAN_FAILED_SCANNING_TOO_FREQUENTLY), which leads to the assignment of a new value to mScannerId (-2 instead of -1). Therefore, the change type is a control dependency change, classified as 3.","The introduction of a new conditional branch that assigns a different value to the field mScannerId under certain conditions (when the status is SCAN_FAILED_SCANNING_TOO_FREQUENTLY) could potentially lead to a different behavior of the API. Clients who rely on the value of mScannerId being set to -1 on failure would now receive a different value (-2) in this specific failure case, which constitutes a potential compatibility issue due to different return values or types hence the CI type is 1."
51,"<android.view.ViewGroup: void notifySubtreeAccessibilityStateChanged(View,View,int)>",26,27,,,,"{
    // from this view. Otherwise, we can let it propagate up.
    if (getAccessibilityLiveRegion() != ACCESSIBILITY_LIVE_REGION_NONE) {
        notifyViewAccessibilityStateChangedIfNeeded(changeType);
    } else if (mParent != null) {
        try {
            mParent.notifySubtreeAccessibilityStateChanged(this, source, changeType);
        } catch (AbstractMethodError e) {
            Log.e(VIEW_LOG_TAG, mParent.getClass().getSimpleName() + "" does not fully implement ViewParent"", e);
        }
    }
}","{
    // from this view. Otherwise, we can let it propagate up.
    if (getAccessibilityLiveRegion() != ACCESSIBILITY_LIVE_REGION_NONE) {
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    } else if (mParent != null) {
        try {
            mParent.notifySubtreeAccessibilityStateChanged(this, source, changeType);
        } catch (AbstractMethodError e) {
            Log.e(VIEW_LOG_TAG, mParent.getClass().getSimpleName() + "" does not fully implement ViewParent"", e);
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change is in the parameter passed to notifyViewAccessibilityStateChangedIfNeeded, from changeType to AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE within the if clause. Therefore, the code change type is 4.","There is no compatibility issue arising from this change because it affects only the constant value used in a method call within the same control flow, and does not affect the external behavior of the method regarding return values or exceptions thrown, so the CI type is 0."
52,<android.hardware.SensorDirectChannel: void finalize()>,26,27,,,,"{
    try {
        mCloseGuard.warnIfOpen();
        close();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"The code change is the addition of an if condition to check for nullity of mCloseGuard before calling warnIfOpen on it, so the change type is 3.","The addition of a null check does not introduce a new behavior in terms of the API’s output or exceptions that it may throw; it only prevents a potential NullPointerException. The original and new implementations both call close() and super.finalize(), and the added check does not affect the output of the finalize method. Therefore, there is no Compatibility Issue, so the CI type is 0."
53,<android.view.autofill.AutofillManager: void commit()>,26,27,,,,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled && mSessionId == NO_SESSION) {
            return;
        }
        finishSessionLocked();
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled && !isActiveLocked()) {
            return;
        }
        finishSessionLocked();
    }
}",1,"/**
 * Called to indicate the current autofill context should be commited.
 *
 * <p>For example, when a virtual view is rendering an {@code HTML} page with a form, it should
 * call this method after the form is submitted and another page is rendered.
 */
","/**
 * Called to indicate the current autofill context should be commited.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method after the form is submitted and
 * another page is rendered.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
",1,,,0,,,,,,,"3, 5",0,"The conditional check within the synchronized block has changed from checking `mSessionId == NO_SESSION` to calling `!isActiveLocked()`. This implies that the control flow could be different based on the implementation of `isActiveLocked()`. There's also a possible dependent API change if the behavior of `isActiveLocked()` differs from the direct comparison `mSessionId == NO_SESSION`. Thus, the code change type is 3, 5.","Although there is a control dependency change and a dependent API change, this method (`commit()`) does not return any value nor does it throw any checked exceptions. The change inside the synchronized block pertains to internal state checks before performing an operation (finish a session), which will not lead to a different return value or type, nor does it change the exceptions thrown since the method is defined to return void and the exception handling did not change. The behavioral change is internal and doesn't affect the outward contract of the method. Therefore, there is no Compatibility Issue based on the information provided, hence CI type is 0."
55,<android.text.style.TextAppearanceSpan: String getFamily()>,26,27,,,,"{
    return mTypeface;
}","{
    return mFamilyName;
}",1,"/**
 * Returns the typeface family specified by this span, or <code>null</code>
 * if it does not specify one.
 */
","/**
 * Returns the typeface family specified by this span, or <code>null</code>
 * if it does not specify one.
 */
",0,,,0,,,,,,,1,1,"The return statement has changed from returning mTypeface to returning mFamilyName, which implies a change in the value that the method returns, so the code change type is 1.","The change in what the return statement returns (mTypeface vs. mFamilyName), this could potentially lead to the method returning a different value. Therefore, the Compatibility Issue type is 1."
56,<android.net.IpSecManager.SecurityParameterIndex: void close()>,26,27,,,,"{
    mSpi = INVALID_SECURITY_PARAMETER_INDEX;
    mCloseGuard.close();
}","{
    try {
        mService.releaseSecurityParameterIndex(mResourceId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    mCloseGuard.close();
}",1,"/**
 * Release an SPI that was previously reserved.
 *
 * <p>Release an SPI for use by other users in the system. If a SecurityParameterIndex is
 * applied to an IpSecTransform, it will become unusable for future transforms but should
 * still be closed to ensure system resources are released.
 */
","/**
 * Release an SPI that was previously reserved.
 *
 * <p>Release an SPI for use by other users in the system. If a SecurityParameterIndex is
 * applied to an IpSecTransform, it will become unusable for future transforms but should
 * still be closed to ensure system resources are released.
 */
",0,[@Override],[@Override],0,,,,,,,"2,5",2,"The method implementation has completely changed by adding a try-catch block with a new method call (mService.releaseSecurityParameterIndex(mResourceId)) and exception handling (throw e.rethrowFromSystemServer()), which was not there in the early version. The change type is 2 for the exception handling and 5 because a method call to another API (mService.releaseSecurityParameterIndex) is added.","The late implementation introduces a new exception handling mechanism that can throw an exception under different circumstances than the early version, which did not throw any exception. Therefore, the CI type is 2, as there is a potential different exception handling introduced."
58,<android.app.ActivityThread.ActivityClientRecord: String getStateString()>,26,27,,,,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""ActivityClientRecord{"");
    sb.append(""paused="").append(paused);
    sb.append("", stopped="").append(stopped);
    sb.append("", hideForNow="").append(hideForNow);
    sb.append("", startsNotResumed="").append(startsNotResumed);
    sb.append("", isForward="").append(isForward);
    sb.append("", pendingConfigChanges="").append(pendingConfigChanges);
    sb.append("", onlyLocalRequest="").append(onlyLocalRequest);
    sb.append("", preserveWindow="").append(mPreserveWindow);
    if (activity != null) {
        sb.append("", Activity{"");
        sb.append(""resumed="").append(activity.mResumed);
        sb.append("", stopped="").append(activity.mStopped);
        sb.append("", finished="").append(activity.isFinishing());
        sb.append("", destroyed="").append(activity.isDestroyed());
        sb.append("", startedActivity="").append(activity.mStartedActivity);
        sb.append("", temporaryPause="").append(activity.mTemporaryPause);
        sb.append("", changingConfigurations="").append(activity.mChangingConfigurations);
        sb.append("", visibleBehind="").append(activity.mVisibleBehind);
        sb.append(""}"");
    }
    sb.append(""}"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""ActivityClientRecord{"");
    sb.append(""paused="").append(paused);
    sb.append("", stopped="").append(stopped);
    sb.append("", hideForNow="").append(hideForNow);
    sb.append("", startsNotResumed="").append(startsNotResumed);
    sb.append("", isForward="").append(isForward);
    sb.append("", pendingConfigChanges="").append(pendingConfigChanges);
    sb.append("", onlyLocalRequest="").append(onlyLocalRequest);
    sb.append("", preserveWindow="").append(mPreserveWindow);
    if (activity != null) {
        sb.append("", Activity{"");
        sb.append(""resumed="").append(activity.mResumed);
        sb.append("", stopped="").append(activity.mStopped);
        sb.append("", finished="").append(activity.isFinishing());
        sb.append("", destroyed="").append(activity.isDestroyed());
        sb.append("", startedActivity="").append(activity.mStartedActivity);
        sb.append("", temporaryPause="").append(activity.mTemporaryPause);
        sb.append("", changingConfigurations="").append(activity.mChangingConfigurations);
        sb.append(""}"");
    }
    sb.append(""}"");
    return sb.toString();
}",1,,,0,,,0,,,,,,,4,0,"The only change is the removal of one line appending `"", visibleBehind="").append(activity.mVisibleBehind)` to the StringBuilder, which is an 'other statement changed', so the code change type is 4.","This change only affects the content of the string being built and returned. It does not change the behavior of the method in terms of different values or types being returned nor does it introduce any new exception handling. Therefore, there is no Compatibility Issue; hence, CI type is 0."
60,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,26,27,,,,"{
    if (eventType == TYPES_ALL_MASK) {
        return ""TYPES_ALL_MASK"";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_LONG_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SELECTED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_ENTER"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_EXIT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_NOTIFICATION_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_CONTENT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_SELECTION_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SCROLLED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_ANNOUNCEMENT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOWS_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOWS_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_CONTEXT_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_CONTEXT_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_ASSIST_READING_CONTEXT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_ASSIST_READING_CONTEXT"");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}","{
    if (eventType == TYPES_ALL_MASK) {
        return ""TYPES_ALL_MASK"";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        if (eventTypeCount > 0) {
            builder.append("", "");
        }
        builder.append(singleEventTypeToString(eventTypeFlag));
        eventTypeCount++;
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}",1,"/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
","/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
",0,,,0,,,,,,,,,,
61,<android.hardware.radio.RadioManager.ModuleProperties: int hashCode()>,26,27,,,,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + mId;
    result = prime * result + mClassId;
    result = prime * result + ((mImplementor == null) ? 0 : mImplementor.hashCode());
    result = prime * result + ((mProduct == null) ? 0 : mProduct.hashCode());
    result = prime * result + ((mVersion == null) ? 0 : mVersion.hashCode());
    result = prime * result + ((mSerial == null) ? 0 : mSerial.hashCode());
    result = prime * result + mNumTuners;
    result = prime * result + mNumAudioSources;
    result = prime * result + (mIsCaptureSupported ? 1 : 0);
    result = prime * result + Arrays.hashCode(mBands);
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + mId;
    result = prime * result + mServiceName.hashCode();
    result = prime * result + mClassId;
    result = prime * result + ((mImplementor == null) ? 0 : mImplementor.hashCode());
    result = prime * result + ((mProduct == null) ? 0 : mProduct.hashCode());
    result = prime * result + ((mVersion == null) ? 0 : mVersion.hashCode());
    result = prime * result + ((mSerial == null) ? 0 : mSerial.hashCode());
    result = prime * result + mNumTuners;
    result = prime * result + mNumAudioSources;
    result = prime * result + (mIsCaptureSupported ? 1 : 0);
    result = prime * result + Arrays.hashCode(mBands);
    result = prime * result + (mIsBgScanSupported ? 1 : 0);
    result = prime * result + mVendorInfo.hashCode();
    return result;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"The hashCode method's implementation has been altered to include additional fields in the hash computation: `mServiceName`, `mIsBgScanSupported`, and `mVendorInfo`. Since new expressions that affect the value returned by the method have been added, this constitutes a change to the return statement as well as an other statement change since there are new lines of code that do not involve control flow or exception handling.","The changes to the hash code calculation will result in different return values for objects of the `ModuleProperties` class when invoking `hashCode()`. Since hashCode is frequently used in collections such as HashMap and HashSet, the different return values could lead to unexpected behaviors in collections or any other data structures that depend on the object's hash code, hence a Compatibility Issue related to potential different return values."
62,"<android.net.nsd.NsdManager: void registerService(NsdServiceInfo,int,RegistrationListener)>",26,27,,,,"{
    if (TextUtils.isEmpty(serviceInfo.getServiceName()) || TextUtils.isEmpty(serviceInfo.getServiceType())) {
        throw new IllegalArgumentException(""Service name or type cannot be empty"");
    }
    if (serviceInfo.getPort() <= 0) {
        throw new IllegalArgumentException(""Invalid port number"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    if (protocolType != PROTOCOL_DNS_SD) {
        throw new IllegalArgumentException(""Unsupported protocol"");
    }
    int key = putListener(listener, serviceInfo);
    if (key == BUSY_LISTENER_KEY) {
        throw new IllegalArgumentException(""listener already in use"");
    }
    mAsyncChannel.sendMessage(REGISTER_SERVICE, 0, key, serviceInfo);
}","{
    checkArgument(serviceInfo.getPort() > 0, ""Invalid port number"");
    checkServiceInfo(serviceInfo);
    checkProtocol(protocolType);
    int key = putListener(listener, serviceInfo);
    mAsyncChannel.sendMessage(REGISTER_SERVICE, 0, key, serviceInfo);
}",1,"/**
 * Register a service to be discovered by other services.
 *
 * <p> The function call immediately returns after sending a request to register service
 * to the framework. The application is notified of a successful registration
 * through the callback {@link RegistrationListener#onServiceRegistered} or a failure
 * through {@link RegistrationListener#onRegistrationFailed}.
 *
 * <p> The application should call {@link #unregisterService} when the service
 * registration is no longer required, and/or whenever the application is stopped.
 *
 * @param serviceInfo The service being registered
 * @param protocolType The service discovery protocol
 * @param listener The listener notifies of a successful registration and is used to
 * unregister this service through a call on {@link #unregisterService}. Cannot be null.
 * Cannot be in use for an active service registration.
 */
","/**
 * Register a service to be discovered by other services.
 *
 * <p> The function call immediately returns after sending a request to register service
 * to the framework. The application is notified of a successful registration
 * through the callback {@link RegistrationListener#onServiceRegistered} or a failure
 * through {@link RegistrationListener#onRegistrationFailed}.
 *
 * <p> The application should call {@link #unregisterService} when the service
 * registration is no longer required, and/or whenever the application is stopped.
 *
 * @param serviceInfo The service being registered
 * @param protocolType The service discovery protocol
 * @param listener The listener notifies of a successful registration and is used to
 * unregister this service through a call on {@link #unregisterService}. Cannot be null.
 * Cannot be in use for an active service registration.
 */
",0,,,0,,,,,,,"1,3,4,5","1,2","The early implementation contains direct argument checks and throws IllegalArgumentExceptions with specific error messages, whereas the late implementation uses helper methods like checkArgument(), checkServiceInfo(), and checkProtocol() to perform validation. The exception messages may differ due to the use of these methods, there is control dependency change due to change in checks, and the signatures of the helper methods indicate a change in the dependent API. The changes are therefore categorized under types 1, 3, 4, and 5.","The removal of direct exception throwing for some cases and the changes in validation logic can result in different exceptions being thrown and potentially different exception messages. Also, if the newly introduced methods like checkServiceInfo() and checkProtocol() behave differently than the original inline checks (e.g., additional validation logic), they can introduce different behavior that could lead to a change in the return value or type (even though the method is void, the listener behavior could change). So CI types 1 (for return value or type, considering listener callback behaviors) and 2 (for different exceptions) are possible."
64,"<android.hardware.usb.UsbManager: HashMap<String, UsbDevice> getDeviceList()>",26,27,,,,"{
    Bundle bundle = new Bundle();
    try {
        mService.getDeviceList(bundle);
        HashMap<String, UsbDevice> result = new HashMap<String, UsbDevice>();
        for (String name : bundle.keySet()) {
            result.put(name, (UsbDevice) bundle.get(name));
        }
        return result;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    HashMap<String, UsbDevice> result = new HashMap<String, UsbDevice>();
    if (mService == null) {
        return result;
    }
    Bundle bundle = new Bundle();
    try {
        mService.getDeviceList(bundle);
        for (String name : bundle.keySet()) {
            result.put(name, (UsbDevice) bundle.get(name));
        }
        return result;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a HashMap containing all USB devices currently attached.
 * USB device name is the key for the returned HashMap.
 * The result will be empty if no devices are attached, or if
 * USB host mode is inactive or unsupported.
 *
 * @return HashMap containing all connected USB devices.
 */
","/**
 * Returns a HashMap containing all USB devices currently attached.
 * USB device name is the key for the returned HashMap.
 * The result will be empty if no devices are attached, or if
 * USB host mode is inactive or unsupported.
 *
 * @return HashMap containing all connected USB devices.
 */
",0,,,0,,,,,,,"3,4",0,"The new version introduces an if-statement to check whether mService is null and returns the HashMap directly if true. This is both control dependency and other statement change, so the code change type is 3,4.","Although the control dependency has changed, this will not lead to a compatibility issue in terms of different behavior. The introduction of the null check for mService and immediate return of an empty HashMap if mService is null is standard defensive programming. It handles a potential null object reference that was implicitly assumed not to occur in the early version. This change does not affect the method's contract or return type, so the CI type is 0."
65,<android.net.ConnectivityManager: boolean isNetworkTypeValid(int)>,26,27,,,,"{
    return networkType >= 0 && networkType <= MAX_NETWORK_TYPE;
}","{
    return MIN_NETWORK_TYPE <= networkType && networkType <= MAX_NETWORK_TYPE;
}",1,"/**
 * Tests if a given integer represents a valid network type.
 * @param networkType the type to be tested
 * @return a boolean.  {@code true} if the type is valid, else {@code false}
 * @deprecated All APIs accepting a network type are deprecated. There should be no need to
 * validate a network type.
 */
","/**
 * Tests if a given integer represents a valid network type.
 * @param networkType the type to be tested
 * @return a boolean.  {@code true} if the type is valid, else {@code false}
 * @deprecated All APIs accepting a network type are deprecated. There should be no need to
 * validate a network type.
 */
",0,[@Deprecated],[@Deprecated],0,,,,,,,4,0,"The condition in the return statement checks the same range, but the order of the comparisons has been switched. This does not change the logic or output of the function, so the code change type is 4.","Although there is a change in the logic, it does not alter the behavior of the method. The range that is being checked (from MIN_NETWORK_TYPE to MAX_NETWORK_TYPE) remains the same. Therefore, no compatibility issue is introduced, and the CI type is 0."
66,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",26,27,,,,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",0,,,0,,,,,,,"4,5",1,"The constructor call for NetworkStats has an additional parameter 'mFlags' in the late version, so the dependent API constructor for NetworkStats has changed, making the change type 4 and 5.","The addition of the 'mFlags' parameter in the constructor can change the behavior or state of the 'NetworkStats' object being returned by the API. This can potentially lead to a different return value when the method is called, thus the CI type is 1."
67,<android.app.UiAutomation: ParcelFileDescriptor executeShellCommand(String)>,26,27,,,,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    ParcelFileDescriptor source = null;
    ParcelFileDescriptor sink = null;
    try {
        ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
        source = pipe[0];
        sink = pipe[1];
        // Calling out without a lock held.
        mUiAutomationConnection.executeShellCommand(command, sink);
    } catch (IOException ioe) {
        Log.e(LOG_TAG, ""Error executing shell command!"", ioe);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing shell command!"", re);
    } finally {
        IoUtils.closeQuietly(sink);
    }
    return source;
}","{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    ParcelFileDescriptor source = null;
    ParcelFileDescriptor sink = null;
    try {
        ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
        source = pipe[0];
        sink = pipe[1];
        // Calling out without a lock held.
        mUiAutomationConnection.executeShellCommand(command, sink, null);
    } catch (IOException ioe) {
        Log.e(LOG_TAG, ""Error executing shell command!"", ioe);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing shell command!"", re);
    } finally {
        IoUtils.closeQuietly(sink);
    }
    return source;
}",1,"/**
 * Executes a shell command. This method returs a file descriptor that points
 * to the standard output stream. The command execution is similar to running
 * ""adb shell <command>"" from a host connected to the device.
 * <p>
 * <strong>Note:</strong> It is your responsibility to close the retunred file
 * descriptor once you are done reading.
 * </p>
 *
 * @param command The command to execute.
 * @return A file descriptor to the standard output stream.
 */
","/**
 * Executes a shell command. This method returns a file descriptor that points
 * to the standard output stream. The command execution is similar to running
 * ""adb shell <command>"" from a host connected to the device.
 * <p>
 * <strong>Note:</strong> It is your responsibility to close the returned file
 * descriptor once you are done reading.
 * </p>
 *
 * @param command The command to execute.
 * @return A file descriptor to the standard output stream.
 */
",1,,,0,,,,,,,5,0,"The only change in the implementation is an extra null parameter added to the method call mUiAutomationConnection.executeShellCommand(command, sink, null). This change relates to a dependent API and constitutes the code change type of 5.","Since there is only an additional null argument added to the method call and it does not affect the method's return value or exception handling, there is no compatibility issue (CI type is 0)."
69,"<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",26,27,,,,"{
    getSelectionActionModeHelper().onSelectionAction();
    if (mProcessTextIntentActionsHandler.performMenuItemAction(item)) {
        return true;
    }
    Callback customCallback = getCustomCallback();
    if (customCallback != null && customCallback.onActionItemClicked(mode, item)) {
        return true;
    }
    final TextClassification textClassification = getSelectionActionModeHelper().getTextClassification();
    if (TextView.ID_ASSIST == item.getItemId() && textClassification != null) {
        final OnClickListener onClickListener = textClassification.getOnClickListener();
        if (onClickListener != null) {
            onClickListener.onClick(mTextView);
        } else {
            final Intent intent = textClassification.getIntent();
            if (intent != null) {
                TextClassification.createStartActivityOnClickListener(mTextView.getContext(), intent).onClick(mTextView);
            }
        }
        mMetricsLogger.action(MetricsEvent.ACTION_TEXT_SELECTION_MENU_ITEM_ASSIST, textClassification.getLogType());
        stopTextActionMode();
        return true;
    }
    return mTextView.onTextContextMenuItem(item.getItemId());
}","{
    getSelectionActionModeHelper().onSelectionAction(item.getItemId());
    if (mProcessTextIntentActionsHandler.performMenuItemAction(item)) {
        return true;
    }
    Callback customCallback = getCustomCallback();
    if (customCallback != null && customCallback.onActionItemClicked(mode, item)) {
        return true;
    }
    final TextClassification textClassification = getSelectionActionModeHelper().getTextClassification();
    if (TextView.ID_ASSIST == item.getItemId() && textClassification != null) {
        final OnClickListener onClickListener = textClassification.getOnClickListener();
        if (onClickListener != null) {
            onClickListener.onClick(mTextView);
        } else {
            final Intent intent = textClassification.getIntent();
            if (intent != null) {
                TextClassification.createStartActivityOnClickListener(mTextView.getContext(), intent).onClick(mTextView);
            }
        }
        mMetricsLogger.action(MetricsEvent.ACTION_TEXT_SELECTION_MENU_ITEM_ASSIST, textClassification.getLogType());
        stopTextActionMode();
        return true;
    }
    return mTextView.onTextContextMenuItem(item.getItemId());
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,5",0,"The code change involves the method getSelectionActionModeHelper().onSelectionAction(), which in the early implementation takes no arguments and in the late version takes item.getItemId() as an argument, indicating a change in the dependent API. Therefore, the code change type is 3,5.","While the dependent method getSelectionActionModeHelper().onSelectionAction() now takes a new parameter, this change does not affect the return value of the onActionItemClicked(.) method because it does not change any behavior related to what is returned or any exception that is thrown. All other code remains the same, including the return paths and exception handling. Hence, there is no Compatibility Issue, and the CI type is 0."
70,"<android.app.FragmentManagerImpl: void moveToState(int,boolean)>",26,27,,,,"{
    if (mHost == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        boolean loadersRunning = false;
        // Must add them in the proper order. mActive fragments may be out of order
        if (mAdded != null) {
            final int numAdded = mAdded.size();
            for (int i = 0; i < numAdded; i++) {
                Fragment f = mAdded.get(i);
                moveFragmentToExpectedState(f);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        // Now iterate through all active fragments. These will include those that are removed
        // and detached.
        final int numActive = mActive.size();
        for (int i = 0; i < numActive; i++) {
            Fragment f = mActive.valueAt(i);
            if (f != null && (f.mRemoving || f.mDetached) && !f.mIsNewlyAdded) {
                moveFragmentToExpectedState(f);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        if (!loadersRunning) {
            startPendingDeferredFragments();
        }
        if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {
            mHost.onInvalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}","{
    if (mHost == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        boolean loadersRunning = false;
        // Must add them in the proper order. mActive fragments may be out of order
        final int numAdded = mAdded.size();
        for (int i = 0; i < numAdded; i++) {
            Fragment f = mAdded.get(i);
            moveFragmentToExpectedState(f);
            if (f.mLoaderManager != null) {
                loadersRunning |= f.mLoaderManager.hasRunningLoaders();
            }
        }
        // Now iterate through all active fragments. These will include those that are removed
        // and detached.
        final int numActive = mActive.size();
        for (int i = 0; i < numActive; i++) {
            Fragment f = mActive.valueAt(i);
            if (f != null && (f.mRemoving || f.mDetached) && !f.mIsNewlyAdded) {
                moveFragmentToExpectedState(f);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        if (!loadersRunning) {
            startPendingDeferredFragments();
        }
        if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {
            mHost.onInvalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}",1,"/**
 * Changes the state of the fragment manager to {@code newState}. If the fragment manager
 * changes state or {@code always} is {@code true}, any fragments within it have their
 * states updated as well.
 *
 * @param newState The new state for the fragment manager
 * @param always If {@code true}, all fragments update their state, even
 * if {@code newState} matches the current fragment manager's state.
 */
","/**
 * Changes the state of the fragment manager to {@code newState}. If the fragment manager
 * changes state or {@code always} is {@code true}, any fragments within it have their
 * states updated as well.
 *
 * @param newState The new state for the fragment manager
 * @param always If {@code true}, all fragments update their state, even
 * if {@code newState} matches the current fragment manager's state.
 */
",0,,,0,,,,,,,0,0,There are no changes between the code in the early version and the late version; they are identical.,No Compatibility Issues could arise since there were no changes made to the method between the two versions.
72,<android.content.ContentResolver.CursorWrapperInner: void finalize()>,26,27,,,,"{
    try {
        mCloseGuard.warnIfOpen();
        close();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"There is the addition of an 'if' check on mCloseGuard before calling mCloseGuard.warnIfOpen(), and there is no change in the control flow regarding the return statement or exception handling. Thus, the changes are 3 for control dependency change and 4 for other statement changes.","These changes should not lead to a Compatibility Issue as they only add a defensive null check before calling warnIfOpen(). The call to close() and the finally block are unaltered, meaning that the behavior related to the finalize method's resource management and finalization should not be affected. There will be no potential different return values or exceptions thrown due to this change, so CI is classified as 0."
73,<android.app.FragmentManagerImpl: Fragment findFragmentByTag(String)>,26,27,,,,"{
    if (mAdded != null && tag != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    if (mActive != null && tag != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.valueAt(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    return null;
}","{
    if (tag != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    if (mActive != null && tag != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.valueAt(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    return null;
}",1,,,0,,,0,,,,,,,3,0,The change is in the control dependency of the first 'if' statement; the condition has been simplified by removing the redundant check for mAdded not being null because the loop over mAdded already implicitly checks for it by iterating from mAdded.size() - 1.,"There is no compatibility issue arising from this change because the condition for accessing mAdded was redundant; therefore, no change in behavior is expected, and the API will return the same value as before."
75,<android.hardware.radio.RadioManager.ProgramInfo: int getChannel()>,26,27,,,,"{
    return mChannel;
}","{
    try {
        return (int) mSelector.getFirstId(ProgramSelector.IDENTIFIER_TYPE_AMFM_FREQUENCY);
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, ""Not an AM/FM program"");
        return 0;
    }
}",1,"/**
 * Main channel expressed in units according to band type.
 * Currently all defined band types express channels as frequency in kHz
 * @return the program channel
 */
","/**
 * Main channel expressed in units according to band type.
 * Currently all defined band types express channels as frequency in kHz
 * @return the program channel
 * @deprecated Use {@link getSelector()} instead.
 */
",1,,[@Deprecated],1,,,,,,,"1,2,5","1,2","There is a new try-catch block with a return statement that relies on a method call (getFirstId) that did not appear in the early version. Moreover, this change includes a different exception handling strategy and return behavior when an exception is caught, and it relies on a potentially different dependent API (getFirstId). Thus the change types are 1,2,5.","The late version introduces a new method of calculating the value to be returned and handles IllegalArgumentException differently, which could potentially return a different value or throw a different exception compared to the early version. The CI is affected by return values (type 1) because of the new calculation method, and by exception handling (type 2) due to the new catch block."
77,<android.os.BaseBundle: void unparcel()>,26,27,,,,"{
    synchronized (this) {
        final Parcel parcelledData = mParcelledData;
        if (parcelledData == null) {
            if (DEBUG)
                Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": no parcelled data"");
            return;
        }
        if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
            Slog.wtf(TAG, ""Attempting to unparcel a Bundle while in transit; this may "" + ""clobber all data inside!"", new Throwable());
        }
        if (isEmptyParcel()) {
            if (DEBUG)
                Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": empty"");
            if (mMap == null) {
                mMap = new ArrayMap<>(1);
            } else {
                mMap.erase();
            }
            mParcelledData = null;
            return;
        }
        int N = parcelledData.readInt();
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": reading "" + N + "" maps"");
        if (N < 0) {
            return;
        }
        ArrayMap<String, Object> map = mMap;
        if (map == null) {
            map = new ArrayMap<>(N);
        } else {
            map.erase();
            map.ensureCapacity(N);
        }
        try {
            parcelledData.readArrayMapInternal(map, N, mClassLoader);
        } catch (BadParcelableException e) {
            if (sShouldDefuse) {
                Log.w(TAG, ""Failed to parse Bundle, but defusing quietly"", e);
                map.erase();
            } else {
                throw e;
            }
        } finally {
            mMap = map;
            parcelledData.recycle();
            mParcelledData = null;
        }
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "" final map: "" + mMap);
    }
}","{
    synchronized (this) {
        final Parcel source = mParcelledData;
        if (source != null) {
            initializeFromParcelLocked(source, /*recycleParcel=*/
            true);
        } else {
            if (DEBUG) {
                Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": no parcelled data"");
            }
        }
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,"1,3,4",1,"The entire implementation of unparcel() has been modified. A new method call initializeFromParcelLocked(source, true) is used in the late version instead of the direct manipulation of ArrayMap as seen in the early version. The control dependency has also changed in the `if` condition check due to the inversion of the condition. The original implementation contained more code including branching conditions and exception handling, which is now entirely absent. Therefore, the changes include return statement, control dependency and other statements which are classified as 1,3,4.","Considering the drastic change in implementation, the late version could potentially return different results than the early version since prior logic and behavior may not be replicated in the new method call. Hence, there could be a potential different return value or type, which is a CI type of 1."
79,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>",26,27,,,,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
            IoUtils.closeQuietly(newState);
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    // Ensure that any side-effect SharedPreferences writes have landed *before*
    // we may be about to rewrite the file out from underneath
    waitForSharedPrefs();
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // And bring live SharedPreferences instances up to date
        reloadSharedPreferences();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
            IoUtils.closeQuietly(newState);
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The code change includes moving the waitForSharedPrefs() method call from the finally block to before creating the BackupDataInput object, and adding a call to reloadSharedPreferences() in the finally block, resulting in the changes of type 3,4.","The method doRestore() has not changed in terms of its control flow as it relates to returning a value or throwing an exception; the method still does not return a value, and the exceptions and their handling remain the same. The method waitForSharedPrefs() being moved and the addition of reloadSharedPreferences() do not directly affect the method's output or the exceptions it might throw. Therefore, no Compatibility Issue is detected."
80,"<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>",26,27,,,,"{
    checkPendingIntent(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}",1,"/**
 * Registers a PendingIntent to be sent when a network is available which satisfies the given
 * {@link NetworkRequest}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)}.
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 */
","/**
 * Registers a PendingIntent to be sent when a network is available which satisfies the given
 * {@link NetworkRequest}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)}.
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 */
",0,[@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)],[@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)],0,,,,,,,"2,4,5",2,"The change includes an alteration in a method call from checkPendingIntent to checkPendingIntentNotNull and an addition of a new exception handling statement for ServiceSpecificException. Hence, the code change type includes 4 for the method call change and 2 for the exception handling change. Additionally, there is a change in a dependent API, as the implementation now depends on the behavior of the newly referenced checkPendingIntentNotNull method, which could be different from the previous checkPendingIntent method, indicating a code change type of 5.","The addition of a new exception handling block could lead to different exception behavior. The new catch block specifically catches ServiceSpecificException and throws a potentially different exception after conversion, which could lead to a CI since clients of the API may now receive a new type of exception, or the parameters of the exception may have changed. Thus, the CI type is 2."
81,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,26,27,,,,"{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, ""text/*"", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, ""UTF-8"");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (SecurityException e) {
            Log.w(""ClipData"", ""Failure opening stream"", e);
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w(""ClipData"", ""Failure loading text"", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // If we couldn't open the URI as a stream, use the URI itself as a textual
        // representation (but not for ""content"", ""android.resource"" or ""file"" schemes).
        final String scheme = uri.getScheme();
        if (SCHEME_CONTENT.equals(scheme) || SCHEME_ANDROID_RESOURCE.equals(scheme) || SCHEME_FILE.equals(scheme)) {
            return """";
        }
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return """";
}","{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        final ContentResolver resolver = context.getContentResolver();
        AssetFileDescriptor descr = null;
        FileInputStream stream = null;
        InputStreamReader reader = null;
        try {
            try {
                // Ask for a stream of the desired type.
                descr = resolver.openTypedAssetFileDescriptor(uri, ""text/*"", null);
            } catch (SecurityException e) {
                Log.w(""ClipData"", ""Failure opening stream"", e);
            } catch (FileNotFoundException | RuntimeException e) {
            // Unable to open content URI as text...  not really an
            // error, just something to ignore.
            }
            if (descr != null) {
                try {
                    stream = descr.createInputStream();
                    reader = new InputStreamReader(stream, ""UTF-8"");
                    // Got it...  copy the stream into a local string and return it.
                    final StringBuilder builder = new StringBuilder(128);
                    char[] buffer = new char[8192];
                    int len;
                    while ((len = reader.read(buffer)) > 0) {
                        builder.append(buffer, 0, len);
                    }
                    return builder.toString();
                } catch (IOException e) {
                    // Something bad has happened.
                    Log.w(""ClipData"", ""Failure loading text"", e);
                    return e.toString();
                }
            }
        } finally {
            IoUtils.closeQuietly(descr);
            IoUtils.closeQuietly(stream);
            IoUtils.closeQuietly(reader);
        }
        // If we couldn't open the URI as a stream, use the URI itself as a textual
        // representation (but not for ""content"", ""android.resource"" or ""file"" schemes).
        final String scheme = uri.getScheme();
        if (SCHEME_CONTENT.equals(scheme) || SCHEME_ANDROID_RESOURCE.equals(scheme) || SCHEME_FILE.equals(scheme)) {
            return """";
        }
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return """";
}",1,"// BEGIN_INCLUDE(coerceToText)
","// BEGIN_INCLUDE(coerceToText)
",0,,,0,,,,,,,,,,
82,<android.service.autofill.FillResponse: String toString()>,26,27,,,,"{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    return new StringBuilder(""FillResponse : [mRequestId="" + mRequestId).append("", datasets="").append(mDatasets).append("", saveInfo="").append(mSaveInfo).append("", clientState="").append(mClientState != null).append("", hasPresentation="").append(mPresentation != null).append("", hasAuthentication="").append(mAuthentication != null).append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds)).append("", ignoredIds="").append(Arrays.toString(mIgnoredIds)).append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    return new StringBuilder(""FillResponse : [mRequestId="" + mRequestId).append("", datasets="").append(mDatasets == null ? ""N/A"" : mDatasets.getList()).append("", saveInfo="").append(mSaveInfo).append("", clientState="").append(mClientState != null).append("", hasPresentation="").append(mPresentation != null).append("", hasAuthentication="").append(mAuthentication != null).append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds)).append("", ignoredIds="").append(Arrays.toString(mIgnoredIds)).append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",0,[@Override],[@Override],0,,,,,,,4,0,"The code change consists of a modification in the StringBuilder appending logic for mDatasets, with a null check and conditional logic to print ""N/A"" if mDatasets is null in the late version. This is an 'Other statement changed,' which is represented by 4.","There is no Compatibility Issue detected. The change only affects the string representation of the object used for debugging purposes and does not affect the API's logic/behavior. The change does not influence return value types, exception handling, or dependencies."
83,"<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>",26,27,,,,"{
    if (mInitialized)
        return;
    mInitialized = true;
    mAppContext = context.getApplicationContext();
    initSched(context, renderProxy);
    initGraphicsStats();
}","{
    if (mInitialized)
        return;
    mInitialized = true;
    mAppContext = context.getApplicationContext();
    initSched(renderProxy);
    initGraphicsStats();
}",1,,,0,,,0,,,,,,,"4,5",0,"The method invocation inside the method body has changed from initSched(context, renderProxy) to initSched(renderProxy), which indicates that the method signature of the dependent API initSched may have changed its parameter list. For that, the change types are 4,5.","However, as there's no return or exception handling statement within the method implementation that's been changed, we do not have a Compatibility Issue since the changes do not affect the return value or the exceptions thrown by the method. Hence the CI type is 0."
87,<android.app.Notification.Builder: Notification build()>,26,27,,,,"{
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.buildStyled(mN);
    }
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (useExistingRemoteView())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    return mN;
}","{
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (useExistingRemoteView())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    return mN;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
",0,,,0,,,,,,,4,0,"There are two method calls added (`mStyle.reduceImageSizes(mContext)` and `mStyle.purgeResources()`) which do not change the return type or control flow related to exception handling. As they are just performing some actions on `mStyle` which seemingly optimize or modify resources without altering the return value or the overall control flow. Hence, the code change is of type 4.","Since these added method calls do not seem to affect the final built Notification object that is returned (there are no changes to the `mN` object in the context of these method calls), no compatibility issue is caused in terms of return values or exceptions. The return value `mN` remains unaffected, and no new exceptions are introduced in the control flow. The changes appear to be internal optimizations/improvements that do not impact the API behavior as observed by the caller. Therefore, the CI type is 0."
88,<android.content.ContentProviderClient: void finalize()>,26,27,,,,"{
    try {
        mCloseGuard.warnIfOpen();
        close();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The introduction of a null-check condition for mCloseGuard before `mCloseGuard.warnIfOpen()` indicates a change of control dependency structure (type 3). Additionally, there is an added null-check control statement which doesn't change the external behavior of the method but does modify its internal logic, so it can also be classified as another statement changed (type 4).","There is no Compatibility Issue because the finalization behavior for external callers remains unchanged. The addition of the null check prevents potential NullPointerException, ensuring that the close operation still occurs, and the call to `super.finalize()` will always be executed. The change does not affect the return type, the returned value, or the exception thrown that could be observed by the external caller."
89,"<android.text.format.Formatter: String formatFileSize(Context,long)>",26,27,,,,"{
    if (context == null) {
        return """";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, 0);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}","{
    return formatFileSize(context, sizeBytes, FLAG_DEFAULT);
}",1,"/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc.
 *
 * <p>As of O, the prefixes are used in their standard meanings in the SI system, so kB = 1000
 * bytes, MB = 1,000,000 bytes, etc.</p>
 *
 * <p class=""note"">In {@link android.os.Build.VERSION_CODES#N} and earlier, powers of 1024 are
 * used instead, with KB = 1024 bytes, MB = 1,048,576 bytes, etc.</p>
 *
 * <p>If the context has a right-to-left locale, the returned string is wrapped in bidi
 * formatting characters to make sure it's displayed correctly if inserted inside a
 * right-to-left string. (This is useful in cases where the unit strings, like ""MB"", are
 * left-to-right, but the locale is right-to-left.)</p>
 *
 * @param context Context to use to load the localized units
 * @param sizeBytes size value to be formatted, in bytes
 * @return formatted string with the number
 */
","/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc.
 *
 * <p>As of O, the prefixes are used in their standard meanings in the SI system, so kB = 1000
 * bytes, MB = 1,000,000 bytes, etc.</p>
 *
 * <p class=""note"">In {@link android.os.Build.VERSION_CODES#N} and earlier, powers of 1024 are
 * used instead, with KB = 1024 bytes, MB = 1,048,576 bytes, etc.</p>
 *
 * <p>If the context has a right-to-left locale, the returned string is wrapped in bidi
 * formatting characters to make sure it's displayed correctly if inserted inside a
 * right-to-left string. (This is useful in cases where the unit strings, like ""MB"", are
 * left-to-right, but the locale is right-to-left.)</p>
 *
 * @param context Context to use to load the localized units
 * @param sizeBytes size value to be formatted, in bytes
 * @return formatted string with the number
 */
",0,,,0,,,,,,,5,0,"The implementation of the method has completely changed to call another method formatFileSize with different parameters. However, this seems like an internal refactoring to another overloaded variant of the same method, which indicates a change in the dependent API, so the code change type is 5.","Despite the change in the implementation, the method's signature and its expected behavior (as judged by the method's name and not inspecting the new dependent API) have remained consistent. Without additional context indicating that the behavior of formatFileSize(context, sizeBytes, FLAG_DEFAULT) is different from the early version's implementation, we cannot conclude that there would be a compatibility issue merely based on the refactoring. Therefore, until proven otherwise, we assume no compatibility issue, and the CI type is 0."
92,<android.app.FragmentManagerImpl: void dispatchPictureInPictureModeChanged(boolean)>,26,27,,,,"{
    if (mAdded == null) {
        return;
    }
    for (int i = mAdded.size() - 1; i >= 0; --i) {
        final Fragment f = mAdded.get(i);
        if (f != null) {
            f.performPictureInPictureModeChanged(isInPictureInPictureMode);
        }
    }
}","{
    for (int i = mAdded.size() - 1; i >= 0; --i) {
        final Fragment f = mAdded.get(i);
        if (f != null) {
            f.performPictureInPictureModeChanged(isInPictureInPictureMode);
        }
    }
}",1,"/**
 * @deprecated use {@link #dispatchPictureInPictureModeChanged(boolean, Configuration)}
 */
","/**
 * @deprecated use {@link #dispatchPictureInPictureModeChanged(boolean, Configuration)}
 */
",0,[@Deprecated],[@Deprecated],0,,,,,,,3,1,"The early version has a conditional check that will return from the method early if mAdded is null, which has been removed in the late version. Therefore, the code change is due to the change in a control dependency, which is classified as type 3.","The removal of the conditional check for a null mAdded list could potentially lead to a NullPointerException if mAdded is null in the late version. As such, this change could cause different behavior of the API by affecting the return value (by potentially throwing an exception where it would have previously returned early), leading to a Compatibility Issue of type 1."
93,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int capture(CaptureRequest,CaptureCallback,Handler)>",26,27,,,,"{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    } else if (request.isReprocess() && !isReprocessable()) {
        throw new IllegalArgumentException(""this capture session cannot handle reprocess "" + ""requests"");
    } else if (request.isReprocess() && request.getReprocessableSessionId() != mId) {
        throw new IllegalArgumentException(""capture request was created for another session"");
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (DEBUG) {
        Log.v(TAG, mIdString + ""capture - request "" + request + "", callback "" + callback + "" handler "" + handler);
    }
    return addPendingSequence(mDeviceImpl.capture(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}","{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    } else if (request.isReprocess() && !isReprocessable()) {
        throw new IllegalArgumentException(""this capture session cannot handle reprocess "" + ""requests"");
    } else if (request.isReprocess() && request.getReprocessableSessionId() != mId) {
        throw new IllegalArgumentException(""capture request was created for another session"");
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            Log.v(TAG, mIdString + ""capture - request "" + request + "", callback "" + callback + "" handler "" + handler);
        }
        return addPendingSequence(mDeviceImpl.capture(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"The addition of the synchronized block on the object mDeviceImpl.mInterfaceLock is a control dependency change (code change type 3), as this modifies the thread-safety of the code by introducing synchronization.","The introduction of the synchronized block does not by itself cause a Compatibility Issue as it does not lead to a change in the API's behavior from the perspective of return values or exceptions. It is a thread-safety enhancement to prevent concurrent access issues. Therefore, there is no Compatibility Issue (CI type 0)."
95,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,26,27,,,,"{
    CameraCharacteristics characteristics = null;
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}","{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"2,4",2,"New checks and exception handling for CameraManagerGlobal.sCameraServiceDisabled have been introduced, which weren't present in the early version of the API. Additionally, a new throw statement has been introduced at the beginning of the method, which throws an IllegalArgumentException if the camera service is disabled on the device. The new exception is of a different type than those thrown in the earlier version. These are considered as ""Other statement changed"" (code change type 4) and ""Exception handling statement changed"" (code change type 2).","The introduction of a new check that can lead to a different exception type (IllegalArgumentException instead of CameraAccessException) being thrown represents a compatibility issue due to the potential different exception handling (CI type 2). Users of the earlier version of this API would not expect an IllegalArgumentException, and thus existing error handling code might not correctly handle this new type of exception."
96,<android.appwidget.AppWidgetHost: void stopListening()>,26,27,,,,"{
    try {
        sService.stopListening(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (sService == null) {
        return;
    }
    try {
        sService.stopListening(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
","/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
",0,,,0,,,,,,,3,0,"The late version introduces a new condition and return statement at the beginning of the method to directly return in case sService is null, which is a control dependency change classified as type 3.","This change does not lead to a CI because the additional return statement only returns early in a scenario where the service is null, which would be a no-op anyway in the early version (no action would be taken if the service is null since it wouldn't be possible to call stopListening on a null reference). There is no difference in behavior in terms of API contract because, in the early version, a NullPointerException would be thrown implicitly by the JVM if sService were null, which would not be a normal expected behavior. The late version makes this behavior explicit and safe by returning early. Consequently, there is no CI for different return values or exception handling."
97,<android.appwidget.AppWidgetHost: int[] getAppWidgetIds()>,26,27,,,,"{
    try {
        if (sService == null) {
            bindService();
        }
        return sService.getAppWidgetIdsForHost(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (sService == null) {
        return new int[0];
    }
    try {
        return sService.getAppWidgetIdsForHost(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Gets a list of all the appWidgetIds that are bound to the current host
 */
","/**
 * Gets a list of all the appWidgetIds that are bound to the current host
 */
",0,,,0,,,,,,,"1,3",1,"The try-catch block has been moved, and a new return statement 'return new int[0]' has been added when 'sService' is null before entering the try-catch block. The changes are related to return statements and the control dependency of the try-catch block, so the code change type is 1,3.","The late version may return an empty array when 'sService' is null, unlike the early version which attempts to bind the service before invoking 'getAppWidgetIdsForHost'. This constitutes a change in the return value under a specific condition, leading to a potential different return value or type, hence the CI type is 1."
98,<android.hardware.usb.UsbManager: UsbAccessory[] getAccessoryList()>,26,27,,,,"{
    try {
        UsbAccessory accessory = mService.getCurrentAccessory();
        if (accessory == null) {
            return null;
        } else {
            return new UsbAccessory[] { accessory };
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null) {
        return null;
    }
    try {
        UsbAccessory accessory = mService.getCurrentAccessory();
        if (accessory == null) {
            return null;
        } else {
            return new UsbAccessory[] { accessory };
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a list of currently attached USB accessories.
 * (in the current implementation there can be at most one)
 *
 * @return list of USB accessories, or null if none are attached.
 */
","/**
 * Returns a list of currently attached USB accessories.
 * (in the current implementation there can be at most one)
 *
 * @return list of USB accessories, or null if none are attached.
 */
",0,,,0,,,,,,,3,0,The late implementation adds a new control dependency that checks if mService is null before attempting to access it. This change is of type 3 (Control dependency changed).,"There is no Compatibility Issue since the additional check for null in the late implementation will prevent a potential NullPointerException that could occur in the early implementation if mService is null. Therefore, the behavior is consistent with no change or an improvement in reliability. The return values are consistent in cases where mService is not null, and for the null case, the early implementation would not execute successfully anyway. Thus, the change does not lead to CI."
99,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,26,27,,,,"{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                performAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                performAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        case MSG_PREPARE_FOR_EXTRA_DATA_REQUEST:
            {
                prepareForExtraDataRequestUiThread(message);
            }
            break;
        case MSG_APP_PREPARATION_FINISHED:
            {
                requestPreparerDoneUiThread(message);
            }
            break;
        case MSG_APP_PREPARATION_TIMEOUT:
            {
                requestPreparerTimeoutUiThread();
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",2,"The late version introduced new case statements for 'MSG_PREPARE_FOR_EXTRA_DATA_REQUEST', 'MSG_APP_PREPARATION_FINISHED', and 'MSG_APP_PREPARATION_TIMEOUT', which are indeed new control flow branches, meaning the code change type is 3. Also, new statements (method calls) are added within these branches, so code change type 4 applies as well.","The new case statements introduce potential new behavior by handling additional message types that were not present before. If the new message types are used, the late version of the API will execute different code that did not exist in the early version. This alteration can potentially lead to a Compatibility Issue due to different exception handlings since the default case throws an exception, and the new cases do not. If one of the new message types is passed to the handleMessage method, the earlier version would throw an IllegalArgumentException, while the later version would not, indicating a CI type 2."
100,<android.os.UserManager: String getUserName()>,26,27,,,,"{
    try {
        return mService.getUserInfo(getUserHandle()).name;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    UserInfo user = getUserInfo(getUserHandle());
    return user == null ? """" : user.name;
}",1,"/**
 * Returns the user name of the user making this call.  This call is only
 * available to applications on the system image; it requires the
 * MANAGE_USERS permission.
 * @return the user name
 */
","/**
 * Returns the user name of the user making this call.  This call is only
 * available to applications on the system image; it requires the
 * MANAGE_USERS permission.
 * @return the user name
 */
",0,,,0,,,,,,,"1,5",1,"The late implementation no longer directly returns the result of a method call chain. Instead, it first stores the result of getUserInfo(getUserHandle()) in a variable and then checks for null before returning the user's name. Additionally, there's no longer a try-catch block to catch RemoteException, and the method getUserInfo() is being used, which might have changed. Hence, the change types are 1,5.","The early version could throw a RemoteException wrapped with rethrowFromSystemServer(), while the late version eliminates the exception handling and adds a null check with a conditional return. This alteration of exception handling and return statement could lead to the API returning different values (an empty string instead of a possible null name in the case of 'user' being null, and no longer wrapping RemoteException into a system error), so the CI type is 1."
101,<android.view.accessibility.AccessibilityNodeInfo: void addAction(int)>,26,27,,,,"{
    enforceNotSealed();
    if ((action & ACTION_TYPE_MASK) != 0) {
        throw new IllegalArgumentException(""Action is not a combination of the standard "" + ""actions: "" + action);
    }
    addLegacyStandardActions(action);
}","{
    enforceNotSealed();
    if ((action & ACTION_TYPE_MASK) != 0) {
        throw new IllegalArgumentException(""Action is not a combination of the standard "" + ""actions: "" + action);
    }
    addStandardActions(action);
}",1,"/**
 * Adds an action that can be performed on the node.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param action The action.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 * @throws IllegalArgumentException If the argument is not one of the standard actions.
 *
 * @deprecated This has been deprecated for {@link #addAction(AccessibilityAction)}
 */
","/**
 * Adds an action that can be performed on the node.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param action The action.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 * @throws IllegalArgumentException If the argument is not one of the standard actions.
 *
 * @deprecated This has been deprecated for {@link #addAction(AccessibilityAction)}
 */
",0,[@Deprecated],[@Deprecated],0,,,,,,,"4,5",0,"The change is replacing the call from addLegacyStandardActions(action) to addStandardActions(action), so the code change type is 4. This is also a change in a dependent API call, so 5 is also applicable.","Since the method's functionality is to add actions and there's no change in the logic which affects what is returned or which exceptions are thrown, there's no Compatibility Issue caused by potential differences in return values or types, nor in exception handling. The change from a legacy to a standard method call is not expected to alter the method's behavior from an API consumer's viewpoint, assuming they both achieve the same purpose – adding actions. Hence, the CI type is 0."
102,<android.hardware.radio.RadioManager.BandConfig: boolean equals(Object)>,26,27,,,,"{
    if (this == obj)
        return true;
    if (!(obj instanceof BandConfig))
        return false;
    BandConfig other = (BandConfig) obj;
    if (mDescriptor != other.getDescriptor())
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof BandConfig))
        return false;
    BandConfig other = (BandConfig) obj;
    BandDescriptor otherDesc = other.getDescriptor();
    if ((mDescriptor == null) != (otherDesc == null))
        return false;
    if (mDescriptor != null && !mDescriptor.equals(otherDesc))
        return false;
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"The comparison logic for mDescriptor has been changed. Previously, it was a simple identity check using !=. In the later version, it includes a null check and uses 'equals' to compare the descriptors, so the change is classified in Return statement changed and Control dependency changed due to the introduction of additional conditional checks.","Because the comparison method for mDescriptor has been changed from a reference identity check to invoking the equals method, the outcomes of the equals function could be different, which could result in the API returning different values when comparing BandConfig objects."
103,"<android.bluetooth.BluetoothHealth: ParcelFileDescriptor getMainChannelFd(BluetoothDevice,BluetoothHealthAppConfiguration)>",26,27,,,,"{
    if (mService != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return mService.getMainChannelFd(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}","{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.getMainChannelFd(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}",1,"/**
 * Get the file descriptor of the main channel associated with the remote device
 * and application configuration.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * <p> Its the responsibility of the caller to close the ParcelFileDescriptor
 * when done.
 *
 * @param device The remote Bluetooth health device
 * @param config The application configuration
 * @return null on failure, ParcelFileDescriptor on success.
 */
","/**
 * Get the file descriptor of the main channel associated with the remote device
 * and application configuration.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * <p> Its the responsibility of the caller to close the ParcelFileDescriptor
 * when done.
 *
 * @param device The remote Bluetooth health device
 * @param config The application configuration
 * @return null on failure, ParcelFileDescriptor on success.
 */
",0,,,0,,,,,,,4,0,"There is a small change where mService is assigned to a new local variable service and then this variable is used instead of directly using mService. However, this doesn't affect the behavior of the program as it's only a change in the reference, not the object it points to, so the code change type is 4.","No Compatibility Issue arises because the semantics of the method has not changed; it still performs the same operations with the same control flow and error handling, so no CI is caused by potential different return values or exception handlings. The outcome of the API invocation should remain unchanged."
104,"<android.text.util.Linkify: boolean addLinks(TextView,int)>",26,27,,,,"{
    if (mask == 0) {
        return false;
    }
    CharSequence t = text.getText();
    if (t instanceof Spannable) {
        if (addLinks((Spannable) t, mask)) {
            addLinkMovementMethod(text);
            return true;
        }
        return false;
    } else {
        SpannableString s = SpannableString.valueOf(t);
        if (addLinks(s, mask)) {
            addLinkMovementMethod(text);
            text.setText(s);
            return true;
        }
        return false;
    }
}","{
    if (mask == 0) {
        return false;
    }
    final Context context = text.getContext();
    final CharSequence t = text.getText();
    if (t instanceof Spannable) {
        if (addLinks((Spannable) t, mask, context)) {
            addLinkMovementMethod(text);
            return true;
        }
        return false;
    } else {
        SpannableString s = SpannableString.valueOf(t);
        if (addLinks(s, mask, context)) {
            addLinkMovementMethod(text);
            text.setText(s);
            return true;
        }
        return false;
    }
}",1,"/**
 * Scans the text of the provided TextView and turns all occurrences of
 * the link types indicated in the mask into clickable links.  If matches
 * are found the movement method for the TextView is set to
 * LinkMovementMethod.
 *
 * @param text TextView whose text is to be marked-up with links
 * @param mask Mask to define which kinds of links will be searched.
 *
 * @return True if at least one link is found and applied.
 */
","/**
 * Scans the text of the provided TextView and turns all occurrences of
 * the link types indicated in the mask into clickable links.  If matches
 * are found the movement method for the TextView is set to
 * LinkMovementMethod.
 *
 * @param text TextView whose text is to be marked-up with links
 * @param mask Mask to define which kinds of links will be searched.
 *
 * @return True if at least one link is found and applied.
 */
",0,,,0,,,,,,,"4,5",0,"The change consists of an added method argument ('context') for the overloaded 'addLinks' method, which modifies the dependent API (the 'addLinks' method being called). There is no change in the control flow, exception handling, or return statements apart from the updated method call, which qualifies the change to be of type 4,5.","There is no compatibility issue in terms of behavior changes to the method as long the updated 'addLinks' method accepts the additional 'context' parameter and continues to behave as expected when the 'mask' and 'text' parameters of this API are the same. The changes are internal to implementation details rather than something that would affect the calling pattern or expected results from this API, thus no CI detected, which is type 0."
105,"<android.content.pm.PackageInstaller: void uninstall(VersionedPackage,IntentSender)>",26,27,,,,"{
    Preconditions.checkNotNull(versionedPackage, ""versionedPackage cannot be null"");
    try {
        mInstaller.uninstall(versionedPackage, mInstallerPackageName, 0, statusReceiver, mUserId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    uninstall(versionedPackage, 0, /*flags*/
    statusReceiver);
}",1,"/**
 * Uninstall the given package with a specific version code, removing it
 * completely from the device. This method is only available to the current
 * ""installer of record"" for the package. If the version code of the package
 * does not match the one passed in the versioned package argument this
 * method is a no-op. Use {@link PackageManager#VERSION_CODE_HIGHEST} to
 * uninstall the latest version of the package.
 *
 * @param versionedPackage The versioned package to uninstall.
 * @param statusReceiver Where to deliver the result.
 */
","/**
 * Uninstall the given package with a specific version code, removing it
 * completely from the device. This method is only available to the current
 * ""installer of record"" for the package. If the version code of the package
 * does not match the one passed in the versioned package argument this
 * method is a no-op. Use {@link PackageManager#VERSION_CODE_HIGHEST} to
 * uninstall the latest version of the package.
 *
 * @param versionedPackage The versioned package to uninstall.
 * @param statusReceiver Where to deliver the result.
 */
",0,"[@RequiresPermission(anyOf = { Manifest.permission.DELETE_PACKAGES, Manifest.permission.REQUEST_DELETE_PACKAGES })]",,1,,,,,,,4,0,"The implementation has changed to calling another overload of the uninstall method within the same class or through inheritance. There's no change in return types, exception handling, or control flow.","There are no changes in the control flow, exception handling, or returned values. The change is internal and does not affect the API's external behavior, so there is no compatibility issue."
106,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getConnectedDevices()>,26,27,,,,"{
    if (VDBG)
        log(""getConnectedDevices()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getConnectedDevices()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,,,0,,,,,,,4,0,The only change in the code is the introduction of a final local variable `service` which is assigned the value of `mService`. This change is an example of refactoring for clarity or code quality improvement and does not affect the method's functionality or behavior. This is classified as 'Other statement changed'.,"Since the refactored code did not alter the return values, exception handling, control flow, or dependent APIs, it does not introduce any compatibility issues. The behavior of the API remains the same before and after the change."
107,<android.app.FragmentManagerImpl: boolean dispatchContextItemSelected(MenuItem)>,26,27,,,,"{
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null) {
                if (f.performContextItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    if (mCurState < Fragment.CREATED) {
        return false;
    }
    for (int i = 0; i < mAdded.size(); i++) {
        Fragment f = mAdded.get(i);
        if (f != null) {
            if (f.performContextItemSelected(item)) {
                return true;
            }
        }
    }
    return false;
}",1,,,0,,,0,,,,,,,3,1,The introduction of a new condition (if (mCurState < Fragment.CREATED)) which results in an early return of 'false' is the reason for the classification as change type 3 (Control dependency change).,"The new condition added at the beginning of the late version could potentially lead to a premature return of 'false' before iterating over the mAdded collection. This is different from the early version, where such a check does not exist, and the iteration would always occur, which could have resulted in 'true' if any Fragment performed the context item selected. Hence, this is a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
108,<android.hardware.usb.UsbManager: boolean hasPermission(UsbDevice)>,26,27,,,,"{
    try {
        return mService.hasDevicePermission(device);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null) {
        return false;
    }
    try {
        return mService.hasDevicePermission(device);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the caller has permission to access the device.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbDevice, PendingIntent)} or
 * by the user choosing the caller as the default application for the device.
 *
 * @param device to check permissions for
 * @return true if caller has permission
 */
","/**
 * Returns true if the caller has permission to access the device.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbDevice, PendingIntent)} or
 * by the user choosing the caller as the default application for the device.
 *
 * @param device to check permissions for
 * @return true if caller has permission
 */
",0,,,0,,,,,,,"1,3",1,"The late version of the implementation introduces a new 'if' condition that checks if mService is null and returns false if the condition is true. This is a control dependency change (3). Furthermore, the introduction of the new 'if' condition means there is a new return statement that returns false when mService is null, so the change also includes a return statement changed (1).","Due to the newly added 'if' check for mService being null, the late version API now has a new behavior where it can return false, whereas the earlier version could throw a NullPointerException if mService were null. This introduces a Compatibility Issue due to potential different return values (1)."
109,"<android.app.FragmentManagerImpl: void dispatchOnFragmentStarted(Fragment,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentStarted(f, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentStarted(this, f);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentStarted(f, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentStarted(this, f);
        }
    }
}",1,,,0,,,0,,,,,,,"1,4",1,"The omission of the conditional return statement, 'if (mLifecycleCallbacks == null) { return; }', results in the code not returning early when 'mLifecycleCallbacks' is null. This is an 'Other statement changed'. The for loop will now execute potentially with 'mLifecycleCallbacks' being null, which would cause a NullPointerException that did not occur in the earlier implementation, this is a 'Return statement changed' as well.","The removal of the conditional return statement could lead to a NullPointerException if 'mLifecycleCallbacks' is null, which changes the behavior of the method and introduces a new exception pathway. Therefore, the CI type is caused by a potential different return value or exception handling, which is type 1."
110,"<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>",26,27,,,,"{
    super.dispatchProvideAutofillStructure(structure, flags);
    if (structure.getChildCount() != 0) {
        return;
    }
    final ChildListForAutoFill children = getChildrenForAutofill(flags);
    final int childrenCount = children.size();
    structure.setChildCount(childrenCount);
    for (int i = 0; i < childrenCount; i++) {
        final View child = children.get(i);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideAutofillStructure(cstructure, flags);
    }
    children.recycle();
}","{
    super.dispatchProvideAutofillStructure(structure, flags);
    if (structure.getChildCount() != 0) {
        return;
    }
    if (!isLaidOut()) {
        Log.v(VIEW_LOG_TAG, ""dispatchProvideAutofillStructure(): not laid out, ignoring "" + mChildrenCount + "" children of "" + getAutofillId());
        return;
    }
    final ChildListForAutoFill children = getChildrenForAutofill(flags);
    final int childrenCount = children.size();
    structure.setChildCount(childrenCount);
    for (int i = 0; i < childrenCount; i++) {
        final View child = children.get(i);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideAutofillStructure(cstructure, flags);
    }
    children.recycle();
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This implementation adds in all child views of the view group, in addition to calling the
 * default {@link View} implementation.
 */
","/**
 * {@inheritDoc}
 *
 * <p>This implementation adds in all child views of the view group, in addition to calling the
 * default {@link View} implementation.
 */
",0,[@Override],[@Override],0,,,,,,,"1,3",1,"The late version introduces a new control structure (an 'if' statement checking whether the view is laid out) and a corresponding return statement when the condition is met, which is not present in the early version. These changes may lead to an early return before dispatching the autofill structure for the children views. So, the change type is 1,3.","With the addition of 'if (!isLaidOut())', the late version has a condition where it would not perform actions it would in the early version, leading to different return behaviours (potentially not providing the autofill structure for the children views). Therefore, the CI type is 1."
111,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,26,27,,,,"{
    if (networkCallback == null || networkCallback.networkRequest == null || networkCallback.networkRequest.requestId == REQUEST_ID_UNSET) {
        throw new IllegalArgumentException(""Invalid NetworkCallback"");
    }
    try {
        // CallbackHandler will release callback when receiving CALLBACK_RELEASED.
        mService.releaseNetworkRequest(networkCallback.networkRequest);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    checkCallbackNotNull(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.networkRequest != null, ""NetworkCallback was not registered"");
        Preconditions.checkArgument(networkCallback.networkRequest != ALREADY_UNREGISTERED, ""NetworkCallback was already unregistered"");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = ALREADY_UNREGISTERED;
    }
}",1,"/**
 * Unregisters callbacks about and possibly releases networks originating from
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and
 * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} calls.
 * If the given {@code NetworkCallback} had previously been used with
 * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request
 * will be disconnected.
 *
 * @param networkCallback The {@link NetworkCallback} used when making the request.
 */
","/**
 * Unregisters a {@code NetworkCallback} and possibly releases networks originating from
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and
 * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} calls.
 * If the given {@code NetworkCallback} had previously been used with
 * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request
 * will be disconnected.
 *
 * Notifications that would have triggered that {@code NetworkCallback} will immediately stop
 * triggering it as soon as this call returns.
 *
 * @param networkCallback The {@link NetworkCallback} used when making the request.
 */
",1,,,0,,,,,,,"2,3,4,5","1,2","The late version introduces a new method `checkCallbackNotNull`, changes the way how network callbacks are handled by introducing new control structures (`synchronized` block along with `for` loops), and alters the exception handling by including it in the new control structure. The late version also modifies how arguments are checked using `Preconditions.checkArgument`. Moreover, there's a modification in how the state of the 'networkCallback' is updated at the end of the method. Thus the change types are a mix of exception handling statement change, control dependency change, other statement changed, and dependent API changed.","The changes could potentially lead to differences in exception handling due to different checks and the rethrowing mechanism, and it could ultimately return different results based on the newly introduced control structures and checks (callbacks released only on successful RPC, the state of 'networkCallback' is set to 'ALREADY_UNREGISTERED'). Therefore, there could be Compatibility Issues both due to potential different return types or values and potential different exception handlings."
112,<android.app.FragmentManagerImpl: Fragment findFragmentById(int)>,26,27,,,,"{
    if (mAdded != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    if (mActive != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.valueAt(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    return null;
}","{
    // First look through added fragments.
    for (int i = mAdded.size() - 1; i >= 0; i--) {
        Fragment f = mAdded.get(i);
        if (f != null && f.mFragmentId == id) {
            return f;
        }
    }
    if (mActive != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.valueAt(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    return null;
}",1,,,0,,,0,,,,,,,0,0,"There are no changes in the implementation or annotation between the early and late versions of the code, so the code change type is 0.","Since there is no change in the implementation, there cannot be a Compatibility Issue; therefore, the CI type is 0."
114,"<android.net.nsd.NsdManager: void resolveService(NsdServiceInfo,ResolveListener)>",26,27,,,,"{
    if (TextUtils.isEmpty(serviceInfo.getServiceName()) || TextUtils.isEmpty(serviceInfo.getServiceType())) {
        throw new IllegalArgumentException(""Service name or type cannot be empty"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    int key = putListener(listener, serviceInfo);
    if (key == BUSY_LISTENER_KEY) {
        throw new IllegalArgumentException(""listener already in use"");
    }
    mAsyncChannel.sendMessage(RESOLVE_SERVICE, 0, key, serviceInfo);
}","{
    checkServiceInfo(serviceInfo);
    int key = putListener(listener, serviceInfo);
    mAsyncChannel.sendMessage(RESOLVE_SERVICE, 0, key, serviceInfo);
}",1,"/**
 * Resolve a discovered service. An application can resolve a service right before
 * establishing a connection to fetch the IP and port details on which to setup
 * the connection.
 *
 * @param serviceInfo service to be resolved
 * @param listener to receive callback upon success or failure. Cannot be null.
 * Cannot be in use for an active service resolution.
 */
","/**
 * Resolve a discovered service. An application can resolve a service right before
 * establishing a connection to fetch the IP and port details on which to setup
 * the connection.
 *
 * @param serviceInfo service to be resolved
 * @param listener to receive callback upon success or failure. Cannot be null.
 * Cannot be in use for an active service resolution.
 */
",0,,,0,,,,,,,"4,5",2,"The code change includes the extraction of the repeated checks on serviceInfo and listener to a new method named checkServiceInfo(). Additionally, the direct throwing of IllegalArgumentException has been removed and now will be potentially thrown inside the checkServiceInfo() method. So the change type is 4 for refactoring and 5 because a dependent API has changed (the new checkServiceInfo method).","This change could potentially lead to different exceptions being thrown. Because checkServiceInfo() method is not provided, we don't know whether it throws the same exceptions as the inlined code in the early version. Therefore, the CI type is 2, implying a potential difference in exception handling."
115,<android.os.MemoryFile: int length()>,26,27,,,,"{
    return mLength;
}","{
    return mSharedMemory.getSize();
}",1,"/**
 * Returns the length of the memory file.
 *
 * @return file length.
 */
","/**
 * Returns the length of the memory file.
 *
 * @return file length.
 */
",0,,,0,,,,,,,"1,5",1,"The method used to obtain the length has been changed from directly returning a field mLength to calling a method mSharedMemory.getSize(), and this implies a dependency on a possibly different API (mSharedMemory.getSize()), so the change types are 1 and 5.","Since the implementation now relies on a different method to determine the length, which in turn could potentially return a different value from the previous direct field access, there is a Compatibility Issue due to a potential difference in the returned value. The CI type is 1."
116,<android.view.ViewRootImpl.SendWindowContentChangedAccessibilityEvent: void run()>,26,27,,,,"{
    // The accessibility may be turned off while we were waiting so check again.
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        mLastEventTimeMillis = SystemClock.uptimeMillis();
        AccessibilityEvent event = AccessibilityEvent.obtain();
        event.setEventType(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
        event.setContentChangeTypes(mChangeTypes);
        mSource.sendAccessibilityEventUnchecked(event);
    } else {
        mLastEventTimeMillis = 0;
    }
    // In any case reset to initial state.
    mSource.resetSubtreeAccessibilityStateChanged();
    mSource = null;
    mChangeTypes = 0;
}","{
    // Protect against re-entrant code and attempt to do the right thing in the case that
    // we're multithreaded.
    View source = mSource;
    mSource = null;
    if (source == null) {
        Log.e(TAG, ""Accessibility content change has no source"");
        return;
    }
    // The accessibility may be turned off while we were waiting so check again.
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        mLastEventTimeMillis = SystemClock.uptimeMillis();
        AccessibilityEvent event = AccessibilityEvent.obtain();
        event.setEventType(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
        event.setContentChangeTypes(mChangeTypes);
        source.sendAccessibilityEventUnchecked(event);
    } else {
        mLastEventTimeMillis = 0;
    }
    // In any case reset to initial state.
    source.resetSubtreeAccessibilityStateChanged();
    mChangeTypes = 0;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The control dependency has changed due to the addition of a local `View source` variable, and protection against re-entrant code, which could affect the order of execution. However, since `mSource` is still used after being checked for `null`, just in a different fashion (the local `source` variable takes its place in actual use), the fundamental flow is not modified. There is also other statement change, because the position of the statement, `mSource = null;` is moved up, but its occurrence is guaranteed as before. Hence, the type of code change is 3 and 4.","There is no Compatibility Issue, since the logical behavior of the code has not changed. The use of a local variable `source` is an internal refactoring to help make code safer against re-entrant calls. The `null` check on `mSource` and the subsequent assignment to a local variable do not alter the externally observable behavior of the method. All actions taken are consistent between versions, and no new return values or exception handlings have been introduced that would affect the API contract. Therefore, the CI type is 0."
117,<android.bluetooth.BluetoothDevice: boolean setPairingConfirmation(boolean)>,26,27,,,,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot set pairing confirmation"");
        return false;
    }
    try {
        return sService.setPairingConfirmation(this, confirm);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot set pairing confirmation"");
        return false;
    }
    try {
        return service.setPairingConfirmation(this, confirm);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Confirm passkey for {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.
 *
 * @return true confirmation has been sent out
 * false for error
 */
","/**
 * Confirm passkey for {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.
 *
 * @return true confirmation has been sent out
 * false for error
 */
",0,[@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)],[@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)],0,,,,,,,0,0,"The only thing that has changed in the implementation is the local variable name from 'sService' to 'service', which does not affect the outward behavior of the method; it's simply a refactoring of internal variable names. There are no changes in return statements, exception handling, or control flow.","There is no Compatibility Issue since the method's behavior, return value, and exception handling remain the same between versions."
118,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,26,27,,,,"{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,,,0,,,,,,,4,0,"The code change indicates a local variable `service` is introduced to reference `mService` before using it. There are no changes to return statements, exception handling, control flow, or the dependent API invocation.","This change does not affect the API's behavior since it only introduces a local variable for code readability or stability but does not alter the logic of the method itself. Thus, there is no Compatibility Issue."
120,<android.os.Parcel: Parcel obtain()>,26,27,,,,"{
    final Parcel[] pool = sOwnedPool;
    synchronized (pool) {
        Parcel p;
        for (int i = 0; i < POOL_SIZE; i++) {
            p = pool[i];
            if (p != null) {
                pool[i] = null;
                if (DEBUG_RECYCLE) {
                    p.mStack = new RuntimeException();
                }
                return p;
            }
        }
    }
    return new Parcel(0);
}","{
    final Parcel[] pool = sOwnedPool;
    synchronized (pool) {
        Parcel p;
        for (int i = 0; i < POOL_SIZE; i++) {
            p = pool[i];
            if (p != null) {
                pool[i] = null;
                if (DEBUG_RECYCLE) {
                    p.mStack = new RuntimeException();
                }
                p.mReadWriteHelper = ReadWriteHelper.DEFAULT;
                return p;
            }
        }
    }
    return new Parcel(0);
}",1,"/**
 * Retrieve a new Parcel object from the pool.
 */
","/**
 * Retrieve a new Parcel object from the pool.
 */
",0,,,0,,,,,,,4,0,"The additional statement 'p.mReadWriteHelper = ReadWriteHelper.DEFAULT;' is introduced. Since this is not in control or exception handling statements and doesn't change the return type nor dependent APIs, the code change type is 4.","The change does not affect the return value or the exceptions thrown by the method; it merely sets a default helper on the parcel before it is returned. Since it doesn't cause the method to behave differently externally in terms of the API contract, there is no compatibility issue introduced, so the CI situation is 0."
121,<android.net.ConnectivityManager.CallbackHandler: void handleMessage(Message)>,26,27,,,,"{
    NetworkRequest request = getObject(message, NetworkRequest.class);
    Network network = getObject(message, Network.class);
    if (DBG) {
        Log.d(TAG, whatToString(message.what) + "" for network "" + network);
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                NetworkCallback callback = getCallback(request, ""PRECHECK"");
                if (callback != null) {
                    callback.onPreCheck(network);
                }
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                NetworkCallback callback = getCallback(request, ""AVAILABLE"");
                if (callback != null) {
                    callback.onAvailable(network);
                }
                break;
            }
        case CALLBACK_LOSING:
            {
                NetworkCallback callback = getCallback(request, ""LOSING"");
                if (callback != null) {
                    callback.onLosing(network, message.arg1);
                }
                break;
            }
        case CALLBACK_LOST:
            {
                NetworkCallback callback = getCallback(request, ""LOST"");
                if (callback != null) {
                    callback.onLost(network);
                }
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                NetworkCallback callback = getCallback(request, ""UNAVAIL"");
                if (callback != null) {
                    callback.onUnavailable();
                }
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCallback callback = getCallback(request, ""CAP_CHANGED"");
                if (callback != null) {
                    NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                    callback.onCapabilitiesChanged(network, cap);
                }
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                NetworkCallback callback = getCallback(request, ""IP_CHANGED"");
                if (callback != null) {
                    LinkProperties lp = getObject(message, LinkProperties.class);
                    callback.onLinkPropertiesChanged(network, lp);
                }
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                NetworkCallback callback = getCallback(request, ""SUSPENDED"");
                if (callback != null) {
                    callback.onNetworkSuspended(network);
                }
                break;
            }
        case CALLBACK_RESUMED:
            {
                NetworkCallback callback = getCallback(request, ""RESUMED"");
                if (callback != null) {
                    callback.onNetworkResumed(network);
                }
                break;
            }
        case CALLBACK_RELEASED:
            {
                final NetworkCallback callback;
                synchronized (sCallbacks) {
                    callback = sCallbacks.remove(request);
                }
                if (callback == null) {
                    Log.e(TAG, ""callback not found for RELEASED message"");
                }
                break;
            }
        case CALLBACK_EXIT:
            {
                break;
            }
        case EXPIRE_LEGACY_REQUEST:
            {
                expireRequest((NetworkCapabilities) message.obj, message.arg1);
                break;
            }
    }
}","{
    if (message.what == EXPIRE_LEGACY_REQUEST) {
        expireRequest((NetworkCapabilities) message.obj, message.arg1);
        return;
    }
    final NetworkRequest request = getObject(message, NetworkRequest.class);
    final Network network = getObject(message, Network.class);
    final NetworkCallback callback;
    synchronized (sCallbacks) {
        callback = sCallbacks.get(request);
    }
    if (DBG) {
        Log.d(TAG, getCallbackName(message.what) + "" for network "" + network);
    }
    if (callback == null) {
        Log.w(TAG, ""callback not found for "" + getCallbackName(message.what) + "" message"");
        return;
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                callback.onPreCheck(network);
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                callback.onAvailable(network);
                break;
            }
        case CALLBACK_LOSING:
            {
                callback.onLosing(network, message.arg1);
                break;
            }
        case CALLBACK_LOST:
            {
                callback.onLost(network);
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                callback.onUnavailable();
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                callback.onCapabilitiesChanged(network, cap);
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onLinkPropertiesChanged(network, lp);
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                callback.onNetworkSuspended(network);
                break;
            }
        case CALLBACK_RESUMED:
            {
                callback.onNetworkResumed(network);
                break;
            }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",0,"The control flow has been refactored, with a new initial condition checking specifically `message.what == EXPIRE_LEGACY_REQUEST` before any other logic proceeds, which indicates a change in the flow of method execution and is a Control dependency change (3). Additionally, an early return is introduced in case of `EXPIRE_LEGACY_REQUEST`, signifying a Return statement change (1). The lookup for the callback and logging behavior has also changed, now happening before the switch statement, affecting Other statement changed (4).","Although there are changes in the implementation, the behavior from the perspective of API clients should remain the same. The switching logic is refactored, but the external behavior (i.e., posts to callbacks) has not been altered. All the cases in the switch statement still invoke the same callback methods as before with the same parameters. Despite the structural changes, these do not cause a change in the API's external behavior, so there is no Compatibility Issue."
123,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult suggestSelection()>,26,27,,,,"{
    trimText();
    final TextSelection sel = mTextClassifier.suggestSelection(mTrimmedText, mRelativeStart, mRelativeEnd, mLocales);
    mSelectionStart = Math.max(0, sel.getSelectionStartIndex() + mTrimStart);
    mSelectionEnd = Math.min(mText.length(), sel.getSelectionEndIndex() + mTrimStart);
    mSelectionTag = sel.getSourceClassifier();
    return classifyText();
}","{
    mHot = true;
    trimText();
    final TextSelection selection = mTextClassifier.suggestSelection(mTrimmedText, mRelativeStart, mRelativeEnd, mLocales);
    // Do not classify new selection boundaries if TextClassifier should be dark launched.
    if (!mTextClassifier.getSettings().isDarkLaunch()) {
        mSelectionStart = Math.max(0, selection.getSelectionStartIndex() + mTrimStart);
        mSelectionEnd = Math.min(mText.length(), selection.getSelectionEndIndex() + mTrimStart);
    }
    return performClassification(selection);
}",1,,,0,[@WorkerThread],[@WorkerThread],0,,,,,,,"1,3,4",1,"There is an introduction of a new expression statement `mHot = true;`, changes in the condition in the 'if' statement and a different method call `performClassification(selection)` instead of `classifyText()`; these are changes of types 3 and 4. The method that is ultimately called to return the result has changed, which is a Return statement changed, so the change type is 1,3,4.","The modification of the method called at the end and the introduction of a conditional check for dark launch changes how the selections are derived and thus results in a different return value. There's a possibility that 'mSelectionStart' and 'mSelectionEnd' might not get updated under certain conditions in late version, whereas they are always updated in the early version. This potentially leads to different return values by affecting the selection result, which is a CI of type 1."
124,"<android.app.LoadedApk.SplitDependencyLoaderImpl: void constructSplit(int,int[],int)>",26,27,,,,"{
    final ArrayList<String> splitPaths = new ArrayList<>();
    if (splitIdx == 0) {
        createOrUpdateClassLoaderLocked(null);
        mCachedClassLoaders[0] = mClassLoader;
        // Never add the base resources here, they always get added no matter what.
        for (int configSplitIdx : configSplitIndices) {
            splitPaths.add(mSplitResDirs[configSplitIdx - 1]);
        }
        mCachedResourcePaths[0] = splitPaths.toArray(new String[splitPaths.size()]);
        return;
    }
    // Since we handled the special base case above, parentSplitIdx is always valid.
    final ClassLoader parent = mCachedClassLoaders[parentSplitIdx];
    mCachedClassLoaders[splitIdx] = ApplicationLoaders.getDefault().getClassLoader(mSplitAppDirs[splitIdx - 1], getTargetSdkVersion(), false, null, null, parent);
    Collections.addAll(splitPaths, mCachedResourcePaths[parentSplitIdx]);
    splitPaths.add(mSplitResDirs[splitIdx - 1]);
    for (int configSplitIdx : configSplitIndices) {
        splitPaths.add(mSplitResDirs[configSplitIdx - 1]);
    }
    mCachedResourcePaths[splitIdx] = splitPaths.toArray(new String[splitPaths.size()]);
}","{
    final ArrayList<String> splitPaths = new ArrayList<>();
    if (splitIdx == 0) {
        createOrUpdateClassLoaderLocked(null);
        mCachedClassLoaders[0] = mClassLoader;
        // Never add the base resources here, they always get added no matter what.
        for (int configSplitIdx : configSplitIndices) {
            splitPaths.add(mSplitResDirs[configSplitIdx - 1]);
        }
        mCachedResourcePaths[0] = splitPaths.toArray(new String[splitPaths.size()]);
        return;
    }
    // Since we handled the special base case above, parentSplitIdx is always valid.
    final ClassLoader parent = mCachedClassLoaders[parentSplitIdx];
    mCachedClassLoaders[splitIdx] = ApplicationLoaders.getDefault().getClassLoader(mSplitAppDirs[splitIdx - 1], getTargetSdkVersion(), false, null, null, parent, mSplitClassLoaderNames[splitIdx - 1]);
    Collections.addAll(splitPaths, mCachedResourcePaths[parentSplitIdx]);
    splitPaths.add(mSplitResDirs[splitIdx - 1]);
    for (int configSplitIdx : configSplitIndices) {
        splitPaths.add(mSplitResDirs[configSplitIdx - 1]);
    }
    mCachedResourcePaths[splitIdx] = splitPaths.toArray(new String[splitPaths.size()]);
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",0,The change includes adding an additional parameter `mSplitClassLoaderNames[splitIdx - 1]` to the method call `ApplicationLoaders.getDefault().getClassLoader(...)`. This classifies as a change in the Other statement (4) and change in Dependent API (5) since a method call has been modified with an additional argument.,"There is no Compatibility Issue detected because the modification to the method call does not affect the behavior of the constructSplit method in ways that would change its return type or the exceptions it might throw. The change does not introduce a new control flow or modify existing returns or exception handling. The API adds an additional parameter to a method call, but since this API does not return a value, and there is no change in exception handling, there is no Compatibility Issue (0)."
127,<android.os.MemoryFile.MemoryInputStream: long skip(long)>,26,27,,,,"{
    if (mOffset + n > mLength) {
        n = mLength - mOffset;
    }
    mOffset += n;
    return n;
}","{
    if (mOffset + n > mSharedMemory.getSize()) {
        n = mSharedMemory.getSize() - mOffset;
    }
    mOffset += n;
    return n;
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",1,"The change is that mLength has been replaced by mSharedMemory.getSize() in the checking condition and assignment of n, so the change type is 4. Since the getSize() method of mSharedMemory is invoked, which is a dependent API, the change type also includes 5.","A different method (getSize()) is now used to determine the amount of data to skip, which can potentially return a different value for the variable n. This can result in the method returning a different value, thus the CI type is 1."
128,<android.hardware.radio.RadioManager.ProgramInfo: int hashCode()>,26,27,,,,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + mChannel;
    result = prime * result + mSubChannel;
    result = prime * result + (mTuned ? 1 : 0);
    result = prime * result + (mStereo ? 1 : 0);
    result = prime * result + (mDigital ? 1 : 0);
    result = prime * result + mSignalStrength;
    result = prime * result + ((mMetadata == null) ? 0 : mMetadata.hashCode());
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + mSelector.hashCode();
    result = prime * result + (mTuned ? 1 : 0);
    result = prime * result + (mStereo ? 1 : 0);
    result = prime * result + (mDigital ? 1 : 0);
    result = prime * result + mFlags;
    result = prime * result + mSignalStrength;
    result = prime * result + ((mMetadata == null) ? 0 : mMetadata.hashCode());
    result = prime * result + mVendorInfo.hashCode();
    return result;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"The hashCode implementation has changed where mChannel and mSubChannel are replaced by mSelector.hashCode(), and mSignalStrength is replaced by mFlags and mVendorInfo.hashCode() added, thus statements other than return, exception handling, and control dependency statements have been altered. This constitutes code change type 4. Since the return value is derived from the member variables contributing to calculating the hashCode, which have changed, this is also a return statement change, type 1.","The implementation change in the calculation of the hashCode will result in different return values for objects that are equivalent in terms of their data fields in the early version compared to the late version. Therefore, there is a Compatibility Issue of type 1 caused by potential different return values."
129,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,26,27,,,,"{
    IBluetooth service = sService;
    if (service == null || isBluetoothEnabled() == false) {
        Log.e(TAG, ""BT not enabled. Cannot fetchUuidsWithSdp"");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    final IBluetooth service = sService;
    if (service == null || !isBluetoothEnabled()) {
        Log.e(TAG, ""BT not enabled. Cannot fetchUuidsWithSdp"");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */
","/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 *
 * @return False if the sanity check fails, True if the process of initiating an ACL connection
 * to the remote device was started.
 */
",1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],0,,,,,,,4,0,"The code change is in the logical negation of the condition: isBluetoothEnabled() == false has been changed to !isBluetoothEnabled(), which is only a syntactical change without affecting the behavior or return values of the API. Thus, the code change type is 4.","There is no Compatibility Issue as the code change does not alter the method's behavior or its return values. The logical condition is essentially the same, just written in a different syntax, which won't affect the outcome of the condition checks."
130,<android.os.Parcel: String readString()>,26,27,,,,"{
    return nativeReadString(mNativePtr);
}","{
    return mReadWriteHelper.readString(this);
}",1,"/**
 * Read a string value from the parcel at the current dataPosition().
 */
","/**
 * Read a string value from the parcel at the current dataPosition().
 */
",0,,,0,,,,,,,5,0,"The internal implementation has changed from using a native method call `nativeReadString(mNativePtr)` to using `mReadWriteHelper.readString(this)`. This is a dependent API change, so the code change type is 5.","Although there is a change in the method used to read the string, as long as the behavior of `mReadWriteHelper.readString(this)` is designed to match what `nativeReadString(mNativePtr)` did, there would be no compatibility issue. There is no evidence given that the replacement of the native method with a helper method invocation changes the return value or the exceptions thrown. Thus, there should be no compatibility issue if the new method is a direct replacement, which means CI type is 0."
132,<android.hardware.radio.RadioManager.ProgramInfo: String toString()>,26,27,,,,"{
    return ""ProgramInfo [mChannel="" + mChannel + "", mSubChannel="" + mSubChannel + "", mTuned="" + mTuned + "", mStereo="" + mStereo + "", mDigital="" + mDigital + "", mSignalStrength="" + mSignalStrength + ((mMetadata == null) ? """" : ("", mMetadata="" + mMetadata.toString())) + ""]"";
}","{
    return ""ProgramInfo [mSelector="" + mSelector + "", mTuned="" + mTuned + "", mStereo="" + mStereo + "", mDigital="" + mDigital + "", mFlags="" + mFlags + "", mSignalStrength="" + mSignalStrength + ((mMetadata == null) ? """" : ("", mMetadata="" + mMetadata.toString())) + ""]"";
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"The string concatenation in the return statement has altered with different fields being concatenated, so the code change type is 1,4.","Since the string concatenation in the return statement has different fields, the returned String representation of the ProgramInfo object will differ between the two versions, so the CI type is 1."
133,<android.app.Activity: void performStop(boolean)>,26,27,,,,"{
    mDoReportFullyDrawn = false;
    mFragments.doLoaderStop(mChangingConfigurations);
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        // destroys hardware resources and causes flicker.
        if (!preserveWindow && mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}","{
    mDoReportFullyDrawn = false;
    mFragments.doLoaderStop(mChangingConfigurations);
    // Disallow entering picture-in-picture after the activity has been stopped
    mCanEnterPictureInPicture = false;
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        // destroys hardware resources and causes flicker.
        if (!preserveWindow && mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}",1,,,0,,,0,,,,,,,4,0,"The only change in the implementations is the addition of the line `mCanEnterPictureInPicture = false;`, which is an assignment statement. Therefore, the code change type is 4.","The change does not affect the return value or the method's behavior related to exceptions. It solely affects internal state management, which does not lead to a compatibility issue. Hence, the CI type is 0."
134,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,26,27,,,,"{
    mHandler.post(() -> mCallback.onDeviceFound(launcher.getIntentSender()));
}","{
    Handler handler = mHandler;
    if (handler == null)
        return;
    handler.post(() -> {
        Callback callback = mCallback;
        if (callback == null)
            return;
        callback.onDeviceFound(launcher.getIntentSender());
    });
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"Control dependency has been introduced as there are now checks for nullability before posting to the handler and before invoking `mCallback.onDeviceFound`. Additionally, there's a refactoring to store the handler and callback in local variables before using them. Hence the code change types are 3 for control dependency change and 4 for other statement changes.","There is no Compatibility Issue as the changes only involve additional null checks and local variable assignments which don't affect the outcome of the method's invocation as long as `mHandler` and `mCallback` are non-null, which is the implicit precondition for both versions. If they're null, the newer version simply avoids NullPointerException. Thus, no CI is induced here (0)."
135,<android.app.ActivityThread.H: void handleMessage(Message)>,26,27,,,,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, ""LAUNCH_ACTIVITY"");
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, false, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                maybeSnapshot();
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY_FINISHING:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, true, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_SHOW:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_HIDE:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            SomeArgs args = (SomeArgs) msg.obj;
            handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true, args.argi3, ""RESUME_ACTIVITY"");
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            mUpdatingSystemConfig = true;
            try {
                handleConfigurationChanged((Configuration) msg.obj, null);
            } finally {
                mUpdatingSystemConfig = false;
            }
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, INVALID_DISPLAY);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_MOVED_TO_DISPLAY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityMovedToDisplay"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case MULTI_WINDOW_MODE_CHANGED:
            handleMultiWindowModeChanged((IBinder) ((SomeArgs) msg.obj).arg1, ((SomeArgs) msg.obj).argi1 == 1, (Configuration) ((SomeArgs) msg.obj).arg2);
            break;
        case PICTURE_IN_PICTURE_MODE_CHANGED:
            handlePictureInPictureModeChanged((IBinder) ((SomeArgs) msg.obj).arg1, ((SomeArgs) msg.obj).argi1 == 1, (Configuration) ((SomeArgs) msg.obj).arg2);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            handleAttachAgent((String) msg.obj);
            break;
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, ""LAUNCH_ACTIVITY"");
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, false, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY_FINISHING:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, true, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_SHOW:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_HIDE:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            SomeArgs args = (SomeArgs) msg.obj;
            handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true, args.argi3, ""RESUME_ACTIVITY"");
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            mUpdatingSystemConfig = true;
            try {
                handleConfigurationChanged((Configuration) msg.obj, null);
            } finally {
                mUpdatingSystemConfig = false;
            }
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, INVALID_DISPLAY);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_MOVED_TO_DISPLAY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityMovedToDisplay"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case MULTI_WINDOW_MODE_CHANGED:
            handleMultiWindowModeChanged((IBinder) ((SomeArgs) msg.obj).arg1, ((SomeArgs) msg.obj).argi1 == 1, (Configuration) ((SomeArgs) msg.obj).arg2);
            break;
        case PICTURE_IN_PICTURE_MODE_CHANGED:
            handlePictureInPictureModeChanged((IBinder) ((SomeArgs) msg.obj).arg1, ((SomeArgs) msg.obj).argi1 == 1, (Configuration) ((SomeArgs) msg.obj).arg2);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            handleAttachAgent((String) msg.obj);
            break;
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,0,,,0,,,,,,,,,,
138,"<android.net.IpSecTransform.Builder: Builder setIpv4Encapsulation(UdpEncapsulationSocket,int)>",26,27,,,,"{
    // TODO: check encap type is valid.
    mConfig.encapType = ENCAP_ESPINUDP;
    // TODO: plug in the encap socket
    mConfig.encapLocalPort = localSocket.getPort();
    mConfig.encapRemotePort = remotePort;
    return this;
}","{
    // TODO: check encap type is valid.
    mConfig.encapType = ENCAP_ESPINUDP;
    mConfig.encapLocalPortResourceId = localSocket.getResourceId();
    mConfig.encapRemotePort = remotePort;
    return this;
}",1,"/**
 * Add UDP encapsulation to an IPv4 transform
 *
 * <p>This option allows IPsec traffic to pass through NAT. Refer to RFC 3947 and 3948 for
 * details on how UDP should be applied to IPsec.
 *
 * @param localSocket a {@link IpSecManager.UdpEncapsulationSocket} for sending and
 * receiving encapsulating traffic.
 * @param remotePort the UDP port number of the remote that will send and receive
 * encapsulated traffic. In the case of IKE, this is likely port 4500.
 */
","/**
 * Add UDP encapsulation to an IPv4 transform
 *
 * <p>This option allows IPsec traffic to pass through NAT. Refer to RFC 3947 and 3948 for
 * details on how UDP should be applied to IPsec.
 *
 * @param localSocket a {@link IpSecManager.UdpEncapsulationSocket} for sending and
 * receiving encapsulating traffic.
 * @param remotePort the UDP port number of the remote that will send and receive
 * encapsulated traffic. In the case of IKE, this is likely port 4500.
 */
",0,,,0,,,,,,,4,0,"Only the line mConfig.encapLocalPort = localSocket.getPort(); is changed to mConfig.encapLocalPortResourceId = localSocket.getResourceId();. Thus, a field is modified but the return type and the control flow of the method are not affected, it's an Other statement changed, so the type is 4.","There is no CI since only the assignment to the internal configuration object is modified, which doesn't directly affect the API's return type, value, or thrown exceptions. The API's behavior is not changed from the caller's perspective since it returns the same Builder object it did in the previous version."
139,<android.bluetooth.BluetoothHeadset: boolean startVoiceRecognition(BluetoothDevice)>,26,27,,,,"{
    if (DBG)
        log(""startVoiceRecognition()"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}","{
    if (DBG)
        log(""startVoiceRecognition()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}",1,"/**
 * Start Bluetooth voice recognition. This methods sends the voice
 * recognition AT command to the headset and establishes the
 * audio connection.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.
 *
 * <p> {@link #EXTRA_STATE} will transition from
 * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when
 * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}
 * in case of failure to establish the audio connection.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected of if the
 * connected headset doesn't support voice recognition
 * or on error, true otherwise
 */
","/**
 * Start Bluetooth voice recognition. This methods sends the voice
 * recognition AT command to the headset and establishes the
 * audio connection.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.
 *
 * <p> {@link #EXTRA_STATE} will transition from
 * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when
 * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}
 * in case of failure to establish the audio connection.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected of if the
 * connected headset doesn't support voice recognition
 * or on error, true otherwise
 */
",0,,,0,,,,,,,4,0,"The code change includes replacing the direct usage of mService with a local variable service, but the behavior of the method does not change as the local variable 'service' points to the same object. Therefore, the code change type is 4.","The change is simply a reference replacement that does not alter the method's logic, exception handling, or return values. Hence, no Compatibility Issue arises, and the CI type is 0."
140,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,26,27,,,,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    return changes;
}",1,,,0,,,0,,,,,,,,,,
141,"<android.app.FragmentManagerImpl: void dispatchOnFragmentPreAttached(Fragment,Context,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentPreAttached(this, f, context);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentPreAttached(this, f, context);
        }
    }
}",1,,,0,,,0,,,,,,,1,0,The conditional null check on mLifecycleCallbacks and the corresponding return statement in the early implementation have been removed in the late version. This means the method no longer has an early exit in cases where mLifecycleCallbacks is null.,"Even though the conditional null check has been removed, a null mLifecycleCallbacks would cause a NullPointerException during the iteration in both the early and late versions. This would result in a consistent exception being thrown in both versions. As such, while there is a code change, it should not affect the method's behavior from an API consumer's standpoint because the exception handling would be implicit due to the null reference, not due to an explicit throw clause. Therefore, this change does not introduce a compatibility issue."
142,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,26,27,,,,"{
    synchronized (this) {
        if (mClosed) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""close - reentering"");
            return;
        }
        if (DEBUG)
            Log.v(TAG, mIdString + ""close - first time"");
        mClosed = true;
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (this) {
            /*
                 * Flush out any repeating request. Since camera is closed, no new requests
                 * can be queued, and eventually the entire request queue will be drained.
                 *
                 * If the camera device was already closed, short circuit and do nothing; since
                 * no more internal device callbacks will fire anyway.
                 *
                 * Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure
                 * the camera. Once that's done, fire #onClosed.
                 */
            try {
                mDeviceImpl.stopRepeating();
            } catch (IllegalStateException e) {
                // OK: Camera device may already be closed, nothing else to do
                // TODO: Fire onClosed anytime we get the device onClosed or the ISE?
                // or just suppress the ISE only and rely onClosed.
                // Also skip any of the draining work if this is already closed.
                // Short-circuit; queue callback immediately and return
                mStateCallback.onClosed(this);
                return;
            } catch (CameraAccessException e) {
                // OK: close does not throw checked exceptions.
                Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e);
            // TODO: call onError instead of onClosed if this happens
            }
        }
    }
    synchronized (this) {
        // If no sequences are pending, fire #onClosed immediately
        mSequenceDrainer.beginDrain();
    }
}","{
    synchronized (mDeviceImpl.mInterfaceLock) {
        if (mClosed) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""close - reentering"");
            return;
        }
        if (DEBUG)
            Log.v(TAG, mIdString + ""close - first time"");
        mClosed = true;
        /*
             * Flush out any repeating request. Since camera is closed, no new requests
             * can be queued, and eventually the entire request queue will be drained.
             *
             * If the camera device was already closed, short circuit and do nothing; since
             * no more internal device callbacks will fire anyway.
             *
             * Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure
             * the camera. Once that's done, fire #onClosed.
             */
        try {
            mDeviceImpl.stopRepeating();
        } catch (IllegalStateException e) {
            // OK: Camera device may already be closed, nothing else to do
            // TODO: Fire onClosed anytime we get the device onClosed or the ISE?
            // or just suppress the ISE only and rely onClosed.
            // Also skip any of the draining work if this is already closed.
            // Short-circuit; queue callback immediately and return
            mStateCallback.onClosed(this);
            return;
        } catch (CameraAccessException e) {
            // OK: close does not throw checked exceptions.
            Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e);
        // TODO: call onError instead of onClosed if this happens
        }
        // If no sequences are pending, fire #onClosed immediately
        mSequenceDrainer.beginDrain();
    }
    if (mInput != null) {
        mInput.release();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"There are changes in the structure of synchronized blocks and the position of code blocks, and also the addition of a new code snippet which releases the input. Since the core logic remains untouched and the new code does not alter the return types or exception handling, these changes are classified under control dependency change (3) and other statement change (4).","Despite the changes in how the locking mechanism is implemented and the addition of input release, these modifications do not impact the behavior of the API in a way that would lead to a potential different return value or different exception handling. The closing process and the try-catch blocks, which are the main operations of the close() method, remain functionally the same. Therefore, there is no Compatibility Issue (0) with respect to the API's execution path with regard to returns and exception handling."
143,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,26,27,,,,"{
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    // Trace this sync instance.  Note, conceptually this should be in
    // SyncStorageEngine.insertStartSyncEvent(), but the trace functions require unique
    // threads in order to track overlapping operations, so we'll do it here for now.
    Trace.traceBegin(Trace.TRACE_TAG_SYNC_MANAGER, mAuthority);
    SyncResult syncResult = new SyncResult();
    ContentProviderClient provider = null;
    try {
        if (isCanceled()) {
            return;
        }
        provider = mContext.getContentResolver().acquireContentProviderClient(mAuthority);
        if (provider != null) {
            AbstractThreadedSyncAdapter.this.onPerformSync(mAccount, mExtras, mAuthority, provider, syncResult);
        } else {
            syncResult.databaseError = true;
        }
    } catch (SecurityException e) {
        AbstractThreadedSyncAdapter.this.onSecurityException(mAccount, mExtras, mAuthority, syncResult);
        syncResult.databaseError = true;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYNC_MANAGER);
        if (provider != null) {
            provider.release();
        }
        if (!isCanceled()) {
            mSyncContext.onFinished(syncResult);
        }
        // that also synchronize accesses to mSyncThreads
        synchronized (mSyncThreadLock) {
            mSyncThreads.remove(mThreadsKey);
        }
    }
}","{
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    if (ENABLE_LOG) {
        Log.d(TAG, ""Thread started"");
    }
    // Trace this sync instance.  Note, conceptually this should be in
    // SyncStorageEngine.insertStartSyncEvent(), but the trace functions require unique
    // threads in order to track overlapping operations, so we'll do it here for now.
    Trace.traceBegin(Trace.TRACE_TAG_SYNC_MANAGER, mAuthority);
    SyncResult syncResult = new SyncResult();
    ContentProviderClient provider = null;
    try {
        if (isCanceled()) {
            if (ENABLE_LOG) {
                Log.d(TAG, ""Already canceled"");
            }
            return;
        }
        if (ENABLE_LOG) {
            Log.d(TAG, ""Calling onPerformSync..."");
        }
        provider = mContext.getContentResolver().acquireContentProviderClient(mAuthority);
        if (provider != null) {
            AbstractThreadedSyncAdapter.this.onPerformSync(mAccount, mExtras, mAuthority, provider, syncResult);
        } else {
            syncResult.databaseError = true;
        }
        if (ENABLE_LOG) {
            Log.d(TAG, ""onPerformSync done"");
        }
    } catch (SecurityException e) {
        if (ENABLE_LOG) {
            Log.d(TAG, ""SecurityException"", e);
        }
        AbstractThreadedSyncAdapter.this.onSecurityException(mAccount, mExtras, mAuthority, syncResult);
        syncResult.databaseError = true;
    } catch (RuntimeException | Error th) {
        if (ENABLE_LOG) {
            Log.d(TAG, ""caught exception"", th);
        }
        throw th;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYNC_MANAGER);
        if (provider != null) {
            provider.release();
        }
        if (!isCanceled()) {
            mSyncContext.onFinished(syncResult);
        }
        // that also synchronize accesses to mSyncThreads
        synchronized (mSyncThreadLock) {
            mSyncThreads.remove(mThreadsKey);
        }
        if (ENABLE_LOG) {
            Log.d(TAG, ""Thread finished"");
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,3,4","1,2","The late version added logging statements (if (ENABLE_LOG) { Log.d(TAG, ""Already canceled""); and others) which are Other statement changed (4). Also, there is a new catch block for `RuntimeException | Error th` introducing a new exception handling statement (2). The control flow was also modified with additional if statements to include the logging, which is a Control dependency changed (3).","The addition of the new catch block for `RuntimeException | Error` may result in these exceptions being explicitly caught and logged, where previously they may have been propagated up the call stack without being caught at this level, which indicates Compatibility Issue caused by potential different exception handlings (2). The additional if statements that check for `ENABLE_LOG` make changes in the behaviors dependent on the log enable state, which can be considered as a change in the behavior causing different return values or actions to occur within the method, indicating Compatibility Issues caused by potential different return values (1)."
144,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void startRegistration()>,26,27,,,,"{
    synchronized (this) {
        // Scan stopped.
        if (mScannerId == -1)
            return;
        try {
            mBluetoothGatt.registerScanner(this, mWorkSource);
            wait(REGISTRATION_CALLBACK_TIMEOUT_MILLIS);
        } catch (InterruptedException | RemoteException e) {
            Log.e(TAG, ""application registeration exception"", e);
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_INTERNAL_ERROR);
        }
        if (mScannerId > 0) {
            mLeScanClients.put(mScanCallback, this);
        } else {
            // subsequent operations can proceed.
            if (mScannerId == 0)
                mScannerId = -1;
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_APPLICATION_REGISTRATION_FAILED);
        }
    }
}","{
    synchronized (this) {
        // Scan stopped.
        if (mScannerId == -1 || mScannerId == -2)
            return;
        try {
            mBluetoothGatt.registerScanner(this, mWorkSource);
            wait(REGISTRATION_CALLBACK_TIMEOUT_MILLIS);
        } catch (InterruptedException | RemoteException e) {
            Log.e(TAG, ""application registeration exception"", e);
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_INTERNAL_ERROR);
        }
        if (mScannerId > 0) {
            mLeScanClients.put(mScanCallback, this);
        } else {
            // subsequent operations can proceed.
            if (mScannerId == 0)
                mScannerId = -1;
            // If scanning too frequently, don't report anything to the app.
            if (mScannerId == -2)
                return;
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_APPLICATION_REGISTRATION_FAILED);
        }
    }
}",1,,,0,,,0,,,,,,,"1,3",1,"The change includes a new check in an ""if"" condition (`mScannerId == -2`) and the addition of a new conditional branch (`if (mScannerId == -2) return;`). This implies a change in both the return statement and control dependency, so the code change type is 1,3.","The new check and return statement will prevent the method from progressing past that point, potentially altering the outcome of the method from what would occur in the early version. This could result in different return behavior when the condition `mScannerId == -2` is met, thus it is a Compatibility Issue of type 1."
145,<android.hardware.usb.UsbRequest: void finalize()>,26,27,,,,"{
    try {
        mCloseGuard.warnIfOpen();
        close();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"There's a new control statement introduced: an ""if"" check around the `mCloseGuard.warnIfOpen();` call. Furthermore, there is a slight change in the way the `close()` method is called without the ""if"" check which could be considered as an ""Other statement changed"" since it's an adjustment in the flow without specifically changing return or exception handling. Therefore, the change types are 3 and 4.","Even though there is a control dependency change with the addition of the ""if"" statement around `mCloseGuard.warnIfOpen();`, this change should not cause a CI because the behavior of this statement is just a warning log without affecting the execution flow. The ""close()"" method is still called unconditionally as before, which is the important step in cleaning up resources in finalize(). The subsequent call to `super.finalize();` remains the same as well. Thus, there is no Compatibility Issue; the result is 0."
148,<android.bluetooth.BluetoothDevice: int getType()>,26,27,,,,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device type"");
        return DEVICE_TYPE_UNKNOWN;
    }
    try {
        return sService.getRemoteType(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return DEVICE_TYPE_UNKNOWN;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device type"");
        return DEVICE_TYPE_UNKNOWN;
    }
    try {
        return service.getRemoteType(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return DEVICE_TYPE_UNKNOWN;
}",1,"/**
 * Get the Bluetooth device type of the remote device.
 *
 * @return the device type {@link #DEVICE_TYPE_CLASSIC}, {@link #DEVICE_TYPE_LE}
 * {@link #DEVICE_TYPE_DUAL}.
 * {@link #DEVICE_TYPE_UNKNOWN} if it's not available
 */
","/**
 * Get the Bluetooth device type of the remote device.
 *
 * @return the device type {@link #DEVICE_TYPE_CLASSIC}, {@link #DEVICE_TYPE_LE}
 * {@link #DEVICE_TYPE_DUAL}.
 * {@link #DEVICE_TYPE_UNKNOWN} if it's not available
 */
",0,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],0,,,,,,,4,0,"The only change in the implementation is the introduction of a local variable `service` to hold `sService` before checking if it's null. This does not change the control flow or the behavior of the API; hence, the code change type is 4.","Despite the local variable introduction, it doesn't affect the API's external behavior. The conditions, exceptions thrown, and values returned remain consistent with the previous version. Therefore, there is no compatibility issue; thus, the CI type is 0."
149,"<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>",26,27,,,,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startSummaryEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    result.startSummaryEnumeration();
    return result;
}",1,"/**
 * Query network usage statistics summaries. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over time, hence all buckets will have the same start and
 * end timestamps. Not aggregated over state, uid, metered, or roaming. This means buckets'
 * start and end timestamps are going to be the same as the 'startTime' and 'endTime'
 * parameters. State, uid, metered, and roaming are going to vary, and tag is going to be the
 * same.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over time, hence all buckets will have the same start and
 * end timestamps. Not aggregated over state, uid, metered, or roaming. This means buckets'
 * start and end timestamps are going to be the same as the 'startTime' and 'endTime'
 * parameters. State, uid, metered, and roaming are going to vary, and tag is going to be the
 * same.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",0,,,0,,,,,,,"4,5",1,"The changes include an additional parameter in the constructor call for a `new NetworkStats`, namely `mFlags`, which indicates that the constructor's signature has changed and the dependent API has changed. Therefore, the code change type is 4,5.","The change in the constructor's parameters could lead to changes in the behavior of the created `NetworkStats` object, which results in a potential return of a different value. Thus, the CI type is 1."
150,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,NetworkCallback,int)>",26,27,,,,"{
    if (timeoutMs <= 0) {
        throw new IllegalArgumentException(""Non-positive timeoutMs: "" + timeoutMs);
    }
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, getDefaultHandler());
}","{
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, getDefaultHandler());
}",1,"/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}, limited
 * by a timeout.
 *
 * This function behaves identically to the non-timed-out version
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)}, but if a suitable network
 * is not found within the given time (in milliseconds) the
 * {@link NetworkCallback#onUnavailable()} callback is called. The request can still be
 * released normally by calling {@link #unregisterNetworkCallback(NetworkCallback)} but does
 * not have to be released if timed-out (it is automatically released). Unregistering a
 * request that timed out is not an error.
 *
 * <p>Do not use this method to poll for the existence of specific networks (e.g. with a small
 * timeout) - {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} is provided
 * for that purpose. Calling this method will attempt to bring up the requested network.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param networkCallback The {@link NetworkCallback} to be utilized for this request. Note
 * the callback must not be shared - it uniquely specifies this request.
 * @param timeoutMs The time in milliseconds to attempt looking for a suitable network
 * before {@link NetworkCallback#onUnavailable()} is called. The timeout must
 * be a positive value (i.e. >0).
 */
","/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}, limited
 * by a timeout.
 *
 * This function behaves identically to the non-timed-out version
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)}, but if a suitable network
 * is not found within the given time (in milliseconds) the
 * {@link NetworkCallback#onUnavailable()} callback is called. The request can still be
 * released normally by calling {@link #unregisterNetworkCallback(NetworkCallback)} but does
 * not have to be released if timed-out (it is automatically released). Unregistering a
 * request that timed out is not an error.
 *
 * <p>Do not use this method to poll for the existence of specific networks (e.g. with a small
 * timeout) - {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} is provided
 * for that purpose. Calling this method will attempt to bring up the requested network.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param networkCallback The {@link NetworkCallback} to be utilized for this request. Note
 * the callback must not be shared - it uniquely specifies this request.
 * @param timeoutMs The time in milliseconds to attempt looking for a suitable network
 * before {@link NetworkCallback#onUnavailable()} is called. The timeout must
 * be a positive value (i.e. >0).
 */
",0,,,0,,,,,,,4,0,"The early version implements the check for a non-positive timeout within the method, while the late version has refactored this check into a separate method called `checkTimeout`. However, there are no changes to the return statement or exception handling statement; It's just an internal refactoring with presumably identical behavior, so the code change type is 4.","There is no Compatibility Issue since the logic for checking the timeout remains the same, but it's now handled in a different method. As long as `checkTimeout` throws the same `IllegalArgumentException` for non-positive `timeoutMs`, which we assume it does, the observable behavior of the API does not change."
151,"<android.bluetooth.BluetoothHealth: boolean disconnectChannel(BluetoothDevice,BluetoothHealthAppConfiguration,int)>",26,27,,,,"{
    if (mService != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return mService.disconnectChannel(device, config, channelId);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}","{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.disconnectChannel(device, config, channelId);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}",1,"/**
 * Disconnect a connected health channel.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using
 * {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @param channelId The channel id associated with the channel
 * @return If true, the callback associated with the application config will be called.
 */
","/**
 * Disconnect a connected health channel.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using
 * {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @param channelId The channel id associated with the channel
 * @return If true, the callback associated with the application config will be called.
 */
",0,,,0,,,,,,,0,0,No change in the implementation between the two versions except for a local variable name change which does not affect the behavior of the method.,There is no compatibility issue since the implementation and behavior of the method have not changed between these versions.
153,<android.view.textservice.SpellCheckerSession: void close()>,26,27,,,,"{
    mIsUsed = false;
    try {
        mSpellCheckerSessionListenerImpl.close();
        mTextServicesManager.finishSpellCheckerService(mSpellCheckerSessionListenerImpl);
    } catch (RemoteException e) {
    // do nothing
    }
}","{
    mGuard.close();
    try {
        mSpellCheckerSessionListenerImpl.close();
        mTextServicesManager.finishSpellCheckerService(mSpellCheckerSessionListenerImpl);
    } catch (RemoteException e) {
    // do nothing
    }
}",1,"/**
 * Finish this session and allow TextServicesManagerService to disconnect the bound spell
 * checker.
 */
","/**
 * Finish this session and allow TextServicesManagerService to disconnect the bound spell
 * checker.
 */
",0,,,0,,,,,,,4,0,"The statement ""mGuard.close();"" is added in the late version implementation, which is not a control dependency change, return statement change, or exception handling change, so the code change type is 4.","The addition of ""mGuard.close();"" does not affect the returned value or the exception handling of the API, so there is no compatibility issue regarding potential different return values/types or exception handlings, and the CI type is 0."
154,<android.net.NetworkCapabilities: String toString()>,26,27,,,,"{
    int[] types = getTransportTypes();
    String transports = (types.length > 0) ? "" Transports: "" + transportNamesOf(types) : """";
    types = getCapabilities();
    String capabilities = (types.length > 0 ? "" Capabilities: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case NET_CAPABILITY_MMS:
                capabilities += ""MMS"";
                break;
            case NET_CAPABILITY_SUPL:
                capabilities += ""SUPL"";
                break;
            case NET_CAPABILITY_DUN:
                capabilities += ""DUN"";
                break;
            case NET_CAPABILITY_FOTA:
                capabilities += ""FOTA"";
                break;
            case NET_CAPABILITY_IMS:
                capabilities += ""IMS"";
                break;
            case NET_CAPABILITY_CBS:
                capabilities += ""CBS"";
                break;
            case NET_CAPABILITY_WIFI_P2P:
                capabilities += ""WIFI_P2P"";
                break;
            case NET_CAPABILITY_IA:
                capabilities += ""IA"";
                break;
            case NET_CAPABILITY_RCS:
                capabilities += ""RCS"";
                break;
            case NET_CAPABILITY_XCAP:
                capabilities += ""XCAP"";
                break;
            case NET_CAPABILITY_EIMS:
                capabilities += ""EIMS"";
                break;
            case NET_CAPABILITY_NOT_METERED:
                capabilities += ""NOT_METERED"";
                break;
            case NET_CAPABILITY_INTERNET:
                capabilities += ""INTERNET"";
                break;
            case NET_CAPABILITY_NOT_RESTRICTED:
                capabilities += ""NOT_RESTRICTED"";
                break;
            case NET_CAPABILITY_TRUSTED:
                capabilities += ""TRUSTED"";
                break;
            case NET_CAPABILITY_NOT_VPN:
                capabilities += ""NOT_VPN"";
                break;
            case NET_CAPABILITY_VALIDATED:
                capabilities += ""VALIDATED"";
                break;
            case NET_CAPABILITY_CAPTIVE_PORTAL:
                capabilities += ""CAPTIVE_PORTAL"";
                break;
            case NET_CAPABILITY_FOREGROUND:
                capabilities += ""FOREGROUND"";
                break;
        }
        if (++i < types.length)
            capabilities += ""&"";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? "" LinkUpBandwidth>="" + mLinkUpBandwidthKbps + ""Kbps"" : """");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? "" LinkDnBandwidth>="" + mLinkDownBandwidthKbps + ""Kbps"" : """");
    String specifier = (mNetworkSpecifier == null ? """" : "" Specifier: <"" + mNetworkSpecifier + "">"");
    String signalStrength = (hasSignalStrength() ? "" SignalStrength: "" + mSignalStrength : """");
    return ""["" + transports + capabilities + upBand + dnBand + specifier + signalStrength + ""]"";
}","{
    // TODO: enumerate bits for transports and capabilities instead of creating arrays.
    // TODO: use a StringBuilder instead of string concatenation.
    int[] types = getTransportTypes();
    String transports = (types.length > 0) ? "" Transports: "" + transportNamesOf(types) : """";
    types = getCapabilities();
    String capabilities = (types.length > 0 ? "" Capabilities: "" : """");
    for (int i = 0; i < types.length; ) {
        capabilities += capabilityNameOf(types[i]);
        if (++i < types.length)
            capabilities += ""&"";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? "" LinkUpBandwidth>="" + mLinkUpBandwidthKbps + ""Kbps"" : """");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? "" LinkDnBandwidth>="" + mLinkDownBandwidthKbps + ""Kbps"" : """");
    String specifier = (mNetworkSpecifier == null ? """" : "" Specifier: <"" + mNetworkSpecifier + "">"");
    String signalStrength = (hasSignalStrength() ? "" SignalStrength: "" + mSignalStrength : """");
    return ""["" + transports + capabilities + upBand + dnBand + specifier + signalStrength + ""]"";
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",0,"The change involved replacing a repeated switch case construction for appending capability names to a string with a single line that calls a method (capabilityNameOf(types[i])). Additionally, a note to use StringBuilder for optimization was added as a comment, which also indicates a future preference toward using StringBuilder over string concatenation. However, since the comments do not affect the logic or execution of the code, they are not calculated in the change type. The change type is 4,5 because it entails other statement changes and also reflects changes in the underlying implementation of the dependent API (capabilityNameOf).","Even though the internal logic to generate the string of capabilities has changed, the actual behavior of the API from the caller's perspective has not. It still returns the same string format, assuming the internal implementation of `capabilityNameOf` correctly maps to the old switch case logic. Therefore, this change should not introduce a compatibility issue so it is classified as 0."
155,<android.view.autofill.AutofillManager: void notifyViewExited(View)>,26,27,,,,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        ensureServiceClientAddedIfNeededLocked();
        if (mEnabled && mSessionId != NO_SESSION) {
            final AutofillId id = getAutofillId(view);
            // Update focus on existing session.
            updateSessionLocked(id, null, null, ACTION_VIEW_EXITED, 0);
        }
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        ensureServiceClientAddedIfNeededLocked();
        if (mEnabled && isActiveLocked()) {
            final AutofillId id = getAutofillId(view);
            // Update focus on existing session.
            updateSessionLocked(id, null, null, ACTION_VIEW_EXITED, 0);
        }
    }
}",1,"/**
 * Called when a {@link View} that supports autofill is exited.
 *
 * @param view {@link View} that was exited.
 */
","/**
 * Called when a {@link View} that supports autofill is exited.
 *
 * @param view {@link View} that was exited.
 */
",0,,,0,,,,,,,3,0,"The condition in the if statement has changed from 'mSessionId != NO_SESSION' to 'isActiveLocked()'. Since this is part of a control dependency, the code change is classified as 3.","The compatibility issue does not arise from this particular change since it modifies a control dependency that checks whether the session is active, but this should not affect the behavior of exiting a view in a way that could lead to different outcomes. The method's purpose is to notify the service when a view exits, and depending on internal state checks (session active or not) to decide whether to act or not does not introduce a compatibility issue in itself. The effect on the API behavior is internal and does not change the API contract."
156,<android.net.ConnectivityManager: void releaseNetworkRequest(PendingIntent)>,26,27,,,,"{
    checkPendingIntent(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    checkPendingIntentNotNull(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Removes a request made via {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)}
 * <p>
 * This method has the same behavior as
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)} with respect to
 * releasing network resources and disconnecting.
 *
 * @param operation A PendingIntent equal (as defined by {@link Intent#filterEquals}) to the
 * PendingIntent passed to
 * {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)} with the
 * corresponding NetworkRequest you'd like to remove. Cannot be null.
 */
","/**
 * Removes a request made via {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)}
 * <p>
 * This method has the same behavior as
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)} with respect to
 * releasing network resources and disconnecting.
 *
 * @param operation A PendingIntent equal (as defined by {@link Intent#filterEquals}) to the
 * PendingIntent passed to
 * {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)} with the
 * corresponding NetworkRequest you'd like to remove. Cannot be null.
 */
",0,,,0,,,,,,,"4,5",0,"The method name that is called at the start of the method body has changed from checkPendingIntent to checkPendingIntentNotNull, so the change type is 4,5 (Other statement changed, Dependent API changed).","Although there is a change in the method being called, this would not count as a Compatibility Issue according to the given definitions if the new method `checkPendingIntentNotNull` has the same or stricter requirements than `checkPendingIntent`. Since the API reflects a validation check without an altered control flow, exception thrown or return statement, it does not lead to a different return value or exception being thrown by this method, so CI is classified as 0 (No Compatibility Issue)."
157,<android.app.FragmentManagerImpl: List<Fragment> getFragments()>,26,27,,,,"{
    if (mAdded == null) {
        return Collections.EMPTY_LIST;
    }
    synchronized (mAdded) {
        return (List<Fragment>) mAdded.clone();
    }
}","{
    if (mAdded.isEmpty()) {
        return Collections.EMPTY_LIST;
    }
    synchronized (mAdded) {
        return (List<Fragment>) mAdded.clone();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"The condition in the if-statement has changed from checking `mAdded == null` to checking `mAdded.isEmpty()`, so the code change type is 3.","Although there is a change in the control dependency, it does not lead to a Compatibility Issue. This is because in both cases when the condition is met (either `null` or `isEmpty`), the method returns `Collections.EMPTY_LIST`. As such, there is no change in the behavior of the API in terms of the values it returns or the exceptions it might throw."
158,"<android.text.format.Formatter: String formatShortFileSize(Context,long)>",26,27,,,,"{
    if (context == null) {
        return """";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, FLAG_SHORTER);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}","{
    return formatFileSize(context, sizeBytes, FLAG_SHORTER);
}",1,"/**
 * Like {@link #formatFileSize}, but trying to generate shorter numbers
 * (showing fewer digits of precision).
 */
","/**
 * Like {@link #formatFileSize}, but trying to generate shorter numbers
 * (showing fewer digits of precision).
 */
",0,,,0,,,,,,,"1,5",1,"The return statement has changed from a complex implementation that calls various methods and passes results along, to a single method call to formatFileSize(). This shows both a return statement change and a dependent API change, which are type 1 and 5 respectively.","Due to the refactoring to use a different method for the implementation, the behavior of the API may inherently change either due to the logic within the new method or the formatting of its results, which can cause the API to return different values or types. Therefore, the CI type is 1."
159,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,26,27,,,,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.mOutsets.set((Rect) message.obj);
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.mOutsets.set((Rect) message.obj);
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    mConnection.onWallpaperColorsChanged(mEngine.onComputeColors());
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,0,,,0,,,,,,,,,,
160,"<android.app.FragmentManagerImpl: void dispatchOnFragmentDestroyed(Fragment,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentDestroyed(f, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentDestroyed(this, f);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentDestroyed(f, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentDestroyed(this, f);
        }
    }
}",1,,,0,,,0,,,,,,,4,0,"The if block that checks `if (mLifecycleCallbacks == null)` has been removed, which falls under ""Other statement changed,"" hence the code change type is 4.","Since the only change is the removal of a check for `mLifecycleCallbacks` being null, which would have previously caused an immediate return from the method, and considering that the following for-loop would not execute if `mLifecycleCallbacks` is null (as it would throw a NullPointerException), the behavior is implicitly preserved. Thus, there is no Compatibility Issue."
162,"<android.app.FragmentManagerImpl: void dispatchOnFragmentViewDestroyed(Fragment,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentViewDestroyed(f, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentViewDestroyed(this, f);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentViewDestroyed(f, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentViewDestroyed(this, f);
        }
    }
}",1,,,0,,,0,,,,,,,1,1,"The early version contains a conditional check if `mLifecycleCallbacks` is null, followed by a return statement which exits the method without executing the subsequent for-loop. This check and the return statement are removed in the late version, leading to the execution of the for-loop regardless of the state of `mLifecycleCallbacks`. The code change type is 1.","The removal of the null check for `mLifecycleCallbacks` means that in the case where `mLifecycleCallbacks` is null, the late version of the method will now try to enter the for-loop, which may result in a NullPointerException that would not occur in the early version. This change could lead to different behaviors, specifically an exception being thrown instead of the method exiting quietly. Therefore, the CI type is 1."
164,<android.app.DownloadManager.Request: ContentValues toContentValues(String)>,26,27,,,,"{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, (this.mUseSystemCache) ? Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION : Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_FLAGS, mFlags);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}","{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_FLAGS, mFlags);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}",1,"/**
 * @return ContentValues to be passed to DownloadProvider.insert()
 */
","/**
 * @return ContentValues to be passed to DownloadProvider.insert()
 */
",0,,,0,,,,,,,"3,4",1,"There is a control dependency change where a part of a ternary operator has been removed: `(this.mUseSystemCache) ? Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION :` no longer exists in the late version. Additionally, other statements that are conditionally executed based on `this.mUseSystemCache` have also been removed, which can be classified as other statements changed.","Since the condition involving `this.mUseSystemCache` is removed in the latter version, it could lead to different values in `ContentValues` being returned if `mDestinationUri` is null and `this.mUseSystemCache` is true in the early version. Therefore, there is a potential Compatibility Issue due to the API potentially returning different values."
165,"<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>",26,27,,,,"{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        Bitmap bitmap = (Bitmap) bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (bitmap == null) {
            return null;
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}","{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        GraphicBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            bitmap = Bitmap.createHardwareBitmap(buffer);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}",1,"/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */
","/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */
",0,,,0,,,,,,,"1,4",1,"There is a new code block that creates a `Bitmap` from a `GraphicBuffer`, if the incoming snapshot is a bundle that does not contain a Bitmap but contains a GraphicBuffer. The returns in the condition blocks remain the same, but the condition that leads to them involves additional logic. Where before it returned null if the bitmap was null, it now checks if both buffer and bitmap are null, and additionally, if the buffer is not null it creates a new bitmap which then affects the rest of the method's behavior. This is a change in an 'if' condition and also introduces a new method call (`Bitmap.createHardwareBitmap`). So, the change affects other statements and conditioning logic, classified as 1 (return statement change due to possibly different returned object) and 4 (other statement changed due to the introduction of new method call and additional checks).","Due to the change in the condition checking if the bitmap is null, and because a Bitmap can now be created from a GraphicBuffer if the original bitmap is `null`, there is a CI due to potential different return values or types (a non-null bitmap where there might have been `null` before). The CI type is 1."
170,<android.view.textclassifier.TextClassification.Builder: Builder setText(String)>,26,27,,,,"{
    mText = Preconditions.checkNotNull(text);
    return this;
}","{
    mText = text;
    return this;
}",1,"/**
 * Sets the classified text.
 */
","/**
 * Sets the classified text.
 */
",0,,,0,,,,,,,4,0,"The change is the deletion of the Preconditions.checkNotNull(text) call. The early implementation uses Preconditions.checkNotNull to ensure that the 'text' parameter is not null before assigning it to 'mText'. In the late implementation, this check has been removed, which means 'mText' could potentially be set to null, but the method's return type and signature remain unchanged, so the code change type is 4 (Other statement changed).","There is no Compatibility Issue, because there were no changes in the API's behavior in terms of exception throwing or return values. The removal of the Preconditions.checkNotNull call means that the method now allows 'mText' to be set to null, but this does not alter the control flow or the method's return type. The method still returns 'this', regardless of whether 'text' is null or not. Therefore, the API's behavior remains compatible with existing code that would be using this API."
171,<android.content.pm.permission.RuntimePermissionPresenter.RemoteService: void handleMessage(Message)>,26,27,,,,"{
    switch(msg.what) {
        case MSG_GET_APP_PERMISSIONS:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                final String packageName = (String) args.arg1;
                final OnResultCallback callback = (OnResultCallback) args.arg2;
                final Handler handler = (Handler) args.arg3;
                args.recycle();
                final IRuntimePermissionPresenter remoteInstance;
                synchronized (mLock) {
                    remoteInstance = mRemoteInstance;
                }
                if (remoteInstance == null) {
                    return;
                }
                try {
                    remoteInstance.getAppPermissions(packageName, new RemoteCallback(new RemoteCallback.OnResultListener() {

                        @Override
                        public void onResult(Bundle result) {
                            final List<RuntimePermissionPresentationInfo> reportedPermissions;
                            List<RuntimePermissionPresentationInfo> permissions = null;
                            if (result != null) {
                                permissions = result.getParcelableArrayList(KEY_RESULT);
                            }
                            if (permissions == null) {
                                permissions = Collections.emptyList();
                            }
                            reportedPermissions = permissions;
                            if (handler != null) {
                                handler.post(new Runnable() {

                                    @Override
                                    public void run() {
                                        callback.onGetAppPermissions(reportedPermissions);
                                    }
                                });
                            } else {
                                callback.onGetAppPermissions(reportedPermissions);
                            }
                        }
                    }, this));
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error getting app permissions"", re);
                }
                scheduleUnbind();
            }
            break;
        case MSG_UNBIND:
            {
                synchronized (mLock) {
                    if (mBound) {
                        mContext.unbindService(this);
                        mBound = false;
                    }
                    mRemoteInstance = null;
                }
            }
            break;
    }
    synchronized (mLock) {
        scheduleNextMessageIfNeededLocked();
    }
}","{
    switch(msg.what) {
        case MSG_GET_APP_PERMISSIONS:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                final String packageName = (String) args.arg1;
                final OnResultCallback callback = (OnResultCallback) args.arg2;
                final Handler handler = (Handler) args.arg3;
                args.recycle();
                final IRuntimePermissionPresenter remoteInstance;
                synchronized (mLock) {
                    remoteInstance = mRemoteInstance;
                }
                if (remoteInstance == null) {
                    return;
                }
                try {
                    remoteInstance.getAppPermissions(packageName, new RemoteCallback(new RemoteCallback.OnResultListener() {

                        @Override
                        public void onResult(Bundle result) {
                            final List<RuntimePermissionPresentationInfo> reportedPermissions;
                            List<RuntimePermissionPresentationInfo> permissions = null;
                            if (result != null) {
                                permissions = result.getParcelableArrayList(KEY_RESULT);
                            }
                            if (permissions == null) {
                                permissions = Collections.emptyList();
                            }
                            reportedPermissions = permissions;
                            if (handler != null) {
                                handler.post(new Runnable() {

                                    @Override
                                    public void run() {
                                        callback.onGetAppPermissions(reportedPermissions);
                                    }
                                });
                            } else {
                                callback.onGetAppPermissions(reportedPermissions);
                            }
                        }
                    }, this));
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error getting app permissions"", re);
                }
                scheduleUnbind();
            }
            break;
        case MSG_UNBIND:
            {
                synchronized (mLock) {
                    if (mBound) {
                        mContext.unbindService(this);
                        mBound = false;
                    }
                    mRemoteInstance = null;
                }
            }
            break;
        case MSG_REVOKE_APP_PERMISSIONS:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                final String packageName = (String) args.arg1;
                final String permissionName = (String) args.arg2;
                args.recycle();
                final IRuntimePermissionPresenter remoteInstance;
                synchronized (mLock) {
                    remoteInstance = mRemoteInstance;
                }
                if (remoteInstance == null) {
                    return;
                }
                try {
                    remoteInstance.revokeRuntimePermission(packageName, permissionName);
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error getting app permissions"", re);
                }
            }
            break;
    }
    synchronized (mLock) {
        scheduleNextMessageIfNeededLocked();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"A new case `MSG_REVOKE_APP_PERMISSIONS` has been added to the switch statement, which introduces a new control block and other statements within that block, hence the code change types are 3 and 4.","There is no Compatibility Issue detected since the changes are additive and confined within a new case block, which does not impact existing behavior or change any existing return types or thrown exceptions for previous cases; it only extends the functionality by handling a new message type."
172,"<android.appwidget.AppWidgetHost: void startAppWidgetConfigureActivityForResult(Activity,int,int,int,Bundle)>",26,27,,,,"{
    try {
        IntentSender intentSender = sService.createAppWidgetConfigIntentSender(mContextOpPackageName, appWidgetId, intentFlags);
        if (intentSender != null) {
            activity.startIntentSenderForResult(intentSender, requestCode, null, 0, 0, 0, options);
        } else {
            throw new ActivityNotFoundException();
        }
    } catch (IntentSender.SendIntentException e) {
        throw new ActivityNotFoundException();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (sService == null) {
        return;
    }
    try {
        IntentSender intentSender = sService.createAppWidgetConfigIntentSender(mContextOpPackageName, appWidgetId, intentFlags);
        if (intentSender != null) {
            activity.startIntentSenderForResult(intentSender, requestCode, null, 0, 0, 0, options);
        } else {
            throw new ActivityNotFoundException();
        }
    } catch (IntentSender.SendIntentException e) {
        throw new ActivityNotFoundException();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Starts an app widget provider configure activity for result on behalf of the caller.
 * Use this method if the provider is in another profile as you are not allowed to start
 * an activity in another profile. You can optionally provide a request code that is
 * returned in {@link Activity#onActivityResult(int, int, android.content.Intent)} and
 * an options bundle to be passed to the started activity.
 * <p>
 * Note that the provided app widget has to be bound for this method to work.
 * </p>
 *
 * @param activity The activity from which to start the configure one.
 * @param appWidgetId The bound app widget whose provider's config activity to start.
 * @param requestCode Optional request code retuned with the result.
 * @param intentFlags Optional intent flags.
 *
 * @throws android.content.ActivityNotFoundException If the activity is not found.
 *
 * @see AppWidgetProviderInfo#getProfile()
 */
","/**
 * Starts an app widget provider configure activity for result on behalf of the caller.
 * Use this method if the provider is in another profile as you are not allowed to start
 * an activity in another profile. You can optionally provide a request code that is
 * returned in {@link Activity#onActivityResult(int, int, android.content.Intent)} and
 * an options bundle to be passed to the started activity.
 * <p>
 * Note that the provided app widget has to be bound for this method to work.
 * </p>
 *
 * @param activity The activity from which to start the configure one.
 * @param appWidgetId The bound app widget whose provider's config activity to start.
 * @param requestCode Optional request code retuned with the result.
 * @param intentFlags Optional intent flags.
 *
 * @throws android.content.ActivityNotFoundException If the activity is not found.
 *
 * @see AppWidgetProviderInfo#getProfile()
 */
",0,,,0,,,,,,,"3,4",0,"The late version introduces a new condition check (if (sService == null)) and a new return statement. Then, it is a combination of control dependency change (3) and other statement changed (4).","Even though a new branch and return statement have been added to the implementation, the method's signature implies that it does not expect to return any value. The newly introduced return statement would only exit the method earlier if a specific condition is met (sService being null), which does not change the method's behavior since it's not supposed to return anything anyhow. There is no Compatibility Issue here because any situation where `sService` is `null` and would trigger the return statement would have previously resulted in a `NullPointerException`, being caught and handled by the catch blocks for `RemoteException` or `SendIntentException`."
173,<android.net.ConnectivityManager: void removeDefaultNetworkActiveListener(OnNetworkActiveListener)>,26,27,,,,"{
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    if (rl == null) {
        throw new IllegalArgumentException(""Listener not registered: "" + l);
    }
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    Preconditions.checkArgument(rl != null, ""Listener was not registered."");
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Remove network active listener previously registered with
 * {@link #addDefaultNetworkActiveListener}.
 *
 * @param l Previously registered listener.
 */
","/**
 * Remove network active listener previously registered with
 * {@link #addDefaultNetworkActiveListener}.
 *
 * @param l Previously registered listener.
 */
",0,,,0,,,,,,,4,0,"The exception throwing statement has been replaced with a precondition check statement, so the change type is 4.","There is no CI because the precondition still throws IllegalArgumentException if the condition is not met like the previous version; the behavior of throwing the exception is the same in both versions, just the way of expressing the conditional check is different."
174,"<android.widget.NumberPicker: void scrollBy(int,int)>",26,27,,,,"{
    int[] selectorIndices = mSelectorIndices;
    if (!mWrapSelectorWheel && y > 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    if (!mWrapSelectorWheel && y < 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    mCurrentScrollOffset += y;
    while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapHeight) {
        mCurrentScrollOffset -= mSelectorElementHeight;
        decrementSelectorIndices(selectorIndices);
        setValueInternal(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX], true);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
    while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapHeight) {
        mCurrentScrollOffset += mSelectorElementHeight;
        incrementSelectorIndices(selectorIndices);
        setValueInternal(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX], true);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
}","{
    int[] selectorIndices = mSelectorIndices;
    int startScrollOffset = mCurrentScrollOffset;
    if (!mWrapSelectorWheel && y > 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    if (!mWrapSelectorWheel && y < 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    mCurrentScrollOffset += y;
    while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapHeight) {
        mCurrentScrollOffset -= mSelectorElementHeight;
        decrementSelectorIndices(selectorIndices);
        setValueInternal(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX], true);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
    while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapHeight) {
        mCurrentScrollOffset += mSelectorElementHeight;
        incrementSelectorIndices(selectorIndices);
        setValueInternal(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX], true);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
    if (startScrollOffset != mCurrentScrollOffset) {
        onScrollChanged(0, mCurrentScrollOffset, 0, startScrollOffset);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The addition of a local variable `startScrollOffset` and a conditional statement checking if `startScrollOffset` is not equal to `mCurrentScrollOffset`, followed by the `onScrollChanged` method call, constitute the observed code changes. These changes fall under control dependency change (since the condition for the if-statement is newly introduced) and other statement change (the variable declaration and the method call), hence the classification is 3,4.","There is no compatibility issue since the newly introduced statements and variable do not alter the execution or return type of the method; the method has a void return type and is meant to scroll the picker by the given amount. The additional method call to `onScrollChanged` is an internal state update or callback that does not affect the return type or throw a new exception, thus it does not cause a compatibility issue—classified as 0."
175,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult classifyText()>,26,27,,,,"{
    if (!Objects.equals(mText, mLastClassificationText) || mSelectionStart != mLastClassificationSelectionStart || mSelectionEnd != mLastClassificationSelectionEnd || !Objects.equals(mLocales, mLastClassificationLocales)) {
        mLastClassificationText = mText;
        mLastClassificationSelectionStart = mSelectionStart;
        mLastClassificationSelectionEnd = mSelectionEnd;
        mLastClassificationLocales = mLocales;
        trimText();
        mLastClassificationResult = new SelectionResult(mSelectionStart, mSelectionEnd, mTextClassifier.classifyText(mTrimmedText, mRelativeStart, mRelativeEnd, mLocales));
    }
    return mLastClassificationResult;
}","{
    mHot = true;
    return performClassification(null);
}",1,,,0,[@WorkerThread],[@WorkerThread],0,,,,,,,"1,3,4",1,"The entire body of the classifyText() method has been changed. In the late version, a new variable setting statement 'mHot = true;' is added, and the method 'return performClassification(null);' is called instead of the previous content. Consequently, the code change type is 1,3,4.","The complete change in the implementation means that the method now potentially returns different results by calling a different method with, in addition, a state change implied by 'mHot = true;'. This would lead to a different return value as the classification is now performed by a different process, hence the CI type is 1."
177,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void abortCaptures()>,26,27,,,,"{
    synchronized (this) {
        checkNotClosed();
        if (DEBUG) {
            Log.v(TAG, mIdString + ""abortCaptures"");
        }
        if (mAborting) {
            Log.w(TAG, mIdString + ""abortCaptures - Session is already aborting; doing nothing"");
            return;
        }
        mAborting = true;
        mAbortDrainer.taskStarted();
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (this) {
            mDeviceImpl.flush();
        // The next BUSY -> IDLE set of transitions will mark the end of the abort.
        }
    }
}","{
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        if (DEBUG) {
            Log.v(TAG, mIdString + ""abortCaptures"");
        }
        if (mAborting) {
            Log.w(TAG, mIdString + ""abortCaptures - Session is already aborting; doing nothing"");
            return;
        }
        mAborting = true;
        mAbortDrainer.taskStarted();
        mDeviceImpl.flush();
    // The next BUSY -> IDLE set of transitions will mark the end of the abort.
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The late version has a simplification in the synchronization blocks (removing the nested 'synchronized (this)' block), so the code change types are 3 (since the blocks in which the synchronization occurs have changed) and 4 (modification in the synchronization structure).","Even though the synchronization blocks have changed, this will not result in a different behavior from the perspective of method output or exception throwing. The method's logic and control flow remains intact, just the scope of synchronization is broadened to include the entire block of code. Hence, the code changes will not lead to a Compatibility Issue."
179,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertisingSet(AdvertisingSetCallback)>,26,27,,,,"{
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    IAdvertisingSetCallback wrapped = mCallbackWrappers.remove(callback);
    if (wrapped == null) {
        return;
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopAdvertisingSet(wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to stop advertising - "", e);
        throw new IllegalStateException(""Failed to stop advertising"");
    }
}","{
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    IAdvertisingSetCallback wrapped = mCallbackWrappers.remove(callback);
    if (wrapped == null) {
        return;
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopAdvertisingSet(wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to stop advertising - "", e);
    }
}",1,"/**
 * Used to dispose of a {@link AdvertisingSet} object, obtained with {@link
 * BluetoothLeAdvertiser#startAdvertisingSet}.
 */
","/**
 * Used to dispose of a {@link AdvertisingSet} object, obtained with {@link
 * BluetoothLeAdvertiser#startAdvertisingSet}.
 */
",0,,,0,,,,,,,2,2,The exception handling statement has been altered; the 'throw new IllegalStateException' was removed in the late version.,"In the early version, a RemoteException would lead to an IllegalStateException being thrown, while in the late version, it just logs the error without throwing an exception. This could lead to different exception handling, hence the CI type is 2."
180,"<android.app.FragmentManagerImpl: void dispatchPictureInPictureModeChanged(boolean,Configuration)>",26,27,,,,"{
    if (mAdded == null) {
        return;
    }
    for (int i = mAdded.size() - 1; i >= 0; --i) {
        final Fragment f = mAdded.get(i);
        if (f != null) {
            f.performPictureInPictureModeChanged(isInPictureInPictureMode, newConfig);
        }
    }
}","{
    for (int i = mAdded.size() - 1; i >= 0; --i) {
        final Fragment f = mAdded.get(i);
        if (f != null) {
            f.performPictureInPictureModeChanged(isInPictureInPictureMode, newConfig);
        }
    }
}",1,,,0,,,0,,,,,,,3,1,"The control statement 'if (mAdded == null)' has been removed in the late version, so the code change type is 3.","The removal of the 'if (mAdded == null)' check means that in the late version, the loop and the call to 'f.performPictureInPictureModeChanged' can now execute even if 'mAdded' is null, which would previously have caused an early return. Hence, the API now potentially behaves differently if 'mAdded' is null (e.g., it could throw a NullPointerException where it previously wouldn't), and the CI type is 1."
181,<android.view.View: void onRestoreInstanceState(Parcelable)>,26,27,,,,"{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        BaseSavedState baseState = (BaseSavedState) state;
        if ((baseState.mSavedData & BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED) != 0) {
            mStartActivityRequestWho = baseState.mStartActivityRequestWhoSaved;
        }
        if ((baseState.mSavedData & BaseSavedState.IS_AUTOFILLED) != 0) {
            setAutofilled(baseState.mIsAutofilled);
        }
        if ((baseState.mSavedData & BaseSavedState.AUTOFILL_ID) != 0) {
            mAutofillViewId = baseState.mAutofillViewId;
        }
    }
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        BaseSavedState baseState = (BaseSavedState) state;
        if ((baseState.mSavedData & BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED) != 0) {
            mStartActivityRequestWho = baseState.mStartActivityRequestWhoSaved;
        }
        if ((baseState.mSavedData & BaseSavedState.IS_AUTOFILLED) != 0) {
            setAutofilled(baseState.mIsAutofilled);
        }
        if ((baseState.mSavedData & BaseSavedState.AUTOFILL_ID) != 0) {
            // It can happen that views have the same view id and the restoration path will not
            // be able to distinguish between them. The autofill id needs to be unique though.
            // Hence prevent the same autofill view id from being restored multiple times.
            ((BaseSavedState) state).mSavedData &= ~BaseSavedState.AUTOFILL_ID;
            mAutofillViewId = baseState.mAutofillViewId;
        }
    }
}",1,"/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
","/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
",0,[@CallSuper],[@CallSuper],0,,,,,,,4,0,"There is an additional operation inside the last 'if' block, which modifies the `mSavedData` field of the `state` object especially for `AUTOFILL_ID`. Therefore, the change type is 4.","The updated line of code is updating a field on the `state` object but is not changing the behavior of the method with respect to the return value or the exceptions thrown. The change only relates to updating a state within the method and does not result in a different outward-facing behavior when invoking the `onRestoreInstanceState` method. Thus, there is no compatibility issue."
182,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,26,27,,,,"{
    throwIfDestroyed();
    mDescription = description;
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkState(mCustomDescription == null, ""Can call setDescription() or setCustomDescription(), but not both"");
    mDescription = description;
    return this;
}",1,"/**
 * Sets an optional description to be shown in the UI when the user is asked to save.
 *
 * <p>Typically, it describes how the data will be stored by the service, so it can help
 * users to decide whether they can trust the service to save their data.
 *
 * @param description a succint description.
 * @return This Builder.
 */
","/**
 * Sets an optional description to be shown in the UI when the user is asked to save.
 *
 * <p>Typically, it describes how the data will be stored by the service, so it can help
 * users to decide whether they can trust the service to save their data.
 *
 * @param description a succint description.
 * @return This Builder.
 *
 * @throws IllegalStateException if this call was made after calling
 * {@link #setCustomDescription(CustomDescription)}.
 */
",1,[@NonNull],[@NonNull],0,,,,,,,4,0,"The change in implementation is the addition of a call to Preconditions.checkState() to ensure that mCustomDescription is null, so the code change type is 4 (Other statement changed).","There's no Compatibility Issue due to the added precondition check. It throws an IllegalStateException if the condition is violated, which would indicate incorrect use of the API rather than a change in behavior that is invisible to the caller (as in, the conditions required for the method to proceed as expected remain unchanged). Consequently, the change doesn't introduce a difference in return values or exception handling that wasn't already accounted for by the API usage contract."
183,<android.widget.TextView: boolean selectAllText()>,26,27,,,,"{
    final int length = mText.length();
    Selection.setSelection((Spannable) mText, 0, length);
    return length > 0;
}","{
    if (mEditor != null) {
        // Hide the toolbar before changing the selection to avoid flickering.
        mEditor.hideFloatingToolbar(FLOATING_TOOLBAR_SELECT_ALL_REFRESH_DELAY);
    }
    final int length = mText.length();
    Selection.setSelection((Spannable) mText, 0, length);
    return length > 0;
}",1,,,0,,,0,,,,,,,"3,4",0,"Additional code (a call to mEditor.hideFloatingToolbar) which is not part of a return or throw statement is introduced before the original code, and it falls under a new condition block. Hence, the change is classified as both a control dependency change and an other statement change.","The new code does not affect the value being returned (length > 0 is still the same condition) or introduce different potential exceptions. Therefore, the change should not cause any compatibility issues."
185,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,26,27,,,,"{
    return ""ModuleProperties [mId="" + mId + "", mClassId="" + mClassId + "", mImplementor="" + mImplementor + "", mProduct="" + mProduct + "", mVersion="" + mVersion + "", mSerial="" + mSerial + "", mNumTuners="" + mNumTuners + "", mNumAudioSources="" + mNumAudioSources + "", mIsCaptureSupported="" + mIsCaptureSupported + "", mBands="" + Arrays.toString(mBands) + ""]"";
}","{
    return ""ModuleProperties [mId="" + mId + "", mServiceName="" + mServiceName + "", mClassId="" + mClassId + "", mImplementor="" + mImplementor + "", mProduct="" + mProduct + "", mVersion="" + mVersion + "", mSerial="" + mSerial + "", mNumTuners="" + mNumTuners + "", mNumAudioSources="" + mNumAudioSources + "", mIsCaptureSupported="" + mIsCaptureSupported + "", mIsBgScanSupported="" + mIsBgScanSupported + "", mBands="" + Arrays.toString(mBands) + ""]"";
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"The return statement in the late implementation has two differences: it includes a new field mServiceName, and another field mIsBgScanSupported has been added. This is a modification to the returned string and also an addition of other statement changes, so the change types are 1 and 4.","The toString() method now returns additional information in the late version. Clients relying on the exact format of the string (such as parsing the string) may face issues. Thus, the API method potentially returns a different value, and the CI type is 1."
186,<android.bluetooth.BluetoothHeadset: boolean stopVoiceRecognition(BluetoothDevice)>,26,27,,,,"{
    if (DBG)
        log(""stopVoiceRecognition()"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}","{
    if (DBG)
        log(""stopVoiceRecognition()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}",1,"/**
 * Stop Bluetooth Voice Recognition mode, and shut down the
 * Bluetooth audio path.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected
 * or on error, true otherwise
 */
","/**
 * Stop Bluetooth Voice Recognition mode, and shut down the
 * Bluetooth audio path.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected
 * or on error, true otherwise
 */
",0,,,0,,,,,,,4,0,"The only change is the introduction of a local final variable `service` to hold the value of `mService`, and then `service` is used instead of directly using `mService` within the method. This is a refactoring that does not affect the method's external behavior or return value, thus the code change type is 4.","There is no Compatibility Issue as the method's return values, control flow, and exception handling have not been altered by the code change. The behavior of the API remains consistent between versions 26 and 27."
187,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUidTag(int,String,long,long,int,int)>",26,27,,,,"{
    NetworkTemplate template;
    template = createTemplate(networkType, subscriberId);
    NetworkStats result;
    try {
        result = new NetworkStats(mContext, template, startTime, endTime);
        result.startHistoryEnumeration(uid, tag);
    } catch (RemoteException e) {
        Log.e(TAG, ""Error while querying stats for uid="" + uid + "" tag="" + tag, e);
        return null;
    }
    return result;
}","{
    NetworkTemplate template;
    template = createTemplate(networkType, subscriberId);
    NetworkStats result;
    try {
        result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
        result.startHistoryEnumeration(uid, tag);
    } catch (RemoteException e) {
        Log.e(TAG, ""Error while querying stats for uid="" + uid + "" tag="" + tag, e);
        return null;
    }
    return result;
}",1,"/**
 * Query network usage statistics details for a given uid and tag. Only usable for uids
 * belonging to calling user. Result is aggregated over state but not aggregated over time.
 * This means buckets' start and end timestamps are going to be between 'startTime' and
 * 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid the
 * same as the 'uid' parameter and tag the same as 'tag' parameter. metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param uid UID of app
 * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for no tags.
 * @return Statistics object or null if an error happened during statistics collection.
 * @throws SecurityException if permissions are insufficient to read network statistics.
 */
","/**
 * Query network usage statistics details for a given uid and tag. Only usable for uids
 * belonging to calling user. Result is aggregated over state but not aggregated over time.
 * This means buckets' start and end timestamps are going to be between 'startTime' and
 * 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid the
 * same as the 'uid' parameter and tag the same as 'tag' parameter. metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param uid UID of app
 * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for no tags.
 * @return Statistics object or null if an error happened during statistics collection.
 * @throws SecurityException if permissions are insufficient to read network statistics.
 */
",0,,,0,,,,,,,4,0,"The instantiation of `NetworkStats` has been modified to include an additional parameter `mFlags`, thus there is another statement changed (type 4).","Despite the modification in the creation of the `NetworkStats` object, the return type remains `NetworkStats`, and the implementation does not affect the method's potential behaviour in terms of returned values or exceptions thrown. Therefore, there is no Compatibility Issue (type 0)."
188,<android.content.ContentProviderClient.CursorWrapperInner: void finalize()>,26,27,,,,"{
    try {
        mCloseGuard.warnIfOpen();
        close();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"The code change consists only in adding an `if` check to see if `mCloseGuard` is not null before calling `warnIfOpen()` on it, so the change type is 3 (Control dependency changed).","This change does not lead to a compatibility issue, as the added null check only prevents a potential null pointer exception from occurring during finalization without altering the API's intended functionality. Therefore, the CI type is 0 (No Compatibility Issue)."
189,<android.app.FragmentManagerImpl: void dispatchMultiWindowModeChanged(boolean)>,26,27,,,,"{
    if (mAdded == null) {
        return;
    }
    for (int i = mAdded.size() - 1; i >= 0; --i) {
        final Fragment f = mAdded.get(i);
        if (f != null) {
            f.performMultiWindowModeChanged(isInMultiWindowMode);
        }
    }
}","{
    for (int i = mAdded.size() - 1; i >= 0; --i) {
        final Fragment f = mAdded.get(i);
        if (f != null) {
            f.performMultiWindowModeChanged(isInMultiWindowMode);
        }
    }
}",1,"/**
 * @deprecated use {@link #dispatchMultiWindowModeChanged(boolean, Configuration)}
 */
","/**
 * @deprecated use {@link #dispatchMultiWindowModeChanged(boolean, Configuration)}
 */
",0,[@Deprecated],[@Deprecated],0,,,,,,,3,0,"The change is the removal of an initial check (if mAdded == null) that would previously have returned early from the method if mAdded was null. Since this check is now removed, the for loop will now execute regardless, assuming mAdded is never null within the method's usage context. This is a removal of a control dependency, so the code change type is 3.","This removal does not constitute a compatibility issue as long as mAdded is never null when the method is invoked. If mAdded could be null in early versions and the method guarded against that, the removal of this check could potentially lead to a NullPointerException in the later version where the null check is no longer performed. However, without additional context or documentation indicating mAdded could indeed be null, we cannot presume this would introduce a CI. Thus, the pred_CI is 0."
190,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,26,27,,,,"{
    if (!mHasSelectorWheel || !isEnabled()) {
        return false;
    }
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                removeAllCallbacks();
                mInputText.setVisibility(View.INVISIBLE);
                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
                mLastDownEventTime = event.getEventTime();
                mIgnoreMoveEvents = false;
                mPerformClickOnTap = false;
                // Handle pressed state before any state change.
                if (mLastDownEventY < mTopSelectionDividerTop) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_DECREMENT);
                    }
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_INCREMENT);
                    }
                }
                // Make sure we support flinging inside scrollables.
                getParent().requestDisallowInterceptTouchEvent(true);
                if (!mFlingScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                } else if (!mAdjustScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                } else if (mLastDownEventY < mTopSelectionDividerTop) {
                    hideSoftInput();
                    postChangeCurrentByOneFromLongPress(false, ViewConfiguration.getLongPressTimeout());
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    hideSoftInput();
                    postChangeCurrentByOneFromLongPress(true, ViewConfiguration.getLongPressTimeout());
                } else {
                    mPerformClickOnTap = true;
                    postBeginSoftInputOnLongPressCommand();
                }
                return true;
            }
    }
    return false;
}","{
    if (!mHasSelectorWheel || !isEnabled()) {
        return false;
    }
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                removeAllCallbacks();
                hideSoftInput();
                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
                mLastDownEventTime = event.getEventTime();
                mIgnoreMoveEvents = false;
                mPerformClickOnTap = false;
                // Handle pressed state before any state change.
                if (mLastDownEventY < mTopSelectionDividerTop) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_DECREMENT);
                    }
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_INCREMENT);
                    }
                }
                // Make sure we support flinging inside scrollables.
                getParent().requestDisallowInterceptTouchEvent(true);
                if (!mFlingScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                } else if (!mAdjustScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                } else if (mLastDownEventY < mTopSelectionDividerTop) {
                    postChangeCurrentByOneFromLongPress(false, ViewConfiguration.getLongPressTimeout());
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    postChangeCurrentByOneFromLongPress(true, ViewConfiguration.getLongPressTimeout());
                } else {
                    mPerformClickOnTap = true;
                    postBeginSoftInputOnLongPressCommand();
                }
                return true;
            }
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The statement `mInputText.setVisibility(View.INVISIBLE);` has been removed in the late version, which means in the late version, the state of the `mInputText` visibility is not being set as it was in the early version, the code change type is 4.","The change of the `mInputText.setVisibility(View.INVISIBLE);` statement does not alter the return type or value nor does it change exception handling, therefore, there is no Compatibility Issue, so the CI type is 0."
191,<android.widget.Editor.HandleView: void show()>,26,27,,,,"{
    if (isShowing())
        return;
    getPositionListener().addSubscriber(this, true);
    // Make sure the offset is always considered new, even when focusing at same position
    mPreviousOffset = -1;
    positionAtCursorOffset(getCurrentCursorOffset(), false);
}","{
    if (isShowing())
        return;
    getPositionListener().addSubscriber(this, true);
    // Make sure the offset is always considered new, even when focusing at same position
    mPreviousOffset = -1;
    positionAtCursorOffset(getCurrentCursorOffset(), false, false);
}",1,,,0,,,0,,,,,,,"4,5",0,"The called method `positionAtCursorOffset` has got an extra boolean parameter in its signature, therefore the change types are 4 (Other statement changed) and 5 (Dependent API changed).","Since only an additional parameter is being passed to a method and assuming the method's additional parameter does not alter the method behavior in a way that would result in this method returning different values or throwing different exceptions, there is no Compatibility Issue. The extra parameter likely provides additional contextual information for the operation of the method `positionAtCursorOffset`, but does not impact the `show` method’s behavior concerning its return values or the exceptions it throws."
192,<android.bluetooth.BluetoothHealth: boolean unregisterAppConfiguration(BluetoothHealthAppConfiguration)>,26,27,,,,"{
    boolean result = false;
    if (mService != null && isEnabled() && config != null) {
        try {
            result = mService.unregisterAppConfiguration(config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && config != null) {
        try {
            result = service.unregisterAppConfiguration(config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return result;
}",1,"/**
 * Unregister an application configuration that has been registered using
 * {@link #registerSinkAppConfiguration}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param config  The health app configuration
 * @return Success or failure.
 */
","/**
 * Unregister an application configuration that has been registered using
 * {@link #registerSinkAppConfiguration}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param config  The health app configuration
 * @return Success or failure.
 */
",0,,,0,,,,,,,0,0,The only difference between the two code versions is the assignment of the service reference to a new local variable before the conditional check instead of using the member variable directly within the check. No substantial change was made to the implementation logic.,"There is no Compatibility Issue because the change in the code does not alter the API behavior, return values, or exceptions thrown. The modification is just a refactor of the service object into a local variable and doesn't affect the observable behavior of the method."
193,<android.widget.DatePicker: void autofill(AutofillValue)>,26,27,,,,"{
    if (!isEnabled())
        return;
    if (!value.isDate()) {
        Log.w(LOG_TAG, value + "" could not be autofilled into "" + this);
        return;
    }
    mDelegate.updateDate(value.getDateValue());
}","{
    if (!isEnabled())
        return;
    mDelegate.autofill(value);
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4,5",0,"The control dependency has changed since an 'if' condition checking (value.isDate()) and associated logging has been removed. Furthermore, a change to 'Other statements changed' is present since the method called on mDelegate is different (updateDate to autofill) and the way the value is processed has changed. Additionally, a 'Dependent API changed' is also detected since the implementation now relies on a different method (autofill rather than updateDate), which assumes changes to how 'value' is processed internally within 'mDelegate'. The code change type is therefore 3,4,5.","Despite the changes, there is No Compatibility Issue because there is no difference in the behavior in terms of the API contract from the caller's perspective; the value is supposed to be autofilled if the widget is enabled, which remains the same before and after the change. The deletion of the log message and the isDate() check, while they represent a change in code, do not affect the functionality exposed to the caller in terms of different return values or exceptions being thrown; these are more about internal validation and error logging which do not cause compatibility issues as per the definitions provided."
194,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,26,27,,,,"{
    if (sService == null || isBluetoothEnabled() == false) {
        Log.e(TAG, ""BT not enabled. Cannot get remote device Uuids"");
        return null;
    }
    try {
        return sService.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    final IBluetooth service = sService;
    if (service == null || !isBluetoothEnabled()) {
        Log.e(TAG, ""BT not enabled. Cannot get remote device Uuids"");
        return null;
    }
    try {
        return service.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 *
 * @return the supported features (UUIDs) of the remote device,
 * or null on error
 */
","/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 *
 * @return the supported features (UUIDs) of the remote device,
 * or null on error
 */
",0,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],0,,,,,,,4,0,"The change is in the assignment of the local variable 'service' and the condition in the if statement, where the method name for checking if Bluetooth is enabled has been changed from ""isBluetoothEnabled()"" to ""!isBluetoothEnabled()"". However, this change does not alter the semantics of the program because the negation operator is moved from outside the method call to inside the method call. So, the code change type is 4, which refers to other statement changed that does not fall under return statements, exception handling statements, and control dependency changes.","There is no compatibility issue here because the change in the if statement does not affect the final output of the method. The API still returns the same values under the same conditions, therefore, the behavior of the API is unchanged."
195,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,26,27,,,,"{
    if (this == obj)
        return true;
    if (!(obj instanceof ProgramInfo))
        return false;
    ProgramInfo other = (ProgramInfo) obj;
    if (mChannel != other.getChannel())
        return false;
    if (mSubChannel != other.getSubChannel())
        return false;
    if (mTuned != other.isTuned())
        return false;
    if (mStereo != other.isStereo())
        return false;
    if (mDigital != other.isDigital())
        return false;
    if (mSignalStrength != other.getSignalStrength())
        return false;
    if (mMetadata == null) {
        if (other.getMetadata() != null)
            return false;
    } else if (!mMetadata.equals(other.getMetadata()))
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof ProgramInfo))
        return false;
    ProgramInfo other = (ProgramInfo) obj;
    if (!mSelector.equals(other.getSelector()))
        return false;
    if (mTuned != other.isTuned())
        return false;
    if (mStereo != other.isStereo())
        return false;
    if (mDigital != other.isDigital())
        return false;
    if (mFlags != other.mFlags)
        return false;
    if (mSignalStrength != other.getSignalStrength())
        return false;
    if (mMetadata == null) {
        if (other.getMetadata() != null)
            return false;
    } else if (!mMetadata.equals(other.getMetadata()))
        return false;
    if (!mVendorInfo.equals(other.mVendorInfo))
        return false;
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4,5",1,The implementation of `equals` method has undergone several changes:,2. A new conditional checking `mSelector.equals(other.getSelector())` was added.
196,<android.net.NetworkCapabilities: boolean hasTransport(int)>,26,27,,,,"{
    if (transportType < MIN_TRANSPORT || transportType > MAX_TRANSPORT) {
        return false;
    }
    return ((mTransportTypes & (1 << transportType)) != 0);
}","{
    return isValidTransport(transportType) && ((mTransportTypes & (1 << transportType)) != 0);
}",1,"/**
 * Tests for the presence of a transport on this instance.
 *
 * @param transportType the {@code NetworkCapabilities.TRANSPORT_*} to be tested for.
 * @return {@code true} if set on this instance.
 */
","/**
 * Tests for the presence of a transport on this instance.
 *
 * @param transportType the {@code NetworkCapabilities.TRANSPORT_*} to be tested for.
 * @return {@code true} if set on this instance.
 */
",0,,,0,,,,,,,"3,4",0,"The control check for the transportType has been extracted to a method call isValidTransport(transportType), changing the control dependency and the implementation details, so the code change type is 3,4.","There's no Compatibility Issue since the behavior of the method has not fundamentally changed. All conditions that would return false before still return false, and the checking mechanism has been abstracted into another method, thus preserving behavior."
201,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,26,27,,,,"{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContextOpPackageName, appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException(""system server dead?"", e);
        }
    }
}","{
    if (sService == null) {
        return;
    }
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContextOpPackageName, appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException(""system server dead?"", e);
        }
    }
}",1,"/**
 * Stop listening to changes for this AppWidget.
 */
","/**
 * Stop listening to changes for this AppWidget.
 */
",0,,,0,,,,,,,"3,4",0,"The check for `sService == null` with `return` has been added to the top of the method, so the code change type is 3,4 due to the control flow change (an if check has been added) and other statement (the return statement).","There's no Compatibility Issue because the added if condition with the return statement only checks for the nullity of `sService` before proceeding with the previous implementation. If `sService` is null, the method now returns early, which prevents a NullPointerException that would have occurred in the early version. This change prevents crashes and unexpected behavior without changing the API's contract."
202,"<android.app.FragmentManagerImpl: void dispatchOnFragmentViewCreated(Fragment,View,Bundle,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentViewCreated(f, v, savedInstanceState, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentViewCreated(this, f, v, savedInstanceState);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentViewCreated(f, v, savedInstanceState, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentViewCreated(this, f, v, savedInstanceState);
        }
    }
}",1,,,0,,,0,,,,,,,"1,4",1,"The early version contains an if-statement checking if 'mLifecycleCallbacks' is null and returning early if it is, which has been removed in the late version. This is a removal of a return statement, which is a change type 1. Furthermore, this change does not fit into exception handling, control dependency, or dependent API changes; therefore, it also falls under other statement changed, which is a change type 4.","Removing the if-statement that returns early when 'mLifecycleCallbacks' is null means in the late implementation the method will continue to the for loop. If 'mLifecycleCallbacks' is null, it will cause a NullPointerException when the for-each loop tries to iterate over it. Hence, the late version could potentially throw an exception instead of returning early, and it could return differently if 'mLifecycleCallbacks' is not null because it always processes the callbacks now. Therefore, the CI type is 1."
203,"<android.app.FragmentState: Fragment instantiate(FragmentHostCallback,FragmentContainer,Fragment,FragmentManagerNonConfig)>",26,27,,,,"{
    if (mInstance == null) {
        final Context context = host.getContext();
        if (mArguments != null) {
            mArguments.setClassLoader(context.getClassLoader());
        }
        if (container != null) {
            mInstance = container.instantiate(context, mClassName, mArguments);
        } else {
            mInstance = Fragment.instantiate(context, mClassName, mArguments);
        }
        if (mSavedFragmentState != null) {
            mSavedFragmentState.setClassLoader(context.getClassLoader());
            mInstance.mSavedFragmentState = mSavedFragmentState;
        }
        mInstance.setIndex(mIndex, parent);
        mInstance.mFromLayout = mFromLayout;
        mInstance.mRestored = true;
        mInstance.mFragmentId = mFragmentId;
        mInstance.mContainerId = mContainerId;
        mInstance.mTag = mTag;
        mInstance.mRetainInstance = mRetainInstance;
        mInstance.mDetached = mDetached;
        mInstance.mHidden = mHidden;
        mInstance.mFragmentManager = host.mFragmentManager;
        if (FragmentManagerImpl.DEBUG)
            Log.v(FragmentManagerImpl.TAG, ""Instantiated fragment "" + mInstance);
    }
    mInstance.mChildNonConfig = childNonConfig;
    return mInstance;
}","{
    if (mInstance == null) {
        final Context context = host.getContext();
        if (mArguments != null) {
            mArguments.setClassLoader(context.getClassLoader());
        }
        if (container != null) {
            mInstance = container.instantiate(context, mClassName, mArguments);
        } else {
            mInstance = Fragment.instantiate(context, mClassName, mArguments);
        }
        if (mSavedFragmentState != null) {
            mSavedFragmentState.setClassLoader(context.getClassLoader());
            mInstance.mSavedFragmentState = mSavedFragmentState;
        }
        mInstance.setIndex(mIndex, parent);
        mInstance.mFromLayout = mFromLayout;
        mInstance.mRestored = true;
        mInstance.mFragmentId = mFragmentId;
        mInstance.mContainerId = mContainerId;
        mInstance.mTag = mTag;
        mInstance.mRetainInstance = mRetainInstance;
        mInstance.mDetached = mDetached;
        mInstance.mHidden = mHidden;
        mInstance.mFragmentManager = host.mFragmentManager;
        if (FragmentManagerImpl.DEBUG) {
            Log.v(FragmentManagerImpl.TAG, ""Instantiated fragment "" + mInstance);
        }
    }
    mInstance.mChildNonConfig = childNonConfig;
    return mInstance;
}",1,,,0,,,0,,,,,,,0,0,The implementation and annotations of the API have not changed between the two versions.,"Since there is no change in the API implementation between the versions, no compatibility issue could arise."
204,"<android.app.FragmentManagerImpl: void dispatchOnFragmentAttached(Fragment,Context,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentAttached(f, context, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentAttached(this, f, context);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentAttached(f, context, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentAttached(this, f, context);
        }
    }
}",1,,,0,,,0,,,,,,,1,1,"The early version includes a control flow that checks if `mLifecycleCallbacks` is null and, if so, returns early without calling any of the lifecycle callbacks. This control flow has been removed in the late version. As a result, the `return` statement has been deleted from the late version. This constitutes a change in the return statement (code change type 1).","The removal of the null check for `mLifecycleCallbacks` could potentially lead to a NullPointerException if `mLifecycleCallbacks` is null in the late version. This change could cause the API to behave differently if `mLifecycleCallbacks` is null, because in the early version it would safely return early, whereas in the late version, it attempts to iterate over `mLifecycleCallbacks` regardless and may throw an exception, causing a potential Compatibility Issue for return values or types (CI type 1)."
207,<android.content.pm.PackageInstaller.SessionInfo: Bitmap getAppIcon()>,26,27,,,,"{
    return appIcon;
}","{
    if (appIcon == null) {
        // lists, so try fetching the specific icon.
        try {
            final SessionInfo info = AppGlobals.getPackageManager().getPackageInstaller().getSessionInfo(sessionId);
            appIcon = (info != null) ? info.appIcon : null;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return appIcon;
}",1,"/**
 * Return an icon representing the app being installed. May be {@code null}
 * if unavailable.
 */
","/**
 * Return an icon representing the app being installed. May be {@code null}
 * if unavailable.
 */
",0,[@Nullable],[@Nullable],0,,,,,,,"1,3",1,"Control dependency changed with new 'if' condition to handle the scenario when appIcon is null, and other statements are included under this 'if' block. Additionally, return statement logic is modified to cope with the condition when appIcon is null, so this is a type 1,3 change.","The late version adds a condition to check if appIcon is null and, if so, attempts to retrieve it, possibly leading to fetching a different icon if appIcon was not set before. This could potentially lead to a different return value, and a new exception handling is introduced for RemoteException, making it a type 1 CI."
208,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,26,27,,,,"{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras);
                    break;
                }
            case PREPARED:
                {
                    int streamId = msg.arg1;
                    mCallbacks.onPrepared(streamId);
                    break;
                }
            case REPEATING_REQUEST_ERROR:
                {
                    long lastFrameNumber = msg.arg2 & 0xFFFFFFFFL;
                    lastFrameNumber = (lastFrameNumber << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    mCallbacks.onRepeatingRequestError(lastFrameNumber);
                    break;
                }
            case REQUEST_QUEUE_EMPTY:
                {
                    mCallbacks.onRequestQueueEmpty();
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}","{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras);
                    break;
                }
            case PREPARED:
                {
                    int streamId = msg.arg1;
                    mCallbacks.onPrepared(streamId);
                    break;
                }
            case REPEATING_REQUEST_ERROR:
                {
                    Object[] objArray = (Object[]) msg.obj;
                    long lastFrameNumber = (Long) objArray[0];
                    int repeatingRequestId = (Integer) objArray[1];
                    mCallbacks.onRepeatingRequestError(lastFrameNumber, repeatingRequestId);
                    break;
                }
            case REQUEST_QUEUE_EMPTY:
                {
                    mCallbacks.onRequestQueueEmpty();
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,5",1,"The implementation within the REPEATING_REQUEST_ERROR case has changed, with how the lastFrameNumber and repeatingRequestId are obtained and passed to the onRepeatingRequestError callback method. Therefore, the code change type is 3,5.",The change in how the lastFrameNumber and repeatingRequestId are extracted from msg.obj and the addition of repeatingRequestId as a parameter to the onRepeatingRequestError callback method can lead to different behavior when the message with REPEATING_REQUEST_ERROR is handled. This constitutes a change in the method's behavior and therefore a potential Compatibility Issue of type 1.
209,"<android.widget.RemoteViews.SetRemoteInputsAction: void apply(View,ViewGroup,OnClickHandler)>",26,27,,,,"{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    target.setTagInternal(R.id.remote_input_tag, remoteInputs);
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    target.setTagInternal(R.id.remote_input_tag, remoteInputs);
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",0,"The only change in the implementation is the target type from `TextView` to `View`, so the change type is 4. Additionally, the late version potentially relies on a changed API (the type of the `findViewById` result), so it is also type 5.","There is no Compatibility Issue detected because the change from `TextView` to `View` doesn't affect the called method `setTagInternal`. The method's behavior and signature remain the same, and it accepts `View` as its invoker. It also doesn't lead to a different value being returned nor different exceptions thrown because the existence check `if (target == null)` ensures that the method `setTagInternal` would be called regardless of the target's type as long as it is not null."
210,<android.app.FragmentManagerImpl: void dispatchOptionsMenuClosed(Menu)>,26,27,,,,"{
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null) {
                f.performOptionsMenuClosed(menu);
            }
        }
    }
}","{
    if (mCurState < Fragment.CREATED) {
        return;
    }
    for (int i = 0; i < mAdded.size(); i++) {
        Fragment f = mAdded.get(i);
        if (f != null) {
            f.performOptionsMenuClosed(menu);
        }
    }
}",1,,,0,,,0,,,,,,,3,0,"A new control flow statement, the 'if' condition that checks the state of mCurState, has been introduced before the for-loop, so the code change type is 3.","Although there is a change in the control flow, it does not lead to a Compatibility Issue because this change limits the method execution to only occur when certain state conditions (mCurState >= Fragment.CREATED) are met. If the state conditions are not met, the method now rightly exits earlier than in the previous version without affecting the eventual behavior (all callbacks to 'performOptionsMenuClosed' would not occur in either version if the state conditions are not met). This is more of a behavior refinement rather than a behavior change that would cause incompatibilities, so there is no Compatibility Issue."
211,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int,int)>",26,27,,,,"{
    if (mService != null) {
        try {
            if (!mService.isWallpaperSupported(context.getOpPackageName())) {
                return null;
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    synchronized (this) {
        if (mCachedWallpaper != null && mCachedWallpaperUserId == userId) {
            return mCachedWallpaper;
        }
        mCachedWallpaper = null;
        mCachedWallpaperUserId = 0;
        try {
            mCachedWallpaper = getCurrentWallpaperLocked(userId);
            mCachedWallpaperUserId = userId;
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""No memory load current wallpaper"", e);
        }
        if (mCachedWallpaper != null) {
            return mCachedWallpaper;
        }
    }
    if (returnDefault) {
        Bitmap defaultWallpaper = mDefaultWallpaper;
        if (defaultWallpaper == null) {
            defaultWallpaper = getDefaultWallpaper(context, which);
            synchronized (this) {
                mDefaultWallpaper = defaultWallpaper;
            }
        }
        return defaultWallpaper;
    }
    return null;
}","{
    if (mService != null) {
        try {
            if (!mService.isWallpaperSupported(context.getOpPackageName())) {
                return null;
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    synchronized (this) {
        if (mCachedWallpaper != null && mCachedWallpaperUserId == userId) {
            return mCachedWallpaper;
        }
        mCachedWallpaper = null;
        mCachedWallpaperUserId = 0;
        try {
            mCachedWallpaper = getCurrentWallpaperLocked(context, userId);
            mCachedWallpaperUserId = userId;
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""Out of memory loading the current wallpaper: "" + e);
        } catch (SecurityException e) {
            if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.O) {
                Log.w(TAG, ""No permission to access wallpaper, suppressing"" + "" exception to avoid crashing legacy app."");
            } else {
                // Post-O apps really most sincerely need the permission.
                throw e;
            }
        }
        if (mCachedWallpaper != null) {
            return mCachedWallpaper;
        }
    }
    if (returnDefault) {
        Bitmap defaultWallpaper = mDefaultWallpaper;
        if (defaultWallpaper == null) {
            defaultWallpaper = getDefaultWallpaper(context, which);
            synchronized (this) {
                mDefaultWallpaper = defaultWallpaper;
            }
        }
        return defaultWallpaper;
    }
    return null;
}",1,,,0,,,0,,,,,,,"2,4,5",2,"The implementation of the method has included additional exception handling for `SecurityException` and the control flow within the `try` block has been modified to include a different method call with an additional parameter (`getCurrentWallpaperLocked(context, userId)` instead of `getCurrentWallpaperLocked(userId)`), and logging message has been updated. These constitute change types 2 (Exception handling statement changed), 4 (Other statement changed due to log message modification), and 5 (Dependent API changed due to different method signature).","The new exception handling block could potentially result in a `SecurityException` being thrown where it was not previously thrown depending on the `targetSdkVersion` of the application context. Previously, there was no potential for a `SecurityException` to lead to a crash of a legacy app, but with this change, apps targeting SDK version greater than Oreo might crash when this exception is thrown. Moreover, the change in the dependent API could have an effect on the `Bitmap` being returned if the implementation of `getCurrentWallpaperLocked` behaves differently with the new context parameter. Therefore, there is a potential Compatibility Issue due to different exception handling, classifying this as CI type 2."
212,"<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertisingSet(AdvertisingSetParameters,AdvertiseData,AdvertiseData,PeriodicAdvertisingParameters,AdvertiseData,int,int,AdvertisingSetCallback,Handler)>",26,27,,,,"{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    boolean isConnectable = parameters.isConnectable();
    if (parameters.isLegacy()) {
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy scan response data too big"");
        }
    } else {
        boolean supportCodedPhy = mBluetoothAdapter.isLeCodedPhySupported();
        boolean support2MPhy = mBluetoothAdapter.isLe2MPhySupported();
        int pphy = parameters.getPrimaryPhy();
        int sphy = parameters.getSecondaryPhy();
        if (pphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) {
            throw new IllegalArgumentException(""Unsupported primary PHY selected"");
        }
        if ((sphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) || (sphy == BluetoothDevice.PHY_LE_2M && !support2MPhy)) {
            throw new IllegalArgumentException(""Unsupported secondary PHY selected"");
        }
        int maxData = mBluetoothAdapter.getLeMaximumAdvertisingDataLength();
        if (totalBytes(advertiseData, isConnectable) > maxData) {
            throw new IllegalArgumentException(""Advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > maxData) {
            throw new IllegalArgumentException(""Scan response data too big"");
        }
        if (totalBytes(periodicData, false) > maxData) {
            throw new IllegalArgumentException(""Periodic advertising data too big"");
        }
        boolean supportPeriodic = mBluetoothAdapter.isLePeriodicAdvertisingSupported();
        if (periodicParameters != null && !supportPeriodic) {
            throw new IllegalArgumentException(""Controller does not support LE Periodic Advertising"");
        }
    }
    if (maxExtendedAdvertisingEvents < 0 || maxExtendedAdvertisingEvents > 255) {
        throw new IllegalArgumentException(""maxExtendedAdvertisingEvents out of range: "" + maxExtendedAdvertisingEvents);
    }
    if (maxExtendedAdvertisingEvents != 0 && !mBluetoothAdapter.isLePeriodicAdvertisingSupported()) {
        throw new IllegalArgumentException(""Can't use maxExtendedAdvertisingEvents with controller that don't support "" + ""LE Extended Advertising"");
    }
    if (duration < 0 || duration > 65535) {
        throw new IllegalArgumentException(""duration out of range: "" + duration);
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to get Bluetooth gatt - "", e);
        throw new IllegalStateException(""Failed to get Bluetooth"");
    }
    IAdvertisingSetCallback wrapped = wrap(callback, handler);
    if (mCallbackWrappers.putIfAbsent(callback, wrapped) != null) {
        throw new IllegalArgumentException(""callback instance already associated with advertising"");
    }
    try {
        gatt.startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, duration, maxExtendedAdvertisingEvents, wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to start advertising set - "", e);
        throw new IllegalStateException(""Failed to start advertising set"");
    }
}","{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    boolean isConnectable = parameters.isConnectable();
    if (parameters.isLegacy()) {
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy scan response data too big"");
        }
    } else {
        boolean supportCodedPhy = mBluetoothAdapter.isLeCodedPhySupported();
        boolean support2MPhy = mBluetoothAdapter.isLe2MPhySupported();
        int pphy = parameters.getPrimaryPhy();
        int sphy = parameters.getSecondaryPhy();
        if (pphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) {
            throw new IllegalArgumentException(""Unsupported primary PHY selected"");
        }
        if ((sphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) || (sphy == BluetoothDevice.PHY_LE_2M && !support2MPhy)) {
            throw new IllegalArgumentException(""Unsupported secondary PHY selected"");
        }
        int maxData = mBluetoothAdapter.getLeMaximumAdvertisingDataLength();
        if (totalBytes(advertiseData, isConnectable) > maxData) {
            throw new IllegalArgumentException(""Advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > maxData) {
            throw new IllegalArgumentException(""Scan response data too big"");
        }
        if (totalBytes(periodicData, false) > maxData) {
            throw new IllegalArgumentException(""Periodic advertising data too big"");
        }
        boolean supportPeriodic = mBluetoothAdapter.isLePeriodicAdvertisingSupported();
        if (periodicParameters != null && !supportPeriodic) {
            throw new IllegalArgumentException(""Controller does not support LE Periodic Advertising"");
        }
    }
    if (maxExtendedAdvertisingEvents < 0 || maxExtendedAdvertisingEvents > 255) {
        throw new IllegalArgumentException(""maxExtendedAdvertisingEvents out of range: "" + maxExtendedAdvertisingEvents);
    }
    if (maxExtendedAdvertisingEvents != 0 && !mBluetoothAdapter.isLePeriodicAdvertisingSupported()) {
        throw new IllegalArgumentException(""Can't use maxExtendedAdvertisingEvents with controller that don't support "" + ""LE Extended Advertising"");
    }
    if (duration < 0 || duration > 65535) {
        throw new IllegalArgumentException(""duration out of range: "" + duration);
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to get Bluetooth gatt - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    IAdvertisingSetCallback wrapped = wrap(callback, handler);
    if (mCallbackWrappers.putIfAbsent(callback, wrapped) != null) {
        throw new IllegalArgumentException(""callback instance already associated with advertising"");
    }
    try {
        gatt.startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, duration, maxExtendedAdvertisingEvents, wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to start advertising set - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
}",1,"/**
 * Creates a new advertising set. If operation succeed, device will start advertising. This
 * method returns immediately, the operation status is delivered through
 * {@code callback.onAdvertisingSetStarted()}.
 * <p>
 * @param parameters Advertising set parameters.
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed
 * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the
 * advertisement is connectable, three bytes will be added for flags.
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param periodicParameters Periodic advertisng parameters. If null, periodic advertising will
 * not be started.
 * @param periodicData Periodic advertising data. Size must not exceed
 * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to
 * 65535 (655,350 ms). 0 means advertising should continue until stopped.
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended
 * advertising, even if the duration has not expired. Valid range is
 * from 1 to 255. 0 means no maximum.
 * @param callback Callback for advertising set.
 * @param handler Thread upon which the callbacks will be invoked.
 * @throws IllegalArgumentException When any of the data parameter exceed the maximum allowable
 * size, or unsupported advertising PHY is selected, or when attempt to use
 * Periodic Advertising feature is made when it's not supported by the
 * controller, or when maxExtendedAdvertisingEvents is used on a controller
 * that doesn't support the LE Extended Advertising
 */
","/**
 * Creates a new advertising set. If operation succeed, device will start advertising. This
 * method returns immediately, the operation status is delivered through
 * {@code callback.onAdvertisingSetStarted()}.
 * <p>
 * @param parameters Advertising set parameters.
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed
 * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the
 * advertisement is connectable, three bytes will be added for flags.
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param periodicParameters Periodic advertisng parameters. If null, periodic advertising will
 * not be started.
 * @param periodicData Periodic advertising data. Size must not exceed
 * {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to
 * 65535 (655,350 ms). 0 means advertising should continue until stopped.
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended
 * advertising, even if the duration has not expired. Valid range is
 * from 1 to 255. 0 means no maximum.
 * @param callback Callback for advertising set.
 * @param handler Thread upon which the callbacks will be invoked.
 * @throws IllegalArgumentException When any of the data parameter exceed the maximum allowable
 * size, or unsupported advertising PHY is selected, or when attempt to use
 * Periodic Advertising feature is made when it's not supported by the
 * controller, or when maxExtendedAdvertisingEvents is used on a controller
 * that doesn't support the LE Extended Advertising
 */
",0,,,0,,,,,,,,,,
213,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,26,27,,,,"{
    try {
        return sService.allocateAppWidgetId(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (sService == null) {
        return -1;
    }
    try {
        return sService.allocateAppWidgetId(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
","/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
",0,,,0,,,,,,,3,0,"The late version of the API includes a new 'if' check for the 'sService' object being 'null'. If 'sService' is null, the method returns -1 immediately. Therefore, the change is an addition of a control dependency, classified as type 3.","The introduction of this 'if' statement does not lead to a compatibility issue. If 'sService' is non-null, the subsequent behavior of the API remains unchanged. If it were null in the early version, a NullPointerException would have occurred, which is a RuntimeException, similar to the RuntimeException that is thrown when a RemoteException occurs. Because the behavior in error conditions remains consistent (throwing an exception), there is no compatibility issue, so the CI type is 0."
214,<android.app.Fragment: void performDestroy()>,26,27,,,,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroy();
    }
    mState = INITIALIZING;
    mCalled = false;
    onDestroy();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDestroy()"");
    }
    mChildFragmentManager = null;
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroy();
    }
    mState = INITIALIZING;
    mCalled = false;
    mIsCreated = false;
    onDestroy();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDestroy()"");
    }
    mChildFragmentManager = null;
}",1,,,0,,,0,,,,,,,4,0,The introduction of a new assignment statement `mIsCreated = false;` is an other statement changed (type 4).,"However, the newly added statement does not affect the return value or exception throwing behavior of the API, hence it does not introduce a Compatibility Issue (CI type 0)."
215,<android.content.pm.PackageInstaller.Session: void commit(IntentSender)>,26,27,,,,"{
    try {
        mSession.commit(statusReceiver);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mSession.commit(statusReceiver, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Attempt to commit everything staged in this session. This may require
 * user intervention, and so it may not happen immediately. The final
 * result of the commit will be reported through the given callback.
 * <p>
 * Once this method is called, the session is sealed and no additional
 * mutations may be performed on the session. If the device reboots
 * before the session has been finalized, you may commit the session again.
 *
 * @throws SecurityException if streams opened through
 * {@link #openWrite(String, long, long)} are still open.
 */
","/**
 * Attempt to commit everything staged in this session. This may require
 * user intervention, and so it may not happen immediately. The final
 * result of the commit will be reported through the given callback.
 * <p>
 * Once this method is called, the session is sealed and no additional
 * mutations may be performed on the session. If the device reboots
 * before the session has been finalized, you may commit the session again.
 *
 * @throws SecurityException if streams opened through
 * {@link #openWrite(String, long, long)} are still open.
 */
",0,,,0,,,,,,,5,0,"The change involves passing a new parameter 'false' to the method commit() of object mSession, indicating that the definition of the dependent API commit() has changed, perhaps to include an additional boolean parameter. Hence, the code change type is 5.","Although there's a change in the method commit() of mSession, the behavior of the API in focus (PackageInstaller.Session.commit) remains consistent in terms of handling exceptions and the nature of the operation performed. It simply delegates to another API with different parameters. As the try-catch block and the exception type have not changed and no indication of a change in return type or exception handling in the dependent API, there is no compatibility issue reported, and the CI type is 0."
216,"<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentActivityCreated(this, f, savedInstanceState);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentActivityCreated(this, f, savedInstanceState);
        }
    }
}",1,,,0,,,0,,,,,,,"1,3",1,"The early version includes a return statement inside a condition that checks if 'mLifecycleCallbacks' is null, which is removed in the late version. Also, the control dependency related to the removed return statement has changed, since the loop now always executes regardless of 'mLifecycleCallbacks' being null or not. Therefore, the code change types are 1 and 3.","Removing the return statement when 'mLifecycleCallbacks' is null changes the method's behavior because in the early version, nothing happens when 'mLifecycleCallbacks' is null but in the late version, the loop attempts to execute, potentially leading to a NullPointerException. This is a compatibility issue of type 1 because the late version API may behave differently (i.e., throw an exception where it previously wouldn't have)."
217,<android.hardware.camera2.legacy.CameraDeviceUserShim: void endConfigure(int)>,26,27,,,,"{
    if (DEBUG) {
        Log.d(TAG, ""endConfigure called."");
    }
    if (mLegacyDevice.isClosed()) {
        String err = ""Cannot end configure, device has been closed."";
        Log.e(TAG, err);
        throw new ServiceSpecificException(ICameraService.ERROR_DISCONNECTED, err);
    }
    if (operatingMode != ICameraDeviceUser.NORMAL_MODE) {
        String err = ""LEGACY devices do not support this operating mode"";
        Log.e(TAG, err);
        throw new ServiceSpecificException(ICameraService.ERROR_ILLEGAL_ARGUMENT, err);
    }
    SparseArray<Surface> surfaces = null;
    synchronized (mConfigureLock) {
        if (!mConfiguring) {
            String err = ""Cannot end configure, no configuration change in progress."";
            Log.e(TAG, err);
            throw new ServiceSpecificException(ICameraService.ERROR_INVALID_OPERATION, err);
        }
        if (mSurfaces != null) {
            surfaces = mSurfaces.clone();
        }
        mConfiguring = false;
    }
    mLegacyDevice.configureOutputs(surfaces);
}","{
    if (DEBUG) {
        Log.d(TAG, ""endConfigure called."");
    }
    if (mLegacyDevice.isClosed()) {
        String err = ""Cannot end configure, device has been closed."";
        Log.e(TAG, err);
        synchronized (mConfigureLock) {
            mConfiguring = false;
        }
        throw new ServiceSpecificException(ICameraService.ERROR_DISCONNECTED, err);
    }
    if (operatingMode != ICameraDeviceUser.NORMAL_MODE) {
        String err = ""LEGACY devices do not support this operating mode"";
        Log.e(TAG, err);
        synchronized (mConfigureLock) {
            mConfiguring = false;
        }
        throw new ServiceSpecificException(ICameraService.ERROR_ILLEGAL_ARGUMENT, err);
    }
    SparseArray<Surface> surfaces = null;
    synchronized (mConfigureLock) {
        if (!mConfiguring) {
            String err = ""Cannot end configure, no configuration change in progress."";
            Log.e(TAG, err);
            throw new ServiceSpecificException(ICameraService.ERROR_INVALID_OPERATION, err);
        }
        if (mSurfaces != null) {
            surfaces = mSurfaces.clone();
        }
        mConfiguring = false;
    }
    mLegacyDevice.configureOutputs(surfaces);
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,4",0,"The only changes are inside the exception handling blocks. The variable `mConfiguring` is set to false within synchronized blocks, which is a change in exception handling, so the code change type is 2. There is also a structural change where the synchronized blocks were added within the if conditions leading up to the exceptions, which are Other statement changed type 4.","There is no Compatibility Issue detected as the behavior of setting `mConfiguring` to false would not affect the output of the method since the exceptions are thrown immediately after this operation. The changes ensure the proper state of `mConfiguring` before throwing an exception, but the observable behavior (the API throwing an exception) remains the same, therefore there's no difference in the return values or exception handling compared to the client's perspective."
218,<android.net.nsd.NsdManager: void unregisterService(RegistrationListener)>,26,27,,,,"{
    int id = getListenerKey(listener);
    if (id == INVALID_LISTENER_KEY) {
        throw new IllegalArgumentException(""listener not registered"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    mAsyncChannel.sendMessage(UNREGISTER_SERVICE, 0, id);
}","{
    int id = getListenerKey(listener);
    mAsyncChannel.sendMessage(UNREGISTER_SERVICE, 0, id);
}",1,"/**
 * Unregister a service registered through {@link #registerService}. A successful
 * unregister is notified to the application with a call to
 * {@link RegistrationListener#onServiceUnregistered}.
 *
 * @param listener This should be the listener object that was passed to
 * {@link #registerService}. It identifies the service that should be unregistered
 * and notifies of a successful or unsuccessful unregistration via the listener
 * callbacks.  In API versions 20 and above, the listener object may be used for
 * another service registration once the callback has been called.  In API versions <= 19,
 * there is no entirely reliable way to know when a listener may be re-used, and a new
 * listener should be created for each service registration request.
 */
","/**
 * Unregister a service registered through {@link #registerService}. A successful
 * unregister is notified to the application with a call to
 * {@link RegistrationListener#onServiceUnregistered}.
 *
 * @param listener This should be the listener object that was passed to
 * {@link #registerService}. It identifies the service that should be unregistered
 * and notifies of a successful or unsuccessful unregistration via the listener
 * callbacks.  In API versions 20 and above, the listener object may be used for
 * another service registration once the callback has been called.  In API versions <= 19,
 * there is no entirely reliable way to know when a listener may be re-used, and a new
 * listener should be created for each service registration request.
 */
",0,,,0,,,,,,,"2,3",2,"The exception handling statements that check the validity of the listener and throw IllegalArgumentException have been removed, and these changes affect control flow. Therefore, the code change types are 2 and 3.","With the removal of the exception handling statements, this API may not throw an IllegalArgumentException where it previously would have in the early version when provided an invalid or null listener. Thus, the type of Compatibility Issue is 2, caused by potential different exception handlings."
219,<android.app.FragmentManagerImpl: void unregisterFragmentLifecycleCallbacks(FragmentLifecycleCallbacks)>,26,27,,,,"{
    if (mLifecycleCallbacks == null) {
        return;
    }
    synchronized (mLifecycleCallbacks) {
        for (int i = 0, N = mLifecycleCallbacks.size(); i < N; i++) {
            if (mLifecycleCallbacks.get(i).first == cb) {
                mLifecycleCallbacks.remove(i);
                break;
            }
        }
    }
}","{
    synchronized (mLifecycleCallbacks) {
        for (int i = 0, N = mLifecycleCallbacks.size(); i < N; i++) {
            if (mLifecycleCallbacks.get(i).first == cb) {
                mLifecycleCallbacks.remove(i);
                break;
            }
        }
    }
}",1,,,0,,,0,,,,,,,"1,3",0,"The early implementation contains a null check that returns early if `mLifecycleCallbacks` is null, this statement has been removed. Therefore, the change types are 1 (return statement changed) and 3 (control dependency changed).","Although the early implementation can return early if `mLifecycleCallbacks` is null, and the late implementation will instead proceed into a synchronized block, this does not constitute a compatibility issue because no value is returned from within the synchronized block and no exceptions are thrown. The removal of the null check does not impact the behavior of the API in a way visible to the caller, as there is no change in the output or exceptions that the method could produce. Therefore, there is no compatibility issue (0)."
220,<android.bluetooth.BluetoothDevice: String getName()>,26,27,,,,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device name"");
        return null;
    }
    try {
        return sService.getRemoteName(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device name"");
        return null;
    }
    try {
        return service.getRemoteName(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 *
 * @return the Bluetooth name, or null if there was a problem.
 */
","/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 *
 * @return the Bluetooth name, or null if there was a problem.
 */
",0,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],0,,,,,,,0,0,"No significant change has been made, the line `final IBluetooth service = sService;` has been added, but it's simply assigning the existing `sService` to a local variable before doing the same null-check and operations as before.","There is no compatibility issue as there is no change in the behavior of the API; it still checks if the service is null, returns null if it is, otherwise it attempts to get the remote name handling exceptions in the same way."
221,<android.app.Activity: void reportFullyDrawn()>,26,27,,,,"{
    if (mDoReportFullyDrawn) {
        mDoReportFullyDrawn = false;
        try {
            ActivityManager.getService().reportActivityFullyDrawn(mToken);
        } catch (RemoteException e) {
        }
    }
}","{
    if (mDoReportFullyDrawn) {
        mDoReportFullyDrawn = false;
        try {
            ActivityManager.getService().reportActivityFullyDrawn(mToken, mRestoredFromBundle);
        } catch (RemoteException e) {
        }
    }
}",1,"/**
 * Report to the system that your app is now fully drawn, purely for diagnostic
 * purposes (calling it does not impact the visible behavior of the activity).
 * This is only used to help instrument application launch times, so that the
 * app can report when it is fully in a usable state; without this, the only thing
 * the system itself can determine is the point at which the activity's window
 * is <em>first</em> drawn and displayed.  To participate in app launch time
 * measurement, you should always call this method after first launch (when
 * {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 * entirely drawn your UI and populated with all of the significant data.  You
 * can safely call this method any time after first launch as well, in which case
 * it will simply be ignored.
 */
","/**
 * Report to the system that your app is now fully drawn, purely for diagnostic
 * purposes (calling it does not impact the visible behavior of the activity).
 * This is only used to help instrument application launch times, so that the
 * app can report when it is fully in a usable state; without this, the only thing
 * the system itself can determine is the point at which the activity's window
 * is <em>first</em> drawn and displayed.  To participate in app launch time
 * measurement, you should always call this method after first launch (when
 * {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 * entirely drawn your UI and populated with all of the significant data.  You
 * can safely call this method any time after first launch as well, in which case
 * it will simply be ignored.
 */
",0,,,0,,,,,,,5,0,"There is a change in the dependent API call; ActivityManager.getService().reportActivityFullyDrawn(mToken) is replaced with ActivityManager.getService().reportActivityFullyDrawn(mToken, mRestoredFromBundle), with an additional parameter, so the change type is 5.","The change in the dependent API does not introduce a Compatibility Issue because the method signature remains the same and there is no change in exception handling or return values (the method is void, and no new exceptions are thrown). Hence, no CI is detected."
222,"<android.app.FragmentManagerImpl: void dispatchOnFragmentResumed(Fragment,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentResumed(f, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentResumed(this, f);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentResumed(f, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentResumed(this, f);
        }
    }
}",1,,,0,,,0,,,,,,,1,0,"A return statement has been deleted, so the code change type is 1.","There is no Compatibility Issue that would arise due to this change because the deleted return statement is conditional on mLifecycleCallbacks being null, which just skips the subsequent for-loop. Since there are no changes to the for-loop's execution or the conditions under which it runs, the method's behavior remains consistent with the previous version in terms of functionality; hence no CI arises."
224,<android.net.IpSecManager.UdpEncapsulationSocket: FileDescriptor getSocket()>,26,27,,,,"{
    return mFd;
}","{
    if (mPfd == null) {
        return null;
    }
    return mPfd.getFileDescriptor();
}",1,"/**
 * Access the inner UDP Encapsulation Socket
 */
","/**
 * Access the inner UDP Encapsulation Socket
 */
",0,,,0,,,,,,,"1,3",0,"The control dependency has changed due to the addition of an if-statement, and the return statement has changed from directly returning mFd to checking mPfd and then returning mPfd.getFileDescriptor(). The change types are 1,3.","There is no Compatibility Issue because any invocation of getSocket() that would have previously returned mFd would now return mPfd.getFileDescriptor(), which is expected to be the same FileDescriptor object, provided that mPfd is not null. The new if-statement adds a null check on mPfd which can lead to the method returning null, which is a new behavior compared to always getting a non-null mFd in the early version. However, this does not constitute a change in the type of value returned by the method or a change in exception handling, so there is no Compatibility Issue in the sense of causing existing code that depends on this API to behave incorrectly. The method simply provides more robust error checking and handles a potential null case that the previous implementation presumably did not account for."
225,<android.widget.TimePickerSpinnerDelegate: void setMinute(int)>,26,27,,,,"{
    if (minute == getMinute()) {
        return;
    }
    mMinuteSpinner.setValue(minute);
    onTimeChanged();
}","{
    setCurrentMinute(minute, true);
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",0,"The internal implementation of setting the minute value has been refactored from directly setting the value through mMinuteSpinner and calling onTimeChanged(), to calling setCurrentMinute with the minute and a boolean parameter. Thus, the change type is 4 due to the alteration in the implementation and 5 because it's relying on another method (setCurrentMinute) whose definition or behavior could have changed.","Assuming setCurrentMinute(minute, true) is correctly refactored to check if the minute is equal to the current minute, and if not, set the value and perform necessary side effects (similar to the early version's onTimeChanged()), there would be no change in behavior for callers of setMinute(int). Thus, there should be no compatibility issue, and CI type is 0. However, this assumption relies on the correct behavior of setCurrentMinute, which is not provided in this context."
227,<android.net.IpSecManager.UdpEncapsulationSocket: void close()>,26,27,,,,"{
    // TODO: Go close the socket
    mCloseGuard.close();
}","{
    try {
        mService.closeUdpEncapsulationSocket(mResourceId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    try {
        mPfd.close();
    } catch (IOException e) {
        Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port= "" + mPort);
        throw e;
    }
    mCloseGuard.close();
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,4",2,"The late implementation has added more code, which includes a try-catch block that calls mService.closeUdpEncapsulationSocket(mResourceId) and can throw exceptions, and another try-catch block for mPfd.close() that also could throw an IOException. The method now contains significant functionality rather than just closing the CloseGuard. With an exception handling statement changed and an additional closing mechanism, the change type is 2,4.","Since the new implementation throws an exception from a remote service directly and does not swallow an IOException (instead, rethrows it after logging), clients could experience a different exception handling behavior. Therefore, it introduces a Compatibility Issue caused by a potential different exception handlings, and the CI type is 2."
232,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",26,27,,,,"{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        if (f.mState == Fragment.INITIALIZING && f.isInBackStack()) {
            // Allow the fragment to be created so that it can be saved later.
            newState = Fragment.CREATED;
        } else {
            // While removing a fragment, we can't change it to a higher state.
            newState = f.mState;
        }
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState <= newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.getAnimatingAway() != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.setAnimatingAway(null);
            moveToState(f, f.getStateAfterAnimating(), 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (newState > Fragment.INITIALIZING) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto CREATED: "" + f);
                    if (f.mSavedFragmentState != null) {
                        f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                        f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                        if (f.mTarget != null) {
                            f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                        }
                        f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                        if (!f.mUserVisibleHint) {
                            f.mDeferStart = true;
                            if (newState > Fragment.STOPPED) {
                                newState = Fragment.STOPPED;
                            }
                        }
                    }
                    f.mHost = mHost;
                    f.mParentFragment = mParent;
                    f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();
                    // so that this one can rely on it as an initialized dependency.
                    if (f.mTarget != null) {
                        if (mActive.get(f.mTarget.mIndex) != f.mTarget) {
                            throw new IllegalStateException(""Fragment "" + f + "" declared target fragment "" + f.mTarget + "" that does not belong to this FragmentManager!"");
                        }
                        if (f.mTarget.mState < Fragment.CREATED) {
                            moveToState(f.mTarget, Fragment.CREATED, 0, 0, true);
                        }
                    }
                    dispatchOnFragmentPreAttached(f, mHost.getContext(), false);
                    f.mCalled = false;
                    f.onAttach(mHost.getContext());
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                    }
                    if (f.mParentFragment == null) {
                        mHost.onAttachFragment(f);
                    } else {
                        f.mParentFragment.onAttachFragment(f);
                    }
                    dispatchOnFragmentAttached(f, mHost.getContext(), false);
                    if (!f.mRetaining) {
                        dispatchOnFragmentPreCreated(f, f.mSavedFragmentState, false);
                        f.performCreate(f.mSavedFragmentState);
                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);
                    } else {
                        f.restoreChildFragmentState(f.mSavedFragmentState, true);
                        f.mState = Fragment.CREATED;
                    }
                    f.mRetaining = false;
                }
            // fall through
            case Fragment.CREATED:
                // This is outside the if statement below on purpose; we want this to run
                // even if we do a moveToState from CREATED => *, CREATED => CREATED, and
                // * => CREATED as part of the case fallthrough above.
                ensureInflatedFragmentView(f);
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            if (f.mContainerId == View.NO_ID) {
                                throwException(new IllegalArgumentException(""Cannot create fragment "" + f + "" for a container view with no id""));
                            }
                            container = mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                String resName;
                                try {
                                    resName = f.getResources().getResourceName(f.mContainerId);
                                } catch (NotFoundException e) {
                                    resName = ""unknown"";
                                }
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + resName + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.performGetLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                container.addView(f.mView);
                            }
                            if (f.mHidden) {
                                f.mView.setVisibility(View.GONE);
                            }
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false);
                            // Only animate the view if it is visible. This is done after
                            // dispatchOnFragmentViewCreated in case visibility is changed
                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE) && f.mContainer != null;
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState > Fragment.ACTIVITY_CREATED) {
                    f.mState = Fragment.STOPPED;
                }
            // fall through
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                    dispatchOnFragmentStarted(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.performResume();
                    dispatchOnFragmentResumed(f, false);
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                    dispatchOnFragmentPaused(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                    dispatchOnFragmentStopped(f, false);
                }
            // fall through
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    dispatchOnFragmentViewDestroyed(f, false);
                    if (f.mView != null && f.mContainer != null) {
                        if (getTargetSdk() >= Build.VERSION_CODES.O) {
                            // Stop any current animations:
                            f.mView.clearAnimation();
                            f.mContainer.endViewTransition(f.mView);
                        }
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed && f.mView.getVisibility() == View.VISIBLE && f.mView.getTransitionAlpha() > 0) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        f.mView.setTransitionAlpha(1f);
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.setAnimatingAway(anim);
                            f.setStateAfterAnimating(newState);
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.getAnimatingAway() != null) {
                                        fragment.setAnimatingAway(null);
                                        moveToState(fragment, fragment.getStateAfterAnimating(), 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            setHWLayerAnimListenerIfAlpha(f.mView, anim);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                    f.mInLayout = false;
                }
            // fall through
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.getAnimatingAway() != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.getAnimatingAway();
                            f.setAnimatingAway(null);
                            anim.cancel();
                        }
                    }
                    if (f.getAnimatingAway() != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.setStateAfterAnimating(newState);
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                            dispatchOnFragmentDestroyed(f, false);
                        } else {
                            f.mState = Fragment.INITIALIZING;
                        }
                        f.performDetach();
                        dispatchOnFragmentDetached(f, false);
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    if (f.mState != newState) {
        Log.w(TAG, ""moveToState: Fragment state for "" + f + "" not updated inline; "" + ""expected state "" + newState + "" found "" + f.mState);
        f.mState = newState;
    }
}","{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        if (f.mState == Fragment.INITIALIZING && f.isInBackStack()) {
            // Allow the fragment to be created so that it can be saved later.
            newState = Fragment.CREATED;
        } else {
            // While removing a fragment, we can't change it to a higher state.
            newState = f.mState;
        }
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState <= newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.getAnimatingAway() != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.setAnimatingAway(null);
            moveToState(f, f.getStateAfterAnimating(), 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (newState > Fragment.INITIALIZING) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto CREATED: "" + f);
                    if (f.mSavedFragmentState != null) {
                        f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                        f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                        if (f.mTarget != null) {
                            f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                        }
                        f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                        if (!f.mUserVisibleHint) {
                            f.mDeferStart = true;
                            if (newState > Fragment.STOPPED) {
                                newState = Fragment.STOPPED;
                            }
                        }
                    }
                    f.mHost = mHost;
                    f.mParentFragment = mParent;
                    f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();
                    // so that this one can rely on it as an initialized dependency.
                    if (f.mTarget != null) {
                        if (mActive.get(f.mTarget.mIndex) != f.mTarget) {
                            throw new IllegalStateException(""Fragment "" + f + "" declared target fragment "" + f.mTarget + "" that does not belong to this FragmentManager!"");
                        }
                        if (f.mTarget.mState < Fragment.CREATED) {
                            moveToState(f.mTarget, Fragment.CREATED, 0, 0, true);
                        }
                    }
                    dispatchOnFragmentPreAttached(f, mHost.getContext(), false);
                    f.mCalled = false;
                    f.onAttach(mHost.getContext());
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                    }
                    if (f.mParentFragment == null) {
                        mHost.onAttachFragment(f);
                    } else {
                        f.mParentFragment.onAttachFragment(f);
                    }
                    dispatchOnFragmentAttached(f, mHost.getContext(), false);
                    if (!f.mIsCreated) {
                        dispatchOnFragmentPreCreated(f, f.mSavedFragmentState, false);
                        f.performCreate(f.mSavedFragmentState);
                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);
                    } else {
                        f.restoreChildFragmentState(f.mSavedFragmentState, true);
                        f.mState = Fragment.CREATED;
                    }
                    f.mRetaining = false;
                }
            // fall through
            case Fragment.CREATED:
                // This is outside the if statement below on purpose; we want this to run
                // even if we do a moveToState from CREATED => *, CREATED => CREATED, and
                // * => CREATED as part of the case fallthrough above.
                ensureInflatedFragmentView(f);
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            if (f.mContainerId == View.NO_ID) {
                                throwException(new IllegalArgumentException(""Cannot create fragment "" + f + "" for a container view with no id""));
                            }
                            container = mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                String resName;
                                try {
                                    resName = f.getResources().getResourceName(f.mContainerId);
                                } catch (NotFoundException e) {
                                    resName = ""unknown"";
                                }
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + resName + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.performGetLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                container.addView(f.mView);
                            }
                            if (f.mHidden) {
                                f.mView.setVisibility(View.GONE);
                            }
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false);
                            // Only animate the view if it is visible. This is done after
                            // dispatchOnFragmentViewCreated in case visibility is changed
                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE) && f.mContainer != null;
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState > Fragment.ACTIVITY_CREATED) {
                    f.mState = Fragment.STOPPED;
                }
            // fall through
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                    dispatchOnFragmentStarted(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.performResume();
                    dispatchOnFragmentResumed(f, false);
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                    dispatchOnFragmentPaused(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                    dispatchOnFragmentStopped(f, false);
                }
            // fall through
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    dispatchOnFragmentViewDestroyed(f, false);
                    if (f.mView != null && f.mContainer != null) {
                        if (getTargetSdk() >= Build.VERSION_CODES.O) {
                            // Stop any current animations:
                            f.mView.clearAnimation();
                            f.mContainer.endViewTransition(f.mView);
                        }
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed && f.mView.getVisibility() == View.VISIBLE && f.mView.getTransitionAlpha() > 0) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        f.mView.setTransitionAlpha(1f);
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.setAnimatingAway(anim);
                            f.setStateAfterAnimating(newState);
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    Animator animator = f.getAnimatingAway();
                                    f.setAnimatingAway(null);
                                    // there was no animation and skip the moveToState()
                                    if (container.indexOfChild(view) == -1 && animator != null) {
                                        moveToState(fragment, fragment.getStateAfterAnimating(), 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            setHWLayerAnimListenerIfAlpha(f.mView, anim);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                    f.mInLayout = false;
                }
            // fall through
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.getAnimatingAway() != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.getAnimatingAway();
                            f.setAnimatingAway(null);
                            anim.cancel();
                        }
                    }
                    if (f.getAnimatingAway() != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.setStateAfterAnimating(newState);
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                            dispatchOnFragmentDestroyed(f, false);
                        } else {
                            f.mState = Fragment.INITIALIZING;
                        }
                        f.performDetach();
                        dispatchOnFragmentDetached(f, false);
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    if (f.mState != newState) {
        Log.w(TAG, ""moveToState: Fragment state for "" + f + "" not updated inline; "" + ""expected state "" + newState + "" found "" + f.mState);
        f.mState = newState;
    }
}",1,,,0,"[@SuppressWarnings(""ReferenceEquality"")]","[@SuppressWarnings(""ReferenceEquality"")]",0,,,,,,,,,,
234,<android.hardware.camera2.CameraManager.CameraManagerGlobal: ICameraService getCameraService()>,26,27,,,,"{
    synchronized (mLock) {
        connectCameraServiceLocked();
        if (mCameraService == null) {
            Log.e(TAG, ""Camera service is unavailable"");
        }
        return mCameraService;
    }
}","{
    synchronized (mLock) {
        connectCameraServiceLocked();
        if (mCameraService == null && !sCameraServiceDisabled) {
            Log.e(TAG, ""Camera service is unavailable"");
        }
        return mCameraService;
    }
}",1,"/**
 * Return a best-effort ICameraService.
 *
 * <p>This will be null if the camera service is not currently available. If the camera
 * service has died since the last use of the camera service, will try to reconnect to the
 * service.</p>
 */
","/**
 * Return a best-effort ICameraService.
 *
 * <p>This will be null if the camera service is not currently available. If the camera
 * service has died since the last use of the camera service, will try to reconnect to the
 * service.</p>
 */
",0,,,0,,,,,,,3,0,"The control dependency changed with the addition of an extra condition in the 'if' statement which checks 'sCameraServiceDisabled', so the code change type is 3.","Although there's a change in the control dependency, it does not lead to a compatibility issue, because regardless of the new condition, the method still returns 'mCameraService', which means the behavior of the API remains consistent in terms of the return value. Hence, the CI type is 0."
236,<android.bluetooth.BluetoothHeadset: boolean isAudioConnected(BluetoothDevice)>,26,27,,,,"{
    if (VDBG)
        log(""isAudioConnected()"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.isAudioConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}","{
    if (VDBG)
        log(""isAudioConnected()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.isAudioConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}",1,"/**
 * Check if Bluetooth SCO audio is connected.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return true if SCO is connected,
 * false otherwise or on error
 */
","/**
 * Check if Bluetooth SCO audio is connected.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return true if SCO is connected,
 * false otherwise or on error
 */
",0,,,0,,,,,,,4,0,"The only change is the local final variable 'service' introduced to hold the value of 'mService' before the usage inside the conditional block. This does not change the external behaviour of the API since it's an internal refactoring that improves code quality without affecting functionality, so the code change type is 4.","No Compatibility Issue is present since the method's behaviour, return value, and the exceptions it may throw remain the same between the two versions, hence the CI type is 0."
237,<android.net.NetworkInfo: String toString()>,26,27,,,,"{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""["");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", failover: "").append(mIsFailover).append("", available: "").append(mIsAvailable).append("", roaming: "").append(mIsRoaming).append("", metered: "").append(mIsMetered).append(""]"");
        return builder.toString();
    }
}","{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""["");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", failover: "").append(mIsFailover).append("", available: "").append(mIsAvailable).append("", roaming: "").append(mIsRoaming).append(""]"");
        return builder.toString();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,1,The method implementation was changed by removing the metered status information from the output string. This constitutes a change in category 4 (Other statement changed).,"Since the method return value reflects the internal state of the NetworkInfo object, and this state representation has been modified by removing the metered status, a Compatibility Issue arises. Clients that rely on parsing the former 'metered' status will not find this information anymore, potentially leading to different behavior or incorrect assumptions. Thus, it falls under CI type 1 (Compatibility Issue caused by potential different return values)."
238,<android.hardware.usb.UsbManager: boolean hasPermission(UsbAccessory)>,26,27,,,,"{
    try {
        return mService.hasAccessoryPermission(accessory);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null) {
        return false;
    }
    try {
        return mService.hasAccessoryPermission(accessory);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the caller has permission to access the accessory.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbAccessory, PendingIntent)} or
 * by the user choosing the caller as the default application for the accessory.
 *
 * @param accessory to check permissions for
 * @return true if caller has permission
 */
","/**
 * Returns true if the caller has permission to access the accessory.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbAccessory, PendingIntent)} or
 * by the user choosing the caller as the default application for the accessory.
 *
 * @param accessory to check permissions for
 * @return true if caller has permission
 */
",0,,,0,,,,,,,3,1,"An if condition is introduced that checks if mService is null, and if so, it returns false, which is a change in the control dependency.","Due to the newly introduced if statement, there is a scenario (when mService is null) where the late version of the API will return false without calling mService.hasAccessoryPermission(accessory), which can potentially lead to a different behaviour compared to the early version. Therefore, this is a CI caused by potential different return values or types, and the CI type is 1."
239,<android.companion.CompanionDeviceManager.CallbackProxy: void onFailure(CharSequence)>,26,27,,,,"{
    mHandler.post(() -> mCallback.onFailure(reason));
}","{
    Handler handler = mHandler;
    if (handler == null)
        return;
    handler.post(() -> {
        Callback callback = mCallback;
        if (callback == null)
            return;
        callback.onFailure(reason);
    });
}",1,,,0,[@Override],[@Override],0,,,,,,,"3, 4",0,"The code change includes the addition of null-checks before using the handler and the callback, which are control dependency changes and other statement changes, so the change type is 3, 4.","There is no change in the method's return type, as it is a void method. The logic change adds null-checks to prevent potential NullPointerExceptions, which is an added safety check and does not alter the behavior of the existing code. Hence, there is no change that could potentially lead to a compatibility issue, and the CI type is 0."
240,<android.content.Intent: Intent cloneFilter()>,26,27,,,,"{
    return new Intent(this, false);
}","{
    return new Intent(this, COPY_MODE_FILTER);
}",1,"/**
 * Make a clone of only the parts of the Intent that are relevant for
 * filter matching: the action, data, type, component, and categories.
 */
","/**
 * Make a clone of only the parts of the Intent that are relevant for
 * filter matching: the action, data, type, component, and categories.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,5,0,"The constructor of Intent called in the return statement has changed its parameter from a boolean to presumably a predefined constant COPY_MODE_FILTER, indicating that Dependency API has changed, so the change type is 5.","Although the constructor parameter for Intent has changed, it is implied by the method name (cloneFilter) and the parameters passed (the context of ""this"" and COPY_MODE_FILTER) that the new constructor is meant to serve the same purpose but with possibly a cleaner API or newer implementation. Since the purpose of the method cloneFilter() likely remains the same (to clone the Intent with filter-related data), it does not introduce a behavioral change that would lead to a Compatibility Issue. Therefore, the CI type is 0."
241,<android.net.IpSecManager.UdpEncapsulationSocket: int getPort()>,26,27,,,,"{
    // TODO get the port number from the Socket;
    return 0;
}","{
    return mPort;
}",1,"/**
 * Retrieve the port number of the inner encapsulation socket
 */
","/**
 * Retrieve the port number of the inner encapsulation socket
 */
",0,,,0,,,,,,,1,1,The implementation of the method has changed from returning a constant value '0' to returning a variable 'mPort'. Thus the change type is 1.,"This change in the return statement causes the API to return a potentially different value in the late version compared to the early version, where it always returned 0. Therefore, the CI type is 1."
243,<android.app.ActivityOptions: Bundle toBundle()>,26,27,,,,"{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    b.putInt(KEY_LAUNCH_STACK_ID, mLaunchStackId);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    b.putInt(KEY_DOCK_CREATE_MODE, mDockCreateMode);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    return b;
}","{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    b.putInt(KEY_LAUNCH_STACK_ID, mLaunchStackId);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    b.putInt(KEY_DOCK_CREATE_MODE, mDockCreateMode);
    b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",0,,,0,,,,,,,,,,
244,<android.view.ViewGroup: void clearFocusedInCluster(View)>,26,27,,,,"{
    if (mFocusedInCluster != child) {
        return;
    }
    View top = findKeyboardNavigationCluster();
    ViewParent parent = this;
    do {
        ((ViewGroup) parent).mFocusedInCluster = null;
        if (parent == top) {
            break;
        }
        parent = parent.getParent();
    } while (parent instanceof ViewGroup);
}","{
    if (mFocusedInCluster != child) {
        return;
    }
    clearFocusedInCluster();
}",1,"/**
 * Removes {@code child} (and associated focusedInCluster chain) from the cluster containing
 * it.
 * <br>
 * This is intended to be run on {@code child}'s immediate parent. This is necessary because
 * the chain is sometimes cleared after {@code child} has been detached.
 */
","/**
 * Removes {@code child} (and associated focusedInCluster chain) from the cluster containing
 * it.
 * <br>
 * This is intended to be run on {@code child}'s immediate parent. This is necessary because
 * the chain is sometimes cleared after {@code child} has been detached.
 */
",0,,,0,,,,,,,"1,5",1,"The implementation of the method has completely changed in which a new method clearFocusedInCluster() is introduced. Because the body of the method is replaced with a single method call, there is a significant code change, likely altering behavior. This is likely a Dependent API change, as it now depends on another method for implementation, and it's also a return statement change because the method now directly exits after a single method call which potentially changes the return behavior of the method.","The potential compatibility issue here is caused by a different return behavior due to the changed implementation of the method and possibly the changed behavior of the new method clearFocusedInCluster(). Therefore, the CI type is 1."
245,"<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>",26,27,,,,"{
    // Slot in a restore helper for the older wallpaper backup schema to support restore
    // from devices still generating data in that format.
    mWallpaperHelper = new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO }, new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY });
    addHelper(WALLPAPER_HELPER, mWallpaperHelper);
    // On restore, we also support a long-ago wallpaper data schema ""system_files""
    addHelper(""system_files"", new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE }, new String[] { WALLPAPER_IMAGE_KEY }));
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    addHelper(PERMISSION_HELPER, new PermissionBackupHelper());
    addHelper(USAGE_STATS_HELPER, new UsageStatsBackupHelper(this));
    addHelper(SHORTCUT_MANAGER_HELPER, new ShortcutBackupHelper());
    addHelper(ACCOUNT_MANAGER_HELPER, new AccountManagerBackupHelper());
    try {
        super.onRestore(data, appVersionCode, newState);
        IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
        if (wallpaper != null) {
            try {
                wallpaper.settingsRestored();
            } catch (RemoteException re) {
                Slog.e(TAG, ""Couldn't restore settings\n"" + re);
            }
        }
    } catch (IOException ex) {
        // If there was a failure, delete everything for the wallpaper, this is too aggressive,
        // but this is hopefully a rare failure.
        Slog.d(TAG, ""restore failed"", ex);
        (new File(WALLPAPER_IMAGE)).delete();
        (new File(WALLPAPER_INFO)).delete();
    }
}","{
    // Slot in a restore helper for the older wallpaper backup schema to support restore
    // from devices still generating data in that format.
    mWallpaperHelper = new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE_KEY });
    addHelper(WALLPAPER_HELPER, mWallpaperHelper);
    // On restore, we also support a long-ago wallpaper data schema ""system_files""
    addHelper(""system_files"", new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE_KEY }));
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    addHelper(PERMISSION_HELPER, new PermissionBackupHelper());
    addHelper(USAGE_STATS_HELPER, new UsageStatsBackupHelper(this));
    addHelper(SHORTCUT_MANAGER_HELPER, new ShortcutBackupHelper());
    addHelper(ACCOUNT_MANAGER_HELPER, new AccountManagerBackupHelper());
    super.onRestore(data, appVersionCode, newState);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4,5",1,"The instantiation of mWallpaperHelper has changed, as it now takes fewer parameters – only WALLPAPER_IMAGE_KEY instead of both WALLPAPER_IMAGE and WALLPAPER_INFO in the array and WALLPAPER_IMAGE_KEY and WALLPAPER_INFO_KEY in the second array. This indicates a change in how the wallpaper data is processed during restoration, which falls under Other statement changed. Additionally, this change likely affects the dependent API of WallpaperBackupHelper, qualifying as Dependent API changed.",
246,<android.bluetooth.BluetoothDevice: int getBondState()>,26,27,,,,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot get bond state"");
        return BOND_NONE;
    }
    try {
        return sService.getBondState(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } catch (NullPointerException npe) {
        // Handle case where bluetooth service proxy
        // is already null.
        Log.e(TAG, ""NullPointerException for getBondState() of device ("" + getAddress() + "")"", npe);
    }
    return BOND_NONE;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get bond state"");
        return BOND_NONE;
    }
    try {
        return service.getBondState(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return BOND_NONE;
}",1,"/**
 * Get the bond state of the remote device.
 * <p>Possible values for the bond state are:
 * {@link #BOND_NONE},
 * {@link #BOND_BONDING},
 * {@link #BOND_BONDED}.
 *
 * @return the bond state
 */
","/**
 * Get the bond state of the remote device.
 * <p>Possible values for the bond state are:
 * {@link #BOND_NONE},
 * {@link #BOND_BONDING},
 * {@link #BOND_BONDED}.
 *
 * @return the bond state
 */
",0,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],0,,,,,,,"3,4",0,"There is a local variable 'service' introduced to hold the value of 'sService' and the NullPointerException catch block has been removed. Therefore, the code change types are 3,4.","The Introduction of a local reference to 'sService' doesn’t change any behavior of the method and the removal of the NullPointerException catch block is a behavior-preserving change since 'NullPointerException' was never thrown by the method 'getBondState' itself but was a safeguard for the proxy object, which has now become redundant. Consequently, there's no Compatibility Issue, so CI type is 0."
247,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,26,27,,,,"{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false);
        } else {
            id = getAutofillId(view);
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true);
                } else {
                    view.setAutofilled(false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false);
            }
        }
        if (!mEnabled || mSessionId == NO_SESSION) {
            return;
        }
        if (id == null) {
            id = getAutofillId(view);
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false);
        } else {
            id = getAutofillId(view);
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true);
                } else {
                    view.setAutofilled(false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false);
            }
        }
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose && mEnabled) {
                Log.v(TAG, ""notifyValueChanged("" + view + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        if (id == null) {
            id = getAutofillId(view);
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}",1,"/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
","/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
",0,,,0,,,,,,,3,0,"The only change detected is in the condition of the if-statement: from `mSessionId == NO_SESSION` to `!isActiveLocked()`. There is a change in a control dependency, categorized as type 3.","Even though there is a change in the control statement, it does not necessarily lead to a compatibility issue since the function's behavior remains consistent: it exits the method early if the autofill is either not enabled or not active, analogous to the previous 'no session' check. Assuming `isActiveLocked()` method is correctly providing the combined check previously made explicit by `mEnabled` and `mSessionId == NO_SESSION`, the behavior of returning from the method should remain consistent with the exception to the logging call added. However, this does not affect code that would be calling `notifyValueChanged(View)`, thus there is no compatibility issue as per the definitions."
248,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int captureBurst(List<CaptureRequest>,CaptureCallback,Handler)>",26,27,,,,"{
    if (requests == null) {
        throw new IllegalArgumentException(""Requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""Requests must have at least one element"");
    }
    for (CaptureRequest request : requests) {
        if (request.isReprocess()) {
            if (!isReprocessable()) {
                throw new IllegalArgumentException(""This capture session cannot handle "" + ""reprocess requests"");
            } else if (request.getReprocessableSessionId() != mId) {
                throw new IllegalArgumentException(""Capture request was created for another "" + ""session"");
            }
        }
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (DEBUG) {
        CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
        Log.v(TAG, mIdString + ""captureBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler "" + handler);
    }
    return addPendingSequence(mDeviceImpl.captureBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}","{
    if (requests == null) {
        throw new IllegalArgumentException(""Requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""Requests must have at least one element"");
    }
    for (CaptureRequest request : requests) {
        if (request.isReprocess()) {
            if (!isReprocessable()) {
                throw new IllegalArgumentException(""This capture session cannot handle "" + ""reprocess requests"");
            } else if (request.getReprocessableSessionId() != mId) {
                throw new IllegalArgumentException(""Capture request was created for another "" + ""session"");
            }
        }
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
            Log.v(TAG, mIdString + ""captureBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler "" + handler);
        }
        return addPendingSequence(mDeviceImpl.captureBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"Code inside the method is now surrounded by a synchronized block on the object mDeviceImpl.mInterfaceLock. The rest of the code, including the return statement and exception handling, remains unchanged.","The addition of the synchronized block does not change the behavior of the method with respect to the return value or exception throwing; it just ensures thread safety when accessing shared resources. Therefore, there is no compatibility issue with potential different return values or exception handling."
250,<android.app.FragmentManagerImpl: boolean dispatchOptionsItemSelected(MenuItem)>,26,27,,,,"{
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null) {
                if (f.performOptionsItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    if (mCurState < Fragment.CREATED) {
        return false;
    }
    for (int i = 0; i < mAdded.size(); i++) {
        Fragment f = mAdded.get(i);
        if (f != null) {
            if (f.performOptionsItemSelected(item)) {
                return true;
            }
        }
    }
    return false;
}",1,,,0,,,0,,,,,,,3,1,"The control flow has changed by introducing an additional condition: if (mCurState < Fragment.CREATED). If this condition is true, the method returns false immediately, which alters the behavior from the early version where this condition was not checked.","This control flow change can lead to a Compatibility Issue where the method may return a different value compared to the early version—specifically, it may return false earlier without iterating over mAdded when mCurState is less than Fragment.CREATED, whereas in the early version it always iterates over mAdded if it's not null regardless of the value of mCurState. Thus, the CI type is 1."
251,<android.service.autofill.SaveInfo.Builder: SaveInfo build()>,26,27,,,,"{
    throwIfDestroyed();
    mDestroyed = true;
    return new SaveInfo(this);
}","{
    throwIfDestroyed();
    Preconditions.checkState(!ArrayUtils.isEmpty(mRequiredIds) || !ArrayUtils.isEmpty(mOptionalIds), ""must have at least one required or optional id"");
    mDestroyed = true;
    return new SaveInfo(this);
}",1,"/**
 * Builds a new {@link SaveInfo} instance.
 */
","/**
 * Builds a new {@link SaveInfo} instance.
 *
 * @throws IllegalStateException if no
 * {@link #SaveInfo.Builder(int, AutofillId[]) required ids}
 * or {@link #setOptionalIds(AutofillId[]) optional ids} were set
 */
",1,,,0,,,,,,,"3,4",0,"An additional precondition check has been added, which changes the control flow. Other than that, there's no other change in return statements or exception handling statements. Therefore, the change types are 3 for control dependency and 4 for other statement change.","The added precondition check does not introduce a new type of exception or change the return type. It simply enforces a check on the existing inputs and throws an IllegalStateException if the condition is met. Since this is enforcing existing API constraints more strictly rather than changing the behavior, no Compatibility Issue is introduced in this context. The type is 0 (no Compatibility Issue)."
253,<android.app.FragmentManagerImpl: boolean dispatchPrepareOptionsMenu(Menu)>,26,27,,,,"{
    boolean show = false;
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null) {
                if (f.performPrepareOptionsMenu(menu)) {
                    show = true;
                }
            }
        }
    }
    return show;
}","{
    if (mCurState < Fragment.CREATED) {
        return false;
    }
    boolean show = false;
    for (int i = 0; i < mAdded.size(); i++) {
        Fragment f = mAdded.get(i);
        if (f != null) {
            if (f.performPrepareOptionsMenu(menu)) {
                show = true;
            }
        }
    }
    return show;
}",1,,,0,,,0,,,,,,,"1,3",1,"The condition checking the current state with mCurState < Fragment.CREATED was added, and this affects whether the method returns false before the other logic is executed. There is also a change in control dependency because there's a new conditional statement that could prevent the rest of the method from executing. So, the code change types are 1 and 3.","The newly added condition can cause the method to return false early, resulting in a different return value under certain circumstances. This is a potential compatibility issue since the previous implementation did not have an early return and would always run through the for loop; thus, the CI type is 1."
254,<android.appwidget.AppWidgetHost: void startListening()>,26,27,,,,"{
    final int[] idsToUpdate;
    synchronized (mViews) {
        int N = mViews.size();
        idsToUpdate = new int[N];
        for (int i = 0; i < N; i++) {
            idsToUpdate[i] = mViews.keyAt(i);
        }
    }
    List<PendingHostUpdate> updates;
    try {
        updates = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, idsToUpdate).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    int N = updates.size();
    for (int i = 0; i < N; i++) {
        PendingHostUpdate update = updates.get(i);
        switch(update.type) {
            case PendingHostUpdate.TYPE_VIEWS_UPDATE:
                updateAppWidgetView(update.appWidgetId, update.views);
                break;
            case PendingHostUpdate.TYPE_PROVIDER_CHANGED:
                onProviderChanged(update.appWidgetId, update.widgetInfo);
                break;
            case PendingHostUpdate.TYPE_VIEW_DATA_CHANGED:
                viewDataChanged(update.appWidgetId, update.viewId);
        }
    }
}","{
    if (sService == null) {
        return;
    }
    final int[] idsToUpdate;
    synchronized (mViews) {
        int N = mViews.size();
        idsToUpdate = new int[N];
        for (int i = 0; i < N; i++) {
            idsToUpdate[i] = mViews.keyAt(i);
        }
    }
    List<PendingHostUpdate> updates;
    try {
        updates = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, idsToUpdate).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    int N = updates.size();
    for (int i = 0; i < N; i++) {
        PendingHostUpdate update = updates.get(i);
        switch(update.type) {
            case PendingHostUpdate.TYPE_VIEWS_UPDATE:
                updateAppWidgetView(update.appWidgetId, update.views);
                break;
            case PendingHostUpdate.TYPE_PROVIDER_CHANGED:
                onProviderChanged(update.appWidgetId, update.widgetInfo);
                break;
            case PendingHostUpdate.TYPE_VIEW_DATA_CHANGED:
                viewDataChanged(update.appWidgetId, update.viewId);
        }
    }
}",1,"/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
","/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
",0,,,0,,,,,,,3,0,"An 'if' statement that checks if 'sService' is null has been introduced at the beginning of the method, so the code change type is 3 (Control dependency changed).","Even though there's a new control statement introduced, it does not cause a Compatibility Issue because the added check for sService being null would prevent a NullPointerException which would be consistent with the method's intention of halting execution if the service is not available. There are no changes in the behavior of the method concerning return values or exception handling beyond this added resiliency to null. Therefore, there is no Compatibility Issue."
256,<android.app.Notification.Builder: int resolveContrastColor()>,26,27,,,,"{
    if (mCachedContrastColorIsFor == mN.color && mCachedContrastColor != COLOR_INVALID) {
        return mCachedContrastColor;
    }
    int color;
    int background = mBackgroundColorHint;
    if (mBackgroundColorHint == COLOR_INVALID) {
        background = mContext.getColor(com.android.internal.R.color.notification_material_background_color);
    }
    if (mN.color == COLOR_DEFAULT) {
        ensureColors();
        color = mSecondaryTextColor;
    } else {
        color = NotificationColorUtil.resolveContrastColor(mContext, mN.color, background);
    }
    if (Color.alpha(color) < 255) {
        // alpha doesn't go well for color filters, so let's blend it manually
        color = NotificationColorUtil.compositeColors(color, background);
    }
    mCachedContrastColorIsFor = mN.color;
    return mCachedContrastColor = color;
}","{
    if (mCachedContrastColorIsFor == mN.color && mCachedContrastColor != COLOR_INVALID) {
        return mCachedContrastColor;
    }
    int color;
    int background = mBackgroundColorHint;
    if (mBackgroundColorHint == COLOR_INVALID) {
        background = mContext.getColor(com.android.internal.R.color.notification_material_background_color);
    }
    if (mN.color == COLOR_DEFAULT) {
        ensureColors();
        color = mSecondaryTextColor;
    } else {
        color = NotificationColorUtil.resolveContrastColor(mContext, mN.color, background, mInNightMode);
    }
    if (Color.alpha(color) < 255) {
        // alpha doesn't go well for color filters, so let's blend it manually
        color = NotificationColorUtil.compositeColors(color, background);
    }
    mCachedContrastColorIsFor = mN.color;
    return mCachedContrastColor = color;
}",1,,,0,,,0,,,,,,,5,0,"The parameter list of the method call to NotificationColorUtil.resolveContrastColor() has been expanded by one additional argument (mInNightMode). This indicates a change in the dependent API, so the code change type is 5.","Even though the implementation now passes an additional parameter to NotificationColorUtil.resolveContrastColor(), this change does not necessarily lead to a different return value or changed exception handling, as the called method (a dependent API) is responsible for handling the new parameter. Without further information on the behavior of NotificationColorUtil.resolveContrastColor() with the new parameter, it cannot be determined that a CI has been introduced solely based on this additional attribute in the method call. Therefore, there is no sufficient evidence to predict a potential CI."
257,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",26,27,,,,"{
    SQLiteDatabase db = new SQLiteDatabase(path, flags, factory, errorHandler);
    db.open();
    return db;
}","{
    SQLiteDatabase db = new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1);
    db.open();
    return db;
}",1,"/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
","/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
",0,,,0,,,,,,,"4,5",0,"The constructor for `SQLiteDatabase` has additional parameters in the late version, indicating a change in the dependent API being used, therefore it's classified as 4 (Other statement changed) and 5 (Dependent API changed).","Despite the change in parameters for the constructor, the returned object type remains `SQLiteDatabase`, and there is no change in the exception handling or control flow. Therefore, there is no potential Compatibility Issue in terms of different return values or exception handlings. The change in the constructor does not inherently affect the behavior of the `openDatabase` method. It may simply be accommodating additional internal functionality that does not impact the API contract. Hence, the CI is classified as 0 (No Compatibility Issue)."
259,<android.content.res.Configuration: int diff(Configuration)>,26,27,,,,"{
    return diff(delta, false);
}","{
    return diff(delta, false, /* compareUndefined */
    false);
}",1,"/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 * {@link android.content.pm.ActivityInfo#CONFIG_LAYOUT_DIRECTION
 * PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION}.
 */
","/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 * {@link android.content.pm.ActivityInfo#CONFIG_LAYOUT_DIRECTION
 * PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION}.
 */
",0,,,0,,,,,,,"1,5",0,"The method call within the return statement now includes an additional parameter, indicating that the signature of the dependent method `diff` has changed. The code change type is thus 1,5.","Although there is a change to the dependent API, the call to the `diff` method is still using the same initial boolean value for the second parameter, and the newly introduced third parameter is also a constant `false`. Given that constant values are used and assuming no behavioral change of the internal `diff` method's handling of these parameters, this should not introduce a Compatibility Issue. Therefore, there might be no Compatibility Issue, or if the internal handling of the third parameter does change behavior when set to `false`, the code review does not provide enough information to infer this. Hence, we are assuming no Compatibility Issue, and the CI type is 0."
263,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",26,27,,,,"{
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContextOpPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}","{
    if (sService == null) {
        return null;
    }
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContextOpPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}",1,"/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
","/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
",0,,,0,,,,,,,3,1,"The control flow has changed due to the addition of an 'if' condition checking for whether sService == null and returning null if this is true. This is a control dependency change, so the code change type is 3.","The new 'if' statement can alter the behavior by potentially returning null, which would not have happened in the early version. This is a change to the behavior of the API that can lead to different return values, so the CI type is 1."
264,"<android.animation.AnimatorSet: void animateBasedOnPlayTime(long,long,boolean)>",26,27,,,,"{
    if (currentPlayTime < 0 || lastPlayTime < 0) {
        throw new UnsupportedOperationException(""Error: Play time should never be negative."");
    }
    // Convert the play times to the forward direction.
    if (inReverse) {
        if (getTotalDuration() == DURATION_INFINITE) {
            throw new UnsupportedOperationException(""Cannot reverse AnimatorSet with infinite"" + "" duration"");
        }
        long duration = getTotalDuration() - mStartDelay;
        currentPlayTime = Math.min(currentPlayTime, duration);
        currentPlayTime = duration - currentPlayTime;
        lastPlayTime = duration - lastPlayTime;
        inReverse = false;
    }
    // Skip all values to start, and iterate mEvents to get animations to the right fraction.
    skipToStartValue(false);
    ArrayList<Node> unfinishedNodes = new ArrayList<>();
    // Assumes forward playing from here on.
    for (int i = 0; i < mEvents.size(); i++) {
        AnimationEvent event = mEvents.get(i);
        if (event.getTime() > currentPlayTime) {
            break;
        }
        // play time, add to the unfinished list.
        if (event.mEvent == AnimationEvent.ANIMATION_DELAY_ENDED) {
            if (event.mNode.mEndTime == DURATION_INFINITE || event.mNode.mEndTime > currentPlayTime) {
                unfinishedNodes.add(event.mNode);
            }
        }
        // they would in a normal run.
        if (event.mEvent == AnimationEvent.ANIMATION_END) {
            // Skip to the end of the animation.
            event.mNode.mAnimation.skipToEndValue(false);
        }
    }
    // Seek unfinished animation to the right time.
    for (int i = 0; i < unfinishedNodes.size(); i++) {
        Node node = unfinishedNodes.get(i);
        long playTime = getPlayTimeForNode(currentPlayTime, node, inReverse);
        if (!inReverse) {
            playTime -= node.mAnimation.getStartDelay();
        }
        node.mAnimation.animateBasedOnPlayTime(playTime, lastPlayTime, inReverse);
    }
}","{
    if (currentPlayTime < 0 || lastPlayTime < 0) {
        throw new UnsupportedOperationException(""Error: Play time should never be negative."");
    }
    // Convert the play times to the forward direction.
    if (inReverse) {
        if (getTotalDuration() == DURATION_INFINITE) {
            throw new UnsupportedOperationException(""Cannot reverse AnimatorSet with infinite"" + "" duration"");
        }
        long duration = getTotalDuration() - mStartDelay;
        currentPlayTime = Math.min(currentPlayTime, duration);
        currentPlayTime = duration - currentPlayTime;
        lastPlayTime = duration - lastPlayTime;
        inReverse = false;
    }
    // Skip all values to start, and iterate mEvents to get animations to the right fraction.
    skipToStartValue(false);
    ArrayList<Node> unfinishedNodes = new ArrayList<>();
    // Assumes forward playing from here on.
    for (int i = 0; i < mEvents.size(); i++) {
        AnimationEvent event = mEvents.get(i);
        if (event.getTime() > currentPlayTime || event.getTime() == DURATION_INFINITE) {
            break;
        }
        // play time, add to the unfinished list.
        if (event.mEvent == AnimationEvent.ANIMATION_DELAY_ENDED) {
            if (event.mNode.mEndTime == DURATION_INFINITE || event.mNode.mEndTime > currentPlayTime) {
                unfinishedNodes.add(event.mNode);
            }
        }
        // they would in a normal run.
        if (event.mEvent == AnimationEvent.ANIMATION_END) {
            // Skip to the end of the animation.
            event.mNode.mAnimation.skipToEndValue(false);
        }
    }
    // Seek unfinished animation to the right time.
    for (int i = 0; i < unfinishedNodes.size(); i++) {
        Node node = unfinishedNodes.get(i);
        long playTime = getPlayTimeForNode(currentPlayTime, node, inReverse);
        if (!inReverse) {
            playTime -= node.mAnimation.getStartDelay();
        }
        node.mAnimation.animateBasedOnPlayTime(playTime, lastPlayTime, inReverse);
    }
}",1,"/**
 * Internal only.
 *
 * This method sets the animation values based on the play time. It also fast forward or
 * backward all the child animations progress accordingly.
 *
 * This method is also responsible for calling
 * {@link android.view.animation.Animation.AnimationListener#onAnimationRepeat(Animation)},
 * as needed, based on the last play time and current play time.
 */
","/**
 * Internal only.
 *
 * This method sets the animation values based on the play time. It also fast forward or
 * backward all the child animations progress accordingly.
 *
 * This method is also responsible for calling
 * {@link android.view.animation.Animation.AnimationListener#onAnimationRepeat(Animation)},
 * as needed, based on the last play time and current play time.
 */
",0,[@Override],[@Override],0,,,,,,,3,0,"The only change in the method implementation is the addition of `|| event.getTime() == DURATION_INFINITE` to the if-statement's condition. This represents a control dependency change, as it introduces a new way a loop can be terminated and therefore is classified as change type 3.","Since the additional condition `event.getTime() == DURATION_INFINITE` only adds an extra scenario under which the loop terminates, it does not introduce any new return values or exceptions. This new condition aligns with the existing logic that deals with infinite durations and is likely meant to handle edge cases in a similar, controlled manner. Thus, there is no Compatibility Issue because the method's contract seems to remain intact from the perspective of the caller; the returned values and thrown exceptions should be consistent with the previous implementation, classified as CI type 0."
266,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,26,27,,,,"{
    switch(format) {
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
            return HAL_PIXEL_FORMAT_BLOB;
        case ImageFormat.DEPTH16:
            return HAL_PIXEL_FORMAT_Y16;
        default:
            return format;
    }
}","{
    switch(format) {
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
            return HAL_PIXEL_FORMAT_BLOB;
        case ImageFormat.DEPTH16:
            return HAL_PIXEL_FORMAT_Y16;
        case ImageFormat.RAW_DEPTH:
            return HAL_PIXEL_FORMAT_RAW16;
        default:
            return format;
    }
}",1,"/**
 * Convert a public format compatible with {@code ImageFormat} to an internal format
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH16 => HAL_PIXEL_FORMAT_Y16
 * </ul>
 * </p>
 *
 * <p>Passing in an internal format which has a different public format equivalent will fail.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
","/**
 * Convert a public format compatible with {@code ImageFormat} to an internal format
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH16 => HAL_PIXEL_FORMAT_Y16
 * </ul>
 * </p>
 *
 * <p>Passing in an internal format which has a different public format equivalent will fail.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
",0,,,0,,,,,,,3,1,"A new case has been added to the switch statement for ImageFormat.RAW_DEPTH, so the code change type is 3.","By adding a new case in the switch statement for a specific image format, the method now potentially returns a different value (HAL_PIXEL_FORMAT_RAW16) when the input format is ImageFormat.RAW_DEPTH. Therefore, the CI type is 1 because the API can return a different value than before."
267,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityAction> getActionList()>,26,27,,,,"{
    if (mActions == null) {
        return Collections.emptyList();
    }
    return mActions;
}","{
    return CollectionUtils.emptyIfNull(mActions);
}",1,"/**
 * Gets the actions that can be performed on the node.
 */
","/**
 * Gets the actions that can be performed on the node.
 */
",0,,,0,,,,,,,4,0,"The implementation is changed from direct null check and using Collections.emptyList() to using CollectionUtils.emptyIfNull(mActions), so the change type is 4.","The behavior of returning an empty list when mActions is null remains the same, only the method of achieving this has been refactored. Hence, there is no Compatibility Issue, as the return value will still be an empty list or `mActions` when it's not null."
268,"<android.app.FragmentManagerImpl: void dispatchOnFragmentCreated(Fragment,Bundle,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentCreated(f, savedInstanceState, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentCreated(this, f, savedInstanceState);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentCreated(f, savedInstanceState, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentCreated(this, f, savedInstanceState);
        }
    }
}",1,,,0,,,0,,,,,,,4,0,"An if statement with a return statement (`if (mLifecycleCallbacks == null) { return; }`) that prevents further execution if `mLifecycleCallbacks` is null has been removed. Therefore, the type of code change is 4.","Even though an if statement with a return has been removed, the for-loop immediately following the removed if statement already requires `mLifecycleCallbacks` to be non-null; if `mLifecycleCallbacks` were null, a NullPointerException would be thrown when attempting to iterate over it. Since the implementation assumes `mLifecycleCallbacks` is non-null due to the for-loop, the behavior of the API remains unchanged. Therefore, there is no Compatibility Issue."
271,<android.app.ContextImpl: File getObbDir()>,26,27,,,,"{
    // Operates on primary external storage
    return getObbDirs()[0];
}","{
    // Operates on primary external storage
    final File[] dirs = getObbDirs();
    return (dirs != null && dirs.length > 0) ? dirs[0] : null;
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"There is an introduction of additional logic that checks if the result from getObbDirs() is null or the length is greater than 0 before accessing the first element. This is a change in the control dependency of the return statement, so the code change type is 3.","In the late version, an additional safety check is implemented which could potentially return null if the getObbDirs() result is null or has a length of 0. This change in the flow of execution can lead to a different return value (null instead of a possible ArrayIndexOutOfBoundsException in the early implementation if the array is empty), resulting in a potential Compatibility Issue, thus the CI type is 1."
273,"<android.util.TimeUtils: TimeZone getTimeZone(int,boolean,long,String)>",26,27,,,,"{
    TimeZone best = null;
    final Date d = new Date(when);
    TimeZone current = TimeZone.getDefault();
    String currentName = current.getID();
    int currentOffset = current.getOffset(when);
    boolean currentDst = current.inDaylightTime(d);
    for (TimeZone tz : getTimeZones(country)) {
        if (tz.getID().equals(currentName)) {
            if (currentOffset == offset && currentDst == dst) {
                return current;
            }
        }
        if (best == null) {
            if (tz.getOffset(when) == offset && tz.inDaylightTime(d) == dst) {
                best = tz;
            }
        }
    }
    return best;
}","{
    android.icu.util.TimeZone icuTimeZone = getIcuTimeZone(offset, dst, when, country);
    // API method.
    return icuTimeZone != null ? java.util.TimeZone.getTimeZone(icuTimeZone.getID()) : null;
}",1,"/**
 * Tries to return a time zone that would have had the specified offset
 * and DST value at the specified moment in the specified country.
 * Returns null if no suitable zone could be found.
 */
","/**
 * Tries to return a time zone that would have had the specified offset
 * and DST value at the specified moment in the specified country.
 * Returns null if no suitable zone could be found.
 */
",0,,,0,,,,,,,"1,4,5",1,"The late version of the implementation has changed significantly; it leverages a different API for getting the TimeZone (getIcuTimeZone) and converts it back to a java.util.TimeZone, rather than iterating over a collection of time zones and comparing their properties as in the early version. The return statement has been modified to return a TimeZone based on the ID from the icuTimeZone object or null when icuTimeZone is null, which is a different logic that was not present in the early version of the code. These are changes to the return statement, other statements, and a change with a dependent API, so the code change types are 1, 4, 5.","The change in the return statement due to using a different API (getIcuTimeZone function), and the logic that constructs the result (conversion from icu.TimeZone to java.util.TimeZone using getTimeZone(icuTimeZone.getID())), means that the method could potentially return a different value. Hence, the CI type is 1."
276,"<android.net.IpSecTransform.Builder: Builder setSpi(int,SecurityParameterIndex)>",26,27,,,,"{
    // TODO: convert to using the resource Id of the SPI. Then build() can validate
    // the owner in the IpSecService
    mConfig.flow[direction].spi = spi.getSpi();
    return this;
}","{
    // TODO: convert to using the resource Id of the SPI. Then build() can validate
    // the owner in the IpSecService
    mConfig.flow[direction].spiResourceId = spi.getResourceId();
    return this;
}",1,"/**
 * Set the SPI, which uniquely identifies a particular IPsec session from others. Because
 * IPsec operates at the IP layer, this 32-bit identifier uniquely identifies packets to a
 * given destination address.
 *
 * <p>Care should be chosen when selecting an SPI to ensure that is is as unique as
 * possible. To reserve a value call {@link IpSecManager#reserveSecurityParameterIndex(int,
 * InetAddress, int)}. Otherwise, SPI collisions would prevent a transform from being
 * activated. IpSecManager#reserveSecurityParameterIndex(int, InetAddres$s, int)}.
 *
 * <p>Unless an SPI is set for a given direction, traffic in that direction will be
 * sent/received without any IPsec applied.
 *
 * @param direction either {@link #DIRECTION_IN or #DIRECTION_OUT}
 * @param spi a unique {@link IpSecManager.SecurityParameterIndex} to identify transformed
 * traffic
 */
","/**
 * Set the SPI, which uniquely identifies a particular IPsec session from others. Because
 * IPsec operates at the IP layer, this 32-bit identifier uniquely identifies packets to a
 * given destination address.
 *
 * <p>Care should be chosen when selecting an SPI to ensure that is is as unique as
 * possible. To reserve a value call {@link IpSecManager#reserveSecurityParameterIndex(int,
 * InetAddress, int)}. Otherwise, SPI collisions would prevent a transform from being
 * activated. IpSecManager#reserveSecurityParameterIndex(int, InetAddres$s, int)}.
 *
 * <p>Unless an SPI is set for a given direction, traffic in that direction will be
 * sent/received without any IPsec applied.
 *
 * @param direction either {@link #DIRECTION_IN or #DIRECTION_OUT}
 * @param spi a unique {@link IpSecManager.SecurityParameterIndex} to identify transformed
 * traffic
 */
",0,,,0,,,,,,,"4,5",0,"The code has changed from writing to mConfig.flow[direction].spi to mConfig.flow[direction].spiResourceId. This change is neither a change in return type, control flow, nor exception handling but rather an assignment to a different field, which classifies it as other statement change type (4) and also the expected type or value being assigned has changed which indicates a dependent API change (5).","There is no Compatibility Issue since the method still returns `this` which is the builder itself, maintaining fluent API usage. The internal representation changes do not affect method return type or the exceptions thrown which are part of the API contract."
277,"<android.view.FocusFinder: boolean beamsOverlap(int,Rect,Rect)>",26,27,,,,"{
    switch(direction) {
        case View.FOCUS_LEFT:
        case View.FOCUS_RIGHT:
            return (rect2.bottom >= rect1.top) && (rect2.top <= rect1.bottom);
        case View.FOCUS_UP:
        case View.FOCUS_DOWN:
            return (rect2.right >= rect1.left) && (rect2.left <= rect1.right);
    }
    throw new IllegalArgumentException(""direction must be one of "" + ""{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}."");
}","{
    switch(direction) {
        case View.FOCUS_LEFT:
        case View.FOCUS_RIGHT:
            return (rect2.bottom > rect1.top) && (rect2.top < rect1.bottom);
        case View.FOCUS_UP:
        case View.FOCUS_DOWN:
            return (rect2.right > rect1.left) && (rect2.left < rect1.right);
    }
    throw new IllegalArgumentException(""direction must be one of "" + ""{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}."");
}",1,"/**
 * Do the ""beams"" w.r.t the given direction's axis of rect1 and rect2 overlap?
 * @param direction the direction (up, down, left, right)
 * @param rect1 The first rectangle
 * @param rect2 The second rectangle
 * @return whether the beams overlap
 */
","/**
 * Do the ""beams"" w.r.t the given direction's axis of rect1 and rect2 overlap?
 * @param direction the direction (up, down, left, right)
 * @param rect1 The first rectangle
 * @param rect2 The second rectangle
 * @return whether the beams overlap
 */
",0,,,0,,,,,,,"1,3",1,"The condition statements inside the 'switch' statement have changed from `>=` and `<=` to `>` and `<`. This change affects the return value based on conditions, so the code change types are 1 and 3.","The CI arises because the changed conditions in the return statements may result in different return values for border cases where rect1's 'top' or 'bottom' is equal to rect2's 'bottom' or 'top' (and similarly with 'right' and 'left'). Previously, when the edges were exactly aligned, the method would return true; now it will return false in such cases, which is a Compatibility Issue caused by potential different return values (type 1)."
278,<android.content.res.Configuration: int compareTo(Configuration)>,26,27,,,,"{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    fixUpLocaleList();
    that.fixUpLocaleList();
    // than any non-empty locale list.
    if (this.mLocaleList.isEmpty()) {
        if (!that.mLocaleList.isEmpty())
            return 1;
    } else if (that.mLocaleList.isEmpty()) {
        return -1;
    } else {
        final int minSize = Math.min(this.mLocaleList.size(), that.mLocaleList.size());
        for (int i = 0; i < minSize; ++i) {
            final Locale thisLocale = this.mLocaleList.get(i);
            final Locale thatLocale = that.mLocaleList.get(i);
            n = thisLocale.getLanguage().compareTo(thatLocale.getLanguage());
            if (n != 0)
                return n;
            n = thisLocale.getCountry().compareTo(thatLocale.getCountry());
            if (n != 0)
                return n;
            n = thisLocale.getVariant().compareTo(thatLocale.getVariant());
            if (n != 0)
                return n;
            n = thisLocale.toLanguageTag().compareTo(thatLocale.toLanguageTag());
            if (n != 0)
                return n;
        }
        n = this.mLocaleList.size() - that.mLocaleList.size();
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.colorMode - that.colorMode;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    if (n != 0)
        return n;
    n = this.assetsSeq - that.assetsSeq;
    // if (n != 0) return n;
    return n;
}","{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    fixUpLocaleList();
    that.fixUpLocaleList();
    // than any non-empty locale list.
    if (this.mLocaleList.isEmpty()) {
        if (!that.mLocaleList.isEmpty())
            return 1;
    } else if (that.mLocaleList.isEmpty()) {
        return -1;
    } else {
        final int minSize = Math.min(this.mLocaleList.size(), that.mLocaleList.size());
        for (int i = 0; i < minSize; ++i) {
            final Locale thisLocale = this.mLocaleList.get(i);
            final Locale thatLocale = that.mLocaleList.get(i);
            n = thisLocale.getLanguage().compareTo(thatLocale.getLanguage());
            if (n != 0)
                return n;
            n = thisLocale.getCountry().compareTo(thatLocale.getCountry());
            if (n != 0)
                return n;
            n = thisLocale.getVariant().compareTo(thatLocale.getVariant());
            if (n != 0)
                return n;
            n = thisLocale.toLanguageTag().compareTo(thatLocale.toLanguageTag());
            if (n != 0)
                return n;
        }
        n = this.mLocaleList.size() - that.mLocaleList.size();
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.colorMode - that.colorMode;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    if (n != 0)
        return n;
    n = this.assetsSeq - that.assetsSeq;
    if (n != 0)
        return n;
    if (this.appBounds == null && that.appBounds != null) {
        return 1;
    } else if (this.appBounds != null && that.appBounds == null) {
        return -1;
    } else if (this.appBounds != null && that.appBounds != null) {
        n = this.appBounds.left - that.appBounds.left;
        if (n != 0)
            return n;
        n = this.appBounds.top - that.appBounds.top;
        if (n != 0)
            return n;
        n = this.appBounds.right - that.appBounds.right;
        if (n != 0)
            return n;
        n = this.appBounds.bottom - that.appBounds.bottom;
        if (n != 0)
            return n;
    }
    // if (n != 0) return n;
    return n;
}",1,,,0,,,0,,,,,,,,,,
279,<android.os.Binder: void finalize()>,26,27,,,,"{
    try {
        destroy();
    } finally {
        super.finalize();
    }
}","{
    try {
        destroyBinder();
    } finally {
        super.finalize();
    }
}",1,,,0,,,0,,,,,,,5,0,"The implementation has changed from calling destroy() to calling destroyBinder(), so the code change type is 5.","There is no compatibility issue because the change is within the finalize method, which is invoked by the garbage collector. The change in the method being called does not affect the return value or exception handling from the perspective of the caller, as finalize does not have a return value or throw exceptions to the caller."
281,"<android.app.FragmentManagerImpl: void dispatchOnFragmentPaused(Fragment,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentPaused(f, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentPaused(this, f);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentPaused(f, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentPaused(this, f);
        }
    }
}",1,,,0,,,0,,,,,,,1,1,"The early implementation includes a return statement ""if (mLifecycleCallbacks == null) { return; }"" that is not present in the late implementation. This change potentially affects the overall flow of the method by allowing further execution of the code that was previously skipped in case mLifecycleCallbacks was null.","The removal of this return statement can lead to a situation where the late version of the method continues to execute and potentially calls the onFragmentPaused callback on the LifecycleCallbacks when it wouldn't have in the early version, leading to a Compatibility Issue due to different behavior. Thus, the CI type is 1."
282,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,26,27,,,,"{
    try {
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        return ActivityManagerNative.getDefault().enterPictureInPictureMode(mToken, params);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        if (!mCanEnterPictureInPicture) {
            throw new IllegalStateException(""Activity must be resumed to enter"" + "" picture-in-picture"");
        }
        return ActivityManagerNative.getDefault().enterPictureInPictureMode(mToken, params);
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system puts this activity into picture-in-picture mode or was already
 * in picture-in-picture mode (@see {@link #isInPictureInPictureMode())
 */
","/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system puts this activity into picture-in-picture mode or was already
 * in picture-in-picture mode (@see {@link #isInPictureInPictureMode())
 */
",0,,,0,,,,,,,3,1,"An additional condition check (`if (!mCanEnterPictureInPicture)`) and a throw statement have been introduced in the late version, which are control dependency changes, thus the code change type is 3.","The added condition check introduces a new possible exception (`IllegalStateException`), so the late version API could potentially throw a different exception than the early version, which is a CI of type 1."
283,<android.net.nsd.NsdManager: void stopServiceDiscovery(DiscoveryListener)>,26,27,,,,"{
    int id = getListenerKey(listener);
    if (id == INVALID_LISTENER_KEY) {
        throw new IllegalArgumentException(""service discovery not active on listener"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    mAsyncChannel.sendMessage(STOP_DISCOVERY, 0, id);
}","{
    int id = getListenerKey(listener);
    mAsyncChannel.sendMessage(STOP_DISCOVERY, 0, id);
}",1,"/**
 * Stop service discovery initiated with {@link #discoverServices}.  An active service
 * discovery is notified to the application with {@link DiscoveryListener#onDiscoveryStarted}
 * and it stays active until the application invokes a stop service discovery. A successful
 * stop is notified to with a call to {@link DiscoveryListener#onDiscoveryStopped}.
 *
 * <p> Upon failure to stop service discovery, application is notified through
 * {@link DiscoveryListener#onStopDiscoveryFailed}.
 *
 * @param listener This should be the listener object that was passed to {@link #discoverServices}.
 * It identifies the discovery that should be stopped and notifies of a successful or
 * unsuccessful stop.  In API versions 20 and above, the listener object may be used for
 * another service discovery once the callback has been called.  In API versions <= 19,
 * there is no entirely reliable way to know when a listener may be re-used, and a new
 * listener should be created for each service discovery request.
 */
","/**
 * Stop service discovery initiated with {@link #discoverServices}.  An active service
 * discovery is notified to the application with {@link DiscoveryListener#onDiscoveryStarted}
 * and it stays active until the application invokes a stop service discovery. A successful
 * stop is notified to with a call to {@link DiscoveryListener#onDiscoveryStopped}.
 *
 * <p> Upon failure to stop service discovery, application is notified through
 * {@link DiscoveryListener#onStopDiscoveryFailed}.
 *
 * @param listener This should be the listener object that was passed to {@link #discoverServices}.
 * It identifies the discovery that should be stopped and notifies of a successful or
 * unsuccessful stop.  In API versions 20 and above, the listener object may be used for
 * another service discovery once the callback has been called.  In API versions <= 19,
 * there is no entirely reliable way to know when a listener may be re-used, and a new
 * listener should be created for each service discovery request.
 */
",0,,,0,,,,,,,"2,4",2,"The exception handling statement that checks for an invalid listener key and the check for a null listener has been removed, indicating that the argument is no longer validated for these conditions in the late version. Thus, the change type is 2 and 4.","The changes will cause a compatibility issue because the early version of the API may throw an IllegalArgumentException if certain conditions are met (such as the listener being null or not active), while the late version removes this exception handling and always proceeds to send a message with mAsyncChannel.sendMessage. This can lead to different exception handlings (situations where an exception would be thrown in the early version but not in the later version), so CI type is 2."
284,<android.app.ContextImpl: File getExternalCacheDir()>,26,27,,,,"{
    // Operates on primary external storage
    return getExternalCacheDirs()[0];
}","{
    // Operates on primary external storage
    final File[] dirs = getExternalCacheDirs();
    return (dirs != null && dirs.length > 0) ? dirs[0] : null;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"The addition of a null check and length check before accessing the first element of the array represents a control dependency change. This can be considered as type 3 change. Also, the addition of a conditional expression to return null when the array is null or empty is a return statement change, thus this is a type 1 change as well.","The change introduces a scenario where the late version of the API can return null if the array returned by getExternalCacheDirs() is null or has length zero while the early version would result in an ArrayIndexOutOfBoundsException in such a case. Therefore, the change can potentially result in different return values which leads to a CI of type 1."
285,<android.hardware.radio.RadioManager.ModuleProperties: boolean equals(Object)>,26,27,,,,"{
    if (this == obj)
        return true;
    if (!(obj instanceof ModuleProperties))
        return false;
    ModuleProperties other = (ModuleProperties) obj;
    if (mId != other.getId())
        return false;
    if (mClassId != other.getClassId())
        return false;
    if (mImplementor == null) {
        if (other.getImplementor() != null)
            return false;
    } else if (!mImplementor.equals(other.getImplementor()))
        return false;
    if (mProduct == null) {
        if (other.getProduct() != null)
            return false;
    } else if (!mProduct.equals(other.getProduct()))
        return false;
    if (mVersion == null) {
        if (other.getVersion() != null)
            return false;
    } else if (!mVersion.equals(other.getVersion()))
        return false;
    if (mSerial == null) {
        if (other.getSerial() != null)
            return false;
    } else if (!mSerial.equals(other.getSerial()))
        return false;
    if (mNumTuners != other.getNumTuners())
        return false;
    if (mNumAudioSources != other.getNumAudioSources())
        return false;
    if (mIsCaptureSupported != other.isCaptureSupported())
        return false;
    if (!Arrays.equals(mBands, other.getBands()))
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof ModuleProperties))
        return false;
    ModuleProperties other = (ModuleProperties) obj;
    if (mId != other.getId())
        return false;
    if (!TextUtils.equals(mServiceName, other.mServiceName))
        return false;
    if (mClassId != other.getClassId())
        return false;
    if (mImplementor == null) {
        if (other.getImplementor() != null)
            return false;
    } else if (!mImplementor.equals(other.getImplementor()))
        return false;
    if (mProduct == null) {
        if (other.getProduct() != null)
            return false;
    } else if (!mProduct.equals(other.getProduct()))
        return false;
    if (mVersion == null) {
        if (other.getVersion() != null)
            return false;
    } else if (!mVersion.equals(other.getVersion()))
        return false;
    if (mSerial == null) {
        if (other.getSerial() != null)
            return false;
    } else if (!mSerial.equals(other.getSerial()))
        return false;
    if (mNumTuners != other.getNumTuners())
        return false;
    if (mNumAudioSources != other.getNumAudioSources())
        return false;
    if (mIsCaptureSupported != other.isCaptureSupported())
        return false;
    if (!Arrays.equals(mBands, other.getBands()))
        return false;
    if (mIsBgScanSupported != other.isBackgroundScanningSupported())
        return false;
    if (!mVendorInfo.equals(other.mVendorInfo))
        return false;
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4,5",1,The code has several changes:,3. Control statements (if) have been changed to include new fields.
286,<com.android.server.SystemConfig: void readPrivAppPermissions(XmlPullParser)>,26,27,,,,"{
    String packageName = parser.getAttributeValue(null, ""package"");
    if (TextUtils.isEmpty(packageName)) {
        Slog.w(TAG, ""package is required for <privapp-permissions> in "" + parser.getPositionDescription());
        return;
    }
    ArraySet<String> permissions = mPrivAppPermissions.get(packageName);
    if (permissions == null) {
        permissions = new ArraySet<>();
    }
    int depth = parser.getDepth();
    while (XmlUtils.nextElementWithin(parser, depth)) {
        String name = parser.getName();
        if (""permission"".equals(name)) {
            String permName = parser.getAttributeValue(null, ""name"");
            if (TextUtils.isEmpty(permName)) {
                Slog.w(TAG, ""name is required for <permission> in "" + parser.getPositionDescription());
                continue;
            }
            permissions.add(permName);
        }
    }
    mPrivAppPermissions.put(packageName, permissions);
}","{
    String packageName = parser.getAttributeValue(null, ""package"");
    if (TextUtils.isEmpty(packageName)) {
        Slog.w(TAG, ""package is required for <privapp-permissions> in "" + parser.getPositionDescription());
        return;
    }
    ArraySet<String> permissions = mPrivAppPermissions.get(packageName);
    if (permissions == null) {
        permissions = new ArraySet<>();
    }
    ArraySet<String> denyPermissions = mPrivAppDenyPermissions.get(packageName);
    int depth = parser.getDepth();
    while (XmlUtils.nextElementWithin(parser, depth)) {
        String name = parser.getName();
        if (""permission"".equals(name)) {
            String permName = parser.getAttributeValue(null, ""name"");
            if (TextUtils.isEmpty(permName)) {
                Slog.w(TAG, ""name is required for <permission> in "" + parser.getPositionDescription());
                continue;
            }
            permissions.add(permName);
        } else if (""deny-permission"".equals(name)) {
            String permName = parser.getAttributeValue(null, ""name"");
            if (TextUtils.isEmpty(permName)) {
                Slog.w(TAG, ""name is required for <deny-permission> in "" + parser.getPositionDescription());
                continue;
            }
            if (denyPermissions == null) {
                denyPermissions = new ArraySet<>();
            }
            denyPermissions.add(permName);
        }
    }
    mPrivAppPermissions.put(packageName, permissions);
    if (denyPermissions != null) {
        mPrivAppDenyPermissions.put(packageName, denyPermissions);
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"A new branch within the while loop has been introduced to handle ""deny-permission"" elements, and additional code was added to update `mPrivAppDenyPermissions`. This leads to change types 3 and 4, since control statements are changed and there are also other statements that do not fit into the previously specified change types.","No Compatibility Issue should arise from these changes because they affect internal data structures without changing the method's behavior with respect to its signature, which has no return type and therefore cannot change in returned values. Additionally, no new exceptions or changed control flow that results in changed exceptions will be externally visible, and the code changes do not affect the signature or the expected outcome of the method when called."
287,<android.bluetooth.BluetoothHeadset: int getConnectionState(BluetoothDevice)>,26,27,,,,"{
    if (VDBG)
        log(""getConnectionState("" + device + "")"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return BluetoothProfile.STATE_DISCONNECTED;
}","{
    if (VDBG)
        log(""getConnectionState("" + device + "")"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return BluetoothProfile.STATE_DISCONNECTED;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,,,0,,,,,,,4,0,"The only change that has occurred is the assignment of `mService` to a local variable `service` and then it's used instead of `mService` directly within the method body, making the change type 4.","This change does not affect the external behavior of the method, as it is merely an internal code refactoring that will not affect the return values nor alter exception handling. Therefore, there's no Compatibility Issue, and the CI type is 0."
289,<android.widget.ArrayAdapter: CharSequence[] getAutofillOptions()>,26,27,,,,"{
    if (!mObjectsFromResources || mObjects == null || mObjects.isEmpty()) {
        return null;
    }
    final int size = mObjects.size();
    final CharSequence[] options = new CharSequence[size];
    mObjects.toArray(options);
    return options;
}","{
    // First check if app developer explicitly set them.
    final CharSequence[] explicitOptions = super.getAutofillOptions();
    if (explicitOptions != null) {
        return explicitOptions;
    }
    // Otherwise, only return options that came from static resources.
    if (!mObjectsFromResources || mObjects == null || mObjects.isEmpty()) {
        return null;
    }
    final int size = mObjects.size();
    final CharSequence[] options = new CharSequence[size];
    mObjects.toArray(options);
    return options;
}",1,"/**
 * {@inheritDoc}
 *
 * @return values from the string array used by {@link #createFromResource(Context, int, int)},
 * or {@code null} if object was created otherwsie or if contents were dynamically changed after
 * creation.
 */
","/**
 * {@inheritDoc}
 *
 * @return values from the string array used by {@link #createFromResource(Context, int, int)},
 * or {@code null} if object was created otherwsie or if contents were dynamically changed after
 * creation.
 */
",0,[@Override],[@Override],0,,,,,,,"1,3,5",1,"The late implementation includes a new check for an explicitly set autofill option array via super.getAutofillOptions() and returns it if it is not null. The early implementation does not have this check. There is also a difference in control dependency due to the new if statement, and a call to a potentially modified dependent method super.getAutofillOptions(), so the changes are 1,3,5.","The new check for an explicitly set autofill options array could result in a different return value which was not present in the previous implementation, so this constitutes a compatibility issue caused by potentially different return values or types, which is type 1."
290,<android.appwidget.AppWidgetHost: void deleteAllHosts()>,26,27,,,,"{
    try {
        sService.deleteAllHosts();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (sService == null) {
        return;
    }
    try {
        sService.deleteAllHosts();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Remove all records about all hosts for your package.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
","/**
 * Remove all records about all hosts for your package.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
",0,,,0,,,,,,,"3,4",0,"An additional check for `sService` being `null` with a return statement was introduced before the 'try' block, which is a control dependency change (type 3) and other statement change (type 4) since no return statement is in the `try-catch` block.","The added null check for `sService` and early return when `sService` is null does not cause a compatibility issue because in the early version, if `sService` were null, it would have thrown a NullPointerException which is unchecked and would result in a runtime exception. In the late version, the method simply exits early if `sService` is null. The functionality (deleting all hosts) only proceeds if `sService` is not null in both versions, therefore there's no actual change in behavior with regards to compatibility. The method still throws a RuntimeException if the remote call fails due to a RemoteException. Hence, there is no compatibility issue (type 0)."
291,<android.widget.TextView: void autofill(AutofillValue)>,26,27,,,,"{
    if (!value.isText() || !isTextEditable()) {
        Log.w(LOG_TAG, value + "" could not be autofilled into "" + this);
        return;
    }
    setText(value.getTextValue(), mBufferType, true, 0);
}","{
    if (!value.isText() || !isTextEditable()) {
        Log.w(LOG_TAG, value + "" could not be autofilled into "" + this);
        return;
    }
    final CharSequence autofilledValue = value.getTextValue();
    // First autofill it...
    setText(autofilledValue, mBufferType, true, 0);
    // ...then move cursor to the end.
    final CharSequence text = getText();
    if ((text instanceof Spannable)) {
        Selection.setSelection((Spannable) text, text.length());
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The late implementation includes additional lines for setting the cursor position after the text is autofilled which represents an ""Other statement changed"". This is a behavior addition and does not affect the existing functionality of setting the text, so it is classified as change type 4.","No Compatibility Issue is detected because the additional functionality simply moves the cursor to the end of the text after autofilling. It does not change the logic for how the text is autofilled nor does it introduce changes in return values or the exceptions thrown, hence the CI type is 0."
292,"<android.hardware.camera2.CameraManager: void setTorchMode(String,boolean)>",26,27,,,,"{
    CameraManagerGlobal.get().setTorchMode(cameraId, enabled);
}","{
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    CameraManagerGlobal.get().setTorchMode(cameraId, enabled);
}",1,"/**
 * Set the flash unit's torch mode of the camera of the given ID without opening the camera
 * device.
 *
 * <p>Use {@link #getCameraIdList} to get the list of available camera devices and use
 * {@link #getCameraCharacteristics} to check whether the camera device has a flash unit.
 * Note that even if a camera device has a flash unit, turning on the torch mode may fail
 * if the camera device or other camera resources needed to turn on the torch mode are in use.
 * </p>
 *
 * <p> If {@link #setTorchMode} is called to turn on or off the torch mode successfully,
 * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked.
 * However, even if turning on the torch mode is successful, the application does not have the
 * exclusive ownership of the flash unit or the camera device. The torch mode will be turned
 * off and becomes unavailable when the camera device that the flash unit belongs to becomes
 * unavailable or when other camera resources to keep the torch on become unavailable (
 * {@link CameraManager.TorchCallback#onTorchModeUnavailable} will be invoked). Also,
 * other applications are free to call {@link #setTorchMode} to turn off the torch mode (
 * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked). If the latest
 * application that turned on the torch mode exits, the torch mode will be turned off.
 *
 * @param cameraId
 * The unique identifier of the camera device that the flash unit belongs to.
 * @param enabled
 * The desired state of the torch mode for the target camera device. Set to
 * {@code true} to turn on the torch mode. Set to {@code false} to turn off the
 * torch mode.
 *
 * @throws CameraAccessException if it failed to access the flash unit.
 * {@link CameraAccessException#CAMERA_IN_USE} will be thrown if the camera device
 * is in use. {@link CameraAccessException#MAX_CAMERAS_IN_USE} will be thrown if
 * other camera resources needed to turn on the torch mode are in use.
 * {@link CameraAccessException#CAMERA_DISCONNECTED} will be thrown if camera
 * service is not available.
 *
 * @throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently
 * or previously available camera device, or the camera device doesn't have a
 * flash unit.
 */
","/**
 * Set the flash unit's torch mode of the camera of the given ID without opening the camera
 * device.
 *
 * <p>Use {@link #getCameraIdList} to get the list of available camera devices and use
 * {@link #getCameraCharacteristics} to check whether the camera device has a flash unit.
 * Note that even if a camera device has a flash unit, turning on the torch mode may fail
 * if the camera device or other camera resources needed to turn on the torch mode are in use.
 * </p>
 *
 * <p> If {@link #setTorchMode} is called to turn on or off the torch mode successfully,
 * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked.
 * However, even if turning on the torch mode is successful, the application does not have the
 * exclusive ownership of the flash unit or the camera device. The torch mode will be turned
 * off and becomes unavailable when the camera device that the flash unit belongs to becomes
 * unavailable or when other camera resources to keep the torch on become unavailable (
 * {@link CameraManager.TorchCallback#onTorchModeUnavailable} will be invoked). Also,
 * other applications are free to call {@link #setTorchMode} to turn off the torch mode (
 * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked). If the latest
 * application that turned on the torch mode exits, the torch mode will be turned off.
 *
 * @param cameraId
 * The unique identifier of the camera device that the flash unit belongs to.
 * @param enabled
 * The desired state of the torch mode for the target camera device. Set to
 * {@code true} to turn on the torch mode. Set to {@code false} to turn off the
 * torch mode.
 *
 * @throws CameraAccessException if it failed to access the flash unit.
 * {@link CameraAccessException#CAMERA_IN_USE} will be thrown if the camera device
 * is in use. {@link CameraAccessException#MAX_CAMERAS_IN_USE} will be thrown if
 * other camera resources needed to turn on the torch mode are in use.
 * {@link CameraAccessException#CAMERA_DISCONNECTED} will be thrown if camera
 * service is not available.
 *
 * @throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently
 * or previously available camera device, or the camera device doesn't have a
 * flash unit.
 */
",0,,,0,,,,,,,"3,4",2,An if-statement checking the status of `CameraManagerGlobal.sCameraServiceDisabled` and potentially throwing an IllegalArgumentException has been introduced. The code change types are 3 for the control statement and 4 for the addition of a new logical block.,"A new conditional logic is added to throw an IllegalArgumentException when `CameraManagerGlobal.sCameraServiceDisabled` is true, which represents an additional exception being thrown in the later version that didn't exist in the earlier version. Therefore, the CI type is 2, illustrating a potential difference in exception handling behavior."
294,"<android.text.StaticLayout.Builder: float addStyleRun(TextPaint,int,int,boolean)>",26,27,,,,"{
    return nAddStyleRun(mNativePtr, paint.getNativeInstance(), paint.mNativeTypeface, start, end, isRtl);
}","{
    setLocales(paint.getTextLocales());
    return nAddStyleRun(mNativePtr, paint.getNativeInstance(), paint.mNativeTypeface, start, end, isRtl);
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,4,0,"An extra method call setLocales(paint.getTextLocales()) is added before the return statement. This new line of code does not affect the return value nor does it introduce any new exception handling, so the code change type is 4.","The addition of the method setLocales(paint.getTextLocales()) doesn't change what is returned by the method or alter exception handling, and since it is a setup step that does not change the output of the API, there is no Compatibility Issue. Therefore, the CI type is 0."
295,<android.view.View: void setHasTransientState(boolean)>,26,27,,,,"{
    mTransientStateCount = hasTransientState ? mTransientStateCount + 1 : mTransientStateCount - 1;
    if (mTransientStateCount < 0) {
        mTransientStateCount = 0;
        Log.e(VIEW_LOG_TAG, ""hasTransientState decremented below 0: "" + ""unmatched pair of setHasTransientState calls"");
    } else if ((hasTransientState && mTransientStateCount == 1) || (!hasTransientState && mTransientStateCount == 0)) {
        // update flag if we've just incremented up from 0 or decremented down to 0
        mPrivateFlags2 = (mPrivateFlags2 & ~PFLAG2_HAS_TRANSIENT_STATE) | (hasTransientState ? PFLAG2_HAS_TRANSIENT_STATE : 0);
        if (mParent != null) {
            try {
                mParent.childHasTransientStateChanged(this, hasTransientState);
            } catch (AbstractMethodError e) {
                Log.e(VIEW_LOG_TAG, mParent.getClass().getSimpleName() + "" does not fully implement ViewParent"", e);
            }
        }
    }
}","{
    final boolean oldHasTransientState = hasTransientState();
    mTransientStateCount = hasTransientState ? mTransientStateCount + 1 : mTransientStateCount - 1;
    if (mTransientStateCount < 0) {
        mTransientStateCount = 0;
        Log.e(VIEW_LOG_TAG, ""hasTransientState decremented below 0: "" + ""unmatched pair of setHasTransientState calls"");
    } else if ((hasTransientState && mTransientStateCount == 1) || (!hasTransientState && mTransientStateCount == 0)) {
        // update flag if we've just incremented up from 0 or decremented down to 0
        mPrivateFlags2 = (mPrivateFlags2 & ~PFLAG2_HAS_TRANSIENT_STATE) | (hasTransientState ? PFLAG2_HAS_TRANSIENT_STATE : 0);
        final boolean newHasTransientState = hasTransientState();
        if (mParent != null && newHasTransientState != oldHasTransientState) {
            try {
                mParent.childHasTransientStateChanged(this, newHasTransientState);
            } catch (AbstractMethodError e) {
                Log.e(VIEW_LOG_TAG, mParent.getClass().getSimpleName() + "" does not fully implement ViewParent"", e);
            }
        }
    }
}",1,"/**
 * Set whether this view is currently tracking transient state that the
 * framework should attempt to preserve when possible. This flag is reference counted,
 * so every call to setHasTransientState(true) should be paired with a later call
 * to setHasTransientState(false).
 *
 * <p>A view with transient state cannot be trivially rebound from an external
 * data source, such as an adapter binding item views in a list. This may be
 * because the view is performing an animation, tracking user selection
 * of content, or similar.</p>
 *
 * @param hasTransientState true if this view has transient state
 */
","/**
 * Set whether this view is currently tracking transient state that the
 * framework should attempt to preserve when possible. This flag is reference counted,
 * so every call to setHasTransientState(true) should be paired with a later call
 * to setHasTransientState(false).
 *
 * <p>A view with transient state cannot be trivially rebound from an external
 * data source, such as an adapter binding item views in a list. This may be
 * because the view is performing an animation, tracking user selection
 * of content, or similar.</p>
 *
 * @param hasTransientState true if this view has transient state
 */
",0,,,0,,,,,,,"3,4",0,"The late implementation introduces a new local variable `oldHasTransientState` at the beginning, and modifies the condition in which `mParent.childHasTransientStateChanged(this, newHasTransientState)` is called. The inner condition for calling `childHasTransientStateChanged` is changed, and the logging of ""does not fully implement ViewParent"" has been removed; these are changes in other statements and control dependency, hence the code change types are 3,4.","There's no potential for a Compatibility Issue here because the changes neither alter the return value nor change the exceptions thrown by the method. The method signature remains void, so no return value is impacted, and exception handling is consistent between versions. The changes are internal to the state management of the View, without altering the API's external behavior."
296,"<android.os.MemoryFile: void writeBytes(byte[],int,int,int)>",26,27,,,,"{
    if (isDeactivated()) {
        throw new IOException(""Can't write to deactivated memory file."");
    }
    if (srcOffset < 0 || srcOffset > buffer.length || count < 0 || count > buffer.length - srcOffset || destOffset < 0 || destOffset > mLength || count > mLength - destOffset) {
        throw new IndexOutOfBoundsException();
    }
    native_write(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);
}","{
    beginAccess();
    try {
        mMapping.position(destOffset);
        mMapping.put(buffer, srcOffset, count);
    } finally {
        endAccess();
    }
}",1,"/**
 * Write bytes to the memory file.
 * Will throw an IOException if the file has been purged.
 *
 * @param buffer byte array to write bytes from.
 * @param srcOffset offset into the byte array buffer to write from.
 * @param destOffset offset  into the memory file to write to.
 * @param count number of bytes to write.
 * @throws IOException if the memory file has been purged or deactivated.
 */
","/**
 * Write bytes to the memory file.
 * Will throw an IOException if the file has been purged.
 *
 * @param buffer byte array to write bytes from.
 * @param srcOffset offset into the byte array buffer to write from.
 * @param destOffset offset  into the memory file to write to.
 * @param count number of bytes to write.
 * @throws IOException if the memory file has been purged or deactivated.
 */
",0,,,0,,,,,,,"2,4,5","1,2","The late version of the implementation removed the check for deactivation and index out of bounds, which are exception handling statements, and replaced the native_write method with a set of operations wrapped in a try-finally block. Furthermore, the method calls within the try block mMapping.position(destOffset) and mMapping.put(buffer, srcOffset, count) indicate that the dependent APIs' method names and behaviors used have changed. This accounts for exception handling statement changed (2), other statement changed (4), and dependent API changed (5).","Since exception handling statements are removed, which results in no longer throwing IOException and IndexOutOfBoundsException under the same conditions, this leads to a compatibility issue due to different exception handlings (2). Additionally, the replacement of the native_write method with different dependent API methods may cause different return types or values, leading to a compatibility issue related to different return values (1)."
297,<android.app.FragmentManagerImpl: void removeFragment(Fragment)>,26,27,,,,"{
    if (DEBUG)
        Log.v(TAG, ""remove: "" + fragment + "" nesting="" + fragment.mBackStackNesting);
    final boolean inactive = !fragment.isInBackStack();
    if (!fragment.mDetached || inactive) {
        if (false) {
            // where it is not a problem.
            if (!mAdded.contains(fragment)) {
                throw new IllegalStateException(""Fragment not added: "" + fragment);
            }
        }
        if (mAdded != null) {
            synchronized (mAdded) {
                mAdded.remove(fragment);
            }
        }
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        fragment.mAdded = false;
        fragment.mRemoving = true;
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""remove: "" + fragment + "" nesting="" + fragment.mBackStackNesting);
    final boolean inactive = !fragment.isInBackStack();
    if (!fragment.mDetached || inactive) {
        if (false) {
            // where it is not a problem.
            if (!mAdded.contains(fragment)) {
                throw new IllegalStateException(""Fragment not added: "" + fragment);
            }
        }
        synchronized (mAdded) {
            mAdded.remove(fragment);
        }
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        fragment.mAdded = false;
        fragment.mRemoving = true;
    }
}",1,,,0,,,0,,,,,,,3,0,"The control dependency has changed; the check for `mAdded != null` before synchronizing on `mAdded` has been removed, and the synchronization is now unconditional, so the code change type is 3.","The removal of the null check for `mAdded` before synchronization does not introduce a change in the method's behavior because the `mAdded.remove(fragment)` call within the synchronized block would have thrown a NullPointerException anyway if `mAdded` were null. There is no change in the exceptions thrown or values returned from the method's execution. Therefore, there is no compatibility issue, and the CI type is 0."
299,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingBurst(List<CaptureRequest>,CaptureCallback,Handler)>",26,27,,,,"{
    if (requests == null) {
        throw new IllegalArgumentException(""requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""requests must have at least one element"");
    }
    for (CaptureRequest r : requests) {
        if (r.isReprocess()) {
            throw new IllegalArgumentException(""repeating reprocess burst requests are not "" + ""supported"");
        }
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (DEBUG) {
        CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
        Log.v(TAG, mIdString + ""setRepeatingBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler"" + """" + handler);
    }
    return addPendingSequence(mDeviceImpl.setRepeatingBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}","{
    if (requests == null) {
        throw new IllegalArgumentException(""requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""requests must have at least one element"");
    }
    for (CaptureRequest r : requests) {
        if (r.isReprocess()) {
            throw new IllegalArgumentException(""repeating reprocess burst requests are not "" + ""supported"");
        }
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
            Log.v(TAG, mIdString + ""setRepeatingBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler"" + """" + handler);
        }
        return addPendingSequence(mDeviceImpl.setRepeatingBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"The control dependency has changed as a `synchronized` block has been added to wrap the method body in the late version, ensuring thread safety on accessing `mDeviceImpl`. This is classified as a control dependency change, so the code change type is 3.","Adding a `synchronized` block on `mDeviceImpl.mInterfaceLock` does not change the overall behavior of the API as seen by the end user, but ensures that the operations within the block are thread-safe. It is unlikely to change the values or types returned by the method nor the exceptions thrown, since it does not alter the underlying logic of the operation being performed within the block (no actual logic change occurred), so there is no compatibility issue and the CI type is 0."
300,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,NetworkCallback,Handler,int)>",26,27,,,,"{
    if (timeoutMs <= 0) {
        throw new IllegalArgumentException(""Non-positive timeoutMs"");
    }
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, cbHandler);
}","{
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, cbHandler);
}",1,"/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}, limited
 * by a timeout.
 *
 * This function behaves identically to the non-timedout version, but if a suitable
 * network is not found within the given time (in milliseconds) the
 * {@link NetworkCallback#onUnavailable} callback is called. The request can still be
 * released normally by calling {@link #unregisterNetworkCallback(NetworkCallback)} but does
 * not have to be released if timed-out (it is automatically released). Unregistering a
 * request that timed out is not an error.
 *
 * <p>Do not use this method to poll for the existence of specific networks (e.g. with a small
 * timeout) - {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} is provided
 * for that purpose. Calling this method will attempt to bring up the requested network.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param networkCallback The {@link NetworkCallback} to be utilized for this request. Note
 * the callback must not be shared - it uniquely specifies this request.
 * @param handler {@link Handler} to specify the thread upon which the callback will be invoked.
 * @param timeoutMs The time in milliseconds to attempt looking for a suitable network
 * before {@link NetworkCallback#onUnavailable} is called.
 */
","/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}, limited
 * by a timeout.
 *
 * This function behaves identically to the non-timedout version, but if a suitable
 * network is not found within the given time (in milliseconds) the
 * {@link NetworkCallback#onUnavailable} callback is called. The request can still be
 * released normally by calling {@link #unregisterNetworkCallback(NetworkCallback)} but does
 * not have to be released if timed-out (it is automatically released). Unregistering a
 * request that timed out is not an error.
 *
 * <p>Do not use this method to poll for the existence of specific networks (e.g. with a small
 * timeout) - {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} is provided
 * for that purpose. Calling this method will attempt to bring up the requested network.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param networkCallback The {@link NetworkCallback} to be utilized for this request. Note
 * the callback must not be shared - it uniquely specifies this request.
 * @param handler {@link Handler} to specify the thread upon which the callback will be invoked.
 * @param timeoutMs The time in milliseconds to attempt looking for a suitable network
 * before {@link NetworkCallback#onUnavailable} is called.
 */
",0,,,0,,,,,,,"3,4,5",0,"The early version contains an `if` check for the timeoutMs argument with an inline exception throw whereas the late version replaces this inline check with a method call to checkTimeout, which is a Dependent API change, classifying as type 5. Control dependency is also altered since the `if` check is replaced by a method call type 3. It is an Other statement change since a condition has been extracted to a separate method type 4.",There is no compatibility issue because the behavior of the method has not changed. The input validation is still present; it is only abstracted into a separate method checkTimeout(timeoutMs). The rest of the method implementation remains the same so it will not lead to different return values or exceptions as long as the abstracted method preserves the original input validation logic.
301,"<android.app.FragmentManagerImpl: void dispatchOnFragmentDetached(Fragment,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentDetached(f, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentDetached(this, f);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentDetached(f, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentDetached(this, f);
        }
    }
}",1,,,0,,,0,,,,,,,1,1,"The if-statement `if (mLifecycleCallbacks == null)` and corresponding `return;` have been removed, so the change type is 1.","The removal of the return statement that previously handled the case when `mLifecycleCallbacks` is null could potentially lead to a `NullPointerException` if `mLifecycleCallbacks` is null in the late version of the code. Therefore, the behavior of the API has changed and the CI type is 1."
303,<android.bluetooth.BluetoothDevice: BluetoothClass getBluetoothClass()>,26,27,,,,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Bluetooth Class"");
        return null;
    }
    try {
        int classInt = sService.getRemoteClass(this);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Bluetooth Class"");
        return null;
    }
    try {
        int classInt = service.getRemoteClass(this);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the Bluetooth class of the remote device.
 *
 * @return Bluetooth class object, or null on error
 */
","/**
 * Get the Bluetooth class of the remote device.
 *
 * @return Bluetooth class object, or null on error
 */
",0,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],0,,,,,,,4,0,"The variable sService has been copied to a local final variable service and then used; this doesn't affect the behavior of the API, so the change type is 4.","The behavior of the method remains the same across versions since the variable change does not affect the external behavior of the method. There's no change in return values, control flow, or exceptions that are thrown, so there's no compatibility issue; CI type is 0."
305,<android.service.autofill.SaveInfo.Builder: Builder setOptionalIds(AutofillId[])>,26,27,,,,"{
    // TODO: add CTS unit tests (not integration) to assert the null cases
    throwIfDestroyed();
    mOptionalIds = assertValid(ids);
    return this;
}","{
    throwIfDestroyed();
    mOptionalIds = assertValid(ids);
    return this;
}",1,"/**
 * Sets the ids of additional, optional views the service would be interested to save.
 *
 * <p>See {@link SaveInfo} for more info.
 *
 * @param ids The ids of the optional views.
 * @return This builder.
 *
 * @throws IllegalArgumentException if {@code ids} is {@code null} or empty, or if
 * it contains any {@code null} entry.
 */
","/**
 * Sets the ids of additional, optional views the service would be interested to save.
 *
 * <p>See {@link SaveInfo} for more info.
 *
 * @param ids The ids of the optional views.
 * @return This builder.
 *
 * @throws IllegalArgumentException if {@code ids} is {@code null} or empty, or if
 * it contains any {@code null} entry.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,0,0,There are no changes to the implementation of the method between the two versions.,"Since there is no change in the implementation or annotations, no Compatibility Issue arises."
307,<android.view.textservice.SpellCheckerSession: void finalize()>,26,27,,,,"{
    super.finalize();
    if (mIsUsed) {
        Log.e(TAG, ""SpellCheckerSession was not finished properly."" + ""You should call finishSession() when you finished to use a spell checker."");
        close();
    }
}","{
    try {
        // Note that mGuard will be null if the constructor threw.
        if (mGuard != null) {
            mGuard.warnIfOpen();
            close();
        }
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4,5",0,"The method's implementation has been significantly restructured. In the early version, it calls super.finalize() at the beginning, and then performs a check on mIsUsed before possibly calling close(). In the late version, it's wrapped inside a try-finally block with a new control flow: it checks a different field (mGuard), calls warnIfOpen() and close() before calling super.finalize() within the finally block. The structure and control flow have changed, which includes control dependency change (3), other statement change (4), and dependent API change (5) because the late implementation references mGuard and warnIfOpen(), which are not present in the early version.","Despite the significant changes, the previous functionality to close the SpellCheckerSession when it's inappropriately used (detected by mIsUsed) is removed and replaced with a new guard mechanism (mGuard.warnIfOpen(). However, since this is the finalize method, which is used for cleanup and is called by the garbage collector before the object is reclaimed, and both versions ensure that close() will eventually be called if necessary, albeit based on different conditions, there is no clear indication that these changes will lead to a different external behavior affecting the API consumers. Therefore, there is no Compatibility Issue."
308,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>",26,27,,,,"{
    if (mask == 0) {
        return false;
    }
    URLSpan[] old = text.getSpans(0, text.length(), URLSpan.class);
    for (int i = old.length - 1; i >= 0; i--) {
        text.removeSpan(old[i]);
    }
    ArrayList<LinkSpec> links = new ArrayList<LinkSpec>();
    if ((mask & WEB_URLS) != 0) {
        gatherLinks(links, text, Patterns.AUTOLINK_WEB_URL, new String[] { ""http://"", ""https://"", ""rtsp://"" }, sUrlMatchFilter, null);
    }
    if ((mask & EMAIL_ADDRESSES) != 0) {
        gatherLinks(links, text, Patterns.AUTOLINK_EMAIL_ADDRESS, new String[] { ""mailto:"" }, null, null);
    }
    if ((mask & PHONE_NUMBERS) != 0) {
        gatherTelLinks(links, text);
    }
    if ((mask & MAP_ADDRESSES) != 0) {
        gatherMapLinks(links, text);
    }
    pruneOverlaps(links);
    if (links.size() == 0) {
        return false;
    }
    for (LinkSpec link : links) {
        applyLink(link.url, link.start, link.end, text);
    }
    return true;
}","{
    return addLinks(text, mask, null);
}",1,"/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 *
 * @param text Spannable whose text is to be marked-up with links
 * @param mask Mask to define which kinds of links will be searched.
 *
 * @return True if at least one link is found and applied.
 */
","/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 *
 * @param text Spannable whose text is to be marked-up with links
 * @param mask Mask to define which kinds of links will be searched.
 *
 * @return True if at least one link is found and applied.
 */
",0,,,0,,,,,,,"1,5",0,The previous implementation was replaced by a single line that calls an overload of the addLinks method with an additional parameter 'null'. This indicates that the implementation of the actual logic might have been shifted to the other method. So the changes are in the return statement and the dependent API.,"Despite the change, there is no direct evidence that the behavior of the method would be different as the existing logic has likely been moved to the overloaded method, and thus no compatibility issue is expected from this change alone. However, without visibility into the implementation of the new overload, we cannot be 100% certain that there is no compatibility issue. But based on the given information, we can conclude that there is no compatibility issue."
310,<android.app.ActivityThread.StopInfo: void run()>,26,27,,,,"{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + activity);
        ActivityManager.getService().activityStopped(activity.token, state, persistentState, description);
    } catch (RemoteException ex) {
        if (ex instanceof TransactionTooLargeException && activity.packageInfo.getTargetSdkVersion() < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data in instance state, so it was ignored"", ex);
            return;
        }
        throw ex.rethrowFromSystemServer();
    }
}","{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + activity);
        ActivityManager.getService().activityStopped(activity.token, state, persistentState, description);
    } catch (RemoteException ex) {
        // Dump statistics about bundle to help developers debug
        final LogWriter writer = new LogWriter(Log.WARN, TAG);
        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, ""  "");
        pw.println(""Bundle stats:"");
        Bundle.dumpStats(pw, state);
        pw.println(""PersistableBundle stats:"");
        Bundle.dumpStats(pw, persistentState);
        if (ex instanceof TransactionTooLargeException && activity.packageInfo.getTargetSdkVersion() < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data in instance state, so it was ignored"", ex);
            return;
        }
        throw ex.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"New log statements were added to dump state information when catching a RemoteException. These statements don't affect the return value or the exceptions thrown by the method, so the code change type is 4.","The added log statements do not change the functionality or behavior of the API; they only provide additional debug information when an exception occurs. These changes do not lead to a Compatibility Issue, hence the CI type is 0."
311,<android.app.Activity: void performRestart()>,26,27,,,,"{
    mFragments.noteStateNotSaved();
    if (mToken != null && mParent == null) {
        // No need to check mStopped, the roots will check if they were actually stopped.
        WindowManagerGlobal.getInstance().setStoppedState(mToken, false);
    }
    if (mStopped) {
        mStopped = false;
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                            throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                        }
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}","{
    mCanEnterPictureInPicture = true;
    mFragments.noteStateNotSaved();
    if (mToken != null && mParent == null) {
        // No need to check mStopped, the roots will check if they were actually stopped.
        WindowManagerGlobal.getInstance().setStoppedState(mToken, false);
    }
    if (mStopped) {
        mStopped = false;
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                            throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                        }
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}",1,,,0,,,0,,,,,,,4,0,"An expression statement has been added at the beginning of the method (`mCanEnterPictureInPicture = true;`), which does not affect any other logic or control flow within the method, so the code change type is 4.","The addition of the new statement does not change the behavior related to return values or the exceptions thrown by the method. There is no Compatibility Issue as the method's behavioral contract seems to remain the same; the new statement simply sets a value that's possibly to maintain the state and does not impact the existing flow or external behavior of this `void` method. Therefore, the CI type is 0."
312,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,26,27,,,,"{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mLastParentXOnScreen = positionListener.getPositionXOnScreen();
                mLastParentYOnScreen = positionListener.getPositionYOnScreen();
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                mTouchToWindowOffsetX = xInWindow - mPositionX;
                mTouchToWindowOffsetY = yInWindow - mPositionY;
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = yInWindow - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = xInWindow - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = yInWindow - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY);
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp();
            mIsDragging = false;
            updateDrawable();
            break;
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable();
            break;
    }
    return true;
}","{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mLastParentXOnScreen = positionListener.getPositionXOnScreen();
                mLastParentYOnScreen = positionListener.getPositionYOnScreen();
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                mTouchToWindowOffsetX = xInWindow - mPositionX;
                mTouchToWindowOffsetY = yInWindow - mPositionY;
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = yInWindow - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = xInWindow - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = yInWindow - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY, ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp(ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
            mIsDragging = false;
            updateDrawable();
            break;
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable();
            break;
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
314,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,26,27,,,,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                final MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                if (mergedConfiguration != null) {
                    // If configuration changed - notify about that and, maybe, about move to
                    // display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeNavBar = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && framesChanged) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mThreadedRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mThreadedRenderer.initializeIfNeeded(mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(mTag, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(mTag, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                        imm.onPreWindowFocus(mView, hasWindowFocus);
                    }
                    if (mView != null) {
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                        if (mAttachInfo.mTooltipHost != null) {
                            mAttachInfo.mTooltipHost.hideTooltip();
                        }
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    } else {
                        if (mPointerCapture) {
                            handlePointerCaptureChanged(false);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                if (!mLastReportedMergedConfiguration.equals(mergedConfiguration)) {
                    // If configuration changed - notify about that and, maybe, about move to
                    // display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeNavBar = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && framesChanged) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mThreadedRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mThreadedRenderer.initializeIfNeeded(mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(mTag, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(mTag, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                        imm.onPreWindowFocus(mView, hasWindowFocus);
                    }
                    if (mView != null) {
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                        if (mAttachInfo.mTooltipHost != null) {
                            mAttachInfo.mTooltipHost.hideTooltip();
                        }
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    } else {
                        if (mPointerCapture) {
                            handlePointerCaptureChanged(false);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
315,<android.content.res.Configuration: int updateFrom(Configuration)>,26,27,,,,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        mLocaleList = delta.mLocaleList;
        // delta.locale can't be null, since delta.mLocaleList is not empty.
        if (!delta.locale.equals(locale)) {
            locale = (Locale) delta.locale.clone();
            // If locale has changed, then layout direction is also changed ...
            changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
            // ... and we need to update the layout direction (represented by the first
            // 2 most significant bits in screenLayout).
            setLayoutDirection(locale);
        }
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (((delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != SCREENLAYOUT_SIZE_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != (screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_SIZE_MASK) | (delta.screenLayout & SCREENLAYOUT_SIZE_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_LONG_MASK) != SCREENLAYOUT_LONG_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_LONG_MASK) != (screenLayout & SCREENLAYOUT_LONG_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_LONG_MASK) | (delta.screenLayout & SCREENLAYOUT_LONG_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != SCREENLAYOUT_ROUND_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != (screenLayout & SCREENLAYOUT_ROUND_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_ROUND_MASK) | (delta.screenLayout & SCREENLAYOUT_ROUND_MASK);
    }
    if ((delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED) != (screenLayout & SCREENLAYOUT_COMPAT_NEEDED) && delta.screenLayout != 0) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_COMPAT_NEEDED) | (delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED);
    }
    if (((delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED) && (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != (colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_WIDE_COLOR_GAMUT_MASK) | (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
    }
    if (((delta.colorMode & COLOR_MODE_HDR_MASK) != COLOR_MODE_HDR_UNDEFINED) && (delta.colorMode & COLOR_MODE_HDR_MASK) != (colorMode & COLOR_MODE_HDR_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_HDR_MASK) | (delta.colorMode & COLOR_MODE_HDR_MASK);
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.appBounds != null && !delta.appBounds.equals(appBounds)) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        setAppBounds(delta.appBounds);
    }
    if (delta.assetsSeq != ASSETS_SEQ_UNDEFINED) {
        changed |= ActivityInfo.CONFIG_ASSETS_PATHS;
        assetsSeq = delta.assetsSeq;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        mLocaleList = delta.mLocaleList;
        // delta.locale can't be null, since delta.mLocaleList is not empty.
        if (!delta.locale.equals(locale)) {
            locale = (Locale) delta.locale.clone();
            // If locale has changed, then layout direction is also changed ...
            changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
            // ... and we need to update the layout direction (represented by the first
            // 2 most significant bits in screenLayout).
            setLayoutDirection(locale);
        }
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (((delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != SCREENLAYOUT_SIZE_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != (screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_SIZE_MASK) | (delta.screenLayout & SCREENLAYOUT_SIZE_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_LONG_MASK) != SCREENLAYOUT_LONG_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_LONG_MASK) != (screenLayout & SCREENLAYOUT_LONG_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_LONG_MASK) | (delta.screenLayout & SCREENLAYOUT_LONG_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != SCREENLAYOUT_ROUND_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != (screenLayout & SCREENLAYOUT_ROUND_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_ROUND_MASK) | (delta.screenLayout & SCREENLAYOUT_ROUND_MASK);
    }
    if ((delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED) != (screenLayout & SCREENLAYOUT_COMPAT_NEEDED) && delta.screenLayout != 0) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_COMPAT_NEEDED) | (delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED);
    }
    if (((delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED) && (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != (colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_WIDE_COLOR_GAMUT_MASK) | (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
    }
    if (((delta.colorMode & COLOR_MODE_HDR_MASK) != COLOR_MODE_HDR_UNDEFINED) && (delta.colorMode & COLOR_MODE_HDR_MASK) != (colorMode & COLOR_MODE_HDR_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_HDR_MASK) | (delta.colorMode & COLOR_MODE_HDR_MASK);
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.appBounds != null && !delta.appBounds.equals(appBounds)) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        setAppBounds(delta.appBounds);
    }
    if (delta.assetsSeq != ASSETS_SEQ_UNDEFINED && delta.assetsSeq != assetsSeq) {
        changed |= ActivityInfo.CONFIG_ASSETS_PATHS;
        assetsSeq = delta.assetsSeq;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}",1,"/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 */
","/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 */
",0,[@Config],[@Config],0,,,,,,,,,,
316,<android.os.MemoryFile: boolean allowPurging(boolean)>,26,27,,,,"{
    boolean oldValue = mAllowPurging;
    if (oldValue != allowPurging) {
        native_pin(mFD, !allowPurging);
        mAllowPurging = allowPurging;
    }
    return oldValue;
}","{
    boolean oldValue = mAllowPurging;
    if (oldValue != allowPurging) {
        native_pin(mSharedMemory.getFileDescriptor(), !allowPurging);
        mAllowPurging = allowPurging;
    }
    return oldValue;
}",1,"/**
 * Enables or disables purging of the memory file.
 *
 * @param allowPurging true if the operating system can purge the contents
 * of the file in low memory situations
 * @return previous value of allowPurging
 */
","/**
 * Enables or disables purging of the memory file.
 *
 * @param allowPurging true if the operating system can purge the contents
 * of the file in low memory situations
 * @return previous value of allowPurging
 *
 * @deprecated Purgable is considered generally fragile and hard to use safely. Applications
 * are recommend to instead use {@link android.content.ComponentCallbacks2#onTrimMemory(int)}
 * to react to memory events and release shared memory regions as appropriate.
 */
",1,,[@Deprecated],1,,,,,,,"4,5",0,"The implementation has changed by using `mSharedMemory.getFileDescriptor()` instead of `mFD`. This is an example of accessing a file descriptor through a different variable, hence the dependent API has been changed, which points to code change type 5. Besides, no return statement or exception handling pattern has been altered. Therefore, no changes occurred in types 1-3.",#CI_description
317,"<android.app.FragmentManagerImpl: void dispatchMultiWindowModeChanged(boolean,Configuration)>",26,27,,,,"{
    if (mAdded == null) {
        return;
    }
    for (int i = mAdded.size() - 1; i >= 0; --i) {
        final Fragment f = mAdded.get(i);
        if (f != null) {
            f.performMultiWindowModeChanged(isInMultiWindowMode, newConfig);
        }
    }
}","{
    for (int i = mAdded.size() - 1; i >= 0; --i) {
        final Fragment f = mAdded.get(i);
        if (f != null) {
            f.performMultiWindowModeChanged(isInMultiWindowMode, newConfig);
        }
    }
}",1,,,0,,,0,,,,,,,3,0,"The 'if' control statement checking if mAdded is null gets removed in the late version, so the code change type is 3 (Control dependency change).","The removal of the null check for mAdded seems to be a potential issue as it could now potentially lead to a NullPointerException if mAdded is null. However, this is assuming that mAdded could be null at this point in the code. If mAdded being null is an invariant in the context of this method (i.e., if mAdded is guaranteed to be non-null when this method is called due to prior checks or the logic of the program), then the removal of this condition doesn't introduce a new behavior in terms of API contract but merely eliminates a redundant check. Given the information, there doesn't seem to be enough context to definitively state whether a Compatibility Issue is introduced. Therefore, with the benefit of the doubt and assuming API invariants are respected, I categorize it as No Compatibility Issue."
318,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,26,27,,,,"{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource);
}","{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource, mVersionInfo);
}",1,"/**
 * Builds and returns {@link TextSelection} object.
 */
","/**
 * Builds and returns {@link TextSelection} object.
 */
",0,,,0,,,,,,,"1,5",1,"The constructor for TextSelection has been changed by adding a new parameter mVersionInfo, so the code change types include 1 for the return statement change and 5 because the constructor API that it depends on has likely changed.","This change in the constructor call means the method will return a TextSelection object with potentially different state due to the inclusion of the new parameter mVersionInfo, so there is a compatibility issue of type 1."
319,"<android.app.FragmentManagerImpl: void dispatchOnFragmentStopped(Fragment,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentStopped(f, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentStopped(this, f);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentStopped(f, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentStopped(this, f);
        }
    }
}",1,,,0,,,0,,,,,,,1,1,"The if condition check for `mLifecycleCallbacks == null` has been removed along with its associated return statement which would skip the following loop if `mLifecycleCallbacks` was null. This means that the late version may attempt to iterate over `mLifecycleCallbacks` even if it is null, potentially leading to a NullPointerException that did not occur in the early version.","The deletion of the null check on `mLifecycleCallbacks` and the associated return statement means that the API could behave differently if `mLifecycleCallbacks` is null. In the early version, the method would return early, but in the late version, it would continue to the loop and potentially throw a NullPointerException. This change can result in an altered control flow that was not present in the early version, causing a potential Compatibility Issue due to different exceptions being thrown (or not thrown) relative to the early version. Thus, CI type is 1."
321,<android.database.AbstractCursor: int getColumnIndexOrThrow(String)>,26,27,,,,"{
    final int index = getColumnIndex(columnName);
    if (index < 0) {
        throw new IllegalArgumentException(""column '"" + columnName + ""' does not exist"");
    }
    return index;
}","{
    final int index = getColumnIndex(columnName);
    if (index < 0) {
        String availableColumns = """";
        try {
            availableColumns = Arrays.toString(getColumnNames());
        } catch (Exception e) {
            Log.d(TAG, ""Cannot collect column names for debug purposes"", e);
        }
        throw new IllegalArgumentException(""column '"" + columnName + ""' does not exist. Available columns: "" + availableColumns);
    }
    return index;
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,4",2,"An exception handling statement and a log message have been added to enhance error information when throwing IllegalArgumentException, plus an attempt to log available columns on exception. The change type is 2 (for the different exception handling and the additional message in the exception thrown), and 4 (for the logging operation).","The thrown exception contains additional information in the late version (a list of available columns), and there is also a new log operation within the exception handling block, which may not affect the API's functional behavior but does affect its side effects in terms of logging, so the CI type is 2."
322,<android.app.ContextImpl: File getExternalFilesDir(String)>,26,27,,,,"{
    // Operates on primary external storage
    return getExternalFilesDirs(type)[0];
}","{
    // Operates on primary external storage
    final File[] dirs = getExternalFilesDirs(type);
    return (dirs != null && dirs.length > 0) ? dirs[0] : null;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"The late version added a condition check for both 'dirs != null' and 'dirs.length > 0' before returning dirs[0], which adds a null check condition on the array before accessing its first element and thus represents a control dependency change. There is also a return statement change since it now accounts for the possibility of 'dirs' being null or empty and returns null in that case, whereas the early version does not check this and always returns the first element.","The change to the return statement could result in a different return value. In the early version, if 'getExternalFilesDirs(type)' returns null, it could result in a NullPointerException when trying to access the first element of the array, while in the late version, it will simply return null. If 'getExternalFilesDirs(type)' returns an empty array, the early version would lead to an ArrayIndexOutOfBoundsException, while the late version would return null. The late version thus handles potential exceptions by returning null instead of throwing. Therefore, the CI type is 1 due to potential different return values."
324,<android.hardware.camera2.impl.CameraConstrainedHighSpeedCaptureSessionImpl: List<CaptureRequest> createHighSpeedRequestList(CaptureRequest)>,26,27,,,,"{
    if (request == null) {
        throw new IllegalArgumentException(""Input capture request must not be null"");
    }
    Collection<Surface> outputSurfaces = request.getTargets();
    Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
    StreamConfigurationMap config = mCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputSurfaces, fpsRange, config);
    // Request list size: to limit the preview to 30fps, need use maxFps/30; to maximize
    // the preview frame rate, should use maxBatch size for that high speed stream
    // configuration. We choose the former for now.
    int requestListSize = fpsRange.getUpper() / 30;
    List<CaptureRequest> requestList = new ArrayList<CaptureRequest>();
    // Prepare the Request builders: need carry over the request controls.
    // First, create a request builder that will only include preview or recording target.
    CameraMetadataNative requestMetadata = new CameraMetadataNative(request.getNativeCopy());
    // Note that after this step, the requestMetadata is mutated (swapped) and can not be used
    // for next request builder creation.
    CaptureRequest.Builder singleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
    false, CameraCaptureSession.SESSION_ID_NONE);
    // Overwrite the capture intent to make sure a good value is set.
    Iterator<Surface> iterator = outputSurfaces.iterator();
    Surface firstSurface = iterator.next();
    Surface secondSurface = null;
    if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
    } else {
        // Video only, or preview + video
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    }
    singleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
    true);
    // Second, Create a request builder that will include both preview and recording targets.
    CaptureRequest.Builder doubleTargetRequestBuilder = null;
    if (outputSurfaces.size() == 2) {
        // Have to create a new copy, the original one was mutated after a new
        // CaptureRequest.Builder creation.
        requestMetadata = new CameraMetadataNative(request.getNativeCopy());
        doubleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE);
        doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
        doubleTargetRequestBuilder.addTarget(firstSurface);
        secondSurface = iterator.next();
        doubleTargetRequestBuilder.addTarget(secondSurface);
        doubleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
        true);
        // Make sure singleTargetRequestBuilder contains only recording surface for
        // preview + recording case.
        Surface recordingSurface = firstSurface;
        if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
            recordingSurface = secondSurface;
        }
        singleTargetRequestBuilder.addTarget(recordingSurface);
    } else {
        // Single output case: either recording or preview.
        singleTargetRequestBuilder.addTarget(firstSurface);
    }
    // Generate the final request list.
    for (int i = 0; i < requestListSize; i++) {
        if (i == 0 && doubleTargetRequestBuilder != null) {
            // First request should be recording + preview request
            requestList.add(doubleTargetRequestBuilder.build());
        } else {
            requestList.add(singleTargetRequestBuilder.build());
        }
    }
    return Collections.unmodifiableList(requestList);
}","{
    if (request == null) {
        throw new IllegalArgumentException(""Input capture request must not be null"");
    }
    Collection<Surface> outputSurfaces = request.getTargets();
    Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
    StreamConfigurationMap config = mCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputSurfaces, fpsRange, config);
    // Request list size: to limit the preview to 30fps, need use maxFps/30; to maximize
    // the preview frame rate, should use maxBatch size for that high speed stream
    // configuration. We choose the former for now.
    int requestListSize = fpsRange.getUpper() / 30;
    List<CaptureRequest> requestList = new ArrayList<CaptureRequest>();
    // Prepare the Request builders: need carry over the request controls.
    // First, create a request builder that will only include preview or recording target.
    CameraMetadataNative requestMetadata = new CameraMetadataNative(request.getNativeCopy());
    // Note that after this step, the requestMetadata is mutated (swapped) and can not be used
    // for next request builder creation.
    CaptureRequest.Builder singleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
    false, CameraCaptureSession.SESSION_ID_NONE);
    // Carry over userTag, as native metadata doesn't have this field.
    singleTargetRequestBuilder.setTag(request.getTag());
    // Overwrite the capture intent to make sure a good value is set.
    Iterator<Surface> iterator = outputSurfaces.iterator();
    Surface firstSurface = iterator.next();
    Surface secondSurface = null;
    if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
    } else {
        // Video only, or preview + video
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    }
    singleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
    true);
    // Second, Create a request builder that will include both preview and recording targets.
    CaptureRequest.Builder doubleTargetRequestBuilder = null;
    if (outputSurfaces.size() == 2) {
        // Have to create a new copy, the original one was mutated after a new
        // CaptureRequest.Builder creation.
        requestMetadata = new CameraMetadataNative(request.getNativeCopy());
        doubleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE);
        doubleTargetRequestBuilder.setTag(request.getTag());
        doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
        doubleTargetRequestBuilder.addTarget(firstSurface);
        secondSurface = iterator.next();
        doubleTargetRequestBuilder.addTarget(secondSurface);
        doubleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
        true);
        // Make sure singleTargetRequestBuilder contains only recording surface for
        // preview + recording case.
        Surface recordingSurface = firstSurface;
        if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
            recordingSurface = secondSurface;
        }
        singleTargetRequestBuilder.addTarget(recordingSurface);
    } else {
        // Single output case: either recording or preview.
        singleTargetRequestBuilder.addTarget(firstSurface);
    }
    // Generate the final request list.
    for (int i = 0; i < requestListSize; i++) {
        if (i == 0 && doubleTargetRequestBuilder != null) {
            // First request should be recording + preview request
            requestList.add(doubleTargetRequestBuilder.build());
        } else {
            requestList.add(singleTargetRequestBuilder.build());
        }
    }
    return Collections.unmodifiableList(requestList);
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
327,"<android.app.FragmentManagerImpl: void addFragment(Fragment,boolean)>",26,27,,,,"{
    if (mAdded == null) {
        mAdded = new ArrayList<Fragment>();
    }
    if (DEBUG)
        Log.v(TAG, ""add: "" + fragment);
    makeActive(fragment);
    if (!fragment.mDetached) {
        if (mAdded.contains(fragment)) {
            throw new IllegalStateException(""Fragment already added: "" + fragment);
        }
        synchronized (mAdded) {
            mAdded.add(fragment);
        }
        fragment.mAdded = true;
        fragment.mRemoving = false;
        if (fragment.mView == null) {
            fragment.mHiddenChanged = false;
        }
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        if (moveToStateNow) {
            moveToState(fragment);
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""add: "" + fragment);
    makeActive(fragment);
    if (!fragment.mDetached) {
        if (mAdded.contains(fragment)) {
            throw new IllegalStateException(""Fragment already added: "" + fragment);
        }
        synchronized (mAdded) {
            mAdded.add(fragment);
        }
        fragment.mAdded = true;
        fragment.mRemoving = false;
        if (fragment.mView == null) {
            fragment.mHiddenChanged = false;
        }
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        if (moveToStateNow) {
            moveToState(fragment);
        }
    }
}",1,,,0,,,0,,,,,,,4,0,"The code change only shows the deletion of the conditional block that initializes `mAdded` if it is `null`. This block is part of the initialization process and does not affect the behavior of the `addFragment` method if we assume that `mAdded` is properly initialized before this method is called, so the change type is 4.","There is no compatibility issue, assuming that `mAdded` is never `null` when this method is invoked, since the removed code is only about initializing `mAdded`, which should be already initialized under normal conditions. This would not affect the method's behavior and therefore it's classified as 0."
328,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingRequest(CaptureRequest,CaptureCallback,Handler)>",26,27,,,,"{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    } else if (request.isReprocess()) {
        throw new IllegalArgumentException(""repeating reprocess requests are not supported"");
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (DEBUG) {
        Log.v(TAG, mIdString + ""setRepeatingRequest - request "" + request + "", callback "" + callback + "" handler"" + "" "" + handler);
    }
    return addPendingSequence(mDeviceImpl.setRepeatingRequest(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}","{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    } else if (request.isReprocess()) {
        throw new IllegalArgumentException(""repeating reprocess requests are not supported"");
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        checkNotClosed();
        handler = checkHandler(handler, callback);
        if (DEBUG) {
            Log.v(TAG, mIdString + ""setRepeatingRequest - request "" + request + "", callback "" + callback + "" handler"" + "" "" + handler);
        }
        return addPendingSequence(mDeviceImpl.setRepeatingRequest(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,There is a change in control dependency. The entire block of method code has been included within a synchronized block in the late version.,There is no Compatibility Issue as the synchronized block does not alter the behavior of the existing code; it simply adds thread safety by ensuring that the block of code is executed by only one thread at a time. It won't lead to a different return value or exception being thrown.
330,"<android.text.InputFilter.AllCaps: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",26,27,,,,"{
    for (int i = start; i < end; i++) {
        if (Character.isLowerCase(source.charAt(i))) {
            char[] v = new char[end - start];
            TextUtils.getChars(source, start, end, v, 0);
            String s = new String(v).toUpperCase();
            if (source instanceof Spanned) {
                SpannableString sp = new SpannableString(s);
                TextUtils.copySpansFrom((Spanned) source, start, end, null, sp, 0);
                return sp;
            } else {
                return s;
            }
        }
    }
    // keep original
    return null;
}","{
    final CharSequence wrapper = new CharSequenceWrapper(source, start, end);
    boolean lowerOrTitleFound = false;
    final int length = end - start;
    for (int i = 0, cp; i < length; i += Character.charCount(cp)) {
        // We access 'wrapper' instead of 'source' to make sure no code unit beyond 'end' is
        // ever accessed.
        cp = Character.codePointAt(wrapper, i);
        if (Character.isLowerCase(cp) || Character.isTitleCase(cp)) {
            lowerOrTitleFound = true;
            break;
        }
    }
    if (!lowerOrTitleFound) {
        // keep original
        return null;
    }
    final boolean copySpans = source instanceof Spanned;
    final CharSequence upper = TextUtils.toUpperCase(mLocale, wrapper, copySpans);
    if (upper == wrapper) {
        // keep original
        return null;
    }
    // Return a SpannableString or String for backward compatibility.
    return copySpans ? new SpannableString(upper) : upper.toString();
}",1,,,0,,,0,,,,,,,"1,3,4,5",1,"The changes between the versions include the introduction of the CharSequenceWrapper, changes in the for-loop to use code points instead of characters, a new boolean variable lowerOrTitleFound, and the use of TextUtils.toUpperCase that also takes a Locale into account. Additionally, late version uses codePointAt instead of charAt and checks for both isLowerCase and isTitleCase. The early implementation converts the input to uppercase directly in the loop and only if there is a lowercase character. In contrast, the late implementation first determines if there are any characters that need converting (lowercase or titlecase) and then performs the conversion outside the loop. It also uses upper == wrapper to decide whether to keep the original. Finally, it has modified how Spans are copied and what value is returned (either SpannableString or upper.toString()). These are changes to the control structure, other statements, and a change in the dependent API, namely TextUtils.toUpperCase, which likely has a different implementation because it now takes a Locale as a parameter. Hence, the code change type is 1,3,4,5.","The code changes lead to a situation where the method behavior could change in the following ways: it could potentially return different CharSequence values due to the introduction of new conditional checks that modify the flow and the conversion of characters to uppercase; it leverages the Character.codePointAt potentially affecting surrogate pairs differently than the previous implementation; it has an altered mechanism for span copying and conditional logic for return values. Therefore, the behavior can change depending on these new conditions and checks, leading to a different return value or type, making the CI type 1."
331,<android.appwidget.AppWidgetHost: void deleteHost()>,26,27,,,,"{
    try {
        sService.deleteHost(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (sService == null) {
        return;
    }
    try {
        sService.deleteHost(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
","/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
",0,,,0,,,,,,,3,0,"There is a new 'if' control statement added that checks if `sService` is null and returns early if that is the case, so the code change type is 3.","Although there is a new early return statement, it does not introduce a Compatibility Issue because the method's return type is `void`, so the added return statement has no effect on what value (since there is no value) or type the method returns. Additionally, this change does not affect the exception handling, so there is no CI caused by potential different return values or types or by potential different exception handlings."
332,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,FragmentManagerNonConfig)>",26,27,,,,"{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    List<FragmentManagerNonConfig> childNonConfigs = null;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        List<Fragment> nonConfigFragments = nonConfig.getFragments();
        childNonConfigs = nonConfig.getChildNonConfigs();
        final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;
        for (int i = 0; i < count; i++) {
            Fragment f = nonConfigFragments.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            // index of f in fms.mActive
            int index = 0;
            while (index < fms.mActive.length && fms.mActive[index].mIndex != f.mIndex) {
                index++;
            }
            if (index == fms.mActive.length) {
                throwException(new IllegalStateException(""Could not find active fragment "" + ""with index "" + f.mIndex));
            }
            FragmentState fs = fms.mActive[index];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                f.mSavedFragmentState = fs.mSavedFragmentState;
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new SparseArray<>(fms.mActive.length);
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            FragmentManagerNonConfig childNonConfig = null;
            if (childNonConfigs != null && i < childNonConfigs.size()) {
                childNonConfig = childNonConfigs.get(i);
            }
            Fragment f = fs.instantiate(mHost, mContainer, mParent, childNonConfig);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f);
            mActive.put(f.mIndex, f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        List<Fragment> nonConfigFragments = nonConfig.getFragments();
        final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;
        for (int i = 0; i < count; i++) {
            Fragment f = nonConfigFragments.get(i);
            if (f.mTargetIndex >= 0) {
                f.mTarget = mActive.get(f.mTargetIndex);
                if (f.mTarget == null) {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throwException(new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: added #"" + i + "": "" + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException(""Already added!"");
            }
            synchronized (mAdded) {
                mAdded.add(f);
            }
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, ""restoreAllState: back stack #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
                LogWriter logw = new LogWriter(Log.VERBOSE, TAG);
                PrintWriter pw = new FastPrintWriter(logw, false, 1024);
                bse.dump(""  "", pw, false);
                pw.flush();
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
    if (fms.mPrimaryNavActiveIndex >= 0) {
        mPrimaryNav = mActive.get(fms.mPrimaryNavActiveIndex);
    }
    mNextFragmentIndex = fms.mNextFragmentIndex;
}","{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    List<FragmentManagerNonConfig> childNonConfigs = null;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        List<Fragment> nonConfigFragments = nonConfig.getFragments();
        childNonConfigs = nonConfig.getChildNonConfigs();
        final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;
        for (int i = 0; i < count; i++) {
            Fragment f = nonConfigFragments.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            // index of f in fms.mActive
            int index = 0;
            while (index < fms.mActive.length && fms.mActive[index].mIndex != f.mIndex) {
                index++;
            }
            if (index == fms.mActive.length) {
                throwException(new IllegalStateException(""Could not find active fragment "" + ""with index "" + f.mIndex));
            }
            FragmentState fs = fms.mActive[index];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                f.mSavedFragmentState = fs.mSavedFragmentState;
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new SparseArray<>(fms.mActive.length);
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            FragmentManagerNonConfig childNonConfig = null;
            if (childNonConfigs != null && i < childNonConfigs.size()) {
                childNonConfig = childNonConfigs.get(i);
            }
            Fragment f = fs.instantiate(mHost, mContainer, mParent, childNonConfig);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f);
            mActive.put(f.mIndex, f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        List<Fragment> nonConfigFragments = nonConfig.getFragments();
        final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;
        for (int i = 0; i < count; i++) {
            Fragment f = nonConfigFragments.get(i);
            if (f.mTargetIndex >= 0) {
                f.mTarget = mActive.get(f.mTargetIndex);
                if (f.mTarget == null) {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    mAdded.clear();
    if (fms.mAdded != null) {
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throwException(new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: added #"" + i + "": "" + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException(""Already added!"");
            }
            synchronized (mAdded) {
                mAdded.add(f);
            }
        }
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, ""restoreAllState: back stack #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
                LogWriter logw = new LogWriter(Log.VERBOSE, TAG);
                PrintWriter pw = new FastPrintWriter(logw, false, 1024);
                bse.dump(""  "", pw, false);
                pw.flush();
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
    if (fms.mPrimaryNavActiveIndex >= 0) {
        mPrimaryNav = mActive.get(fms.mPrimaryNavActiveIndex);
    }
    mNextFragmentIndex = fms.mNextFragmentIndex;
}",1,,,0,,,0,,,,,,,,,,
333,<android.os.PowerManager.WakeLock: void release(int)>,26,27,,,,"{
    synchronized (mToken) {
        if (!mRefCounted || --mCount == 0) {
            mHandler.removeCallbacks(mReleaser);
            if (mHeld) {
                Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0);
                try {
                    mService.releaseWakeLock(mToken, flags);
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
                mHeld = false;
            }
        }
        if (mCount < 0) {
            throw new RuntimeException(""WakeLock under-locked "" + mTag);
        }
    }
}","{
    synchronized (mToken) {
        mInternalCount--;
        if ((flags & RELEASE_FLAG_TIMEOUT) == 0) {
            mExternalCount--;
        }
        if (!mRefCounted || mInternalCount == 0) {
            mHandler.removeCallbacks(mReleaser);
            if (mHeld) {
                Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0);
                try {
                    mService.releaseWakeLock(mToken, flags);
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
                mHeld = false;
            }
        }
        if (mRefCounted && mExternalCount < 0) {
            throw new RuntimeException(""WakeLock under-locked "" + mTag);
        }
    }
}",1,"/**
 * Releases the wake lock with flags to modify the release behavior.
 * <p>
 * This method releases your claim to the CPU or screen being on.
 * The screen may turn off shortly after you release the wake lock, or it may
 * not if there are other wake locks still held.
 * </p>
 *
 * @param flags Combination of flag values to modify the release behavior.
 * Currently only {@link #RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY} is supported.
 * Passing 0 is equivalent to calling {@link #release()}.
 */
","/**
 * Releases the wake lock with flags to modify the release behavior.
 * <p>
 * This method releases your claim to the CPU or screen being on.
 * The screen may turn off shortly after you release the wake lock, or it may
 * not if there are other wake locks still held.
 * </p>
 *
 * @param flags Combination of flag values to modify the release behavior.
 * Currently only {@link #RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY} is supported.
 * Passing 0 is equivalent to calling {@link #release()}.
 */
",0,,,0,,,,,,,"1,3,4",1,"The method's implementation has been altered to include additional fields (mInternalCount and mExternalCount), a new conditional check for the RELEASE_FLAG_TIMEOUT flag, and changes to the logic for decrementing the reference counts. The changes in the control dependency and additional decrementing logic qualify as a control dependency change (3), and because the implementation now works with different fields, it's an other statement changed (4). Additionally, since new exception handling conditions may apply due to the adjusted logic, this is also a return statement change (1).","Given the additional logic involved in decrementing reference counts based on the flags passed to the release method, the potential decision-making process on whether to release the lock or not has changed. Furthermore, the conditions under which the RuntimeException is thrown have also altered (now checking mExternalCount instead of mCount), which can alter the control flow dramatically. Due to these changes, it's possible for the updated method to exhibit different behavior, thereby leading to a return value change (1) - either because the method might throw a RuntimeException in different scenarios or might alter the state of mHeld differently compared to the earlier implementation."
334,<android.bluetooth.BluetoothDevice: boolean createBond()>,26,27,,,,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot create bond to Remote Device"");
        return false;
    }
    try {
        Log.i(TAG, ""createBond() for device "" + getAddress() + "" called by pid: "" + Process.myPid() + "" tid: "" + Process.myTid());
        return sService.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot create bond to Remote Device"");
        return false;
    }
    try {
        Log.i(TAG, ""createBond() for device "" + getAddress() + "" called by pid: "" + Process.myPid() + "" tid: "" + Process.myTid());
        return service.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 *
 * @return false on immediate error, true if bonding will begin
 */
","/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 *
 * @return false on immediate error, true if bonding will begin
 */
",0,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],0,,,,,,,4,0,"The code change is the local variable introduction for 'sService' by assigning 'service', and then this variable is used instead of 'sService' directly. However, there is no semantic change within the method body itself; hence, the code change type is 4.",There is no Compatibility Issue as the code change does not affect the API's behaviour. The method still performs the same operations and returns the same values under the same conditions as before.
335,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,26,27,,,,"{
    if (DBG)
        Log.d(TAG, ""received "" + nameOf(message.what));
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            return;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            return;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, ""Channel lost"");
            return;
        default:
            break;
    }
    Object listener = getListener(message.arg2);
    if (listener == null) {
        Log.d(TAG, ""Stale key "" + message.arg2);
        return;
    }
    NsdServiceInfo ns = getNsdService(message.arg2);
    switch(message.what) {
        case DISCOVER_SERVICES_STARTED:
            String s = getNsdServiceInfoType((NsdServiceInfo) message.obj);
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            break;
        case DISCOVER_SERVICES_FAILED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            break;
        case STOP_DISCOVERY_FAILED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdServiceInfoType(ns));
            break;
        case REGISTER_SERVICE_FAILED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onRegistrationFailed(ns, message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            break;
        case UNREGISTER_SERVICE_FAILED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onUnregistrationFailed(ns, message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onServiceUnregistered(ns);
            break;
        case RESOLVE_SERVICE_FAILED:
            removeListener(message.arg2);
            ((ResolveListener) listener).onResolveFailed(ns, message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            removeListener(message.arg2);
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, ""Ignored "" + message);
            break;
    }
}","{
    final int what = message.what;
    final int key = message.arg2;
    switch(what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            return;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            return;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, ""Channel lost"");
            return;
        default:
            break;
    }
    final Object listener;
    final NsdServiceInfo ns;
    synchronized (mMapLock) {
        listener = mListenerMap.get(key);
        ns = mServiceMap.get(key);
    }
    if (listener == null) {
        Log.d(TAG, ""Stale key "" + message.arg2);
        return;
    }
    if (DBG) {
        Log.d(TAG, ""received "" + nameOf(what) + "" for key "" + key + "", service "" + ns);
    }
    switch(what) {
        case DISCOVER_SERVICES_STARTED:
            String s = getNsdServiceInfoType((NsdServiceInfo) message.obj);
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            break;
        case DISCOVER_SERVICES_FAILED:
            removeListener(key);
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            break;
        case STOP_DISCOVERY_FAILED:
            // TODO: failure to stop discovery should be internal and retried internally, as
            // the effect for the client is indistinguishable from STOP_DISCOVERY_SUCCEEDED
            removeListener(key);
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            removeListener(key);
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdServiceInfoType(ns));
            break;
        case REGISTER_SERVICE_FAILED:
            removeListener(key);
            ((RegistrationListener) listener).onRegistrationFailed(ns, message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            break;
        case UNREGISTER_SERVICE_FAILED:
            removeListener(key);
            ((RegistrationListener) listener).onUnregistrationFailed(ns, message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            // TODO: do not unregister listener until service is unregistered, or provide
            // alternative way for unregistering ?
            removeListener(message.arg2);
            ((RegistrationListener) listener).onServiceUnregistered(ns);
            break;
        case RESOLVE_SERVICE_FAILED:
            removeListener(key);
            ((ResolveListener) listener).onResolveFailed(ns, message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            removeListener(key);
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, ""Ignored "" + message);
            break;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
336,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForUser(int,String,long,long)>",26,27,,,,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}",1,"/**
 * Query network usage statistics summaries. Result is summarised data usage for all uids
 * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
 * This means the bucket's start and end timestamp are going to be the same as the 'startTime'
 * and 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL},
 * uid {@link NetworkStats.Bucket#UID_ALL}, tag {@link NetworkStats.Bucket#TAG_NONE},
 * metered {@link NetworkStats.Bucket#METERED_ALL}, and roaming
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result is summarised data usage for all uids
 * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
 * This means the bucket's start and end timestamp are going to be the same as the 'startTime'
 * and 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL},
 * uid {@link NetworkStats.Bucket#UID_ALL}, tag {@link NetworkStats.Bucket#TAG_NONE},
 * metered {@link NetworkStats.Bucket#METERED_ALL}, and roaming
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",0,,,0,,,,,,,"4,5",0,"The constructor for NetworkStats has an additional parameter `mFlags` in the late version. This is a change to the dependent API (The constructor of NetworkStats is not part of the given API but is essential for its functioning), so the code change type is 4,5.","There is no CI since there's no change in the behavior of the API function itself. The additional parameter in NetworkStats constructor (`mFlags`) is being handled internally and does not affect the return value or exception handling of the `querySummaryForUser` method. Therefore, the client code relying on `querySummaryForUser` would not experience any change in behavior due to this internal change."
337,<android.content.AbstractThreadedSyncAdapter.ISyncAdapterImpl: void cancelSync(ISyncContext)>,26,27,,,,"{
    // synchronize to make sure that mSyncThreads doesn't change between when we
    // check it and when we use it
    SyncThread info = null;
    synchronized (mSyncThreadLock) {
        for (SyncThread current : mSyncThreads.values()) {
            if (current.mSyncContext.getSyncContextBinder() == syncContext.asBinder()) {
                info = current;
                break;
            }
        }
    }
    if (info != null) {
        if (mAllowParallelSyncs) {
            onSyncCanceled(info);
        } else {
            onSyncCanceled();
        }
    }
}","{
    try {
        // synchronize to make sure that mSyncThreads doesn't change between when we
        // check it and when we use it
        SyncThread info = null;
        synchronized (mSyncThreadLock) {
            for (SyncThread current : mSyncThreads.values()) {
                if (current.mSyncContext.getSyncContextBinder() == syncContext.asBinder()) {
                    info = current;
                    break;
                }
            }
        }
        if (info != null) {
            if (ENABLE_LOG) {
                Log.d(TAG, ""cancelSync() "" + info.mAuthority + "" "" + info.mAccount);
            }
            if (mAllowParallelSyncs) {
                onSyncCanceled(info);
            } else {
                onSyncCanceled();
            }
        } else {
            if (ENABLE_LOG) {
                Log.w(TAG, ""cancelSync() unknown context"");
            }
        }
    } catch (RuntimeException | Error th) {
        if (ENABLE_LOG) {
            Log.d(TAG, ""cancelSync() caught exception"", th);
        }
        throw th;
    } finally {
        if (ENABLE_LOG) {
            Log.d(TAG, ""cancelSync() finishing"");
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,3,4",2,"The late version of the method has introduced a try-catch-finally block, added logging statements, and changed the exception handling behavior by rethrowing exceptions with `throw th`. Thus, the method has undergone exception handling statement changes (2), other statements changed due to the addition of logging (4), and control dependency changes (3) due to the restructuring of the code with try-catch-finally blocks.","The new exception handling could lead to different exceptions being thrown (""RuntimeException"" or ""Error""), which was not present in the early version of the method. Therefore, this modification leads to a Compatibility Issue by potentially causing different exception handlings in the late version compared to the early version, hence the CI type is 2."
339,"<android.app.ContextImpl: SharedPreferences getSharedPreferences(File,int)>",26,27,,,,"{
    checkMode(mode);
    if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.O) {
        if (isCredentialProtectedStorage() && !getSystemService(StorageManager.class).isUserKeyUnlocked(UserHandle.myUserId()) && !isBuggy()) {
            throw new IllegalStateException(""SharedPreferences in credential encrypted "" + ""storage are not available until after user is unlocked"");
        }
    }
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) {
        final ArrayMap<File, SharedPreferencesImpl> cache = getSharedPreferencesCacheLocked();
        sp = cache.get(file);
        if (sp == null) {
            sp = new SharedPreferencesImpl(file, mode);
            cache.put(file, sp);
            return sp;
        }
    }
    if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    }
    return sp;
}","{
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) {
        final ArrayMap<File, SharedPreferencesImpl> cache = getSharedPreferencesCacheLocked();
        sp = cache.get(file);
        if (sp == null) {
            checkMode(mode);
            if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.O) {
                if (isCredentialProtectedStorage() && !getSystemService(UserManager.class).isUserUnlockingOrUnlocked(UserHandle.myUserId())) {
                    throw new IllegalStateException(""SharedPreferences in credential encrypted "" + ""storage are not available until after user is unlocked"");
                }
            }
            sp = new SharedPreferencesImpl(file, mode);
            cache.put(file, sp);
            return sp;
        }
    }
    if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    }
    return sp;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4,5","1,2","The control flow and condition checking for `checkMode(mode)` and the block of code regarding credential protected storage have been moved inside the `if (sp == null)` condition block, and there's also a change from `getSystemService(StorageManager.class)` in early version to `getSystemService(UserManager.class)` in the late version which indicates a dependent API has been changed. Additionally, a part of the Exception message string has been updated. Therefore, the changes include control dependency change (3), other statement changed due to the message string update (4), and dependent API changed (5).","Because of the control flow change, the `throw new IllegalStateException` will now only execute under a narrower set of conditions (only when `sp` is `null`), which could result in it throwing an exception where it previously would not have, causing a CI type of 2. Additionally, the change in dependent API from `StorageManager` to `UserManager` may cause a change in the behavior of how the user unlock state is checked which could lead to the method throwing an exception where it previously might not or vice versa, which is another CI type of 2. The change in where the `checkMode()` method call is made, along with change in exception throwing logic and the change of the dependent API indicate the possibility of the method returning a different value, leading to a CI type of 1."
340,<android.widget.SelectionActionModeHelper: boolean resetSelection(int)>,26,27,,,,"{
    if (mSelectionTracker.resetSelection(textIndex, mEditor, mTextClassificationHelper.getSelectionTag())) {
        invalidateActionModeAsync();
        return true;
    }
    return false;
}","{
    if (mSelectionTracker.resetSelection(textIndex, mEditor)) {
        invalidateActionModeAsync();
        return true;
    }
    return false;
}",1,,,0,,,0,,,,,,,"4,5",0,"The method call `mSelectionTracker.resetSelection` in the conditional statement has removed the third parameter (`mTextClassificationHelper.getSelectionTag()`), therefore change type is 4 for other statement changed and 5 for dependent API changed.","Despite the change in the dependent API, the API always returns a boolean value and neither the return statements nor the exception handling have been altered; hence, it is unlikely to pose potential compatibility issues due to return values or exception handling, so the CI type is 0."
341,"<com.android.server.BootReceiver: int fixFsckFsStat(String,int,String[],int,int)>",26,27,,,,"{
    int stat = statOrg;
    if ((stat & FS_STAT_FS_FIXED) != 0) {
        // fs was fixed. should check if quota warning was caused by tree optimization.
        // This is not a real fix but optimization, so should not be counted as a fs fix.
        Pattern passPattern = Pattern.compile(FSCK_PASS_PATTERN);
        Pattern treeOptPattern = Pattern.compile(FSCK_TREE_OPTIMIZATION_PATTERN);
        String currentPass = """";
        boolean foundTreeOptimization = false;
        boolean foundQuotaFix = false;
        boolean foundOtherFix = false;
        String otherFixLine = null;
        for (int i = startLineNumber; i < endLineNumber; i++) {
            String line = lines[i];
            if (line.contains(FSCK_FS_MODIFIED)) {
                // no need to parse above this
                break;
            } else if (line.startsWith(""Pass "")) {
                Matcher matcher = passPattern.matcher(line);
                if (matcher.find()) {
                    currentPass = matcher.group(1);
                }
            } else if (line.startsWith(""Inode "")) {
                Matcher matcher = treeOptPattern.matcher(line);
                if (matcher.find() && currentPass.equals(""1"")) {
                    foundTreeOptimization = true;
                    Slog.i(TAG, ""fs_stat, partition:"" + partition + "" found tree optimization:"" + line);
                } else {
                    foundOtherFix = true;
                    otherFixLine = line;
                    break;
                }
            } else if (line.startsWith(""[QUOTA WARNING]"") && currentPass.equals(""5"")) {
                Slog.i(TAG, ""fs_stat, partition:"" + partition + "" found quota warning:"" + line);
                foundQuotaFix = true;
                if (!foundTreeOptimization) {
                    // only quota warning, this is real fix.
                    otherFixLine = line;
                    break;
                }
            } else if (line.startsWith(""Update quota info"") && currentPass.equals(""5"")) {
            // follows ""[QUOTA WARNING]"", ignore
            } else {
                line = line.trim();
                // ignore empty msg or any msg before Pass 1
                if (!line.isEmpty() && !currentPass.isEmpty()) {
                    foundOtherFix = true;
                    otherFixLine = line;
                    break;
                }
            }
        }
        if (!foundOtherFix && foundTreeOptimization && foundQuotaFix) {
            // not a real fix, so clear it.
            Slog.i(TAG, ""fs_stat, partition:"" + partition + "" quota fix due to tree optimization"");
            stat &= ~FS_STAT_FS_FIXED;
        } else {
            if (otherFixLine != null) {
                Slog.i(TAG, ""fs_stat, partition:"" + partition + "" fix:"" + otherFixLine);
            }
        }
    }
    return stat;
}","{
    int stat = statOrg;
    if ((stat & FS_STAT_FS_FIXED) != 0) {
        // fs was fixed. should check if quota warning was caused by tree optimization.
        // This is not a real fix but optimization, so should not be counted as a fs fix.
        Pattern passPattern = Pattern.compile(FSCK_PASS_PATTERN);
        Pattern treeOptPattern = Pattern.compile(FSCK_TREE_OPTIMIZATION_PATTERN);
        String currentPass = """";
        boolean foundTreeOptimization = false;
        boolean foundQuotaFix = false;
        boolean foundTimestampAdjustment = false;
        boolean foundOtherFix = false;
        String otherFixLine = null;
        for (int i = startLineNumber; i < endLineNumber; i++) {
            String line = lines[i];
            if (line.contains(FSCK_FS_MODIFIED)) {
                // no need to parse above this
                break;
            } else if (line.startsWith(""Pass "")) {
                Matcher matcher = passPattern.matcher(line);
                if (matcher.find()) {
                    currentPass = matcher.group(1);
                }
            } else if (line.startsWith(""Inode "")) {
                Matcher matcher = treeOptPattern.matcher(line);
                if (matcher.find() && currentPass.equals(""1"")) {
                    foundTreeOptimization = true;
                    Slog.i(TAG, ""fs_stat, partition:"" + partition + "" found tree optimization:"" + line);
                } else {
                    foundOtherFix = true;
                    otherFixLine = line;
                    break;
                }
            } else if (line.startsWith(""[QUOTA WARNING]"") && currentPass.equals(""5"")) {
                Slog.i(TAG, ""fs_stat, partition:"" + partition + "" found quota warning:"" + line);
                foundQuotaFix = true;
                if (!foundTreeOptimization) {
                    // only quota warning, this is real fix.
                    otherFixLine = line;
                    break;
                }
            } else if (line.startsWith(""Update quota info"") && currentPass.equals(""5"")) {
            // follows ""[QUOTA WARNING]"", ignore
            } else if (line.startsWith(""Timestamp(s) on inode"") && line.contains(""beyond 2310-04-04 are likely pre-1970"") && currentPass.equals(""1"")) {
                Slog.i(TAG, ""fs_stat, partition:"" + partition + "" found timestamp adjustment:"" + line);
                // followed by next line, ""Fix? yes""
                if (lines[i + 1].contains(""Fix? yes"")) {
                    i++;
                }
                foundTimestampAdjustment = true;
            } else {
                line = line.trim();
                // ignore empty msg or any msg before Pass 1
                if (!line.isEmpty() && !currentPass.isEmpty()) {
                    foundOtherFix = true;
                    otherFixLine = line;
                    break;
                }
            }
        }
        if (foundOtherFix) {
            if (otherFixLine != null) {
                Slog.i(TAG, ""fs_stat, partition:"" + partition + "" fix:"" + otherFixLine);
            }
        } else if (foundQuotaFix && !foundTreeOptimization) {
            Slog.i(TAG, ""fs_stat, got quota fix without tree optimization, partition:"" + partition);
        } else if ((foundTreeOptimization && foundQuotaFix) || foundTimestampAdjustment) {
            // not a real fix, so clear it.
            Slog.i(TAG, ""fs_stat, partition:"" + partition + "" fix ignored"");
            stat &= ~FS_STAT_FS_FIXED;
        }
    }
    return stat;
}",1,"/**
 * Fix fs_stat from e2fsck.
 * For now, only handle the case of quota warning caused by tree optimization. Clear fs fix
 * flag (=0x400) caused by that.
 *
 * @param partition partition name
 * @param statOrg original stat reported from e2fsck log
 * @param lines e2fsck logs broken down into lines
 * @param startLineNumber start line to parse
 * @param endLineNumber end line. exclusive.
 * @return updated fs_stat. For tree optimization, will clear bit 0x400.
 */
","/**
 * Fix fs_stat from e2fsck.
 * For now, only handle the case of quota warning caused by tree optimization. Clear fs fix
 * flag (=0x400) caused by that.
 *
 * @param partition partition name
 * @param statOrg original stat reported from e2fsck log
 * @param lines e2fsck logs broken down into lines
 * @param startLineNumber start line to parse
 * @param endLineNumber end line. exclusive.
 * @return updated fs_stat. For tree optimization, will clear bit 0x400.
 */
",0,[@VisibleForTesting],[@VisibleForTesting],0,,,,,,,,,,
342,"<android.app.FragmentManagerImpl: void dispatchOnFragmentSaveInstanceState(Fragment,Bundle,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentSaveInstanceState(f, outState, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentSaveInstanceState(this, f, outState);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentSaveInstanceState(f, outState, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentSaveInstanceState(this, f, outState);
        }
    }
}",1,,,0,,,0,,,,,,,"1,3",0,"The check for `mLifecycleCallbacks == null` is removed, and the subsequent return statement is removed. The for loop that follows no longer contains this check, hence the code change types are 1 and 3.","There is no Compatibility Issue in terms of differing return values or exception handling because the original early version returned early only if `mLifecycleCallbacks` was null. In the late version, if `mLifecycleCallbacks` was null, the for-each loop would simply not run (since there would be no elements to iterate over), achieving the same effect as the early return in the previous version. Hence, the behavior from the caller's perspective would remain unchanged, so the CI type is 0."
345,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,26,27,,,,"{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (CameraCaptureSessionImpl.this) {
            /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
            if (DEBUG)
                Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
            // as we won't get state updates any more anyway.
            if (mSkipUnconfigure) {
                return;
            }
            // everything is idle.
            try {
                // begin transition to unconfigured
                mDeviceImpl.configureStreamsChecked(/*inputConfig*/
                null, /*outputs*/
                null, /*operatingMode*/
                ICameraDeviceUser.NORMAL_MODE);
            } catch (CameraAccessException e) {
                // OK: do not throw checked exceptions.
                Log.e(TAG, mIdString + ""Exception while unconfiguring outputs: "", e);
            // TODO: call onError instead of onClosed if this happens
            } catch (IllegalStateException e) {
                // Camera is already closed, so nothing left to do
                if (DEBUG)
                    Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
            }
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
        if (DEBUG)
            Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
        // as we won't get state updates any more anyway.
        if (mSkipUnconfigure) {
            return;
        }
        // everything is idle.
        try {
            // begin transition to unconfigured
            mDeviceImpl.configureStreamsChecked(/*inputConfig*/
            null, /*outputs*/
            null, /*operatingMode*/
            ICameraDeviceUser.NORMAL_MODE);
        } catch (CameraAccessException e) {
            // OK: do not throw checked exceptions.
            Log.e(TAG, mIdString + ""Exception while unconfiguring outputs: "", e);
        // TODO: call onError instead of onClosed if this happens
        } catch (IllegalStateException e) {
            // Camera is already closed, so nothing left to do
            if (DEBUG)
                Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"A synchronized block has been removed. The early implementation was synchronizing on `CameraCaptureSessionImpl.this` within the `synchronized (mDeviceImpl.mInterfaceLock)` block, while the late implementation removed this additional synchronization. This is a control dependency change, hence the change type is 3.","The removal of the inner synchronized block does not introduce a CI because it does not affect the behavior of the visible side effects of the method. The method's actions are still the same, and this change only affects the concurrent behavior, which is not a concern from an API compatibility perspective within the context of this single method's logic. Therefore, there is no Compatibility Issue; the situation is 0."
346,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback,int,int,Handler)>",26,27,,,,"{
    if (callback == null)
        throw new NullPointerException(""callback is null"");
    // TODO(Bluetooth) check whether platform support BLE
    // Do the check here or in GattServer?
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    IBluetoothManager managerService = adapter.getBluetoothManager();
    try {
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return null;
        }
        BluetoothGatt gatt = new BluetoothGatt(iGatt, this, transport, phy);
        gatt.connect(autoConnect, callback, handler);
        return gatt;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    return connectGatt(context, autoConnect, callback, transport, false, phy, handler);
}",1,"/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @param transport preferred transport for GATT connections to remote dual-mode devices
 * {@link BluetoothDevice#TRANSPORT_AUTO} or
 * {@link BluetoothDevice#TRANSPORT_BREDR} or {@link BluetoothDevice#TRANSPORT_LE}
 * @param phy preferred PHY for connections to remote LE device. Bitwise OR of any of
 * {@link BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK},
 * an d{@link BluetoothDevice#PHY_LE_CODED_MASK}. This option does not take effect
 * if {@code autoConnect} is set to true.
 * @param handler The handler to use for the callback. If {@code null}, callbacks will happen
 * on an un-specified background thread.
 * @throws NullPointerException if callback is null
 */
","/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @param transport preferred transport for GATT connections to remote dual-mode devices
 * {@link BluetoothDevice#TRANSPORT_AUTO} or
 * {@link BluetoothDevice#TRANSPORT_BREDR} or {@link BluetoothDevice#TRANSPORT_LE}
 * @param phy preferred PHY for connections to remote LE device. Bitwise OR of any of
 * {@link BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK},
 * an d{@link BluetoothDevice#PHY_LE_CODED_MASK}. This option does not take effect
 * if {@code autoConnect} is set to true.
 * @param handler The handler to use for the callback. If {@code null}, callbacks will happen
 * on an un-specified background thread.
 * @throws NullPointerException if callback is null
 */
",0,,,0,,,,,,,"4,5",1,"The late implementation of `connectGatt` indicates the presence of an overload of `connectGatt` that accepts additional parameters. The early implementation is replaced by a single call to this new method overload. This is a clear indication of a dependent API change since the implementation relies on another method and is delegating all the arguments to it. In terms of code classification, this would likely be 'other statement changed' as no specific control dependency, exception handling, or return statement is directly altered within this method itself.","With the delegation to the new overloaded `connectGatt` method, the behavior is now dependent on this new method's implementation. If the behavior of this newly referenced method differs from the original inline code, then it's a compatibility issue of type 1 due to potential different return values or types. However, without seeing the implementation of the new `connectGatt` method, it can be assumed that it's designed to handle the responsibilities of the old code, potentially aiming to consolidate multiple entry points with similar functionality into a single reusable method. If the implementation of the new method has the same behavior, there would be no compatibility issue, but since we cannot confirm, we still need to acknowledge the potential compatibility issue due to the changed return behavior."
348,"<android.os.MemoryFile: int readBytes(byte[],int,int,int)>",26,27,,,,"{
    if (isDeactivated()) {
        throw new IOException(""Can't read from deactivated memory file."");
    }
    if (destOffset < 0 || destOffset > buffer.length || count < 0 || count > buffer.length - destOffset || srcOffset < 0 || srcOffset > mLength || count > mLength - srcOffset) {
        throw new IndexOutOfBoundsException();
    }
    return native_read(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);
}","{
    beginAccess();
    try {
        mMapping.position(srcOffset);
        mMapping.get(buffer, destOffset, count);
    } finally {
        endAccess();
    }
    return count;
}",1,"/**
 * Reads bytes from the memory file.
 * Will throw an IOException if the file has been purged.
 *
 * @param buffer byte array to read bytes into.
 * @param srcOffset offset into the memory file to read from.
 * @param destOffset offset into the byte array buffer to read into.
 * @param count number of bytes to read.
 * @return number of bytes read.
 * @throws IOException if the memory file has been purged or deactivated.
 */
","/**
 * Reads bytes from the memory file.
 * Will throw an IOException if the file has been purged.
 *
 * @param buffer byte array to read bytes into.
 * @param srcOffset offset into the memory file to read from.
 * @param destOffset offset into the byte array buffer to read into.
 * @param count number of bytes to read.
 * @return number of bytes read.
 * @throws IOException if the memory file has been purged or deactivated.
 */
",0,,,0,,,,,,,"1,2,3,4,5","1,2","The late version has a different mechanism to read bytes, it uses a Buffer to read them instead of a native method. A new control dependency (try-finally), and exception handling (beginAccess may throw exceptions) are introduced. The return value has been changed; it now always returns count (the number of bytes to read) instead of the result of the native_read call. The dependent API changed because it no longer uses native_read and uses Buffer methods (position, get) instead. The changes are categorized as 1,2,3,4,5.","There are Compatibility Issues of types 1 and 2 due to the different mechanisms used for reading bytes, and because exception handling has changed (now any exception from beginAccess or the Buffer read would not result in IndexOutOfBoundsException, but in whatever exceptions those methods throw). The method now always returns count, regardless of whether the read was successful or not, which is a different behavior from the early version that would return the result of native_read. Therefore, there is a Compatibility Issue caused by potential different return values or types as well as different exception handlings."
349,"<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>",26,27,,,,"{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds);
}","{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    GraphicBuffer graphicBuffer = bitmap.createGraphicBufferHandle();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER, graphicBuffer);
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}",1,"/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */
","/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */
",0,,,0,,,,,,,"1,4,5",1,There are multiple changes between the early and late implementations:,- The method 'TransitionUtils.createDrawableBitmap(d)' from the early version is now called with an additional argument 'imageView' in the late version (Dependent API changed).
350,<android.os.MemoryFile.MemoryInputStream: int available()>,26,27,,,,"{
    if (mOffset >= mLength) {
        return 0;
    }
    return mLength - mOffset;
}","{
    if (mOffset >= mSharedMemory.getSize()) {
        return 0;
    }
    return mSharedMemory.getSize() - mOffset;
}",1,,,0,[@Override],[@Override],0,,,,,,,5,1,"The return statement logic hasn't changed, but it now uses getSize() from mSharedMemory to determine the size instead of directly using mLength; this shows a change in the dependent API, so the change type is 5.","Although there are no direct changes to the return statements or control structures within the method, the source of the size value has changed from a direct member access (mLength) to a method call (mSharedMemory.getSize()). If the getSize() method behaves differently than the direct mLength access did, this could lead to a different return value. Therefore, the CI type is 1."
352,"<android.app.FragmentManagerImpl: void dispatchOnFragmentPreCreated(Fragment,Bundle,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentPreCreated(f, savedInstanceState, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentPreCreated(this, f, savedInstanceState);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentPreCreated(f, savedInstanceState, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentPreCreated(this, f, savedInstanceState);
        }
    }
}",1,,,0,,,0,,,,,,,1,0,The return statement that was previously triggered when 'mLifecycleCallbacks == null' has been removed.,"Although there is a code change (the removed return statement), it does not introduce a Compatibility Issue because the original implementation would exit early and do nothing when 'mLifecycleCallbacks == null', and the new implementation simply continues to the loop that would not run when 'mLifecycleCallbacks' is null due to the enhanced for-loop's behavior with empty collections. Therefore, the behavior of the API remains the same in both versions."
353,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForDevice(int,String,long,long)>",26,27,,,,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    Bucket bucket = null;
    NetworkStats stats = new NetworkStats(mContext, template, startTime, endTime);
    bucket = stats.getDeviceSummaryForNetwork();
    stats.close();
    return bucket;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    Bucket bucket = null;
    NetworkStats stats = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    bucket = stats.getDeviceSummaryForNetwork();
    stats.close();
    return bucket;
}",1,"/**
 * Query network usage statistics summaries. Result is summarised data usage for the whole
 * device. Result is a single Bucket aggregated over time, state, uid, tag, metered, and
 * roaming. This means the bucket's start and end timestamp are going to be the same as the
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid {@link NetworkStats.Bucket#UID_ALL},
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered {@link NetworkStats.Bucket#METERED_ALL},
 * and roaming {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result is summarised data usage for the whole
 * device. Result is a single Bucket aggregated over time, state, uid, tag, metered, and
 * roaming. This means the bucket's start and end timestamp are going to be the same as the
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid {@link NetworkStats.Bucket#UID_ALL},
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered {@link NetworkStats.Bucket#METERED_ALL},
 * and roaming {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",0,,,0,,,,,,,"4,5",0,"The constructor call for `NetworkStats` has an additional parameter, `mFlags`, in the late version. This is a change in how the `NetworkStats` object is instantiated, which is an other statement change, and since `NetworkStats` is a dependent API, this is also a dependent API changed, making the code change types 4 and 5.","This change does not necessarily lead to a Compatibility Issue. The additional parameter does not affect the control flow or the behavior of the `querySummaryForDevice` method itself. It only changes how the `NetworkStats` object is initialized. If the handling of `mFlags` inside the `NetworkStats` constructor maintains backward compatibility, then the final outcome in terms of the `Bucket` returned by `getDeviceSummaryForNetwork()` should remain unchanged. Therefore, there is no Compatibility Issue detected based on the provided information."
354,"<android.view.autofill.AutofillManager: void notifyViewExited(View,int)>",26,27,,,,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        ensureServiceClientAddedIfNeededLocked();
        if (mEnabled && mSessionId != NO_SESSION) {
            final AutofillId id = getAutofillId(view, virtualId);
            // Update focus on existing session.
            updateSessionLocked(id, null, null, ACTION_VIEW_EXITED, 0);
        }
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        ensureServiceClientAddedIfNeededLocked();
        if (mEnabled && isActiveLocked()) {
            final AutofillId id = getAutofillId(view, virtualId);
            // Update focus on existing session.
            updateSessionLocked(id, null, null, ACTION_VIEW_EXITED, 0);
        }
    }
}",1,"/**
 * Called when a virtual view that supports autofill is exited.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 */
","/**
 * Called when a virtual view that supports autofill is exited.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 */
",0,,,0,,,,,,,"3,5",0,"The condition inside the if statement has changed from ""mSessionId != NO_SESSION"" to ""isActiveLocked()"". This represents a control dependency change, and since the change is likely due to the redefinition of what it means for the session to be active, which suggests that the method ""isActiveLocked()"" is a new or modified method, we also consider this a dependent API changed. Hence, the code change types are 3,5.","There is no Compatibility Issue because although the condition checked in the if statement has changed, the outcome (either proceeding with updating the session or not doing anything) remains consistent with the early version API expectations in terms of behavior. The condition change is internal and abstracted from the caller, not affecting how the method is used or the results it produces from the caller's perspective; thus, no CI is detected."
356,"<android.view.View: void setFlags(int,int)>",26,27,,,,"{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    // If focusable is auto, update the FOCUSABLE bit.
    int focusableChangedByAuto = 0;
    if (((mViewFlags & FOCUSABLE_AUTO) != 0) && (changed & (FOCUSABLE_MASK | CLICKABLE)) != 0) {
        // Heuristic only takes into account whether view is clickable.
        final int newFocus;
        if ((mViewFlags & CLICKABLE) != 0) {
            newFocus = FOCUSABLE;
        } else {
            newFocus = NOT_FOCUSABLE;
        }
        mViewFlags = (mViewFlags & ~FOCUSABLE) | newFocus;
        focusableChangedByAuto = (old & FOCUSABLE) ^ (newFocus & FOCUSABLE);
        changed = (changed & ~FOCUSABLE) | focusableChangedByAuto;
    }
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null) {
                ViewRootImpl viewRootImpl = getViewRootImpl();
                if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) {
                    mParent.focusableViewAvailable(this);
                }
            }
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || mDefaultFocusHighlight != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}","{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    // If focusable is auto, update the FOCUSABLE bit.
    int focusableChangedByAuto = 0;
    if (((mViewFlags & FOCUSABLE_AUTO) != 0) && (changed & (FOCUSABLE_MASK | CLICKABLE)) != 0) {
        // Heuristic only takes into account whether view is clickable.
        final int newFocus;
        if ((mViewFlags & CLICKABLE) != 0) {
            newFocus = FOCUSABLE;
        } else {
            newFocus = NOT_FOCUSABLE;
        }
        mViewFlags = (mViewFlags & ~FOCUSABLE) | newFocus;
        focusableChangedByAuto = (old & FOCUSABLE) ^ (newFocus & FOCUSABLE);
        changed = (changed & ~FOCUSABLE) | focusableChangedByAuto;
    }
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
            if (mParent instanceof ViewGroup) {
                ((ViewGroup) mParent).clearFocusedInCluster();
            }
        } else if (((old & FOCUSABLE) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null) {
                ViewRootImpl viewRootImpl = getViewRootImpl();
                if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) {
                    mParent.focusableViewAvailable(this);
                }
            }
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus()) {
                clearFocus();
                if (mParent instanceof ViewGroup) {
                    ((ViewGroup) mParent).clearFocusedInCluster();
                }
            }
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus()) {
                    clearFocus();
                    if (mParent instanceof ViewGroup) {
                        ((ViewGroup) mParent).clearFocusedInCluster();
                    }
                }
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || mDefaultFocusHighlight != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",0,,,0,,,,,,,,,,
357,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,26,27,,,,"{
    enforceSealed();
    if (mSourceNode != null) {
        return AccessibilityNodeInfo.obtain(mSourceNode);
    }
    return null;
}","{
    enforceSealed();
    if ((mConnectionId == UNDEFINED) || (mSourceWindowId == AccessibilityWindowInfo.UNDEFINED_WINDOW_ID) || (AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) == AccessibilityNodeInfo.UNDEFINED_ITEM_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceNodeId, false, GET_SOURCE_PREFETCH_FLAGS, null);
}",1,"/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
","/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
",0,,,0,,,,,,,"3,4,5",1,"There are changes in control dependency with a new condition introduced that checks variable states before returning a value, other statements are added especially the way `AccessibilityNodeInfo` is obtained by calling different methods with different parameters, and dependent APIs have changed including `AccessibilityInteractionClient.getInstance()` and `AccessibilityInteractionClient.findAccessibilityNodeInfoByAccessibilityId()`. Hence, the code change type is 3,4,5.","Since the late version may not return an `AccessibilityNodeInfo` object in cases where the early version would, and vice versa, due to changes in the conditions checked and how the object is obtained, this represents a potential Compatibility Issue caused by potentially returning different values. The CI type is 1."
358,<android.hardware.camera2.impl.CameraCaptureSessionImpl.AbortDrainListener: void onDrained()>,26,27,,,,"{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onAbortDrained"");
    synchronized (CameraCaptureSessionImpl.this) {
        // as we won't get state updates any more anyway.
        if (mSkipUnconfigure) {
            return;
        }
        mIdleDrainer.beginDrain();
    }
}","{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onAbortDrained"");
    synchronized (mDeviceImpl.mInterfaceLock) {
        // as we won't get state updates any more anyway.
        if (mSkipUnconfigure) {
            return;
        }
        mIdleDrainer.beginDrain();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The synchronized block has changed to lock on a different object (`CameraCaptureSessionImpl.this` to `mDeviceImpl.mInterfaceLock`), so the code change type is 4.","The change in the object being locked on (`CameraCaptureSessionImpl` versus `mDeviceImpl.mInterfaceLock`) does not in itself cause a change in the behavior of the method as far as returning different values or throwing different exceptions. It might affect the thread-safety of the method when accessed from multiple threads, but this lock change alone does not lead to a different behavior from the method itself, as the method's return values and exceptions thrown remain the same. Hence, there is no Compatibility Issue."
359,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,26,27,,,,"{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
            return HAL_DATASPACE_DEPTH;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}","{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
        case ImageFormat.RAW_DEPTH:
            return HAL_DATASPACE_DEPTH;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}",1,"/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
","/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
",0,,,0,,,,,,,"3,5",0,"The `switch` case block has added a new case (`ImageFormat.RAW_DEPTH`) that returns `HAL_DATASPACE_DEPTH`. This is a control dependency change and also a change regarding a dependent API (ImageFormat) as it now accepts another image format as an input. Therefore, the code change type is 3,5.","Even though a new case for `ImageFormat.RAW_DEPTH` is added to the switch statement, it will not lead to a compatibility issue because this addition will only affect images of that format, which were not handled previously. Thus, existing behavior for known formats remains unchanged, resulting in no compatibility issue, indicated as 0."
360,<android.bluetooth.BluetoothHealth: int getConnectionState(BluetoothDevice)>,26,27,,,,"{
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getHealthDeviceConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return STATE_DISCONNECTED;
}","{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getHealthDeviceConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return STATE_DISCONNECTED;
}",1,"/**
 * Get the current connection state of the profile.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter with the remote device. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param device Remote bluetooth device.
 * @return State of the profile connection. One of
 * {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
 * {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING}
 */
","/**
 * Get the current connection state of the profile.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter with the remote device. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param device Remote bluetooth device.
 * @return State of the profile connection. One of
 * {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
 * {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING}
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"The change is in the local variable assignment from `mService` to `service`, but the logic of the code remains the same, so the code change type is 4.","Since the actual behavior of the API hasn't changed—this is simply a local variable renaming within the method—the change does not affect the API's contract or its behavior when invoked. There is no Compatibility Issue, so the CI type is 0."
362,<android.view.accessibility.AccessibilityEvent: String toString()>,26,27,,,,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; ContentChangeTypes: "").append(mContentChangeTypes);
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        if (mSourceNode != null) {
            builder.append(""; mSourceNodeId: "").append(mSourceNode.getSourceNodeId());
        }
        for (int i = 0; i < getRecordCount(); i++) {
            final AccessibilityRecord record = getRecord(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; ContentChangeTypes: "").append(contentChangeTypesToString(mContentChangeTypes));
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; mSourceNodeId: "").append(mSourceNodeId);
        for (int i = 0; i < getRecordCount(); i++) {
            final AccessibilityRecord record = getRecord(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The changes consist of altering a method call (`contentChangeTypesToString(mContentChangeTypes)` instead of just `mContentChangeTypes`) and removing the conditional block that checks if `mSourceNode` is not null. These changes are not to a return statement, an exception handling statement, or a control statement, but are rather changes to how a value is appended to the StringBuilder, which is why the code change type is 4.","The behavior of the `toString()` method is not altered in such a manner that would lead to a compatibility issue, as the method will still return a String representation of the object, just with a different format. No new exceptions are thrown and no changes in method contracts are implicated, so the CI type is 0."
363,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",26,27,,,,"{
    checkPendingIntent(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}",1,"/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */
","/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */
",0,,,0,,,,,,,"2,3,5",2,"The change includes the replacement of the method 'checkPendingIntent' with 'checkPendingIntentNotNull' and there is a new exception handling statement for 'ServiceSpecificException'. This indicates a code change type of 2 (Exception handling statement changed), 3 (Control dependency changed considering the try-catch structure), and 5 (Dependent API changed due to the change in the method being called).","A new exception handling for 'ServiceSpecificException' has been added, which means the API can potentially throw a new type of exception in the late version, causing a compatibility issue of type 2 (Compatibility Issue caused by potential different exception handlings)."
366,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",26,27,,,,"{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        Log.d(TAG, ""onRestoreFile ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}","{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        Log.d(TAG, ""onRestoreFile ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        // And bring live SharedPreferences instances up to date
        reloadSharedPreferences();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change between the two versions is the addition of the reloadSharedPreferences() method call within the finally block. Therefore, the code change type is 4.","The addition of the reloadSharedPreferences() method call is unlikely to cause a compatibility issue regarding return values/types or exception handling. It is an internal operation that updates the live SharedPreferences instances to reflect any changes. Therefore, it doesn't affect the API's external behavior regarding value returned or exception thrown, so there is no compatibility issue."
367,<android.widget.TabWidget: void dispatchDraw(Canvas)>,26,27,,,,"{
    super.dispatchDraw(canvas);
    // Do nothing if there are no tabs.
    if (getTabCount() == 0)
        return;
    // do not draw the bottom strips.
    if (!mDrawBottomStrips) {
        // Skip drawing the bottom strips.
        return;
    }
    final View selectedChild = getChildTabViewAt(mSelectedTab);
    final Drawable leftStrip = mLeftStrip;
    final Drawable rightStrip = mRightStrip;
    leftStrip.setState(selectedChild.getDrawableState());
    rightStrip.setState(selectedChild.getDrawableState());
    if (mStripMoved) {
        final Rect bounds = mBounds;
        bounds.left = selectedChild.getLeft();
        bounds.right = selectedChild.getRight();
        final int myHeight = getHeight();
        leftStrip.setBounds(Math.min(0, bounds.left - leftStrip.getIntrinsicWidth()), myHeight - leftStrip.getIntrinsicHeight(), bounds.left, myHeight);
        rightStrip.setBounds(bounds.right, myHeight - rightStrip.getIntrinsicHeight(), Math.max(getWidth(), bounds.right + rightStrip.getIntrinsicWidth()), myHeight);
        mStripMoved = false;
    }
    leftStrip.draw(canvas);
    rightStrip.draw(canvas);
}","{
    super.dispatchDraw(canvas);
    // Do nothing if there are no tabs.
    if (getTabCount() == 0)
        return;
    // do not draw the bottom strips.
    if (!mDrawBottomStrips) {
        // Skip drawing the bottom strips.
        return;
    }
    final View selectedChild = getChildTabViewAt(mSelectedTab);
    final Drawable leftStrip = mLeftStrip;
    final Drawable rightStrip = mRightStrip;
    if (leftStrip != null) {
        leftStrip.setState(selectedChild.getDrawableState());
    }
    if (rightStrip != null) {
        rightStrip.setState(selectedChild.getDrawableState());
    }
    if (mStripMoved) {
        final Rect bounds = mBounds;
        bounds.left = selectedChild.getLeft();
        bounds.right = selectedChild.getRight();
        final int myHeight = getHeight();
        if (leftStrip != null) {
            leftStrip.setBounds(Math.min(0, bounds.left - leftStrip.getIntrinsicWidth()), myHeight - leftStrip.getIntrinsicHeight(), bounds.left, myHeight);
        }
        if (rightStrip != null) {
            rightStrip.setBounds(bounds.right, myHeight - rightStrip.getIntrinsicHeight(), Math.max(getWidth(), bounds.right + rightStrip.getIntrinsicWidth()), myHeight);
        }
        mStripMoved = false;
    }
    if (leftStrip != null) {
        leftStrip.draw(canvas);
    }
    if (rightStrip != null) {
        rightStrip.draw(canvas);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The code change includes adding null checks before invoking methods on `leftStrip` and `rightStrip`, which are control dependency changes (type 3) as well as other statement changes because of the added if statements (type 4).","There is no Compatibility Issue because the added null checks do not change the behavior of the existing code. They prevent potential NullPointerExceptions if `leftStrip` or `rightStrip` were null. Existing behavior when `leftStrip` or `rightStrip` are not null remains unchanged, so the code change would not lead to different return values, nor does it introduce different exceptions to be thrown or caught."
