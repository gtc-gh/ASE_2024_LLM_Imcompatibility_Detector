Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,"<android.webkit.WebView: boolean savePicture(Bundle,File)>",6,7,"<android.webkit.WebView: boolean savePicture(Bundle,File)>","<android.webkit.WebView: boolean savePicture(Bundle,File)>",0,"{
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    try {
        final FileOutputStream out = new FileOutputStream(dest);
        p.writeToStream(out);
        out.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (RuntimeException e) {
        e.printStackTrace();
    }
    if (dest.length() > 0) {
        b.putInt(""scrollX"", mScrollX);
        b.putInt(""scrollY"", mScrollY);
        b.putFloat(""scale"", mActualScale);
        if (mInZoomOverview) {
            b.putFloat(""lastScale"", mLastScale);
        }
        return true;
    }
    return false;
}","{
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    try {
        final FileOutputStream out = new FileOutputStream(dest);
        p.writeToStream(out);
        out.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (RuntimeException e) {
        e.printStackTrace();
    }
    if (dest.length() > 0) {
        b.putInt(""scrollX"", mScrollX);
        b.putInt(""scrollY"", mScrollY);
        b.putFloat(""scale"", mActualScale);
        b.putFloat(""textwrapScale"", mTextWrapScale);
        b.putBoolean(""overview"", mInZoomOverview);
        return true;
    }
    return false;
}",1,"/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 */
","/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"There are three extra method calls in the late version: b.putFloat(""textwrapScale"", mTextWrapScale), b.putBoolean(""overview"", mInZoomOverview). But the implementation of these methods is not given, so we can't classify them into 'Dependent API changed' category. Hence, the change falls into 'Other statement changed' category.","The saving behavior of the picture has been modified by changing the attributes saved in the Bundle object. As a result, the later version of the API may return a different result, thus leading to a potential change in return variable (value or type). Therefore, the CI is 'Compatibility Issue caused by potential different return values or types'."
2,<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View)>,6,7,<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View)>,<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View)>,0,"{
    final View target = root.findViewById(viewId);
    if (target != null && pendingIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                try {
                    // TODO: Unregister this handler if PendingIntent.FLAG_ONE_SHOT?
                    v.getContext().startIntentSender(pendingIntent.getIntentSender(), null, Intent.FLAG_ACTIVITY_NEW_TASK, Intent.FLAG_ACTIVITY_NEW_TASK, 0);
                } catch (IntentSender.SendIntentException e) {
                    android.util.Log.e(LOG_TAG, ""Cannot send pending intent: "", e);
                }
            }
        };
        target.setOnClickListener(listener);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target != null && pendingIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                Intent intent = new Intent();
                intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight()));
                try {
                    // TODO: Unregister this handler if PendingIntent.FLAG_ONE_SHOT?
                    v.getContext().startIntentSender(pendingIntent.getIntentSender(), intent, Intent.FLAG_ACTIVITY_NEW_TASK, Intent.FLAG_ACTIVITY_NEW_TASK, 0);
                } catch (IntentSender.SendIntentException e) {
                    android.util.Log.e(LOG_TAG, ""Cannot send pending intent: "", e);
                }
            }
        };
        target.setOnClickListener(listener);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is that there are few additional lines of code added in the 'onClick' method implementation without altering any current implementation. Hence, the change type is 4.","Despite the change in implementation, the new added codes do not affect the existing implementation and have not introduced any new return statements or exceptions in the late implementation, hence, there is no compatibility issue, Type 0."
3,<android.server.BluetoothService: String getProperty(String)>,6,7,<android.server.BluetoothService: String getProperty(String)>,<android.server.BluetoothService: String getProperty(String)>,0,"{
    if (!mAdapterProperties.isEmpty())
        return mAdapterProperties.get(name);
    getAllProperties();
    return mAdapterProperties.get(name);
}","{
    if (!isEnabledInternal())
        return null;
    return getPropertyInternal(name);
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The if condition changed its condition from !mAdapterProperties.isEmpty() to isNewEnabledInternal. This is a Control Dependency Change. Also, the methods called within the implementation have changed totally which refers to Other Statements Changed and Dependent API changed. Hence, the code change types are 1,4,5.","The implementation changes in the late version may return different results based on the new if condition and the new method called within the if condition. Therefore, the API potentially returns different values in the two versions and hence, the CI type is 1."
5,"<android.server.BluetoothService: boolean fetchRemoteUuids(String,ParcelUuid,IBluetoothCallback)>",6,7,"<android.server.BluetoothService: boolean fetchRemoteUuids(String,ParcelUuid,IBluetoothCallback)>","<android.server.BluetoothService: boolean fetchRemoteUuids(String,ParcelUuid,IBluetoothCallback)>",0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    RemoteService service = new RemoteService(address, uuid);
    if (uuid != null && mUuidCallbackTracker.get(service) != null) {
        // Do not add this callback for the uuid
        return false;
    }
    if (mUuidIntentTracker.contains(address)) {
        // Add this uuid onto the in-progress SDP query
        if (uuid != null) {
            mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
        }
        return true;
    }
    boolean ret;
    if (getBondState(address) == BluetoothDevice.BOND_BONDED) {
        String path = getObjectPathFromAddress(address);
        if (path == null)
            return false;
        // Use an empty string for the UUID pattern
        ret = discoverServicesNative(path, """");
    } else {
        ret = createDeviceNative(address);
    }
    mUuidIntentTracker.add(address);
    if (uuid != null) {
        mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
    }
    Message message = mHandler.obtainMessage(MESSAGE_UUID_INTENT);
    message.obj = address;
    mHandler.sendMessageDelayed(message, UUID_INTENT_DELAY);
    return ret;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    RemoteService service = new RemoteService(address, uuid);
    if (uuid != null && mUuidCallbackTracker.get(service) != null) {
        // Do not add this callback for the uuid
        return false;
    }
    if (mUuidIntentTracker.contains(address)) {
        // Add this uuid onto the in-progress SDP query
        if (uuid != null) {
            mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
        }
        return true;
    }
    boolean ret;
    if (getBondState(address) == BluetoothDevice.BOND_BONDED) {
        String path = getObjectPathFromAddress(address);
        if (path == null)
            return false;
        // Use an empty string for the UUID pattern
        ret = discoverServicesNative(path, """");
    } else {
        ret = createDeviceNative(address);
    }
    mUuidIntentTracker.add(address);
    if (uuid != null) {
        mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
    }
    Message message = mHandler.obtainMessage(MESSAGE_UUID_INTENT);
    message.obj = address;
    mHandler.sendMessageDelayed(message, UUID_INTENT_DELAY);
    return ret;
}",1,"/**
 * Connect and fetch new UUID's using SDP.
 * The UUID's found are broadcast as intents.
 * Optionally takes a uuid and callback to fetch the RFCOMM channel for the
 * a given uuid.
 * TODO: Don't wait UUID_INTENT_DELAY to broadcast UUID intents on success
 * TODO: Don't wait UUID_INTENT_DELAY to handle the failure case for
 * callback and broadcast intents.
 */
","/**
 * Connect and fetch new UUID's using SDP.
 * The UUID's found are broadcast as intents.
 * Optionally takes a uuid and callback to fetch the RFCOMM channel for the
 * a given uuid.
 * TODO: Don't wait UUID_INTENT_DELAY to broadcast UUID intents on success
 * TODO: Don't wait UUID_INTENT_DELAY to handle the failure case for
 * callback and broadcast intents.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"A new return statement 'return false;' has been introduced when 'isEnabledInternal()' method returns false. Therefore, the code change type is 1.","The newly introduced return statement could lead to a different behavior because if 'isEnabledInternal()' returns false in the new version, the API returns false immediately and the rest of the code will not be executed. Therefore, the CI type is 1."
6,<android.server.BluetoothService.BondState: void loadBondState()>,6,7,<android.server.BluetoothService.BondState: void loadBondState()>,<android.server.BluetoothService.BondState: void loadBondState()>,0,"{
    if (mBluetoothState != BluetoothAdapter.STATE_TURNING_ON) {
        return;
    }
    String[] bonds = null;
    String val = getProperty(""Devices"");
    if (val != null) {
        bonds = val.split("","");
    }
    if (bonds == null) {
        return;
    }
    mState.clear();
    if (DBG)
        log(""found "" + bonds.length + "" bonded devices"");
    for (String device : bonds) {
        mState.put(getAddressFromObjectPath(device).toUpperCase(), BluetoothDevice.BOND_BONDED);
    }
}","{
    if (mBluetoothState != BluetoothAdapter.STATE_TURNING_ON) {
        return;
    }
    String[] bonds = null;
    String val = getPropertyInternal(""Devices"");
    if (val != null) {
        bonds = val.split("","");
    }
    if (bonds == null) {
        return;
    }
    mState.clear();
    if (DBG)
        log(""found "" + bonds.length + "" bonded devices"");
    for (String device : bonds) {
        mState.put(getAddressFromObjectPath(device).toUpperCase(), BluetoothDevice.BOND_BONDED);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method that the API relies on has changed from getProperty(""Devices"") to getPropertyInternal(""Devices""), so the code change type is 5.","Even though the dependent API has changed, it does not lead to a change in the return values of our method or potentially result in throwing different exceptions. Therefore, no Compatibility Issue (CI) exists, and the CI type is 0."
7,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",6,7,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    DragState[] ds;
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    float dx = ds[0].mX - event.getX();
                    float dy = ds[0].mY - event.getY();
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    scrollTo(widget, layout, nx, ny);
                    widget.cancelLongPress();
                    return true;
                }
            }
    }
    return false;
}","{
    DragState[] ds;
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    float dx = ds[0].mX - event.getX();
                    float dy = ds[0].mY - event.getY();
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}",1,"/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
","/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"In the late version 'oldX' and 'oldY' variables were inserted right before the 'scrollTo' method call and after the 'scrollTo' call, a new condition was inserted to cancel the long press. Hence, the code change type is 3.","The changes do not modify the API's behaviour in terms of return type, return value, or thrown exception under the same circumstances, therefore no compatibility issue is detected."
8,<android.server.BluetoothService: boolean cancelBondProcess(String)>,6,7,<android.server.BluetoothService: boolean cancelBondProcess(String)>,<android.server.BluetoothService: boolean cancelBondProcess(String)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    address = address.toUpperCase();
    if (mBondState.getBondState(address) != BluetoothDevice.BOND_BONDING) {
        return false;
    }
    mBondState.setBondState(address, BluetoothDevice.BOND_NONE, BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
    cancelDeviceCreationNative(address);
    return true;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    address = address.toUpperCase();
    if (mBondState.getBondState(address) != BluetoothDevice.BOND_BONDING) {
        return false;
    }
    mBondState.setBondState(address, BluetoothDevice.BOND_NONE, BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
    cancelDeviceCreationNative(address);
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition 'isEnabledInternal()' has been added, this change represents a change in control dependency (3). Also a method call to isEnabledInternal() has been introduced which is not return or exception-handling related, it is an ""other statement changed"" (4).","The addition of 'isEnabledInternal()' returns a boolean, if it returns false, then the API return value is impacted, thus a compatibility issue (1) occurs."
9,<android.webkit.WebView: void onDraw(Canvas)>,6,7,<android.webkit.WebView: void onDraw(Canvas)>,<android.webkit.WebView: void onDraw(Canvas)>,0,"{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    int saveCount = canvas.save();
    if (mTitleBar != null) {
        canvas.translate(0, (int) mTitleBar.getHeight());
    }
    // Update the buttons in the picture, so when we draw the picture
    // to the screen, they are in the correct state.
    // Tell the native side if user is a) touching the screen,
    // b) pressing the trackball down, or c) pressing the enter key
    // If the cursor is on a button, we need to draw it in the pressed
    // state.
    // If mNativeClass is 0, we should not reach here, so we do not
    // need to check it again.
    nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode == TOUCH_SHORTPRESS_START_MODE || mTrackballDown || mGotCenterDown, false);
    drawCoreAndCursorRing(canvas, mBackgroundColor, mDrawCursorRing);
    canvas.restoreToCount(saveCount);
    // Now draw the shadow.
    if (mTitleBar != null) {
        int y = mScrollY + getVisibleTitleHeight();
        int height = (int) (5f * getContext().getResources().getDisplayMetrics().density);
        mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height);
        mTitleShadow.draw(canvas);
    }
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
}","{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    int saveCount = canvas.save();
    if (mTitleBar != null) {
        canvas.translate(0, (int) mTitleBar.getHeight());
    }
    if (mDragTrackerHandler == null || !mDragTrackerHandler.draw(canvas)) {
        drawContent(canvas);
    }
    canvas.restoreToCount(saveCount);
    // Now draw the shadow.
    if (mTitleBar != null) {
        int y = mScrollY + getVisibleTitleHeight();
        int height = (int) (5f * getContext().getResources().getDisplayMetrics().density);
        mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height);
        mTitleShadow.draw(canvas);
    }
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,"There are changes in the control structures, as well as changes to method calls and a removal of return statement, therefore the changes are in the categories 1,3,4.","Although there is change in method calls and a return statement removal, these changes do not alter the API's behavior with respect to its return values or thrown exceptions, hence no compatibility issues exist."
10,<android.server.BluetoothService: int getScanMode()>,6,7,<android.server.BluetoothService: int getScanMode()>,<android.server.BluetoothService: int getScanMode()>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabled())
        return BluetoothAdapter.SCAN_MODE_NONE;
    boolean pairable = getProperty(""Pairable"").equals(""true"");
    boolean discoverable = getProperty(""Discoverable"").equals(""true"");
    return bluezStringToScanMode(pairable, discoverable);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return BluetoothAdapter.SCAN_MODE_NONE;
    boolean pairable = getProperty(""Pairable"").equals(""true"");
    boolean discoverable = getProperty(""Discoverable"").equals(""true"");
    return bluezStringToScanMode(pairable, discoverable);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method isEnabled() in the first if condition has been replaced with isEnabledInternal(). Therefore, the types of changes are 1 and 5.","Since the isEnabled() method has been replaced by isEnabledInternal(), the return of SCAN_MODE_NONE may vary depending on the conditions in the isEnabledInternal() method. Therefore, it leads to compatibility issue of type 1."
12,<android.server.BluetoothService: boolean cancelDiscovery()>,6,7,<android.server.BluetoothService: boolean cancelDiscovery()>,<android.server.BluetoothService: boolean cancelDiscovery()>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    return stopDiscoveryNative();
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    return stopDiscoveryNative();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The code change introduces a new condition check in the late version in which if the isEnabledInternal() returns false, it will return false immediately, which is a return statement change and a control dependency change, so the change type is 1,3.","The change of return statement, due to the introduction of a new condition check, will make the API potentially return a different value, so the CI type is 1."
13,"<android.server.BluetoothService: boolean setPairingConfirmation(String,boolean)>",6,7,"<android.server.BluetoothService: boolean setPairingConfirmation(String,boolean)>","<android.server.BluetoothService: boolean setPairingConfirmation(String,boolean)>",0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    address = address.toUpperCase();
    Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
    if (data == null) {
        Log.w(TAG, ""setPasskey("" + address + "") called but no native data available, "" + ""ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device"" + "" or by bluez.\n"");
        return false;
    }
    return setPairingConfirmationNative(address, confirm, data.intValue());
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    address = address.toUpperCase();
    Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
    if (data == null) {
        Log.w(TAG, ""setPasskey("" + address + "") called but no native data available, "" + ""ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device"" + "" or by bluez.\n"");
        return false;
    }
    return setPairingConfirmationNative(address, confirm, data.intValue());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency has changed. A new 'if' statement 'if (!isEnabledInternal()) return false;' has been added in the late version, so the pred_change is 3.","The new 'if' statement will possibly lead the method to return false early in some cases, implying that the method could potentially return a different value between the two continuous versions. So, pred_CI is 1."
14,<android.widget.TextView: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,6,7,<android.widget.TextView: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,<android.widget.TextView: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,0,"{
    boolean isPassword = (mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD);
    if (!isPassword) {
        CharSequence text = getText();
        if (TextUtils.isEmpty(text)) {
            text = getHint();
        }
        if (!TextUtils.isEmpty(text)) {
            if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
                text = text.subSequence(0, AccessibilityEvent.MAX_TEXT_LENGTH + 1);
            }
            event.getText().add(text);
        }
    } else {
        event.setPassword(isPassword);
    }
    return false;
}","{
    final boolean isPassword = isPasswordInputType(mInputType);
    if (!isPassword) {
        CharSequence text = getText();
        if (TextUtils.isEmpty(text)) {
            text = getHint();
        }
        if (!TextUtils.isEmpty(text)) {
            if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
                text = text.subSequence(0, AccessibilityEvent.MAX_TEXT_LENGTH + 1);
            }
            event.getText().add(text);
        }
    } else {
        event.setPassword(isPassword);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The way of how 'isPassword' value calculated has changed from directly calculate bit operation to call 'isPasswordInputType(mInputType)', so the change type is 3,5.","Although the calculation of 'isPassword' value changed, it does not affect the return value from this method. Therefore, there's no Compatibility Issue in this change."
15,<android.view.View: void buildDrawingCache(boolean)>,6,7,<android.view.View: void buildDrawingCache(boolean)>,<android.view.View: void buildDrawingCache(boolean)>,0,"{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? (mDrawingCache == null || mDrawingCache.get() == null) : (mUnscaledDrawingCache == null || mUnscaledDrawingCache.get() == null))) {
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.BUILD_CACHE);
        }
        if (Config.DEBUG && ViewDebug.profileDrawing) {
            EventLog.writeEvent(60002, hashCode());
        }
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean translucentWindow = attachInfo != null && attachInfo.mTranslucentWindow;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !translucentWindow ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? (mDrawingCache == null ? null : mDrawingCache.get()) : (mUnscaledDrawingCache == null ? null : mUnscaledDrawingCache.get());
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_4444;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = translucentWindow ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = new SoftReference<Bitmap>(bitmap);
                } else {
                    mUnscaledDrawingCache = new SoftReference<Bitmap>(bitmap);
                }
                if (opaque && translucentWindow)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            if (ViewDebug.TRACE_HIERARCHY) {
                ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
            }
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
        mPrivateFlags |= DRAWING_CACHE_VALID;
    }
}","{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? (mDrawingCache == null || mDrawingCache.get() == null) : (mUnscaledDrawingCache == null || mUnscaledDrawingCache.get() == null))) {
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.BUILD_CACHE);
        }
        if (Config.DEBUG && ViewDebug.profileDrawing) {
            EventLog.writeEvent(60002, hashCode());
        }
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean translucentWindow = attachInfo != null && attachInfo.mTranslucentWindow;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !translucentWindow ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? (mDrawingCache == null ? null : mDrawingCache.get()) : (mUnscaledDrawingCache == null ? null : mUnscaledDrawingCache.get());
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_4444;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = translucentWindow ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = new SoftReference<Bitmap>(bitmap);
                } else {
                    mUnscaledDrawingCache = new SoftReference<Bitmap>(bitmap);
                }
                if (opaque && translucentWindow)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        mPrivateFlags |= DRAWING_CACHE_VALID;
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            if (ViewDebug.TRACE_HIERARCHY) {
                ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
            }
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,No difference is shown in the two version implementations of the method. The method stays the same across both versions without any change.,There won't be any Compatibility Issues since there are no changes between the two versions.
16,<android.server.BluetoothService: String[] getRemoteDeviceProperties(String)>,6,7,<android.server.BluetoothService: String[] getRemoteDeviceProperties(String)>,<android.server.BluetoothService: String[] getRemoteDeviceProperties(String)>,0,"{
    String objectPath = getObjectPathFromAddress(address);
    return (String[]) getDevicePropertiesNative(objectPath);
}","{
    if (!isEnabledInternal())
        return null;
    String objectPath = getObjectPathFromAddress(address);
    return (String[]) getDevicePropertiesNative(objectPath);
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,A new control statement 'if (!isEnabledInternal()) return null;' has been introduced into the late version. So the code change types include '3) Control dependency changed' and '4) Other statement changed'.,"The additional control statement 'if (!isEnabledInternal()) return null;' could make the API potentially return a null value in the late version if 'isEnabledInternal()' returns false while this never happens in the early version. Therefore, the API has potential to return the different value, leading to '1) Compatibility Issue caused by potential different return values or types'."
17,<android.content.Intent: String toUri(int)>,6,7,<android.content.Intent: String toUri(int)>,<android.content.Intent: String toUri(int)>,0,"{
    StringBuilder uri = new StringBuilder(128);
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '-') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    uri.append(""#Intent;"");
    if (scheme != null) {
        uri.append(""scheme="").append(scheme).append(';');
    }
    if (mAction != null) {
        uri.append(""action="").append(Uri.encode(mAction)).append(';');
    }
    if (mCategories != null) {
        for (String category : mCategories) {
            uri.append(""category="").append(Uri.encode(category)).append(';');
        }
    }
    if (mType != null) {
        uri.append(""type="").append(Uri.encode(mType, ""/"")).append(';');
    }
    if (mFlags != 0) {
        uri.append(""launchFlags=0x"").append(Integer.toHexString(mFlags)).append(';');
    }
    if (mPackage != null) {
        uri.append(""package="").append(Uri.encode(mPackage)).append(';');
    }
    if (mComponent != null) {
        uri.append(""component="").append(Uri.encode(mComponent.flattenToShortString(), ""/"")).append(';');
    }
    if (mExtras != null) {
        for (String key : mExtras.keySet()) {
            final Object value = mExtras.get(key);
            char entryType = value instanceof String ? 'S' : value instanceof Boolean ? 'B' : value instanceof Byte ? 'b' : value instanceof Character ? 'c' : value instanceof Double ? 'd' : value instanceof Float ? 'f' : value instanceof Integer ? 'i' : value instanceof Long ? 'l' : value instanceof Short ? 's' : '\0';
            if (entryType != '\0') {
                uri.append(entryType);
                uri.append('.');
                uri.append(Uri.encode(key));
                uri.append('=');
                uri.append(Uri.encode(value.toString()));
                uri.append(';');
            }
        }
    }
    uri.append(""end"");
    return uri.toString();
}","{
    StringBuilder uri = new StringBuilder(128);
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '-') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    uri.append(""#Intent;"");
    if (scheme != null) {
        uri.append(""scheme="").append(scheme).append(';');
    }
    if (mAction != null) {
        uri.append(""action="").append(Uri.encode(mAction)).append(';');
    }
    if (mCategories != null) {
        for (String category : mCategories) {
            uri.append(""category="").append(Uri.encode(category)).append(';');
        }
    }
    if (mType != null) {
        uri.append(""type="").append(Uri.encode(mType, ""/"")).append(';');
    }
    if (mFlags != 0) {
        uri.append(""launchFlags=0x"").append(Integer.toHexString(mFlags)).append(';');
    }
    if (mPackage != null) {
        uri.append(""package="").append(Uri.encode(mPackage)).append(';');
    }
    if (mComponent != null) {
        uri.append(""component="").append(Uri.encode(mComponent.flattenToShortString(), ""/"")).append(';');
    }
    if (mSourceBounds != null) {
        uri.append(""sourceBounds="").append(Uri.encode(mSourceBounds.flattenToString())).append(';');
    }
    if (mExtras != null) {
        for (String key : mExtras.keySet()) {
            final Object value = mExtras.get(key);
            char entryType = value instanceof String ? 'S' : value instanceof Boolean ? 'B' : value instanceof Byte ? 'b' : value instanceof Character ? 'c' : value instanceof Double ? 'd' : value instanceof Float ? 'f' : value instanceof Integer ? 'i' : value instanceof Long ? 'l' : value instanceof Short ? 's' : '\0';
            if (entryType != '\0') {
                uri.append(entryType);
                uri.append('.');
                uri.append(Uri.encode(key));
                uri.append('=');
                uri.append(Uri.encode(value.toString()));
                uri.append(';');
            }
        }
    }
    uri.append(""end"");
    return uri.toString();
}",1,"/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
","/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"A new condition has been introduced in the late implementation (if (mSourceBounds != null)), and so an additional string is added to the stringBuilder, so the code change type is 4.","As a new condition has been introduced and based on its condition another string appended to the uri in late implementation, the return type, which is the 'uri.toString()', can be different than the early implementation, so the CI type is 1."
18,<android.server.BluetoothService: boolean removeBond(String)>,6,7,<android.server.BluetoothService: boolean removeBond(String)>,<android.server.BluetoothService: boolean removeBond(String)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    return removeDeviceNative(getObjectPathFromAddress(address));
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    return removeDeviceNative(getObjectPathFromAddress(address));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new 'if' statement (control dependency) 'if (!isEnabledInternal()) return false;' has been introduced, so the code change type includes 3. Also, a method 'isEnabledInternal()' (other statement) has been added that was not present in early version, so it is also of the type 4.","The introduction of a new 'if' statement can potentially return a different value (false) if the condition 'isEnabledInternal()' is met. Therefore, the change can cause the Compatibility Issue type 1, because the API may return a different value."
19,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,6,7,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
        return false;
    }
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode);
    }
    int action = ev.getAction();
    float x = ev.getX();
    float y = ev.getY();
    long eventTime = ev.getEventTime();
    // getViewWidth(). Same applied to the height.
    if (x > getViewWidth() - 1) {
        x = getViewWidth() - 1;
    }
    if (y > getViewHeightWithTitle() - 1) {
        y = getViewHeightWithTitle() - 1;
    }
    // pass the touch events from UI thread to WebCore thread
    if (mForwardTouchEvents && (action != MotionEvent.ACTION_MOVE || eventTime - mLastSentTouchTime > TOUCH_SENT_INTERVAL)) {
        WebViewCore.TouchEventData ted = new WebViewCore.TouchEventData();
        ted.mAction = action;
        ted.mX = viewToContentX((int) x + mScrollX);
        ted.mY = viewToContentY((int) y + mScrollY);
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
        mLastSentTouchTime = eventTime;
    }
    int deltaX = (int) (mLastTouchX - x);
    int deltaY = (int) (mLastTouchY - y);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                mPreventDrag = PREVENT_DRAG_NO;
                if (!mScroller.isFinished()) {
                    // stop the current scroll animation, but if this is
                    // the start of a fling, allow it to add to the current
                    // fling's velocity
                    mScroller.abortAnimation();
                    mTouchMode = TOUCH_DRAG_START_MODE;
                    mPrivateHandler.removeMessages(RESUME_WEBCORE_UPDATE);
                } else if (mShiftIsPressed) {
                    mSelectX = mScrollX + (int) x;
                    mSelectY = mScrollY + (int) y;
                    mTouchMode = TOUCH_SELECT_MODE;
                    if (DebugFlags.WEB_VIEW) {
                        Log.v(LOGTAG, ""select="" + mSelectX + "","" + mSelectY);
                    }
                    nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), false);
                    mTouchSelection = mExtendSelection = true;
                } else if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
                    mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
                    if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
                        mTouchMode = TOUCH_DOUBLE_TAP_MODE;
                    } else {
                        // commit the short press action for the previous tap
                        doShortPress();
                    // continue, mTouchMode should be still TOUCH_INIT_MODE
                    }
                } else {
                    mTouchMode = TOUCH_INIT_MODE;
                    mPreventDrag = mForwardTouchEvents ? PREVENT_DRAG_MAYBE_YES : PREVENT_DRAG_NO;
                    mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
                    if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
                        EventLog.writeEvent(EVENT_LOG_DOUBLE_TAP_DURATION, (eventTime - mLastTouchUpTime), eventTime);
                    }
                }
                // Trigger the link
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(SWITCH_TO_SHORTPRESS), TAP_TIMEOUT);
                }
                // Remember where the motion event started
                mLastTouchX = x;
                mLastTouchY = y;
                mLastTouchTime = eventTime;
                mVelocityTracker = VelocityTracker.obtain();
                mSnapScrollMode = SNAP_NONE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                if (mTouchMode == TOUCH_DONE_MODE) {
                    // no dragging during scroll zoom animation
                    break;
                }
                mVelocityTracker.addMovement(ev);
                if (mTouchMode != TOUCH_DRAG_MODE) {
                    if (mTouchMode == TOUCH_SELECT_MODE) {
                        mSelectX = mScrollX + (int) x;
                        mSelectY = mScrollY + (int) y;
                        if (DebugFlags.WEB_VIEW) {
                            Log.v(LOGTAG, ""xtend="" + mSelectX + "","" + mSelectY);
                        }
                        nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), true);
                        invalidate();
                        break;
                    }
                    if ((deltaX * deltaX + deltaY * deltaY) < mTouchSlopSquare) {
                        break;
                    }
                    if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                        // track mLastTouchTime as we may need to do fling at
                        // ACTION_UP
                        mLastTouchTime = eventTime;
                        break;
                    }
                    if (mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                    } else if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                    }
                    // if it starts nearly horizontal or vertical, enforce it
                    int ax = Math.abs(deltaX);
                    int ay = Math.abs(deltaY);
                    if (ax > MAX_SLOPE_FOR_DIAG * ay) {
                        mSnapScrollMode = SNAP_X;
                        mSnapPositive = deltaX > 0;
                    } else if (ay > MAX_SLOPE_FOR_DIAG * ax) {
                        mSnapScrollMode = SNAP_Y;
                        mSnapPositive = deltaY > 0;
                    }
                    mTouchMode = TOUCH_DRAG_MODE;
                    WebViewCore.pauseUpdate(mWebViewCore);
                    if (!mDragFromTextInput) {
                        nativeHideCursor();
                    }
                    WebSettings settings = getSettings();
                    if (settings.supportZoom() && settings.getBuiltInZoomControls() && !mZoomButtonsController.isVisible() && mMinZoomScale < mMaxZoomScale) {
                        mZoomButtonsController.setVisible(true);
                        int count = settings.getDoubleTapToastCount();
                        if (mInZoomOverview && count > 0) {
                            settings.setDoubleTapToastCount(--count);
                            Toast.makeText(mContext, com.android.internal.R.string.double_tap_toast, Toast.LENGTH_LONG).show();
                        }
                    }
                }
                // do pan
                int newScrollX = pinLocX(mScrollX + deltaX);
                deltaX = newScrollX - mScrollX;
                int newScrollY = pinLocY(mScrollY + deltaY);
                deltaY = newScrollY - mScrollY;
                boolean done = false;
                if (deltaX == 0 && deltaY == 0) {
                    done = true;
                } else {
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
                        int ax = Math.abs(deltaX);
                        int ay = Math.abs(deltaY);
                        if (mSnapScrollMode == SNAP_X) {
                            // radical change means getting out of snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ((mSnapPositive && deltaX < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaX > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_X_LOCK;
                            }
                        } else {
                            // radical change means getting out of snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ay > MAX_SLOPE_FOR_DIAG * ax) && ((mSnapPositive && deltaY < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaY > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_Y_LOCK;
                            }
                        }
                    }
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_X_LOCK) {
                        if (deltaX == 0) {
                            // keep the scrollbar on the screen even there is no
                            // scroll
                            awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                        } else {
                            scrollBy(deltaX, 0);
                        }
                        mLastTouchX = x;
                    } else if (mSnapScrollMode == SNAP_Y || mSnapScrollMode == SNAP_Y_LOCK) {
                        if (deltaY == 0) {
                            // keep the scrollbar on the screen even there is no
                            // scroll
                            awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                        } else {
                            scrollBy(0, deltaY);
                        }
                        mLastTouchY = y;
                    } else {
                        scrollBy(deltaX, deltaY);
                        mLastTouchX = x;
                        mLastTouchY = y;
                    }
                    mLastTouchTime = eventTime;
                    mUserScroll = true;
                }
                if (!getSettings().getBuiltInZoomControls()) {
                    boolean showPlusMinus = mMinZoomScale < mMaxZoomScale;
                    if (mZoomControls != null && showPlusMinus) {
                        if (mZoomControls.getVisibility() == View.VISIBLE) {
                            mPrivateHandler.removeCallbacks(mZoomControlRunnable);
                        } else {
                            mZoomControls.show(showPlusMinus, false);
                        }
                        mPrivateHandler.postDelayed(mZoomControlRunnable, ZOOM_CONTROLS_TIMEOUT);
                    }
                }
                if (done) {
                    // keep the scrollbar on the screen even there is no scroll
                    awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                    // view space
                    return false;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                mLastTouchUpTime = eventTime;
                switch(mTouchMode) {
                    case // double tap
                    TOUCH_DOUBLE_TAP_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mTouchMode = TOUCH_DONE_MODE;
                        doDoubleTap();
                        break;
                    case TOUCH_SELECT_MODE:
                        commitCopy();
                        mTouchSelection = false;
                        break;
                    // tap
                    case TOUCH_INIT_MODE:
                    case TOUCH_SHORTPRESS_START_MODE:
                    case TOUCH_SHORTPRESS_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if ((deltaX * deltaX + deltaY * deltaY) > mTouchSlopSquare) {
                            Log.w(LOGTAG, ""Miss a drag as we are waiting for"" + "" WebCore's response for touch down."");
                            if (computeHorizontalScrollExtent() < computeHorizontalScrollRange() || computeVerticalScrollExtent() < computeVerticalScrollRange()) {
                                // we will not rewrite drag code here, but we
                                // will try fling if it applies.
                                WebViewCore.pauseUpdate(mWebViewCore);
                            // fall through to TOUCH_DRAG_MODE
                            } else {
                                break;
                            }
                        } else {
                            if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                                // if mPreventDrag is not confirmed, treat it as
                                // no so that it won't block tap or double tap.
                                mPreventDrag = PREVENT_DRAG_NO;
                            }
                            if (mPreventDrag == PREVENT_DRAG_NO) {
                                if (mTouchMode == TOUCH_INIT_MODE) {
                                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(RELEASE_SINGLE_TAP), ViewConfiguration.getDoubleTapTimeout());
                                } else {
                                    mTouchMode = TOUCH_DONE_MODE;
                                    doShortPress();
                                }
                            }
                            break;
                        }
                    case TOUCH_DRAG_MODE:
                        // redraw in high-quality, as we're done dragging
                        invalidate();
                        // up, we don't want to do a fling
                        if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
                            mVelocityTracker.addMovement(ev);
                            doFling();
                            break;
                        }
                        mLastVelocity = 0;
                        WebViewCore.resumeUpdate(mWebViewCore);
                        break;
                    case TOUCH_DRAG_START_MODE:
                    case TOUCH_DONE_MODE:
                        // do nothing
                        break;
                }
                // mode in the drawing code
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                // mode in the drawing code
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (mTouchMode == TOUCH_DRAG_MODE) {
                    WebViewCore.resumeUpdate(mWebViewCore);
                }
                mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                mTouchMode = TOUCH_DONE_MODE;
                nativeHideCursor();
                break;
            }
    }
    return true;
}","{
    if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
        return false;
    }
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode);
    }
    int action;
    float x, y;
    long eventTime = ev.getEventTime();
    // events later.
    if (mSupportMultiTouch && mMinZoomScale < mMaxZoomScale && ev.getPointerCount() > 1) {
        mScaleDetector.onTouchEvent(ev);
        if (mScaleDetector.isInProgress()) {
            mLastTouchTime = eventTime;
            return true;
        }
        x = mScaleDetector.getFocusX();
        y = mScaleDetector.getFocusY();
        action = ev.getAction() & MotionEvent.ACTION_MASK;
        if (action == MotionEvent.ACTION_POINTER_DOWN) {
            cancelTouch();
            action = MotionEvent.ACTION_DOWN;
        } else if (action == MotionEvent.ACTION_POINTER_UP) {
            // set mLastTouchX/Y to the remaining point
            mLastTouchX = x;
            mLastTouchY = y;
        } else if (action == MotionEvent.ACTION_MOVE) {
            // negative x or y indicate it is on the edge, skip it.
            if (x < 0 || y < 0) {
                return true;
            }
        }
    } else {
        action = ev.getAction();
        x = ev.getX();
        y = ev.getY();
    }
    // getViewWidth(). Same applied to the height.
    if (x > getViewWidth() - 1) {
        x = getViewWidth() - 1;
    }
    if (y > getViewHeightWithTitle() - 1) {
        y = getViewHeightWithTitle() - 1;
    }
    // pass the touch events from UI thread to WebCore thread
    if (mForwardTouchEvents && (action != MotionEvent.ACTION_MOVE || eventTime - mLastSentTouchTime > TOUCH_SENT_INTERVAL)) {
        WebViewCore.TouchEventData ted = new WebViewCore.TouchEventData();
        ted.mAction = action;
        ted.mX = viewToContentX((int) x + mScrollX);
        ted.mY = viewToContentY((int) y + mScrollY);
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
        mLastSentTouchTime = eventTime;
    }
    int deltaX = (int) (mLastTouchX - x);
    int deltaY = (int) (mLastTouchY - y);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                mPreventDrag = PREVENT_DRAG_NO;
                if (!mScroller.isFinished()) {
                    // stop the current scroll animation, but if this is
                    // the start of a fling, allow it to add to the current
                    // fling's velocity
                    mScroller.abortAnimation();
                    mTouchMode = TOUCH_DRAG_START_MODE;
                    mPrivateHandler.removeMessages(RESUME_WEBCORE_UPDATE);
                } else if (mShiftIsPressed) {
                    mSelectX = mScrollX + (int) x;
                    mSelectY = mScrollY + (int) y;
                    mTouchMode = TOUCH_SELECT_MODE;
                    if (DebugFlags.WEB_VIEW) {
                        Log.v(LOGTAG, ""select="" + mSelectX + "","" + mSelectY);
                    }
                    nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), false);
                    mTouchSelection = mExtendSelection = true;
                } else if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
                    mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
                    if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
                        mTouchMode = TOUCH_DOUBLE_TAP_MODE;
                    } else {
                        // commit the short press action for the previous tap
                        doShortPress();
                    // continue, mTouchMode should be still TOUCH_INIT_MODE
                    }
                } else {
                    mPreviewZoomOnly = false;
                    mTouchMode = TOUCH_INIT_MODE;
                    mPreventDrag = mForwardTouchEvents ? PREVENT_DRAG_MAYBE_YES : PREVENT_DRAG_NO;
                    mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
                    if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
                        EventLog.writeEvent(EVENT_LOG_DOUBLE_TAP_DURATION, (eventTime - mLastTouchUpTime), eventTime);
                    }
                }
                // Trigger the link
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(SWITCH_TO_SHORTPRESS), TAP_TIMEOUT);
                }
                // Remember where the motion event started
                startTouch(x, y, eventTime);
                if (mDragTracker != null) {
                    mDragTrackerHandler = new DragTrackerHandler(x, y, mDragTracker);
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                if (mTouchMode == TOUCH_DONE_MODE) {
                    // no dragging during scroll zoom animation
                    break;
                }
                mVelocityTracker.addMovement(ev);
                if (mTouchMode != TOUCH_DRAG_MODE) {
                    if (mTouchMode == TOUCH_SELECT_MODE) {
                        mSelectX = mScrollX + (int) x;
                        mSelectY = mScrollY + (int) y;
                        if (DebugFlags.WEB_VIEW) {
                            Log.v(LOGTAG, ""xtend="" + mSelectX + "","" + mSelectY);
                        }
                        nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), true);
                        invalidate();
                        break;
                    }
                    if ((deltaX * deltaX + deltaY * deltaY) < mTouchSlopSquare) {
                        break;
                    }
                    if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                        // track mLastTouchTime as we may need to do fling at
                        // ACTION_UP
                        mLastTouchTime = eventTime;
                        break;
                    }
                    if (mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                    } else if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                    }
                    // if it starts nearly horizontal or vertical, enforce it
                    int ax = Math.abs(deltaX);
                    int ay = Math.abs(deltaY);
                    if (ax > MAX_SLOPE_FOR_DIAG * ay) {
                        mSnapScrollMode = SNAP_X;
                        mSnapPositive = deltaX > 0;
                    } else if (ay > MAX_SLOPE_FOR_DIAG * ax) {
                        mSnapScrollMode = SNAP_Y;
                        mSnapPositive = deltaY > 0;
                    }
                    mTouchMode = TOUCH_DRAG_MODE;
                    WebViewCore.pauseUpdate(mWebViewCore);
                    if (!mDragFromTextInput) {
                        nativeHideCursor();
                    }
                    WebSettings settings = getSettings();
                    if (settings.supportZoom() && settings.getBuiltInZoomControls() && !mZoomButtonsController.isVisible() && mMinZoomScale < mMaxZoomScale) {
                        mZoomButtonsController.setVisible(true);
                        int count = settings.getDoubleTapToastCount();
                        if (mInZoomOverview && count > 0) {
                            settings.setDoubleTapToastCount(--count);
                            Toast.makeText(mContext, com.android.internal.R.string.double_tap_toast, Toast.LENGTH_LONG).show();
                        }
                    }
                }
                // do pan
                int newScrollX = pinLocX(mScrollX + deltaX);
                deltaX = newScrollX - mScrollX;
                int newScrollY = pinLocY(mScrollY + deltaY);
                deltaY = newScrollY - mScrollY;
                boolean done = false;
                if (deltaX == 0 && deltaY == 0) {
                    done = true;
                } else {
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
                        int ax = Math.abs(deltaX);
                        int ay = Math.abs(deltaY);
                        if (mSnapScrollMode == SNAP_X) {
                            // radical change means getting out of snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ((mSnapPositive && deltaX < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaX > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_X_LOCK;
                            }
                        } else {
                            // radical change means getting out of snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ay > MAX_SLOPE_FOR_DIAG * ax) && ((mSnapPositive && deltaY < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaY > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_Y_LOCK;
                            }
                        }
                    }
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_X_LOCK) {
                        if (deltaX == 0) {
                            // keep the scrollbar on the screen even there is no
                            // scroll
                            awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                        } else {
                            scrollBy(deltaX, 0);
                        }
                        mLastTouchX = x;
                    } else if (mSnapScrollMode == SNAP_Y || mSnapScrollMode == SNAP_Y_LOCK) {
                        if (deltaY == 0) {
                            // keep the scrollbar on the screen even there is no
                            // scroll
                            awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                        } else {
                            scrollBy(0, deltaY);
                        }
                        mLastTouchY = y;
                    } else {
                        scrollBy(deltaX, deltaY);
                        mLastTouchX = x;
                        mLastTouchY = y;
                    }
                    mLastTouchTime = eventTime;
                    mUserScroll = true;
                }
                if (!getSettings().getBuiltInZoomControls()) {
                    boolean showPlusMinus = mMinZoomScale < mMaxZoomScale;
                    if (mZoomControls != null && showPlusMinus) {
                        if (mZoomControls.getVisibility() == View.VISIBLE) {
                            mPrivateHandler.removeCallbacks(mZoomControlRunnable);
                        } else {
                            mZoomControls.show(showPlusMinus, false);
                        }
                        mPrivateHandler.postDelayed(mZoomControlRunnable, ZOOM_CONTROLS_TIMEOUT);
                    }
                }
                if (mDragTrackerHandler != null) {
                    mDragTrackerHandler.dragTo(x, y);
                }
                if (done) {
                    // keep the scrollbar on the screen even there is no scroll
                    awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                    // view space
                    return false;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                if (mDragTrackerHandler != null) {
                    mDragTrackerHandler.stopDrag();
                    mDragTrackerHandler = null;
                }
                mLastTouchUpTime = eventTime;
                switch(mTouchMode) {
                    case // double tap
                    TOUCH_DOUBLE_TAP_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mTouchMode = TOUCH_DONE_MODE;
                        doDoubleTap();
                        break;
                    case TOUCH_SELECT_MODE:
                        commitCopy();
                        mTouchSelection = false;
                        break;
                    // tap
                    case TOUCH_INIT_MODE:
                    case TOUCH_SHORTPRESS_START_MODE:
                    case TOUCH_SHORTPRESS_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if ((deltaX * deltaX + deltaY * deltaY) > mTouchSlopSquare) {
                            Log.w(LOGTAG, ""Miss a drag as we are waiting for"" + "" WebCore's response for touch down."");
                            if (computeHorizontalScrollExtent() < computeHorizontalScrollRange() || computeVerticalScrollExtent() < computeVerticalScrollRange()) {
                                // we will not rewrite drag code here, but we
                                // will try fling if it applies.
                                WebViewCore.pauseUpdate(mWebViewCore);
                            // fall through to TOUCH_DRAG_MODE
                            } else {
                                break;
                            }
                        } else {
                            if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                                // if mPreventDrag is not confirmed, treat it as
                                // no so that it won't block tap or double tap.
                                mPreventDrag = PREVENT_DRAG_NO;
                            }
                            if (mPreventDrag == PREVENT_DRAG_NO) {
                                if (mTouchMode == TOUCH_INIT_MODE) {
                                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(RELEASE_SINGLE_TAP), ViewConfiguration.getDoubleTapTimeout());
                                } else {
                                    mTouchMode = TOUCH_DONE_MODE;
                                    doShortPress();
                                }
                            }
                            break;
                        }
                    case TOUCH_DRAG_MODE:
                        // redraw in high-quality, as we're done dragging
                        invalidate();
                        // up, we don't want to do a fling
                        if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
                            mVelocityTracker.addMovement(ev);
                            doFling();
                            break;
                        }
                        mLastVelocity = 0;
                        WebViewCore.resumeUpdate(mWebViewCore);
                        break;
                    case TOUCH_DRAG_START_MODE:
                    case TOUCH_DONE_MODE:
                        // do nothing
                        break;
                }
                // mode in the drawing code
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                if (mDragTrackerHandler != null) {
                    mDragTrackerHandler.stopDrag();
                    mDragTrackerHandler = null;
                }
                cancelTouch();
                break;
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
20,"<android.server.BluetoothService: int addRfcommServiceRecord(String,ParcelUuid,int,IBinder)>",6,7,"<android.server.BluetoothService: int addRfcommServiceRecord(String,ParcelUuid,int,IBinder)>","<android.server.BluetoothService: int addRfcommServiceRecord(String,ParcelUuid,int,IBinder)>",0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (serviceName == null || uuid == null || channel < 1 || channel > BluetoothSocket.MAX_RFCOMM_CHANNEL) {
        return -1;
    }
    if (BluetoothUuid.isUuidPresent(BluetoothUuid.RESERVED_UUIDS, uuid)) {
        Log.w(TAG, ""Attempted to register a reserved UUID: "" + uuid);
        return -1;
    }
    int handle = addRfcommServiceRecordNative(serviceName, uuid.getUuid().getMostSignificantBits(), uuid.getUuid().getLeastSignificantBits(), (short) channel);
    if (DBG)
        log(""new handle "" + Integer.toHexString(handle));
    if (handle == -1) {
        return -1;
    }
    int pid = Binder.getCallingPid();
    mServiceRecordToPid.put(new Integer(handle), new Integer(pid));
    try {
        b.linkToDeath(new Reaper(handle, pid), 0);
    } catch (RemoteException e) {
    }
    return handle;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return -1;
    if (serviceName == null || uuid == null || channel < 1 || channel > BluetoothSocket.MAX_RFCOMM_CHANNEL) {
        return -1;
    }
    if (BluetoothUuid.isUuidPresent(BluetoothUuid.RESERVED_UUIDS, uuid)) {
        Log.w(TAG, ""Attempted to register a reserved UUID: "" + uuid);
        return -1;
    }
    int handle = addRfcommServiceRecordNative(serviceName, uuid.getUuid().getMostSignificantBits(), uuid.getUuid().getLeastSignificantBits(), (short) channel);
    if (DBG)
        log(""new handle "" + Integer.toHexString(handle));
    if (handle == -1) {
        return -1;
    }
    int pid = Binder.getCallingPid();
    mServiceRecordToPid.put(new Integer(handle), new Integer(pid));
    try {
        b.linkToDeath(new Reaper(handle, pid), 0);
    } catch (RemoteException e) {
    }
    return handle;
}",1,"/**
 * b is a handle to a Binder instance, so that this service can be notified
 * for Applications that terminate unexpectedly, to clean there service
 * records
 */
","/**
 * b is a handle to a Binder instance, so that this service can be notified
 * for Applications that terminate unexpectedly, to clean there service
 * records
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"A new statement 'if (!isEnabledInternal()) return -1;' is introduced, so the code change type is 3 (Control dependency changed).","The introduction of the new method 'isEnabledInternal()' may lead the API to return a different value (i.e., -1) if the statement 'if (!isEnabledInternal())' evaluates to true. Therefore, the CI type is 1, which refers to a compatibility issue caused by potential different return values."
21,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,6,7,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,0,"{
    String str = get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX);
    return splitInt(str);
}","{
    String str = get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX);
    ArrayList<Integer> formats = new ArrayList<Integer>();
    for (String s : split(str)) {
        int f = pixelFormatForCameraFormat(s);
        if (f == PixelFormat.UNKNOWN)
            continue;
        formats.add(f);
    }
    return formats;
}",1,"/**
 * Gets the supported picture formats.
 *
 * @return a List of Integer objects (values are PixelFormat.XXX). null
 * if picture setting is not supported.
 */
","/**
 * Gets the supported picture formats.
 *
 * @return a List of Integer objects (values are PixelFormat.XXX). This
 * method will always return a list with at least one element.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, a new method 'pixelFormatForCameraFormat(s)' is called, a new return statement and a new control statement 'for' are introduced, and the 'get' function uses different parameter. Accordingly, the code change type is 1,3,4.","Due to these changes, especially the introduction of the new 'for' loop and the modification of the 'get' function, the return value of the API is potentially changed, leading to CI type 1."
22,"<android.server.BluetoothService: boolean setPin(String,byte[])>",6,7,"<android.server.BluetoothService: boolean setPin(String,byte[])>","<android.server.BluetoothService: boolean setPin(String,byte[])>",0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (pin == null || pin.length <= 0 || pin.length > 16 || !BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    address = address.toUpperCase();
    Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
    if (data == null) {
        Log.w(TAG, ""setPin("" + address + "") called but no native data available, "" + ""ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device"" + "" or by bluez.\n"");
        return false;
    }
    // bluez API wants pin as a string
    String pinString;
    try {
        pinString = new String(pin, ""UTF8"");
    } catch (UnsupportedEncodingException uee) {
        Log.e(TAG, ""UTF8 not supported?!?"");
        return false;
    }
    return setPinNative(address, pinString, data.intValue());
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    if (pin == null || pin.length <= 0 || pin.length > 16 || !BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    address = address.toUpperCase();
    Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
    if (data == null) {
        Log.w(TAG, ""setPin("" + address + "") called but no native data available, "" + ""ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device"" + "" or by bluez.\n"");
        return false;
    }
    // bluez API wants pin as a string
    String pinString;
    try {
        pinString = new String(pin, ""UTF8"");
    } catch (UnsupportedEncodingException uee) {
        Log.e(TAG, ""UTF8 not supported?!?"");
        return false;
    }
    return setPinNative(address, pinString, data.intValue());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"There is a new if condition 'if (!isEnabledInternal()) return false;' introduced in the late version, which clearly indicates a control dependency change (type 3).","Since a new if condition has been added in the implementation, it can cause the method to return false in cases where the earlier version would not have done. This change leads to the potential behavior difference thus creating a Compatibility Issue of type 1."
24,"<android.server.BluetoothService: int getRemoteServiceChannel(String,ParcelUuid)>",6,7,"<android.server.BluetoothService: int getRemoteServiceChannel(String,ParcelUuid)>","<android.server.BluetoothService: int getRemoteServiceChannel(String,ParcelUuid)>",0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return BluetoothDevice.ERROR;
    }
    // Check if we are recovering from a crash.
    if (mDeviceProperties.isEmpty()) {
        if (!updateRemoteDevicePropertiesCache(address))
            return -1;
    }
    Map<ParcelUuid, Integer> value = mDeviceServiceChannelCache.get(address);
    if (value != null && value.containsKey(uuid))
        return value.get(uuid);
    return -1;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return -1;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return BluetoothDevice.ERROR;
    }
    // Check if we are recovering from a crash.
    if (mDeviceProperties.isEmpty()) {
        if (!updateRemoteDevicePropertiesCache(address))
            return -1;
    }
    Map<ParcelUuid, Integer> value = mDeviceServiceChannelCache.get(address);
    if (value != null && value.containsKey(uuid))
        return value.get(uuid);
    return -1;
}",1,"/**
 * Gets the rfcomm channel associated with the UUID.
 * Pulls records from the cache only.
 *
 * @param address Address of the remote device
 * @param uuid ParcelUuid of the service attribute
 *
 * @return rfcomm channel associated with the service attribute
 * -1 on error
 */
","/**
 * Gets the rfcomm channel associated with the UUID.
 * Pulls records from the cache only.
 *
 * @param address Address of the remote device
 * @param uuid ParcelUuid of the service attribute
 *
 * @return rfcomm channel associated with the service attribute
 * -1 on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is a new control statement (if (!isEnabledInternal())) introduced in the late version, and also a new return statement (return -1) introduced, so the code change type is 3,4.","Due to the extra control check (!isEnabledInternal()) and return -1 in the late version, there's potential that the new version may return -1 under conditions where the early version wouldn't. This suggests that the CI type is 1."
25,<android.server.BluetoothService: boolean isEnabled()>,6,7,<android.server.BluetoothService: boolean isEnabled()>,<android.server.BluetoothService: boolean isEnabled()>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothState == BluetoothAdapter.STATE_ON;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return isEnabledInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement of the method has changed from 'mBluetoothState == BluetoothAdapter.STATE_ON' to 'isEnabledInternal()'. So, the code change types are 1 and 5, as the dependent function has also changed.","The replacement of the return statement 'mBluetoothState == BluetoothAdapter.STATE_ON' with 'isEnabledInternal()' can potentially cause the API to return a different value. Therefore, there is a Compatibility Issue caused by potential different return values, and the CI type is 1."
27,<android.view.VelocityTracker: float getXVelocity()>,6,7,<android.view.VelocityTracker: float getXVelocity()>,<android.view.VelocityTracker: float getXVelocity()>,0,"{
    return mXVelocity;
}","{
    return mXVelocity[0];
}",1,"/**
 * Retrieve the last computed X velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @return The previously computed X velocity.
 */
","/**
 * Retrieve the last computed X velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @return The previously computed X velocity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement of this function is changed from returning a float variable 'mXVelocity' to returning the first value in the float array 'mXVelocity', so the code change type is 1.","As the return statement is changed, it could potentially return a different value. Therefore, the CI type is 1."
28,"<android.server.BluetoothService: boolean setTrust(String,boolean)>",6,7,"<android.server.BluetoothService: boolean setTrust(String,boolean)>","<android.server.BluetoothService: boolean setTrust(String,boolean)>",0,"{
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
        return false;
    }
    return setDevicePropertyBooleanNative(getObjectPathFromAddress(address), ""Trusted"", value ? 1 : 0);
}","{
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
        return false;
    }
    if (!isEnabledInternal())
        return false;
    return setDevicePropertyBooleanNative(getObjectPathFromAddress(address), ""Trusted"", value ? 1 : 0);
}",1,"/**
 * Sets the remote device trust state.
 *
 * @return boolean to indicate operation success or fail
 */
","/**
 * Sets the remote device trust state.
 *
 * @return boolean to indicate operation success or fail
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new 'if' statement is introduced, so the code change type is 3. The new 'return false' statement inside this 'if' statement is also considered type 4.","As the newly introduced 'if' statement can potentially cause the API to return false under conditions that were not considered in the early version, thus the CI type is 1."
29,"<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean)>",6,7,"<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean)>","<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean)>",0,"{
    ReceiverDispatcher rd = mDispatcher.get();
    if (DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Log.i(TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + rd);
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky);
    }
}","{
    ReceiverDispatcher rd = mDispatcher.get();
    if (DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Log.i(TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + rd);
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (DEBUG_BROADCAST) {
            Log.i(TAG, ""Broadcast to unregistered receiver"");
        }
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            mgr.finishReceiver(this, resultCode, data, extras, false);
        } catch (RemoteException e) {
            Log.w(TAG, ""Couldn't finish broadcast to unregistered receiver"");
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3",2,"New statements are added into the 'else' branch which includes a new method call and exception handling. Thus the change types include return statement change, exception handling statement change, and control dependency change. So the code change type is 1,2,3.","In the early version, the method doesn't handle the case where 'rd' is null. But in the later version, the method attempts to finish the receiver once 'rd' is confirmed as null and even handles the RemoteException. These changes could potentially lead the method to throw a different exception, therefore, the CI type is 2."
30,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,6,7,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
        // Reset this state; it will be re-set if super.onTouchEvent
        // causes focus to move to the view.
        mTouchFocusSelected = false;
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mEatTouchRelease && action == MotionEvent.ACTION_UP) {
        mEatTouchRelease = false;
        return superResult;
    }
    if ((mMovement != null || onCheckIsTextEditor()) && mText instanceof Spannable && mLayout != null) {
        if (action == MotionEvent.ACTION_DOWN) {
            mScrolled = false;
        }
        boolean handled = false;
        int oldSelStart = Selection.getSelectionStart(mText);
        int oldSelEnd = Selection.getSelectionEnd(mText);
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        if (mText instanceof Editable && onCheckIsTextEditor()) {
            if (action == MotionEvent.ACTION_UP && isFocused() && !mScrolled) {
                InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                // This is going to be gross...  if tapping on the text view
                // causes the IME to be displayed, we don't want the selection
                // to change.  But the selection has already changed, and
                // we won't know right away whether the IME is getting
                // displayed, so...
                int newSelStart = Selection.getSelectionStart(mText);
                int newSelEnd = Selection.getSelectionEnd(mText);
                CommitSelectionReceiver csr = null;
                if (newSelStart != oldSelStart || newSelEnd != oldSelEnd) {
                    csr = new CommitSelectionReceiver();
                    csr.mNewStart = newSelStart;
                    csr.mNewEnd = newSelEnd;
                }
                if (imm.showSoftInput(this, 0, csr) && csr != null) {
                    // The IME might get shown -- revert to the old
                    // selection, and change to the new when we finally
                    // find out of it is okay.
                    Selection.setSelection((Spannable) mText, oldSelStart, oldSelEnd);
                    handled = true;
                }
            }
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
        // Reset this state; it will be re-set if super.onTouchEvent
        // causes focus to move to the view.
        mTouchFocusSelected = false;
        mScrolled = false;
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mEatTouchRelease && action == MotionEvent.ACTION_UP) {
        mEatTouchRelease = false;
        return superResult;
    }
    if ((mMovement != null || onCheckIsTextEditor()) && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        int oldSelStart = Selection.getSelectionStart(mText);
        int oldSelEnd = Selection.getSelectionEnd(mText);
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        if (mText instanceof Editable && onCheckIsTextEditor()) {
            if (action == MotionEvent.ACTION_UP && isFocused() && !mScrolled) {
                InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                // This is going to be gross...  if tapping on the text view
                // causes the IME to be displayed, we don't want the selection
                // to change.  But the selection has already changed, and
                // we won't know right away whether the IME is getting
                // displayed, so...
                int newSelStart = Selection.getSelectionStart(mText);
                int newSelEnd = Selection.getSelectionEnd(mText);
                CommitSelectionReceiver csr = null;
                if (newSelStart != oldSelStart || newSelEnd != oldSelEnd) {
                    csr = new CommitSelectionReceiver();
                    csr.mNewStart = newSelStart;
                    csr.mNewEnd = newSelEnd;
                }
                if (imm.showSoftInput(this, 0, csr) && csr != null) {
                    // The IME might get shown -- revert to the old
                    // selection, and change to the new when we finally
                    // find out of it is okay.
                    Selection.setSelection((Spannable) mText, oldSelStart, oldSelEnd);
                    handled = true;
                }
            }
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The conditional statement `if (action == MotionEvent.ACTION_DOWN)` has changed, since an extra assignment `mScrolled = false;` was added in the late version. Thus, the code change type is 3.","Because the change of control dependency statement can affect the execution of the other statements and potentially make the API return different value, the CI type is 1."
31,<android.server.BluetoothService: String getAddressFromObjectPath(String)>,6,7,<android.server.BluetoothService: String getAddressFromObjectPath(String)>,<android.server.BluetoothService: String getAddressFromObjectPath(String)>,0,"{
    String adapterObjectPath = getProperty(""ObjectPath"");
    if (adapterObjectPath == null || objectPath == null) {
        Log.e(TAG, ""getAddressFromObjectPath: AdpaterObjectPath:"" + adapterObjectPath + ""  or deviceObjectPath:"" + objectPath + "" is null"");
        return null;
    }
    if (!objectPath.startsWith(adapterObjectPath)) {
        Log.e(TAG, ""getAddressFromObjectPath: AdpaterObjectPath:"" + adapterObjectPath + ""  is not a prefix of deviceObjectPath:"" + objectPath + ""bluetoothd crashed ?"");
        return null;
    }
    String address = objectPath.substring(adapterObjectPath.length());
    if (address != null)
        return address.replace('_', ':');
    Log.e(TAG, ""getAddressFromObjectPath: Address being returned is null"");
    return null;
}","{
    String adapterObjectPath = getPropertyInternal(""ObjectPath"");
    if (adapterObjectPath == null || objectPath == null) {
        Log.e(TAG, ""getAddressFromObjectPath: AdpaterObjectPath:"" + adapterObjectPath + ""  or deviceObjectPath:"" + objectPath + "" is null"");
        return null;
    }
    if (!objectPath.startsWith(adapterObjectPath)) {
        Log.e(TAG, ""getAddressFromObjectPath: AdpaterObjectPath:"" + adapterObjectPath + ""  is not a prefix of deviceObjectPath:"" + objectPath + ""bluetoothd crashed ?"");
        return null;
    }
    String address = objectPath.substring(adapterObjectPath.length());
    if (address != null)
        return address.replace('_', ':');
    Log.e(TAG, ""getAddressFromObjectPath: Address being returned is null"");
    return null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The code change occurs in the line where there's a call to the dependent API 'getProperty(""ObjectPath"")' in early version. In the late version, it's replaced with 'getPropertyInternal(""ObjectPath"")'. So the change types are 4 and 5.","The change in the dependent API from 'getProperty' to 'getPropertyInternal' may potentially affect the return value, hence the CI type is 1."
32,<android.service.wallpaper.WallpaperService.Engine: void detach()>,6,7,<android.service.wallpaper.WallpaperService.Engine: void detach()>,<android.service.wallpaper.WallpaperService.Engine: void detach()>,0,"{
    mDestroyed = true;
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    if (mDestroyReportNeeded) {
        mDestroyReportNeeded = false;
        SurfaceHolder.Callback[] callbacks;
        synchronized (mSurfaceHolder.mCallbacks) {
            callbacks = new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
        }
        for (SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
        }
        if (DEBUG)
            Log.v(TAG, ""onSurfaceDestroyed("" + mSurfaceHolder + ""): "" + this);
        onSurfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    unregisterReceiver(mReceiver);
    if (mCreated) {
        try {
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
    }
}","{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    if (mDestroyReportNeeded) {
        mDestroyReportNeeded = false;
        SurfaceHolder.Callback[] callbacks;
        synchronized (mSurfaceHolder.mCallbacks) {
            callbacks = new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
        }
        for (SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
        }
        if (DEBUG)
            Log.v(TAG, ""onSurfaceDestroyed("" + mSurfaceHolder + ""): "" + this);
        onSurfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    unregisterReceiver(mReceiver);
    if (mCreated) {
        try {
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new 'if' conditional statement is introduced at the beginning of the method, and a new `return` statement has been added within this 'if', so the code change type is 1,3.","Given the newly added 'if' condition and `return` statement, the method might terminate and return earlier than it did in the previous version. Thus, CI type is 1 for the potential difference in return."
34,<android.server.BluetoothService: boolean startDiscovery()>,6,7,<android.server.BluetoothService: boolean startDiscovery()>,<android.server.BluetoothService: boolean startDiscovery()>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabled()) {
        return false;
    }
    return startDiscoveryNative();
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    return startDiscoveryNative();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The condition statement in the if statement has changed from isEnabled() to isEnabledInternal(), and the dependent API isEnabled() was replaced by isEnabledInternal(), so the code change type is 1,5.","The modification of condition statement and the change of dependent APIs will make the API potentially return a different value when checking the if condition, demonstrating that the CI type is 1."
35,<android.server.BluetoothService: String getObjectPathFromAddress(String)>,6,7,<android.server.BluetoothService: String getObjectPathFromAddress(String)>,<android.server.BluetoothService: String getObjectPathFromAddress(String)>,0,"{
    String path = getProperty(""ObjectPath"");
    if (path == null) {
        Log.e(TAG, ""Error: Object Path is null"");
        return null;
    }
    path = path + address.replace("":"", ""_"");
    return path;
}","{
    String path = getPropertyInternal(""ObjectPath"");
    if (path == null) {
        Log.e(TAG, ""Error: Object Path is null"");
        return null;
    }
    path = path + address.replace("":"", ""_"");
    return path;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method that this API depends on has changed from 'getProperty' to 'getPropertyInternal', so the code change type is 4,5.","Since 'getPropertyInternal' may return different results from 'getProperty', the 'return path' could potentially return different values in the late version from the early version, so the CI type is 1."
36,<android.server.BluetoothService: boolean cancelPairingUserInput(String)>,6,7,<android.server.BluetoothService: boolean cancelPairingUserInput(String)>,<android.server.BluetoothService: boolean cancelPairingUserInput(String)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    mBondState.setBondState(address, BluetoothDevice.BOND_NONE, BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
    address = address.toUpperCase();
    Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
    if (data == null) {
        Log.w(TAG, ""cancelUserInputNative("" + address + "") called but no native data "" + ""available, ignoring. Maybe the PasskeyAgent Request was already cancelled "" + ""by the remote or by bluez.\n"");
        return false;
    }
    return cancelPairingUserInputNative(address, data.intValue());
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    mBondState.setBondState(address, BluetoothDevice.BOND_NONE, BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
    address = address.toUpperCase();
    Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
    if (data == null) {
        Log.w(TAG, ""cancelUserInputNative("" + address + "") called but no native data "" + ""available, ignoring. Maybe the PasskeyAgent Request was already cancelled "" + ""by the remote or by bluez.\n"");
        return false;
    }
    return cancelPairingUserInputNative(address, data.intValue());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition statement '!isEnabledInternal()' is added in the method, so the type of code change is 3.","The early version of the API doesn't contain isCheckedInternal() as a condition to return false. But in the late version, if isCheckedInternal() is not true, the method will return false. This change will potentially lead the method to return a different value. So the CI type is 1."
38,<android.server.BluetoothService: void finalize()>,6,7,<android.server.BluetoothService: void finalize()>,<android.server.BluetoothService: void finalize()>,0,"{
    if (mIsAirplaneSensitive) {
        mContext.unregisterReceiver(mReceiver);
    }
    try {
        cleanupNativeDataNative();
    } finally {
        super.finalize();
    }
}","{
    mContext.unregisterReceiver(mReceiver);
    try {
        cleanupNativeDataNative();
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,2,"The conditional check for 'isAirplaneSensitive' was removed in the Late Version, otherwise, no changes were made. Hence, the code change falls under type 3.","Before, the app would only attempt to unregister the receiver if `mIsAirplaneSensitive` was true. Now it attempts to unregister the receiver regardless. Depending on the implementation of `unregisterReceiver()`, it is plausible that an exception could be thrown if it's called when the receiver is not already registered, causing a compatibility issue of type 2."
40,<android.view.VelocityTracker: float getYVelocity()>,6,7,<android.view.VelocityTracker: float getYVelocity()>,<android.view.VelocityTracker: float getYVelocity()>,0,"{
    return mYVelocity;
}","{
    return mYVelocity[0];
}",1,"/**
 * Retrieve the last computed Y velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @return The previously computed Y velocity.
 */
","/**
 * Retrieve the last computed Y velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @return The previously computed Y velocity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The value of 'mYVelocity' is directly returned in the early version while the first element in the 'mYVelocity' array is returned in the late version, so the code change type is 1.","The change of the return statement in the late version may cause the API to return a different value, so the CI type is 1."
41,<android.server.BluetoothA2dpService: int getSinkPriority(BluetoothDevice)>,6,7,<android.server.BluetoothA2dpService: int getSinkPriority(BluetoothDevice)>,<android.server.BluetoothA2dpService: int getSinkPriority(BluetoothDevice)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.getBluetoothA2dpSinkPriorityKey(device.getAddress()), BluetoothA2dp.PRIORITY_OFF);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.getBluetoothA2dpSinkPriorityKey(device.getAddress()), BluetoothA2dp.PRIORITY_UNDEFINED);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'BluetoothA2dp.PRIORITY_OFF' to 'BluetoothA2dp.PRIORITY_UNDEFINED' in the settings secure getInt method, which means the code change type is 1.","The return statement has changed, which means that the method 'getSinkPriority' is potentially returning a different value, thereby resulting in a CI of type 1."
43,<android.webkit.WebView: boolean zoomOut()>,6,7,<android.webkit.WebView: boolean zoomOut()>,<android.webkit.WebView: boolean zoomOut()>,0,"{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    float scale = mActualScale * 0.8f;
    if (scale < (mMinZoomScale + 0.1f) && mWebViewCore.getSettings().getUseWideViewPort()) {
        // when zoom out to min scale, switch to overview mode
        doDoubleTap();
        return true;
    } else {
        // Center zooming to the center of the screen.
        mZoomCenterX = getViewWidth() * .5f;
        mZoomCenterY = getViewHeight() * .5f;
        return zoomWithPreview(scale);
    }
}","{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    // Center zooming to the center of the screen.
    mZoomCenterX = getViewWidth() * .5f;
    mZoomCenterY = getViewHeight() * .5f;
    mAnchorX = viewToContentX((int) mZoomCenterX + mScrollX);
    mAnchorY = viewToContentY((int) mZoomCenterY + mScrollY);
    return zoomWithPreview(mActualScale * 0.8f);
}",1,"/**
 * Perform zoom out in the webview
 * @return TRUE if zoom out succeeds. FALSE if no zoom changes.
 */
","/**
 * Perform zoom out in the webview
 * @return TRUE if zoom out succeeds. FALSE if no zoom changes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow of the method has changed due to removal of an if/else block, and new statements are introduced (assignment of mAnchorX and mAnchorY), and the return statement 'return zoomWithPreview(scale);' has been changed to 'return zoomWithPreview(mActualScale * 0.8f);'. So, the change type is 1,3.","Since the control flow and the return statement, which is based on the condition statement, has been changed, the potential return value will be different. Therefore, the CI Type is 1."
44,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>",6,7,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>","<android.webkit.WebView: boolean restorePicture(Bundle,File)>",0,"{
    if (src == null || b == null) {
        return false;
    }
    if (src.exists()) {
        Picture p = null;
        try {
            final FileInputStream in = new FileInputStream(src);
            p = Picture.createFromStream(in);
            in.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (p != null) {
            int sx = b.getInt(""scrollX"", 0);
            int sy = b.getInt(""scrollY"", 0);
            float scale = b.getFloat(""scale"", 1.0f);
            mDrawHistory = true;
            mHistoryPicture = p;
            mScrollX = sx;
            mScrollY = sy;
            mHistoryWidth = Math.round(p.getWidth() * scale);
            mHistoryHeight = Math.round(p.getHeight() * scale);
            // as getWidth() / getHeight() of the view are not
            // available yet, set up mActualScale, so that when
            // onSizeChanged() is called, the rest will be set
            // correctly
            mActualScale = scale;
            float lastScale = b.getFloat(""lastScale"", -1.0f);
            if (lastScale > 0) {
                mInZoomOverview = true;
                mLastScale = lastScale;
            } else {
                mInZoomOverview = false;
            }
            invalidate();
            return true;
        }
    }
    return false;
}","{
    if (src == null || b == null) {
        return false;
    }
    if (src.exists()) {
        Picture p = null;
        try {
            final FileInputStream in = new FileInputStream(src);
            p = Picture.createFromStream(in);
            in.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (p != null) {
            int sx = b.getInt(""scrollX"", 0);
            int sy = b.getInt(""scrollY"", 0);
            float scale = b.getFloat(""scale"", 1.0f);
            mDrawHistory = true;
            mHistoryPicture = p;
            mScrollX = sx;
            mScrollY = sy;
            mHistoryWidth = Math.round(p.getWidth() * scale);
            mHistoryHeight = Math.round(p.getHeight() * scale);
            // as getWidth() / getHeight() of the view are not
            // available yet, set up mActualScale, so that when
            // onSizeChanged() is called, the rest will be set
            // correctly
            mActualScale = scale;
            mTextWrapScale = b.getFloat(""textwrapScale"", scale);
            mInZoomOverview = b.getBoolean(""overview"");
            invalidate();
            return true;
        }
    }
    return false;
}",1,"/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 */
","/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There are a few variable settings changed in the codes, like 'mInZoomOverview' and added 'mTextWrapScale'. This can be classified into 'Other statement changed' category, which is 4.","The changes in the second version do not seem to affect the return value or exception handling of the API as both versions are consistent in their return statements and exception handling. Hence, it can be concluded that no compatibility issue exists, which is 0."
46,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,6,7,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged();
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false);
                if (reportDraw) {
                    try {
                        mEngine.mSession.finishDrawing(mEngine.mWindow);
                    } catch (RemoteException e) {
                    }
                }
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                MotionEvent ev = (MotionEvent) message.obj;
                synchronized (mEngine.mLock) {
                    if (mEngine.mPendingMove == ev) {
                        mEngine.mPendingMove = null;
                    }
                }
                if (DEBUG)
                    Log.v(TAG, ""Delivering touch event: "" + ev);
                mEngine.onTouchEvent(ev);
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged();
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false);
                if (reportDraw) {
                    try {
                        mEngine.mSession.finishDrawing(mEngine.mWindow);
                    } catch (RemoteException e) {
                    }
                }
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                MotionEvent ev = (MotionEvent) message.obj;
                synchronized (mEngine.mLock) {
                    if (mEngine.mPendingMove == ev) {
                        mEngine.mPendingMove = null;
                    }
                }
                if (DEBUG)
                    Log.v(TAG, ""Delivering touch event: "" + ev);
                mEngine.onTouchEvent(ev);
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"Code changes occurred under the 'DO_ATTACH' and 'DO_DETACH' cases. In the 'DO_ATTACH' case, a new line of code has been added (mActiveEngines.add(engine)), and in the 'DO_DETACH' case, a line of code has been removed (mActiveEngines.remove(mEngine)). Therefore, the code change type is categorized as 3 (Control dependency changed).","Despite the changes in the control statements, these modifications do not change the API's behavior, as they don't affect the returned value or the thrown exceptions. Therefore, there is no compatibility issue, so the CI type is 0."
47,<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.Args: void run()>,6,7,<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.Args: void run()>,<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.Args: void run()>,0,"{
    BroadcastReceiver receiver = mReceiver;
    if (DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Log.i(TAG, ""Dispathing broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
    }
    if (receiver == null) {
        return;
    }
    IActivityManager mgr = ActivityManagerNative.getDefault();
    Intent intent = mCurIntent;
    mCurIntent = null;
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        if (mCurMap != null) {
            mCurMap.setClassLoader(cl);
        }
        receiver.setOrderedHint(true);
        receiver.setResult(mCurCode, mCurData, mCurMap);
        receiver.clearAbortBroadcast();
        receiver.setOrderedHint(mCurOrdered);
        receiver.setInitialStickyHint(mCurSticky);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && mCurOrdered) {
            try {
                mgr.finishReceiver(mIIntentReceiver, mCurCode, mCurData, mCurMap, false);
            } catch (RemoteException ex) {
            }
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (mRegistered && mCurOrdered) {
        try {
            mgr.finishReceiver(mIIntentReceiver, receiver.getResultCode(), receiver.getResultData(), receiver.getResultExtras(false), receiver.getAbortBroadcast());
        } catch (RemoteException ex) {
        }
    }
}","{
    BroadcastReceiver receiver = mReceiver;
    if (DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Log.i(TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
    }
    if (receiver == null) {
        return;
    }
    IActivityManager mgr = ActivityManagerNative.getDefault();
    Intent intent = mCurIntent;
    mCurIntent = null;
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        if (mCurMap != null) {
            mCurMap.setClassLoader(cl);
        }
        receiver.setOrderedHint(true);
        receiver.setResult(mCurCode, mCurData, mCurMap);
        receiver.clearAbortBroadcast();
        receiver.setOrderedHint(mCurOrdered);
        receiver.setInitialStickyHint(mCurSticky);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && mCurOrdered) {
            try {
                mgr.finishReceiver(mIIntentReceiver, mCurCode, mCurData, mCurMap, false);
            } catch (RemoteException ex) {
            }
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (mRegistered && mCurOrdered) {
        try {
            mgr.finishReceiver(mIIntentReceiver, receiver.getResultCode(), receiver.getResultData(), receiver.getResultExtras(false), receiver.getAbortBroadcast());
        } catch (RemoteException ex) {
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the code, only the spelling in the comment has been corrected from ""Dispathing"" to ""Dispatching"". So, the code change type is 0.","Since there is no change in the code implementation, there will be no compatibility issue in this case. So, the CI type is 0."
48,"<android.content.Intent: Intent parseUri(String,int)>",6,7,"<android.content.Intent: Intent parseUri(String,int)>","<android.content.Intent: Intent parseUri(String,int)>",0,"{
    int i = 0;
    try {
        // Validate intent scheme for if requested.
        if ((flags & URI_INTENT_SCHEME) != 0) {
            if (!uri.startsWith(""intent:"")) {
                Intent intent = new Intent(ACTION_VIEW);
                try {
                    intent.setData(Uri.parse(uri));
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
                return intent;
            }
        }
        // simple case
        i = uri.lastIndexOf(""#"");
        if (i == -1)
            return new Intent(ACTION_VIEW, Uri.parse(uri));
        // old format Intent URI
        if (!uri.startsWith(""#Intent;"", i))
            return getIntentOld(uri);
        // new format
        Intent intent = new Intent(ACTION_VIEW);
        // fetch data part, if present
        String data = i >= 0 ? uri.substring(0, i) : null;
        String scheme = null;
        i += ""#Intent;"".length();
        // loop over contents of Intent, all name=value;
        while (!uri.startsWith(""end"", i)) {
            int eq = uri.indexOf('=', i);
            int semi = uri.indexOf(';', eq);
            String value = Uri.decode(uri.substring(eq + 1, semi));
            // action
            if (uri.startsWith(""action="", i)) {
                intent.mAction = value;
            } else // categories
            if (uri.startsWith(""category="", i)) {
                intent.addCategory(value);
            } else // type
            if (uri.startsWith(""type="", i)) {
                intent.mType = value;
            } else // launch  flags
            if (uri.startsWith(""launchFlags="", i)) {
                intent.mFlags = Integer.decode(value).intValue();
            } else // package
            if (uri.startsWith(""package="", i)) {
                intent.mPackage = value;
            } else // component
            if (uri.startsWith(""component="", i)) {
                intent.mComponent = ComponentName.unflattenFromString(value);
            } else // scheme
            if (uri.startsWith(""scheme="", i)) {
                scheme = value;
            } else // extra
            {
                String key = Uri.decode(uri.substring(i + 2, eq));
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                Bundle b = intent.mExtras;
                // add EXTRA
                if (uri.startsWith(""S."", i))
                    b.putString(key, value);
                else if (uri.startsWith(""B."", i))
                    b.putBoolean(key, Boolean.parseBoolean(value));
                else if (uri.startsWith(""b."", i))
                    b.putByte(key, Byte.parseByte(value));
                else if (uri.startsWith(""c."", i))
                    b.putChar(key, value.charAt(0));
                else if (uri.startsWith(""d."", i))
                    b.putDouble(key, Double.parseDouble(value));
                else if (uri.startsWith(""f."", i))
                    b.putFloat(key, Float.parseFloat(value));
                else if (uri.startsWith(""i."", i))
                    b.putInt(key, Integer.parseInt(value));
                else if (uri.startsWith(""l."", i))
                    b.putLong(key, Long.parseLong(value));
                else if (uri.startsWith(""s."", i))
                    b.putShort(key, Short.parseShort(value));
                else
                    throw new URISyntaxException(uri, ""unknown EXTRA type"", i);
            }
            // move to the next item
            i = semi + 1;
        }
        if (data != null) {
            if (data.startsWith(""intent:"")) {
                data = data.substring(7);
                if (scheme != null) {
                    data = scheme + ':' + data;
                }
            }
            if (data.length() > 0) {
                try {
                    intent.mData = Uri.parse(data);
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
            }
        }
        return intent;
    } catch (IndexOutOfBoundsException e) {
        throw new URISyntaxException(uri, ""illegal Intent URI format"", i);
    }
}","{
    int i = 0;
    try {
        // Validate intent scheme for if requested.
        if ((flags & URI_INTENT_SCHEME) != 0) {
            if (!uri.startsWith(""intent:"")) {
                Intent intent = new Intent(ACTION_VIEW);
                try {
                    intent.setData(Uri.parse(uri));
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
                return intent;
            }
        }
        // simple case
        i = uri.lastIndexOf(""#"");
        if (i == -1)
            return new Intent(ACTION_VIEW, Uri.parse(uri));
        // old format Intent URI
        if (!uri.startsWith(""#Intent;"", i))
            return getIntentOld(uri);
        // new format
        Intent intent = new Intent(ACTION_VIEW);
        // fetch data part, if present
        String data = i >= 0 ? uri.substring(0, i) : null;
        String scheme = null;
        i += ""#Intent;"".length();
        // loop over contents of Intent, all name=value;
        while (!uri.startsWith(""end"", i)) {
            int eq = uri.indexOf('=', i);
            int semi = uri.indexOf(';', eq);
            String value = Uri.decode(uri.substring(eq + 1, semi));
            // action
            if (uri.startsWith(""action="", i)) {
                intent.mAction = value;
            } else // categories
            if (uri.startsWith(""category="", i)) {
                intent.addCategory(value);
            } else // type
            if (uri.startsWith(""type="", i)) {
                intent.mType = value;
            } else // launch flags
            if (uri.startsWith(""launchFlags="", i)) {
                intent.mFlags = Integer.decode(value).intValue();
            } else // package
            if (uri.startsWith(""package="", i)) {
                intent.mPackage = value;
            } else // component
            if (uri.startsWith(""component="", i)) {
                intent.mComponent = ComponentName.unflattenFromString(value);
            } else // scheme
            if (uri.startsWith(""scheme="", i)) {
                scheme = value;
            } else // source bounds
            if (uri.startsWith(""sourceBounds="", i)) {
                intent.mSourceBounds = Rect.unflattenFromString(value);
            } else // extra
            {
                String key = Uri.decode(uri.substring(i + 2, eq));
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                Bundle b = intent.mExtras;
                // add EXTRA
                if (uri.startsWith(""S."", i))
                    b.putString(key, value);
                else if (uri.startsWith(""B."", i))
                    b.putBoolean(key, Boolean.parseBoolean(value));
                else if (uri.startsWith(""b."", i))
                    b.putByte(key, Byte.parseByte(value));
                else if (uri.startsWith(""c."", i))
                    b.putChar(key, value.charAt(0));
                else if (uri.startsWith(""d."", i))
                    b.putDouble(key, Double.parseDouble(value));
                else if (uri.startsWith(""f."", i))
                    b.putFloat(key, Float.parseFloat(value));
                else if (uri.startsWith(""i."", i))
                    b.putInt(key, Integer.parseInt(value));
                else if (uri.startsWith(""l."", i))
                    b.putLong(key, Long.parseLong(value));
                else if (uri.startsWith(""s."", i))
                    b.putShort(key, Short.parseShort(value));
                else
                    throw new URISyntaxException(uri, ""unknown EXTRA type"", i);
            }
            // move to the next item
            i = semi + 1;
        }
        if (data != null) {
            if (data.startsWith(""intent:"")) {
                data = data.substring(7);
                if (scheme != null) {
                    data = scheme + ':' + data;
                }
            }
            if (data.length() > 0) {
                try {
                    intent.mData = Uri.parse(data);
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
            }
        }
        return intent;
    } catch (IndexOutOfBoundsException e) {
        throw new URISyntaxException(uri, ""illegal Intent URI format"", i);
    }
}",1,"/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
","/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"There is addition of a new 'if' condition statement in late implementation where 'sourceBounds' is checked and 'intent.mSourceBounds = Rect.unflattenFromString(value);' is executed. So, the change type is 4.",The late version implementation has a new case where it is checking for 'sourceBounds' and setting it into Intent if exists. This could lead to different behaviour when late version API is invoked compared to early version API. Hence CI type is 1.
50,<android.database.sqlite.SQLiteDatabase: void onCorruption()>,6,7,<android.database.sqlite.SQLiteDatabase: void onCorruption()>,<android.database.sqlite.SQLiteDatabase: void onCorruption()>,0,"{
    try {
        // Close the database (if we can), which will cause subsequent operations to fail.
        close();
    } finally {
        Log.e(TAG, ""Removing corrupt database: "" + mPath);
        // Delete the corrupt file.  Don't re-create it now -- that would just confuse people
        // -- but the next time someone tries to open it, they can set it up from scratch.
        new File(mPath).delete();
    }
}","{
    try {
        // Close the database (if we can), which will cause subsequent operations to fail.
        close();
    } finally {
        Log.e(TAG, ""Removing corrupt database: "" + mPath);
        EventLog.writeEvent(EVENT_DB_CORRUPT, mPath);
        // Delete the corrupt file.  Don't re-create it now -- that would just confuse people
        // -- but the next time someone tries to open it, they can set it up from scratch.
        new File(mPath).delete();
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new logging statement has been introduced in the 'finally' block, which logs an event. Therefore, the code change type is 4.","Without regard to the additional logging statement, the potential return value and exceptions caught will not be affected. As such, no compatibility issue type exists, which is category 0."
51,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,6,7,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, msg.what < REMEMBER_PASSWORD || msg.what > INVAL_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                // it won't block panning the page.
                if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                    mPreventDrag = PREVENT_DRAG_NO;
                }
                if (mTouchMode == TOUCH_INIT_MODE) {
                    mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                    updateSelection();
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (mPreventDrag == PREVENT_DRAG_NO) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                    rebuildWebTextView();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                if (mPreventDrag == PREVENT_DRAG_NO) {
                    mTouchMode = TOUCH_DONE_MODE;
                    doShortPress();
                }
                break;
            }
        case SCROLL_BY_MSG_ID:
            setContentScrollBy(msg.arg1, msg.arg2, (Boolean) msg.obj);
            break;
        case SYNC_SCROLL_TO_MSG_ID:
            if (mUserScroll) {
                // if user has scrolled explicitly, don't sync the
                // scroll position any more
                mUserScroll = false;
                break;
            }
        // fall through
        case SCROLL_TO_MSG_ID:
            if (setContentScrollTo(msg.arg1, msg.arg2)) {
                // if we can't scroll to the exact position due to pin,
                // send a message to WebCore to re-scroll when we get a
                // new picture
                mUserScroll = false;
                mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, msg.arg1, msg.arg2);
            }
            break;
        case SPAWN_SCROLL_TO_MSG_ID:
            spawnContentScrollTo(msg.arg1, msg.arg2);
            break;
        case NEW_PICTURE_MSG_ID:
            {
                WebSettings settings = mWebViewCore.getSettings();
                // called for new content
                final int viewWidth = getViewWidth();
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                final Point viewSize = draw.mViewPoint;
                boolean useWideViewport = settings.getUseWideViewPort();
                WebViewCore.RestoreState restoreState = draw.mRestoreState;
                if (restoreState != null) {
                    mInZoomOverview = false;
                    mLastScale = mInitialScaleInPercent > 0 ? mInitialScaleInPercent / 100.0f : restoreState.mTextWrapScale;
                    if (restoreState.mMinScale == 0) {
                        if (restoreState.mMobileSite) {
                            if (draw.mMinPrefWidth > Math.max(0, draw.mViewPoint.x)) {
                                mMinZoomScale = (float) viewWidth / draw.mMinPrefWidth;
                                mMinZoomScaleFixed = false;
                            } else {
                                mMinZoomScale = restoreState.mDefaultScale;
                                mMinZoomScaleFixed = true;
                            }
                        } else {
                            mMinZoomScale = DEFAULT_MIN_ZOOM_SCALE;
                            mMinZoomScaleFixed = false;
                        }
                    } else {
                        mMinZoomScale = restoreState.mMinScale;
                        mMinZoomScaleFixed = true;
                    }
                    if (restoreState.mMaxScale == 0) {
                        mMaxZoomScale = DEFAULT_MAX_ZOOM_SCALE;
                    } else {
                        mMaxZoomScale = restoreState.mMaxScale;
                    }
                    setNewZoomScale(mLastScale, false);
                    setContentScrollTo(restoreState.mScrollX, restoreState.mScrollY);
                    if (useWideViewport && settings.getLoadWithOverviewMode()) {
                        if (restoreState.mViewScale == 0 || (restoreState.mMobileSite && mMinZoomScale < restoreState.mDefaultScale)) {
                            mInZoomOverview = true;
                        }
                    }
                    // As we are on a new page, remove the WebTextView. This
                    // is necessary for page loads driven by webkit, and in
                    // particular when the user was on a password field, so
                    // the WebTextView was visible.
                    clearTextEntry();
                }
                // We update the layout (i.e. request a layout from the
                // view system) if the last view size that we sent to
                // WebCore matches the view size of the picture we just
                // received in the fixed dimension.
                final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
                recordNewContentSize(draw.mWidthHeight.x, draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0), updateLayout);
                if (DebugFlags.WEB_VIEW) {
                    Rect b = draw.mInvalRegion.getBounds();
                    Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
                }
                invalidateContentRect(draw.mInvalRegion.getBounds());
                if (mPictureListener != null) {
                    mPictureListener.onNewPicture(WebView.this, capturePicture());
                }
                if (useWideViewport) {
                    mZoomOverviewWidth = Math.max(draw.mMinPrefWidth, draw.mViewPoint.x);
                }
                if (!mMinZoomScaleFixed) {
                    mMinZoomScale = (float) viewWidth / mZoomOverviewWidth;
                }
                if (!mDrawHistory && mInZoomOverview) {
                    // the rounding error case.
                    if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
                        setNewZoomScale((float) viewWidth / mZoomOverviewWidth, false);
                    }
                }
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            nativeCreate(msg.arg1);
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.getData().getBoolean(""password"")) {
                    Spannable text = (Spannable) mWebTextView.getText();
                    int start = Selection.getSelectionStart(text);
                    int end = Selection.getSelectionEnd(text);
                    mWebTextView.setInPassword(true);
                    // Restore the selection, which may have been
                    // ruined by setInPassword.
                    Spannable pword = (Spannable) mWebTextView.getText();
                    Selection.setSelection(pword, start, end);
                // If the text entry has created more events, ignore
                // this one.
                } else if (msg.arg2 == mTextGeneration) {
                    mWebTextView.setTextAndKeepSelection((String) msg.obj);
                }
            }
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
                WebViewCore.TextSelectionData tData = (WebViewCore.TextSelectionData) msg.obj;
                mWebTextView.setSelectionFromWebKit(tData.mStart, tData.mEnd);
            }
            break;
        case MOVE_OUT_OF_PLUGIN:
            if (nativePluginEatsNavKey()) {
                navHandledKey(msg.arg1, 1, false, 0, true);
            }
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                mWebTextView.bringIntoView();
                rebuildWebTextView();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case UPDATE_CLIPBOARD:
            String str = (String) msg.obj;
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""UPDATE_CLIPBOARD "" + str);
            }
            try {
                IClipboard clip = IClipboard.Stub.asInterface(ServiceManager.getService(""clipboard""));
                clip.setClipboardText(str);
            } catch (android.os.RemoteException e) {
                Log.e(LOGTAG, ""Clipboard failed"", e);
            }
            break;
        case RESUME_WEBCORE_UPDATE:
            WebViewCore.resumeUpdate(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            // do nothing.
            if (getParent() != null) {
                performLongClick();
            }
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (msg.arg1 == MotionEvent.ACTION_DOWN) {
                // to time out
                if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                    mPreventDrag = msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
                    if (mPreventDrag == PREVENT_DRAG_YES) {
                        mTouchMode = TOUCH_DONE_MODE;
                    }
                }
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                // it won't block panning the page.
                if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                    mPreventDrag = PREVENT_DRAG_NO;
                }
                if (mTouchMode == TOUCH_INIT_MODE) {
                    mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                    updateSelection();
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (mPreventDrag == PREVENT_DRAG_NO) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                    rebuildWebTextView();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                if (mPreventDrag == PREVENT_DRAG_NO) {
                    mTouchMode = TOUCH_DONE_MODE;
                    doShortPress();
                }
                break;
            }
        case SCROLL_BY_MSG_ID:
            setContentScrollBy(msg.arg1, msg.arg2, (Boolean) msg.obj);
            break;
        case SYNC_SCROLL_TO_MSG_ID:
            if (mUserScroll) {
                // if user has scrolled explicitly, don't sync the
                // scroll position any more
                mUserScroll = false;
                break;
            }
        // fall through
        case SCROLL_TO_MSG_ID:
            if (setContentScrollTo(msg.arg1, msg.arg2)) {
                // if we can't scroll to the exact position due to pin,
                // send a message to WebCore to re-scroll when we get a
                // new picture
                mUserScroll = false;
                mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, msg.arg1, msg.arg2);
            }
            break;
        case SPAWN_SCROLL_TO_MSG_ID:
            spawnContentScrollTo(msg.arg1, msg.arg2);
            break;
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.RestoreState restoreState = (WebViewCore.RestoreState) msg.obj;
                // mScrollX contains the new minPrefWidth
                updateZoomRange(restoreState, getViewWidth(), restoreState.mScrollX, false);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                WebSettings settings = mWebViewCore.getSettings();
                // called for new content
                final int viewWidth = getViewWidth();
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                final Point viewSize = draw.mViewPoint;
                boolean useWideViewport = settings.getUseWideViewPort();
                WebViewCore.RestoreState restoreState = draw.mRestoreState;
                if (restoreState != null) {
                    mInZoomOverview = false;
                    updateZoomRange(restoreState, viewSize.x, draw.mMinPrefWidth, true);
                    if (mInitialScaleInPercent > 0) {
                        setNewZoomScale(mInitialScaleInPercent / 100.0f, mInitialScaleInPercent != mTextWrapScale * 100, false);
                    } else if (restoreState.mViewScale > 0) {
                        mTextWrapScale = restoreState.mTextWrapScale;
                        setNewZoomScale(restoreState.mViewScale, false, false);
                    } else {
                        mInZoomOverview = useWideViewport && settings.getLoadWithOverviewMode();
                        float scale;
                        if (mInZoomOverview) {
                            scale = (float) viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
                        } else {
                            scale = restoreState.mTextWrapScale;
                        }
                        setNewZoomScale(scale, Math.abs(scale - mTextWrapScale) >= 0.01f, false);
                    }
                    setContentScrollTo(restoreState.mScrollX, restoreState.mScrollY);
                    // As we are on a new page, remove the WebTextView. This
                    // is necessary for page loads driven by webkit, and in
                    // particular when the user was on a password field, so
                    // the WebTextView was visible.
                    clearTextEntry();
                }
                // We update the layout (i.e. request a layout from the
                // view system) if the last view size that we sent to
                // WebCore matches the view size of the picture we just
                // received in the fixed dimension.
                final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
                recordNewContentSize(draw.mWidthHeight.x, draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0), updateLayout);
                if (DebugFlags.WEB_VIEW) {
                    Rect b = draw.mInvalRegion.getBounds();
                    Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
                }
                invalidateContentRect(draw.mInvalRegion.getBounds());
                if (mPictureListener != null) {
                    mPictureListener.onNewPicture(WebView.this, capturePicture());
                }
                if (useWideViewport) {
                    mZoomOverviewWidth = Math.max((int) (viewWidth / mDefaultScale), Math.max(draw.mMinPrefWidth, draw.mViewPoint.x));
                }
                if (!mMinZoomScaleFixed) {
                    mMinZoomScale = (float) viewWidth / mZoomOverviewWidth;
                }
                if (!mDrawHistory && mInZoomOverview) {
                    // the rounding error case.
                    if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
                        setNewZoomScale((float) viewWidth / mZoomOverviewWidth, Math.abs(mActualScale - mTextWrapScale) < 0.01f, false);
                    }
                }
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            nativeCreate(msg.arg1);
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.getData().getBoolean(""password"")) {
                    Spannable text = (Spannable) mWebTextView.getText();
                    int start = Selection.getSelectionStart(text);
                    int end = Selection.getSelectionEnd(text);
                    mWebTextView.setInPassword(true);
                    // Restore the selection, which may have been
                    // ruined by setInPassword.
                    Spannable pword = (Spannable) mWebTextView.getText();
                    Selection.setSelection(pword, start, end);
                // If the text entry has created more events, ignore
                // this one.
                } else if (msg.arg2 == mTextGeneration) {
                    mWebTextView.setTextAndKeepSelection((String) msg.obj);
                }
            }
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
                WebViewCore.TextSelectionData tData = (WebViewCore.TextSelectionData) msg.obj;
                mWebTextView.setSelectionFromWebKit(tData.mStart, tData.mEnd);
            }
            break;
        case MOVE_OUT_OF_PLUGIN:
            if (nativePluginEatsNavKey()) {
                navHandledKey(msg.arg1, 1, false, 0, true);
            }
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                mWebTextView.bringIntoView();
                rebuildWebTextView();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case UPDATE_CLIPBOARD:
            String str = (String) msg.obj;
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""UPDATE_CLIPBOARD "" + str);
            }
            try {
                IClipboard clip = IClipboard.Stub.asInterface(ServiceManager.getService(""clipboard""));
                clip.setClipboardText(str);
            } catch (android.os.RemoteException e) {
                Log.e(LOGTAG, ""Clipboard failed"", e);
            }
            break;
        case RESUME_WEBCORE_UPDATE:
            WebViewCore.resumeUpdate(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            // do nothing.
            if (getParent() != null) {
                performLongClick();
            }
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (msg.arg1 == MotionEvent.ACTION_DOWN) {
                // to time out
                if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                    mPreventDrag = msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
                    if (mPreventDrag == PREVENT_DRAG_YES) {
                        mTouchMode = TOUCH_DONE_MODE;
                    }
                }
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case SHOW_RECT_MSG_ID:
            WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
            int x = mScrollX;
            int left = contentToViewDimension(data.mLeft);
            int width = contentToViewDimension(data.mWidth);
            int maxWidth = contentToViewDimension(data.mContentWidth);
            int viewWidth = getViewWidth();
            if (width < viewWidth) {
                // center align
                x += left + width / 2 - mScrollX - viewWidth / 2;
            } else {
                x += (int) (left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
            }
            // use the passing content width to cap x as the current
            // mContentWidth may not be updated yet
            x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
            int y = mScrollY;
            int top = contentToViewDimension(data.mTop);
            int height = contentToViewDimension(data.mHeight);
            int maxHeight = contentToViewDimension(data.mContentHeight);
            int viewHeight = getViewHeight();
            if (height < viewHeight) {
                // middle align
                y += top + height / 2 - mScrollY - viewHeight / 2;
            } else {
                y += (int) (top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
            }
            // use the passing content height to cap y as the current
            // mContentHeight may not be updated yet
            y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
            scrollTo(x, y);
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
53,"<android.view.View: void setFlags(int,int)>",6,7,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, set the DRAWN flag so that
                 * the next invalidate() will not be skipped.
                 */
            mPrivateFlags |= DRAWN;
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        invalidate();
        if (((mViewFlags & VISIBILITY_MASK) == GONE) && hasFocus()) {
            clearFocus();
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        invalidate();
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus
            if (getRootView() != this) {
                clearFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBGDrawable != null) {
                mPrivateFlags &= ~SKIP_DRAW;
                mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~SKIP_DRAW;
        }
        requestLayout();
        invalidate();
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null) {
            mParent.recomputeViewAttributes(this);
        }
    }
}","{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, set the DRAWN flag so that
                 * the next invalidate() will not be skipped.
                 */
            mPrivateFlags |= DRAWN;
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        invalidate();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            destroyDrawingCache();
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        invalidate();
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus
            if (getRootView() != this) {
                clearFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBGDrawable != null) {
                mPrivateFlags &= ~SKIP_DRAW;
                mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~SKIP_DRAW;
        }
        requestLayout();
        invalidate();
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null) {
            mParent.recomputeViewAttributes(this);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Some statement has changed between the two versions, specifically under ""if"" condition - a line ""destroyDrawingCache();"" is added to the late version's implementation so the change type is 4.","There is no Compatibility Issue as this change won't result in different return types/values or throw different exceptions between implementations. Therefore, the CI type is 0."
54,"<android.content.Intent: int fillIn(Intent,int)>",6,7,"<android.content.Intent: int fillIn(Intent,int)>","<android.content.Intent: int fillIn(Intent,int)>",0,"{
    int changes = 0;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new HashSet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        mPackage = other.mPackage;
        changes |= FILL_IN_PACKAGE;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    return changes;
}","{
    int changes = 0;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new HashSet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        mPackage = other.mPackage;
        changes |= FILL_IN_PACKAGE;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    return changes;
}",1,"/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data URI and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * and {@link #FILL_IN_COMPONENT} to override the restriction where the
 * corresponding field will not be replaced if it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT} is explicitly
 * specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * and {@link #FILL_IN_COMPONENT} indicating which fields were changed.
 */
","/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data URI and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * and {@link #FILL_IN_COMPONENT} to override the restriction where the
 * corresponding field will not be replaced if it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT} is explicitly
 * specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * and {@link #FILL_IN_COMPONENT} indicating which fields were changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The 'if' condition 'other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)' and its statement inside added in the late implementation, which involves both change of control dependency and adding new assignment statements. Thus, the change type would be 1,4.","The introduction of additional condition and assignment that depend on the 'mSourceBounds' field could change final value of 'changes' variable that is returned by the method. Hence, the CI type would be 1."
56,"<android.widget.TextView: boolean extractTextInternal(ExtractedTextRequest,int,int,int,ExtractedText)>",6,7,"<android.widget.TextView: boolean extractTextInternal(ExtractedTextRequest,int,int,int,ExtractedText)>","<android.widget.TextView: boolean extractTextInternal(ExtractedTextRequest,int,int,int,ExtractedText)>",0,"{
    final CharSequence content = mText;
    if (content != null) {
        if (partialStartOffset != EXTRACT_NOTHING) {
            final int N = content.length();
            if (partialStartOffset < 0) {
                outText.partialStartOffset = outText.partialEndOffset = -1;
                partialStartOffset = 0;
                partialEndOffset = N;
            } else {
                // Adjust offsets to ensure we contain full spans.
                if (content instanceof Spanned) {
                    Spanned spanned = (Spanned) content;
                    Object[] spans = spanned.getSpans(partialStartOffset, partialEndOffset, ParcelableSpan.class);
                    int i = spans.length;
                    while (i > 0) {
                        i--;
                        int j = spanned.getSpanStart(spans[i]);
                        if (j < partialStartOffset)
                            partialStartOffset = j;
                        j = spanned.getSpanEnd(spans[i]);
                        if (j > partialEndOffset)
                            partialEndOffset = j;
                    }
                }
                outText.partialStartOffset = partialStartOffset;
                outText.partialEndOffset = partialEndOffset;
                // Now use the delta to determine the actual amount of text
                // we need.
                partialEndOffset += delta;
                if (partialEndOffset > N) {
                    partialEndOffset = N;
                } else if (partialEndOffset < 0) {
                    partialEndOffset = 0;
                }
            }
            if ((request.flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) {
                outText.text = content.subSequence(partialStartOffset, partialEndOffset);
            } else {
                outText.text = TextUtils.substring(content, partialStartOffset, partialEndOffset);
            }
        }
        outText.flags = 0;
        if (MetaKeyKeyListener.getMetaState(mText, MetaKeyKeyListener.META_SELECTING) != 0) {
            outText.flags |= ExtractedText.FLAG_SELECTING;
        }
        if (mSingleLine) {
            outText.flags |= ExtractedText.FLAG_SINGLE_LINE;
        }
        outText.startOffset = 0;
        outText.selectionStart = Selection.getSelectionStart(content);
        outText.selectionEnd = Selection.getSelectionEnd(content);
        return true;
    }
    return false;
}","{
    final CharSequence content = mText;
    if (content != null) {
        if (partialStartOffset != EXTRACT_NOTHING) {
            final int N = content.length();
            if (partialStartOffset < 0) {
                outText.partialStartOffset = outText.partialEndOffset = -1;
                partialStartOffset = 0;
                partialEndOffset = N;
            } else {
                // Adjust offsets to ensure we contain full spans.
                if (content instanceof Spanned) {
                    Spanned spanned = (Spanned) content;
                    Object[] spans = spanned.getSpans(partialStartOffset, partialEndOffset, ParcelableSpan.class);
                    int i = spans.length;
                    while (i > 0) {
                        i--;
                        int j = spanned.getSpanStart(spans[i]);
                        if (j < partialStartOffset)
                            partialStartOffset = j;
                        j = spanned.getSpanEnd(spans[i]);
                        if (j > partialEndOffset)
                            partialEndOffset = j;
                    }
                }
                outText.partialStartOffset = partialStartOffset;
                outText.partialEndOffset = partialEndOffset;
                // Now use the delta to determine the actual amount of text
                // we need.
                partialEndOffset += delta;
                if (partialStartOffset > N) {
                    partialStartOffset = N;
                } else if (partialStartOffset < 0) {
                    partialStartOffset = 0;
                }
                if (partialEndOffset > N) {
                    partialEndOffset = N;
                } else if (partialEndOffset < 0) {
                    partialEndOffset = 0;
                }
            }
            if ((request.flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) {
                outText.text = content.subSequence(partialStartOffset, partialEndOffset);
            } else {
                outText.text = TextUtils.substring(content, partialStartOffset, partialEndOffset);
            }
        }
        outText.flags = 0;
        if (MetaKeyKeyListener.getMetaState(mText, MetaKeyKeyListener.META_SELECTING) != 0) {
            outText.flags |= ExtractedText.FLAG_SELECTING;
        }
        if (mSingleLine) {
            outText.flags |= ExtractedText.FLAG_SINGLE_LINE;
        }
        outText.startOffset = 0;
        outText.selectionStart = Selection.getSelectionStart(content);
        outText.selectionEnd = Selection.getSelectionEnd(content);
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The implementation of the method has been changed as there is an addition of IF condition that checks if the 'partialStartOffset' is greater than 'N'. The 'partialStartOffset' is then set to 'N' if this condition is met and set to 0 if 'partialStartOffset' is less than 0. This is a control dependency change, thus the code change type is 3.","This new condition checking 'partialStartOffset' can potentially change the return value of the method, leading to the possibility of the API returning a different value. Thus, the CI type is 1."
57,<android.server.BluetoothService: boolean createBond(String)>,6,7,<android.server.BluetoothService: boolean createBond(String)>,<android.server.BluetoothService: boolean createBond(String)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    address = address.toUpperCase();
    if (mBondState.getPendingOutgoingBonding() != null) {
        log(""Ignoring createBond(): another device is bonding"");
        // a different device is currently bonding, fail
        return false;
    }
    // pairing exponential back-off attempts.
    if (!mBondState.isAutoPairingAttemptsInProgress(address) && mBondState.getBondState(address) != BluetoothDevice.BOND_NONE) {
        log(""Ignoring createBond(): this device is already bonding or bonded"");
        return false;
    }
    if (!createPairedDeviceNative(address, 60000)) {
        return false;
    }
    mBondState.setPendingOutgoingBonding(address);
    mBondState.setBondState(address, BluetoothDevice.BOND_BONDING);
    return true;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    address = address.toUpperCase();
    if (mBondState.getPendingOutgoingBonding() != null) {
        log(""Ignoring createBond(): another device is bonding"");
        // a different device is currently bonding, fail
        return false;
    }
    // pairing exponential back-off attempts.
    if (!mBondState.isAutoPairingAttemptsInProgress(address) && mBondState.getBondState(address) != BluetoothDevice.BOND_NONE) {
        log(""Ignoring createBond(): this device is already bonding or bonded"");
        return false;
    }
    if (address.equals(mDockAddress)) {
        if (!writeDockPin()) {
            log(""Error while writing Pin for the dock"");
            return false;
        }
    }
    if (!createPairedDeviceNative(address, 60000)) {
        return false;
    }
    mBondState.setPendingOutgoingBonding(address);
    mBondState.setBondState(address, BluetoothDevice.BOND_BONDING);
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, two new control dependency statements are introduced: one is the 'if' condition statement with 'isEnabledInternal' and another 'if' condition statement that checks equality with 'mDockAddress'. Additionally, a new return statement `return false;` is added under both new condition statements. Therefore, the code change type is 1,3.","The introduction of new control statements and return false statements could potentially lead to a different returning value of the API between the two versions. Thus, the CI type is 1."
58,<android.webkit.WebView: boolean zoomIn()>,6,7,<android.webkit.WebView: boolean zoomIn()>,<android.webkit.WebView: boolean zoomIn()>,0,"{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    // Center zooming to the center of the screen.
    if (mInZoomOverview) {
        // if in overview mode, bring it back to normal mode
        mLastTouchX = getViewWidth() * .5f;
        mLastTouchY = getViewHeight() * .5f;
        doDoubleTap();
        return true;
    } else {
        mZoomCenterX = getViewWidth() * .5f;
        mZoomCenterY = getViewHeight() * .5f;
        return zoomWithPreview(mActualScale * 1.25f);
    }
}","{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    mInZoomOverview = false;
    // Center zooming to the center of the screen.
    mZoomCenterX = getViewWidth() * .5f;
    mZoomCenterY = getViewHeight() * .5f;
    mAnchorX = viewToContentX((int) mZoomCenterX + mScrollX);
    mAnchorY = viewToContentY((int) mZoomCenterY + mScrollY);
    return zoomWithPreview(mActualScale * 1.25f);
}",1,"/**
 * Perform zoom in in the webview
 * @return TRUE if zoom in succeeds. FALSE if no zoom changes.
 */
","/**
 * Perform zoom in in the webview
 * @return TRUE if zoom in succeeds. FALSE if no zoom changes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control statement in the form of if-else and the return statement inside the if block (doDoubleTap(), return true) are removed. New variables assignment statements are added and the return statement remains the same. Hence, the type of code change is 1,3. ","Since the branching control statement is removed and the associated return statement within the if branch is deleted as well, the potential return value of the method has been changed in late version. Thus, it can be a potential cause for a compatibility issue, and therefore CI type is 1."
60,"<android.server.BluetoothService: boolean setPasskey(String,int)>",6,7,"<android.server.BluetoothService: boolean setPasskey(String,int)>","<android.server.BluetoothService: boolean setPasskey(String,int)>",0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (passkey < 0 || passkey > 999999 || !BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    address = address.toUpperCase();
    Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
    if (data == null) {
        Log.w(TAG, ""setPasskey("" + address + "") called but no native data available, "" + ""ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device"" + "" or by bluez.\n"");
        return false;
    }
    return setPasskeyNative(address, passkey, data.intValue());
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    if (passkey < 0 || passkey > 999999 || !BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    address = address.toUpperCase();
    Integer data = mEventLoop.getPasskeyAgentRequestData().remove(address);
    if (data == null) {
        Log.w(TAG, ""setPasskey("" + address + "") called but no native data available, "" + ""ignoring. Maybe the PasskeyAgent Request was cancelled by the remote device"" + "" or by bluez.\n"");
        return false;
    }
    return setPasskeyNative(address, passkey, data.intValue());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"An additional boolean check with '!isEnabledInternal()' has been added in the late version before the logic. Also, the method 'isEnabledInternal()' is a dependent API which is not present in the early version. Hence, the code change types are 3 and 5.","The new check '!isEnabledInternal()' could possibly lead to a different return value because if '!isEnabledInternal' returns false, the API ends prematurely in the late version, but not in the early version. Thus, the CI type is 1."
