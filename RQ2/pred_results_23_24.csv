Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,<android.os.BaseBundle: void readFromParcelInner(Parcel)>,23,24,<android.os.BaseBundle: void readFromParcelInner(Parcel)>,<android.os.BaseBundle: void readFromParcelInner(Parcel)>,0,"{
    int length = parcel.readInt();
    if (length < 0) {
        throw new RuntimeException(""Bad length in parcel: "" + length);
    }
    readFromParcelInner(parcel, length);
}","{
    // Keep implementation in sync with readFromParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    int length = parcel.readInt();
    readFromParcelInner(parcel, length);
}",1,"/**
 * Reads the Parcel contents into this Bundle, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */
","/**
 * Reads the Parcel contents into this Bundle, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement that throws a RuntimeException if 'length' is less than 0 has been removed, resulting in a code change type of 2.","The removal of the exception handling statement means that the late version no longer throws a RuntimeException for the case where 'length' is less than 0. This is a behavioural change that could lead to compatibility issues, so the CI type is 2."
1,"<android.app.admin.DevicePolicyManager: void setMaximumTimeToLock(ComponentName,long)>",23,24,"<android.app.admin.DevicePolicyManager: void setMaximumTimeToLock(ComponentName,long)>","<android.app.admin.DevicePolicyManager: void setMaximumTimeToLock(ComponentName,long)>",0,"{
    if (mService != null) {
        try {
            mService.setMaximumTimeToLock(admin, timeMs);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setMaximumTimeToLock(admin, timeMs, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * maximum time for user activity until the device will lock.  This limits
 * the length that the user can set.  It takes effect immediately.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeMs The new desired maximum time to lock in milliseconds.
 * A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the maximum time for user
 * activity until the device will lock. This limits the length that the user can set. It takes
 * effect immediately.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 * to be able to call this method; if it has not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeMs The new desired maximum time to lock in milliseconds. A value of 0 means there
 * is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or it does not use
 * {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","There's a change in the dependent API called within `setMaximumTimeToLock` as the parameters list has changed by adding `mParentInstance`, and there is also a change in exception handling as the catch block now throws the exception instead of just logging it. Thus, the code change types are 2 and 5.","Due to the change in the parameter list of the dependent API, a Compatibility Issue could arise if the updated API has different behavior or if the mParentInstance affects the outcome. Additionally, the change in exception handling means that the method can now throw exceptions where it did not before, which is another potential Compatibility Issue. The CI types are 1, due to possible different return values or types (throw is considered a return type in this context), and 2, due to potential different exception handlings."
2,<android.content.res.Resources: CharSequence getText(int)>,23,24,<android.content.res.Resources: CharSequence getText(int)>,<android.content.res.Resources: CharSequence getText(int)>,0,"{
    CharSequence res = mAssets.getResourceText(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""String resource ID #0x"" + Integer.toHexString(id));
}","{
    CharSequence res = mResourcesImpl.getAssets().getResourceText(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""String resource ID #0x"" + Integer.toHexString(id));
}",1,"/**
 * Return the string value associated with a particular resource ID.  The
 * returned object will be a String if this is a plain string; it will be
 * some other type of CharSequence if it is styled.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return CharSequence The string data associated with the resource, plus
 * possibly styled text information.
 */
","/**
 * Return the string value associated with a particular resource ID.  The
 * returned object will be a String if this is a plain string; it will be
 * some other type of CharSequence if it is styled.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return CharSequence The string data associated with the resource, plus
 * possibly styled text information.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from using `mAssets` to `mResourcesImpl.getAssets()` to get the resource text, which is a change in the dependent API. Thus, the code change type is 4,5.","Even though there's a change in the dependent API, since the logic of the method has not been altered and the return value or exception thrown would not change as a result of this modification (assuming that mResourcesImpl.getAssets() is a refactored version of mAssets and still returns the same objects), no compatibility issue is anticipated. So the CI type is 0."
3,<android.app.ActivityManager.AppTask: void finishAndRemoveTask()>,23,24,<android.app.ActivityManager.AppTask: void finishAndRemoveTask()>,<android.app.ActivityManager.AppTask: void finishAndRemoveTask()>,0,"{
    try {
        mAppTaskImpl.finishAndRemoveTask();
    } catch (RemoteException e) {
        Slog.e(TAG, ""Invalid AppTask"", e);
    }
}","{
    try {
        mAppTaskImpl.finishAndRemoveTask();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Finishes all activities in this task and removes it from the recent tasks list.
 */
","/**
 * Finishes all activities in this task and removes it from the recent tasks list.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from logging the RemoteException to throwing the RemoteException with the method call e.rethrowFromSystemServer(), so the change type is 2.","The change in exception handling will cause the late version of the API potentially to throw a different exception rather than just logging it, so the CI type is 2."
5,"<android.print.PrinterCapabilitiesInfo.Builder: Builder setDuplexModes(int,int)>",23,24,"<android.print.PrinterCapabilitiesInfo.Builder: Builder setDuplexModes(int,int)>","<android.print.PrinterCapabilitiesInfo.Builder: Builder setDuplexModes(int,int)>",0,"{
    int currentModes = duplexModes;
    while (currentModes > 0) {
        final int currentMode = (1 << Integer.numberOfTrailingZeros(currentModes));
        currentModes &= ~currentMode;
        PrintAttributes.enforceValidDuplexMode(currentMode);
    }
    PrintAttributes.enforceValidDuplexMode(defaultDuplexMode);
    mPrototype.mDuplexModes = duplexModes;
    mPrototype.mDefaults[PROPERTY_DUPLEX_MODE] = defaultDuplexMode;
    return this;
}","{
    enforceValidMask(duplexModes, (currentMode) -> PrintAttributes.enforceValidDuplexMode(currentMode));
    PrintAttributes.enforceValidDuplexMode(defaultDuplexMode);
    mPrototype.mDuplexModes = duplexModes;
    mPrototype.mDefaults[PROPERTY_DUPLEX_MODE] = defaultDuplexMode;
    return this;
}",1,"/**
 * Sets the duplex modes.
 * <p>
 * <strong>Required:</strong> No
 * </p>
 *
 * @param duplexModes The duplex mode bit mask.
 * @param defaultDuplexMode The default duplex mode.
 * @return This builder.
 *
 * @throws IllegalArgumentException If duplex modes contains an invalid
 * mode bit or if the default duplex mode is invalid.
 *
 * @see PrintAttributes#DUPLEX_MODE_NONE
 * @see PrintAttributes#DUPLEX_MODE_LONG_EDGE
 * @see PrintAttributes#DUPLEX_MODE_SHORT_EDGE
 */
","/**
 * Sets the duplex modes.
 * <p>
 * <strong>Required:</strong> No
 * </p>
 *
 * @param duplexModes The duplex mode bit mask.
 * @param defaultDuplexMode The default duplex mode.
 * @return This builder.
 *
 * @throws IllegalArgumentException If duplex modes contains an invalid
 * mode bit or if the default duplex mode is invalid.
 *
 * @see PrintAttributes#DUPLEX_MODE_NONE
 * @see PrintAttributes#DUPLEX_MODE_LONG_EDGE
 * @see PrintAttributes#DUPLEX_MODE_SHORT_EDGE
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method internals have changed; the while loop block has been replaced by a method call enforceValidMask() that abstracts the iteration and validation logic, which is a clear change in control flow and implementation, and there's a visible change in the return type due to the addition of the @NonNull annotation. Also, enforceValidMask might represent a dependent API change if its implementation affects the current method's behavior. These changes are therefore classified as 1 (Return statement changed as there is a new annotation indicating the returned value can't be null), 4 (Other statement changed), and 5 (Dependent API changed).","The newly introduced @NonNull annotation might make the API to return a different value when null used to be returned earlier, and the change in logic with the enforceValidMask method could result in a different behavior if that method throws an exception or operates differently. Thus the potential for a different return value or type exists, and there is a CI type 1."
6,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int,int[])>",23,24,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int,int[])>","<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int,int[])>",0,"{
    final int len = attrs.length;
    final TypedArray array = TypedArray.obtain(Resources.this, len);
    array.mTheme = this;
    if (false) {
        int[] data = array.mData;
        System.out.println(""**********************************************************"");
        System.out.println(""**********************************************************"");
        System.out.println(""**********************************************************"");
        System.out.println(""Attributes:"");
        String s = ""  Attrs:"";
        int i;
        for (i = 0; i < attrs.length; i++) {
            s = s + "" 0x"" + Integer.toHexString(attrs[i]);
        }
        System.out.println(s);
        s = ""  Found:"";
        TypedValue value = new TypedValue();
        for (i = 0; i < attrs.length; i++) {
            int d = i * AssetManager.STYLE_NUM_ENTRIES;
            value.type = data[d + AssetManager.STYLE_TYPE];
            value.data = data[d + AssetManager.STYLE_DATA];
            value.assetCookie = data[d + AssetManager.STYLE_ASSET_COOKIE];
            value.resourceId = data[d + AssetManager.STYLE_RESOURCE_ID];
            s = s + "" 0x"" + Integer.toHexString(attrs[i]) + ""="" + value;
        }
        System.out.println(s);
    }
    AssetManager.applyStyle(mTheme, 0, resid, 0, attrs, array.mData, array.mIndices);
    return array;
}","{
    return mThemeImpl.obtainStyledAttributes(this, null, attrs, 0, resId);
}",1,"/**
 * Return a TypedArray holding the values defined by the style
 * resource <var>resid</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param resid The desired style resource.
 * @param attrs The desired attributes in the style.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
","/**
 * Return a TypedArray holding the values defined by the style
 * resource <var>resid</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param resId The desired style resource.
 * @param attrs The desired attributes in the style.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed from a series of operations and a manual call to AssetManager.applyStyle() to a single call to mThemeImpl.obtainStyledAttributes(). The internal logic of creating the TypedArray and applying styles has been moved to another method and possibly another object, which implies a change in dependent APIs as well. The presence of code for debug purposes (printing to System.out) in the early version has been removed in the late version, so this is also considered an ""Other statement changed"" type of change, 4. So, the changes involve return statement modification, dependent API change, and other statement changes, which correspond to types 1,4,5 respectively.","The new implementation delegates the behavior to mThemeImpl.obtainStyledAttributes(), which may have different implementation details, which means the TypedArray returned can potentially have different values, or initialization details. Especially since the early version manually constructs and initializes the TypedArray, while the late version uses a different method call to achieve this, suggesting different internal behaviors. Therefore, this change introduces a Compatibility Issue of type 1, due to potentially different return values."
8,"<android.app.admin.DevicePolicyManager: boolean setPermissionGrantState(ComponentName,String,String,int)>",23,24,"<android.app.admin.DevicePolicyManager: boolean setPermissionGrantState(ComponentName,String,String,int)>","<android.app.admin.DevicePolicyManager: boolean setPermissionGrantState(ComponentName,String,String,int)>",0,"{
    try {
        return mService.setPermissionGrantState(admin, packageName, permission, grantState);
    } catch (RemoteException re) {
        Log.w(TAG, ""Failed talking with device policy service"", re);
        return false;
    }
}","{
    throwIfParentInstance(""setPermissionGrantState"");
    try {
        return mService.setPermissionGrantState(admin, packageName, permission, grantState);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the grant state of a runtime permission for a specific application. The state
 * can be {@link #PERMISSION_GRANT_STATE_DEFAULT default} in which a user can manage it
 * through the UI, {@link #PERMISSION_GRANT_STATE_DENIED denied}, in which the permission
 * is denied and the user cannot manage it through the UI, and {@link
 * #PERMISSION_GRANT_STATE_GRANTED granted} in which the permission is granted and the
 * user cannot manage it through the UI. This might affect all permissions in a
 * group that the runtime permission belongs to. This method can only be called
 * by a profile or device owner.
 *
 * <p/>Setting the grant state to {@link #PERMISSION_GRANT_STATE_DEFAULT default} does not
 * revoke the permission. It retains the previous grant, if any.
 *
 * <p/>Permissions can be granted or revoked only for applications built with a
 * {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param packageName The application to grant or revoke a permission to.
 * @param permission The permission to grant or revoke.
 * @param grantState The permission grant state which is one of {@link
 * #PERMISSION_GRANT_STATE_DENIED}, {@link #PERMISSION_GRANT_STATE_DEFAULT},
 * {@link #PERMISSION_GRANT_STATE_GRANTED},
 * @return whether the permission was successfully granted or revoked.
 *
 * @see #PERMISSION_GRANT_STATE_DENIED
 * @see #PERMISSION_GRANT_STATE_DEFAULT
 * @see #PERMISSION_GRANT_STATE_GRANTED
 */
","/**
 * Sets the grant state of a runtime permission for a specific application. The state can be
 * {@link #PERMISSION_GRANT_STATE_DEFAULT default} in which a user can manage it through the UI,
 * {@link #PERMISSION_GRANT_STATE_DENIED denied}, in which the permission is denied and the user
 * cannot manage it through the UI, and {@link #PERMISSION_GRANT_STATE_GRANTED granted} in which
 * the permission is granted and the user cannot manage it through the UI. This might affect all
 * permissions in a group that the runtime permission belongs to. This method can only be called
 * by a profile or device owner.
 * <p/>
 * Setting the grant state to {@link #PERMISSION_GRANT_STATE_DEFAULT default} does not revoke
 * the permission. It retains the previous grant, if any.
 * <p/>
 * Permissions can be granted or revoked only for applications built with a
 * {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param packageName The application to grant or revoke a permission to.
 * @param permission The permission to grant or revoke.
 * @param grantState The permission grant state which is one of
 * {@link #PERMISSION_GRANT_STATE_DENIED}, {@link #PERMISSION_GRANT_STATE_DEFAULT},
 * {@link #PERMISSION_GRANT_STATE_GRANTED},
 * @return whether the permission was successfully granted or revoked.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #PERMISSION_GRANT_STATE_DENIED
 * @see #PERMISSION_GRANT_STATE_DEFAULT
 * @see #PERMISSION_GRANT_STATE_GRANTED
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The introduction of `throwIfParentInstance(""setPermissionGrantState"");` represents a new conditional check which changes the flow control and a new exception handling statement (`throw re.rethrowFromSystemServer();`) was added in place of just logging the exception and returning false. Therefore, the change types are 2 (exception handling statement changed) and 4 (other statement changed).","The removal of the previous `return false;` in the case of an exception and replacement with `throw re.rethrowFromSystemServer();`, changes the exception handling behavior of the API method. Previously, it caught the `RemoteException` and simply returned false, hiding the exception from the caller, whereas in the late version, it now throws the exception after wrapping it with `rethrowFromSystemServer`, which will affect the caller. Therefore, the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
9,<android.app.admin.DevicePolicyManager: String[] getAccountTypesWithManagementDisabled()>,23,24,<android.app.admin.DevicePolicyManager: String[] getAccountTypesWithManagementDisabled()>,<android.app.admin.DevicePolicyManager: String[] getAccountTypesWithManagementDisabled()>,0,"{
    return getAccountTypesWithManagementDisabledAsUser(UserHandle.myUserId());
}","{
    throwIfParentInstance(""getAccountTypesWithManagementDisabled"");
    return getAccountTypesWithManagementDisabledAsUser(myUserId());
}",1,"/**
 * Gets the array of accounts for which account management is disabled by the profile owner.
 *
 * <p> Account management can be disabled/enabled by calling
 * {@link #setAccountManagementDisabled}.
 *
 * @return a list of account types for which account management has been disabled.
 *
 * @see #setAccountManagementDisabled
 */
","/**
 * Gets the array of accounts for which account management is disabled by the profile owner.
 *
 * <p> Account management can be disabled/enabled by calling
 * {@link #setAccountManagementDisabled}.
 *
 * @return a list of account types for which account management has been disabled.
 *
 * @see #setAccountManagementDisabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"A new method call, throwIfParentInstance(""getAccountTypesWithManagementDisabled""), has been added before the existing return statement. Moreover, the myUserId() has changed from being called with the UserHandle prefix. The code change type consists of an exception handling statement changed (2), an other statement changed (4), and a dependent API changed due to the modification of how myUserId() is invoked (5).","The addition of a new exception handling statement, throwIfParentInstance, means that a new precondition check is in place and can lead to a new potential exception being thrown before the usual return statement. This indicates a different exception behaviour, so the CI type is 2."
11,<android.app.ContextImpl: void unregisterReceiver(BroadcastReceiver)>,23,24,<android.app.ContextImpl: void unregisterReceiver(BroadcastReceiver)>,<android.app.ContextImpl: void unregisterReceiver(BroadcastReceiver)>,0,"{
    if (mPackageInfo != null) {
        IIntentReceiver rd = mPackageInfo.forgetReceiverDispatcher(getOuterContext(), receiver);
        try {
            ActivityManagerNative.getDefault().unregisterReceiver(rd);
        } catch (RemoteException e) {
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}","{
    if (mPackageInfo != null) {
        IIntentReceiver rd = mPackageInfo.forgetReceiverDispatcher(getOuterContext(), receiver);
        try {
            ActivityManagerNative.getDefault().unregisterReceiver(rd);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling for `RemoteException` has changed from an empty catch block to throwing a new exception via `rethrowFromSystemServer()`, leading to a change in the exception handling statement; this is a change type of 2.","Exception handling has potentially changed because `RemoteException` is no longer swallowed; it is now being rethrown as a different exception using `rethrowFromSystemServer()`. This could lead to a different behavior when the exception occurs, as it is no longer being ignored, so the CI type is 2."
13,<android.animation.AnimatorSet.Node: Node clone()>,23,24,<android.animation.AnimatorSet.Node: Node clone()>,<android.animation.AnimatorSet.Node: Node clone()>,0,"{
    try {
        Node node = (Node) super.clone();
        node.animation = animation.clone();
        node.done = false;
        return node;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}","{
    try {
        Node node = (Node) super.clone();
        node.mAnimation = mAnimation.clone();
        if (mChildNodes != null) {
            node.mChildNodes = new ArrayList<>(mChildNodes);
        }
        if (mSiblings != null) {
            node.mSiblings = new ArrayList<>(mSiblings);
        }
        if (mParents != null) {
            node.mParents = new ArrayList<>(mParents);
        }
        node.mEnded = false;
        return node;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The structure of the Node class appears to have changed between these versions with additional fields for child nodes, siblings, and parents, as seen from assigning new ArrayLists to mChildNodes, mSiblings, and mParents, and by renaming done to mEnded and animation to mAnimation. Therefore, the code change includes changes in other statements (class member assignments), so the change type is 1,4.","The change in the structure of Node class means that the returned Node object from the clone method might contain different data. Because new fields are now being cloned and the existing fields have been renamed and are being cloned differently, which affects the returned object, we can deduce that the potential behavior of the clone API can result in a different return value. Hence the CI type is 1."
15,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",23,24,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>","<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",0,"{
    SetCommand s = sSetCommandMap.get(key);
    if (s != null) {
        s.setValue(this, value);
        return;
    }
    setBase(key, value);
}","{
    set(key.getNativeKey(), value);
}",1,"/**
 * Set a camera metadata field to a value. The field definitions can be
 * found in {@link CameraCharacteristics}, {@link CaptureResult}, and
 * {@link CaptureRequest}.
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */
",,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early implementation utilized a command map to identify a SetCommand associated with the key and then set the value if found; otherwise, it would call setBase. The late version directly calls a different set method with 'key.getNativeKey()' and 'value' as arguments. The code change type is 4 and 5 because the entire structure of the method is altered, and it now depends on a new or modified set method.","Despite the significant code change, since the method signature remains the same and no new return statements or exception handling code has been introduced, it does not necessarily lead to a CI in terms of the method's external behavior. Hence, the CI situation is 0, assuming that the underlying 'set' implementation in the late version will handle all keys and values appropriately, similar to the combination of the command map and setBase in the early version."
17,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> editProperties(String,Activity,AccountManagerCallback<Bundle>,Handler)>",23,24,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> editProperties(String,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> editProperties(String,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.editProperties(mResponse, accountType, activity != null);
        }
    }.start();
}","{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.editProperties(mResponse, accountType, activity != null);
        }
    }.start();
}",1,"/**
 * Offers the user an opportunity to change an authenticator's settings.
 * These properties are for the authenticator in general, not a particular
 * account.  Not all authenticators support this method.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to have the same signature as the
 * authenticator associated with the specified account type.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param accountType The account type associated with the authenticator
 * to adjust
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to adjust authenticator settings;
 * used only to call startActivity(); if null, the settings dialog will
 * not be launched directly, but the necessary {@link Intent} will be
 * returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * which is empty if properties were edited successfully, or
 * if no activity was specified, contains only {@link #KEY_INTENT}
 * needed to launch the authenticator's settings dialog.
 * If an error occurred, {@link AccountManagerFuture#getResult()}
 * throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the settings dialog
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * updating settings, usually because of network trouble
 * </ul>
 */
","/**
 * Offers the user an opportunity to change an authenticator's settings.
 * These properties are for the authenticator in general, not a particular
 * account.  Not all authenticators support this method.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to have the same signature as the
 * authenticator associated with the specified account type.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param accountType The account type associated with the authenticator
 * to adjust
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to adjust authenticator settings;
 * used only to call startActivity(); if null, the settings dialog will
 * not be launched directly, but the necessary {@link Intent} will be
 * returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * which is empty if properties were edited successfully, or
 * if no activity was specified, contains only {@link #KEY_INTENT}
 * needed to launch the authenticator's settings dialog.
 * If an error occurred, {@link AccountManagerFuture#getResult()}
 * throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the settings dialog
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * updating settings, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"No changes were made to the actual implementation of the method; the only difference is the addition of the `@Override` annotation, which does not affect the execution flow or behavior of the method.","Since there are no changes in the execution behavior of the method, there is no compatibility issue."
18,<android.app.ContextImpl: File getNoBackupFilesDir()>,23,24,<android.app.ContextImpl: File getNoBackupFilesDir()>,<android.app.ContextImpl: File getNoBackupFilesDir()>,0,"{
    synchronized (mSync) {
        if (mNoBackupFilesDir == null) {
            mNoBackupFilesDir = new File(getDataDirFile(), ""no_backup"");
        }
        return createFilesDirLocked(mNoBackupFilesDir);
    }
}","{
    synchronized (mSync) {
        if (mNoBackupFilesDir == null) {
            mNoBackupFilesDir = new File(getDataDir(), ""no_backup"");
        }
        return ensurePrivateDirExists(mNoBackupFilesDir);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to get the data directory has changed from getDataDirFile() to getDataDir(), and the method called to ensure the directory exists has changed from createFilesDirLocked(mNoBackupFilesDir) to ensurePrivateDirExists(mNoBackupFilesDir), so the code change type is 4,5.","Despite the changes in internal method calls, the purpose and contract of the method getNoBackupFilesDir() remain unchanged; it still provides a File object for the no_backup directory. There is no change to the return type, and the method is expected to still return a valid File object for the same intended directory, so there is no compatibility issue, and the CI type is 0."
19,<android.app.Fragment: void performCreate(Bundle)>,23,24,<android.app.Fragment: void performCreate(Bundle)>,<android.app.Fragment: void performCreate(Bundle)>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
    }
    mCalled = false;
    onCreate(savedInstanceState);
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onCreate()"");
    }
    if (savedInstanceState != null) {
        Parcelable p = savedInstanceState.getParcelable(Activity.FRAGMENTS_TAG);
        if (p != null) {
            if (mChildFragmentManager == null) {
                instantiateChildFragmentManager();
            }
            mChildFragmentManager.restoreAllState(p, null);
            mChildFragmentManager.dispatchCreate();
        }
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
    }
    mState = CREATED;
    mCalled = false;
    onCreate(savedInstanceState);
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onCreate()"");
    }
    final Context context = getContext();
    final int version = context != null ? context.getApplicationInfo().targetSdkVersion : 0;
    if (version < Build.VERSION_CODES.N) {
        restoreChildFragmentState(savedInstanceState, false);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The implementation has seen several changes. An assignment statement for 'mState' was introduced and the block that handles 'savedInstanceState' was replaced with a call to 'restoreChildFragmentState(savedIstanceState, false)' under a certain condition. Additionally, new local variables 'context' and 'version' have been introduced to check SDK version compatibility. As such, the change types here include return statement changed (1), control dependency changed (3), and other statement changed (4).","Despite these changes, there is no Compatibility Issue because the overall behavior of the method remains the same in terms of how it is expected to react given any potential input. The contract of the method (e.g., exceptions thrown, expected results) does not seem to be altered as there are no changes that would affect the return value or the types of exceptions thrown under normal operation (assuming 'restoreChildFragmentState' method has the same behavior as the replaced code, which is a safe assumption since it's an internal change aimed to refactor the code without altering its functionality)."
20,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> hasFeatures(Account,String[],AccountManagerCallback<Boolean>,Handler)>",23,24,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> hasFeatures(Account,String[],AccountManagerCallback<Boolean>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Boolean> hasFeatures(Account,String[],AccountManagerCallback<Boolean>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (features == null)
        throw new IllegalArgumentException(""features is null"");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.hasFeatures(mResponse, account, features, mContext.getOpPackageName());
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (features == null)
        throw new IllegalArgumentException(""features is null"");
    return new Future2Task<Boolean>(handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.hasFeatures(mResponse, account, features, mContext.getOpPackageName());
        }

        @Override
        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}",1,"/**
 * Finds out whether a particular account has all the specified features.
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties.  For example, features are used to tell
 * whether Google accounts have a particular service (such as Google
 * Calendar or Google Talk) enabled.  The feature names and their meanings
 * are published somewhere associated with the authenticator in question.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS} or be a signature
 * match with the AbstractAccountAuthenticator that manages the account.
 *
 * @param account The {@link Account} to test
 * @param features An array of the account features to check
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account exists and has all of the specified features.
 */
","/**
 * Finds out whether a particular account has all the specified features.
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties.  For example, features are used to tell
 * whether Google accounts have a particular service (such as Google
 * Calendar or Google Talk) enabled.  The feature names and their meanings
 * are published somewhere associated with the authenticator in question.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS} or be a signature
 * match with the AbstractAccountAuthenticator that manages the account.
 *
 * @param account The {@link Account} to test
 * @param features An array of the account features to check
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account exists and has all of the specified features.
 */
",-1,[@RequiresPermission(GET_ACCOUNTS)],[@RequiresPermission(GET_ACCOUNTS)],-1,-1,-1,-1,-1,-1,0,0,"There is no actual change to the implementation of the method. Only the annotation `@Override` has been added, which does not affect the behavior of the method.","Since there is no change in the actual implementation or the behavior of the method, there is no compatibility issue."
21,"<android.util.Log: int v(String,String,Throwable)>",23,24,"<android.util.Log: int v(String,String,Throwable)>","<android.util.Log: int v(String,String,Throwable)>",0,"{
    return println_native(LOG_ID_MAIN, VERBOSE, tag, msg + '\n' + getStackTraceString(tr));
}","{
    return printlns(LOG_ID_MAIN, VERBOSE, tag, msg, tr);
}",1,"/**
 * Send a {@link #VERBOSE} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #VERBOSE} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation changes from calling println_native with concatenated strings to calling printlns with separate parameters, and a dependent API printlns is now being used instead of println_native. This introduces a change in the parameters passed to the logging method, so the code change type is 1 for the return statement, 4 for other statements changed, and 5 for the dependent API changed.","The change in the API used for logging (println_native to printlns) and the way the message and throwable are passed to the logging method could potentially lead to a different return value due to the altered handling of the input parameters. Therefore, the CI type is 1 due to the potential for a different return value."
22,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,23,24,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,0,"{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // and torch statuses will be updated.
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(STATUS_NOT_PRESENT, cameraId);
        }
        for (int i = 0; i < mTorchStatus.size(); i++) {
            String cameraId = mTorchStatus.keyAt(i);
            onTorchStatusChangedLocked(TORCH_STATUS_NOT_AVAILABLE, cameraId);
        }
        scheduleCameraServiceReconnectionLocked();
    }
}","{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // and torch statuses will be updated.
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, cameraId);
        }
        for (int i = 0; i < mTorchStatus.size(); i++) {
            String cameraId = mTorchStatus.keyAt(i);
            onTorchStatusChangedLocked(ICameraServiceListener.TORCH_STATUS_NOT_AVAILABLE, cameraId);
        }
        scheduleCameraServiceReconnectionLocked();
    }
}",1,"/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
","/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change in the late version is in the constants used as arguments in the methods `onStatusChangedLocked()` and `onTorchStatusChangedLocked()`. They are changed from `STATUS_NOT_PRESENT` and `TORCH_STATUS_NOT_AVAILABLE` to `ICameraServiceListener.STATUS_NOT_PRESENT` and `ICameraServiceListener.TORCH_STATUS_NOT_AVAILABLE`, respectively. This indicates the reference to constants has been updated, possibly to improve readability or maintainability, assuming the values of these constants are unchanged. So the code change type is 4.","As the constants used should not change the value that these methods work with (given they still represent the same statuses), there should be no compatibility issue arising from this change. Therefore, the CI type is 0."
24,"<android.widget.Editor.TextActionModeCallback: void onGetContentRect(ActionMode,View,Rect)>",23,24,"<android.widget.Editor.TextActionModeCallback: void onGetContentRect(ActionMode,View,Rect)>","<android.widget.Editor.TextActionModeCallback: void onGetContentRect(ActionMode,View,Rect)>",0,"{
    if (!view.equals(mTextView) || mTextView.getLayout() == null) {
        super.onGetContentRect(mode, view, outRect);
        return;
    }
    if (mTextView.getSelectionStart() != mTextView.getSelectionEnd()) {
        // We have a selection.
        mSelectionPath.reset();
        mTextView.getLayout().getSelectionPath(mTextView.getSelectionStart(), mTextView.getSelectionEnd(), mSelectionPath);
        mSelectionPath.computeBounds(mSelectionBounds, true);
        mSelectionBounds.bottom += mHandleHeight;
    } else if (mCursorCount == 2) {
        // We have a split cursor. In this case, we take the rectangle that includes both
        // parts of the cursor to ensure we don't obscure either of them.
        Rect firstCursorBounds = mCursorDrawable[0].getBounds();
        Rect secondCursorBounds = mCursorDrawable[1].getBounds();
        mSelectionBounds.set(Math.min(firstCursorBounds.left, secondCursorBounds.left), Math.min(firstCursorBounds.top, secondCursorBounds.top), Math.max(firstCursorBounds.right, secondCursorBounds.right), Math.max(firstCursorBounds.bottom, secondCursorBounds.bottom) + mHandleHeight);
    } else {
        // We have a single cursor.
        Layout layout = getActiveLayout();
        int line = layout.getLineForOffset(mTextView.getSelectionStart());
        float primaryHorizontal = layout.getPrimaryHorizontal(mTextView.getSelectionStart());
        mSelectionBounds.set(primaryHorizontal, layout.getLineTop(line), primaryHorizontal, layout.getLineTop(line + 1) + mHandleHeight);
    }
    // Take TextView's padding and scroll into account.
    int textHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    int textVerticalOffset = mTextView.viewportToContentVerticalOffset();
    outRect.set((int) Math.floor(mSelectionBounds.left + textHorizontalOffset), (int) Math.floor(mSelectionBounds.top + textVerticalOffset), (int) Math.ceil(mSelectionBounds.right + textHorizontalOffset), (int) Math.ceil(mSelectionBounds.bottom + textVerticalOffset));
}","{
    if (!view.equals(mTextView) || mTextView.getLayout() == null) {
        super.onGetContentRect(mode, view, outRect);
        return;
    }
    if (mTextView.getSelectionStart() != mTextView.getSelectionEnd()) {
        // We have a selection.
        mSelectionPath.reset();
        mTextView.getLayout().getSelectionPath(mTextView.getSelectionStart(), mTextView.getSelectionEnd(), mSelectionPath);
        mSelectionPath.computeBounds(mSelectionBounds, true);
        mSelectionBounds.bottom += mHandleHeight;
    } else if (mCursorCount == 2) {
        // We have a split cursor. In this case, we take the rectangle that includes both
        // parts of the cursor to ensure we don't obscure either of them.
        Rect firstCursorBounds = mCursorDrawable[0].getBounds();
        Rect secondCursorBounds = mCursorDrawable[1].getBounds();
        mSelectionBounds.set(Math.min(firstCursorBounds.left, secondCursorBounds.left), Math.min(firstCursorBounds.top, secondCursorBounds.top), Math.max(firstCursorBounds.right, secondCursorBounds.right), Math.max(firstCursorBounds.bottom, secondCursorBounds.bottom) + mHandleHeight);
    } else {
        // We have a single cursor.
        Layout layout = mTextView.getLayout();
        int line = layout.getLineForOffset(mTextView.getSelectionStart());
        float primaryHorizontal = clampHorizontalPosition(null, layout.getPrimaryHorizontal(mTextView.getSelectionStart()));
        mSelectionBounds.set(primaryHorizontal, layout.getLineTop(line), primaryHorizontal, layout.getLineTop(line + 1) + mHandleHeight);
    }
    // Take TextView's padding and scroll into account.
    int textHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    int textVerticalOffset = mTextView.viewportToContentVerticalOffset();
    outRect.set((int) Math.floor(mSelectionBounds.left + textHorizontalOffset), (int) Math.floor(mSelectionBounds.top + textVerticalOffset), (int) Math.ceil(mSelectionBounds.right + textHorizontalOffset), (int) Math.ceil(mSelectionBounds.bottom + textVerticalOffset));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change is related to how the primaryHorizontal value is computed. In the late version, clampHorizontalPosition(null, layout.getPrimaryHorizontal(mTextView.getSelectionStart())) is used instead of layout.getPrimaryHorizontal(mTextView.getSelectionStart()). There's no visible change to return statements, exception handling, or dependent API, but there is a change in other statements and a control dependency due to the different method of calculation used. Thus, the change types are 3 and 4.","The change does not result in a different return value or type, nor an exception handling change that could lead to a Compatibility Issue; the algorithm for computing 'primaryHorizontal' has indeed changed, but the nature of the method 'getPrimaryHorizontal' and 'clampHorizontalPosition' suggests that they will both return a valid horizontal position for the cursor. Therefore, there is no CI detected, which is indicated by 0."
25,<android.net.ConnectivityManager: boolean isDefaultNetworkActive()>,23,24,<android.net.ConnectivityManager: boolean isDefaultNetworkActive()>,<android.net.ConnectivityManager: boolean isDefaultNetworkActive()>,0,"{
    try {
        return getNetworkManagementService().isNetworkActive();
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return getNetworkManagementService().isNetworkActive();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return whether the data network is currently active.  An active network means that
 * it is currently in a high power state for performing data transmission.  On some
 * types of networks, it may be expensive to move and stay in such a state, so it is
 * more power efficient to batch network traffic together when the radio is already in
 * this state.  This method tells you whether right now is currently a good time to
 * initiate network traffic, as the network is already active.
 */
","/**
 * Return whether the data network is currently active.  An active network means that
 * it is currently in a high power state for performing data transmission.  On some
 * types of networks, it may be expensive to move and stay in such a state, so it is
 * more power efficient to batch network traffic together when the radio is already in
 * this state.  This method tells you whether right now is currently a good time to
 * initiate network traffic, as the network is already active.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement is changed where the catch block in the early version does nothing and returns false, while the catch block in the late version throws a wrapped exception with throw e.rethrowFromSystemServer(), so the code change type is 2.","Because of the newly introduced throw statement, the late version could potentially cause the method to throw a different exception, leading to a change in the method's exception flow. Therefore, there is a compatibility issue caused by potential different exception handlings, and the CI type is 2."
26,<android.os.Binder: UserHandle getCallingUserHandle()>,23,24,<android.os.Binder: UserHandle getCallingUserHandle()>,<android.os.Binder: UserHandle getCallingUserHandle()>,0,"{
    return new UserHandle(UserHandle.getUserId(getCallingUid()));
}","{
    return UserHandle.of(UserHandle.getUserId(getCallingUid()));
}",1,"/**
 * Return the UserHandle assigned to the process that sent you the
 * current transaction that is being processed.  This is the user
 * of the caller.  It is distinct from {@link #getCallingUid()} in that a
 * particular user will have multiple distinct apps running under it each
 * with their own uid.  If the current thread is not currently executing an
 * incoming transaction, then its own UserHandle is returned.
 */
","/**
 * Return the UserHandle assigned to the process that sent you the
 * current transaction that is being processed.  This is the user
 * of the caller.  It is distinct from {@link #getCallingUid()} in that a
 * particular user will have multiple distinct apps running under it each
 * with their own uid.  If the current thread is not currently executing an
 * incoming transaction, then its own UserHandle is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The difference between the two implementations lies in the use of a different constructor/method to create a UserHandle object. Initially, it uses `new UserHandle(...)` and in the later version, it uses `UserHandle.of(...)`. Since both constructors are likely to return the same instance of UserHandle for the same UID, this change is classified as 'Other statement changed' and does not affect the returned value, hence no return statement change.","There is no CI caused by this change because the action of getting the calling UserHandle should semantically be the same. The same UserHandle should be returned from both constructors, assuming the 'of' method is meant to replace the direct use of the constructor and serves simply as a static factory method that most likely returns an equivalent instance to the new expression. Therefore, the behavior of the API remains unchanged."
27,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,23,24,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final int count = event.getPointerCount();
    final boolean isStylusButtonDown = (event.getButtonState() & MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;
    final boolean anchoredScaleCancelled = mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS && !isStylusButtonDown;
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        } else if (inAnchoredScaleMode() && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    if (!mInProgress && mStylusScaleEnabled && !inAnchoredScaleMode() && !streamComplete && isStylusButtonDown) {
        // Start of a button scale gesture
        mAnchoredScaleStartX = event.getX();
        mAnchoredScaleStartY = event.getY();
        mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;
        mInitialSpan = 0;
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (inAnchoredScaleMode()) {
        // In anchored scale mode, the focal pt is always where the double tap
        // or button down gesture started
        focusX = mAnchoredScaleStartX;
        focusY = mAnchoredScaleStartY;
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inAnchoredScaleMode()) {
        span = spanY;
    } else {
        span = (float) Math.hypot(spanX, spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inAnchoredScaleMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inAnchoredScaleMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final int count = event.getPointerCount();
    final boolean isStylusButtonDown = (event.getButtonState() & MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;
    final boolean anchoredScaleCancelled = mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS && !isStylusButtonDown;
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        } else if (inAnchoredScaleMode() && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        }
        if (streamComplete) {
            return true;
        }
    }
    if (!mInProgress && mStylusScaleEnabled && !inAnchoredScaleMode() && !streamComplete && isStylusButtonDown) {
        // Start of a button scale gesture
        mAnchoredScaleStartX = event.getX();
        mAnchoredScaleStartY = event.getY();
        mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;
        mInitialSpan = 0;
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (inAnchoredScaleMode()) {
        // In anchored scale mode, the focal pt is always where the double tap
        // or button down gesture started
        focusX = mAnchoredScaleStartX;
        focusY = mAnchoredScaleStartY;
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        devSumX += Math.abs(event.getX(i) - focusX);
        devSumY += Math.abs(event.getY(i) - focusY);
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inAnchoredScaleMode()) {
        span = spanY;
    } else {
        span = (float) Math.hypot(spanX, spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inAnchoredScaleMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inAnchoredScaleMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}",1,"/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
","/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
28,"<android.app.Notification.Builder: Builder setSmallIcon(int,int)>",23,24,"<android.app.Notification.Builder: Builder setSmallIcon(int,int)>","<android.app.Notification.Builder: Builder setSmallIcon(int,int)>",0,"{
    mSmallIconLevel = level;
    return setSmallIcon(icon);
}","{
    mN.iconLevel = level;
    return setSmallIcon(icon);
}",1,"/**
 * A variant of {@link #setSmallIcon(int) setSmallIcon(int)} that takes an additional
 * level parameter for when the icon is a {@link android.graphics.drawable.LevelListDrawable
 * LevelListDrawable}.
 *
 * @param icon A resource ID in the application's package of the drawable to use.
 * @param level The level to use for the icon.
 *
 * @see Notification#icon
 * @see Notification#iconLevel
 */
","/**
 * A variant of {@link #setSmallIcon(int) setSmallIcon(int)} that takes an additional
 * level parameter for when the icon is a {@link android.graphics.drawable.LevelListDrawable
 * LevelListDrawable}.
 *
 * @param icon A resource ID in the application's package of the drawable to use.
 * @param level The level to use for the icon.
 *
 * @see Notification#icon
 * @see Notification#iconLevel
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The assignment statement has changed from `mSmallIconLevel = level` to `mN.iconLevel = level`. ,"There is no Compatibility Issue as the change is internal and does not affect the behavior of the `setSmallIcon(int,int)` method. Both versions assign a level and then call `setSmallIcon(icon)`, which means the behavior observed by a caller would not be altered by this change."
29,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLowerCase(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLowerCase(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLowerCase(ComponentName)>,0,"{
    return getPasswordMinimumLowerCase(admin, UserHandle.myUserId());
}","{
    return getPasswordMinimumLowerCase(admin, myUserId());
}",1,"/**
 * Retrieve the current number of lower case letters required in the
 * password for all admins of this user and its profiles or a particular one.
 * This is the same value as set by
 * {#link {@link #setPasswordMinimumLowerCase(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of lower case letters required in the
 * password.
 */
","/**
 * Retrieve the current number of lower case letters required in the password
 * for a particular admin or all admins that set retrictions on this user
 * and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 * This is the same value as set by
 * {@link #setPasswordMinimumLowerCase(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of lower case letters required in the
 * password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is only a method call change from UserHandle.myUserId() to myUserId(), without changing the control flow or return value, so the code change type is 5.","Since both early and late implementations ultimately make a call to getPasswordMinimumLowerCase() with the value returned from UserHandle.myUserId() or myUserId() as a parameter and that the logic of getPasswordMinimumLowerCase() is not provided, no change in the behavior of the API would be expected unless the method myUserId() has different behavior than UserHandle.myUserId(). Therefore, without evidence of such a change in behavior, we assume no compatibility issue, thus the CI type is 0."
30,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,0,"{
    return isAdminActiveAsUser(admin, UserHandle.myUserId());
}","{
    return isAdminActiveAsUser(admin, myUserId());
}",1,"/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */
","/**
 * Return true if the given administrator component is currently active (enabled) in the system.
 *
 * @param admin The administrator component to check for.
 * @return {@code true} if {@code admin} is currently enabled in the system, {@code false}
 * otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within the return statement changed from UserHandle.myUserId() to myUserId(), so the code change type is 5 (Dependent API changed).","There is no Compatibility Issue detected as the change is an internal call to a potentially equivalent method that presumably returns the same value as before, there is no change to the semantics or the return type of the method; therefore, the behavior of the API should remain unchanged."
32,<android.app.ActivityManager: void clearWatchHeapLimit()>,23,24,<android.app.ActivityManager: void clearWatchHeapLimit()>,<android.app.ActivityManager: void clearWatchHeapLimit()>,0,"{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, 0, null);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, 0, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Clear a heap watch limit previously set by {@link #setWatchHeapLimit(long)}.
 */
","/**
 * Clear a heap watch limit previously set by {@link #setWatchHeapLimit(long)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has been changed, adding a throw statement in the catch block, so the change type is 2.","The introduction of a throw statement within the catch block (throw e.rethrowFromSystemServer()) indicates that the exception will not be silently ignored as before, but will be rethrown to be handled by the system server. This change potentially leads to different exception handling behaviour in the new version of the API, so the CI type is 2."
35,<android.os.Parcel: void writeException(Exception)>,23,24,<android.os.Parcel: void writeException(Exception)>,<android.os.Parcel: void writeException(Exception)>,0,"{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}","{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    } else if (e instanceof ServiceSpecificException) {
        code = EX_SERVICE_SPECIFIC;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
    if (e instanceof ServiceSpecificException) {
        writeInt(((ServiceSpecificException) e).errorCode);
    }
}",1,"/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
","/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"There is an introduction of a new exception handling for ServiceSpecificException, and assignment of a new error code, as well as a new 'writeInt' statement for the errorCode of ServiceSpecificException. These represent a control dependency change, an other statement change, and an exception handling statement change, so the change types are 2,3,4.","As there is a new exception handling branch introduced for ServiceSpecificException that did not exist before, the API could potentially throw a new type of exception (specifically, a ServiceSpecificException with the errorCode being written into the Parcel), or handle exceptions differently. A CI is evident since this new branch alters the exception handling behavior of the API, therefore the CI type is 2."
36,<android.widget.GridLayout: LayoutParams generateLayoutParams(LayoutParams)>,23,24,<android.widget.GridLayout: LayoutParams generateLayoutParams(LayoutParams)>,<android.widget.GridLayout: LayoutParams generateLayoutParams(LayoutParams)>,0,"{
    return new LayoutParams(p);
}","{
    if (lp instanceof LayoutParams) {
        return new LayoutParams((LayoutParams) lp);
    } else if (lp instanceof MarginLayoutParams) {
        return new LayoutParams((MarginLayoutParams) lp);
    } else {
        return new LayoutParams(lp);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late implementation introduces a control structure to check the exact type of LayoutParams and use different constructors accordingly, resulting in a control dependency change. Additionally, it changes how the return object is constructed, which is a return statement change. Thus, the code change types are 1 and 3.","Because there's a new evaluation of the type of the input 'LayoutParams', which could result in different 'LayoutParams' being returned, this can lead to a Compatibility Issue due to potentially different return values. Therefore, the type is 1."
37,<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,23,24,<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,0,"{
    if (mService == null) {
        return Bundle.EMPTY;
    }
    try {
        return mService.getAppWidgetOptions(mPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return Bundle.EMPTY;
    }
    try {
        return mService.getAppWidgetOptions(mPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the extras associated with a given widget instance.
 * <p>
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #updateAppWidgetOptions(int, Bundle)
 *
 * @param appWidgetId The AppWidget instances for which to set the RemoteViews.
 * @return The options associated with the given widget instance.
 */
","/**
 * Get the extras associated with a given widget instance.
 * <p>
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #updateAppWidgetOptions(int, Bundle)
 *
 * @param appWidgetId The AppWidget instances for which to set the RemoteViews.
 * @return The options associated with the given widget instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing rethrowFromSystemServer(), so the change type is 2.","As the exception handling statement has been modified, it may cause the method to throw a different exception type in the late version, which could lead to a CI type of 2."
38,<android.bluetooth.BluetoothAdapter: int getScanMode()>,23,24,<android.bluetooth.BluetoothAdapter: int getScanMode()>,<android.bluetooth.BluetoothAdapter: int getScanMode()>,0,"{
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getScanMode();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return SCAN_MODE_NONE;
}","{
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getScanMode();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return SCAN_MODE_NONE;
}",1,"/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return scan mode
 */
","/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return scan mode
 */
",-1,"[@RequiresPermission(Manifest.permission.BLUETOOTH), @ScanMode]","[@RequiresPermission(Manifest.permission.BLUETOOTH), @ScanMode]",-1,-1,-1,-1,-1,-1,"3,4",0,"The change is in how the lock is managed around the call to mService.getScanMode(). The early implementation used synchronized on mManagerCallback, while the late implementation uses a ReadWriteLock held by mServiceLock.readLock() to guard this call. This is a change in the locking mechanism, so the code change is categorized as 3,4 (Control dependency changed, Other statement changed).","Even though there is a structural change in how concurrency is managed, the logical flow and outcome of the method should remain the same. The method still returns the same values for the same conditions, and exception handling is not affected by this change. This implies the behavior witnessed from outside should be consistent, therefore there is no compatibility issue, leading to pred_CI being 0."
39,<android.speech.tts.TextToSpeechService.SynthesisToFileOutputStreamSpeechItemV1: AbstractSynthesisCallback createSynthesisCallback()>,23,24,<android.speech.tts.TextToSpeechService.SynthesisToFileOutputStreamSpeechItemV1: AbstractSynthesisCallback createSynthesisCallback()>,<android.speech.tts.TextToSpeechService.SynthesisToFileOutputStreamSpeechItemV1: AbstractSynthesisCallback createSynthesisCallback()>,0,"{
    return new FileSynthesisCallback(mFileOutputStream.getChannel(), this, getCallerIdentity(), false);
}","{
    return new FileSynthesisCallback(mFileOutputStream.getChannel(), this, false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor call to FileSynthesisCallback has changed. In the early version it takes four parameters, while in the late version it only takes three. Therefore, the change type is 1,5 since it involves both a return statement change and a dependent API change.","The constructor's signature of the FileSynthesisCallback has changed, which means it may potentially return a different type of AbstractSynthesisCallback object or with different behavior due to a missing parameter. This can lead to a Compatibility Issue of the type 1, where the return value or type may differ between versions."
40,<android.content.pm.PackageInstaller: List<SessionInfo> getAllSessions()>,23,24,<android.content.pm.PackageInstaller: List<SessionInfo> getAllSessions()>,<android.content.pm.PackageInstaller: List<SessionInfo> getAllSessions()>,0,"{
    final ApplicationInfo info = mContext.getApplicationInfo();
    if (""com.google.android.googlequicksearchbox"".equals(info.packageName) && info.versionCode <= 300400110) {
        Log.d(TAG, ""Ignoring callback request from old prebuilt"");
        return Collections.EMPTY_LIST;
    }
    try {
        return mInstaller.getAllSessions(mUserId).getList();
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        return mInstaller.getAllSessions(mUserId).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return list of all known install sessions, regardless of the installer.
 */
","/**
 * Return list of all known install sessions, regardless of the installer.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency has changed with removal of code that checks the `ApplicationInfo`. Moreover, there's a change in the exception handling statement from `rethrowAsRuntimeException()` to `rethrowFromSystemServer()`. Since a return statement (`return Collections.EMPTY_LIST`) has been removed, the code change types are 1, 3.","The API potentially returns a different variable because the condition check for the package name and version code along with its associated return statement has been removed; this could lead to returning a non-empty list when previously an empty list would be returned. Therefore, the CI type is 1."
41,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,23,24,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The signature of the method that is called within try block has changed. The late version no longer passes `service.getType()`, `service.getInstanceId()`, and `new ParcelUuid(service.getUuid())` to `mService.writeCharacteristic`. Therefore, a dependent API has been altered, which results in code change type 5.","Because the underlying method `mService.writeCharacteristic` has a different signature and potentially different implementation, this could lead to return different behaviour when writing to the BluetoothGattCharacteristic. Consequently, a Compatibility Issue arises due to potential different return values or types, so CI type is 1."
42,<android.app.admin.DevicePolicyManager: boolean getCrossProfileCallerIdDisabled(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean getCrossProfileCallerIdDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getCrossProfileCallerIdDisabled(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getCrossProfileCallerIdDisabled(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""getCrossProfileCallerIdDisabled"");
    if (mService != null) {
        try {
            return mService.getCrossProfileCallerIdDisabled(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by a profile owner of a managed profile to determine whether or not caller-Id
 * information has been disabled.
 *
 * <p>The calling device admin must be a profile owner. If it is not, a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 */
","/**
 * Called by a profile owner of a managed profile to determine whether or not caller-Id
 * information has been disabled.
 * <p>
 * The calling device admin must be a profile owner. If it is not, a security exception will be
 * thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional method call to `throwIfParentInstance(""getCrossProfileCallerIdDisabled"")` is inserted at the beginning of the late implementation. This is a new statement outside of the control flow or return mechanisms, so the code change type is 4.","There is no Compatibility Issue detected as this new method call does not affect the return type or value, nor does it change the exception handling in a way that affects the publicly-facing behavior or contract of the method. It seems to be an internal check added before proceeding with the rest of the method's logic. The rest of the code, including the return statement and exception handling, remains the same. Therefore, the CI type is 0."
43,<android.widget.Editor.PinnedPopupWindow: void hide()>,23,24,<android.widget.Editor.PinnedPopupWindow: void hide()>,<android.widget.Editor.PinnedPopupWindow: void hide()>,0,"{
    mPopupWindow.dismiss();
    getPositionListener().removeSubscriber(this);
}","{
    if (!isShowing()) {
        return;
    }
    mPopupWindow.dismiss();
    getPositionListener().removeSubscriber(this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new control structure 'if (!isShowing())' with a return statement has been added, which is a control dependency change, so the code change type is 3.","The new control check 'if (!isShowing())' is checking to see if the popup is already not showing, and if so, it early returns from the method. Since the additional check prevents the rest of the method from executing when the popup is not showing, it doesn't alter the behavior compared to the early version (where the dismissal would be a noop if the popup wasn't showing). As the rest of the method's instructions remain intact and executed in the same way when the popup is showing, there is no Compatibility Issue, hence the CI type is 0."
44,<android.net.LocalSocketImpl.SocketInputStream: int available()>,23,24,<android.net.LocalSocketImpl.SocketInputStream: int available()>,<android.net.LocalSocketImpl.SocketInputStream: int available()>,0,"{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    return available_native(myFd);
}","{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    MutableInt avail = new MutableInt(0);
    try {
        Os.ioctlInt(myFd, OsConstants.FIONREAD, avail);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
    return avail.value;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The implementation has changed from using a native method (available_native) to using Os.ioctlInt with a subsequent exception handling statement (catching ErrnoException and throwing IOException). This involves changing the mechanism to determine the available bytes and introducing new exception handling, so the change type is 1 (due to the new return value), 2 (due to the new exception handling structure), and 5 (reliance on the new Os.ioctlInt method which is a dependent API).","The change in both the way of determining the available bytes to read from the input stream and the exception handling mechanism could lead to the API returning different values and throwing different exceptions under certain conditions. Therefore, the CI type is both 1 (potential different return values) and 2 (potential different exception handlings)."
45,<android.view.inputmethod.InputMethodManager: boolean shouldOfferSwitchingToNextInputMethod(IBinder)>,23,24,<android.view.inputmethod.InputMethodManager: boolean shouldOfferSwitchingToNextInputMethod(IBinder)>,<android.view.inputmethod.InputMethodManager: boolean shouldOfferSwitchingToNextInputMethod(IBinder)>,0,"{
    synchronized (mH) {
        try {
            return mService.shouldOfferSwitchingToNextInputMethod(imeToken);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
            return false;
        }
    }
}","{
    synchronized (mH) {
        try {
            return mService.shouldOfferSwitchingToNextInputMethod(imeToken);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Returns true if the current IME needs to offer the users ways to switch to a next input
 * method (e.g. a globe key.).
 * When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
 * the IME has to offer ways to to invoke {@link #switchToNextInputMethod} accordingly.
 * <p> Note that the system determines the most appropriate next input method
 * and subtype in order to provide the consistent user experience in switching
 * between IMEs and subtypes.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 */
","/**
 * Returns true if the current IME needs to offer the users ways to switch to a next input
 * method (e.g. a globe key.).
 * When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
 * the IME has to offer ways to to invoke {@link #switchToNextInputMethod} accordingly.
 * <p> Note that the system determines the most appropriate next input method
 * and subtype in order to provide the consistent user experience in switching
 * between IMEs and subtypes.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed; it changes from logging the exception and returning false to throwing the exception (throw e.rethrowFromSystemServer()), so the change type is 2.","Since the method in the late version now throws an exception instead of swallowing it and returning false, the behavior is significantly different when an exception occurs, which can cause a Compatibility Issue. Therefore, the CI type is 2."
46,"<android.app.admin.DevicePolicyManager: boolean removeCrossProfileWidgetProvider(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: boolean removeCrossProfileWidgetProvider(ComponentName,String)>","<android.app.admin.DevicePolicyManager: boolean removeCrossProfileWidgetProvider(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            return mService.removeCrossProfileWidgetProvider(admin, packageName);
        } catch (RemoteException re) {
            Log.w(TAG, ""Error calling removeCrossProfileWidgetProvider"", re);
        }
    }
    return false;
}","{
    throwIfParentInstance(""removeCrossProfileWidgetProvider"");
    if (mService != null) {
        try {
            return mService.removeCrossProfileWidgetProvider(admin, packageName);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by the profile owner of a managed profile to disable widget providers from a given
 * package to be available in the parent profile. For this method to take effect the
 * package should have been added via {@link #addCrossProfileWidgetProvider(
 * android.content.ComponentName, String)}.
 * <p>
 * <strong>Note:</strong> By default no widget provider package is white-listed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The package from which widget providers are no longer
 * white-listed.
 * @return Whether the package was removed.
 *
 * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)
 * @see #getCrossProfileWidgetProviders(android.content.ComponentName)
 */
","/**
 * Called by the profile owner of a managed profile to disable widget providers from a given
 * package to be available in the parent profile. For this method to take effect the package
 * should have been added via
 * {@link #addCrossProfileWidgetProvider( android.content.ComponentName, String)}.
 * <p>
 * <strong>Note:</strong> By default no widget provider package is white-listed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The package from which widget providers are no longer white-listed.
 * @return Whether the package was removed.
 * @throws SecurityException if {@code admin} is not a profile owner.
 * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)
 * @see #getCrossProfileWidgetProviders(android.content.ComponentName)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The method now contains a new call ""throwIfParentInstance"" outside of the try block which was not present in the early version, and also it changes the exception handling mechanism replacing a log statement with a throw statement, so the changes include the categories 2 and 4.","The introduction of a new potential throw statement (throwIfParentInstance) could lead to a different exception being thrown than in the early version (where this call is absent). Additionally, changing the exception handling mechanism in the catch block to throw an exception instead of logging an error can cause the late version to propagate exceptions differently compared to just logging them in the early version. Therefore, this introduces the possibility of different exception handling, and the CI type is 2."
47,<android.content.res.Resources: Configuration getConfiguration()>,23,24,<android.content.res.Resources: Configuration getConfiguration()>,<android.content.res.Resources: Configuration getConfiguration()>,0,"{
    return mConfiguration;
}","{
    return mResourcesImpl.getConfiguration();
}",1,"/**
 * Return the current configuration that is in effect for this resource
 * object.  The returned object should be treated as read-only.
 *
 * @return The resource's current configuration.
 */
","/**
 * Return the current configuration that is in effect for this resource
 * object.  The returned object should be treated as read-only.
 *
 * @return The resource's current configuration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation calls a different method (mResourcesImpl.getConfiguration()) instead of directly returning the member variable mConfiguration, hence the code change is of type 5.","As the return type and value are determined by the internal implementation of the getConfiguration() method, assuming the behavior of mResourcesImpl.getConfiguration() is internally consistent with returning mConfiguration directly, there would be no Compatibility Issue in terms of return type or value. Therefore, there are no Compatibility Issues detected based on the given information."
48,<android.widget.PopupWindow: void dismiss()>,23,24,<android.widget.PopupWindow: void dismiss()>,<android.widget.PopupWindow: void dismiss()>,0,"{
    if (!isShowing() || mIsTransitioningToDismiss) {
        return;
    }
    final PopupDecorView decorView = mDecorView;
    final View contentView = mContentView;
    final ViewGroup contentHolder;
    final ViewParent contentParent = contentView.getParent();
    if (contentParent instanceof ViewGroup) {
        contentHolder = ((ViewGroup) contentParent);
    } else {
        contentHolder = null;
    }
    // Ensure any ongoing or pending transitions are canceled.
    decorView.cancelTransitions();
    mIsShowing = false;
    mIsTransitioningToDismiss = true;
    final Transition exitTransition = mExitTransition;
    if (exitTransition != null && decorView.isLaidOut()) {
        // The decor view is non-interactive during exit transitions.
        final LayoutParams p = (LayoutParams) decorView.getLayoutParams();
        p.flags |= LayoutParams.FLAG_NOT_TOUCHABLE;
        p.flags |= LayoutParams.FLAG_NOT_FOCUSABLE;
        mWindowManager.updateViewLayout(decorView, p);
        final Rect epicenter = getRelativeAnchorBounds();
        exitTransition.setEpicenterCallback(new EpicenterCallback() {

            @Override
            public Rect onGetEpicenter(Transition transition) {
                return epicenter;
            }
        });
        decorView.startExitTransition(exitTransition, new TransitionListenerAdapter() {

            @Override
            public void onTransitionEnd(Transition transition) {
                dismissImmediate(decorView, contentHolder, contentView);
            }
        });
    } else {
        dismissImmediate(decorView, contentHolder, contentView);
    }
    // Clears the anchor view.
    unregisterForScrollChanged();
    if (mOnDismissListener != null) {
        mOnDismissListener.onDismiss();
    }
}","{
    if (!isShowing() || mIsTransitioningToDismiss) {
        return;
    }
    final PopupDecorView decorView = mDecorView;
    final View contentView = mContentView;
    final ViewGroup contentHolder;
    final ViewParent contentParent = contentView.getParent();
    if (contentParent instanceof ViewGroup) {
        contentHolder = ((ViewGroup) contentParent);
    } else {
        contentHolder = null;
    }
    // Ensure any ongoing or pending transitions are canceled.
    decorView.cancelTransitions();
    mIsShowing = false;
    mIsTransitioningToDismiss = true;
    // This method may be called as part of window detachment, in which
    // case the anchor view (and its root) will still return true from
    // isAttachedToWindow() during execution of this method; however, we
    // can expect the OnAttachStateChangeListener to have been called prior
    // to executing this method, so we can rely on that instead.
    final Transition exitTransition = mExitTransition;
    if (mIsAnchorRootAttached && exitTransition != null && decorView.isLaidOut()) {
        // The decor view is non-interactive and non-IME-focusable during exit transitions.
        final LayoutParams p = (LayoutParams) decorView.getLayoutParams();
        p.flags |= LayoutParams.FLAG_NOT_TOUCHABLE;
        p.flags |= LayoutParams.FLAG_NOT_FOCUSABLE;
        p.flags &= ~LayoutParams.FLAG_ALT_FOCUSABLE_IM;
        mWindowManager.updateViewLayout(decorView, p);
        // Once we start dismissing the decor view, all state (including
        // the anchor root) needs to be moved to the decor view since we
        // may open another popup while it's busy exiting.
        final View anchorRoot = mAnchorRoot != null ? mAnchorRoot.get() : null;
        final Rect epicenter = getTransitionEpicenter();
        exitTransition.setEpicenterCallback(new EpicenterCallback() {

            @Override
            public Rect onGetEpicenter(Transition transition) {
                return epicenter;
            }
        });
        decorView.startExitTransition(exitTransition, anchorRoot, new TransitionListenerAdapter() {

            @Override
            public void onTransitionEnd(Transition transition) {
                dismissImmediate(decorView, contentHolder, contentView);
            }
        });
    } else {
        dismissImmediate(decorView, contentHolder, contentView);
    }
    // Clears the anchor view.
    detachFromAnchor();
    if (mOnDismissListener != null) {
        mOnDismissListener.onDismiss();
    }
}",1,"/**
 * Disposes of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing
 * that, calling this method will have no effect.
 *
 * @see #showAsDropDown(android.view.View)
 */
","/**
 * Disposes of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing
 * that, calling this method will have no effect.
 *
 * @see #showAsDropDown(android.view.View)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency and other statement have changed by adding a new condition check (mIsAnchorRootAttached) before the transition block, modifying the flag unset (p.flags &= ~LayoutParams.FLAG_ALT_FOCUSABLE_IM;) and changing the arguments of the method call to startExitTransition (added anchorRoot and changed call signature).",#CI_description
49,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,23,24,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"2,4,5",2,"There is a change in the method call intent.prepareToLeaveProcess(), where the late version adds 'this' as an argument. Additionally, the catch block is modified to throw a different exception with the throw e.rethrowFromSystemServer() instead of throw new RuntimeException(). The changes fall under exception handling statement changed (2), other statement changed due to the parameter change (4), and dependent API changed (5) because a method called on an object of type Intent now has a different signature.","The change in the exception handling from throwing a generic RuntimeException to rethrowFromSystemServer() could cause the method to throw different types of exceptions when encountering a RemoteException, which represents a change in behavior causing a compatibility issue (CI type 2)."
50,"<android.hardware.input.InputManager: void registerInputDeviceListener(InputDeviceListener,Handler)>",23,24,"<android.hardware.input.InputManager: void registerInputDeviceListener(InputDeviceListener,Handler)>","<android.hardware.input.InputManager: void registerInputDeviceListener(InputDeviceListener,Handler)>",0,"{
    if (listener == null) {
        throw new IllegalArgumentException(""listener must not be null"");
    }
    synchronized (mInputDevicesLock) {
        int index = findInputDeviceListenerLocked(listener);
        if (index < 0) {
            mInputDeviceListeners.add(new InputDeviceListenerDelegate(listener, handler));
        }
    }
}","{
    if (listener == null) {
        throw new IllegalArgumentException(""listener must not be null"");
    }
    synchronized (mInputDevicesLock) {
        populateInputDevicesLocked();
        int index = findInputDeviceListenerLocked(listener);
        if (index < 0) {
            mInputDeviceListeners.add(new InputDeviceListenerDelegate(listener, handler));
        }
    }
}",1,"/**
 * Registers an input device listener to receive notifications about when
 * input devices are added, removed or changed.
 *
 * @param listener The listener to register.
 * @param handler The handler on which the listener should be invoked, or null
 * if the listener should be invoked on the calling thread's looper.
 *
 * @see #unregisterInputDeviceListener
 */
","/**
 * Registers an input device listener to receive notifications about when
 * input devices are added, removed or changed.
 *
 * @param listener The listener to register.
 * @param handler The handler on which the listener should be invoked, or null
 * if the listener should be invoked on the calling thread's looper.
 *
 * @see #unregisterInputDeviceListener
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call populateInputDevicesLocked() has been added within the synchronized block, so the code change type is 4.","Since the populateInputDevicesLocked() method appears to be related to updating or populating the state relevant to input devices, and there is no change in the value being returned or the exception being thrown (the signature and exception handling remain the same), this change should not lead to a compatibility issue."
51,<android.accounts.AccountManager: boolean removeAccountExplicitly(Account)>,23,24,<android.accounts.AccountManager: boolean removeAccountExplicitly(Account)>,<android.accounts.AccountManager: boolean removeAccountExplicitly(Account)>,0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.removeAccountExplicitly(account);
    } catch (RemoteException e) {
        // May happen if the caller doesn't match the signature of the authenticator.
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.removeAccountExplicitly(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Removes an account directly. Normally used by authenticators, not
 * directly by applications. Does not delete the account from the server.
 * The authenticator may have its own policies preventing account deletion,
 * in which case the account will not be deleted.
 * <p>
 * It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The {@link Account} to delete.
 * @return True if the account was successfully deleted, false if the
 * account did not exist, the account is null, or another error
 * occurs.
 */
","/**
 * Removes an account directly. Normally used by authenticators, not
 * directly by applications. Does not delete the account from the server.
 * The authenticator may have its own policies preventing account deletion,
 * in which case the account will not be deleted.
 * <p>
 * It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The {@link Account} to delete.
 * @return True if the account was successfully deleted, false if the
 * account did not exist, the account is null, or another error
 * occurs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The only code change between the two versions occurs in the exception handling code block. In the early version, it throws a new RuntimeException when a RemoteException occurs, while in the later version, it throws the RemoteException wrapped with rethrowFromSystemServer(). Thus, the code change type is 2.","The method now potentially throws a different exception. The RemoteException is no longer being wrapped in a RuntimeException but is being rethrown directly, potentially altering the exception that the caller has to handle. Thus, the change in exception handling could lead to a Compatibility Issue of type 2."
52,<android.app.FragmentManagerImpl: boolean execPendingActions()>,23,24,<android.app.FragmentManagerImpl: boolean execPendingActions()>,<android.app.FragmentManagerImpl: boolean execPendingActions()>,0,"{
    if (mExecutingActions) {
        throw new IllegalStateException(""Recursive entry to executePendingTransactions"");
    }
    if (Looper.myLooper() != mHost.getHandler().getLooper()) {
        throw new IllegalStateException(""Must be called from main thread of process"");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                break;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mHost.getHandler().removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
    if (mHavePendingDeferredStart) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null && f.mLoaderManager != null) {
                loadersRunning |= f.mLoaderManager.hasRunningLoaders();
            }
        }
        if (!loadersRunning) {
            mHavePendingDeferredStart = false;
            startPendingDeferredFragments();
        }
    }
    return didSomething;
}","{
    if (mExecutingActions) {
        throw new IllegalStateException(""Recursive entry to executePendingTransactions"");
    }
    if (Looper.myLooper() != mHost.getHandler().getLooper()) {
        throw new IllegalStateException(""Must be called from main thread of process"");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                break;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mHost.getHandler().removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
    doPendingDeferredStart();
    return didSomething;
}",1,"/**
 * Only call from main thread!
 */
","/**
 * Only call from main thread!
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency and other statements changed. In the early version, there is an if block that checks if loaders are running and then conditionally executes startPendingDeferredFragments(). In the late version, this block has been replaced with a single method call to doPendingDeferredStart(). The removal of the condition and the addition of a new method call is a control dependency change (3), and a change to other statements (4) as well.","There is no Compatibility Issue because the old if block, although it is checking for loaders running, does not impact the return value if the condition `!loadersRunning` is false. The behavior change only refactors how deferred fragments are started without affecting the method's return value. The method still ultimately returns the value of didSomething, which is unchanged by the refactored code since the setting of didSomething to true only occurs if there was an action in the mPendingActions queue and that logic remains unchanged."
53,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,23,24,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,0,"{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    int num = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG) {
            Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" op #"" + num + "" base fragment #"" + mOps[pos]);
        }
        int findex = mOps[pos++];
        if (findex >= 0) {
            Fragment f = fm.mActive.get(findex);
            op.fragment = f;
        } else {
            op.fragment = null;
        }
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        final int N = mOps[pos++];
        if (N > 0) {
            op.removed = new ArrayList<Fragment>(N);
            for (int i = 0; i < N; i++) {
                if (FragmentManagerImpl.DEBUG) {
                    Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" set remove fragment #"" + mOps[pos]);
                }
                Fragment r = fm.mActive.get(mOps[pos++]);
                op.removed.add(r);
            }
        }
        bse.addOp(op);
        num++;
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.mSharedElementSourceNames = mSharedElementSourceNames;
    bse.mSharedElementTargetNames = mSharedElementTargetNames;
    bse.bumpBackStackNesting(1);
    return bse;
}","{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    int num = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG) {
            Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" op #"" + num + "" base fragment #"" + mOps[pos]);
        }
        int findex = mOps[pos++];
        if (findex >= 0) {
            Fragment f = fm.mActive.get(findex);
            op.fragment = f;
        } else {
            op.fragment = null;
        }
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        final int N = mOps[pos++];
        if (N > 0) {
            op.removed = new ArrayList<Fragment>(N);
            for (int i = 0; i < N; i++) {
                if (FragmentManagerImpl.DEBUG) {
                    Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" set remove fragment #"" + mOps[pos]);
                }
                Fragment r = fm.mActive.get(mOps[pos++]);
                op.removed.add(r);
            }
        }
        bse.mEnterAnim = op.enterAnim;
        bse.mExitAnim = op.exitAnim;
        bse.mPopEnterAnim = op.popEnterAnim;
        bse.mPopExitAnim = op.popExitAnim;
        bse.addOp(op);
        num++;
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.mSharedElementSourceNames = mSharedElementSourceNames;
    bse.mSharedElementTargetNames = mSharedElementTargetNames;
    bse.bumpBackStackNesting(1);
    return bse;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code changes are assignments to different variables within the BackStackRecord object. They are not return statements or exception handling statements, and there are no changes in control flow or dependencies, so the code change type is 4.","There is no Compatibility Issue caused by these changes as the variables being assigned are within the state of the BackStackRecord object, and do not affect the API's return type or the exceptions it may throw. The instantiation and returned value from the API remain the same, no behavior change is introduced to the API in terms of its interaction with the outward calling code, hence no CI."
54,<android.os.PowerManager: boolean isInteractive()>,23,24,<android.os.PowerManager: boolean isInteractive()>,<android.os.PowerManager: boolean isInteractive()>,0,"{
    try {
        return mService.isInteractive();
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return mService.isInteractive();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the device is in an interactive state.
 * <p>
 * When this method returns true, the device is awake and ready to interact
 * with the user (although this is not a guarantee that the user is actively
 * interacting with the device just this moment).  The main screen is usually
 * turned on while in this state.  Certain features, such as the proximity
 * sensor, may temporarily turn off the screen while still leaving the device in an
 * interactive state.  Note in particular that the device is still considered
 * to be interactive while dreaming (since dreams can be interactive) but not
 * when it is dozing or asleep.
 * </p><p>
 * When this method returns false, the device is dozing or asleep and must
 * be awoken before it will become ready to interact with the user again.  The
 * main screen is usually turned off while in this state.  Certain features,
 * such as ""ambient mode"" may cause the main screen to remain on (albeit in a
 * low power state) to display system-provided content while the device dozes.
 * </p><p>
 * The system will send a {@link android.content.Intent#ACTION_SCREEN_ON screen on}
 * or {@link android.content.Intent#ACTION_SCREEN_OFF screen off} broadcast
 * whenever the interactive state of the device changes.  For historical reasons,
 * the names of these broadcasts refer to the power state of the screen
 * but they are actually sent in response to changes in the overall interactive
 * state of the device, as described by this method.
 * </p><p>
 * Services may use the non-interactive state as a hint to conserve power
 * since the user is not present.
 * </p>
 *
 * @return True if the device is in an interactive state.
 *
 * @see android.content.Intent#ACTION_SCREEN_ON
 * @see android.content.Intent#ACTION_SCREEN_OFF
 */
","/**
 * Returns true if the device is in an interactive state.
 * <p>
 * When this method returns true, the device is awake and ready to interact
 * with the user (although this is not a guarantee that the user is actively
 * interacting with the device just this moment).  The main screen is usually
 * turned on while in this state.  Certain features, such as the proximity
 * sensor, may temporarily turn off the screen while still leaving the device in an
 * interactive state.  Note in particular that the device is still considered
 * to be interactive while dreaming (since dreams can be interactive) but not
 * when it is dozing or asleep.
 * </p><p>
 * When this method returns false, the device is dozing or asleep and must
 * be awoken before it will become ready to interact with the user again.  The
 * main screen is usually turned off while in this state.  Certain features,
 * such as ""ambient mode"" may cause the main screen to remain on (albeit in a
 * low power state) to display system-provided content while the device dozes.
 * </p><p>
 * The system will send a {@link android.content.Intent#ACTION_SCREEN_ON screen on}
 * or {@link android.content.Intent#ACTION_SCREEN_OFF screen off} broadcast
 * whenever the interactive state of the device changes.  For historical reasons,
 * the names of these broadcasts refer to the power state of the screen
 * but they are actually sent in response to changes in the overall interactive
 * state of the device, as described by this method.
 * </p><p>
 * Services may use the non-interactive state as a hint to conserve power
 * since the user is not present.
 * </p>
 *
 * @return True if the device is in an interactive state.
 *
 * @see android.content.Intent#ACTION_SCREEN_ON
 * @see android.content.Intent#ACTION_SCREEN_OFF
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from returning false to throwing an exception using e.rethrowFromSystemServer(), so the change type is 2.","The behavior of the API in exception cases has changed because previously it returned false, but now it throws an exception instead. This leads to a different exception handling, causing a Compatibility Issue of type 2."
55,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,23,24,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,0,"{
    super.dispatchProvideStructure(structure);
    if (!isAssistBlocked()) {
        if (structure.getChildCount() == 0) {
            final int childrenCount = getChildCount();
            if (childrenCount > 0) {
                structure.setChildCount(childrenCount);
                ArrayList<View> preorderedList = buildOrderedChildList();
                boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                final View[] children = mChildren;
                for (int i = 0; i < childrenCount; i++) {
                    int childIndex;
                    try {
                        childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                    } catch (IndexOutOfBoundsException e) {
                        childIndex = i;
                        if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                            Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                            // At least one app is failing when we call getChildDrawingOrder
                            // at this point, so deal semi-gracefully with it by falling back
                            // on the basic order.
                            customOrder = false;
                            if (i > 0) {
                                // If we failed at the first index, there really isn't
                                // anything to do -- we will just proceed with the simple
                                // sequence order.
                                // Otherwise, we failed in the middle, so need to come up
                                // with an order for the remaining indices and use that.
                                // Failed at the first one, easy peasy.
                                int[] permutation = new int[childrenCount];
                                SparseBooleanArray usedIndices = new SparseBooleanArray();
                                // Go back and collected the indices we have done so far.
                                for (int j = 0; j < i; j++) {
                                    permutation[j] = getChildDrawingOrder(childrenCount, j);
                                    usedIndices.put(permutation[j], true);
                                }
                                // Fill in the remaining indices with indices that have not
                                // yet been used.
                                int nextIndex = 0;
                                for (int j = i; j < childrenCount; j++) {
                                    while (usedIndices.get(nextIndex, false)) {
                                        nextIndex++;
                                    }
                                    permutation[j] = nextIndex;
                                    nextIndex++;
                                }
                                // Build the final view list.
                                preorderedList = new ArrayList<>(childrenCount);
                                for (int j = 0; j < childrenCount; j++) {
                                    preorderedList.add(children[permutation[j]]);
                                }
                            }
                        } else {
                            throw e;
                        }
                    }
                    final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                    ViewStructure cstructure = structure.newChild(i);
                    child.dispatchProvideStructure(cstructure);
                }
            }
        }
    }
}","{
    super.dispatchProvideStructure(structure);
    if (!isAssistBlocked()) {
        if (structure.getChildCount() == 0) {
            final int childrenCount = getChildCount();
            if (childrenCount > 0) {
                structure.setChildCount(childrenCount);
                ArrayList<View> preorderedList = buildOrderedChildList();
                boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                final View[] children = mChildren;
                for (int i = 0; i < childrenCount; i++) {
                    int childIndex;
                    try {
                        childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                    } catch (IndexOutOfBoundsException e) {
                        childIndex = i;
                        if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                            Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                            // At least one app is failing when we call getChildDrawingOrder
                            // at this point, so deal semi-gracefully with it by falling back
                            // on the basic order.
                            customOrder = false;
                            if (i > 0) {
                                // If we failed at the first index, there really isn't
                                // anything to do -- we will just proceed with the simple
                                // sequence order.
                                // Otherwise, we failed in the middle, so need to come up
                                // with an order for the remaining indices and use that.
                                // Failed at the first one, easy peasy.
                                int[] permutation = new int[childrenCount];
                                SparseBooleanArray usedIndices = new SparseBooleanArray();
                                // Go back and collected the indices we have done so far.
                                for (int j = 0; j < i; j++) {
                                    permutation[j] = getChildDrawingOrder(childrenCount, j);
                                    usedIndices.put(permutation[j], true);
                                }
                                // Fill in the remaining indices with indices that have not
                                // yet been used.
                                int nextIndex = 0;
                                for (int j = i; j < childrenCount; j++) {
                                    while (usedIndices.get(nextIndex, false)) {
                                        nextIndex++;
                                    }
                                    permutation[j] = nextIndex;
                                    nextIndex++;
                                }
                                // Build the final view list.
                                preorderedList = new ArrayList<>(childrenCount);
                                for (int j = 0; j < childrenCount; j++) {
                                    preorderedList.add(children[permutation[j]]);
                                }
                            }
                        } else {
                            throw e;
                        }
                    }
                    final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                    final ViewStructure cstructure = structure.newChild(i);
                    child.dispatchProvideStructure(cstructure);
                }
                if (preorderedList != null)
                    preorderedList.clear();
            }
        }
    }
}",1,"/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
","/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,,,,
56,<android.app.admin.DevicePolicyManager: long getPasswordExpiration(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: long getPasswordExpiration(ComponentName)>,<android.app.admin.DevicePolicyManager: long getPasswordExpiration(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordExpiration(admin, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    if (mService != null) {
        try {
            return mService.getPasswordExpiration(admin, myUserId(), mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}",1,"/**
 * Get the current password expiration time for the given admin or an aggregate of
 * all admins of this user and its profiles if admin is null. If the password is
 * expired, this will return the time since the password expired as a negative number.
 * If admin is null, then a composite of all expiration timeouts is returned
 * - which will be the minimum of all timeouts.
 *
 * @param admin The name of the admin component to check, or {@code null} to aggregate all admins.
 * @return The password expiration time, in ms.
 */
","/**
 * Get the current password expiration time for a particular admin or all admins that set
 * retrictions on this user and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account. If admin is {@code null}, then a composite
 * of all expiration times is returned - which will be the minimum of all of them.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * the password expiration for the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to aggregate all admins.
 * @return The password expiration time, in milliseconds since epoch.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The exception handling statement has changed from logging the exception to throwing it, and there is also a change in the arguments passed to the method mService.getPasswordExpiration, indicating a change in the invocation of a dependent API. Therefore, the code change types are 2 (Exception handling statement changed) and 5 (Dependent API changed).","By changing from logging an exception to throwing it, the method now has a different exception handling which can indeed cause a different behavior. Also, the change in parameters passed to getPasswordExpiration could change the return value if the implementation of getPasswordExpiration relies upon the extra parameter mParentInstance. Hence, the compatibility issue types are 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
57,<android.widget.RemoteViewsAdapter.RemoteViewsMetaData: int getMappedViewType(int)>,23,24,<android.widget.RemoteViewsAdapter.RemoteViewsMetaData: int getMappedViewType(int)>,<android.widget.RemoteViewsAdapter.RemoteViewsMetaData: int getMappedViewType(int)>,0,"{
    if (mTypeIdIndexMap.containsKey(typeId)) {
        return mTypeIdIndexMap.get(typeId);
    } else {
        // We +1 because the loading view always has view type id of 0
        int incrementalTypeId = mTypeIdIndexMap.size() + 1;
        mTypeIdIndexMap.put(typeId, incrementalTypeId);
        return incrementalTypeId;
    }
}","{
    int mappedTypeId = mTypeIdIndexMap.get(typeId, -1);
    if (mappedTypeId == -1) {
        // We +1 because the loading view always has view type id of 0
        mappedTypeId = mTypeIdIndexMap.size() + 1;
        mTypeIdIndexMap.put(typeId, mappedTypeId);
    }
    return mappedTypeId;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method now uses a different signature of the get() method on `mTypeIdIndexMap` by introducing the default return value '-1' and the classic if-else has been replaced with a modified condition and a single return statement. The use of the default return value likely changes the behavior of the lookup, so the change is in return statement, control dependency change, and dependent API change.","Since the implementation has been altered to use `get(typeId, -1)` instead of `containsKey(typeId)` and a corresponding get, this can change the value returned by the method, hence there's a compatibility issue with a potential different return value, and the CI type is 1."
58,<android.net.NetworkRequest.Builder: Builder setNetworkSpecifier(String)>,23,24,<android.net.NetworkRequest.Builder: Builder setNetworkSpecifier(String)>,<android.net.NetworkRequest.Builder: Builder setNetworkSpecifier(String)>,0,"{
    mNetworkCapabilities.setNetworkSpecifier(networkSpecifier);
    return this;
}","{
    if (NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER.equals(networkSpecifier)) {
        throw new IllegalArgumentException(""Invalid network specifier - must not be '"" + NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER + ""'"");
    }
    mNetworkCapabilities.setNetworkSpecifier(networkSpecifier);
    return this;
}",1,"/**
 * Sets the optional bearer specific network specifier.
 * This has no meaning if a single transport is also not specified, so calling
 * this without a single transport set will generate an exception, as will
 * subsequently adding or removing transports after this is set.
 * </p>
 * The interpretation of this {@code String} is bearer specific and bearers that use
 * it should document their particulars.  For example, Bluetooth may use some sort of
 * device id while WiFi could used ssid and/or bssid.  Cellular may use carrier spn.
 *
 * @param networkSpecifier An {@code String} of opaque format used to specify the bearer
 * specific network specifier where the bearer has a choice of
 * networks.
 */
","/**
 * Sets the optional bearer specific network specifier.
 * This has no meaning if a single transport is also not specified, so calling
 * this without a single transport set will generate an exception, as will
 * subsequently adding or removing transports after this is set.
 * </p>
 * The interpretation of this {@code String} is bearer specific and bearers that use
 * it should document their particulars.  For example, Bluetooth may use some sort of
 * device id while WiFi could used ssid and/or bssid.  Cellular may use carrier spn.
 *
 * @param networkSpecifier An {@code String} of opaque format used to specify the bearer
 * specific network specifier where the bearer has a choice of
 * networks.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An if-statement with a throw clause is introduced before the setNetworkSpecifier method is called, so the code change types include an exception handling statement changed (2) and a control dependency changed (3).","With the introduction of the new if-statement that checks for a specific invalid network specifier and throws an IllegalArgumentException, the late version of the API may throw a new exception that the early version would not have thrown. This change can lead to a Compatibility Issue caused by potential different exception handlings (2)."
60,<android.print.PrinterInfo.Builder: Builder setName(String)>,23,24,<android.print.PrinterInfo.Builder: Builder setName(String)>,<android.print.PrinterInfo.Builder: Builder setName(String)>,0,"{
    mPrototype.mName = name;
    return this;
}","{
    mName = checkName(name);
    return this;
}",1,"/**
 * Sets the <strong>localized</strong> printer name which
 * is shown to the user
 *
 * @param name The name.
 * @return This builder.
 */
","/**
 * Sets the <strong>localized</strong> printer name which
 * is shown to the user
 *
 * @param name The name.
 * @return This builder.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",1,"Instead of directly setting the value of mName, the late version uses checkName(name) which is a Dependent API. This suggests a different method is being called which validates or transforms the input name before assigning it to mName, so the change type is 4,5.","Because the method checkName(name) is introduced, it might result in validation or transformation of input 'name'. If checkName(name) modifies, returns null, or throws an unchecked exception, when provided with a name that the early version would accept, the behavior of the setName method would differ from the early version, leading to a potentially different return value. Therefore, the CI type is 1."
61,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,23,24,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,0,"{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        if (subtype.mSubtypeId != 0 || mSubtypeId != 0) {
            return (subtype.hashCode() == hashCode());
        }
        return (subtype.hashCode() == hashCode()) && (subtype.getLocale().equals(getLocale())) && (subtype.getMode().equals(getMode())) && (subtype.getExtraValue().equals(getExtraValue())) && (subtype.isAuxiliary() == isAuxiliary()) && (subtype.overridesImplicitlyEnabledSubtype() == overridesImplicitlyEnabledSubtype()) && (subtype.isAsciiCapable() == isAsciiCapable());
    }
    return false;
}","{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        if (subtype.mSubtypeId != 0 || mSubtypeId != 0) {
            return (subtype.hashCode() == hashCode());
        }
        return (subtype.hashCode() == hashCode()) && (subtype.getLocale().equals(getLocale())) && (subtype.getLanguageTag().equals(getLanguageTag())) && (subtype.getMode().equals(getMode())) && (subtype.getExtraValue().equals(getExtraValue())) && (subtype.isAuxiliary() == isAuxiliary()) && (subtype.overridesImplicitlyEnabledSubtype() == overridesImplicitlyEnabledSubtype()) && (subtype.isAsciiCapable() == isAsciiCapable());
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within the equality check has changed from comparing locale values with `subtype.getLocale().equals(getLocale())` to comparing language tags with `subtype.getLanguageTag().equals(getLanguageTag())`. Because the locale and language tag can represent similar but not always identical data, this changes the conditions under which the method would return true or false, so the code change type is 1,5.","Since the semantics of the `equals` method can be different because of the change from comparing locale to comparing language tag, there is a potential for the method to return a different value when comparing two `InputMethodSubtype` objects that might have had the same locale but different language tags, or vice versa. Therefore, there is a potential Compatibility Issue caused by potentially different return values, and the CI type is 1."
62,<android.text.BidiFormatter: BidiFormatter getInstance()>,23,24,<android.text.BidiFormatter: BidiFormatter getInstance()>,<android.text.BidiFormatter: BidiFormatter getInstance()>,0,"{
    return new Builder().build();
}","{
    return getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault()));
}",1,"/**
 * Factory for creating an instance of BidiFormatter for the default locale directionality.
 */
","/**
 * Factory for creating an instance of BidiFormatter for the default locale directionality.
 *
 * This does not create any new objects, and returns already existing static instances.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the getInstance() method has changed from new Builder().build(); to getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault())); which is entirely different, indicating a change in the underlying behavior. Additionally, this change is dependent on the newly introduced methods getDefaultInstanceFromContext and isRtlLocale, as well as the behavior of Locale.getDefault(), which are not present in the early version.",The new implementation of getInstance() is reliant on the default locale and a new method to determine whether to get the default instance or not. This could lead to a different return value based on the locale and consequently cause compatibility issues. The difference in the return value of getInstance() method represents a potential Compatibility Issue of type 1.
63,"<android.app.admin.DevicePolicyManager: void setGlobalSetting(ComponentName,String,String)>",23,24,"<android.app.admin.DevicePolicyManager: void setGlobalSetting(ComponentName,String,String)>","<android.app.admin.DevicePolicyManager: void setGlobalSetting(ComponentName,String,String)>",0,"{
    if (mService != null) {
        try {
            mService.setGlobalSetting(admin, setting, value);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setGlobalSetting"");
    if (mService != null) {
        try {
            mService.setGlobalSetting(admin, setting, value);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by device owners to update {@link Settings.Global} settings. Validation that the value
 * of the setting is in the correct form for the setting type should be performed by the caller.
 * <p>The settings that can be updated with this method are:
 * <ul>
 * <li>{@link Settings.Global#ADB_ENABLED}</li>
 * <li>{@link Settings.Global#AUTO_TIME}</li>
 * <li>{@link Settings.Global#AUTO_TIME_ZONE}</li>
 * <li>{@link Settings.Global#DATA_ROAMING}</li>
 * <li>{@link Settings.Global#USB_MASS_STORAGE_ENABLED}</li>
 * <li>{@link Settings.Global#WIFI_SLEEP_POLICY}</li>
 * <li>{@link Settings.Global#STAY_ON_WHILE_PLUGGED_IN}
 * This setting is only available from {@link android.os.Build.VERSION_CODES#M} onwards
 * and can only be set if {@link #setMaximumTimeToLock} is not used to set a timeout.</li>
 * <li>{@link Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN}</li>
 * This setting is only available from {@link android.os.Build.VERSION_CODES#M} onwards.
 * </li>
 * </ul>
 * <p>Changing the following settings has no effect as of
 * {@link android.os.Build.VERSION_CODES#M}:
 * <ul>
 * <li>{@link Settings.Global#BLUETOOTH_ON}.
 * Use {@link android.bluetooth.BluetoothAdapter#enable()} and
 * {@link android.bluetooth.BluetoothAdapter#disable()} instead.</li>
 * <li>{@link Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}</li>
 * <li>{@link Settings.Global#MODE_RINGER}.
 * Use {@link android.media.AudioManager#setRingerMode(int)} instead.</li>
 * <li>{@link Settings.Global#NETWORK_PREFERENCE}</li>
 * <li>{@link Settings.Global#WIFI_ON}.
 * Use {@link android.net.wifi.WifiManager#setWifiEnabled(boolean)} instead.</li>
 * </ul>
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param setting The name of the setting to update.
 * @param value The value to update the setting to.
 */
","/**
 * Called by device owners to update {@link Settings.Global} settings. Validation that the value
 * of the setting is in the correct form for the setting type should be performed by the caller.
 * <p>
 * The settings that can be updated with this method are:
 * <ul>
 * <li>{@link Settings.Global#ADB_ENABLED}</li>
 * <li>{@link Settings.Global#AUTO_TIME}</li>
 * <li>{@link Settings.Global#AUTO_TIME_ZONE}</li>
 * <li>{@link Settings.Global#DATA_ROAMING}</li>
 * <li>{@link Settings.Global#USB_MASS_STORAGE_ENABLED}</li>
 * <li>{@link Settings.Global#WIFI_SLEEP_POLICY}</li>
 * <li>{@link Settings.Global#STAY_ON_WHILE_PLUGGED_IN} This setting is only available from
 * {@link android.os.Build.VERSION_CODES#M} onwards and can only be set if
 * {@link #setMaximumTimeToLock} is not used to set a timeout.</li>
 * <li>{@link Settings.Global#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN}</li> This setting is only
 * available from {@link android.os.Build.VERSION_CODES#M} onwards.</li>
 * </ul>
 * <p>
 * Changing the following settings has no effect as of {@link android.os.Build.VERSION_CODES#M}:
 * <ul>
 * <li>{@link Settings.Global#BLUETOOTH_ON}. Use
 * {@link android.bluetooth.BluetoothAdapter#enable()} and
 * {@link android.bluetooth.BluetoothAdapter#disable()} instead.</li>
 * <li>{@link Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}</li>
 * <li>{@link Settings.Global#MODE_RINGER}. Use
 * {@link android.media.AudioManager#setRingerMode(int)} instead.</li>
 * <li>{@link Settings.Global#NETWORK_PREFERENCE}</li>
 * <li>{@link Settings.Global#WIFI_ON}. Use
 * {@link android.net.wifi.WifiManager#setWifiEnabled(boolean)} instead.</li>
 * </ul>
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param setting The name of the setting to update.
 * @param value The value to update the setting to.
 * @throws SecurityException if {@code admin} is not a device owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An additional method call throwIfParentInstance(""setGlobalSetting"") was introduced (which is an ""Other statement changed"", type 4), and the exception handling statement changed because it no longer logs the exception but throws it instead (type 2).","The extra throw statement (throw e.rethrowFromSystemServer()), replacing a log operation, indicates that the method has a new behavior where it can throw an exception that was previously caught and logged. This change might make the late version of the API throw an exception where the early version did not, indicating a ""Compatibility Issue caused by potential different exception handlings"", type 2."
64,<android.app.Activity: void recreate()>,23,24,<android.app.Activity: void recreate()>,<android.app.Activity: void recreate()>,0,"{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false);
}","{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false, false);
}",1,"/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
","/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is the addition of a new parameter to the method call mMainThread.requestRelaunchActivity(). Since it is a modification in a method call with an additional argument, the change type is 4,5.","The method call change doesn't affect the control flow or exception handling, nor does it alter the returned value or the exceptions thrown by the method itself. Therefore, there is no compatibility issue in terms of changing return values, types, or exceptions thrown, so the CI type is 0."
65,<android.app.admin.DeviceAdminInfo: String toString()>,23,24,<android.app.admin.DeviceAdminInfo: String toString()>,<android.app.admin.DeviceAdminInfo: String toString()>,0,"{
    return ""DeviceAdminInfo{"" + mReceiver.activityInfo.name + ""}"";
}","{
    return ""DeviceAdminInfo{"" + mActivityInfo.name + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation has changed from directly accessing a member of mReceiver to accessing mActivityInfo, however, since these appear to reference the same value, there is only an internal change, so the code change type is 4.","Despite the internal implementation change, the API exhibits the same external behavior, so there is no Compatibility Issue."
66,<android.app.ContextImpl: void unbindService(ServiceConnection)>,23,24,<android.app.ContextImpl: void unbindService(ServiceConnection)>,<android.app.ContextImpl: void unbindService(ServiceConnection)>,0,"{
    if (conn == null) {
        throw new IllegalArgumentException(""connection is null"");
    }
    if (mPackageInfo != null) {
        IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(getOuterContext(), conn);
        try {
            ActivityManagerNative.getDefault().unbindService(sd);
        } catch (RemoteException e) {
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}","{
    if (conn == null) {
        throw new IllegalArgumentException(""connection is null"");
    }
    if (mPackageInfo != null) {
        IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(getOuterContext(), conn);
        try {
            ActivityManagerNative.getDefault().unbindService(sd);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,The catch block has been modified to now throw an exception where previously it was swallowing the RemoteException with an empty catch block. This means there is a change in the exception handling statement which is of type 2.,"The introduction of the throw statement in the catch block for RemoteException means that previously where a remote exception would have been silent, it will now cause the method to throw a RuntimeException, changing its behaviour with regard to exception handling. This is a Compatibility Issue of type 2 (Exception handling statement changed)."
67,<android.view.View.DeclaredOnClickListener: void onClick(View)>,23,24,<android.view.View.DeclaredOnClickListener: void onClick(View)>,<android.view.View.DeclaredOnClickListener: void onClick(View)>,0,"{
    if (mMethod == null) {
        mMethod = resolveMethod(mHostView.getContext(), mMethodName);
    }
    try {
        mMethod.invoke(mHostView.getContext(), v);
    } catch (IllegalAccessException e) {
        throw new IllegalStateException(""Could not execute non-public method for android:onClick"", e);
    } catch (InvocationTargetException e) {
        throw new IllegalStateException(""Could not execute method for android:onClick"", e);
    }
}","{
    if (mResolvedMethod == null) {
        resolveMethod(mHostView.getContext(), mMethodName);
    }
    try {
        mResolvedMethod.invoke(mResolvedContext, v);
    } catch (IllegalAccessException e) {
        throw new IllegalStateException(""Could not execute non-public method for android:onClick"", e);
    } catch (InvocationTargetException e) {
        throw new IllegalStateException(""Could not execute method for android:onClick"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The control dependency has changed since the way methods are resolved now uses mResolvedMethod rather than mMethod, and it also sets mResolvedContext which wasn't previously set. There are changes in variable names which indicate a change in state management, but the logic remains effectively the same. Furthermore, there's a dependent API changed since the resolveMethod() seems to be called without assignment to mMethod, which suggests that resolveMethod() implementation might be responsible for setting mResolvedMethod and mResolvedContext internally. Hence, the change types are 3,4,5.","There seems to be no compatibility issue as the method's external behavior and exceptions thrown haven't changed. The variables names have changed internally, alongside how the resolved method and context are stored, but it does not affect the method's signature or its observable behaviors from an API consumer's standpoint. The exception messages and types that are thrown remain unchanged. Hence there's no potential CI from these changes."
69,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,23,24,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,0,"{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}",1,"/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */
","/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, with the addition of `throw e.rethrowFromSystemServer();` in the late version, so the code change type is 2.","Because the exception handling behavior has changed, where previously the exception was caught and ignored, and now it is rethrown, the method could potentially throw a different exception than it did in the early version. Thus, the CI type is 2."
70,"<android.app.NotificationManager: void cancel(String,int)>",23,24,"<android.app.NotificationManager: void cancel(String,int)>","<android.app.NotificationManager: void cancel(String,int)>",0,"{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancel("" + id + "")"");
    try {
        service.cancelNotificationWithTag(pkg, tag, id, UserHandle.myUserId());
    } catch (RemoteException e) {
    }
}","{
    cancelAsUser(tag, id, new UserHandle(UserHandle.myUserId()));
}",1,"/**
 * Cancel a previously shown notification.  If it's transient, the view
 * will be hidden.  If it's persistent, it will be removed from the status
 * bar.
 */
","/**
 * Cancel a previously shown notification.  If it's transient, the view
 * will be hidden.  If it's persistent, it will be removed from the status
 * bar.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the late version invokes another method 'cancelAsUser' instead of directly using the service, resulting in an internal refactoring that does not directly alter the external behavior. The change type here is 4,5 since the way the method executes its underlying cancellation is different, even though it still achieves the same end result.","There is no Compatibility Issue introduced since, from the perspective of the API user, the expected outcome remains the same: the notification identified by the given tag and id is cancelled for the current user. The change is internal and does not affect the external behavior or contract of the method."
73,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int,Theme)>",23,24,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int,Theme)>","<android.content.res.Resources: Drawable getDrawableForDensity(int,int,Theme)>",0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValueForDensity(id, density, value, true);
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = mMetrics.densityDpi;
            } else {
                value.density = (value.density * mMetrics.densityDpi) / density;
            }
        }
    }
    final Drawable res = loadDrawable(value, id, theme);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValueForDensity(id, density, value, true);
        // If the drawable's XML lives in our current density qualifier,
        // it's okay to use a scaled version from the cache. Otherwise, we
        // need to actually load the drawable from XML.
        final DisplayMetrics metrics = impl.getDisplayMetrics();
        final boolean useCache = value.density == metrics.densityDpi;
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = metrics.densityDpi;
            } else {
                value.density = (value.density * metrics.densityDpi) / density;
            }
        }
        return impl.loadDrawable(this, value, id, theme, useCache);
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI and styled for the specified theme.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density The desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @param theme The theme used to style the drawable attributes, may be {@code null}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
","/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI and styled for the specified theme.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density The desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @param theme The theme used to style the drawable attributes, may be {@code null}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
",-1,[@Nullable],,-1,-1,-1,-1,-1,-1,"4,5",0,"The obtainTempTypedValue() and releaseTempTypedValue(value) methods indicate internal changes in how TypedValue objects are managed, which is a dependent API change. The control flow and logic of the code remain the same. However, internal resource management has changed, so the change type is 4,5.","Although there's an internal resource management change, it does not affect the behavior visible to the API client; the method receives the same parameters and returns a Drawable based on the given density and theme. Therefore, no Compatibility Issue is introduced as the changes should not affect the return value or the exception throwing behavior, hence the CI type is 0."
74,<android.app.AlarmManager: void setTimeZone(String)>,23,24,<android.app.AlarmManager: void setTimeZone(String)>,<android.app.AlarmManager: void setTimeZone(String)>,0,"{
    if (TextUtils.isEmpty(timeZone)) {
        return;
    }
    // Reject this timezone if it isn't an Olson zone we recognize.
    if (mTargetSdkVersion >= Build.VERSION_CODES.M) {
        boolean hasTimeZone = false;
        try {
            hasTimeZone = ZoneInfoDB.getInstance().hasTimeZone(timeZone);
        } catch (IOException ignored) {
        }
        if (!hasTimeZone) {
            throw new IllegalArgumentException(""Timezone: "" + timeZone + "" is not an Olson ID"");
        }
    }
    try {
        mService.setTimeZone(timeZone);
    } catch (RemoteException ex) {
    }
}","{
    if (TextUtils.isEmpty(timeZone)) {
        return;
    }
    // Reject this timezone if it isn't an Olson zone we recognize.
    if (mTargetSdkVersion >= Build.VERSION_CODES.M) {
        boolean hasTimeZone = false;
        try {
            hasTimeZone = ZoneInfoDB.getInstance().hasTimeZone(timeZone);
        } catch (IOException ignored) {
        }
        if (!hasTimeZone) {
            throw new IllegalArgumentException(""Timezone: "" + timeZone + "" is not an Olson ID"");
        }
    }
    try {
        mService.setTimeZone(timeZone);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the system's persistent default time zone. This is the time zone for all apps, even
 * after a reboot. Use {@link java.util.TimeZone#setDefault} if you just want to change the
 * time zone within your app, and even then prefer to pass an explicit
 * {@link java.util.TimeZone} to APIs that require it rather than changing the time zone for
 * all threads.
 *
 * <p> On android M and above, it is an error to pass in a non-Olson timezone to this
 * function. Note that this is a bad idea on all Android releases because POSIX and
 * the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}
 * in the same non-Olson ID.
 *
 * @param timeZone one of the Olson ids from the list returned by
 * {@link java.util.TimeZone#getAvailableIDs}
 */
","/**
 * Sets the system's persistent default time zone. This is the time zone for all apps, even
 * after a reboot. Use {@link java.util.TimeZone#setDefault} if you just want to change the
 * time zone within your app, and even then prefer to pass an explicit
 * {@link java.util.TimeZone} to APIs that require it rather than changing the time zone for
 * all threads.
 *
 * <p> On android M and above, it is an error to pass in a non-Olson timezone to this
 * function. Note that this is a bad idea on all Android releases because POSIX and
 * the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}
 * in the same non-Olson ID.
 *
 * @param timeZone one of the Olson ids from the list returned by
 * {@link java.util.TimeZone#getAvailableIDs}
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has changed, with the new version throwing (throw ex.rethrowFromSystemServer()) a caught RemoteException. Thereby, the code change type is 2.","The new exception handling introduces a different exception handling behavior, which could cause new or different exceptions to be thrown in the late version compared to the early version where the RemoteException is caught and ignored. Thus, the CI type is 2."
75,<android.printservice.PrintJob: boolean block(String)>,23,24,<android.printservice.PrintJob: boolean block(String)>,<android.printservice.PrintJob: boolean block(String)>,0,"{
    PrintService.throwIfNotCalledOnMainThread();
    PrintJobInfo info = getInfo();
    final int state = info.getState();
    if (state == PrintJobInfo.STATE_STARTED || (state == PrintJobInfo.STATE_BLOCKED && !TextUtils.equals(info.getStateReason(), reason))) {
        return setState(PrintJobInfo.STATE_BLOCKED, reason);
    }
    return false;
}","{
    PrintService.throwIfNotCalledOnMainThread();
    PrintJobInfo info = getInfo();
    final int state = info.getState();
    if (state == PrintJobInfo.STATE_STARTED || state == PrintJobInfo.STATE_BLOCKED) {
        return setState(PrintJobInfo.STATE_BLOCKED, reason);
    }
    return false;
}",1,"/**
 * Blocks the print job. You should call this method if {@link
 * #isStarted()} or {@link #isBlocked()} returns true and you need
 * to block the print job. For example, the user has to add some
 * paper to continue printing. To resume the print job call {@link
 * #start()}.
 *
 * @return Whether the job was blocked.
 *
 * @see #isStarted()
 * @see #isBlocked()
 */
","/**
 * Blocks the print job. You should call this method if {@link #isStarted()} returns true and
 * you need to block the print job. For example, the user has to add some paper to continue
 * printing. To resume the print job call {@link #start()}. To change the reason call
 * {@link #setStatus(CharSequence)}.
 *
 * @param reason The human readable, short, and translated reason why the print job is blocked.
 * @return Whether the job was blocked.
 *
 * @see #isStarted()
 * @see #isBlocked()
 */
",-1,,[@MainThread],-1,-1,-1,-1,-1,-1,3,1,"The condition checking `!TextUtils.equals(info.getStateReason(), reason)` has been removed from the `if` statement, which is a control dependency change, so the change type is 3.","This change in the control flow can make the API introduce a behavioral difference, as the condition for blocking the print job has been altered. In the early version, a job would only be blocked if it wasn't already blocked for the same reason. In the late version, this check is no longer performed. Therefore, a job might be blocked under different circumstances, and the CI type is 1."
76,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>",23,24,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The arguments for intent.prepareToLeaveProcess() have changed, with the 'this' reference being added in the late version, which suggests an update to a dependent API (change type 5). Additionally, the exception handling changed from throwing a new RuntimeException to calling e.rethrowFromSystemServer() (change type 2). The exception handling statement is introduced, which means the API could throw a different exception in the late version (change type 2).","The change to the dependent API could potentially cause the method to behave differently, resulting in different return types or values (CI type 1). The updated exception handling could result in different exceptions being thrown, which can cause a compatibility issue (CI type 2)."
78,<android.animation.AnimatorSet: AnimatorSet clone()>,23,24,<android.animation.AnimatorSet: AnimatorSet clone()>,<android.animation.AnimatorSet: AnimatorSet clone()>,0,"{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    final int nodeCount = mNodes.size();
    anim.mNeedsSort = true;
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new ArrayMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>(nodeCount);
    anim.mSortedNodes = new ArrayList<Node>(nodeCount);
    anim.mReversible = mReversible;
    anim.mSetListener = null;
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        Node nodeClone = node.clone();
        node.mTmpClone = nodeClone;
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.animation, nodeClone);
        // Clear out the dependencies in the clone; we'll set these up manually later
        nodeClone.dependencies = null;
        nodeClone.tmpDependencies = null;
        nodeClone.nodeDependents = null;
        nodeClone.nodeDependencies = null;
        // clear out any listeners that were set up by the AnimatorSet; these will
        // be set up when the clone's nodes are sorted
        final ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
        if (cloneListeners != null) {
            for (int i = cloneListeners.size() - 1; i >= 0; i--) {
                final AnimatorListener listener = cloneListeners.get(i);
                if (listener instanceof AnimatorSetListener) {
                    cloneListeners.remove(i);
                }
            }
        }
    }
    // dependencies, mapping the old dependencies to the new nodes
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        final Node clone = node.mTmpClone;
        if (node.dependencies != null) {
            clone.dependencies = new ArrayList<Dependency>(node.dependencies.size());
            final int depSize = node.dependencies.size();
            for (int i = 0; i < depSize; i++) {
                final Dependency dependency = node.dependencies.get(i);
                Dependency cloneDependency = new Dependency(dependency.node.mTmpClone, dependency.rule);
                clone.dependencies.add(cloneDependency);
            }
        }
        if (node.nodeDependents != null) {
            clone.nodeDependents = new ArrayList<Node>(node.nodeDependents.size());
            for (Node dep : node.nodeDependents) {
                clone.nodeDependents.add(dep.mTmpClone);
            }
        }
        if (node.nodeDependencies != null) {
            clone.nodeDependencies = new ArrayList<Node>(node.nodeDependencies.size());
            for (Node dep : node.nodeDependencies) {
                clone.nodeDependencies.add(dep.mTmpClone);
            }
        }
    }
    for (int n = 0; n < nodeCount; n++) {
        mNodes.get(n).mTmpClone = null;
    }
    return anim;
}","{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    final int nodeCount = mNodes.size();
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new ArrayMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>(nodeCount);
    anim.mReversible = mReversible;
    anim.mSetListener = new AnimatorSetListener(anim);
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        Node nodeClone = node.clone();
        node.mTmpClone = nodeClone;
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.mAnimation, nodeClone);
        // clear out any listeners that were set up by the AnimatorSet
        final ArrayList<AnimatorListener> cloneListeners = nodeClone.mAnimation.getListeners();
        if (cloneListeners != null) {
            for (int i = cloneListeners.size() - 1; i >= 0; i--) {
                final AnimatorListener listener = cloneListeners.get(i);
                if (listener instanceof AnimatorSetListener) {
                    cloneListeners.remove(i);
                }
            }
        }
    }
    anim.mRootNode = mRootNode.mTmpClone;
    anim.mDelayAnim = (ValueAnimator) anim.mRootNode.mAnimation;
    // dependencies, mapping the old dependencies to the new nodes
    for (int i = 0; i < nodeCount; i++) {
        Node node = mNodes.get(i);
        // Update dependencies for node's clone
        node.mTmpClone.mLatestParent = node.mLatestParent == null ? null : node.mLatestParent.mTmpClone;
        int size = node.mChildNodes == null ? 0 : node.mChildNodes.size();
        for (int j = 0; j < size; j++) {
            node.mTmpClone.mChildNodes.set(j, node.mChildNodes.get(j).mTmpClone);
        }
        size = node.mSiblings == null ? 0 : node.mSiblings.size();
        for (int j = 0; j < size; j++) {
            node.mTmpClone.mSiblings.set(j, node.mSiblings.get(j).mTmpClone);
        }
        size = node.mParents == null ? 0 : node.mParents.size();
        for (int j = 0; j < size; j++) {
            node.mTmpClone.mParents.set(j, node.mParents.get(j).mTmpClone);
        }
    }
    for (int n = 0; n < nodeCount; n++) {
        mNodes.get(n).mTmpClone = null;
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
79,"<android.view.View: boolean postDelayed(Runnable,long)>",23,24,"<android.view.View: boolean postDelayed(Runnable,long)>","<android.view.View: boolean postDelayed(Runnable,long)>",0,"{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler.postDelayed(action, delayMillis);
    }
    // Assume that post will succeed later
    ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);
    return true;
}","{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler.postDelayed(action, delayMillis);
    }
    // Postpone the runnable until we know on which thread it needs to run.
    // Assume that the runnable will be successfully placed after attach.
    getRunQueue().postDelayed(action, delayMillis);
    return true;
}",1,"/**
 * <p>Causes the Runnable to be added to the message queue, to be run
 * after the specified amount of time elapses.
 * The runnable will be run on the user interface thread.</p>
 *
 * @param action The Runnable that will be executed.
 * @param delayMillis The delay (in milliseconds) until the Runnable
 * will be executed.
 *
 * @return true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.  Note that a
 * result of true does not mean the Runnable will be processed --
 * if the looper is quit before the delivery time of the message
 * occurs then the message will be dropped.
 *
 * @see #post
 * @see #removeCallbacks
 */
","/**
 * <p>Causes the Runnable to be added to the message queue, to be run
 * after the specified amount of time elapses.
 * The runnable will be run on the user interface thread.</p>
 *
 * @param action The Runnable that will be executed.
 * @param delayMillis The delay (in milliseconds) until the Runnable
 * will be executed.
 *
 * @return true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.  Note that a
 * result of true does not mean the Runnable will be processed --
 * if the looper is quit before the delivery time of the message
 * occurs then the message will be dropped.
 *
 * @see #post
 * @see #removeCallbacks
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in a comment and the method call from `ViewRootImpl.getRunQueue()` to `getRunQueue()` without changing the logic or the behavior of the implementation, so the change type is 4.","The change is only in a comment and method call which does not affect the method's behavior. Comments don’t influence code execution, and assuming `getRunQueue()` points to the same `getRunQueue` method previously qualified by the class `ViewRootImpl` there is no change affecting compatibility. No Compatibility Issue should arise from the updated implementation."
83,<android.app.AlarmManager: void setTime(long)>,23,24,<android.app.AlarmManager: void setTime(long)>,<android.app.AlarmManager: void setTime(long)>,0,"{
    try {
        mService.setTime(millis);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mService.setTime(millis);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Set the system wall clock time.
 * Requires the permission android.permission.SET_TIME.
 *
 * @param millis time in milliseconds since the Epoch
 */
","/**
 * Set the system wall clock time.
 * Requires the permission android.permission.SET_TIME.
 *
 * @param millis time in milliseconds since the Epoch
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement in the catch block has changed: it now throws the exception with ""throw ex.rethrowFromSystemServer();"" instead of swallowing the exception, which is a change of type 2.","This change introduces a potential different exception handling because in the earlier version, RemoteException is caught and ignored, while in the late version, it is re-thrown with ""ex.rethrowFromSystemServer();"" leading to a potential different behavior if RemoteException occurs. Therefore, the Compatibility Issue type is 2."
84,<android.widget.TextView: boolean performLongClick()>,23,24,<android.widget.TextView: boolean performLongClick()>,<android.widget.TextView: boolean performLongClick()>,0,"{
    boolean handled = false;
    if (super.performLongClick()) {
        handled = true;
    }
    if (mEditor != null) {
        handled |= mEditor.performLongClick(handled);
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        if (mEditor != null)
            mEditor.mDiscardNextActionUp = true;
    }
    return handled;
}","{
    boolean handled = false;
    if (mEditor != null) {
        mEditor.mIsBeingLongClicked = true;
    }
    if (super.performLongClick()) {
        handled = true;
    }
    if (mEditor != null) {
        handled |= mEditor.performLongClick(handled);
        mEditor.mIsBeingLongClicked = false;
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        if (mEditor != null)
            mEditor.mDiscardNextActionUp = true;
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The order of execution has changed due to an additional assignment mEditor.mIsBeingLongClicked = true. Also, after invoking super.performLongClick(), the assignment mEditor.mIsBeingLongClicked = false is introduced. These represent a control dependency change and other statement changed, indicating a change type of 3,4.","The changes made do not directly affect the return values or exception handling of the method, since handled is still determined in the same way via the same operations. They represent internal state changes without impacting the external behavior. There is no new exception or different return value introduced due to the changes. Thus, there is no Compatibility Issue, which implies the CI type is 0."
86,"<android.content.res.Resources.Theme: boolean resolveAttribute(int,TypedValue,boolean)>",23,24,"<android.content.res.Resources.Theme: boolean resolveAttribute(int,TypedValue,boolean)>","<android.content.res.Resources.Theme: boolean resolveAttribute(int,TypedValue,boolean)>",0,"{
    boolean got = mAssets.getThemeValue(mTheme, resid, outValue, resolveRefs);
    if (false) {
        System.out.println(""resolveAttribute #"" + Integer.toHexString(resid) + "" got="" + got + "", type=0x"" + Integer.toHexString(outValue.type) + "", data=0x"" + Integer.toHexString(outValue.data));
    }
    return got;
}","{
    return mThemeImpl.resolveAttribute(resid, outValue, resolveRefs);
}",1,"/**
 * Retrieve the value of an attribute in the Theme.  The contents of
 * <var>outValue</var> are ultimately filled in by
 * {@link Resources#getValue}.
 *
 * @param resid The resource identifier of the desired theme
 * attribute.
 * @param outValue Filled in with the ultimate resource value supplied
 * by the attribute.
 * @param resolveRefs If true, resource references will be walked; if
 * false, <var>outValue</var> may be a
 * TYPE_REFERENCE.  In either case, it will never
 * be a TYPE_ATTRIBUTE.
 *
 * @return boolean Returns true if the attribute was found and
 * <var>outValue</var> is valid, else false.
 */
","/**
 * Retrieve the value of an attribute in the Theme.  The contents of
 * <var>outValue</var> are ultimately filled in by
 * {@link Resources#getValue}.
 *
 * @param resid The resource identifier of the desired theme
 * attribute.
 * @param outValue Filled in with the ultimate resource value supplied
 * by the attribute.
 * @param resolveRefs If true, resource references will be walked; if
 * false, <var>outValue</var> may be a
 * TYPE_REFERENCE.  In either case, it will never
 * be a TYPE_ATTRIBUTE.
 *
 * @return boolean Returns true if the attribute was found and
 * <var>outValue</var> is valid, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The way the attribute is resolved has changed. The early version uses mAssets.getThemeValue with several parameters, while the late version uses mThemeImpl.resolveAttribute with the same parameters. Moreover, the debug print statement controlled by if(false) has been removed. These are Other statement changes (4), Return statement changed (1), and Dependent API changed (5).","The change of dependent API and the return statement could potentially return a different value due to the change in the method of attribute resolution, hence causing a Compatibility Issue of type 1."
89,<android.widget.TextView: boolean onTextContextMenuItem(int)>,23,24,<android.widget.TextView: boolean onTextContextMenuItem(int)>,<android.widget.TextView: boolean onTextContextMenuItem(int)>,0,"{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            // This starts an action mode if triggered from another action mode. Text is
            // highlighted, so that it can be bulk edited, like selectAllOnFocus does. Returns
            // true even if text is empty.
            boolean shouldRestartActionMode = mEditor != null && mEditor.mTextActionMode != null;
            stopTextActionMode();
            selectAllText();
            if (shouldRestartActionMode) {
                mEditor.startSelectionActionMode();
            }
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            stopTextActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopTextActionMode();
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
    }
    return false;
}","{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            selectAllText();
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopTextActionMode();
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
    }
    return false;
}",1,"/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */
","/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"In the case for ID_SELECT_ALL, the statements 'boolean shouldRestartActionMode = ...' and 'if (shouldRestartActionMode)...' have been removed, changes that fall under the categories of control dependency changed (3) and other statement changed (4).","These changes do not result in a different return value or exception handling. Instead, they modify the behavior inside a specific case without affecting the API's external behavior regarding its output. Therefore, there's no Compatibility Issue detected."
90,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,23,24,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,0,"{
    if (mIndexMetaData.containsKey(position)) {
        return mIndexMetaData.get(position);
    }
    return null;
}","{
    return mIndexMetaData.get(position);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The early version of the code checks if the `mIndexMetaData` contains the key before retrieving the value. If it doesn't contain the key, it returns `null`. The late version of the code directly returns the value without the check, resulting in a difference in the control flow and the return value. So, the code change type is 1.","Since the control flow was changed by removing the check on whether the key exists in `mIndexMetaData`, there might be different return values between the two versions when the key doesn't exist. In the early version, it would return `null`, while in the late version, it might throw a `NullPointerException`. Therefore, the CI type is 1."
94,<android.view.textservice.SpellCheckerSubtype: boolean equals(Object)>,23,24,<android.view.textservice.SpellCheckerSubtype: boolean equals(Object)>,<android.view.textservice.SpellCheckerSubtype: boolean equals(Object)>,0,"{
    if (o instanceof SpellCheckerSubtype) {
        SpellCheckerSubtype subtype = (SpellCheckerSubtype) o;
        return (subtype.hashCode() == hashCode()) && (subtype.getNameResId() == getNameResId()) && (subtype.getLocale().equals(getLocale())) && (subtype.getExtraValue().equals(getExtraValue()));
    }
    return false;
}","{
    if (o instanceof SpellCheckerSubtype) {
        SpellCheckerSubtype subtype = (SpellCheckerSubtype) o;
        if (subtype.mSubtypeId != SUBTYPE_ID_NONE || mSubtypeId != SUBTYPE_ID_NONE) {
            return (subtype.hashCode() == hashCode());
        }
        return (subtype.hashCode() == hashCode()) && (subtype.getNameResId() == getNameResId()) && (subtype.getLocale().equals(getLocale())) && (subtype.getLanguageTag().equals(getLanguageTag())) && (subtype.getExtraValue().equals(getExtraValue()));
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The method implementation has introduced a new control flow (if statement) and the return statement is changed to compare different sets of properties based on the subtype ID. Therefore, the code change classification includes 1 (return statement changed) and 3 (control dependency change).","The addition of a new check for subtype IDs and the change in properties being compared can lead to different return values. These alterations make it possible for the API to return different results given the same input, hence there is a Compatibility Issue of type 1, caused by potential different return values."
95,<android.app.Fragment: void performStart()>,23,24,<android.app.Fragment: void performStart()>,<android.app.Fragment: void performStart()>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
        mChildFragmentManager.execPendingActions();
    }
    mCalled = false;
    onStart();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onStart()"");
    }
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchStart();
    }
    if (mLoaderManager != null) {
        mLoaderManager.doReportStart();
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
        mChildFragmentManager.execPendingActions();
    }
    mState = STARTED;
    mCalled = false;
    onStart();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onStart()"");
    }
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchStart();
    }
    if (mLoaderManager != null) {
        mLoaderManager.doReportStart();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is an additional assignment: ""mState = STARTED;"". This is not within the control, exception handling, or return statements categories. It's an internal state change of the Fragment, which is an 'other' statement change.","The new line that assigns 'STARTED' to 'mState' does not affect the method's return type, nor does it introduce a new code path that could result in a different exception being thrown. It's just an internal state update with no visible effect on method's behavior from the caller's point of view. This does not cause a Compatibility Issue."
96,<android.widget.AccessibilityIterators.PageTextSegmentIterator: int[] preceding(int)>,23,24,<android.widget.AccessibilityIterators.PageTextSegmentIterator: int[] preceding(int)>,<android.widget.AccessibilityIterators.PageTextSegmentIterator: int[] preceding(int)>,0,"{
    final int textLegth = mText.length();
    if (textLegth <= 0) {
        return null;
    }
    if (offset <= 0) {
        return null;
    }
    if (!mView.getGlobalVisibleRect(mTempRect)) {
        return null;
    }
    final int end = Math.min(mText.length(), offset);
    final int currentLine = mLayout.getLineForOffset(end);
    final int currentLineTop = mLayout.getLineTop(currentLine);
    final int pageHeight = mTempRect.height() - mView.getTotalPaddingTop() - mView.getTotalPaddingBottom();
    final int previousPageEndY = currentLineTop - pageHeight;
    final int currentPageStartLine = (previousPageEndY > 0) ? mLayout.getLineForVertical(previousPageEndY) + 1 : 0;
    final int start = getLineEdgeIndex(currentPageStartLine, DIRECTION_START);
    return getRange(start, end);
}","{
    final int textLength = mText.length();
    if (textLength <= 0) {
        return null;
    }
    if (offset <= 0) {
        return null;
    }
    if (!mView.getGlobalVisibleRect(mTempRect)) {
        return null;
    }
    final int end = Math.min(mText.length(), offset);
    final int currentLine = mLayout.getLineForOffset(end);
    final int currentLineTop = mLayout.getLineTop(currentLine);
    final int pageHeight = mTempRect.height() - mView.getTotalPaddingTop() - mView.getTotalPaddingBottom();
    final int previousPageEndY = currentLineTop - pageHeight;
    int currentPageStartLine = (previousPageEndY > 0) ? mLayout.getLineForVertical(previousPageEndY) : 0;
    // start of the next line, so we should move up one fewer lines than we would otherwise.
    if (end == mText.length() && (currentPageStartLine < currentLine)) {
        currentPageStartLine += 1;
    }
    final int start = getLineEdgeIndex(currentPageStartLine, DIRECTION_START);
    return getRange(start, end);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"An additional condition has been introduced that alters the value of `currentPageStartLine` under certain circumstances and other statements are unchanged, so the change types are 3 and 4.","The introduction of the new condition could cause the API to return a different value under the specific condition (where `end == mText.length()` and `currentPageStartLine < currentLine`), resulting in a different behavior of the API. Therefore, the CI type is 1."
97,"<android.accounts.AccountManager: AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String,String[],AccountManagerCallback<Account[]>,Handler)>",23,24,"<android.accounts.AccountManager: AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String,String[],AccountManagerCallback<Account[]>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String,String[],AccountManagerCallback<Account[]>,Handler)>",0,"{
    if (type == null)
        throw new IllegalArgumentException(""type is null"");
    return new Future2Task<Account[]>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAccountsByFeatures(mResponse, type, features, mContext.getOpPackageName());
        }

        public Account[] bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_ACCOUNTS)) {
                throw new AuthenticatorException(""no result in response"");
            }
            final Parcelable[] parcelables = bundle.getParcelableArray(KEY_ACCOUNTS);
            Account[] descs = new Account[parcelables.length];
            for (int i = 0; i < parcelables.length; i++) {
                descs[i] = (Account) parcelables[i];
            }
            return descs;
        }
    }.start();
}","{
    if (type == null)
        throw new IllegalArgumentException(""type is null"");
    return new Future2Task<Account[]>(handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.getAccountsByFeatures(mResponse, type, features, mContext.getOpPackageName());
        }

        @Override
        public Account[] bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_ACCOUNTS)) {
                throw new AuthenticatorException(""no result in response"");
            }
            final Parcelable[] parcelables = bundle.getParcelableArray(KEY_ACCOUNTS);
            Account[] descs = new Account[parcelables.length];
            for (int i = 0; i < parcelables.length; i++) {
                descs[i] = (Account) parcelables[i];
            }
            return descs;
        }
    }.start();
}",1,"/**
 * Lists all accounts of a type which have certain features.  The account
 * type identifies the authenticator (see {@link #getAccountsByType}).
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties (see {@link #hasFeatures}).
 *
 * <p>Unlike {@link #getAccountsByType}, this method calls the authenticator,
 * which may contact the server or do other work to check account features,
 * so the method returns an {@link AccountManagerFuture}.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>Clients of this method that have not been granted the
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission,
 * will only see those accounts managed by AbstractAccountAuthenticators whose
 * signature matches the client.
 *
 * @param type The type of accounts to return, must not be null
 * @param features An array of the account features to require,
 * may be null or empty
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * GET_ACCOUNTS permission is needed for those platforms, irrespective of uid
 * or signature match. See docs for this function in API level 22.
 *
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to an array of
 * {@link Account}, one per account of the specified type which
 * matches the requested features.
 */
","/**
 * Lists all accounts of a type which have certain features.  The account
 * type identifies the authenticator (see {@link #getAccountsByType}).
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties (see {@link #hasFeatures}).
 *
 * <p>Unlike {@link #getAccountsByType}, this method calls the authenticator,
 * which may contact the server or do other work to check account features,
 * so the method returns an {@link AccountManagerFuture}.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>Clients of this method that have not been granted the
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission,
 * will only see those accounts managed by AbstractAccountAuthenticators whose
 * signature matches the client.
 *
 * @param type The type of accounts to return, must not be null
 * @param features An array of the account features to require,
 * may be null or empty
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * GET_ACCOUNTS permission is needed for those platforms, irrespective of uid
 * or signature match. See docs for this function in API level 22.
 *
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to an array of
 * {@link Account}, one per account of the specified type which
 * matches the requested features.
 */
",-1,[@RequiresPermission(GET_ACCOUNTS)],[@RequiresPermission(GET_ACCOUNTS)],-1,-1,-1,-1,-1,-1,0,0,The code is unchanged except addition of the @Override annotations which does not affect the execution of the method.,No Compatibility Issue as there are no changes in method behavior between the two versions.
98,<android.view.View: boolean verifyDrawable(Drawable)>,23,24,<android.view.View: boolean verifyDrawable(Drawable)>,<android.view.View: boolean verifyDrawable(Drawable)>,0,"{
    return who == mBackground || (mScrollCache != null && mScrollCache.scrollBar == who) || (mForegroundInfo != null && mForegroundInfo.mDrawable == who);
}","{
    // drawable from triggering invalidations and scheduling runnables.
    return who == mBackground || (mForegroundInfo != null && mForegroundInfo.mDrawable == who);
}",1,"/**
 * If your view subclass is displaying its own Drawable objects, it should
 * override this function and return true for any Drawable it is
 * displaying.  This allows animations for those drawables to be
 * scheduled.
 *
 * <p>Be sure to call through to the super class when overriding this
 * function.
 *
 * @param who The Drawable to verify.  Return true if it is one you are
 * displaying, else return the result of calling through to the
 * super class.
 *
 * @return boolean If true than the Drawable is being displayed in the
 * view; else false and it is not allowed to animate.
 *
 * @see #unscheduleDrawable(android.graphics.drawable.Drawable)
 * @see #drawableStateChanged()
 */
","/**
 * If your view subclass is displaying its own Drawable objects, it should
 * override this function and return true for any Drawable it is
 * displaying.  This allows animations for those drawables to be
 * scheduled.
 *
 * <p>Be sure to call through to the super class when overriding this
 * function.
 *
 * @param who The Drawable to verify.  Return true if it is one you are
 * displaying, else return the result of calling through to the
 * super class.
 *
 * @return boolean If true than the Drawable is being displayed in the
 * view; else false and it is not allowed to animate.
 *
 * @see #unscheduleDrawable(android.graphics.drawable.Drawable)
 * @see #drawableStateChanged()
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed because a condition has been removed (mScrollCache != null && mScrollCache.scrollBar == who). Additionally, there is a non-functional comment added, which does not affect the control flow or the functional behavior of the code. Thus, the change type is 1,4.","Since a condition in the return statement has been removed, this change could lead to the method returning 'false' where it previously might have returned 'true', because the Drawable that was previously coming from mScrollCache.scrollBar will no longer lead to a 'true' return. The method signature has not changed, and the behavior of the method has, so there is a Compatibility Issue related to different return values, type 1."
99,"<android.app.admin.DevicePolicyManager: void setPermissionPolicy(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPermissionPolicy(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPermissionPolicy(ComponentName,int)>",0,"{
    try {
        mService.setPermissionPolicy(admin, policy);
    } catch (RemoteException re) {
        Log.w(TAG, ""Failed talking with device policy service"", re);
    }
}","{
    throwIfParentInstance(""setPermissionPolicy"");
    try {
        mService.setPermissionPolicy(admin, policy);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by profile or device owners to set the default response for future runtime permission
 * requests by applications. The policy can allow for normal operation which prompts the
 * user to grant a permission, or can allow automatic granting or denying of runtime
 * permission requests by an application. This also applies to new permissions declared by app
 * updates. When a permission is denied or granted this way, the effect is equivalent to setting
 * the permission grant state via {@link #setPermissionGrantState}.
 *
 * <p/>As this policy only acts on runtime permission requests, it only applies to applications
 * built with a {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param policy One of the policy constants {@link #PERMISSION_POLICY_PROMPT},
 * {@link #PERMISSION_POLICY_AUTO_GRANT} and {@link #PERMISSION_POLICY_AUTO_DENY}.
 *
 * @see #setPermissionGrantState
 */
","/**
 * Called by profile or device owners to set the default response for future runtime permission
 * requests by applications. The policy can allow for normal operation which prompts the user to
 * grant a permission, or can allow automatic granting or denying of runtime permission requests
 * by an application. This also applies to new permissions declared by app updates. When a
 * permission is denied or granted this way, the effect is equivalent to setting the permission
 * grant state via {@link #setPermissionGrantState}.
 * <p/>
 * As this policy only acts on runtime permission requests, it only applies to applications
 * built with a {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param policy One of the policy constants {@link #PERMISSION_POLICY_PROMPT},
 * {@link #PERMISSION_POLICY_AUTO_GRANT} and {@link #PERMISSION_POLICY_AUTO_DENY}.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setPermissionGrantState
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,2,"A new method call throwIfParentInstance(""setPermissionPolicy"") is added at the beginning of the method, which can throw an exception, so the code change type is 4 (other statement changed).","The inclusion of the throwIfParentInstance() method can cause a new exception to be thrown before the main functionality of the method is performed, changing exception handling behavior, thus the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
100,<android.hardware.input.InputManager.InputDeviceVibrator: void cancel()>,23,24,<android.hardware.input.InputManager.InputDeviceVibrator: void cancel()>,<android.hardware.input.InputManager.InputDeviceVibrator: void cancel()>,0,"{
    try {
        mIm.cancelVibrate(mDeviceId, mToken);
    } catch (RemoteException ex) {
        Log.w(TAG, ""Failed to cancel vibration."", ex);
    }
}","{
    try {
        mIm.cancelVibrate(mDeviceId, mToken);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from catching the RemoteException and logging it to throwing it again after being processed with rethrowFromSystemServer(), so the code change type is 2.","The original version catches an exception and logs it, while the new version throws it as a RuntimeException. This could lead to a different exception handling behavior for the caller of the API. Thus, the CI type is 2."
101,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",23,24,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
            if (DEBUG)
                Log.v(TAG, ""BadTokenException: IME is done."");
            mWindowVisible = false;
            mWindowAdded = false;
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
        // We have ignored BadTokenException here since Jelly Bean MR-2 (API Level 18).
        // We could ignore BadTokenException in InputMethodService#showWindow() instead,
        // but it may break assumptions for those who override #showWindow() that we can
        // detect errors in #showWindow() by checking BadTokenException.
        // TODO: Investigate its feasibility.  Update JavaDoc of #showWindow() of
        // whether it's OK to override #showWindow() or not.
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}",1,"/**
 * Handle a request by the system to show the soft input area.
 */
","/**
 * Handle a request by the system to show the soft input area.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The method name changed from `onShowInputRequested` to `dispatchOnShowInputRequested`. The exception handling for `BadTokenException` was removed and the debug logging within the catch block has been deleted, which is a type 2 change. Additionally, comments have been added which do not impact execution and hence is a type 4 change. There is also a control dependency change since the exception is no longer caught which affects the flow of the method (type 3).","Since the method no longer explicitly logs or sets variables upon a `BadTokenException`, the behavior of the method when such an exception occurs has changed, potentially affecting the flow and/or observable side-effects of the method which could lead to a CI. Therefore, it is a CI type 2."
102,"<android.view.inputmethod.BaseInputConnection: boolean commitText(CharSequence,int)>",23,24,"<android.view.inputmethod.BaseInputConnection: boolean commitText(CharSequence,int)>","<android.view.inputmethod.BaseInputConnection: boolean commitText(CharSequence,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""commitText "" + text);
    replaceText(text, newCursorPosition, false);
    mIMM.notifyUserAction();
    sendCurrentText();
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""commitText "" + text);
    replaceText(text, newCursorPosition, false);
    sendCurrentText();
    return true;
}",1,"/**
 * Default implementation replaces any existing composing text with
 * the given text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
","/**
 * Default implementation replaces any existing composing text with
 * the given text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement 'mIMM.notifyUserAction();' has been removed, and no other types of code change have happened, so the code change type is 4.","The removed statement does not affect the method's return type or value, nor does it change exception handling. It is not related to control dependencies or the return statement, and thus no Compatibility Issue is introduced. The CI type is 0."
103,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,23,24,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            int requestId = mRepeatingRequestId;
            mRepeatingRequestId = REQUEST_ID_NONE;
            // Queue for deletion after in-flight requests finish
            if (mCaptureCallbackMap.get(requestId) != null) {
                mRepeatingRequestIdDeletedList.add(requestId);
            }
            try {
                LongParcelable lastFrameNumberRef = new LongParcelable();
                mRemoteDevice.cancelRequest(requestId, /*out*/
                lastFrameNumberRef);
                long lastFrameNumber = lastFrameNumberRef.getNumber();
                checkEarlyTriggerSequenceComplete(requestId, lastFrameNumber);
            } catch (CameraRuntimeException e) {
                throw e.asChecked();
            } catch (RemoteException e) {
                // impossible
                return;
            }
        }
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            int requestId = mRepeatingRequestId;
            mRepeatingRequestId = REQUEST_ID_NONE;
            long lastFrameNumber;
            try {
                lastFrameNumber = mRemoteDevice.cancelRequest(requestId);
            } catch (IllegalArgumentException e) {
                if (DEBUG) {
                    Log.v(TAG, ""Repeating request was already stopped for request "" + requestId);
                }
                // Repeating request was already stopped. Nothing more to do.
                return;
            }
            checkEarlyTriggerSequenceComplete(requestId, lastFrameNumber);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","There is a control dependency change as the exception handling for `RemoteException` has been removed and a new one for `IllegalArgumentException` has been introduced. Additionally, the type and the number of return values ​​from `cancelRequest` have changed (from a method providing a `LongParcelable` to a method directly returning a `long`), which qualifies as a dependent API changed. Therefore, the changes are 2, 3, and 5.","The compatibility issues are related to the change in exception handling, where RemoteException is no longer caught, which could lead to a different behavior if such an exception were thrown. Also, the change in the dependent method `cancelRequest` could lead to the API returning a different value (previously a parcelable object, now a direct long value), creating potential issues with return values or types. Hence the CI types are 1 and 2."
105,<android.content.res.AssetManager: CharSequence getResourceText(int)>,23,24,<android.content.res.AssetManager: CharSequence getResourceText(int)>,<android.content.res.AssetManager: CharSequence getResourceText(int)>,0,"{
    synchronized (this) {
        TypedValue tmpValue = mValue;
        int block = loadResourceValue(ident, (short) 0, tmpValue, true);
        if (block >= 0) {
            if (tmpValue.type == TypedValue.TYPE_STRING) {
                return mStringBlocks[block].get(tmpValue.data);
            }
            return tmpValue.coerceToString();
        }
    }
    return null;
}","{
    synchronized (this) {
        final TypedValue outValue = mValue;
        if (getResourceValue(resId, 0, outValue, true)) {
            return outValue.coerceToString();
        }
        return null;
    }
}",1,"/*package*/
","/**
 * Retrieves the string value associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @return the string value, or {@code null}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5",1,There are several changes between the early and late implementation: ,"- Variable names were also changed from `tmpValue` to `outValue` and `ident` to `resId`, though these are just local variable name changes and have no real impact on behavior."
106,<android.app.ActivityManager: List<RunningAppProcessInfo> getRunningAppProcesses()>,23,24,<android.app.ActivityManager: List<RunningAppProcessInfo> getRunningAppProcesses()>,<android.app.ActivityManager: List<RunningAppProcessInfo> getRunningAppProcesses()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getRunningAppProcesses();
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getRunningAppProcesses();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a list of application processes that are running on the device.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @return Returns a list of RunningAppProcessInfo records, or null if there are no
 * running processes (it will not return an empty list).  This list ordering is not
 * specified.
 */
","/**
 * Returns a list of application processes that are running on the device.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @return Returns a list of RunningAppProcessInfo records, or null if there are no
 * running processes (it will not return an empty list).  This list ordering is not
 * specified.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from returning null to throwing a new exception with throw e.rethrowFromSystemServer(), hence the change type is 2.","Due to the change in the exception handling, where the API previously returned null when catching a RemoteException, it now throws a new exception. This change in exception handling can lead to a different behavior, causing a Compatibility Issue of type 2."
107,"<android.widget.ListView: int measureHeightOfChildren(int,int,int,int,int)>",23,24,"<android.widget.ListView: int measureHeightOfChildren(int,int,int,int,int)>","<android.widget.ListView: int measureHeightOfChildren(int,int,int,int,int)>",0,"{
    final ListAdapter adapter = mAdapter;
    if (adapter == null) {
        return mListPadding.top + mListPadding.bottom;
    }
    // Include the padding of the list
    int returnedHeight = mListPadding.top + mListPadding.bottom;
    final int dividerHeight = ((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
    // The previous height value that was less than maxHeight and contained
    // no partial children
    int prevHeightWithoutPartialChild = 0;
    int i;
    View child;
    // mItemCount - 1 since endPosition parameter is inclusive
    endPosition = (endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
    final AbsListView.RecycleBin recycleBin = mRecycler;
    final boolean recyle = recycleOnMeasure();
    final boolean[] isScrap = mIsScrap;
    for (i = startPosition; i <= endPosition; ++i) {
        child = obtainView(i, isScrap);
        measureScrapChild(child, i, widthMeasureSpec, maxHeight);
        if (i > 0) {
            // Count the divider for all but one child
            returnedHeight += dividerHeight;
        }
        // Recycle the view before we possibly return from the method
        if (recyle && recycleBin.shouldRecycleViewType(((LayoutParams) child.getLayoutParams()).viewType)) {
            recycleBin.addScrapView(child, -1);
        }
        returnedHeight += child.getMeasuredHeight();
        if (returnedHeight >= maxHeight) {
            // then the i'th position did not fit completely.
            return // Disallowing is enabled (> -1)
            (disallowPartialChildPosition >= 0) && // We've past the min pos
            (i > disallowPartialChildPosition) && // We have a prev height
            (prevHeightWithoutPartialChild > 0) && // i'th child did not fit completely
            (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
        }
        if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
            prevHeightWithoutPartialChild = returnedHeight;
        }
    }
    // completely fit, so return the returnedHeight
    return returnedHeight;
}","{
    final ListAdapter adapter = mAdapter;
    if (adapter == null) {
        return mListPadding.top + mListPadding.bottom;
    }
    // Include the padding of the list
    int returnedHeight = mListPadding.top + mListPadding.bottom;
    final int dividerHeight = mDividerHeight;
    // The previous height value that was less than maxHeight and contained
    // no partial children
    int prevHeightWithoutPartialChild = 0;
    int i;
    View child;
    // mItemCount - 1 since endPosition parameter is inclusive
    endPosition = (endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
    final AbsListView.RecycleBin recycleBin = mRecycler;
    final boolean recyle = recycleOnMeasure();
    final boolean[] isScrap = mIsScrap;
    for (i = startPosition; i <= endPosition; ++i) {
        child = obtainView(i, isScrap);
        measureScrapChild(child, i, widthMeasureSpec, maxHeight);
        if (i > 0) {
            // Count the divider for all but one child
            returnedHeight += dividerHeight;
        }
        // Recycle the view before we possibly return from the method
        if (recyle && recycleBin.shouldRecycleViewType(((LayoutParams) child.getLayoutParams()).viewType)) {
            recycleBin.addScrapView(child, -1);
        }
        returnedHeight += child.getMeasuredHeight();
        if (returnedHeight >= maxHeight) {
            // then the i'th position did not fit completely.
            return // Disallowing is enabled (> -1)
            (disallowPartialChildPosition >= 0) && // We've past the min pos
            (i > disallowPartialChildPosition) && // We have a prev height
            (prevHeightWithoutPartialChild > 0) && // i'th child did not fit completely
            (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
        }
        if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
            prevHeightWithoutPartialChild = returnedHeight;
        }
    }
    // completely fit, so return the returnedHeight
    return returnedHeight;
}",1,"/**
 * Measures the height of the given range of children (inclusive) and
 * returns the height with this ListView's padding and divider heights
 * included. If maxHeight is provided, the measuring will stop when the
 * current height reaches maxHeight.
 *
 * @param widthMeasureSpec The width measure spec to be given to a child's
 * {@link View#measure(int, int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to be
 * shown. Specify {@link #NO_POSITION} if the last child should be
 * the last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all the
 * children don't fit in this value, this value will be
 * returned).
 * @param disallowPartialChildPosition In general, whether the returned
 * height should only contain entire children. This is more
 * powerful--it is the first inclusive position at which partial
 * children will not be allowed. Example: it looks nice to have
 * at least 3 completely visible children, and in portrait this
 * will most likely fit; but in landscape there could be times
 * when even 2 children can not be completely shown, so a value
 * of 2 (remember, inclusive) would be good (assuming
 * startPosition is 0).
 * @return The height of this ListView with the given children.
 */
","/**
 * Measures the height of the given range of children (inclusive) and
 * returns the height with this ListView's padding and divider heights
 * included. If maxHeight is provided, the measuring will stop when the
 * current height reaches maxHeight.
 *
 * @param widthMeasureSpec The width measure spec to be given to a child's
 * {@link View#measure(int, int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to be
 * shown. Specify {@link #NO_POSITION} if the last child should be
 * the last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all the
 * children don't fit in this value, this value will be
 * returned).
 * @param disallowPartialChildPosition In general, whether the returned
 * height should only contain entire children. This is more
 * powerful--it is the first inclusive position at which partial
 * children will not be allowed. Example: it looks nice to have
 * at least 3 completely visible children, and in portrait this
 * will most likely fit; but in landscape there could be times
 * when even 2 children can not be completely shown, so a value
 * of 2 (remember, inclusive) would be good (assuming
 * startPosition is 0).
 * @return The height of this ListView with the given children.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment of `dividerHeight` has changed from a conditional operation to a direct assignment from the `mDividerHeight` field. This is categorized as an ""Other statement changed"".","Even though the calculation of `dividerHeight` is simpler in the late version, as long as `mDividerHeight` is set to the same value in both versions, the overall behavior of the method remains the same. The removal of the condition that checks `mDivider` != null and `mDividerHeight > 0` does not lead to a compatibility issue because the value of `returnedHeight` is ultimately the same when `mDividerHeight` is greater than 0 and `mDivider` is not null. There is no indication that `mDividerHeight` can be negative. Thus, there is no compatibility issue in this change."
108,<android.app.admin.DevicePolicyManager: int getCurrentFailedPasswordAttempts()>,23,24,<android.app.admin.DevicePolicyManager: int getCurrentFailedPasswordAttempts()>,<android.app.admin.DevicePolicyManager: int getCurrentFailedPasswordAttempts()>,0,"{
    if (mService != null) {
        try {
            return mService.getCurrentFailedPasswordAttempts(UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return -1;
}","{
    return getCurrentFailedPasswordAttempts(myUserId());
}",1,"/**
 * Retrieve the number of times the user has failed at entering a
 * password since that last successful password entry.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} to be able to call
 * this method; if it has not, a security exception will be thrown.
 */
","/**
 * Retrieve the number of times the user has failed at entering a password since that last
 * successful password entry.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to retrieve the number of failed
 * password attemts for the parent user.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN}
 * to be able to call this method; if it has not, a security exception will be thrown.
 *
 * @return The number of times user has entered an incorrect password since the last correct
 * password entry.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The way of obtaining the current failed password attempts count has changed. The early version directly interacts with a service member (mService) and handles RemoteException, while the late version calls another method (getCurrentFailedPasswordAttempts) with the current user ID. Therefore, it is considered an 'Other statement changed' since the logic and calls have been refactored, and it is also a 'Dependent API changed' because the method now depends on a different version of getCurrentFailedPasswordAttempts. However, because there are no details provided about that new API, it's impossible to analyze its implementation and its effect on compatibility more deeply.","The late version of the code removes exception handling logic for RemoteException and it seems that the exception could now be propagated to the caller which was earlier logged and not propagated. Moreover, the refactoring to call getCurrentFailedPasswordAttempts(myUserId()) method indicates that there may be a different implementation which could lead to different behaviour, and hence, it could cause a Compatibility Issue due to a potentially different return value."
111,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",23,24,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>","<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",0,"{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.min(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                width += lineWidths[i];
                flag |= flags[i] & TAB_MASK;
            }
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}","{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
112,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",23,24,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>","<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccountExplicitly(account, password, userdata);
    } catch (RemoteException e) {
        // Can happen if there was a SecurityException was thrown.
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccountExplicitly(account, password, userdata);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Adds an account directly to the AccountManager. Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 * <p>Calling this method does not update the last authenticated timestamp,
 * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * However, if this method is called when it is triggered by addAccount() or
 * addAccountAsUser() or similar functions, then there is no need to update
 * timestamp manually as it is updated automatically by framework on
 * successful completion of the mentioned functions.
 * <p>It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for
 * none
 * @return True if the account was successfully added, false if the account
 * already exists, the account is null, or another error occurs.
 */
","/**
 * Adds an account directly to the AccountManager. Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 * <p>Calling this method does not update the last authenticated timestamp,
 * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * However, if this method is called when it is triggered by addAccount() or
 * addAccountAsUser() or similar functions, then there is no need to update
 * timestamp manually as it is updated automatically by framework on
 * successful completion of the mentioned functions.
 * <p>It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for
 * none
 * @return True if the account was successfully added, false if the account
 * already exists, the account is null, or another error occurs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from ""throw new RuntimeException(e);"" to ""throw e.rethrowFromSystemServer();"", so the code change type is 2.","Since the way RemoteException is being handled has changed, the exception thrown by the method in case of RemoteException will be different. This is a compatibility issue as it affects the exception handling of the method, so the CI type is 2."
113,"<android.net.TrafficStats: void incrementOperationCount(int,int)>",23,24,"<android.net.TrafficStats: void incrementOperationCount(int,int)>","<android.net.TrafficStats: void incrementOperationCount(int,int)>",0,"{
    final int uid = android.os.Process.myUid();
    try {
        getStatsService().incrementOperationCount(uid, tag, operationCount);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    final int uid = android.os.Process.myUid();
    try {
        getStatsService().incrementOperationCount(uid, tag, operationCount);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Increment count of network operations performed under the given
 * accounting tag. This can be used to derive bytes-per-operation.
 *
 * @param tag Accounting tag used in {@link #setThreadStatsTag(int)}.
 * @param operationCount Number of operations to increment count by.
 */
","/**
 * Increment count of network operations performed under the given
 * accounting tag. This can be used to derive bytes-per-operation.
 *
 * @param tag Accounting tag used in {@link #setThreadStatsTag(int)}.
 * @param operationCount Number of operations to increment count by.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement is changed to a different method of exception handling (throw new RuntimeException(e) to throw e.rethrowFromSystemServer()), hence, the code change type is 2.","The change in exception handling could result in the API throwing a different exception under specific circumstances (catching RemoteException), therefore representing a change in the API's behavior. The CI type due to this change is 2."
115,"<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>",23,24,"<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>","<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>",0,"{
    final Sensor sensor = mManager.mHandleToSensor.get(handle);
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    // call onAccuracyChanged() only if the value changes
    final int accuracy = mSensorAccuracies.get(handle);
    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
        mSensorAccuracies.put(handle, t.accuracy);
        mListener.onAccuracyChanged(t.sensor, t.accuracy);
    }
    mListener.onSensorChanged(t);
}","{
    final Sensor sensor = mManager.mHandleToSensor.get(handle);
    if (sensor == null) {
        // sensor disconnected
        return;
    }
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    // call onAccuracyChanged() only if the value changes
    final int accuracy = mSensorAccuracies.get(handle);
    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
        mSensorAccuracies.put(handle, t.accuracy);
        mListener.onAccuracyChanged(t.sensor, t.accuracy);
    }
    mListener.onSensorChanged(t);
}",1,"// Called from native code.
","// Called from native code.
",-1,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",-1,-1,-1,-1,-1,-1,"1,3",1,"The early version does not check if the sensor variable is 'null', whereas the late version introduces a 'null' check for the sensor and returns if it is 'null'. The 'if' condition added involves checking a different variable (sensor instead of t), which changes the control dependency. Therefore, the code change types are 1 and 3.","The addition of a 'null' check on the sensor variable and an early return if the sensor is 'null' can lead to a scenario where a SensorEvent is not dispatched, which would be a change in behavior compared to the early version. This means the method could potentially return without dispatching an event, causing a CI of type 1 due to a potential different return value or type."
116,<android.os.UserManager: boolean isSystemUser()>,23,24,<android.os.UserManager: boolean isSystemUser()>,<android.os.UserManager: boolean isSystemUser()>,0,"{
    return UserHandle.myUserId() == UserHandle.USER_OWNER;
}","{
    return UserHandle.myUserId() == UserHandle.USER_SYSTEM;
}",1,"/**
 * Used to check if this process is running under the system user. The system user
 * is the initial user that is implicitly created on first boot and hosts most of the
 * system services.
 *
 * @return whether this process is running under the system user.
 */
","/**
 * Used to check if this process is running under the system user. The system user
 * is the initial user that is implicitly created on first boot and hosts most of the
 * system services.
 *
 * @return whether this process is running under the system user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed as the comparison has been updated from UserHandle.USER_OWNER to UserHandle.USER_SYSTEM and definition of the constant to check against changed, so the code change type is 1,5.","The return value will differ if UserHandle.USER_OWNER and UserHandle.USER_SYSTEM are not referring to the same value. The constant used in the comparison has been changed, which potentially alters the boolean result. Therefore, the CI type is 1."
117,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: void reset()>,23,24,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: void reset()>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: void reset()>,0,"{
    // Note: We do not try and reset the meta data, since that information is still used by
    // collection views to validate it's own contents (and will be re-requested if the data
    // is invalidated through the notifyDataSetChanged() flow).
    mPreloadLowerBound = 0;
    mPreloadUpperBound = -1;
    mLastRequestedIndex = -1;
    mIndexRemoteViews.clear();
    mIndexMetaData.clear();
    synchronized (mLoadIndices) {
        mRequestedIndices.clear();
        mLoadIndices.clear();
    }
}","{
    // Note: We do not try and reset the meta data, since that information is still used by
    // collection views to validate it's own contents (and will be re-requested if the data
    // is invalidated through the notifyDataSetChanged() flow).
    mPreloadLowerBound = 0;
    mPreloadUpperBound = -1;
    mLastRequestedIndex = -1;
    mIndexRemoteViews.clear();
    mIndexMetaData.clear();
    synchronized (mIndicesToLoad) {
        mIndicesToLoad.clear();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code changes include one variable name change from `mLoadIndices` to `mIndicesToLoad` and an adjustment in the synchronized block, so the change type is 4,5.","There is no CI caused as no new behavior is introduced. The change to the variable name within the internal synchronized block will not affect the external behavior. There is no change in the return value or exception thrown, so the CI type is 0."
118,<android.app.ActivityThread.Idler: boolean queueIdle()>,23,24,<android.app.ActivityThread.Idler: boolean queueIdle()>,<android.app.ActivityThread.Idler: boolean queueIdle()>,0,"{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig, stopProfiling);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                // Ignore
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    ensureJitEnabled();
    return false;
}","{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig, stopProfiling);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                    throw ex.rethrowFromSystemServer();
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    ensureJitEnabled();
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"In the late version of the implementation, there is an added throw statement within the catch block for RemoteException which replaces the comment `// Ignore`. The exception is now rethrown using `throw ex.rethrowFromSystemServer();`, causing a change in exception handling, so the change type is 2.","The change in exception handling implies that where a RemoteException was previously silently ignored, it will now be thrown wrapped in a RuntimeException, meaning clients of this API might now have to handle an additional unchecked exception. Thus, there is a change in the potential exceptions thrown by the API, and the CI type is 2."
119,<android.print.PrinterInfo.Builder: Builder setStatus(int)>,23,24,<android.print.PrinterInfo.Builder: Builder setStatus(int)>,<android.print.PrinterInfo.Builder: Builder setStatus(int)>,0,"{
    mPrototype.mStatus = status;
    return this;
}","{
    mStatus = checkStatus(status);
    return this;
}",1,"/**
 * Sets the printer status.
 *
 * @param status The status.
 * @return This builder.
 *
 * @see PrinterInfo#STATUS_IDLE
 * @see PrinterInfo#STATUS_BUSY
 * @see PrinterInfo#STATUS_UNAVAILABLE
 */
","/**
 * Sets the printer status.
 *
 * @param status The status.
 * @return This builder.
 * @see PrinterInfo#STATUS_IDLE
 * @see PrinterInfo#STATUS_BUSY
 * @see PrinterInfo#STATUS_UNAVAILABLE
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method for setting status has changed to include a check via ""checkStatus(status)"" instead of directly assigning the status. This is a change in an internal method call, which is a type 4 change (Other statement changed). Additionally, the field being modified has changed from ""mPrototype.mStatus"" to ""mStatus,"" indicating that the member being accessed has changed, which is categorized under type 5 (Dependent API changed).","However, assuming ""checkStatus(status)"" validates the status and potentially throws an error if the status is invalid, this would not introduce a compatibility issue considering the following assumption: The method ""Builder setStatus(int)"" is expected to assign a valid status to the printer info. If we assume ""checkStatus(status)"" only throws an exception for invalid status values, this wouldn't change the behavior from the caller's perspective in terms of valid input. If the status is valid, the behavior remains the same, thus there is no compatibility issue (type 0). If the input status is invalid, then throwing an exception would be consistent with handling an out-of-contract condition, which also does not constitute a compatibility issue."
120,<android.app.Activity: boolean navigateUpTo(Intent)>,23,24,<android.app.Activity: boolean navigateUpTo(Intent)>,<android.app.Activity: boolean navigateUpTo(Intent)>,0,"{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess();
        }
        try {
            upIntent.prepareToLeaveProcess();
            return ActivityManagerNative.getDefault().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}","{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess(this);
        }
        try {
            upIntent.prepareToLeaveProcess(this);
            return ActivityManagerNative.getDefault().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}",1,"/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
","/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method calls resultData.prepareToLeaveProcess() and upIntent.prepareToLeaveProcess() in the early version were changed to resultData.prepareToLeaveProcess(this) and upIntent.prepareToLeaveProcess(this) in the late version. This change indicates that the signatures for these methods have been updated to take an additional parameter. The change type is thus 4,5 - Other statement changed and Dependent API changed.","There is no Compatibility Issue because the modification does not lead to a different return value or type, nor does it change exception handling. It is an internal change where an extra context parameter is passed to the method, but it is not exposed in the API's contract or behavior to the client code, assuming that the updated prepareToLeaveProcess() methods properly handle the addition of the Activity reference without altering the behavior as seen by the caller."
122,"<android.print.PrinterCapabilitiesInfo.Builder: Builder setColorModes(int,int)>",23,24,"<android.print.PrinterCapabilitiesInfo.Builder: Builder setColorModes(int,int)>","<android.print.PrinterCapabilitiesInfo.Builder: Builder setColorModes(int,int)>",0,"{
    int currentModes = colorModes;
    while (currentModes > 0) {
        final int currentMode = (1 << Integer.numberOfTrailingZeros(currentModes));
        currentModes &= ~currentMode;
        PrintAttributes.enforceValidColorMode(currentMode);
    }
    PrintAttributes.enforceValidColorMode(defaultColorMode);
    mPrototype.mColorModes = colorModes;
    mPrototype.mDefaults[PROPERTY_COLOR_MODE] = defaultColorMode;
    return this;
}","{
    enforceValidMask(colorModes, (currentMode) -> PrintAttributes.enforceValidColorMode(currentMode));
    PrintAttributes.enforceValidColorMode(defaultColorMode);
    mPrototype.mColorModes = colorModes;
    mPrototype.mDefaults[PROPERTY_COLOR_MODE] = defaultColorMode;
    return this;
}",1,"/**
 * Sets the color modes.
 * <p>
 * <strong>Required:</strong> Yes
 * </p>
 *
 * @param colorModes The color mode bit mask.
 * @param defaultColorMode The default color mode.
 * @return This builder.
 * <p>
 * <strong>Note:</strong> On platform version 19 (Kitkat) specifying
 * only PrintAttributes#COLOR_MODE_MONOCHROME leads to a print spooler
 * crash. Hence, you should declare either both color modes or
 * PrintAttributes#COLOR_MODE_COLOR.
 * </p>
 *
 * @throws IllegalArgumentException If color modes contains an invalid
 * mode bit or if the default color mode is invalid.
 *
 * @see PrintAttributes#COLOR_MODE_COLOR
 * @see PrintAttributes#COLOR_MODE_MONOCHROME
 */
","/**
 * Sets the color modes.
 * <p>
 * <strong>Required:</strong> Yes
 * </p>
 *
 * @param colorModes The color mode bit mask.
 * @param defaultColorMode The default color mode.
 * @return This builder.
 * <p>
 * <strong>Note:</strong> On platform version 19 (Kitkat) specifying
 * only PrintAttributes#COLOR_MODE_MONOCHROME leads to a print spooler
 * crash. Hence, you should declare either both color modes or
 * PrintAttributes#COLOR_MODE_COLOR.
 * </p>
 *
 * @throws IllegalArgumentException If color modes contains an invalid
 * mode bit or if the default color mode is invalid.
 *
 * @see PrintAttributes#COLOR_MODE_COLOR
 * @see PrintAttributes#COLOR_MODE_MONOCHROME
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The control structure for processing 'colorModes' has been entirely replaced with a call to a new method 'enforceValidMask'. This removed the 'while' loop and introduced a new method call with a lambda expression, so the code change types are 3,4,5.","Although the implementation has changed, there's no indication that the behavior of 'PrinterCapabilitiesInfo.Builder setColorModes(int,int)' will be different between the early version and the late version. The method still enforces valid color modes and sets the color modes and default color mode on the prototype object identically in both versions. Therefore, there is no compatibility issue caused by potential different return values, types, or exception handlings, and the pred_CI is 0."
123,<android.view.ViewGroup: ArrayList<View> buildOrderedChildList()>,23,24,<android.view.ViewGroup: ArrayList<View> buildOrderedChildList()>,<android.view.ViewGroup: ArrayList<View> buildOrderedChildList()>,0,"{
    final int count = mChildrenCount;
    if (count <= 1 || !hasChildWithZ())
        return null;
    if (mPreSortedChildren == null) {
        mPreSortedChildren = new ArrayList<View>(count);
    } else {
        mPreSortedChildren.ensureCapacity(count);
    }
    final boolean useCustomOrder = isChildrenDrawingOrderEnabled();
    for (int i = 0; i < mChildrenCount; i++) {
        // add next child (in child order) to end of list
        int childIndex = useCustomOrder ? getChildDrawingOrder(mChildrenCount, i) : i;
        View nextChild = mChildren[childIndex];
        float currentZ = nextChild.getZ();
        // insert ahead of any Views with greater Z
        int insertIndex = i;
        while (insertIndex > 0 && mPreSortedChildren.get(insertIndex - 1).getZ() > currentZ) {
            insertIndex--;
        }
        mPreSortedChildren.add(insertIndex, nextChild);
    }
    return mPreSortedChildren;
}","{
    final int childrenCount = mChildrenCount;
    if (childrenCount <= 1 || !hasChildWithZ())
        return null;
    if (mPreSortedChildren == null) {
        mPreSortedChildren = new ArrayList<>(childrenCount);
    } else {
        // callers should clear, so clear shouldn't be necessary, but for safety...
        mPreSortedChildren.clear();
        mPreSortedChildren.ensureCapacity(childrenCount);
    }
    final boolean customOrder = isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        // add next child (in child order) to end of list
        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        final View nextChild = mChildren[childIndex];
        final float currentZ = nextChild.getZ();
        // insert ahead of any Views with greater Z
        int insertIndex = i;
        while (insertIndex > 0 && mPreSortedChildren.get(insertIndex - 1).getZ() > currentZ) {
            insertIndex--;
        }
        mPreSortedChildren.add(insertIndex, nextChild);
    }
    return mPreSortedChildren;
}",1,"/**
 * Populates (and returns) mPreSortedChildren with a pre-ordered list of the View's children,
 * sorted first by Z, then by child drawing order (if applicable). This list must be cleared
 * after use to avoid leaking child Views.
 *
 * Uses a stable, insertion sort which is commonly O(n) for ViewGroups with very few elevated
 * children.
 */
","/**
 * Populates (and returns) mPreSortedChildren with a pre-ordered list of the View's children,
 * sorted first by Z, then by child drawing order (if applicable). This list must be cleared
 * after use to avoid leaking child Views.
 *
 * Uses a stable, insertion sort which is commonly O(n) for ViewGroups with very few elevated
 * children.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation code changes include renaming variables for clarity and modifying the reuse of the `mPreSortedChildren` list by clearing it before ensuring capacity, instead of just ensuring capacity. Additionally, the method `getChildDrawingOrder` is replaced with `getAndVerifyPreorderedIndex`, changing how children drawing order is retrieved. These changes are control dependency changes and fall under other statement changes as well, specifically variable renaming and dependent method invocation with potentially different logic (type 3,4).","Despite the changes in implementation, there is no compatibility issue as they do not affect the list returned by the `buildOrderedChildList` method. The logic for ordering the child views remains consistent with the previous version. The change in method from `getChildDrawingOrder` to `getAndVerifyPreorderedIndex` is an internal change and presumes that the latter method serves the same purpose with additional verification, without changing the output contract of `buildOrderedChildList`. Thus, there is no CI (type 0)."
124,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",23,24,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                ds[0].mIsSelectionStarted = false;
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                        if (event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                            ds[0].mIsActivelySelecting = true;
                            ds[0].mIsSelectionStarted = true;
                        }
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        ds[0].mIsActivelySelecting = false;
                    }
                    float dx;
                    float dy;
                    if (cap && event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        scrollTo(widget, layout, nx, ny);
                    }
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}","{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    float dx;
                    float dy;
                    if (cap) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}",1,"/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
","/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
126,<android.animation.ValueAnimator: void resume()>,23,24,<android.animation.ValueAnimator: void resume()>,<android.animation.ValueAnimator: void resume()>,0,"{
    if (mPaused) {
        mResumed = true;
    }
    super.resume();
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be resumed from the same "" + ""thread that the animator was started on"");
    }
    if (mPaused && !mResumed) {
        mResumed = true;
        if (mPauseTime > 0) {
            AnimationHandler handler = AnimationHandler.getInstance();
            handler.addAnimationFrameCallback(this, 0);
        }
    }
    super.resume();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","Changes include the addition of an exception throwing statement, control dependency changes within the 'if' block, and other statement changes (such as setting `mResumed = true` under different conditions, checking `Looper.myLooper()` and the use of `AnimationHandler`). Therefore, the code change types are 2,3,4.","1) Exception handling statement changed: A `throw` statement has been introduced that depends on the condition `Looper.myLooper() == null`, which could potentially throw a new RuntimeException if the Looper check fails. This is a direct cause of a potential different exception handling."
127,"<android.app.admin.DevicePolicyManager: void uninstallCaCert(ComponentName,byte[])>",23,24,"<android.app.admin.DevicePolicyManager: void uninstallCaCert(ComponentName,byte[])>","<android.app.admin.DevicePolicyManager: void uninstallCaCert(ComponentName,byte[])>",0,"{
    if (mService != null) {
        try {
            final String alias = getCaCertAlias(certBuffer);
            mService.uninstallCaCerts(admin, new String[] { alias });
        } catch (CertificateException e) {
            Log.w(TAG, ""Unable to parse certificate"", e);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""uninstallCaCert"");
    if (mService != null) {
        try {
            final String alias = getCaCertAlias(certBuffer);
            mService.uninstallCaCerts(admin, new String[] { alias });
        } catch (CertificateException e) {
            Log.w(TAG, ""Unable to parse certificate"", e);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Uninstalls the given certificate from trusted user CAs, if present.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to remove.
 */
","/**
 * Uninstalls the given certificate from trusted user CAs, if present.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to remove.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An additional call to throwIfParentInstance(""uninstallCaCert"") is added at the beginning of the late version, and exception handling is changed for RemoteException. It now throws the exception instead of just logging it. This categorizes as other statement changed (4) and exception handling statement changed (2).","The addition of a new method call (throwIfParentInstance) could lead to an exception being thrown before the original implementation is executed, if certain conditions are met. Moreover, changes in the RemoteException catch block now throw the exception up the chain, altering the method's behavior regarding exception handling. Both changes could potentially cause a Compatibility Issue due to different exception handlings, so the CI type is 2."
129,<android.content.ClipboardManager: boolean hasPrimaryClip()>,23,24,<android.content.ClipboardManager: boolean hasPrimaryClip()>,<android.content.ClipboardManager: boolean hasPrimaryClip()>,0,"{
    try {
        return getService().hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return getService().hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if there is currently a primary clip on the clipboard.
 */
","/**
 * Returns true if there is currently a primary clip on the clipboard.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. In the early version, the method catches the RemoteException and returns false, while in the late version, the code rethrows the exception via e.rethrowFromSystemServer(). Hence, the change type is 2.","This change in exception handling potentially leads to different behaviors in the API. Instead of returning false when a RemoteException occurs in the early version, the late version will now throw an exception, which is a different way of handling errors. Therefore, the CI type is 2."
130,<android.app.ContextImpl: boolean isRestricted()>,23,24,<android.app.ContextImpl: boolean isRestricted()>,<android.app.ContextImpl: boolean isRestricted()>,0,"{
    return mRestricted;
}","{
    return (mFlags & Context.CONTEXT_RESTRICTED) != 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The logic of how the return value is determined has changed from directly returning the value of a field (mRestricted) to evaluating a condition involving a bitwise operation (mFlags & Context.CONTEXT_RESTRICTED), so the code change types are 1 and 4.","Since the way of determining the return value has been altered significantly, there is a potential that the value returned by the API could be different in the late version. Therefore, this could lead to a Compatibility Issue of type 1."
131,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLowerCase(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLowerCase(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of lower case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of lower case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
","/**
 * Called by an application that is administering the device to set the minimum number of lower
 * case letters required in the password. After setting this, the user will not be able to enter
 * a new password that is not at least as restrictive as what has been set. Note that the
 * current password will remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of lower case letters required in the password.
 * A value of 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"An additional parameter, 'mParentInstance', is passed to the method mService.setPasswordMinimumLowerCase, and a new throw statement is introduced to replace a log statement inside the catch block. The code change type is 2,4,5 due to the additional parameter in the method call and changes inside the exception handling block.","The additional parameter could affect the behavior of the called method, and altering throwing an exception instead of just logging it can alter the exception behavior of the method. Potential different exception handling constitutes a CI of type 2."
133,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,23,24,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) {
        // We don't have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }
    boolean result = false;
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }
    if (onFilterTouchEventForSecurity(event)) {
        // noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }
    if (!result && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN && !result)) {
        stopNestedScroll();
    }
    return result;
}","{
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) {
        // We don't have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }
    boolean result = false;
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }
    if (onFilterTouchEventForSecurity(event)) {
        if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
            result = true;
        }
        // noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }
    if (!result && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN && !result)) {
        stopNestedScroll();
    }
    return result;
}",1,"/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change introduces an additional conditional block that checks if `(mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)` and sets `result` to true if it evaluates to true. This is not a change in the return statement, exception handling, control dependency, or a dependent API change. Thus, the code is classified as 4 (Other statement changed).","The newly added conditional block adds the ability to set `result` to true under a new condition related to scrollbar dragging. However, since the return value `result` is already set to true based on other conditions that remain unchanged, this does not necessarily lead to a different return value or exception handling, assuming the method `handleScrollBarDragging(event)` does not throw an exception. Therefore, there's no CI, and the answer is 0 (No Compatibility Issue)."
134,<android.app.Activity: void performStart()>,23,24,<android.app.Activity: void performStart()>,<android.app.Activity: void performStart()>,0,"{
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
    mActivityTransitionState.enterReady(this);
}","{
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
    // This property is set for all builds except final release
    boolean isDlwarningEnabled = SystemProperties.getInt(""ro.bionic.ld.warning"", 0) == 1;
    boolean isAppDebuggable = (mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    if (isAppDebuggable || isDlwarningEnabled) {
        String dlwarning = getDlWarning();
        if (dlwarning != null) {
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = ""Detected problems with app native libraries\n"" + ""(please consult log for detail):\n"" + dlwarning;
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + ""\n"" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    mActivityTransitionState.enterReady(this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a new control dependency (if-statement block) that checks for `isDlwarningEnabled` and `isAppDebuggable`. It also includes new other statements to execute within this if-block, such as getting the dlwarning and showing a dialog or toast if certain conditions are met. However, these are not related to the method's return type or exception handling; thus, the code change types are 3 (Control dependency changed) and 4 (Other statement changed).","Although there are new statements and control flows introduced, these changes do not affect the method's signature or its intended behavior, as it neither changes the return type/value nor introduces new exceptions. It specifically adds diagnostic messages that alert the developer of issues, which do not translate to a behavioral change from the perspective of the API consumer. Therefore, there are no Compatibility Issues regarding the return value or the exceptions thrown by the method; thus, the CI type is 0 (No Compatibility Issue)."
135,<android.app.ActivityThread.H: String codeToString(int)>,23,24,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case CANCEL_VISIBLE_BEHIND:
                return ""CANCEL_VISIBLE_BEHIND"";
            case BACKGROUND_VISIBLE_BEHIND_CHANGED:
                return ""BACKGROUND_VISIBLE_BEHIND_CHANGED"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case CANCEL_VISIBLE_BEHIND:
                return ""CANCEL_VISIBLE_BEHIND"";
            case BACKGROUND_VISIBLE_BEHIND_CHANGED:
                return ""BACKGROUND_VISIBLE_BEHIND_CHANGED"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case MULTI_WINDOW_MODE_CHANGED:
                return ""MULTI_WINDOW_MODE_CHANGED"";
            case PICTURE_IN_PICTURE_MODE_CHANGED:
                return ""PICTURE_IN_PICTURE_MODE_CHANGED"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
137,<android.content.pm.PackageInstaller: void unregisterSessionCallback(SessionCallback)>,23,24,<android.content.pm.PackageInstaller: void unregisterSessionCallback(SessionCallback)>,<android.content.pm.PackageInstaller: void unregisterSessionCallback(SessionCallback)>,0,"{
    synchronized (mDelegates) {
        for (Iterator<SessionCallbackDelegate> i = mDelegates.iterator(); i.hasNext(); ) {
            final SessionCallbackDelegate delegate = i.next();
            if (delegate.mCallback == callback) {
                try {
                    mInstaller.unregisterCallback(delegate);
                } catch (RemoteException e) {
                    throw e.rethrowAsRuntimeException();
                }
                i.remove();
            }
        }
    }
}","{
    synchronized (mDelegates) {
        for (Iterator<SessionCallbackDelegate> i = mDelegates.iterator(); i.hasNext(); ) {
            final SessionCallbackDelegate delegate = i.next();
            if (delegate.mCallback == callback) {
                try {
                    mInstaller.unregisterCallback(delegate);
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
                i.remove();
            }
        }
    }
}",1,"/**
 * Unregister a previously registered callback.
 */
","/**
 * Unregister a previously registered callback.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The only change between the early version and the late version of the implementation is how the RemoteException is handled. In the early version, RemoteException is rethrown as a RuntimeException by calling e.rethrowAsRuntimeException(), whereas in the late version, RemoteException is rethrown by calling e.rethrowFromSystemServer(). Therefore, the change type is an exception handling statement changed (2).","The change from rethrowAsRuntimeException() to rethrowFromSystemServer() potentially results in a different exception being thrown when the RemoteException occurs, which is a change in the exception handling logic. This altered behavior constitutes a Compatibility Issue related to different exception handlings (2)."
138,<android.text.Html: Spanned fromHtml(String)>,23,24,<android.text.Html: Spanned fromHtml(String)>,<android.text.Html: Spanned fromHtml(String)>,0,"{
    return fromHtml(source, null, null);
}","{
    return fromHtml(source, FROM_HTML_MODE_LEGACY, null, null);
}",1,"/**
 * Returns displayable styled text from the provided HTML string.
 * Any &lt;img&gt; tags in the HTML will display as a generic
 * replacement image which your program can then go through and
 * replace with real images.
 *
 * <p>This uses TagSoup to handle real HTML, including all of the brokenness found in the wild.
 */
","/**
 * Returns displayable styled text from the provided HTML string with the legacy flags
 * {@link #FROM_HTML_MODE_LEGACY}.
 *
 * @deprecated use {@link #fromHtml(String, int)} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The signature of the method called within fromHtml has changed from fromHtml(source, null, null) to fromHtml(source, FROM_HTML_MODE_LEGACY, null, null), with an additional parameter added, so the change type is 1,5.","The change introduced a new parameter in the method call, which can lead to different behavior since FROM_HTML_MODE_LEGACY specifies a parsing mode that could affect the output. This change potentially causes the API to return a different variable (value or type), so the CI type is 1."
139,<android.widget.ListPopupWindow: OnTouchListener createDragToOpenListener(View)>,23,24,<android.widget.ListPopupWindow: OnTouchListener createDragToOpenListener(View)>,<android.widget.ListPopupWindow: OnTouchListener createDragToOpenListener(View)>,0,"{
    return new ForwardingListener(src) {

        @Override
        public ListPopupWindow getPopup() {
            return ListPopupWindow.this;
        }
    };
}","{
    return new ForwardingListener(src) {

        @Override
        public ShowableListMenu getPopup() {
            return ListPopupWindow.this;
        }
    };
}",1,"/**
 * Returns an {@link OnTouchListener} that can be added to the source view
 * to implement drag-to-open behavior. Generally, the source view should be
 * the same view that was passed to {@link #setAnchorView}.
 * <p>
 * When the listener is set on a view, touching that view and dragging
 * outside of its bounds will open the popup window. Lifting will select the
 * currently touched list item.
 * <p>
 * Example usage:
 * <pre>
 * ListPopupWindow myPopup = new ListPopupWindow(context);
 * myPopup.setAnchor(myAnchor);
 * OnTouchListener dragListener = myPopup.createDragToOpenListener(myAnchor);
 * myAnchor.setOnTouchListener(dragListener);
 * </pre>
 *
 * @param src the view on which the resulting listener will be set
 * @return a touch listener that controls drag-to-open behavior
 */
","/**
 * Returns an {@link OnTouchListener} that can be added to the source view
 * to implement drag-to-open behavior. Generally, the source view should be
 * the same view that was passed to {@link #setAnchorView}.
 * <p>
 * When the listener is set on a view, touching that view and dragging
 * outside of its bounds will open the popup window. Lifting will select the
 * currently touched list item.
 * <p>
 * Example usage:
 * <pre>
 * ListPopupWindow myPopup = new ListPopupWindow(context);
 * myPopup.setAnchor(myAnchor);
 * OnTouchListener dragListener = myPopup.createDragToOpenListener(myAnchor);
 * myAnchor.setOnTouchListener(dragListener);
 * </pre>
 *
 * @param src the view on which the resulting listener will be set
 * @return a touch listener that controls drag-to-open behavior
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return type of the overridden method getPopup() within the anonymous class ForwardingListener has been changed from ListPopupWindow to ShowableListMenu. This change affects the API's implementation, so the code change type is 1 and 5.","The change of the overridden method's return type in the implementation code indicates that the API could potentially return a different type of object in the late version. Therefore, the CI type is 1."
140,"<android.view.inputmethod.InputMethodManager: Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()>",23,24,"<android.view.inputmethod.InputMethodManager: Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()>","<android.view.inputmethod.InputMethodManager: Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()>",0,"{
    synchronized (mH) {
        HashMap<InputMethodInfo, List<InputMethodSubtype>> ret = new HashMap<InputMethodInfo, List<InputMethodSubtype>>();
        try {
            // TODO: We should change the return type from List<Object> to List<Parcelable>
            List<Object> info = mService.getShortcutInputMethodsAndSubtypes();
            // ""info"" has imi1, subtype1, subtype2, imi2, subtype2, imi3, subtype3..in the list
            ArrayList<InputMethodSubtype> subtypes = null;
            if (info != null && !info.isEmpty()) {
                final int N = info.size();
                for (int i = 0; i < N; ++i) {
                    Object o = info.get(i);
                    if (o instanceof InputMethodInfo) {
                        if (ret.containsKey(o)) {
                            Log.e(TAG, ""IMI list already contains the same InputMethod."");
                            break;
                        }
                        subtypes = new ArrayList<InputMethodSubtype>();
                        ret.put((InputMethodInfo) o, subtypes);
                    } else if (subtypes != null && o instanceof InputMethodSubtype) {
                        subtypes.add((InputMethodSubtype) o);
                    }
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
        return ret;
    }
}","{
    synchronized (mH) {
        HashMap<InputMethodInfo, List<InputMethodSubtype>> ret = new HashMap<>();
        try {
            // TODO: We should change the return type from List<Object> to List<Parcelable>
            List<Object> info = mService.getShortcutInputMethodsAndSubtypes();
            // ""info"" has imi1, subtype1, subtype2, imi2, subtype2, imi3, subtype3..in the list
            ArrayList<InputMethodSubtype> subtypes = null;
            if (info != null && !info.isEmpty()) {
                final int N = info.size();
                for (int i = 0; i < N; ++i) {
                    Object o = info.get(i);
                    if (o instanceof InputMethodInfo) {
                        if (ret.containsKey(o)) {
                            Log.e(TAG, ""IMI list already contains the same InputMethod."");
                            break;
                        }
                        subtypes = new ArrayList<>();
                        ret.put((InputMethodInfo) o, subtypes);
                    } else if (subtypes != null && o instanceof InputMethodSubtype) {
                        subtypes.add((InputMethodSubtype) o);
                    }
                }
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        return ret;
    }
}",1,"/**
 * Returns a map of all shortcut input method info and their subtypes.
 */
","/**
 * Returns a map of all shortcut input method info and their subtypes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4","1,2","The exception handling has changed from logging an error message to re-throwing the exception using e.rethrowFromSystemServer(). Additionally, type parameters are omitted from the constructor call new ArrayList<>() in the late version, but since it's using the diamond operator the actual type is inferred, this change doesn't affect the behavior of the code. Therefore, the code change type is 2,4.","Although the diamond operator is used in late version which generally doesn't change the behavior, the change in the exception handling from logging to throwing an exception directly could lead to different behavior. As a consequence, the late version of the API could potentially throw a different exception (the unwrapped one), leading to a different control flow in the client code. Thus, the CI type is 1,2."
141,<android.content.SyncRequest.Builder: Builder setDisallowMetered(boolean)>,23,24,<android.content.SyncRequest.Builder: Builder setDisallowMetered(boolean)>,<android.content.SyncRequest.Builder: Builder setDisallowMetered(boolean)>,0,"{
    if (mIgnoreSettings && disallow) {
        throw new IllegalArgumentException(""setDisallowMetered(true) after having"" + ""specified that settings are ignored."");
    }
    mDisallowMetered = disallow;
    return this;
}","{
    if (mIgnoreSettings && disallow) {
        throw new IllegalArgumentException(""setDisallowMetered(true) after having"" + "" specified that settings are ignored."");
    }
    mDisallowMetered = disallow;
    return this;
}",1,"/**
 * Will throw an <code>IllegalArgumentException</code> if called and
 * {@link #setIgnoreSettings(boolean ignoreSettings)} has already been called.
 * @param disallow true to allow this transfer on metered networks. Default false.
 */
","/**
 * Will throw an <code>IllegalArgumentException</code> if called and
 * {@link #setIgnoreSettings(boolean ignoreSettings)} has already been called.
 * @param disallow true to allow this transfer on metered networks. Default false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The early and late versions of the implementation are functionally identical. There appears to be only a minor textual change in the exception message (an extra space) which does not affect the functionality or the behavior of the method. Therefore, there is no code change.","There is no Compatibility Issue since there is no functional change between the two versions of the method that could lead to a different return value, type, or exception thrown."
142,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,23,24,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,0,"{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightness="" + screenBrightness + "", screenAutoBrightnessAdjustment="" + screenAutoBrightnessAdjustment + "", brightnessSetByUser="" + brightnessSetByUser + "", useAutoBrightness="" + useAutoBrightness + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", boostScreenBrightness="" + boostScreenBrightness + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState);
}","{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightness="" + screenBrightness + "", screenAutoBrightnessAdjustment="" + screenAutoBrightnessAdjustment + "", brightnessSetByUser="" + brightnessSetByUser + "", useAutoBrightness="" + useAutoBrightness + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", boostScreenBrightness="" + boostScreenBrightness + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState) + "", useTwilight="" + useTwilight;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"A new string concatenation has been added to the return statement which adds "", useTwilight="" + useTwilight to the output, and this represents both a change in the return statement and an other statement change, thus the change types are 1 and 4.","Since the return statement is modified to include additional information, the returned value will be different, which could lead to a different behavior for the clients relying on the exact output of the `toString()` method, hence the CI type is 1."
143,"<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle)>",23,24,"<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle)>","<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle)>",0,"{
    enforceTree(uri);
    if (opts != null && opts.containsKey(ContentResolver.EXTRA_SIZE)) {
        final Point sizeHint = opts.getParcelable(ContentResolver.EXTRA_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, null);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts);
    }
}","{
    return openTypedAssetFileImpl(uri, mimeTypeFilter, opts, null);
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 */
","/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 * @see #openTypedDocument(String, String, Bundle, CancellationSignal)
 * @see #getDocumentStreamTypes(String, String)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation changes completely from an 'if-else' control structure with a call to `openDocumentThumbnail()` and `super.openTypedAssetFile()` to a single method call to `openTypedAssetFileImpl()`. Additionally, the dependencies of the API have changed, since `openTypedAssetFileImpl()` is not present in the early version. Therefore, the code change type is 1,5.","The method now always delegates to `openTypedAssetFileImpl()`, whereas before, it could call different methods based on the condition. This change in the method call can potentially return different values or types because the method being called and the method's behavior might differ. Thus, the CI type is 1."
146,"<android.content.res.TypedArray: int getLayoutDimension(int,String)>",23,24,"<android.content.res.TypedArray: int getLayoutDimension(int,String)>","<android.content.res.TypedArray: int getLayoutDimension(int,String)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(getPositionDescription() + "": You must supply a "" + name + "" attribute."");
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(getPositionDescription() + "": You must supply a "" + name + "" attribute."");
}",1,"/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension or integer (enum).
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension or integer (enum).
 */
","/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension or integer (enum).
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension or integer (enum).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is the introduction of a new local variable `attrIndex` to store the original value of `index`, and the modification of the argument passed to `getValueAt()` from `index * AssetManager.STYLE_NUM_ENTRIES` to just `index`. This change qualifies as type 4 (Other statement changed) according to the classification.","There's no Compatibility Issue, as none of the return statements nor the exception handling statements have been altered. The behavior of the method does not seem to be impacted, as the final outcome (which is determined by the return statements and exceptions which remained unchanged) would be the same despite introducing a new local variable for clarity or readability purposes."
148,"<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setMaximumFailedPasswordsForWipe(admin, num);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setMaximumFailedPasswordsForWipe(admin, num, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Setting this to a value greater than zero enables a built-in policy
 * that will perform a device wipe after too many incorrect
 * device-unlock passwords have been entered.  This built-in policy combines
 * watching for failed passwords and wiping the device, and requires
 * that you request both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.
 *
 * <p>To implement any other policy (e.g. wiping data for a particular
 * application only, erasing or revoking credentials, or reporting the
 * failure to a server), you should implement
 * {@link DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)}
 * instead.  Do not use this API, because if the maximum count is reached,
 * the device will be wiped immediately, and your callback will not be invoked.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param num The number of failed password attempts at which point the
 * device will wipe its data.
 */
","/**
 * Setting this to a value greater than zero enables a built-in policy that will perform a
 * device or profile wipe after too many incorrect device-unlock passwords have been entered.
 * This built-in policy combines watching for failed passwords and wiping the device, and
 * requires that you request both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.
 * <p>
 * To implement any other policy (e.g. wiping data for a particular application only, erasing or
 * revoking credentials, or reporting the failure to a server), you should implement
 * {@link DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)} instead. Do not
 * use this API, because if the maximum count is reached, the device or profile will be wiped
 * immediately, and your callback will not be invoked.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set a value on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param num The number of failed password attempts at which point the device or profile will
 * be wiped.
 * @throws SecurityException if {@code admin} is not an active administrator or does not use
 * both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"A new parameter 'mParentInstance' is passed to the method 'mService.setMaximumFailedPasswordsForWipe' and exception handling statement has changed from logging the exception to throwing it, so the change type is 2,4,5 due to exception handling statement changed and dependent API changed.","The late implementation throws the RemoteException which, as opposed to only logging it, could lead to different exception handling behavior when this method encounters an error, thus could potentially lead to different behavior of the surrounding code in client applications executing this API. There might be a CI type 2 due to potential different exception handlings."
149,"<android.app.Service: void startForeground(int,Notification)>",23,24,"<android.app.Service: void startForeground(int,Notification)>","<android.app.Service: void startForeground(int,Notification)>",0,"{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, true);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, 0);
    } catch (RemoteException ex) {
    }
}",1,"/**
 * Make this service run in the foreground, supplying the ongoing
 * notification to be shown to the user while in this state.
 * By default services are background, meaning that if the system needs to
 * kill them to reclaim more memory (such as to display a large page in a
 * web browser), they can be killed without too much harm.  You can set this
 * flag if killing your service would be disruptive to the user, such as
 * if your service is performing background music playback, so the user
 * would notice if their music stopped playing.
 *
 * <p>If you need your application to run on platform versions prior to API
 * level 5, you can use the following model to call the the older setForeground()
 * or this modern method as appropriate:
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/ForegroundService.java
 * foreground_compatibility}
 *
 * @param id The identifier for this notification as per
 * {@link NotificationManager#notify(int, Notification)
 * NotificationManager.notify(int, Notification)}; must not be 0.
 * @param notification The Notification to be displayed.
 *
 * @see #stopForeground(boolean)
 */
","/**
 * Make this service run in the foreground, supplying the ongoing
 * notification to be shown to the user while in this state.
 * By default services are background, meaning that if the system needs to
 * kill them to reclaim more memory (such as to display a large page in a
 * web browser), they can be killed without too much harm.  You can set this
 * flag if killing your service would be disruptive to the user, such as
 * if your service is performing background music playback, so the user
 * would notice if their music stopped playing.
 *
 * <p>If you need your application to run on platform versions prior to API
 * level 5, you can use the following model to call the the older setForeground()
 * or this modern method as appropriate:
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/ForegroundService.java
 * foreground_compatibility}
 *
 * @param id The identifier for this notification as per
 * {@link NotificationManager#notify(int, Notification)
 * NotificationManager.notify(int, Notification)}; must not be 0.
 * @param notification The Notification to be displayed.
 *
 * @see #stopForeground(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call statement has changed by altering the last argument from 'true' to '0', as part of the arguments passed into the setServiceForeground method, so the change type is 4.","Although there's a change in the argument passed to setServiceForeground, there is no compatibility issue because the method's signature remains the same, and there are no new return statements, nor are any exception handling changes. The behavior inside the try block does not affect the API consumer directly, assuming that the change in argument does not alter the contract of how the method should be used. Without further context about the specific effects of changing 'true' to '0' in the fifth argument of setServiceForeground, this change can be seen as an internal change without compatibility implications. Therefore, the CI type is 0."
150,"<android.app.admin.DevicePolicyManager: void setKeyguardDisabledFeatures(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setKeyguardDisabledFeatures(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setKeyguardDisabledFeatures(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setKeyguardDisabledFeatures(admin, which);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setKeyguardDisabledFeatures(admin, which, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to disable keyguard customizations,
 * such as widgets. After setting this, keyguard features will be disabled according to the
 * provided feature list.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * <p>Calling this from a managed profile before version
 * {@link android.os.Build.VERSION_CODES#M} will throw a security exception.
 *
 * <p>From version {@link android.os.Build.VERSION_CODES#M} a profile owner can set:
 * <ul>
 * <li>{@link #KEYGUARD_DISABLE_TRUST_AGENTS}, {@link #KEYGUARD_DISABLE_FINGERPRINT}
 * these will affect the profile's parent user.
 * <li>{@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS} this will affect notifications
 * generated by applications in the managed profile.
 * </ul>
 * <p>Requests to disable other features on a managed profile will be ignored. The admin
 * can check which features have been disabled by calling
 * {@link #getKeyguardDisabledFeatures(ComponentName)}
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param which {@link #KEYGUARD_DISABLE_FEATURES_NONE} (default),
 * {@link #KEYGUARD_DISABLE_WIDGETS_ALL}, {@link #KEYGUARD_DISABLE_SECURE_CAMERA},
 * {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS}, {@link #KEYGUARD_DISABLE_TRUST_AGENTS},
 * {@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS}, {@link #KEYGUARD_DISABLE_FINGERPRINT},
 * {@link #KEYGUARD_DISABLE_FEATURES_ALL}
 */
","/**
 * Called by an application that is administering the device to disable keyguard customizations,
 * such as widgets. After setting this, keyguard features will be disabled according to the
 * provided feature list.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call this method;
 * if it has not, a security exception will be thrown.
 * <p>
 * Calling this from a managed profile before version {@link android.os.Build.VERSION_CODES#M}
 * will throw a security exception. From version {@link android.os.Build.VERSION_CODES#M} the
 * profile owner of a managed profile can set:
 * <ul>
 * <li>{@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which affects the parent user, but only if there
 * is no separate challenge set on the managed profile.
 * <li>{@link #KEYGUARD_DISABLE_FINGERPRINT} which affects the managed profile challenge if
 * there is one, or the parent user otherwise.
 * <li>{@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS} which affects notifications generated
 * by applications in the managed profile.
 * </ul>
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} and {@link #KEYGUARD_DISABLE_FINGERPRINT} can also be
 * set on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 * <p>
 * Requests to disable other features on a managed profile will be ignored.
 * <p>
 * The admin can check which features have been disabled by calling
 * {@link #getKeyguardDisabledFeatures(ComponentName)}
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param which {@link #KEYGUARD_DISABLE_FEATURES_NONE} (default),
 * {@link #KEYGUARD_DISABLE_WIDGETS_ALL}, {@link #KEYGUARD_DISABLE_SECURE_CAMERA},
 * {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS},
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS},
 * {@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS},
 * {@link #KEYGUARD_DISABLE_FINGERPRINT}, {@link #KEYGUARD_DISABLE_FEATURES_ALL}
 * @throws SecurityException if {@code admin} is not an active administrator or does not user
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The late version implementation adds a third parameter, mParentInstance, to the method mService.setKeyguardDisabledFeatures. Additionally, the exception handling has changed from logging the error to throwing an exception. The change types are 2 (Exception handling statement changed) and 5 (Dependent API changed).","The added parameter to the method call could potentially affect the behavior of the API. Besides this, the modification in exception handling from logging to throwing the exception changes the way the method responds to RemoteExceptions. This could lead to different exception behaviors, resulting in a CI type of 2 (Compatibility Issue caused by potential different exception handlings)."
151,<android.hardware.fingerprint.FingerprintManager: boolean hasEnrolledFingerprints()>,23,24,<android.hardware.fingerprint.FingerprintManager: boolean hasEnrolledFingerprints()>,<android.hardware.fingerprint.FingerprintManager: boolean hasEnrolledFingerprints()>,0,"{
    if (mService != null)
        try {
            return mService.hasEnrolledFingerprints(UserHandle.myUserId(), mContext.getOpPackageName());
        } catch (RemoteException e) {
            Log.v(TAG, ""Remote exception in getEnrolledFingerprints: "", e);
        }
    return false;
}","{
    if (mService != null)
        try {
            return mService.hasEnrolledFingerprints(UserHandle.myUserId(), mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    return false;
}",1,"/**
 * Determine if there is at least one fingerprint enrolled.
 *
 * @return true if at least one fingerprint is enrolled, false otherwise
 */
","/**
 * Determine if there is at least one fingerprint enrolled.
 *
 * @return true if at least one fingerprint is enrolled, false otherwise
 */
",-1,[@RequiresPermission(USE_FINGERPRINT)],[@RequiresPermission(USE_FINGERPRINT)],-1,-1,-1,-1,-1,-1,2,2,"The method body has only changed in the exception handling part. The catch block was revised to throw the caught RemoteException after it's been rethrown from the system server, unlike the previous version, which simply logged the exception and returned false. This indicates a change type of 2.","This change in the exception handling statement leads to a potential different behavior because in the case of a RemoteException, the method earlier simply logged the error and returned false, but now it throws an exception, causing the method caller to handle this exception potentially differently. Thus, the CI type is 2."
154,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,23,24,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,0,"{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    final String datePattern = DateFormat.getBestDateTimePattern(locale, ""EMMMd"");
    mMonthDayFormat = new SimpleDateFormat(datePattern, locale);
    mYearFormat = new SimpleDateFormat(""y"", locale);
    // Update the header text.
    onCurrentDateChanged(false);
}","{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    final String datePattern = DateFormat.getBestDateTimePattern(locale, ""EMMMd"");
    mMonthDayFormat = new SimpleDateFormat(datePattern, locale);
    mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);
    mYearFormat = new SimpleDateFormat(""y"", locale);
    // Update the header text.
    onCurrentDateChanged(false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"In the late version, a new method call 'mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE)' is introduced. This is a change in the other statement (class 4) and also a control dependency change (class 3) because it alters the configuration of `mMonthDayFormat`.","The new method call `mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE)` merely adjusts the internal state of the `mMonthDayFormat` object and does not affect the return type, value, or the exceptions being thrown by the `onLocaleChanged` method. Thus, it does not cause a Compatibility Issue."
155,<android.print.PrinterInfo.Builder: PrinterInfo build()>,23,24,<android.print.PrinterInfo.Builder: PrinterInfo build()>,<android.print.PrinterInfo.Builder: PrinterInfo build()>,0,"{
    return mPrototype;
}","{
    return new PrinterInfo(mPrinterId, mName, mStatus, mIconResourceId, mHasCustomPrinterIcon, mDescription, mInfoIntent, mCapabilities, mCustomPrinterIconGen);
}",1,"/**
 * Creates a new {@link PrinterInfo}.
 *
 * @return A new {@link PrinterInfo}.
 */
","/**
 * Creates a new {@link PrinterInfo}.
 *
 * @return A new {@link PrinterInfo}.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been changed from returning a member variable 'mPrototype' to constructing a new PrinterInfo object with a list of parameters, so the code change type is 1.","Since the implementation of the build() method is now returning a newly constructed object instead of a previously existing member variable, the return value will be different in the older and newer version for sure. Consequently, the change will potentially return a different value, and thus the CI type is 1."
156,"<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>",23,24,"<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>","<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>",0,"{
    // Look up where all of our various well-defined dir trees live on this device
    String mainDir;
    String filesDir;
    String nbFilesDir;
    String dbDir;
    String spDir;
    String cacheDir;
    String codeCacheDir;
    String libDir;
    String efDir = null;
    String filePath;
    ApplicationInfo appInfo = getApplicationInfo();
    try {
        mainDir = new File(appInfo.dataDir).getCanonicalPath();
        filesDir = getFilesDir().getCanonicalPath();
        nbFilesDir = getNoBackupFilesDir().getCanonicalPath();
        dbDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
        spDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
        cacheDir = getCacheDir().getCanonicalPath();
        codeCacheDir = getCodeCacheDir().getCanonicalPath();
        libDir = (appInfo.nativeLibraryDir == null) ? null : new File(appInfo.nativeLibraryDir).getCanonicalPath();
        // may or may not have external files access to attempt backup/restore there
        if (Process.myUid() != Process.SYSTEM_UID) {
            File efLocation = getExternalFilesDir(null);
            if (efLocation != null) {
                efDir = efLocation.getCanonicalPath();
            }
        }
        // Now figure out which well-defined tree the file is placed in, working from
        // most to least specific.  We also specifically exclude the lib, cache,
        // and code_cache dirs.
        filePath = file.getCanonicalPath();
    } catch (IOException e) {
        Log.w(TAG, ""Unable to obtain canonical paths"");
        return;
    }
    if (filePath.startsWith(cacheDir) || filePath.startsWith(codeCacheDir) || filePath.startsWith(libDir) || filePath.startsWith(nbFilesDir)) {
        Log.w(TAG, ""lib, cache, code_cache, and no_backup files are not backed up"");
        return;
    }
    final String domain;
    String rootpath = null;
    if (filePath.startsWith(dbDir)) {
        domain = FullBackup.DATABASE_TREE_TOKEN;
        rootpath = dbDir;
    } else if (filePath.startsWith(spDir)) {
        domain = FullBackup.SHAREDPREFS_TREE_TOKEN;
        rootpath = spDir;
    } else if (filePath.startsWith(filesDir)) {
        domain = FullBackup.DATA_TREE_TOKEN;
        rootpath = filesDir;
    } else if (filePath.startsWith(mainDir)) {
        domain = FullBackup.ROOT_TREE_TOKEN;
        rootpath = mainDir;
    } else if ((efDir != null) && filePath.startsWith(efDir)) {
        domain = FullBackup.MANAGED_EXTERNAL_TREE_TOKEN;
        rootpath = efDir;
    } else {
        Log.w(TAG, ""File "" + filePath + "" is in an unsupported location; skipping"");
        return;
    }
    // without transmitting any file data.
    if (DEBUG)
        Log.i(TAG, ""backupFile() of "" + filePath + "" => domain="" + domain + "" rootpath="" + rootpath);
    FullBackup.backupToTar(getPackageName(), domain, null, rootpath, filePath, output);
}","{
    // Look up where all of our various well-defined dir trees live on this device
    final String rootDir;
    final String filesDir;
    final String nbFilesDir;
    final String dbDir;
    final String spDir;
    final String cacheDir;
    final String codeCacheDir;
    final String deviceRootDir;
    final String deviceFilesDir;
    final String deviceNbFilesDir;
    final String deviceDbDir;
    final String deviceSpDir;
    final String deviceCacheDir;
    final String deviceCodeCacheDir;
    final String libDir;
    String efDir = null;
    String filePath;
    ApplicationInfo appInfo = getApplicationInfo();
    try {
        // System apps have control over where their default storage context
        // is pointed, so we're always explicit when building paths.
        final Context ceContext = createCredentialProtectedStorageContext();
        rootDir = ceContext.getDataDir().getCanonicalPath();
        filesDir = ceContext.getFilesDir().getCanonicalPath();
        nbFilesDir = ceContext.getNoBackupFilesDir().getCanonicalPath();
        dbDir = ceContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
        spDir = ceContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
        cacheDir = ceContext.getCacheDir().getCanonicalPath();
        codeCacheDir = ceContext.getCodeCacheDir().getCanonicalPath();
        final Context deContext = createDeviceProtectedStorageContext();
        deviceRootDir = deContext.getDataDir().getCanonicalPath();
        deviceFilesDir = deContext.getFilesDir().getCanonicalPath();
        deviceNbFilesDir = deContext.getNoBackupFilesDir().getCanonicalPath();
        deviceDbDir = deContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
        deviceSpDir = deContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
        deviceCacheDir = deContext.getCacheDir().getCanonicalPath();
        deviceCodeCacheDir = deContext.getCodeCacheDir().getCanonicalPath();
        libDir = (appInfo.nativeLibraryDir == null) ? null : new File(appInfo.nativeLibraryDir).getCanonicalPath();
        // may or may not have external files access to attempt backup/restore there
        if (Process.myUid() != Process.SYSTEM_UID) {
            File efLocation = getExternalFilesDir(null);
            if (efLocation != null) {
                efDir = efLocation.getCanonicalPath();
            }
        }
        // Now figure out which well-defined tree the file is placed in, working from
        // most to least specific.  We also specifically exclude the lib, cache,
        // and code_cache dirs.
        filePath = file.getCanonicalPath();
    } catch (IOException e) {
        Log.w(TAG, ""Unable to obtain canonical paths"");
        return;
    }
    if (filePath.startsWith(cacheDir) || filePath.startsWith(codeCacheDir) || filePath.startsWith(nbFilesDir) || filePath.startsWith(deviceCacheDir) || filePath.startsWith(deviceCodeCacheDir) || filePath.startsWith(deviceNbFilesDir) || filePath.startsWith(libDir)) {
        Log.w(TAG, ""lib, cache, code_cache, and no_backup files are not backed up"");
        return;
    }
    final String domain;
    String rootpath = null;
    if (filePath.startsWith(dbDir)) {
        domain = FullBackup.DATABASE_TREE_TOKEN;
        rootpath = dbDir;
    } else if (filePath.startsWith(spDir)) {
        domain = FullBackup.SHAREDPREFS_TREE_TOKEN;
        rootpath = spDir;
    } else if (filePath.startsWith(filesDir)) {
        domain = FullBackup.FILES_TREE_TOKEN;
        rootpath = filesDir;
    } else if (filePath.startsWith(rootDir)) {
        domain = FullBackup.ROOT_TREE_TOKEN;
        rootpath = rootDir;
    } else if (filePath.startsWith(deviceDbDir)) {
        domain = FullBackup.DEVICE_DATABASE_TREE_TOKEN;
        rootpath = deviceDbDir;
    } else if (filePath.startsWith(deviceSpDir)) {
        domain = FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN;
        rootpath = deviceSpDir;
    } else if (filePath.startsWith(deviceFilesDir)) {
        domain = FullBackup.DEVICE_FILES_TREE_TOKEN;
        rootpath = deviceFilesDir;
    } else if (filePath.startsWith(deviceRootDir)) {
        domain = FullBackup.DEVICE_ROOT_TREE_TOKEN;
        rootpath = deviceRootDir;
    } else if ((efDir != null) && filePath.startsWith(efDir)) {
        domain = FullBackup.MANAGED_EXTERNAL_TREE_TOKEN;
        rootpath = efDir;
    } else {
        Log.w(TAG, ""File "" + filePath + "" is in an unsupported location; skipping"");
        return;
    }
    // without transmitting any file data.
    if (DEBUG)
        Log.i(TAG, ""backupFile() of "" + filePath + "" => domain="" + domain + "" rootpath="" + rootpath);
    FullBackup.backupToTar(getPackageName(), domain, null, rootpath, filePath, output);
}",1,"/**
 * Write an entire file as part of a full-backup operation.  The file's contents
 * will be delivered to the backup destination along with the metadata necessary
 * to place it with the proper location and permissions on the device where the
 * data is restored.
 *
 * <p class=""note"">It is safe to explicitly back up files underneath your application's
 * {@link #getNoBackupFilesDir()} directory, and they will be restored to that
 * location correctly.
 *
 * @param file The file to be backed up.  The file must exist and be readable by
 * the caller.
 * @param output The destination to which the backed-up file data will be sent.
 */
","/**
 * Write an entire file as part of a full-backup operation.  The file's contents
 * will be delivered to the backup destination along with the metadata necessary
 * to place it with the proper location and permissions on the device where the
 * data is restored.
 *
 * <p class=""note"">Attempting to back up files in directories that are ignored by
 * the backup system will have no effect.  For example, if the app calls this method
 * with a file inside the {@link #getNoBackupFilesDir()} directory, it will be ignored.
 * See {@link #onFullBackup(FullBackupDataOutput) for details on what directories
 * are excluded from backups.
 *
 * @param file The file to be backed up.  The file must exist and be readable by
 * the caller.
 * @param output The destination to which the backed-up file data will be sent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
157,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",23,24,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>","<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",0,"{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method intent.prepareToLeaveProcess has been modified to include the current Activity context as a parameter (intent.prepareToLeaveProcess(this)). This qualifies as an ""Other statement changed"" code change, which is categorized as type 4.","The change in the parameter does not directly lead to a different return value or throw a new kind of exception. If the underlying implementation of 'prepareToLeaveProcess' uses the context in a way that doesn't affect the output or behavior of 'startActivityIfNeeded', then there would be no Compatibility Issue. However, my capabilities do not include access to the implementation details of 'prepareToLeaveProcess'. Given the information available, we can infer that there is no immediate Compatibility Issue arising from this change, hence the prediction is 0."
158,"<android.view.inputmethod.InputMethodManager: List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo,boolean)>",23,24,"<android.view.inputmethod.InputMethodManager: List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo,boolean)>","<android.view.inputmethod.InputMethodManager: List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo,boolean)>",0,"{
    try {
        return mService.getEnabledInputMethodSubtypeList(imi == null ? null : imi.getId(), allowsImplicitlySelectedSubtypes);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        return mService.getEnabledInputMethodSubtypeList(imi == null ? null : imi.getId(), allowsImplicitlySelectedSubtypes);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a list of enabled input method subtypes for the specified input method info.
 * @param imi An input method info whose subtypes list will be returned.
 * @param allowsImplicitlySelectedSubtypes A boolean flag to allow to return the implicitly
 * selected subtypes. If an input method info doesn't have enabled subtypes, the framework
 * will implicitly enable subtypes according to the current system language.
 */
","/**
 * Returns a list of enabled input method subtypes for the specified input method info.
 * @param imi An input method info whose subtypes list will be returned.
 * @param allowsImplicitlySelectedSubtypes A boolean flag to allow to return the implicitly
 * selected subtypes. If an input method info doesn't have enabled subtypes, the framework
 * will implicitly enable subtypes according to the current system language.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. In the early version, it throws a new RuntimeException, while in the late version, it rethrows the RemoteException with e.rethrowFromSystemServer(), so the change type is 2.","Since the exception that is thrown in case of a RemoteException has changed, this would constitute a change in the API's behavior when it encounters an error condition, possibly leading to a Compatibility Issue of type 2 due to different exception handlings."
160,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",23,24,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method call intent.prepareToLeaveProcess() has changed to intent.prepareToLeaveProcess(this), which is a change in the parameters of the method being called. This is categorized as an ""Other statement changed"" (code 4). Additionally, the updated method call to a different variation of prepareToLeaveProcess() suggests a dependency on another internal API which could have different parameter requirements, indicating a ""Dependent API changed"" (code 5).","Though there's a change in the method call parameter of prepareToLeaveProcess, given the method is being called with 'this' in the context of the current object which in this case would not cause a different behavior because the method intent.prepareToLeaveProcess() is intended to prepare the Intent object with the necessary adjustments before leaving the process. Moreover, the exception handling change from throwing a new RuntimeException to calling rethrowFromSystemServer doesn't contribute to a compatibility issue because it is still propagating an exception of type RemoteException albeit in a different way; hence, there's no change in the types of exceptions thrown to the caller. Thus, no compatibility issue is detected here."
162,"<android.app.admin.DevicePolicyManager: void setUserIcon(ComponentName,Bitmap)>",23,24,"<android.app.admin.DevicePolicyManager: void setUserIcon(ComponentName,Bitmap)>","<android.app.admin.DevicePolicyManager: void setUserIcon(ComponentName,Bitmap)>",0,"{
    try {
        mService.setUserIcon(admin, icon);
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not set the user icon "", re);
    }
}","{
    throwIfParentInstance(""setUserIcon"");
    try {
        mService.setUserIcon(admin, icon);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by profile or device owners to set the current user's photo.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param icon the bitmap to set as the photo.
 */
","/**
 * Called by profile or device owners to set the user's photo.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param icon the bitmap to set as the photo.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"There is an introduction of a new method call 'throwIfParentInstance(""setUserIcon"")' before the try block, a change in the catch block from logging the exception to rethrowing it, and no modification in return statement, so the code change types are 2,3,4.","The new method 'throwIfParentInstance' could throw an exception that didn't exist in the early version, and the change in exception handling from logging to throwing an exception with 'rethrowFromSystemServer' may lead to a different behaviour in exception scenarios, so the CI type is 2."
163,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,23,24,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    onUserInteraction();
    // the window handling it
    if (event.getKeyCode() == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
        return true;
    }
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}","{
    onUserInteraction();
    // Let action bars open menus in response to the menu key prioritized over
    // the window handling it
    final int keyCode = event.getKeyCode();
    if (keyCode == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
        return true;
    } else if (event.isCtrlPressed() && event.getUnicodeChar(event.getMetaState() & ~KeyEvent.META_CTRL_MASK) == '<') {
        // Capture the Control-< and send focus to the ActionBar
        final int action = event.getAction();
        if (action == KeyEvent.ACTION_DOWN) {
            final ActionBar actionBar = getActionBar();
            if (actionBar != null && actionBar.isShowing() && actionBar.requestFocus()) {
                mEatKeyUpEvent = true;
                return true;
            }
        } else if (action == KeyEvent.ACTION_UP && mEatKeyUpEvent) {
            mEatKeyUpEvent = false;
            return true;
        }
    }
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}",1,"/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
","/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The late version of the implementation introduces a new check for a combination of control key press and specific unicode character, which after certain conditions could return true. This constitutes a control dependency change.","The new control statement introduced in the late version implementation could potentially lead to the method returning a different value ('true' instead of continuing the normal flow), which would be a different behavior from the previous version especially when a certain key combination is pressed. Thus, the CI type is 1."
164,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(AttributeSet,int[],int,int)>",23,24,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(AttributeSet,int[],int,int)>","<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(AttributeSet,int[],int,int)>",0,"{
    final int len = attrs.length;
    final TypedArray array = TypedArray.obtain(Resources.this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    final XmlBlock.Parser parser = (XmlBlock.Parser) set;
    AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);
    array.mTheme = this;
    array.mXml = parser;
    if (false) {
        int[] data = array.mData;
        System.out.println(""Attributes:"");
        String s = ""  Attrs:"";
        int i;
        for (i = 0; i < set.getAttributeCount(); i++) {
            s = s + "" "" + set.getAttributeName(i);
            int id = set.getAttributeNameResource(i);
            if (id != 0) {
                s = s + ""(0x"" + Integer.toHexString(id) + "")"";
            }
            s = s + ""="" + set.getAttributeValue(i);
        }
        System.out.println(s);
        s = ""  Found:"";
        TypedValue value = new TypedValue();
        for (i = 0; i < attrs.length; i++) {
            int d = i * AssetManager.STYLE_NUM_ENTRIES;
            value.type = data[d + AssetManager.STYLE_TYPE];
            value.data = data[d + AssetManager.STYLE_DATA];
            value.assetCookie = data[d + AssetManager.STYLE_ASSET_COOKIE];
            value.resourceId = data[d + AssetManager.STYLE_RESOURCE_ID];
            s = s + "" 0x"" + Integer.toHexString(attrs[i]) + ""="" + value;
        }
        System.out.println(s);
    }
    return array;
}","{
    return mThemeImpl.obtainStyledAttributes(this, set, attrs, defStyleAttr, defStyleRes);
}",1,"/**
 * Return a TypedArray holding the attribute values in
 * <var>set</var>
 * that are listed in <var>attrs</var>.  In addition, if the given
 * AttributeSet specifies a style class (through the ""style"" attribute),
 * that style will be applied on top of the base attributes it defines.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * <p>When determining the final value of a particular attribute, there
 * are four inputs that come into play:</p>
 *
 * <ol>
 * <li> Any attribute values in the given AttributeSet.
 * <li> The style resource specified in the AttributeSet (named
 * ""style"").
 * <li> The default style specified by <var>defStyleAttr</var> and
 * <var>defStyleRes</var>
 * <li> The base values in this theme.
 * </ol>
 *
 * <p>Each of these inputs is considered in-order, with the first listed
 * taking precedence over the following ones.  In other words, if in the
 * AttributeSet you have supplied <code>&lt;Button
 * textColor=""#ff000000""&gt;</code>, then the button's text will
 * <em>always</em> be black, regardless of what is specified in any of
 * the styles.
 *
 * @param set The base set of attribute values.  May be null.
 * @param attrs The desired attributes to be retrieved.
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(int, int[])
 */
","/**
 * Return a TypedArray holding the attribute values in
 * <var>set</var>
 * that are listed in <var>attrs</var>.  In addition, if the given
 * AttributeSet specifies a style class (through the ""style"" attribute),
 * that style will be applied on top of the base attributes it defines.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * <p>When determining the final value of a particular attribute, there
 * are four inputs that come into play:</p>
 *
 * <ol>
 * <li> Any attribute values in the given AttributeSet.
 * <li> The style resource specified in the AttributeSet (named
 * ""style"").
 * <li> The default style specified by <var>defStyleAttr</var> and
 * <var>defStyleRes</var>
 * <li> The base values in this theme.
 * </ol>
 *
 * <p>Each of these inputs is considered in-order, with the first listed
 * taking precedence over the following ones.  In other words, if in the
 * AttributeSet you have supplied <code>&lt;Button
 * textColor=""#ff000000""&gt;</code>, then the button's text will
 * <em>always</em> be black, regardless of what is specified in any of
 * the styles.
 *
 * @param set The base set of attribute values.  May be null.
 * @param attrs The desired attributes to be retrieved.
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(int, int[])
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from an entire block of code that manually obtains styled attributes to a single call to mThemeImpl.obtainStyledAttributes(), and the dependent API mThemeImpl.obtainStyledAttributes() is invoked instead of the code inside the method. This implies a change in both the return statement and the dependent API, so the code change type is 1,5.","The implementation of obtaining styled attributes has been entirely replaced by a call to another method, hence, the behavior could be different than the previous version, and the returned TypedArray could potentially carry different data, which leads to a CI type of 1."
167,<android.animation.AnimatorSet: void end()>,23,24,<android.animation.AnimatorSet: void end()>,<android.animation.AnimatorSet: void end()>,0,"{
    mTerminated = true;
    if (isStarted()) {
        if (mSortedNodes.size() != mNodes.size()) {
            // hasn't been started yet - sort the nodes now, then end them
            sortNodes();
            for (Node node : mSortedNodes) {
                if (mSetListener == null) {
                    mSetListener = new AnimatorSetListener(this);
                }
                node.animation.addListener(mSetListener);
            }
        }
        if (mDelayAnim != null) {
            mDelayAnim.cancel();
        }
        if (mSortedNodes.size() > 0) {
            for (Node node : mSortedNodes) {
                node.animation.end();
            }
        }
        if (mListeners != null) {
            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            for (AnimatorListener listener : tmpListeners) {
                listener.onAnimationEnd(this);
            }
        }
        mStarted = false;
    }
}","{
    if (mShouldIgnoreEndWithoutStart && !isStarted()) {
        return;
    }
    mTerminated = true;
    if (isStarted()) {
        endRemainingAnimations();
    }
    if (mListeners != null) {
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        for (int i = 0; i < tmpListeners.size(); i++) {
            tmpListeners.get(i).onAnimationEnd(this);
        }
    }
    mStarted = false;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>Note that ending a <code>AnimatorSet</code> also ends all of the animations that it is
 * responsible for.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p>Note that ending a <code>AnimatorSet</code> also ends all of the animations that it is
 * responsible for.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation has several changes including the control dependency (a new if statement was added at the beginning and the condition statement for `if (mSortedNodes.size() > 0)` was removed), the return statement within the new control dependency, and other internal method changes such as calling endRemainingAnimations() instead of the loop that calls node.animation.end(). These constitute code change types 1, 3, and 4.","Both the new if statement that checks `mShouldIgnoreEndWithoutStart` and the elimination of the loop that calls `node.animation.end()` could lead to a different ending process of the animations. Thus, the API might have different behavior (e.g., which animations are actually ended) and return a different value/state due to the alterations, which can be a cause for compatibility issues, so the CI type is 1."
168,<android.app.admin.DevicePolicyManager: int getPermissionPolicy(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPermissionPolicy(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPermissionPolicy(ComponentName)>,0,"{
    try {
        return mService.getPermissionPolicy(admin);
    } catch (RemoteException re) {
        return PERMISSION_POLICY_PROMPT;
    }
}","{
    throwIfParentInstance(""getPermissionPolicy"");
    try {
        return mService.getPermissionPolicy(admin);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the current runtime permission policy set by the device or profile owner. The
 * default is {@link #PERMISSION_POLICY_PROMPT}.
 * @param admin Which profile or device owner this request is associated with.
 * @return the current policy for future permission requests.
 */
","/**
 * Returns the current runtime permission policy set by the device or profile owner. The
 * default is {@link #PERMISSION_POLICY_PROMPT}.
 * @param admin Which profile or device owner this request is associated with.
 * @return the current policy for future permission requests.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,2",2,"The introduction of a new method call throwIfParentInstance(""getPermissionPolicy"") before the try block is a change in the method that does not affect control flow or the return value directly, indicating an 'Other statement changed'. Additionally, the exception handling behavior has changed. Instead of returning a default value PERMISSION_POLICY_PROMPT, the new code throws the exception, which is an 'Exception handling statement changed'.","The change in exception handling from returning a default value to throwing an exception can lead to different behavior in terms of exception handling when the method is called and encounters a RemoteException, so the CI type is 2."
169,"<android.content.res.Resources: void getValueForDensity(int,int,TypedValue,boolean)>",23,24,"<android.content.res.Resources: void getValueForDensity(int,int,TypedValue,boolean)>","<android.content.res.Resources: void getValueForDensity(int,int,TypedValue,boolean)>",0,"{
    boolean found = mAssets.getResourceValue(id, density, outValue, resolveRefs);
    if (found) {
        return;
    }
    throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id));
}","{
    mResourcesImpl.getValueForDensity(id, density, outValue, resolveRefs);
}",1,"/**
 * Get the raw value associated with a resource with associated density.
 *
 * @param id resource identifier
 * @param density density in DPI
 * @param resolveRefs If true, a resource that is a reference to another
 * resource will be followed so that you receive the actual final
 * resource data. If false, the TypedValue will be filled in with
 * the reference itself.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @see #getValue(String, TypedValue, boolean)
 */
","/**
 * Get the raw value associated with a resource with associated density.
 *
 * @param id resource identifier
 * @param density density in DPI
 * @param resolveRefs If true, a resource that is a reference to another
 * resource will be followed so that you receive the actual final
 * resource data. If false, the TypedValue will be filled in with
 * the reference itself.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @see #getValue(String, TypedValue, boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",2,"The method body has changed from using 'mAssets.getResourceValue' to 'mResourcesImpl.getValueForDensity' without the accompanying control flow to throw NotFoundException. Additionally, there is no try-catch block or other exception handling in the late version. Thus, the code change types are 4 (other statement changed) and 5 (dependent API changed).","In the early version, if the resource is not found, a NotFoundException is thrown. In the late version, the NotFoundException is no longer thrown because the exception handling code has been removed. Therefore, the API could potentially throw different exceptions, and the CI type is 2."
171,<android.app.ActivityManager: int getLockTaskModeState()>,23,24,<android.app.ActivityManager: int getLockTaskModeState()>,<android.app.ActivityManager: int getLockTaskModeState()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getLockTaskModeState();
    } catch (RemoteException e) {
        return ActivityManager.LOCK_TASK_MODE_NONE;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getLockTaskModeState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
","/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from a return statement to a throw statement, so the code change type is 2.","The late version of the API throws an exception instead of returning a default value, potentially leading to different exception handling behavior, so the CI type is 2."
172,"<android.accounts.AccountManager: void setUserData(Account,String,String)>",23,24,"<android.accounts.AccountManager: void setUserData(Account,String,String)>","<android.accounts.AccountManager: void setUserData(Account,String,String)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        mService.setUserData(account, key, value);
    } catch (RemoteException e) {
        // Will happen if there is not signature match.
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        mService.setUserData(account, key, value);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets one userdata key for an account.  Intended by use for the
 * authenticator to stash state for itself, not directly by applications.
 * The meaning of the keys and values is up to the authenticator.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account Account whose user data is to be set. Must not be {@code null}.
 * @param key String user data key to set.  Must not be null
 * @param value String value to set, {@code null} to clear this user data key
 */
","/**
 * Sets one userdata key for an account.  Intended by use for the
 * authenticator to stash state for itself, not directly by applications.
 * The meaning of the keys and values is up to the authenticator.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account Account whose user data is to be set. Must not be {@code null}.
 * @param key String user data key to set.  Must not be null
 * @param value String value to set, {@code null} to clear this user data key
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The catch block's exception rethrowing mechanism has changed from throwing a new RuntimeException to throwing the result of e.rethrowFromSystemServer(), hence the code change type is 2.","The change in the exception handling statement could lead to potential different exception handlings, as the new mechanism might throw a different type of exception than the previous version would. Therefore, the CI type is 2."
174,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",23,24,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>","<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",0,"{
    if (mParcelledData != null) {
        if (mParcelledData == EMPTY_PARCEL) {
            parcel.writeInt(0);
        } else {
            int length = mParcelledData.dataSize();
            parcel.writeInt(length);
            parcel.writeInt(BUNDLE_MAGIC);
            parcel.appendFrom(mParcelledData, 0, length);
        }
    } else {
        // Special case for empty bundles.
        if (mMap == null || mMap.size() <= 0) {
            parcel.writeInt(0);
            return;
        }
        int lengthPos = parcel.dataPosition();
        // dummy, will hold length
        parcel.writeInt(-1);
        parcel.writeInt(BUNDLE_MAGIC);
        int startPos = parcel.dataPosition();
        parcel.writeArrayMapInternal(mMap);
        int endPos = parcel.dataPosition();
        // Backpatch length
        parcel.setDataPosition(lengthPos);
        int length = endPos - startPos;
        parcel.writeInt(length);
        parcel.setDataPosition(endPos);
    }
}","{
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final Parcel parcelledData;
    synchronized (this) {
        parcelledData = mParcelledData;
    }
    if (parcelledData != null) {
        if (isEmptyParcel()) {
            parcel.writeInt(0);
        } else {
            int length = parcelledData.dataSize();
            parcel.writeInt(length);
            parcel.writeInt(BUNDLE_MAGIC);
            parcel.appendFrom(parcelledData, 0, length);
        }
    } else {
        // Special case for empty bundles.
        if (mMap == null || mMap.size() <= 0) {
            parcel.writeInt(0);
            return;
        }
        int lengthPos = parcel.dataPosition();
        // dummy, will hold length
        parcel.writeInt(-1);
        parcel.writeInt(BUNDLE_MAGIC);
        int startPos = parcel.dataPosition();
        parcel.writeArrayMapInternal(mMap);
        int endPos = parcel.dataPosition();
        // Backpatch length
        parcel.setDataPosition(lengthPos);
        int length = endPos - startPos;
        parcel.writeInt(length);
        parcel.setDataPosition(endPos);
    }
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation change is the addition of a synchronized block around the retrieval of `mParcelledData`. There is no change in the logic of the code that could affect the outcome of the operations performed by the `writeToParcelInner` method. Therefore, the code change type is 4.","There is no Compatibility Issue since the addition of the synchronized block will not change the behavior of how data is written to the `Parcel` object provided that the state of `BaseBundle` is correctly maintained across different threads. This change ensures thread safety when accessing `mParcelledData` but does not alter the data that is written to the `Parcel`. Hence, the implementation change does not lead to a Compatibility Issue."
176,<android.view.ViewGroup: boolean onInterceptHoverEvent(MotionEvent)>,23,24,<android.view.ViewGroup: boolean onInterceptHoverEvent(MotionEvent)>,<android.view.ViewGroup: boolean onInterceptHoverEvent(MotionEvent)>,0,"{
    return false;
}","{
    if (event.isFromSource(InputDevice.SOURCE_MOUSE)) {
        final int action = event.getAction();
        final float x = event.getX();
        final float y = event.getY();
        if ((action == MotionEvent.ACTION_HOVER_MOVE || action == MotionEvent.ACTION_HOVER_ENTER) && isOnScrollbar(x, y)) {
            return true;
        }
    }
    return false;
}",1,"/**
 * Implement this method to intercept hover events before they are handled
 * by child views.
 * <p>
 * This method is called before dispatching a hover event to a child of
 * the view group or to the view group's own {@link #onHoverEvent} to allow
 * the view group a chance to intercept the hover event.
 * This method can also be used to watch all pointer motions that occur within
 * the bounds of the view group even when the pointer is hovering over
 * a child of the view group rather than over the view group itself.
 * </p><p>
 * The view group can prevent its children from receiving hover events by
 * implementing this method and returning <code>true</code> to indicate
 * that it would like to intercept hover events.  The view group must
 * continuously return <code>true</code> from {@link #onInterceptHoverEvent}
 * for as long as it wishes to continue intercepting hover events from
 * its children.
 * </p><p>
 * Interception preserves the invariant that at most one view can be
 * hovered at a time by transferring hover focus from the currently hovered
 * child to the view group or vice-versa as needed.
 * </p><p>
 * If this method returns <code>true</code> and a child is already hovered, then the
 * child view will first receive a hover exit event and then the view group
 * itself will receive a hover enter event in {@link #onHoverEvent}.
 * Likewise, if this method had previously returned <code>true</code> to intercept hover
 * events and instead returns <code>false</code> while the pointer is hovering
 * within the bounds of one of a child, then the view group will first receive a
 * hover exit event in {@link #onHoverEvent} and then the hovered child will
 * receive a hover enter event.
 * </p><p>
 * The default implementation always returns false.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view group would like to intercept the hover event
 * and prevent its children from receiving it.
 */
","/**
 * Implement this method to intercept hover events before they are handled
 * by child views.
 * <p>
 * This method is called before dispatching a hover event to a child of
 * the view group or to the view group's own {@link #onHoverEvent} to allow
 * the view group a chance to intercept the hover event.
 * This method can also be used to watch all pointer motions that occur within
 * the bounds of the view group even when the pointer is hovering over
 * a child of the view group rather than over the view group itself.
 * </p><p>
 * The view group can prevent its children from receiving hover events by
 * implementing this method and returning <code>true</code> to indicate
 * that it would like to intercept hover events.  The view group must
 * continuously return <code>true</code> from {@link #onInterceptHoverEvent}
 * for as long as it wishes to continue intercepting hover events from
 * its children.
 * </p><p>
 * Interception preserves the invariant that at most one view can be
 * hovered at a time by transferring hover focus from the currently hovered
 * child to the view group or vice-versa as needed.
 * </p><p>
 * If this method returns <code>true</code> and a child is already hovered, then the
 * child view will first receive a hover exit event and then the view group
 * itself will receive a hover enter event in {@link #onHoverEvent}.
 * Likewise, if this method had previously returned <code>true</code> to intercept hover
 * events and instead returns <code>false</code> while the pointer is hovering
 * within the bounds of one of a child, then the view group will first receive a
 * hover exit event in {@link #onHoverEvent} and then the hovered child will
 * receive a hover enter event.
 * </p><p>
 * The default implementation handles mouse hover on the scroll bars.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view group would like to intercept the hover event
 * and prevent its children from receiving it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late implementation introduces a new control dependency with 'if' condition and changes the logic by returning 'true' under some circumstances, so it is categorized as 1,3.","The late version of the method introduces new conditions under which the method will return true instead of false. This constitutes a change in the return value under certain conditions, indicating a potential CI of type 1."
177,<android.app.ActivityManager.TaskDescription: String toString()>,23,24,<android.app.ActivityManager.TaskDescription: String toString()>,<android.app.ActivityManager.TaskDescription: String toString()>,0,"{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" colorPrimary: "" + mColorPrimary;
}","{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been altered to include additional information (mIconFilename and mColorBackground), which changes the string returned by the method. Thus, the change type is 1.","The modification of the return statement will result in a different return value in the new version of the API compared to the previous one. Therefore, the CI type is 1."
178,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,23,24,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final ArrayList<View> preorderedList = buildOrderedChildList();
            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
            if (preorderedList != null)
                preorderedList.clear();
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}","{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final ArrayList<View> preorderedList = buildOrderedChildList();
            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
            if (preorderedList != null)
                preorderedList.clear();
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
",,-1,"[@SuppressWarnings({ ""ConstantConditions"" }), @Override]","[@SuppressWarnings({ ""ConstantConditions"" }), @Override]",-1,-1,-1,-1,-1,-1,,,,
179,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,23,24,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!mIsUserSeekable || !isEnabled()) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            if (isInScrollingContainer()) {
                mTouchDownX = event.getX();
            } else {
                setPressed(true);
                if (mThumb != null) {
                    // This may be within the padding region
                    invalidate(mThumb.getBounds());
                }
                onStartTrackingTouch();
                trackTouchEvent(event);
                attemptClaimDrag();
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mIsDragging) {
                trackTouchEvent(event);
            } else {
                final float x = event.getX();
                if (Math.abs(x - mTouchDownX) > mScaledTouchSlop) {
                    setPressed(true);
                    if (mThumb != null) {
                        // This may be within the padding region
                        invalidate(mThumb.getBounds());
                    }
                    onStartTrackingTouch();
                    trackTouchEvent(event);
                    attemptClaimDrag();
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsDragging) {
                trackTouchEvent(event);
                onStopTrackingTouch();
                setPressed(false);
            } else {
                // Touch up when we never crossed the touch slop threshold should
                // be interpreted as a tap-seek to that location.
                onStartTrackingTouch();
                trackTouchEvent(event);
                onStopTrackingTouch();
            }
            // ProgressBar doesn't know to repaint the thumb drawable
            // in its inactive state when the touch stops (because the
            // value has not apparently changed)
            invalidate();
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsDragging) {
                onStopTrackingTouch();
                setPressed(false);
            }
            // see above explanation
            invalidate();
            break;
    }
    return true;
}","{
    if (!mIsUserSeekable || !isEnabled()) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            if (isInScrollingContainer()) {
                mTouchDownX = event.getX();
            } else {
                startDrag(event);
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mIsDragging) {
                trackTouchEvent(event);
            } else {
                final float x = event.getX();
                if (Math.abs(x - mTouchDownX) > mScaledTouchSlop) {
                    startDrag(event);
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsDragging) {
                trackTouchEvent(event);
                onStopTrackingTouch();
                setPressed(false);
            } else {
                // Touch up when we never crossed the touch slop threshold should
                // be interpreted as a tap-seek to that location.
                onStartTrackingTouch();
                trackTouchEvent(event);
                onStopTrackingTouch();
            }
            // ProgressBar doesn't know to repaint the thumb drawable
            // in its inactive state when the touch stops (because the
            // value has not apparently changed)
            invalidate();
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsDragging) {
                onStopTrackingTouch();
                setPressed(false);
            }
            // see above explanation
            invalidate();
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The method body has changed by replacing explicit code with a call to startDrag(event) in the ACTION_DOWN and ACTION_MOVE cases of the switch statement. The replacement of these specific blocks of code by the startDrag(event) method call is a change type of Other statement changed (4) since new method invocations have been introduced. Additionally, there are Control dependency changes (3) because the structure of the 'if' conditions inside the switch cases has been altered.","Although there are changes in the method implementation, this method always returns true, and the exception handling hasn't been changed. The refactoring to startDrag(event) presumably encapsulates the functionality that was explicitly written out in the early version of the method. As long as startDrag(event) does not modify the method's behavior regarding returned results or exceptions, no compatibility issue related to returned values or exception handling should be introduced. Thus, based on the information provided, there appears to be No Compatibility Issue (0). However, it assumes that the new startDrag method's implementation is consistent with the replaced code's behavior."
180,<android.net.http.X509TrustManagerExtensions: boolean isUserAddedCertificate(X509Certificate)>,23,24,<android.net.http.X509TrustManagerExtensions: boolean isUserAddedCertificate(X509Certificate)>,<android.net.http.X509TrustManagerExtensions: boolean isUserAddedCertificate(X509Certificate)>,0,"{
    return mDelegate.isUserAddedCertificate(cert);
}","{
    return UserCertificateSource.getInstance().findBySubjectAndPublicKey(cert) != null;
}",1,"/**
 * Checks whether a CA certificate is added by an user.
 *
 * <p>Since {@link X509TrustManager#checkServerTrusted} allows its parameter {@code chain} to
 * chain up to user-added CA certificates, this method can be used to perform additional
 * policies for user-added CA certificates.
 *
 * @return {@code true} to indicate that the certificate was added by the user, {@code false}
 * otherwise.
 */
","/**
 * Checks whether a CA certificate is added by an user.
 *
 * <p>Since {@link X509TrustManager#checkServerTrusted} may allow its parameter {@code chain} to
 * chain up to user-added CA certificates, this method can be used to perform additional
 * policies for user-added CA certificates.
 *
 * @return {@code true} to indicate that the certificate authority exists in the user added
 * certificate store, {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement now directly uses a different method, UserCertificateSource.getInstance().findBySubjectAndPublicKey(cert) != null, instead of mDelegate.isUserAddedCertificate(cert). Since this is using a different mechanism to determine if the certificate is user added, the change type is 1,5.","The change in the implementation of the return statement could potentially lead to a different return value since it's reliant on a different underlying method to check if a certificate is user-added, therefore it is a CI type 1."
181,"<android.app.admin.DevicePolicyManager: void setCertInstallerPackage(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: void setCertInstallerPackage(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void setCertInstallerPackage(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            mService.setCertInstallerPackage(admin, installerPackage);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setCertInstallerPackage"");
    if (mService != null) {
        try {
            mService.setCertInstallerPackage(admin, installerPackage);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile owner or device owner to grant access to privileged certificate
 * manipulation APIs to a third-party certificate installer app. Granted APIs include
 * {@link #getInstalledCaCerts}, {@link #hasCaCertInstalled}, {@link #installCaCert},
 * {@link #uninstallCaCert}, {@link #uninstallAllUserCaCerts} and {@link #installKeyPair}.
 * <p>
 * Delegated certificate installer is a per-user state. The delegated access is persistent until
 * it is later cleared by calling this method with a null value or uninstallling the certificate
 * installer.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param installerPackage The package name of the certificate installer which will be given
 * access. If {@code null} is given the current package will be cleared.
 */
","/**
 * Called by a profile owner or device owner to grant access to privileged certificate
 * manipulation APIs to a third-party certificate installer app. Granted APIs include
 * {@link #getInstalledCaCerts}, {@link #hasCaCertInstalled}, {@link #installCaCert},
 * {@link #uninstallCaCert}, {@link #uninstallAllUserCaCerts} and {@link #installKeyPair}.
 * <p>
 * Delegated certificate installer is a per-user state. The delegated access is persistent until
 * it is later cleared by calling this method with a null value or uninstallling the certificate
 * installer.
 * <p>
 * <b>Note:</b>Starting from {@link android.os.Build.VERSION_CODES#N}, if the caller
 * application's target SDK version is {@link android.os.Build.VERSION_CODES#N} or newer, the
 * supplied certificate installer package must be installed when calling this API, otherwise an
 * {@link IllegalArgumentException} will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param installerPackage The package name of the certificate installer which will be given
 * access. If {@code null} is given the current package will be cleared.
 * @throws SecurityException if {@code admin} is not a device or a profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The changes in the code include the introduction of a new method call throwIfParentInstance(""setCertInstallerPackage"") before the existing code and changing the handling of RemoteException from logging an error to throwing an exception using e.rethrowFromSystemServer(). Thus, the change types are 3 (control dependency changed due to the new method call) and 2,4 (exception handling statement changed and other statement changed).","The addition of throwIfParentInstance could potentially lead to a new exception being thrown before the existing code executes. Furthermore, changing the error handling from logging to throwing an exception directly with e.rethrowFromSystemServer() means that RemoteException will now be thrown instead of being caught and logged. Thus, the CI type is 2 (compatibility issue caused by potential different exception handlings)."
182,<android.app.NotificationManager: void cancelAll()>,23,24,<android.app.NotificationManager: void cancelAll()>,<android.app.NotificationManager: void cancelAll()>,0,"{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancelAll()"");
    try {
        service.cancelAllNotifications(pkg, UserHandle.myUserId());
    } catch (RemoteException e) {
    }
}","{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancelAll()"");
    try {
        service.cancelAllNotifications(pkg, UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Cancel all previously shown notifications. See {@link #cancel} for the
 * detailed behavior.
 */
","/**
 * Cancel all previously shown notifications. See {@link #cancel} for the
 * detailed behavior.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement was changed in the API to throw an exception instead of doing nothing on a RemoteException, so the code change type is 2.","Because in the early version RemoteException was ignored, while in the late version it is re-thrown, it can potentially lead to different exception handling behaviour. Therefore, the CI type is 2."
184,"<android.widget.AutoCompleteTextView: void onFocusChanged(boolean,int,Rect)>",23,24,"<android.widget.AutoCompleteTextView: void onFocusChanged(boolean,int,Rect)>","<android.widget.AutoCompleteTextView: void onFocusChanged(boolean,int,Rect)>",0,"{
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
    if (mTemporaryDetach) {
        // If we are temporarily in the detach state, then do nothing.
        return;
    }
    // Perform validation if the view is losing focus.
    if (!focused) {
        performValidation();
    }
    if (!focused && !mPopup.isDropDownAlwaysVisible()) {
        dismissDropDown();
    }
}","{
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
    if (isTemporarilyDetached()) {
        // If we are temporarily in the detach state, then do nothing.
        return;
    }
    // Perform validation if the view is losing focus.
    if (!focused) {
        performValidation();
    }
    if (!focused && !mPopup.isDropDownAlwaysVisible()) {
        dismissDropDown();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change is from accessing the variable `mTemporaryDetach` directly to call the method `isTemporarilyDetached()`. This is the usage of a potentially different dependent API (method), so the change type is 5.","There is no compatibility issue detected because the change is an internal check using a different method but with presumably the same behavior. The outcome of the method appears to maintain the previous logic, and no new return or exception handling changes have been introduced that would alter the API's behavior from a caller's perspective. Therefore, the CI situation is 0."
185,<android.animation.ValueAnimator: ValueAnimator setDuration(long)>,23,24,<android.animation.ValueAnimator: ValueAnimator setDuration(long)>,<android.animation.ValueAnimator: ValueAnimator setDuration(long)>,0,"{
    if (duration < 0) {
        throw new IllegalArgumentException(""Animators cannot have negative duration: "" + duration);
    }
    mUnscaledDuration = duration;
    updateScaledDuration();
    return this;
}","{
    if (duration < 0) {
        throw new IllegalArgumentException(""Animators cannot have negative duration: "" + duration);
    }
    mDuration = duration;
    return this;
}",1,"/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */
","/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There has been a change in the assignment statement from 'mUnscaledDuration = duration;' to 'mDuration = duration;' and the method call 'updateScaledDuration()' was removed, so the type of change is 4.","The change in variable assignment and the removal of a method call do not lead to different return values or types, nor do they change exception handling. Therefore, there is no Compatibility Issue."
186,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",23,24,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>","<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    if (parentMatches(startParent, endParent)) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        final int startLeft = startBounds.left;
        final int endLeft = endBounds.left;
        final int startTop = startBounds.top;
        final int endTop = endBounds.top;
        final int startRight = startBounds.right;
        final int endRight = endBounds.right;
        final int startBottom = startBounds.bottom;
        final int endBottom = endBounds.bottom;
        final int startWidth = startRight - startLeft;
        final int startHeight = startBottom - startTop;
        final int endWidth = endRight - endLeft;
        final int endHeight = endBottom - endTop;
        Rect startClip = (Rect) startValues.values.get(PROPNAME_CLIP);
        Rect endClip = (Rect) endValues.values.get(PROPNAME_CLIP);
        int numChanges = 0;
        if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
            if (startLeft != endLeft || startTop != endTop)
                ++numChanges;
            if (startRight != endRight || startBottom != endBottom)
                ++numChanges;
        }
        if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
            ++numChanges;
        }
        if (numChanges > 0) {
            Animator anim;
            if (!mResizeClip) {
                view.setLeftTopRightBottom(startLeft, startTop, startRight, startBottom);
                if (numChanges == 2) {
                    if (startWidth == endWidth && startHeight == endHeight) {
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        anim = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                    } else {
                        final ViewBounds viewBounds = new ViewBounds(view);
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        ObjectAnimator topLeftAnimator = ObjectAnimator.ofObject(viewBounds, TOP_LEFT_PROPERTY, null, topLeftPath);
                        Path bottomRightPath = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                        ObjectAnimator bottomRightAnimator = ObjectAnimator.ofObject(viewBounds, BOTTOM_RIGHT_PROPERTY, null, bottomRightPath);
                        AnimatorSet set = new AnimatorSet();
                        set.playTogether(topLeftAnimator, bottomRightAnimator);
                        anim = set;
                        set.addListener(new AnimatorListenerAdapter() {

                            // We need a strong reference to viewBounds until the
                            // animator ends.
                            private ViewBounds mViewBounds = viewBounds;
                        });
                    }
                } else if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    anim = ObjectAnimator.ofObject(view, TOP_LEFT_ONLY_PROPERTY, null, topLeftPath);
                } else {
                    Path bottomRight = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                    anim = ObjectAnimator.ofObject(view, BOTTOM_RIGHT_ONLY_PROPERTY, null, bottomRight);
                }
            } else {
                int maxWidth = Math.max(startWidth, endWidth);
                int maxHeight = Math.max(startHeight, endHeight);
                view.setLeftTopRightBottom(startLeft, startTop, startLeft + maxWidth, startTop + maxHeight);
                ObjectAnimator positionAnimator = null;
                if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    positionAnimator = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                }
                final Rect finalClip = endClip;
                if (startClip == null) {
                    startClip = new Rect(0, 0, startWidth, startHeight);
                }
                if (endClip == null) {
                    endClip = new Rect(0, 0, endWidth, endHeight);
                }
                ObjectAnimator clipAnimator = null;
                if (!startClip.equals(endClip)) {
                    view.setClipBounds(startClip);
                    clipAnimator = ObjectAnimator.ofObject(view, ""clipBounds"", sRectEvaluator, startClip, endClip);
                    clipAnimator.addListener(new AnimatorListenerAdapter() {

                        private boolean mIsCanceled;

                        @Override
                        public void onAnimationCancel(Animator animation) {
                            mIsCanceled = true;
                        }

                        @Override
                        public void onAnimationEnd(Animator animation) {
                            if (!mIsCanceled) {
                                view.setClipBounds(finalClip);
                                view.setLeftTopRightBottom(endLeft, endTop, endRight, endBottom);
                            }
                        }
                    });
                }
                anim = TransitionUtils.mergeAnimators(positionAnimator, clipAnimator);
            }
            if (view.getParent() instanceof ViewGroup) {
                final ViewGroup parent = (ViewGroup) view.getParent();
                parent.suppressLayout(true);
                TransitionListener transitionListener = new TransitionListenerAdapter() {

                    boolean mCanceled = false;

                    @Override
                    public void onTransitionCancel(Transition transition) {
                        parent.suppressLayout(false);
                        mCanceled = true;
                    }

                    @Override
                    public void onTransitionEnd(Transition transition) {
                        if (!mCanceled) {
                            parent.suppressLayout(false);
                        }
                    }

                    @Override
                    public void onTransitionPause(Transition transition) {
                        parent.suppressLayout(false);
                    }

                    @Override
                    public void onTransitionResume(Transition transition) {
                        parent.suppressLayout(true);
                    }
                };
                addListener(transitionListener);
            }
            return anim;
        }
    } else {
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X);
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y);
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X);
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y);
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            sceneRoot.getLocationInWindow(tempLocation);
            Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            final float transitionAlpha = view.getTransitionAlpha();
            view.setTransitionAlpha(0);
            sceneRoot.getOverlay().add(drawable);
            Path topLeftPath = getPathMotion().getPath(startX - tempLocation[0], startY - tempLocation[1], endX - tempLocation[0], endY - tempLocation[1]);
            PropertyValuesHolder origin = PropertyValuesHolder.ofObject(DRAWABLE_ORIGIN_PROPERTY, null, topLeftPath);
            ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(drawable, origin);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setTransitionAlpha(transitionAlpha);
                }
            });
            return anim;
        }
    }
    return null;
}","{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    if (parentMatches(startParent, endParent)) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        final int startLeft = startBounds.left;
        final int endLeft = endBounds.left;
        final int startTop = startBounds.top;
        final int endTop = endBounds.top;
        final int startRight = startBounds.right;
        final int endRight = endBounds.right;
        final int startBottom = startBounds.bottom;
        final int endBottom = endBounds.bottom;
        final int startWidth = startRight - startLeft;
        final int startHeight = startBottom - startTop;
        final int endWidth = endRight - endLeft;
        final int endHeight = endBottom - endTop;
        Rect startClip = (Rect) startValues.values.get(PROPNAME_CLIP);
        Rect endClip = (Rect) endValues.values.get(PROPNAME_CLIP);
        int numChanges = 0;
        if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
            if (startLeft != endLeft || startTop != endTop)
                ++numChanges;
            if (startRight != endRight || startBottom != endBottom)
                ++numChanges;
        }
        if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
            ++numChanges;
        }
        if (numChanges > 0) {
            Animator anim;
            if (!mResizeClip) {
                view.setLeftTopRightBottom(startLeft, startTop, startRight, startBottom);
                if (numChanges == 2) {
                    if (startWidth == endWidth && startHeight == endHeight) {
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        anim = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                    } else {
                        final ViewBounds viewBounds = new ViewBounds(view);
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        ObjectAnimator topLeftAnimator = ObjectAnimator.ofObject(viewBounds, TOP_LEFT_PROPERTY, null, topLeftPath);
                        Path bottomRightPath = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                        ObjectAnimator bottomRightAnimator = ObjectAnimator.ofObject(viewBounds, BOTTOM_RIGHT_PROPERTY, null, bottomRightPath);
                        AnimatorSet set = new AnimatorSet();
                        set.playTogether(topLeftAnimator, bottomRightAnimator);
                        anim = set;
                        set.addListener(new AnimatorListenerAdapter() {

                            // We need a strong reference to viewBounds until the
                            // animator ends.
                            private ViewBounds mViewBounds = viewBounds;
                        });
                    }
                } else if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    anim = ObjectAnimator.ofObject(view, TOP_LEFT_ONLY_PROPERTY, null, topLeftPath);
                } else {
                    Path bottomRight = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                    anim = ObjectAnimator.ofObject(view, BOTTOM_RIGHT_ONLY_PROPERTY, null, bottomRight);
                }
            } else {
                int maxWidth = Math.max(startWidth, endWidth);
                int maxHeight = Math.max(startHeight, endHeight);
                view.setLeftTopRightBottom(startLeft, startTop, startLeft + maxWidth, startTop + maxHeight);
                ObjectAnimator positionAnimator = null;
                if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    positionAnimator = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                }
                final Rect finalClip = endClip;
                if (startClip == null) {
                    startClip = new Rect(0, 0, startWidth, startHeight);
                }
                if (endClip == null) {
                    endClip = new Rect(0, 0, endWidth, endHeight);
                }
                ObjectAnimator clipAnimator = null;
                if (!startClip.equals(endClip)) {
                    view.setClipBounds(startClip);
                    clipAnimator = ObjectAnimator.ofObject(view, ""clipBounds"", sRectEvaluator, startClip, endClip);
                    clipAnimator.addListener(new AnimatorListenerAdapter() {

                        private boolean mIsCanceled;

                        @Override
                        public void onAnimationCancel(Animator animation) {
                            mIsCanceled = true;
                        }

                        @Override
                        public void onAnimationEnd(Animator animation) {
                            if (!mIsCanceled) {
                                view.setClipBounds(finalClip);
                                view.setLeftTopRightBottom(endLeft, endTop, endRight, endBottom);
                            }
                        }
                    });
                }
                anim = TransitionUtils.mergeAnimators(positionAnimator, clipAnimator);
            }
            if (view.getParent() instanceof ViewGroup) {
                final ViewGroup parent = (ViewGroup) view.getParent();
                parent.suppressLayout(true);
                TransitionListener transitionListener = new TransitionListenerAdapter() {

                    boolean mCanceled = false;

                    @Override
                    public void onTransitionCancel(Transition transition) {
                        parent.suppressLayout(false);
                        mCanceled = true;
                    }

                    @Override
                    public void onTransitionEnd(Transition transition) {
                        if (!mCanceled) {
                            parent.suppressLayout(false);
                        }
                    }

                    @Override
                    public void onTransitionPause(Transition transition) {
                        parent.suppressLayout(false);
                    }

                    @Override
                    public void onTransitionResume(Transition transition) {
                        parent.suppressLayout(true);
                    }
                };
                addListener(transitionListener);
            }
            return anim;
        }
    } else {
        sceneRoot.getLocationInWindow(tempLocation);
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            final int width = view.getWidth();
            final int height = view.getHeight();
            Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            drawable.setBounds(startX, startY, startX + width, startY + height);
            final float transitionAlpha = view.getTransitionAlpha();
            view.setTransitionAlpha(0);
            sceneRoot.getOverlay().add(drawable);
            Path topLeftPath = getPathMotion().getPath(startX, startY, endX, endY);
            PropertyValuesHolder origin = PropertyValuesHolder.ofObject(DRAWABLE_ORIGIN_PROPERTY, null, topLeftPath);
            ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(drawable, origin);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setTransitionAlpha(transitionAlpha);
                }
            });
            return anim;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
187,<android.content.res.Resources: Movie getMovie(int)>,23,24,<android.content.res.Resources: Movie getMovie(int)>,<android.content.res.Resources: Movie getMovie(int)>,0,"{
    InputStream is = openRawResource(id);
    Movie movie = Movie.decodeStream(is);
    try {
        is.close();
    } catch (java.io.IOException e) {
    // don't care, since the return value is valid
    }
    return movie;
}","{
    final InputStream is = openRawResource(id);
    final Movie movie = Movie.decodeStream(is);
    try {
        is.close();
    } catch (IOException e) {
    // No one cares.
    }
    return movie;
}",1,"/**
 * Return a movie object associated with the particular resource ID.
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Return a movie object associated with the particular resource ID.
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"No significant code change is detected, only comments and the use of 'final' modifier for local variables changed, which does not affect the API's behavior.","There is no Compatibility Issue because the changes made do not affect the execution path, return values, exception handling, or any other behavior of the method."
188,<android.view.View: int[] onCreateDrawableState(int)>,23,24,<android.view.View: int[] onCreateDrawableState(int)>,<android.view.View: int[] onCreateDrawableState(int)>,0,"{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PFLAG_PRESSED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= StateSet.VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= StateSet.VIEW_STATE_FOCUSED;
    if ((privateFlags & PFLAG_SELECTED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= StateSet.VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & PFLAG_ACTIVATED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested && HardwareRenderer.isAvailable()) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= StateSet.VIEW_STATE_ACCELERATED;
    }
    if ((privateFlags & PFLAG_HOVERED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_HOVERED;
    final int privateFlags2 = mPrivateFlags2;
    if ((privateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_CAN_ACCEPT;
    }
    if ((privateFlags2 & PFLAG2_DRAG_HOVERED) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_HOVERED;
    }
    drawableState = StateSet.get(viewStateIndex);
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PFLAG_PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & PFLAG_SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}","{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PFLAG_PRESSED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= StateSet.VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= StateSet.VIEW_STATE_FOCUSED;
    if ((privateFlags & PFLAG_SELECTED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= StateSet.VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & PFLAG_ACTIVATED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested && ThreadedRenderer.isAvailable()) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= StateSet.VIEW_STATE_ACCELERATED;
    }
    if ((privateFlags & PFLAG_HOVERED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_HOVERED;
    final int privateFlags2 = mPrivateFlags2;
    if ((privateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_CAN_ACCEPT;
    }
    if ((privateFlags2 & PFLAG2_DRAG_HOVERED) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_HOVERED;
    }
    drawableState = StateSet.get(viewStateIndex);
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PFLAG_PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & PFLAG_SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}",1,"/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates(int[], int[])
 */
","/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates(int[], int[])
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
189,"<android.widget.TabWidget: void onFocusChange(View,boolean)>",23,24,"<android.widget.TabWidget: void onFocusChange(View,boolean)>","<android.widget.TabWidget: void onFocusChange(View,boolean)>",0,"{
    if (v == this && hasFocus && getTabCount() > 0) {
        getChildTabViewAt(mSelectedTab).requestFocus();
        return;
    }
    if (hasFocus) {
        int i = 0;
        int numTabs = getTabCount();
        while (i < numTabs) {
            if (getChildTabViewAt(i) == v) {
                setCurrentTab(i);
                mSelectionChangedListener.onTabSelectionChanged(i, false);
                if (isShown()) {
                    // a tab is focused so send an event to announce the tab widget state
                    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED);
                }
                break;
            }
            i++;
        }
    }
}","{
// No-op. Tab selection is separate from keyboard focus.
}",1,"/**
 * {@inheritDoc}
 */
",,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The Late_Implementation has been replaced with a no-operation comment, removing all previous code. Therefore, the change types include the removal of a return statement (1) and other statements that were handling logic (4).","Since the entire implementation was removed and replaced with a no-operation comment, the API will no longer behave as it previously did which indicates a change in return values (it now effectively returns nothing), thus causing a Compatibility Issue of type 1."
190,<android.text.TextUtils: boolean isGraphic(CharSequence)>,23,24,<android.text.TextUtils: boolean isGraphic(CharSequence)>,<android.text.TextUtils: boolean isGraphic(CharSequence)>,0,"{
    final int len = str.length();
    for (int i = 0; i < len; i++) {
        int gc = Character.getType(str.charAt(i));
        if (gc != Character.CONTROL && gc != Character.FORMAT && gc != Character.SURROGATE && gc != Character.UNASSIGNED && gc != Character.LINE_SEPARATOR && gc != Character.PARAGRAPH_SEPARATOR && gc != Character.SPACE_SEPARATOR) {
            return true;
        }
    }
    return false;
}","{
    final int len = str.length();
    for (int cp, i = 0; i < len; i += Character.charCount(cp)) {
        cp = Character.codePointAt(str, i);
        int gc = Character.getType(cp);
        if (gc != Character.CONTROL && gc != Character.FORMAT && gc != Character.SURROGATE && gc != Character.UNASSIGNED && gc != Character.LINE_SEPARATOR && gc != Character.PARAGRAPH_SEPARATOR && gc != Character.SPACE_SEPARATOR) {
            return true;
        }
    }
    return false;
}",1,"/**
 * Returns whether the given CharSequence contains any printable characters.
 */
","/**
 * Returns whether the given CharSequence contains any printable characters.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The internal loop logic has changed as it now uses Character.codePointAt(str, i) and adjusts the iterator 'i' by the character count of the code point. Additionally, an assignment operation was introduced for the 'cp' variable inside the loop. These changes affect other statements and hence, are classified as types 3 (Control dependency change) and 4 (Other statement changed).","The change potentially leads to a different return value as the decision to return true is now based on a possibly different set of character properties (via full Unicode code points rather than single characters). Hence, this modification impacts the behavior of the method and could cause a Compatibility Issue by returning different values under certain conditions, classified as type 1."
192,<android.app.admin.DevicePolicyManager: void lockNow()>,23,24,<android.app.admin.DevicePolicyManager: void lockNow()>,<android.app.admin.DevicePolicyManager: void lockNow()>,0,"{
    if (mService != null) {
        try {
            mService.lockNow();
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.lockNow(mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Make the device lock immediately, as if the lock screen timeout has
 * expired at the point of this call.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK} to be able to call
 * this method; if it has not, a security exception will be thrown.
 */
","/**
 * Make the device lock immediately, as if the lock screen timeout has expired at the point of
 * this call.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 * to be able to call this method; if it has not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to lock the parent profile.
 *
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5","1,2","The method call mService.lockNow() has been updated to pass an additional argument mParentInstance, which is a change in a dependent API resulting in a different behavior. Additionally, the exception handling has changed from logging an error to throwing a new wrapped exception. Therefore, both Other statement changed (4) and Dependent API changed (5) have occurred.","The introduction of a new parameter in the mService.lockNow method call could lead to different behavior, resulting in CI type 1 caused by different return values. Furthermore, the change in exception handling from logging to throwing an exception could lead to CI type 2 caused by potential different exception handling."
194,<android.app.admin.DevicePolicyManager: int getPasswordHistoryLength(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPasswordHistoryLength(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordHistoryLength(ComponentName)>,0,"{
    return getPasswordHistoryLength(admin, UserHandle.myUserId());
}","{
    return getPasswordHistoryLength(admin, myUserId());
}",1,"/**
 * Retrieve the current password history length for all admins of this
 * user and its profiles or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 * @return The length of the password history
 */
","/**
 * Retrieve the current password history length for a particular admin or all admins that
 * set retrictions on this user and its participating profiles. Restrictions on profiles that
 * have a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 * @return The length of the password history
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changed from calling `UserHandle.myUserId()` to `myUserId()` directly, so the code change type is 5 (dependent API changed).","Since both `UserHandle.myUserId()` and `myUserId()` are expected to return the current user ID and there's no change in functionality or the value returned by the method, there should be no compatibility issue; hence, the CI type is 0."
195,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",23,24,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",0,"{
    int block = loadThemeAttributeValue(theme, ident, outValue, resolveRefs);
    if (block >= 0) {
        if (outValue.type != TypedValue.TYPE_STRING) {
            return true;
        }
        StringBlock[] blocks = mStringBlocks;
        if (blocks == null) {
            ensureStringBlocks();
            blocks = mStringBlocks;
        }
        outValue.string = blocks[block].get(outValue.data);
        return true;
    }
    return false;
}","{
    final int block = loadThemeAttributeValue(theme, resId, outValue, resolveRefs);
    if (block < 0) {
        return false;
    }
    if (outValue.type == TypedValue.TYPE_STRING) {
        final StringBlock[] blocks = ensureStringBlocks();
        outValue.string = blocks[block].get(outValue.data);
    }
    return true;
}",1,"/*package*/
","/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow structure of the method has been changed by adjusting the condition in the 'if' statement, and replacing the two separate instances of code initialization with a single instance. The 'if' condition change also impacts the return value, and therefore, the changes are classified as both 1 for the return statement change and 3 for the control dependency change.","A Compatibility Issue could arise due to the modification of the 'if' condition which changes the early exit behavior of the method, potentially leading to a different return value than in the previous version. Therefore, the CI is classified as 1, indicating it could return different values or types."
196,<android.security.NetworkSecurityPolicy: boolean isCleartextTrafficPermitted()>,23,24,<android.security.NetworkSecurityPolicy: boolean isCleartextTrafficPermitted()>,<android.security.NetworkSecurityPolicy: boolean isCleartextTrafficPermitted()>,0,"{
    return libcore.net.NetworkSecurityPolicy.isCleartextTrafficPermitted();
}","{
    return libcore.net.NetworkSecurityPolicy.getInstance().isCleartextTrafficPermitted();
}",1,"/**
 * Returns whether cleartext network traffic (e.g. HTTP, FTP, WebSockets, XMPP, IMAP, SMTP --
 * without TLS or STARTTLS) is permitted for this process.
 *
 * <p>When cleartext network traffic is not permitted, the platform's components (e.g. HTTP and
 * FTP stacks, {@link android.app.DownloadManager}, {@link android.media.MediaPlayer}) will
 * refuse this process's requests to use cleartext traffic. Third-party libraries are strongly
 * encouraged to honor this setting as well.
 *
 * <p>This flag is honored on a best effort basis because it's impossible to prevent all
 * cleartext traffic from Android applications given the level of access provided to them. For
 * example, there's no expectation that the {@link java.net.Socket} API will honor this flag
 * because it cannot determine whether its traffic is in cleartext. However, most network
 * traffic from applications is handled by higher-level network stacks/components which can
 * honor this aspect of the policy.
 *
 * <p>NOTE: {@link android.webkit.WebView} does not honor this flag.
 */
","/**
 * Returns whether cleartext network traffic (e.g. HTTP, FTP, WebSockets, XMPP, IMAP, SMTP --
 * without TLS or STARTTLS) is permitted for all network communication from this process.
 *
 * <p>When cleartext network traffic is not permitted, the platform's components (e.g. HTTP and
 * FTP stacks, {@link android.app.DownloadManager}, {@link android.media.MediaPlayer}) will
 * refuse this process's requests to use cleartext traffic. Third-party libraries are strongly
 * encouraged to honor this setting as well.
 *
 * <p>This flag is honored on a best effort basis because it's impossible to prevent all
 * cleartext traffic from Android applications given the level of access provided to them. For
 * example, there's no expectation that the {@link java.net.Socket} API will honor this flag
 * because it cannot determine whether its traffic is in cleartext. However, most network
 * traffic from applications is handled by higher-level network stacks/components which can
 * honor this aspect of the policy.
 *
 * <p>NOTE: {@link android.webkit.WebView} does not honor this flag.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the API is calling a different method on `NetworkSecurityPolicy`. It changes from calling a static method to calling an instance method. Even though the method name is the same (`isCleartextTrafficPermitted()`), how the instance is obtained has changed (`getInstance()` is called in the late version). Thus the change type is 5.","There is no compatibility issue due to the change because the behavior of the `isCleartextTrafficPermitted()` method is presumed to remain the same, regardless of whether it's called on a singleton instance or directly as a static method. The change does not directly imply different return values or exception handlings; it merely indicates a different way to access the method. Assuming that the singleton pattern is correctly implemented for the `NetworkSecurityPolicy` class, the method should return the same result in both versions, therefore CI type is 0."
197,<android.app.Notification.Builder: Builder setDefaults(int)>,23,24,<android.app.Notification.Builder: Builder setDefaults(int)>,<android.app.Notification.Builder: Builder setDefaults(int)>,0,"{
    mDefaults = defaults;
    return this;
}","{
    mN.defaults = defaults;
    return this;
}",1,"/**
 * Set which notification properties will be inherited from system defaults.
 * <p>
 * The value should be one or more of the following fields combined with
 * bitwise-or:
 * {@link #DEFAULT_SOUND}, {@link #DEFAULT_VIBRATE}, {@link #DEFAULT_LIGHTS}.
 * <p>
 * For all default values, use {@link #DEFAULT_ALL}.
 */
","/**
 * Set which notification properties will be inherited from system defaults.
 * <p>
 * The value should be one or more of the following fields combined with
 * bitwise-or:
 * {@link #DEFAULT_SOUND}, {@link #DEFAULT_VIBRATE}, {@link #DEFAULT_LIGHTS}.
 * <p>
 * For all default values, use {@link #DEFAULT_ALL}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the assignment of the defaults from a possibly direct field mDefaults to a field in an object mN.defaults. This constitutes a change to an ""other statement,"" so the code change type is 4.","The way the default values are assigned has changed internally, but this does not impact the API's behavior from the perspective of the API consumer. The method signature is unchanged, and it still accepts an int parameter and returns a Builder object. Therefore, there is no compatibility issue, and the CI type is 0."
198,<android.text.BidiFormatter: BidiFormatter getInstance(Locale)>,23,24,<android.text.BidiFormatter: BidiFormatter getInstance(Locale)>,<android.text.BidiFormatter: BidiFormatter getInstance(Locale)>,0,"{
    return new Builder(locale).build();
}","{
    return getDefaultInstanceFromContext(isRtlLocale(locale));
}",1,"/**
 * Factory for creating an instance of BidiFormatter given the context locale.
 *
 * @param locale The context locale.
 */
","/**
 * Factory for creating an instance of BidiFormatter given the context locale.
 *
 * This does not create any new objects, and returns already existing static instances.
 *
 * @param locale The context locale.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the method changed from directly creating a new Builder instance to calling a different method getDefaultInstanceFromContext with a new condition isRtlLocale(locale), so the code change type is 4,5.","Since the late version of the API uses a new method (getDefaultInstanceFromContext) that likely has different internal logic to create a BidiFormatter instance, the API potentially returns a different object, hence the CI type is 1."
199,<android.printservice.PrintService: List<PrintJob> getActivePrintJobs()>,23,24,<android.printservice.PrintService: List<PrintJob> getActivePrintJobs()>,<android.printservice.PrintService: List<PrintJob> getActivePrintJobs()>,0,"{
    throwIfNotCalledOnMainThread();
    if (mClient == null) {
        return Collections.emptyList();
    }
    try {
        List<PrintJob> printJobs = null;
        List<PrintJobInfo> printJobInfos = mClient.getPrintJobInfos();
        if (printJobInfos != null) {
            final int printJobInfoCount = printJobInfos.size();
            printJobs = new ArrayList<PrintJob>(printJobInfoCount);
            for (int i = 0; i < printJobInfoCount; i++) {
                printJobs.add(new PrintJob(printJobInfos.get(i), mClient));
            }
        }
        if (printJobs != null) {
            return printJobs;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error calling getPrintJobs()"", re);
    }
    return Collections.emptyList();
}","{
    throwIfNotCalledOnMainThread();
    if (mClient == null) {
        return Collections.emptyList();
    }
    try {
        List<PrintJob> printJobs = null;
        List<PrintJobInfo> printJobInfos = mClient.getPrintJobInfos();
        if (printJobInfos != null) {
            final int printJobInfoCount = printJobInfos.size();
            printJobs = new ArrayList<PrintJob>(printJobInfoCount);
            for (int i = 0; i < printJobInfoCount; i++) {
                printJobs.add(new PrintJob(this, printJobInfos.get(i), mClient));
            }
        }
        if (printJobs != null) {
            return printJobs;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error calling getPrintJobs()"", re);
    }
    return Collections.emptyList();
}",1,"/**
 * Gets the active print jobs for the printers managed by this service.
 * Active print jobs are ones that are not in a final state, i.e. whose
 * state is queued or started.
 *
 * @return The active print jobs.
 *
 * @see PrintJob#isQueued() PrintJob.isQueued()
 * @see PrintJob#isStarted() PrintJob.isStarted()
 */
","/**
 * Gets the active print jobs for the printers managed by this service.
 * Active print jobs are ones that are not in a final state, i.e. whose
 * state is queued or started.
 *
 * @return The active print jobs.
 *
 * @see PrintJob#isQueued() PrintJob.isQueued()
 * @see PrintJob#isStarted() PrintJob.isStarted()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The constructor used for creating PrintJob instances has changed; it now takes 'this' as the first argument. So, the code change includes both a change in the constructor call which is an 'Other statement changed' (change type 4) and a 'Dependent API changed' since it's now calling a different constructor signature (change type 5).","Although the constructor for PrintJob has changed, this is within the internal implementation and does not affect the return type of the method. It still returns a List<PrintJob> and handles exceptions in the same way. The change does not directly lead to a potential different behavior observable from outside the method - the list of active print jobs returned should still represent the same set of jobs, just potentially constructed differently internally. Therefore, there is no Compatibility Issue according to the definitions provided (change types 1 and 2)."
200,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",23,24,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>","<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",0,"{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 * {@link BluetoothProfile#GATT} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 * {@link BluetoothProfile#GATT} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The late version has an additional 'if' branch for the new profile type `BluetoothProfile.PBAP_CLIENT`, so the code change type is 3 since there's a change in the control dependency.","There is no compatibility issue because the change is an extension that adds support for a new Bluetooth profile. The change does not affect the behavior of the existing profiles, and it will only return true for the new profile type that did not exist in the early version. Existing clients calling this method for previously supported profiles will experience no change in behavior."
201,<android.app.admin.DeviceAdminInfo: ComponentName getComponent()>,23,24,<android.app.admin.DeviceAdminInfo: ComponentName getComponent()>,<android.app.admin.DeviceAdminInfo: ComponentName getComponent()>,0,"{
    return new ComponentName(mReceiver.activityInfo.packageName, mReceiver.activityInfo.name);
}","{
    return new ComponentName(mActivityInfo.packageName, mActivityInfo.name);
}",1,"/**
 * Return the component of the receiver that implements this device admin.
 */
","/**
 * Return the component of the receiver that implements this device admin.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The change from referring mReceiver.activityInfo to mActivityInfo. While the change did alter the code, it does not indicate a behavior change within the method itself as it is simply a refactor to use a direct reference versus a nested reference. This qualifies as the change type 4. The late version has an additional annotation [@NonNull], which suggests the return value is guaranteed to be non-null, but this annotation does not affect the existing method's behavior, so it is counted as dependent API changed, identified as the change type 5.","There is no compatibility issue identified here because the method's behavior is to return a ComponentName object based on certain fields (packageName and name). The fields are still accessed, and there's no indication the fields themselves have changed. So there is no compatibility issue caused by potentially different return values or exceptions, hence the CI type is 0."
203,<android.ddm.DdmHandleViewDebug: Chunk handleChunk(Chunk)>,23,24,<android.ddm.DdmHandleViewDebug: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleViewDebug: Chunk handleChunk(Chunk)>,0,"{
    int type = request.type;
    if (type == CHUNK_VUGL) {
        return handleOpenGlTrace(request);
    } else if (type == CHUNK_VULW) {
        return listWindows();
    }
    ByteBuffer in = wrapChunk(request);
    int op = in.getInt();
    View rootView = getRootView(in);
    if (rootView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid View Root"");
    }
    if (type == CHUNK_VURT) {
        if (op == VURT_DUMP_HIERARCHY)
            return dumpHierarchy(rootView, in);
        else if (op == VURT_CAPTURE_LAYERS)
            return captureLayers(rootView);
        else if (op == VURT_DUMP_THEME)
            return dumpTheme(rootView);
        else
            return createFailChunk(ERR_INVALID_OP, ""Unknown view root operation: "" + op);
    }
    final View targetView = getTargetView(rootView, in);
    if (targetView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid target view"");
    }
    if (type == CHUNK_VUOP) {
        switch(op) {
            case VUOP_CAPTURE_VIEW:
                return captureView(rootView, targetView);
            case VUOP_DUMP_DISPLAYLIST:
                return dumpDisplayLists(rootView, targetView);
            case VUOP_PROFILE_VIEW:
                return profileView(rootView, targetView);
            case VUOP_INVOKE_VIEW_METHOD:
                return invokeViewMethod(rootView, targetView, in);
            case VUOP_SET_LAYOUT_PARAMETER:
                return setLayoutParameter(rootView, targetView, in);
            default:
                return createFailChunk(ERR_INVALID_OP, ""Unknown view operation: "" + op);
        }
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    int type = request.type;
    if (type == CHUNK_VULW) {
        return listWindows();
    }
    ByteBuffer in = wrapChunk(request);
    int op = in.getInt();
    View rootView = getRootView(in);
    if (rootView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid View Root"");
    }
    if (type == CHUNK_VURT) {
        if (op == VURT_DUMP_HIERARCHY)
            return dumpHierarchy(rootView, in);
        else if (op == VURT_CAPTURE_LAYERS)
            return captureLayers(rootView);
        else if (op == VURT_DUMP_THEME)
            return dumpTheme(rootView);
        else
            return createFailChunk(ERR_INVALID_OP, ""Unknown view root operation: "" + op);
    }
    final View targetView = getTargetView(rootView, in);
    if (targetView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid target view"");
    }
    if (type == CHUNK_VUOP) {
        switch(op) {
            case VUOP_CAPTURE_VIEW:
                return captureView(rootView, targetView);
            case VUOP_DUMP_DISPLAYLIST:
                return dumpDisplayLists(rootView, targetView);
            case VUOP_PROFILE_VIEW:
                return profileView(rootView, targetView);
            case VUOP_INVOKE_VIEW_METHOD:
                return invokeViewMethod(rootView, targetView, in);
            case VUOP_SET_LAYOUT_PARAMETER:
                return setLayoutParameter(rootView, targetView, in);
            default:
                return createFailChunk(ERR_INVALID_OP, ""Unknown view operation: "" + op);
        }
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The control structure changed because the condition handling CHUNK_VUGL is removed in the late version. Additionally, there is no other statement inside the early implementation that refers to 'CHUNK_VUGL' or 'handleOpenGlTrace', hence indicating a part of the functionality has been removed. This corresponds to a change in the return statement as well as other statement changes, so the code change type is 1,4.","Since the condition handling CHUNK_VUGL is removed, this API would no longer handle a case that it previously did, which would have called handleOpenGlTrace(request) in the early version. This could potentially lead to a 'Runtime Exception' being thrown in the late version when CHUNK_VUGL is provided while it was properly handled in the early version. Hence, this change could cause the API to return a different value or behave differently, so the CI type is 1."
204,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",23,24,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>","<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    try {
        mService.setAuthToken(account, authTokenType, authToken);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    try {
        mService.setAuthToken(account, authTokenType, authToken);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */
","/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,The exception handling statement for RemoteException has changed from throwing a new RuntimeException in the early version to throwing e.rethrowFromSystemServer() in the late version. The change type is 2.,"There's a Compatibility Issue due to the exception handling change. In the early version, a RuntimeException would have been thrown in case of a RemoteException, while in the late version, the RemoteException is wrapped into a RuntimeException and thrown, which could lead to different behavior for the caller. Therefore, the CI type is 2."
208,<android.os.PersistableBundle: String toString()>,23,24,<android.os.PersistableBundle: String toString()>,<android.os.PersistableBundle: String toString()>,0,"{
    if (mParcelledData != null) {
        if (mParcelledData == EMPTY_PARCEL) {
            return ""PersistableBundle[EMPTY_PARCEL]"";
        } else {
            return ""PersistableBundle[mParcelledData.dataSize="" + mParcelledData.dataSize() + ""]"";
        }
    }
    return ""PersistableBundle["" + mMap.toString() + ""]"";
}","{
    if (mParcelledData != null) {
        if (isEmptyParcel()) {
            return ""PersistableBundle[EMPTY_PARCEL]"";
        } else {
            return ""PersistableBundle[mParcelledData.dataSize="" + mParcelledData.dataSize() + ""]"";
        }
    }
    return ""PersistableBundle["" + mMap.toString() + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The conditional expression related to checking emptiness of the parcel has been changed to calling a new method isEmptyParcel(), whereas previously it was directly comparing with EMPTY_PARCEL. This is identified as a change in the code that doesn't directly affect control flow (as the logic remains the same assuming isEmptyParcel() correctly encapsulates the previous direct comparison), thus it falls under type 4 (Other statement changed). Since isEmptyParcel() is a new method that is being called, it is also classified as type 5 (Dependent API changed).","Despite the introduction of a new method isEmptyParcel(), the logical flow and the return values of the method have not changed given that isEmptyParcel() is expected to be a direct encapsulation of the original comparison logic. Thus, no Compatibility Issue is detected, so the CI type is 0."
209,<android.widget.DatePickerCalendarDelegate: void setMinDate(long)>,23,24,<android.widget.DatePickerCalendarDelegate: void setMinDate(long)>,<android.widget.DatePickerCalendarDelegate: void setMinDate(long)>,0,"{
    mTempDate.setTimeInMillis(minDate);
    if (mTempDate.get(Calendar.YEAR) == mMinDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMinDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    if (mCurrentDate.before(mTempDate)) {
        mCurrentDate.setTimeInMillis(minDate);
        onDateChanged(false, true);
    }
    mMinDate.setTimeInMillis(minDate);
    mDayPickerView.setMinDate(minDate);
    mYearPickerView.setRange(mMinDate, mMaxDate);
}","{
    mTempDate.setTimeInMillis(minDate);
    if (mTempDate.get(Calendar.YEAR) == mMinDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) == mMinDate.get(Calendar.DAY_OF_YEAR)) {
        // Same day, no-op.
        return;
    }
    if (mCurrentDate.before(mTempDate)) {
        mCurrentDate.setTimeInMillis(minDate);
        onDateChanged(false, true);
    }
    mMinDate.setTimeInMillis(minDate);
    mDayPickerView.setMinDate(minDate);
    mYearPickerView.setRange(mMinDate, mMaxDate);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The condition in the if statement has changed from checking for inequality to checking for equality regarding the DAY_OF_YEAR, but the return path remains unchanged. So, the code change type is 3.",There are no Compatibility Issues introduced because the change in the if condition inversion does not affect the method's execution flow in a way that would lead to different behavior. The method will still return early if the day of the year is the same as the minimum date's day of the year. This is merely a clarification of the existing logic.
210,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,23,24,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,0,"{
    try {
        close();
    } catch (CameraRuntimeException e) {
        Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage());
    } finally {
        super.finalize();
    }
}","{
    try {
        close();
    } catch (ServiceSpecificException e) {
        Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage());
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,5",2,"The exception type caught in the catch block has been changed from CameraRuntimeException to ServiceSpecificException, which implies a change to the exception handling statement. There might be a change in the dependent API as well since the exception type was modified which could be a part of another API's signature change, so the code change type is 2,5.","The change in the exception type caught implies that the method might now throw different exceptions under certain conditions, or handle the same exception differently, hence there could be a Compatibility Issue of type 2 caused by potential different exception handlings."
211,<android.net.ConnectivityManager: NetworkInfo getNetworkInfo(int)>,23,24,<android.net.ConnectivityManager: NetworkInfo getNetworkInfo(int)>,<android.net.ConnectivityManager: NetworkInfo getNetworkInfo(int)>,0,"{
    try {
        return mService.getNetworkInfo(networkType);
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return mService.getNetworkInfo(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns connection status information about a particular
 * network type.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param networkType integer specifying which networkType in
 * which you're interested.
 * @return a {@link NetworkInfo} object for the requested
 * network type or {@code null} if the type is not
 * supported by the device.
 *
 * @deprecated This method does not support multiple connected networks
 * of the same type. Use {@link #getAllNetworks} and
 * {@link #getNetworkInfo(android.net.Network)} instead.
 */
","/**
 * Returns connection status information about a particular
 * network type.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param networkType integer specifying which networkType in
 * which you're interested.
 * @return a {@link NetworkInfo} object for the requested
 * network type or {@code null} if the type is not
 * supported by the device.
 *
 * @deprecated This method does not support multiple connected networks
 * of the same type. Use {@link #getAllNetworks} and
 * {@link #getNetworkInfo(android.net.Network)} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The catch block changed from returning null to throwing a runtime exception (e.rethrowFromSystemServer()), so the change type is 2.","This change leads to a different exception handling where previously a null was returned but now an exception is thrown. Hence, the CI type is 2."
212,<android.content.res.Resources: TypedArray obtainTypedArray(int)>,23,24,<android.content.res.Resources: TypedArray obtainTypedArray(int)>,<android.content.res.Resources: TypedArray obtainTypedArray(int)>,0,"{
    int len = mAssets.getArraySize(id);
    if (len < 0) {
        throw new NotFoundException(""Array resource ID #0x"" + Integer.toHexString(id));
    }
    TypedArray array = TypedArray.obtain(this, len);
    array.mLength = mAssets.retrieveArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}","{
    final ResourcesImpl impl = mResourcesImpl;
    int len = impl.getAssets().getArraySize(id);
    if (len < 0) {
        throw new NotFoundException(""Array resource ID #0x"" + Integer.toHexString(id));
    }
    TypedArray array = TypedArray.obtain(this, len);
    array.mLength = impl.getAssets().retrieveArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}",1,"/**
 * Return an array of heterogeneous values.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the array values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 */
","/**
 * Return an array of heterogeneous values.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the array values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The object on which getArraySize and retrieveArray are invoked has changed from mAssets to impl.getAssets(). Additionally, the use of a local variable (ResourcesImpl impl) and method chaining (impl.getAssets()) instead of direct field access (mAssets) has been introduced, which corresponds to other statement changes (code change type 4). The dependent API getArraySize and retrieveArray may have been changed as well, indicated by the shift from mAssets to impl.getAssets(), implying a dependent API change (code change type 5).","There are no changes that would affect the behavior of the method in a way that would cause a Compatibility Issue. The implementation logically still performs the same operations and would result in the same outcomes, assuming the underlying implementation of the dependent API (getArraySize and retrieveArray) has not changed in behavior. Thus, no Compatibility Issue is detected (CI type 0)."
214,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String,CancellationSignal)>",23,24,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String,CancellationSignal)>","<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String,CancellationSignal)>",0,"{
    if (mTables == null) {
        return null;
    }
    if (mStrict && selection != null && selection.length() > 0) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        String sqlForValidation = buildQuery(projectionIn, ""("" + selection + "")"", groupBy, having, sortOrder, limit);
        validateQuerySql(db, sqlForValidation, // will throw if query is invalid
        cancellationSignal);
    }
    String sql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Performing query: "" + sql);
    }
    return db.rawQueryWithFactory(mFactory, sql, selectionArgs, SQLiteDatabase.findEditTable(mTables), // will throw if query is invalid
    cancellationSignal);
}","{
    if (mTables == null) {
        return null;
    }
    if (mStrict && selection != null && selection.length() > 0) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        String sqlForValidation = buildQuery(projectionIn, ""("" + selection + "")"", groupBy, having, sortOrder, limit);
        // will throw if query is invalid
        db.validateSql(sqlForValidation, cancellationSignal);
    }
    String sql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Performing query: "" + sql);
    }
    return db.rawQueryWithFactory(mFactory, sql, selectionArgs, SQLiteDatabase.findEditTable(mTables), // will throw if query is invalid
    cancellationSignal);
}",1,"/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
","/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early implementation calls `validateQuerySql(db, sqlForValidation, cancellationSignal)` for query validation, which is changed in the late implementation to `db.validateSql(sqlForValidation, cancellationSignal)`. The call within the API to validate the SQL query has changed resulting in a Dependent API changed (5). This is an Other statement changed (4) because it involves a different method call even if it is likely serving a similar purpose. ","The change in the validation method does not necessarily lead to a Compatibility Issue since it should not alter the behavior of the `query` API in a way that could cause it to return a different result or throw different exceptions given the same inputs. Assuming the new `validateSql` method is designed to perform the same check as the previous one, the behavior will remain consistent from the perspective of an API consumer. Thus, no Compatibility Issue is detected."
216,<android.content.pm.PackageInstaller.Session: void abandon()>,23,24,<android.content.pm.PackageInstaller.Session: void abandon()>,<android.content.pm.PackageInstaller.Session: void abandon()>,0,"{
    try {
        mSession.abandon();
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        mSession.abandon();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Completely abandon this session, destroying all staged data and
 * rendering it invalid. Abandoned sessions will be reported to
 * {@link SessionCallback} listeners as failures. This is equivalent to
 * opening the session and calling {@link Session#abandon()}.
 */
","/**
 * Completely abandon this session, destroying all staged data and
 * rendering it invalid. Abandoned sessions will be reported to
 * {@link SessionCallback} listeners as failures. This is equivalent to
 * opening the session and calling {@link Session#abandon()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from rethrowAsRuntimeException to rethrowFromSystemServer, which may change the type of exception thrown to the caller, so the code change type is 2.","The change in exception handling can potentially lead to a different type of exception throwing behavior when the late version of the API is invoked. Therefore, the CI type is 2."
218,<android.preference.PreferenceManager: SharedPreferences getSharedPreferences()>,23,24,<android.preference.PreferenceManager: SharedPreferences getSharedPreferences()>,<android.preference.PreferenceManager: SharedPreferences getSharedPreferences()>,0,"{
    if (mSharedPreferences == null) {
        mSharedPreferences = mContext.getSharedPreferences(mSharedPreferencesName, mSharedPreferencesMode);
    }
    return mSharedPreferences;
}","{
    if (mSharedPreferences == null) {
        final Context storageContext;
        switch(mStorage) {
            case STORAGE_DEVICE_PROTECTED:
                storageContext = mContext.createDeviceProtectedStorageContext();
                break;
            case STORAGE_CREDENTIAL_PROTECTED:
                storageContext = mContext.createCredentialProtectedStorageContext();
                break;
            default:
                storageContext = mContext;
                break;
        }
        mSharedPreferences = storageContext.getSharedPreferences(mSharedPreferencesName, mSharedPreferencesMode);
    }
    return mSharedPreferences;
}",1,"/**
 * Gets a SharedPreferences instance that preferences managed by this will
 * use.
 *
 * @return A SharedPreferences instance pointing to the file that contains
 * the values of preferences that are managed by this.
 */
","/**
 * Gets a SharedPreferences instance that preferences managed by this will
 * use.
 *
 * @return A SharedPreferences instance pointing to the file that contains
 * the values of preferences that are managed by this.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The implementation has included a new control flow construct 'switch' that changes the context in which the SharedPreferences are retrieved based on the value of mStorage. Additionally, the statements within this switch have been introduced. This results in a change type of 3,4.","Due to the newly introduced control flow and conditions, the context from which the SharedPreferences are retrieved may differ between versions, which could lead to the method returning a different SharedPreferences instance. This constitutes a potential Compatibility Issue caused by the API potentially returning different values, so the CI type is 1."
219,"<android.text.SpannableStringInternal: T[] getSpans(int,int,Class<T>)>",23,24,"<android.text.SpannableStringInternal: T[] getSpans(int,int,Class<T>)>","<android.text.SpannableStringInternal: T[] getSpans(int,int,Class<T>)>",0,"{
    int count = 0;
    int spanCount = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    Object[] ret = null;
    Object ret1 = null;
    for (int i = 0; i < spanCount; i++) {
        int spanStart = data[i * COLUMNS + START];
        int spanEnd = data[i * COLUMNS + END];
        if (spanStart > queryEnd) {
            continue;
        }
        if (spanEnd < queryStart) {
            continue;
        }
        if (spanStart != spanEnd && queryStart != queryEnd) {
            if (spanStart == queryEnd) {
                continue;
            }
            if (spanEnd == queryStart) {
                continue;
            }
        }
        // verify span class as late as possible, since it is expensive
        if (kind != null && !kind.isInstance(spans[i])) {
            continue;
        }
        if (count == 0) {
            ret1 = spans[i];
            count++;
        } else {
            if (count == 1) {
                ret = (Object[]) Array.newInstance(kind, spanCount - i + 1);
                ret[0] = ret1;
            }
            int prio = data[i * COLUMNS + FLAGS] & Spanned.SPAN_PRIORITY;
            if (prio != 0) {
                int j;
                for (j = 0; j < count; j++) {
                    int p = getSpanFlags(ret[j]) & Spanned.SPAN_PRIORITY;
                    if (prio > p) {
                        break;
                    }
                }
                System.arraycopy(ret, j, ret, j + 1, count - j);
                ret[j] = spans[i];
                count++;
            } else {
                ret[count++] = spans[i];
            }
        }
    }
    if (count == 0) {
        return (T[]) ArrayUtils.emptyArray(kind);
    }
    if (count == 1) {
        ret = (Object[]) Array.newInstance(kind, 1);
        ret[0] = ret1;
        return (T[]) ret;
    }
    if (count == ret.length) {
        return (T[]) ret;
    }
    Object[] nret = (Object[]) Array.newInstance(kind, count);
    System.arraycopy(ret, 0, nret, 0, count);
    return (T[]) nret;
}","{
    int count = 0;
    int spanCount = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    Object[] ret = null;
    Object ret1 = null;
    for (int i = 0; i < spanCount; i++) {
        int spanStart = data[i * COLUMNS + START];
        int spanEnd = data[i * COLUMNS + END];
        if (spanStart > queryEnd) {
            continue;
        }
        if (spanEnd < queryStart) {
            continue;
        }
        if (spanStart != spanEnd && queryStart != queryEnd) {
            if (spanStart == queryEnd) {
                continue;
            }
            if (spanEnd == queryStart) {
                continue;
            }
        }
        // verify span class as late as possible, since it is expensive
        if (kind != null && kind != Object.class && !kind.isInstance(spans[i])) {
            continue;
        }
        if (count == 0) {
            ret1 = spans[i];
            count++;
        } else {
            if (count == 1) {
                ret = (Object[]) Array.newInstance(kind, spanCount - i + 1);
                ret[0] = ret1;
            }
            int prio = data[i * COLUMNS + FLAGS] & Spanned.SPAN_PRIORITY;
            if (prio != 0) {
                int j;
                for (j = 0; j < count; j++) {
                    int p = getSpanFlags(ret[j]) & Spanned.SPAN_PRIORITY;
                    if (prio > p) {
                        break;
                    }
                }
                System.arraycopy(ret, j, ret, j + 1, count - j);
                ret[j] = spans[i];
                count++;
            } else {
                ret[count++] = spans[i];
            }
        }
    }
    if (count == 0) {
        return (T[]) ArrayUtils.emptyArray(kind);
    }
    if (count == 1) {
        ret = (Object[]) Array.newInstance(kind, 1);
        ret[0] = ret1;
        return (T[]) ret;
    }
    if (count == ret.length) {
        return (T[]) ret;
    }
    Object[] nret = (Object[]) Array.newInstance(kind, count);
    System.arraycopy(ret, 0, nret, 0, count);
    return (T[]) nret;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
221,<android.print.PrintJob: boolean equals(Object)>,23,24,<android.print.PrintJob: boolean equals(Object)>,<android.print.PrintJob: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrintJob other = (PrintJob) obj;
    return mCachedInfo.getId().equals(other.mCachedInfo.getId());
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrintJob other = (PrintJob) obj;
    return Objects.equals(mCachedInfo.getId(), other.mCachedInfo.getId());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation change is in the last line, where the equality check `mCachedInfo.getId().equals(other.mCachedInfo.getId())` is replaced with `Objects.equals(mCachedInfo.getId(), other.mCachedInfo.getId())`. This is a change in how the check is performed but does not alter the semantics of equality check. Therefore, it falls under the category of other statement changed.","No Compatibility Issue should arise from this change as the `Objects.equals` method is designed to handle nulls safely and will return the same boolean result as the `equals` method when used with non-null operands. Thus, the behavior of the `equals` method remains the same."
222,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",23,24,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>","<android.view.View: boolean draw(Canvas,ViewGroup,long)>",0,"{
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
    boolean drawingWithRenderNode = mAttachInfo != null && mAttachInfo.mHardwareAccelerated && hardwareAcceleratedCanvas;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;
    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    // TODO: signify cache state with just 'cache' local
    int layerType = getLayerType();
    if (layerType == LAYER_TYPE_SOFTWARE || (!drawingWithRenderNode && layerType != LAYER_TYPE_NONE)) {
        // If not drawing with RenderNode, treat HW layers as SW
        layerType = LAYER_TYPE_SOFTWARE;
        buildDrawingCache(true);
        cache = getDrawingCache(true);
    }
    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;
    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            mLayerPaint.setAlpha(layerPaintAlpha);
        }
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
    boolean drawingWithRenderNode = mAttachInfo != null && mAttachInfo.mHardwareAccelerated && hardwareAcceleratedCanvas;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;
    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    // TODO: signify cache state with just 'cache' local
    int layerType = getLayerType();
    if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
        if (layerType != LAYER_TYPE_NONE) {
            // If not drawing with RenderNode, treat HW layers as SW
            layerType = LAYER_TYPE_SOFTWARE;
            buildDrawingCache(true);
        }
        cache = getDrawingCache(true);
    }
    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;
    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            if (alpha < 1) {
                mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            }
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            if (alpha < 1) {
                mLayerPaint.setAlpha(layerPaintAlpha);
            }
        }
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 *
 * This is where the View specializes rendering behavior based on layer type,
 * and hardware acceleration.
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 *
 * This is where the View specializes rendering behavior based on layer type,
 * and hardware acceleration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
223,<android.widget.TextView: Parcelable onSaveInstanceState()>,23,24,<android.widget.TextView: Parcelable onSaveInstanceState()>,<android.widget.TextView: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            Spannable sp = new SpannableStringBuilder(mText);
            if (mEditor != null) {
                removeMisspelledSpans(sp);
                sp.removeSpan(mEditor.mSuggestionRangeSpan);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = getError();
        if (mEditor != null) {
            ss.editorState = mEditor.saveInstanceState();
        }
        return ss;
    }
    return superState;
}","{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    final boolean freezesText = getFreezesText();
    boolean hasSelection = false;
    int start = -1;
    int end = -1;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            hasSelection = true;
        }
    }
    if (freezesText || hasSelection) {
        SavedState ss = new SavedState(superState);
        if (freezesText) {
            if (mText instanceof Spanned) {
                final Spannable sp = new SpannableStringBuilder(mText);
                if (mEditor != null) {
                    removeMisspelledSpans(sp);
                    sp.removeSpan(mEditor.mSuggestionRangeSpan);
                }
                ss.text = sp;
            } else {
                ss.text = mText.toString();
            }
        }
        if (hasSelection) {
            // XXX Should also save the current scroll position!
            ss.selStart = start;
            ss.selEnd = end;
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = getError();
        if (mEditor != null) {
            ss.editorState = mEditor.saveInstanceState();
        }
        return ss;
    }
    return superState;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The code has undergone several changes including variable renaming, change in control logic dependency, and the structure of conditions and code under those conditions, so the change types are 1,3,4.","The refactored control logic alters when the `SavedState ss` object's fields are populated and what data is saved. The variable `hasSelection` and `freezesText` changes could lead to different `SavedState` object states being created, particularly in the text and selection fields, so there might be a different return value. Therefore, the CI type is 1."
224,"<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String)>",23,24,"<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String)>","<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String)>",0,"{
    return addLinks(text, pattern, scheme, null, null);
}","{
    return addLinks(text, pattern, scheme, null, null, null);
}",1,"/**
 * Applies a regex to a Spannable turning the matches into
 * links.
 *
 * @param text         Spannable whose text is to be marked-up with
 * links
 * @param pattern      Regex pattern to be used for finding links
 * @param scheme       Url scheme string (eg <code>http://</code> to be
 * prepended to the url of links that do not have
 * a scheme specified in the link text
 */
","/**
 * Applies a regex to a Spannable turning the matches into
 * links.
 *
 * @param text         Spannable whose text is to be marked-up with links
 * @param pattern      Regex pattern to be used for finding links
 * @param scheme       URL scheme string (eg <code>http://</code>) to be
 * prepended to the links that do not start with this scheme.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The early version API implementation calls addLinks with 4 parameters, while the late version calls a version with 5 parameters. This indicates a change in the dependent API, so the code change type is 5.",There is no Compatibility Issue since the method is still returning the same value from an overloaded version of the dependent API method addLinks. The difference in the number of parameters does not affect the operation of the current API method.
226,"<android.util.ArrayMap: V put(K,V)>",23,24,"<android.util.ArrayMap: V put(K,V)>","<android.util.ArrayMap: V put(K,V)>",0,"{
    final int hash;
    int index;
    if (key == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = key.hashCode();
        index = indexOf(key, hash);
    }
    if (index >= 0) {
        index = (index << 1) + 1;
        final V old = (V) mArray[index];
        mArray[index] = value;
        return old;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""put: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""put: copy 0-"" + mSize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG)
            Log.d(TAG, ""put: move "" + index + ""-"" + (mSize - index) + "" to "" + (index + 1));
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index << 1, mArray, (index + 1) << 1, (mSize - index) << 1);
    }
    mHashes[index] = hash;
    mArray[index << 1] = key;
    mArray[(index << 1) + 1] = value;
    mSize++;
    return null;
}","{
    final int hash;
    int index;
    if (key == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();
        index = indexOf(key, hash);
    }
    if (index >= 0) {
        index = (index << 1) + 1;
        final V old = (V) mArray[index];
        mArray[index] = value;
        return old;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""put: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""put: copy 0-"" + mSize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG)
            Log.d(TAG, ""put: move "" + index + ""-"" + (mSize - index) + "" to "" + (index + 1));
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index << 1, mArray, (index + 1) << 1, (mSize - index) << 1);
    }
    mHashes[index] = hash;
    mArray[index << 1] = key;
    mArray[(index << 1) + 1] = value;
    mSize++;
    return null;
}",1,"/**
 * Add a new value to the array map.
 * @param key The key under which to store the value.  If
 * this key already exists in the array, its value will be replaced.
 * @param value The value to store for the given key.
 * @return Returns the old value that was stored for the given key, or null if there
 * was no such key.
 */
","/**
 * Add a new value to the array map.
 * @param key The key under which to store the value.  If
 * this key already exists in the array, its value will be replaced.
 * @param value The value to store for the given key.
 * @return Returns the old value that was stored for the given key, or null if there
 * was no such key.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change in the implementation is the introduction of a condition to determine the hashing method for the key (using System.identityHashCode(key) if mIdentityHashCode is true, otherwise using key.hashCode()). The rest of the code has no changes. Therefore, the change type is 4 (Other statement changed).","Since the method's return behavior remains intact for the existing contract of the method (it returns the previous value associated with the key, or null if there was no mapping for the key), and given that the adjustment is strictly an internal change tied to a decision on hashing, this change does not directly lead to a different return variable type or value from the method's perspective. It also does not lead to a change in exceptions thrown. Hence, there is no Compatibility Issue; CI type is 0."
230,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",23,24,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean readOnly;
                readOnly = data.readInt() != 0;
                int resultCode = mountSecureContainer(id, key, ownerUid, readOnly);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = encryptStorage(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = changeEncryptionPassword(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                int uid = data.readInt();
                String packageName = data.readString();
                int _flags = data.readInt();
                StorageVolume[] result = getVolumeList(uid, packageName, _flags);
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mkdirs:
            {
                data.enforceInterface(DESCRIPTOR);
                String callingPkg = data.readString();
                String path = data.readString();
                int result = mkdirs(callingPkg, path);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPasswordType:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getPasswordType();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String result = getPassword();
                reply.writeNoException();
                reply.writeString(result);
                return true;
            }
        case TRANSACTION_clearPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                clearPassword();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = data.readString();
                setField(field, contents);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = getField(field);
                reply.writeNoException();
                reply.writeString(contents);
                return true;
            }
        case TRANSACTION_resizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String key;
                key = data.readString();
                int resultCode = resizeSecureContainer(id, sizeMb, key);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_lastMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                long lastMaintenance = lastMaintenance();
                reply.writeNoException();
                reply.writeLong(lastMaintenance);
                return true;
            }
        case TRANSACTION_runMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                runMaintenance();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_waitForAsecScan:
            {
                data.enforceInterface(DESCRIPTOR);
                waitForAsecScan();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getDisks:
            {
                data.enforceInterface(DESCRIPTOR);
                DiskInfo[] disks = getDisks();
                reply.writeNoException();
                reply.writeTypedArray(disks, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getVolumes:
            {
                data.enforceInterface(DESCRIPTOR);
                int _flags = data.readInt();
                VolumeInfo[] volumes = getVolumes(_flags);
                reply.writeNoException();
                reply.writeTypedArray(volumes, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getVolumeRecords:
            {
                data.enforceInterface(DESCRIPTOR);
                int _flags = data.readInt();
                VolumeRecord[] volumes = getVolumeRecords(_flags);
                reply.writeNoException();
                reply.writeTypedArray(volumes, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_mount:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                mount(volId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmount:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                unmount(volId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_format:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                format(volId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_benchmark:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                long res = benchmark(volId);
                reply.writeNoException();
                reply.writeLong(res);
                return true;
            }
        case TRANSACTION_partitionPublic:
            {
                data.enforceInterface(DESCRIPTOR);
                String diskId = data.readString();
                partitionPublic(diskId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_partitionPrivate:
            {
                data.enforceInterface(DESCRIPTOR);
                String diskId = data.readString();
                partitionPrivate(diskId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_partitionMixed:
            {
                data.enforceInterface(DESCRIPTOR);
                String diskId = data.readString();
                int ratio = data.readInt();
                partitionMixed(diskId, ratio);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setVolumeNickname:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                String nickname = data.readString();
                setVolumeNickname(volId, nickname);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setVolumeUserFlags:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                int _flags = data.readInt();
                int _mask = data.readInt();
                setVolumeUserFlags(volId, _flags, _mask);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_forgetVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String fsUuid = data.readString();
                forgetVolume(fsUuid);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_forgetAllVolumes:
            {
                data.enforceInterface(DESCRIPTOR);
                forgetAllVolumes();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setDebugFlags:
            {
                data.enforceInterface(DESCRIPTOR);
                int _flags = data.readInt();
                int _mask = data.readInt();
                setDebugFlags(_flags, _mask);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getPrimaryStorageUuid:
            {
                data.enforceInterface(DESCRIPTOR);
                String volumeUuid = getPrimaryStorageUuid();
                reply.writeNoException();
                reply.writeString(volumeUuid);
                return true;
            }
        case TRANSACTION_setPrimaryStorageUuid:
            {
                data.enforceInterface(DESCRIPTOR);
                String volumeUuid = data.readString();
                IPackageMoveObserver listener = IPackageMoveObserver.Stub.asInterface(data.readStrongBinder());
                setPrimaryStorageUuid(volumeUuid, listener);
                reply.writeNoException();
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}","{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean readOnly;
                readOnly = data.readInt() != 0;
                int resultCode = mountSecureContainer(id, key, ownerUid, readOnly);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = encryptStorage(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = changeEncryptionPassword(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                int uid = data.readInt();
                String packageName = data.readString();
                int _flags = data.readInt();
                StorageVolume[] result = getVolumeList(uid, packageName, _flags);
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mkdirs:
            {
                data.enforceInterface(DESCRIPTOR);
                String callingPkg = data.readString();
                String path = data.readString();
                int result = mkdirs(callingPkg, path);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPasswordType:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getPasswordType();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String result = getPassword();
                reply.writeNoException();
                reply.writeString(result);
                return true;
            }
        case TRANSACTION_clearPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                clearPassword();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = data.readString();
                setField(field, contents);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = getField(field);
                reply.writeNoException();
                reply.writeString(contents);
                return true;
            }
        case TRANSACTION_isConvertibleToFBE:
            {
                data.enforceInterface(DESCRIPTOR);
                int resultCode = isConvertibleToFBE() ? 1 : 0;
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_resizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String key;
                key = data.readString();
                int resultCode = resizeSecureContainer(id, sizeMb, key);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_lastMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                long lastMaintenance = lastMaintenance();
                reply.writeNoException();
                reply.writeLong(lastMaintenance);
                return true;
            }
        case TRANSACTION_runMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                runMaintenance();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_waitForAsecScan:
            {
                data.enforceInterface(DESCRIPTOR);
                waitForAsecScan();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getDisks:
            {
                data.enforceInterface(DESCRIPTOR);
                DiskInfo[] disks = getDisks();
                reply.writeNoException();
                reply.writeTypedArray(disks, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getVolumes:
            {
                data.enforceInterface(DESCRIPTOR);
                int _flags = data.readInt();
                VolumeInfo[] volumes = getVolumes(_flags);
                reply.writeNoException();
                reply.writeTypedArray(volumes, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getVolumeRecords:
            {
                data.enforceInterface(DESCRIPTOR);
                int _flags = data.readInt();
                VolumeRecord[] volumes = getVolumeRecords(_flags);
                reply.writeNoException();
                reply.writeTypedArray(volumes, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_mount:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                mount(volId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmount:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                unmount(volId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_format:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                format(volId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_benchmark:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                long res = benchmark(volId);
                reply.writeNoException();
                reply.writeLong(res);
                return true;
            }
        case TRANSACTION_partitionPublic:
            {
                data.enforceInterface(DESCRIPTOR);
                String diskId = data.readString();
                partitionPublic(diskId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_partitionPrivate:
            {
                data.enforceInterface(DESCRIPTOR);
                String diskId = data.readString();
                partitionPrivate(diskId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_partitionMixed:
            {
                data.enforceInterface(DESCRIPTOR);
                String diskId = data.readString();
                int ratio = data.readInt();
                partitionMixed(diskId, ratio);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setVolumeNickname:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                String nickname = data.readString();
                setVolumeNickname(volId, nickname);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setVolumeUserFlags:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                int _flags = data.readInt();
                int _mask = data.readInt();
                setVolumeUserFlags(volId, _flags, _mask);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_forgetVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String fsUuid = data.readString();
                forgetVolume(fsUuid);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_forgetAllVolumes:
            {
                data.enforceInterface(DESCRIPTOR);
                forgetAllVolumes();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setDebugFlags:
            {
                data.enforceInterface(DESCRIPTOR);
                int _flags = data.readInt();
                int _mask = data.readInt();
                setDebugFlags(_flags, _mask);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getPrimaryStorageUuid:
            {
                data.enforceInterface(DESCRIPTOR);
                String volumeUuid = getPrimaryStorageUuid();
                reply.writeNoException();
                reply.writeString(volumeUuid);
                return true;
            }
        case TRANSACTION_setPrimaryStorageUuid:
            {
                data.enforceInterface(DESCRIPTOR);
                String volumeUuid = data.readString();
                IPackageMoveObserver listener = IPackageMoveObserver.Stub.asInterface(data.readStrongBinder());
                setPrimaryStorageUuid(volumeUuid, listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_createUserKey:
            {
                data.enforceInterface(DESCRIPTOR);
                int userId = data.readInt();
                int serialNumber = data.readInt();
                boolean ephemeral = data.readInt() != 0;
                createUserKey(userId, serialNumber, ephemeral);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_destroyUserKey:
            {
                data.enforceInterface(DESCRIPTOR);
                int userId = data.readInt();
                destroyUserKey(userId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_addUserKeyAuth:
            {
                data.enforceInterface(DESCRIPTOR);
                int userId = data.readInt();
                int serialNumber = data.readInt();
                byte[] token = data.createByteArray();
                byte[] secret = data.createByteArray();
                addUserKeyAuth(userId, serialNumber, token, secret);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_fixateNewestUserKeyAuth:
            {
                data.enforceInterface(DESCRIPTOR);
                int userId = data.readInt();
                fixateNewestUserKeyAuth(userId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unlockUserKey:
            {
                data.enforceInterface(DESCRIPTOR);
                int userId = data.readInt();
                int serialNumber = data.readInt();
                byte[] token = data.createByteArray();
                byte[] secret = data.createByteArray();
                unlockUserKey(userId, serialNumber, token, secret);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_lockUserKey:
            {
                data.enforceInterface(DESCRIPTOR);
                int userId = data.readInt();
                lockUserKey(userId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUserKeyUnlocked:
            {
                data.enforceInterface(DESCRIPTOR);
                int userId = data.readInt();
                boolean result = isUserKeyUnlocked(userId);
                reply.writeNoException();
                reply.writeInt(result ? 1 : 0);
                return true;
            }
        case TRANSACTION_prepareUserStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String volumeUuid = data.readString();
                int userId = data.readInt();
                int serialNumber = data.readInt();
                int _flags = data.readInt();
                prepareUserStorage(volumeUuid, userId, serialNumber, _flags);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_destroyUserStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String volumeUuid = data.readString();
                int userId = data.readInt();
                int _flags = data.readInt();
                destroyUserStorage(volumeUuid, userId, _flags);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountAppFuse:
            {
                data.enforceInterface(DESCRIPTOR);
                String name = data.readString();
                ParcelFileDescriptor fd = mountAppFuse(name);
                reply.writeNoException();
                reply.writeParcelable(fd, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
232,"<android.content.pm.LauncherApps: void registerCallback(Callback,Handler)>",23,24,"<android.content.pm.LauncherApps: void registerCallback(Callback,Handler)>","<android.content.pm.LauncherApps: void registerCallback(Callback,Handler)>",0,"{
    synchronized (this) {
        if (callback != null && findCallbackLocked(callback) < 0) {
            boolean addedFirstCallback = mCallbacks.size() == 0;
            addCallbackLocked(callback, handler);
            if (addedFirstCallback) {
                try {
                    mService.addOnAppsChangedListener(mAppsChangedListener);
                } catch (RemoteException re) {
                }
            }
        }
    }
}","{
    synchronized (this) {
        if (callback != null && findCallbackLocked(callback) < 0) {
            boolean addedFirstCallback = mCallbacks.size() == 0;
            addCallbackLocked(callback, handler);
            if (addedFirstCallback) {
                try {
                    mService.addOnAppsChangedListener(mContext.getPackageName(), mAppsChangedListener);
                } catch (RemoteException re) {
                    throw re.rethrowFromSystemServer();
                }
            }
        }
    }
}",1,"/**
 * Registers a callback for changes to packages in current and managed profiles.
 *
 * @param callback The callback to register.
 * @param handler that should be used to post callbacks on, may be null.
 */
","/**
 * Registers a callback for changes to packages in current and managed profiles.
 *
 * @param callback The callback to register.
 * @param handler that should be used to post callbacks on, may be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The method mService.addOnAppsChangedListener has a changed signature by including an additional parameter in the late version. Exception handling also changed by adding a throw statement inside the catch block with rethrowFromSystemServer call, so the code change is multiple: 2 for the exception handling and 5 for the dependent API changed.","This change can potentially lead to compatibility issues due to the new exception being thrown, which was not the case in the early version. Now, consumers of this API may encounter an exception that wasn't present before, affecting the control flow of their applications. Therefore, the CI type is due to potential different exception handlings: 2."
233,<android.service.notification.StatusBarNotification: StatusBarNotification clone()>,23,24,<android.service.notification.StatusBarNotification: StatusBarNotification clone()>,<android.service.notification.StatusBarNotification: StatusBarNotification clone()>,0,"{
    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, this.score, this.notification.clone(), this.user, this.postTime);
}","{
    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, this.notification.clone(), this.user, this.overrideGroupKey, this.postTime);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor parameters of `StatusBarNotification` have been changed as one parameter `this.score` is removed and a new parameter `this.overrideGroupKey` is added to the `StatusBarNotification` constructor in the new version. The code change type is 1,5.","The signature of the constructor for `StatusBarNotification` has been altered, leading to a different instantiation of the `StatusBarNotification` object, which results in different return values. Thus, the CI type is 1."
234,<android.app.job.JobInfo.Builder: JobInfo build()>,23,24,<android.app.job.JobInfo.Builder: JobInfo build()>,<android.app.job.JobInfo.Builder: JobInfo build()>,0,"{
    // Allow jobs with no constraints - What am I, a database?
    if (!mHasEarlyConstraint && !mHasLateConstraint && !mRequiresCharging && !mRequiresDeviceIdle && mNetworkType == NETWORK_TYPE_NONE) {
        throw new IllegalArgumentException(""You're trying to build a job with no "" + ""constraints, this is not allowed."");
    }
    // Make our own copy.
    mExtras = new PersistableBundle(mExtras);
    // Check that a deadline was not set on a periodic job.
    if (mIsPeriodic && (mMaxExecutionDelayMillis != 0L)) {
        throw new IllegalArgumentException(""Can't call setOverrideDeadline() on a "" + ""periodic job."");
    }
    if (mIsPeriodic && (mMinLatencyMillis != 0L)) {
        throw new IllegalArgumentException(""Can't call setMinimumLatency() on a "" + ""periodic job"");
    }
    if (mBackoffPolicySet && mRequiresDeviceIdle) {
        throw new IllegalArgumentException(""An idle mode job will not respect any"" + "" back-off policy, so calling setBackoffCriteria with"" + "" setRequiresDeviceIdle is an error."");
    }
    return new JobInfo(this);
}","{
    // Allow jobs with no constraints - What am I, a database?
    if (!mHasEarlyConstraint && !mHasLateConstraint && !mRequiresCharging && !mRequiresDeviceIdle && mNetworkType == NETWORK_TYPE_NONE && mTriggerContentUris == null) {
        throw new IllegalArgumentException(""You're trying to build a job with no "" + ""constraints, this is not allowed."");
    }
    // Make our own copy.
    mExtras = new PersistableBundle(mExtras);
    // Check that a deadline was not set on a periodic job.
    if (mIsPeriodic && (mMaxExecutionDelayMillis != 0L)) {
        throw new IllegalArgumentException(""Can't call setOverrideDeadline() on a "" + ""periodic job."");
    }
    if (mIsPeriodic && (mMinLatencyMillis != 0L)) {
        throw new IllegalArgumentException(""Can't call setMinimumLatency() on a "" + ""periodic job"");
    }
    if (mIsPeriodic && (mTriggerContentUris != null)) {
        throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""periodic job"");
    }
    if (mIsPersisted && (mTriggerContentUris != null)) {
        throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""persisted job"");
    }
    if (mBackoffPolicySet && mRequiresDeviceIdle) {
        throw new IllegalArgumentException(""An idle mode job will not respect any"" + "" back-off policy, so calling setBackoffCriteria with"" + "" setRequiresDeviceIdle is an error."");
    }
    JobInfo job = new JobInfo(this);
    if (job.isPeriodic()) {
        if (job.intervalMillis != job.getIntervalMillis()) {
            StringBuilder builder = new StringBuilder();
            builder.append(""Specified interval for "").append(String.valueOf(mJobId)).append("" is "");
            formatDuration(mIntervalMillis, builder);
            builder.append("". Clamped to "");
            formatDuration(job.getIntervalMillis(), builder);
            Log.w(TAG, builder.toString());
        }
        if (job.flexMillis != job.getFlexMillis()) {
            StringBuilder builder = new StringBuilder();
            builder.append(""Specified flex for "").append(String.valueOf(mJobId)).append("" is "");
            formatDuration(mFlexMillis, builder);
            builder.append("". Clamped to "");
            formatDuration(job.getFlexMillis(), builder);
            Log.w(TAG, builder.toString());
        }
    }
    return job;
}",1,"/**
 * @return The job object to hand to the JobScheduler. This object is immutable.
 */
","/**
 * @return The job object to hand to the JobScheduler. This object is immutable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The exception handling statement has changed with the addition of new conditions and new exceptions being thrown, which indicates a change of type 2. There are changes in control dependency with additional checks for 'mIsPeriodic' and 'mIsPersisted', which is type 3. Moreover, there are other changes like assigning 'new JobInfo(this)' to a local variable 'job' and adding new log statements, which indicates a change of type 4.","There are potential Compatibility Issues due to different exception handlings (the addition of new exceptions that are thrown under certain conditions) which is type 2; and because of the possible different return values due to the new check conditions and the addition of warnings that affect the return value, which is type 1."
235,<android.net.ConnectivityManager: boolean requestBandwidthUpdate(Network)>,23,24,<android.net.ConnectivityManager: boolean requestBandwidthUpdate(Network)>,<android.net.ConnectivityManager: boolean requestBandwidthUpdate(Network)>,0,"{
    try {
        return mService.requestBandwidthUpdate(network);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return mService.requestBandwidthUpdate(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Requests bandwidth update for a given {@link Network} and returns whether the update request
 * is accepted by ConnectivityService. Once accepted, ConnectivityService will poll underlying
 * network connection for updated bandwidth information. The caller will be notified via
 * {@link ConnectivityManager.NetworkCallback} if there is an update. Notice that this
 * method assumes that the caller has previously called {@link #registerNetworkCallback} to
 * listen for network changes.
 *
 * @param network {@link Network} specifying which network you're interested.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 */
","/**
 * Requests bandwidth update for a given {@link Network} and returns whether the update request
 * is accepted by ConnectivityService. Once accepted, ConnectivityService will poll underlying
 * network connection for updated bandwidth information. The caller will be notified via
 * {@link ConnectivityManager.NetworkCallback} if there is an update. Notice that this
 * method assumes that the caller has previously called
 * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} to listen for network
 * changes.
 *
 * @param network {@link Network} specifying which network you're interested.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from returning 'false' to throwing 'e.rethrowFromSystemServer()', so the code change type is 2.","The change in exception handling could lead to different behavior when an exception occurs. Instead of returning 'false', the late version now throws an exception. Therefore, the CI type is 2."
237,<android.widget.TimePickerSpinnerDelegate: Parcelable onSaveInstanceState(Parcelable)>,23,24,<android.widget.TimePickerSpinnerDelegate: Parcelable onSaveInstanceState(Parcelable)>,<android.widget.TimePickerSpinnerDelegate: Parcelable onSaveInstanceState(Parcelable)>,0,"{
    return new SavedState(superState, getCurrentHour(), getCurrentMinute());
}","{
    return new SavedState(superState, getHour(), getMinute(), is24Hour());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed because the constructor for SavedState now takes additional parameters (is24Hour()), and the methods used to retrieve the hour and minute have also changed from getCurrentHour(), getCurrentMinute() to getHour(), getMinute(). This indicates both a return statement change and a change in the dependent API.","Since the implementation now includes an additional parameter (is24Hour()) and uses different methods to retrieve the hour and minute, the Parcelable returned by onSaveInstanceState in the later version has a different structure. This could potentially lead to compatibility issues due to the API returning a different type/value of Parcelable, so the CI type is 1."
239,"<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>",23,24,"<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>","<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>",0,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final String canonicalPath = new File(rawPath).getCanonicalPath();
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.mountObb(rawPath, canonicalPath, key, mObbActionListener, nonce);
        return true;
    } catch (IOException e) {
        throw new IllegalArgumentException(""Failed to resolve path: "" + rawPath, e);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to mount OBB"", e);
    }
    return false;
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final String canonicalPath = new File(rawPath).getCanonicalPath();
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.mountObb(rawPath, canonicalPath, key, mObbActionListener, nonce);
        return true;
    } catch (IOException e) {
        throw new IllegalArgumentException(""Failed to resolve path: "" + rawPath, e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
 * specified, it is supplied to the mounting process to be used in any
 * encryption used in the OBB.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param rawPath the path to the OBB file
 * @param key secret used to encrypt the OBB; may be <code>null</code> if no
 * encryption was used on the OBB.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
","/**
 * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
 * specified, it is supplied to the mounting process to be used in any
 * encryption used in the OBB.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param rawPath the path to the OBB file
 * @param key secret used to encrypt the OBB; may be <code>null</code> if no
 * encryption was used on the OBB.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"There is no alteration in the method's return statements, but there is a change in an exception handling statement, where a `Log.e` was replaced by a `throw e.rethrowFromSystemServer()`, so the code change type is 2.","The alteration in exception handling means that under the same conditions, where a RemoteException is caught, the early version logs the exception and returns false, while the late version will throw the exception instead. This difference indicates a potential Compatibility Issue of type 2 because the exception thrown is different between the two versions."
240,<android.net.LocalSocketImpl: void shutdownInput()>,23,24,<android.net.LocalSocketImpl: void shutdownInput()>,<android.net.LocalSocketImpl: void shutdownInput()>,0,"{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    shutdown(fd, true);
}","{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    try {
        Os.shutdown(fd, OsConstants.SHUT_RD);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Shuts down the input side of the socket.
 *
 * @throws IOException
 */
","/**
 * Shuts down the input side of the socket.
 *
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The method shutdown(fd, true) has been replaced by Os.shutdown(fd, OsConstants.SHUT_RD) within a try-catch block, and the catch block has been added for ErrnoException, which is converted to an IOException. Therefore, both an exception handling statement and a dependent API have changed, so the code change types are 2,5.","The changes can potentially lead to different exception handling (ErrnoException to IOException conversion) and also due to the method signature change (different dependent API usage), which can also affect the behavior of the method. Hence, the CI type is 1,2."
242,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,23,24,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,0,"{
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getProfileConnectionState(profile);
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""getProfileConnectionState:"", e);
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}","{
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getProfileConnectionState(profile);
    } catch (RemoteException e) {
        Log.e(TAG, ""getProfileConnectionState:"", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}",1,"/**
 * Get the current connection state of a profile.
 * This function can be used to check whether the local Bluetooth adapter
 * is connected to any remote device for a specific profile.
 * Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * <p> Return value can be one of
 * {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING},
 * {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING}
 */
","/**
 * Get the current connection state of a profile.
 * This function can be used to check whether the local Bluetooth adapter
 * is connected to any remote device for a specific profile.
 * Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * <p> Return value can be one of
 * {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING},
 * {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING}
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a change in how the service object is accessed: synchronized block has been replaced with a readLock lock and unlock in a try-finally construct, so the code change type is 3,4. While the logic of service access might be different, the functional behavior of the method has not changed: it still returns the connection state of the profile or `BluetoothProfile.STATE_DISCONNECTED`.","Even though the synchronization mechanism on `mService` access has changed, this does not constitute a change in behavior from the API user's perspective. As such, as long as 'mService' implements the method calls correctly, there is no change in the exception thrown or the return value under the provided method contract, so no compatibility issue is expected to arise from this change."
243,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,23,24,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,0,"{
    try {
        return ActivityManagerNative.getDefault().getTasks(maxNum, 0);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getTasks(maxNum, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still retu rn a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
","/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still retu rn a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, with the removal of a return statement that returned null and the introduction of a throw statement instead, so the change type is 2.","The change in how exceptions are handled, where previously a null was returned and now an exception is thrown, could lead to different behaviors when exceptions happen. Therefore, a Compatibility Issue of type 2 (different exception handling) could arise."
244,<android.content.RestrictionsManager: Bundle getApplicationRestrictions()>,23,24,<android.content.RestrictionsManager: Bundle getApplicationRestrictions()>,<android.content.RestrictionsManager: Bundle getApplicationRestrictions()>,0,"{
    try {
        if (mService != null) {
            return mService.getApplicationRestrictions(mContext.getPackageName());
        }
    } catch (RemoteException re) {
        Log.w(TAG, ""Couldn't reach service"");
    }
    return null;
}","{
    try {
        if (mService != null) {
            return mService.getApplicationRestrictions(mContext.getPackageName());
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    return null;
}",1,"/**
 * Returns any available set of application-specific restrictions applicable
 * to this application.
 * @return the application restrictions as a Bundle. Returns null if there
 * are no restrictions.
 */
","/**
 * Returns any available set of application-specific restrictions applicable
 * to this application.
 * @return the application restrictions as a Bundle. Returns null if there
 * are no restrictions.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from logging an error message to throwing an exception, which is a change in how exceptions are handled, so the code change type is 2.","As the new implementation throws an exception instead of logging an error message and continuing by returning `null`, the late version of this API could potentially throw a new type of exception. Hence, a Compatibility Issue is introduced due to the potential difference in exception handling, and the CI type is 2."
245,"<android.content.res.Resources: float getFraction(int,int,int)>",23,24,"<android.content.res.Resources: float getFraction(int,int,int)>","<android.content.res.Resources: float getFraction(int,int,int)>",0,"{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_FRACTION) {
            return TypedValue.complexToFraction(value.data, base, pbase);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        mResourcesImpl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_FRACTION) {
            return TypedValue.complexToFraction(value.data, base, pbase);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Retrieve a fractional unit for a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Retrieve a fractional unit for a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"In the late version, the method of obtaining the TypedValue object changed from using a local cache (`mTmpValue`) to calling new methods (`obtainTempTypedValue()` and `releaseTempTypedValue()`). Additionally, the method for getting value (`mResourcesImpl.getValue()`) has changed compared to the early version (`getValue()`). The synchronized block was also removed, and a try-finally structure was introduced to ensure the release of resources. As a result, the code change type is 3,4,5.","These changes do not directly affect the return type or value, nor do they change the exception handling that pertains to the API contract (both versions throw NotFoundException on error). The locking mechanism change might influence multithreaded behaviour, but it should not lead to a difference in API behavior from a client perspective. Thus, there is no Compatibility Issue as per the given API contract, leading to CI type 0."
246,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,23,24,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,0,"{
    synchronized (mIMM.mH) {
        ViewRootImpl viewRootImpl = mTargetView != null ? mTargetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mIMM.mServedView != null) {
                viewRootImpl = mIMM.mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
    mIMM.notifyUserAction();
    return false;
}","{
    mIMM.dispatchKeyEventFromInputMethod(mTargetView, event);
    return false;
}",1,"/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */
","/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method body is changed to a single line of code that calls a different method on the mIMM object; the control structures and redundant checks are removed. This indicates that there has been a significant refactoring or optimization in the implementation, which constitutes other statement changes (4) and a potential dependent API change (5) since the `dispatchKeyEventFromInputMethod` method is being called on the `mIMM` object which could have been altered.","Despite the simplification of the implementation, the method still consistently returns `false` at the end. Consequently, no new exceptions are introduced, and the method’s behavior regarding the return value remains unchanged. There does not seem to be any CI concerning differing return values or types, or exception handlings. Thus, there's no Compatibility Issue detected."
247,"<android.hardware.usb.UsbManager: HashMap<String, UsbDevice> getDeviceList()>",23,24,"<android.hardware.usb.UsbManager: HashMap<String, UsbDevice> getDeviceList()>","<android.hardware.usb.UsbManager: HashMap<String, UsbDevice> getDeviceList()>",0,"{
    Bundle bundle = new Bundle();
    try {
        mService.getDeviceList(bundle);
        HashMap<String, UsbDevice> result = new HashMap<String, UsbDevice>();
        for (String name : bundle.keySet()) {
            result.put(name, (UsbDevice) bundle.get(name));
        }
        return result;
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in getDeviceList"", e);
        return null;
    }
}","{
    Bundle bundle = new Bundle();
    try {
        mService.getDeviceList(bundle);
        HashMap<String, UsbDevice> result = new HashMap<String, UsbDevice>();
        for (String name : bundle.keySet()) {
            result.put(name, (UsbDevice) bundle.get(name));
        }
        return result;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a HashMap containing all USB devices currently attached.
 * USB device name is the key for the returned HashMap.
 * The result will be empty if no devices are attached, or if
 * USB host mode is inactive or unsupported.
 *
 * @return HashMap containing all connected USB devices.
 */
","/**
 * Returns a HashMap containing all USB devices currently attached.
 * USB device name is the key for the returned HashMap.
 * The result will be empty if no devices are attached, or if
 * USB host mode is inactive or unsupported.
 *
 * @return HashMap containing all connected USB devices.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"There's an exception handling statement change where a `Log.e(TAG, ""RemoteException in getDeviceList"", e); return null;` is replaced with `throw e.rethrowFromSystemServer();`, so the code change type is 2.","Because of the removed return statement inside the catch block, in the late version, the API won't return null when a RemoteException occurs but will instead throw an exception. Therefore, there is a CI caused by potential different exception handlings, marked by the number 2."
248,<android.app.ContextImpl: File[] getExternalCacheDirs()>,23,24,<android.app.ContextImpl: File[] getExternalCacheDirs()>,<android.app.ContextImpl: File[] getExternalCacheDirs()>,0,"{
    synchronized (mSync) {
        if (mExternalCacheDirs == null) {
            mExternalCacheDirs = Environment.buildExternalStorageAppCacheDirs(getPackageName());
        }
        // Create dirs if needed
        return ensureDirsExistOrFilter(mExternalCacheDirs);
    }
}","{
    synchronized (mSync) {
        if (mExternalCacheDirs == null) {
            mExternalCacheDirs = Environment.buildExternalStorageAppCacheDirs(getPackageName());
        }
        // Create dirs if needed
        return ensureExternalDirsExistOrFilter(mExternalCacheDirs);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed the method it calls from 'ensureDirsExistOrFilter' to 'ensureExternalDirsExistOrFilter', which is a change in a dependent API (dependent on the implementation of 'ensureExternalDirsExistOrFilter' vs. 'ensureDirsExistOrFilter'), so the code change type is 4,5.","This change does not necessarily introduce a compatibility issue, as it is an internal change and depends on whether the logic and return value of the new method 'ensureExternalDirsExistOrFilter' are consistent with the old method 'ensureDirsExistOrFilter'. Since the internal logic or return type of the methods called is not provided, based on the naming, the new method is expected to perform the same overall function but maybe for external directories specifically. Without evidence of a difference in behavior, we cannot assume a compatibility issue exists, so no compatibility issue is predicted."
249,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",23,24,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"{
    NetworkTemplate template = createTemplate(networkType, subscriberId);
    if (template == null) {
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters, state is going to be {@link NetworkStats.Bucket#STATE_ALL} and uid will vary.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE} and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",0,"The new try-catch block for IllegalArgumentException around createTemplate, an additional if statement to check the DBG flag, and the assignment of networkTemplate within that try-catch block indicate changes of type 2, 3, and 4.",There's no Compatibility Issue arising from these changes since the method ultimately still returns either null (in case of an exception or template being null) or a valid NetworkStats result. The catch block merely adds logging and the control flow remains effectively unchanged in terms of the API contract.
252,<android.app.ContextImpl: File getDatabasePath(String)>,23,24,<android.app.ContextImpl: File getDatabasePath(String)>,<android.app.ContextImpl: File getDatabasePath(String)>,0,"{
    return validateFilePath(name, false);
}","{
    File dir;
    File f;
    if (name.charAt(0) == File.separatorChar) {
        String dirPath = name.substring(0, name.lastIndexOf(File.separatorChar));
        dir = new File(dirPath);
        name = name.substring(name.lastIndexOf(File.separatorChar));
        f = new File(dir, name);
        if (!dir.isDirectory() && dir.mkdir()) {
            FileUtils.setPermissions(dir.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        }
    } else {
        dir = getDatabasesDir();
        f = makeFilename(dir, name);
    }
    return f;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The method implementation has completely changed, including the way the file path is constructed and how directories are handled. There have been changes in control dependency due to new 'if' condition, and new variables and method calls are also added. Hence, the code change types are 3 for control dependency change and 4 for other statement changes.","This change can lead to a different file being returned depending on the pathname provided as input - 'name'. Since the previous implementation always called validateFilePath method and the current implementation handles absolute paths and database directory location internally, the actual file returned by the API could be different, which is why there is a Compatibility Issue type 1."
255,<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchFlushCompleteEvent(int)>,23,24,<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchFlushCompleteEvent(int)>,<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchFlushCompleteEvent(int)>,0,"{
    if (mListener instanceof SensorEventListener2) {
        final Sensor sensor = mManager.mHandleToSensor.get(handle);
        ((SensorEventListener2) mListener).onFlushCompleted(sensor);
    }
    return;
}","{
    if (mListener instanceof SensorEventListener2) {
        final Sensor sensor = mManager.mHandleToSensor.get(handle);
        if (sensor == null) {
            // sensor disconnected
            return;
        }
        ((SensorEventListener2) mListener).onFlushCompleted(sensor);
    }
    return;
}",1,,"// Called from native code.
",-1,"[@SuppressWarnings(""unused"")]","[@SuppressWarnings(""unused""), @Override]",-1,-1,-1,-1,-1,-1,"3,4",0,"There's a new Control dependency change where an additional condition is being checked (if the sensor is null, then return early). Additionally, there is another statement for this null check, which is classified as an Other statement change. Therefore, the code change type is 3,4.","The new null check on the sensor before calling onFlushCompleted does not constitute a Compatibility Issue as it prevents a null sensor from being used, which would likely have resulted in a NullPointerException in the previous version. With this additional safety check, the behavior remains functionally consistent as the function would have failed previously anyway if a null sensor was passed to onFlushCompleted. Thus, there is no Compatibility Issue; so the CI type is 0."
256,<android.widget.TextView: int getRightPaddingOffset()>,23,24,<android.widget.TextView: int getRightPaddingOffset()>,<android.widget.TextView: int getRightPaddingOffset()>,0,"{
    return -(getFudgedPaddingRight() - mPaddingRight) + (int) Math.max(0, mShadowDx + mShadowRadius);
}","{
    return -(getCompoundPaddingRight() - mPaddingRight) + (int) Math.max(0, mShadowDx + mShadowRadius);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method getFudgedPaddingRight() from the early version is replaced with the method getCompoundPaddingRight() in the late version. Since this is a change in the method being called, the code falls under the categories of return statement changed (1) and dependent API changed (5).","This change alters what method is being called to calculate the right padding offset, which could potentially return a different padding value from the one returned in the previous version. Therefore, it is classified as a Compatibility Issue caused by potential different return values or types (1)."
257,"<android.provider.ContactsContract.Contacts: InputStream openContactPhotoInputStream(ContentResolver,Uri,boolean)>",23,24,"<android.provider.ContactsContract.Contacts: InputStream openContactPhotoInputStream(ContentResolver,Uri,boolean)>","<android.provider.ContactsContract.Contacts: InputStream openContactPhotoInputStream(ContentResolver,Uri,boolean)>",0,"{
    if (preferHighres) {
        final Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
        InputStream inputStream;
        try {
            AssetFileDescriptor fd = cr.openAssetFileDescriptor(displayPhotoUri, ""r"");
            return fd.createInputStream();
        } catch (IOException e) {
        // fallback to the thumbnail code
        }
    }
    Uri photoUri = Uri.withAppendedPath(contactUri, Photo.CONTENT_DIRECTORY);
    if (photoUri == null) {
        return null;
    }
    Cursor cursor = cr.query(photoUri, new String[] { ContactsContract.CommonDataKinds.Photo.PHOTO }, null, null, null);
    try {
        if (cursor == null || !cursor.moveToNext()) {
            return null;
        }
        byte[] data = cursor.getBlob(0);
        if (data == null) {
            return null;
        }
        return new ByteArrayInputStream(data);
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
}","{
    if (preferHighres) {
        final Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
        try {
            AssetFileDescriptor fd = cr.openAssetFileDescriptor(displayPhotoUri, ""r"");
            if (fd != null) {
                return fd.createInputStream();
            }
        } catch (IOException e) {
        // fallback to the thumbnail code
        }
    }
    Uri photoUri = Uri.withAppendedPath(contactUri, Photo.CONTENT_DIRECTORY);
    if (photoUri == null) {
        return null;
    }
    Cursor cursor = cr.query(photoUri, new String[] { ContactsContract.CommonDataKinds.Photo.PHOTO }, null, null, null);
    try {
        if (cursor == null || !cursor.moveToNext()) {
            return null;
        }
        byte[] data = cursor.getBlob(0);
        if (data == null) {
            return null;
        }
        return new ByteArrayInputStream(data);
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
}",1,"/**
 * Opens an InputStream for the contacts's photo and returns the
 * photo as a byte stream.
 * @param cr The content resolver to use for querying
 * @param contactUri the contact whose photo should be used. This can be used with
 * either a {@link #CONTENT_URI} or a {@link #CONTENT_LOOKUP_URI} URI.
 * @param preferHighres If this is true and the contact has a higher resolution photo
 * available, it is returned. If false, this function always tries to get the thumbnail
 * @return an InputStream of the photo, or null if no photo is present
 */
","/**
 * Opens an InputStream for the contacts's photo and returns the
 * photo as a byte stream.
 * @param cr The content resolver to use for querying
 * @param contactUri the contact whose photo should be used. This can be used with
 * either a {@link #CONTENT_URI} or a {@link #CONTENT_LOOKUP_URI} URI.
 * @param preferHighres If this is true and the contact has a higher resolution photo
 * available, it is returned. If false, this function always tries to get the thumbnail
 * @return an InputStream of the photo, or null if no photo is present
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The code change consists of adding a null check for the `AssetFileDescriptor` object before calling `createInputStream()`. No change in return statements or exception handling statements is introduced.,There is no Compatibility Issue since all code paths still lead to the same behavior; the null check simply prevents a potential `NullPointerException` and doesn't change the successful execution path of the method.
258,<android.os.Bundle: String toString()>,23,24,<android.os.Bundle: String toString()>,<android.os.Bundle: String toString()>,0,"{
    if (mParcelledData != null) {
        if (mParcelledData == EMPTY_PARCEL) {
            return ""Bundle[EMPTY_PARCEL]"";
        } else {
            return ""Bundle[mParcelledData.dataSize="" + mParcelledData.dataSize() + ""]"";
        }
    }
    return ""Bundle["" + mMap.toString() + ""]"";
}","{
    if (mParcelledData != null) {
        if (isEmptyParcel()) {
            return ""Bundle[EMPTY_PARCEL]"";
        } else {
            return ""Bundle[mParcelledData.dataSize="" + mParcelledData.dataSize() + ""]"";
        }
    }
    return ""Bundle["" + mMap.toString() + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"There is a change in the conditional check, where `mParcelledData == EMPTY_PARCEL` has been replaced with a method call `isEmptyParcel()`. This change is a Dependent API changed (5), indicating that there might be a change in how the condition is evaluated.","Even though there is a change in how the condition is checked, the semantics of the method have not been altered. Since the change in the method call does not affect what is returned or how exceptions are handled, there is No Compatibility Issue (0)."
260,<android.printservice.PrintService: IBinder onBind(Intent)>,23,24,<android.printservice.PrintService: IBinder onBind(Intent)>,<android.printservice.PrintService: IBinder onBind(Intent)>,0,"{
    return new IPrintService.Stub() {

        @Override
        public void createPrinterDiscoverySession() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_CREATE_PRINTER_DISCOVERY_SESSION);
        }

        @Override
        public void destroyPrinterDiscoverySession() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_DESTROY_PRINTER_DISCOVERY_SESSION);
        }

        public void startPrinterDiscovery(List<PrinterId> priorityList) {
            mHandler.obtainMessage(ServiceHandler.MSG_START_PRINTER_DISCOVERY, priorityList).sendToTarget();
        }

        @Override
        public void stopPrinterDiscovery() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_STOP_PRINTER_DISCOVERY);
        }

        @Override
        public void validatePrinters(List<PrinterId> printerIds) {
            mHandler.obtainMessage(ServiceHandler.MSG_VALIDATE_PRINTERS, printerIds).sendToTarget();
        }

        @Override
        public void startPrinterStateTracking(PrinterId printerId) {
            mHandler.obtainMessage(ServiceHandler.MSG_START_PRINTER_STATE_TRACKING, printerId).sendToTarget();
        }

        @Override
        public void stopPrinterStateTracking(PrinterId printerId) {
            mHandler.obtainMessage(ServiceHandler.MSG_STOP_PRINTER_STATE_TRACKING, printerId).sendToTarget();
        }

        @Override
        public void setClient(IPrintServiceClient client) {
            mHandler.obtainMessage(ServiceHandler.MSG_SET_CLIENT, client).sendToTarget();
        }

        @Override
        public void requestCancelPrintJob(PrintJobInfo printJobInfo) {
            mHandler.obtainMessage(ServiceHandler.MSG_ON_REQUEST_CANCEL_PRINTJOB, printJobInfo).sendToTarget();
        }

        @Override
        public void onPrintJobQueued(PrintJobInfo printJobInfo) {
            mHandler.obtainMessage(ServiceHandler.MSG_ON_PRINTJOB_QUEUED, printJobInfo).sendToTarget();
        }
    };
}","{
    return new IPrintService.Stub() {

        @Override
        public void createPrinterDiscoverySession() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_CREATE_PRINTER_DISCOVERY_SESSION);
        }

        @Override
        public void destroyPrinterDiscoverySession() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_DESTROY_PRINTER_DISCOVERY_SESSION);
        }

        @Override
        public void startPrinterDiscovery(List<PrinterId> priorityList) {
            mHandler.obtainMessage(ServiceHandler.MSG_START_PRINTER_DISCOVERY, priorityList).sendToTarget();
        }

        @Override
        public void stopPrinterDiscovery() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_STOP_PRINTER_DISCOVERY);
        }

        @Override
        public void validatePrinters(List<PrinterId> printerIds) {
            mHandler.obtainMessage(ServiceHandler.MSG_VALIDATE_PRINTERS, printerIds).sendToTarget();
        }

        @Override
        public void startPrinterStateTracking(PrinterId printerId) {
            mHandler.obtainMessage(ServiceHandler.MSG_START_PRINTER_STATE_TRACKING, printerId).sendToTarget();
        }

        @Override
        public void requestCustomPrinterIcon(PrinterId printerId) {
            mHandler.obtainMessage(ServiceHandler.MSG_REQUEST_CUSTOM_PRINTER_ICON, printerId).sendToTarget();
        }

        @Override
        public void stopPrinterStateTracking(PrinterId printerId) {
            mHandler.obtainMessage(ServiceHandler.MSG_STOP_PRINTER_STATE_TRACKING, printerId).sendToTarget();
        }

        @Override
        public void setClient(IPrintServiceClient client) {
            mHandler.obtainMessage(ServiceHandler.MSG_SET_CLIENT, client).sendToTarget();
        }

        @Override
        public void requestCancelPrintJob(PrintJobInfo printJobInfo) {
            mHandler.obtainMessage(ServiceHandler.MSG_ON_REQUEST_CANCEL_PRINTJOB, printJobInfo).sendToTarget();
        }

        @Override
        public void onPrintJobQueued(PrintJobInfo printJobInfo) {
            mHandler.obtainMessage(ServiceHandler.MSG_ON_PRINTJOB_QUEUED, printJobInfo).sendToTarget();
        }
    };
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new method requestCustomPrinterIcon(PrinterId printerId) has been added to the IPrintService.Stub implementation, but this does not affect the onBind method directly. The onBind method still returns an instance of IPrintService.Stub with no changes to its interface or behavior from the perspective of the onBind method. Therefore, the change is categorized as 4.","There is no Compatibility Issue because the onBind method's contract has not been altered. It still returns an IBinder, and the addition of a new method to the IPrintService.Stub class does not affect the pre-existing contract of the onBind method. The client code that binds to the service will still receive an IBinder as expected, so the behavior remains the same."
261,<android.content.ContentResolver.CursorWrapperInner: void finalize()>,23,24,<android.content.ContentResolver.CursorWrapperInner: void finalize()>,<android.content.ContentResolver.CursorWrapperInner: void finalize()>,0,"{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        if (!mProviderReleased && mContentProvider != null) {
            // Even though we are using CloseGuard, log this anyway so that
            // application developers always see the message in the log.
            Log.w(TAG, ""Cursor finalized without prior close()"");
            ContentResolver.this.releaseProvider(mContentProvider);
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        mCloseGuard.warnIfOpen();
        close();
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,"The finalization logic in the early implementation checks if the `mCloseGuard` is non-null before calling `mCloseGuard.warnIfOpen()`. In the late implementation, it directly calls `warnIfOpen()` without the null check. Additionally, the check for `mProviderReleased` and `mContentProvider` is removed, and instead of logging a warning and releasing the provider, it now simply calls `close()`. These are control dependency changes and other statement changes, so the code change type is 1,3,4.","Despite these changes, all the alterations happen within a `finalize()` method, which is called by the garbage collector when there are no more references to the object. These changes will not affect the API behavior during normal usage (i.e., methods returning different values or exceptions being thrown under circumstances controlled by the API's user). The impact here is invisible to the user of API because it affects only internal resource management after the object is no longer reachable. Therefore, no Compatibility Issue is expected from the perspective of the API consumer, and the CI type is 0."
263,<android.app.Notification.Builder: Builder setContentTitle(CharSequence)>,23,24,<android.app.Notification.Builder: Builder setContentTitle(CharSequence)>,<android.app.Notification.Builder: Builder setContentTitle(CharSequence)>,0,"{
    mContentTitle = safeCharSequence(title);
    return this;
}","{
    mN.extras.putCharSequence(EXTRA_TITLE, safeCharSequence(title));
    return this;
}",1,"/**
 * Set the first line of text in the platform notification template.
 */
","/**
 * Set the first line of text in the platform notification template.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"There is a change in the implementation where the `mContentTitle` is no longer being set. Instead, the title is put directly into `mN.extras` with a specific key `EXTRA_TITLE`. Additionally, there is a change to a dependent API: the method `putCharSequence` is being used in the late version instead of directly assigning the value to `mContentTitle`. Hence, the code change type is 4,5.","The change in how the title is stored will lead to a difference in the internal state of the `Notification.Builder` object after calling `setContentTitle()`. In the early version, the title is stored in the `mContentTitle` field, while in the late version it is stored within a `Bundle` (`mN.extras`). This change affects the state of the object which may affect the behavior of other methods that rely on these fields, resulting in a CI of type 1."
264,<android.content.res.Resources: int getDimensionPixelSize(int)>,23,24,<android.content.res.Resources: int getDimensionPixelSize(int)>,<android.content.res.Resources: int getDimensionPixelSize(int)>,0,"{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimensionPixelSize(value.data, mMetrics);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimensionPixelSize(value.data, impl.getDisplayMetrics());
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Retrieve a dimensional for a particular resource ID for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
","/**
 * Retrieve a dimensional for a particular resource ID for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5","1,2","The way to obtain and release the TypedValue object has changed, and the ResourcesImpl object is accessed differently. There's also a minor change where mMetrics is replaced by impl.getDisplayMetrics(). There are changes to other statements and the dependent API `obtainTempTypedValue()` and `releaseTempTypedValue(value)` were introduced, so the code change type is 3,4,5.","The change of introducing `obtainTempTypedValue()` and `releaseTempTypedValue(value)` along with the use of a different ResourcesImpl object could alter the return value or potentially change exception handling (due to the restructuring of exception handling with try-finally). Additionally, the NotFoundException message has been modified, although the exception type remains the same. Therefore, the CI type is 1,2."
265,<android.app.ActivityManager: void getMemoryInfo(MemoryInfo)>,23,24,<android.app.ActivityManager: void getMemoryInfo(MemoryInfo)>,<android.app.ActivityManager: void getMemoryInfo(MemoryInfo)>,0,"{
    try {
        ActivityManagerNative.getDefault().getMemoryInfo(outInfo);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().getMemoryInfo(outInfo);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return general information about the memory state of the system.  This
 * can be used to help decide how to manage your own memory, though note
 * that polling is not recommended and
 * {@link android.content.ComponentCallbacks2#onTrimMemory(int)
 * ComponentCallbacks2.onTrimMemory(int)} is the preferred way to do this.
 * Also see {@link #getMyMemoryState} for how to retrieve the current trim
 * level of your process as needed, which gives a better hint for how to
 * manage its memory.
 */
","/**
 * Return general information about the memory state of the system.  This
 * can be used to help decide how to manage your own memory, though note
 * that polling is not recommended and
 * {@link android.content.ComponentCallbacks2#onTrimMemory(int)
 * ComponentCallbacks2.onTrimMemory(int)} is the preferred way to do this.
 * Also see {@link #getMyMemoryState} for how to retrieve the current trim
 * level of your process as needed, which gives a better hint for how to
 * manage its memory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement changed from catching and ignoring a RemoteException to rethrowing it after calling e.rethrowFromSystemServer(), so the change type is 2.","Due to the change in exception handling, the late version of the API could throw a new unchecked exception where the early version does not, which is a difference in behavior, therefore the CI type is 2."
266,"<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>",23,24,"<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>","<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>",0,"{
    final Locale locale = getLocaleObject();
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        final String replacementString = containsExtraValueKey(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) ? getExtraValueOf(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) : localeStr;
        try {
            return String.format(subtypeName.toString(), replacementString != null ? replacementString : """");
        } catch (IllegalFormatException e) {
            Slog.w(TAG, ""Found illegal format in subtype name("" + subtypeName + ""): "" + e);
            return """";
        }
    } else {
        return localeStr;
    }
}","{
    if (mSubtypeNameResId == 0) {
        return getLocaleDisplayName(getLocaleFromContext(context), getLocaleObject(), DisplayContext.CAPITALIZATION_FOR_UI_LIST_OR_MENU);
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (TextUtils.isEmpty(subtypeName)) {
        return """";
    }
    final String subtypeNameString = subtypeName.toString();
    String replacementString;
    if (containsExtraValueKey(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME)) {
        replacementString = getExtraValueOf(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME);
    } else {
        final DisplayContext displayContext;
        if (TextUtils.equals(subtypeNameString, ""%s"")) {
            displayContext = DisplayContext.CAPITALIZATION_FOR_UI_LIST_OR_MENU;
        } else if (subtypeNameString.startsWith(""%s"")) {
            displayContext = DisplayContext.CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE;
        } else {
            displayContext = DisplayContext.CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE;
        }
        replacementString = getLocaleDisplayName(getLocaleFromContext(context), getLocaleObject(), displayContext);
    }
    if (replacementString == null) {
        replacementString = """";
    }
    try {
        return String.format(subtypeNameString, replacementString);
    } catch (IllegalFormatException e) {
        Slog.w(TAG, ""Found illegal format in subtype name("" + subtypeName + ""): "" + e);
        return """";
    }
}",1,"/**
 * @param context Context will be used for getting Locale and PackageManager.
 * @param packageName The package name of the IME
 * @param appInfo The application info of the IME
 * @return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 * may have exactly one %s in it. If there is, the %s part will be replaced with the locale's
 * display name by the formatter. If there is not, this method returns the string specified by
 * mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the framework to
 * generate an appropriate display name.
 */
","/**
 * Returns a display name for this subtype.
 *
 * <p>If {@code subtypeNameResId} is specified (!= 0) text generated from that resource will
 * be returned. The localized string resource of the label should be capitalized for inclusion
 * in UI lists. The string resource may contain at most one {@code %s}. If present, the
 * {@code %s} will be replaced with the display name of the subtype locale in the user's locale.
 *
 * <p>If {@code subtypeNameResId} is not specified (== 0) the framework returns the display name
 * of the subtype locale, as capitalized for use in UI lists, in the user's locale.
 *
 * @param context {@link Context} will be used for getting {@link Locale} and
 * {@link android.content.pm.PackageManager}.
 * @param packageName The package name of the input method.
 * @param appInfo The {@link ApplicationInfo} of the input method.
 * @return a display name for this subtype.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed - in the early version it directly returns the result of `getLocaleDisplayName(...)`, while in the late version there's added logic to determine `DisplayContext` and `replacementString` before formatting the subtype name. Moreover, the implementation for getting `replacementString` and the formatting logic for `subtypeName` has also been adjusted, and the method `getLocaleFromContext(context)` is introduced. These are changes in both return statements and other statements, and a new dependent API `getLocaleFromContext` is used. Therefore, the code change types are 1, 4, 5.","The return value of the method could be different because the logic for constructing the display name is different, specifically the determination of `replacementString` and the additional `displayContext` logic. This can cause the API to return different values under certain conditions, resulting in a potential Compatibility Issue of type 1."
270,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,23,24,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    /*
         * Don't try to intercept touch if we can't scroll anyway.
         */
    if (getScrollY() == 0 && !canScrollVertically(1)) {
        return false;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int y = (int) ev.getY(pointerIndex);
                final int yDiff = Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    mNestedYOffset = 0;
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int y = (int) ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                postInvalidateOnAnimation();
            }
            stopNestedScroll();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    if (super.onInterceptTouchEvent(ev)) {
        return true;
    }
    /*
         * Don't try to intercept touch if we can't scroll anyway.
         */
    if (getScrollY() == 0 && !canScrollVertically(1)) {
        return false;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int y = (int) ev.getY(pointerIndex);
                final int yDiff = Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    mNestedYOffset = 0;
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int y = (int) ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                 * If being flinged and user touches the screen, initiate drag;
                 * otherwise don't. mScroller.isFinished should be false when
                 * being flinged. We need to call computeScrollOffset() first so that
                 * isFinished() is correct.
                */
                mScroller.computeScrollOffset();
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                postInvalidateOnAnimation();
            }
            stopNestedScroll();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
271,<android.view.accessibility.AccessibilityCache: List<AccessibilityWindowInfo> getWindows()>,23,24,<android.view.accessibility.AccessibilityCache: List<AccessibilityWindowInfo> getWindows()>,<android.view.accessibility.AccessibilityCache: List<AccessibilityWindowInfo> getWindows()>,0,"{
    synchronized (mLock) {
        final int windowCount = mWindowCache.size();
        if (windowCount > 0) {
            // Careful to return the windows in a decreasing layer order.
            SparseArray<AccessibilityWindowInfo> sortedWindows = mTempWindowArray;
            sortedWindows.clear();
            for (int i = 0; i < windowCount; i++) {
                AccessibilityWindowInfo window = mWindowCache.valueAt(i);
                sortedWindows.put(window.getLayer(), window);
            }
            List<AccessibilityWindowInfo> windows = new ArrayList<>(windowCount);
            for (int i = windowCount - 1; i >= 0; i--) {
                AccessibilityWindowInfo window = sortedWindows.valueAt(i);
                windows.add(AccessibilityWindowInfo.obtain(window));
                sortedWindows.removeAt(i);
            }
            return windows;
        }
        return null;
    }
}","{
    synchronized (mLock) {
        if (!mIsAllWindowsCached) {
            return null;
        }
        final int windowCount = mWindowCache.size();
        if (windowCount > 0) {
            // Careful to return the windows in a decreasing layer order.
            SparseArray<AccessibilityWindowInfo> sortedWindows = mTempWindowArray;
            sortedWindows.clear();
            for (int i = 0; i < windowCount; i++) {
                AccessibilityWindowInfo window = mWindowCache.valueAt(i);
                sortedWindows.put(window.getLayer(), window);
            }
            // It's possible in transient conditions for two windows to share the same
            // layer, which results in sortedWindows being smaller than mWindowCache
            final int sortedWindowCount = sortedWindows.size();
            List<AccessibilityWindowInfo> windows = new ArrayList<>(sortedWindowCount);
            for (int i = sortedWindowCount - 1; i >= 0; i--) {
                AccessibilityWindowInfo window = sortedWindows.valueAt(i);
                windows.add(AccessibilityWindowInfo.obtain(window));
                sortedWindows.removeAt(i);
            }
            return windows;
        }
        return null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement along with a change in the condition involving a new variable check (mIsAllWindowsCached), and a change in how sortedWindows are used due to a transient condition comment have been modified, so the code change type is 1,3.","Introducing an additional check on mIsAllWindowsCached may cause the method to return null in cases where it wouldn't have previously, this is a return statement changed-1. Moreover, the change in handling sortedWindows could potentially result in the method returning a list with different contents is also considered a return statement changed-1 which could possibly lead to a different behaviour; hence, the CI type is 1."
272,"<android.app.admin.DevicePolicyManager: boolean isUninstallBlocked(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: boolean isUninstallBlocked(ComponentName,String)>","<android.app.admin.DevicePolicyManager: boolean isUninstallBlocked(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            return mService.isUninstallBlocked(admin, packageName);
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed to call block uninstall on device policy service"");
        }
    }
    return false;
}","{
    throwIfParentInstance(""isUninstallBlocked"");
    if (mService != null) {
        try {
            return mService.isUninstallBlocked(admin, packageName);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Check whether the current user has been blocked by device policy from uninstalling a package.
 * Requires the caller to be the profile owner if checking a specific admin's policy.
 * <p>
 * <strong>Note:</strong> Starting from {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}, the
 * behavior of this API is changed such that passing {@code null} as the {@code admin}
 * parameter will return if any admin has blocked the uninstallation. Before L MR1, passing
 * {@code null} will cause a NullPointerException to be raised.
 *
 * @param admin The name of the admin component whose blocking policy will be checked, or
 * {@code null} to check whether any admin has blocked the uninstallation.
 * @param packageName package to check.
 * @return true if uninstallation is blocked.
 */
","/**
 * Check whether the user has been blocked by device policy from uninstalling a package.
 * Requires the caller to be the profile owner if checking a specific admin's policy.
 * <p>
 * <strong>Note:</strong> Starting from {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}, the
 * behavior of this API is changed such that passing {@code null} as the {@code admin} parameter
 * will return if any admin has blocked the uninstallation. Before L MR1, passing {@code null}
 * will cause a NullPointerException to be raised.
 *
 * @param admin The name of the admin component whose blocking policy will be checked, or
 * {@code null} to check whether any admin has blocked the uninstallation.
 * @param packageName package to check.
 * @return true if uninstallation is blocked.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"There has been an introduction of a new method call (throwIfParentInstance(""isUninstallBlocked"");) outside the existing control flow and a change in the exception handling (from logging the exception to throwing it with re.rethrowFromSystemServer()). Therefore, a change in other statements as well as exception handling statements has occurred, corresponding to the types 2,3,4.","The introduction of the new call to throwIfParentInstance may result in a new exception being thrown before the rest of the method's logic is executed. The change in exception handling represents a change in the exceptions that can be thrown by the method; instead of catching and logging the RemoteException, it will now be thrown as a result of rethrowFromSystemServer(). Thus, it may potentially cause an incompatibility due to different exception handling, which falls under CI type 2."
273,"<android.app.admin.DevicePolicyManager: void setTrustAgentConfiguration(ComponentName,ComponentName,PersistableBundle)>",23,24,"<android.app.admin.DevicePolicyManager: void setTrustAgentConfiguration(ComponentName,ComponentName,PersistableBundle)>","<android.app.admin.DevicePolicyManager: void setTrustAgentConfiguration(ComponentName,ComponentName,PersistableBundle)>",0,"{
    if (mService != null) {
        try {
            mService.setTrustAgentConfiguration(admin, target, configuration);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setTrustAgentConfiguration(admin, target, configuration, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Sets a list of configuration features to enable for a TrustAgent component. This is meant
 * to be used in conjunction with {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which disables all
 * trust agents but those enabled by this function call. If flag
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is not set, then this call has no effect.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call
 * this method; if not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param target Component name of the agent to be enabled.
 * @param configuration TrustAgent-specific feature bundle. If null for any admin, agent
 * will be strictly disabled according to the state of the
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} flag.
 * <p>If {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is set and options is not null for all admins,
 * then it's up to the TrustAgent itself to aggregate the values from all device admins.
 * <p>Consult documentation for the specific TrustAgent to determine legal options parameters.
 */
","/**
 * Sets a list of configuration features to enable for a TrustAgent component. This is meant to
 * be used in conjunction with {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which disables all trust
 * agents but those enabled by this function call. If flag
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is not set, then this call has no effect.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call this method;
 * if not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set the configuration for
 * the parent profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param target Component name of the agent to be enabled.
 * @param configuration TrustAgent-specific feature bundle. If null for any admin, agent will be
 * strictly disabled according to the state of the
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} flag.
 * <p>
 * If {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is set and options is not null for all
 * admins, then it's up to the TrustAgent itself to aggregate the values from all
 * device admins.
 * <p>
 * Consult documentation for the specific TrustAgent to determine legal options
 * parameters.
 * @throws SecurityException if {@code admin} is not an active administrator or does not use
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The dependent API 'mService.setTrustAgentConfiguration' has an extra parameter 'mParentInstance' in the late version, so the code change type is 5. Also, there is a change in the exception handling code from logging an error to throwing an exception, which is a code change type 2.","There is a Compatibility Issue due to the changed exception handling statement which throws a rethrown exception in the late version, while the early version does not throw an exception but logs an error instead. Therefore, the API may throw an exception where it would not have before, making the CI type 2."
274,<android.app.Notification.Builder: Builder setUsesChronometer(boolean)>,23,24,<android.app.Notification.Builder: Builder setUsesChronometer(boolean)>,<android.app.Notification.Builder: Builder setUsesChronometer(boolean)>,0,"{
    mUseChronometer = b;
    return this;
}","{
    mN.extras.putBoolean(EXTRA_SHOW_CHRONOMETER, b);
    return this;
}",1,"/**
 * Show the {@link Notification#when} field as a stopwatch.
 *
 * Instead of presenting <code>when</code> as a timestamp, the notification will show an
 * automatically updating display of the minutes and seconds since <code>when</code>.
 *
 * Useful when showing an elapsed time (like an ongoing phone call).
 *
 * @see android.widget.Chronometer
 * @see Notification#when
 */
","/**
 * Show the {@link Notification#when} field as a stopwatch.
 *
 * Instead of presenting <code>when</code> as a timestamp, the notification will show an
 * automatically updating display of the minutes and seconds since <code>when</code>.
 *
 * Useful when showing an elapsed time (like an ongoing phone call).
 *
 * The counter can also be set to count down to <code>when</code> when using
 * {@link #setChronometerCountDown(boolean)}.
 *
 * @see android.widget.Chronometer
 * @see Notification#when
 * @see #setChronometerCountDown(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation changed from directly setting a variable (mUseChronometer) to putting a boolean into a Bundle with a key (EXTRA_SHOW_CHRONOMETER), which is a different statement and affects how the chronometer setting is stored. Therefore, the change type is 1,4 due to a change in the assignment and an alteration in the method used for setting the chronometer value.","This change in how the chronometer setting is applied qualifies for a Compatibility Issue due to potential different return values or types. The behavioral change is significant since clients relying on the internal state of mUseChronometer would find it unaffected, leading the method to potentially return different results when clients interact with the changed API. Thus, the CI type is 1."
275,"<android.content.res.Resources: CharSequence getQuantityText(int,int)>",23,24,"<android.content.res.Resources: CharSequence getQuantityText(int,int)>","<android.content.res.Resources: CharSequence getQuantityText(int,int)>",0,"{
    NativePluralRules rule = getPluralRule();
    CharSequence res = mAssets.getResourceBagText(id, attrForQuantityCode(rule.quantityForInt(quantity)));
    if (res != null) {
        return res;
    }
    res = mAssets.getResourceBagText(id, ID_OTHER);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""Plural resource ID #0x"" + Integer.toHexString(id) + "" quantity="" + quantity + "" item="" + stringForQuantityCode(rule.quantityForInt(quantity)));
}","{
    return mResourcesImpl.getQuantityText(id, quantity);
}",1,"/**
 * Returns the character sequence necessary for grammatically correct pluralization
 * of the given resource ID for the given quantity.
 * Note that the character sequence is selected based solely on grammatical necessity,
 * and that such rules differ between languages. Do not assume you know which string
 * will be returned for a given quantity. See
 * <a href=""{@docRoot}guide/topics/resources/string-resource.html#Plurals"">String Resources</a>
 * for more detail.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param quantity The number used to get the correct string for the current language's
 * plural rules.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return CharSequence The string data associated with the resource, plus
 * possibly styled text information.
 */
","/**
 * Returns the character sequence necessary for grammatically correct pluralization
 * of the given resource ID for the given quantity.
 * Note that the character sequence is selected based solely on grammatical necessity,
 * and that such rules differ between languages. Do not assume you know which string
 * will be returned for a given quantity. See
 * <a href=""{@docRoot}guide/topics/resources/string-resource.html#Plurals"">String Resources</a>
 * for more detail.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param quantity The number used to get the correct string for the current language's
 * plural rules.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return CharSequence The string data associated with the resource, plus
 * possibly styled text information.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed entirely from a custom implementation using `NativePluralRules`, `getResourceBagText`, and throwing `NotFoundException` to now simply delegating the call to `mResourcesImpl.getQuantityText(id, quantity)`. Thus, the code change types are 1 and 5.","Since the entire implementation has been changed, including dependencies on other APIs (`mResourcesImpl.getQuantityText` instead of directly accessing assets and plural rules), this can potentially return different values or types. Additionally, the old code may throw a `NotFoundException`, whereas the new one does not, also implying a change in exception behavior. Therefore, CI type 1 is applicable."
276,<android.os.BaseBundle: void unparcel()>,23,24,<android.os.BaseBundle: void unparcel()>,<android.os.BaseBundle: void unparcel()>,0,"{
    if (mParcelledData == null) {
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": no parcelled data"");
        return;
    }
    if (mParcelledData == EMPTY_PARCEL) {
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": empty"");
        if (mMap == null) {
            mMap = new ArrayMap<String, Object>(1);
        } else {
            mMap.erase();
        }
        mParcelledData = null;
        return;
    }
    int N = mParcelledData.readInt();
    if (DEBUG)
        Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": reading "" + N + "" maps"");
    if (N < 0) {
        return;
    }
    if (mMap == null) {
        mMap = new ArrayMap<String, Object>(N);
    } else {
        mMap.erase();
        mMap.ensureCapacity(N);
    }
    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
    if (DEBUG)
        Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "" final map: "" + mMap);
}","{
    synchronized (this) {
        final Parcel parcelledData = mParcelledData;
        if (parcelledData == null) {
            if (DEBUG)
                Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": no parcelled data"");
            return;
        }
        if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
            Slog.wtf(TAG, ""Attempting to unparcel a Bundle while in transit; this may "" + ""clobber all data inside!"", new Throwable());
        }
        if (isEmptyParcel()) {
            if (DEBUG)
                Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": empty"");
            if (mMap == null) {
                mMap = new ArrayMap<>(1);
            } else {
                mMap.erase();
            }
            mParcelledData = null;
            return;
        }
        int N = parcelledData.readInt();
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": reading "" + N + "" maps"");
        if (N < 0) {
            return;
        }
        ArrayMap<String, Object> map = mMap;
        if (map == null) {
            map = new ArrayMap<>(N);
        } else {
            map.erase();
            map.ensureCapacity(N);
        }
        try {
            parcelledData.readArrayMapInternal(map, N, mClassLoader);
        } catch (BadParcelableException e) {
            if (sShouldDefuse) {
                Log.w(TAG, ""Failed to parse Bundle, but defusing quietly"", e);
                map.erase();
            } else {
                throw e;
            }
        } finally {
            mMap = map;
            parcelledData.recycle();
            mParcelledData = null;
        }
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "" final map: "" + mMap);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2",The method has several changes: ,"- The addition of a try-catch-finally block around the method call to `parcelledData.readArrayMapInternal(map, N, mClassLoader)`, catching `BadParcelableException`."
277,"<android.content.res.Resources: int getColor(int,Theme)>",23,24,"<android.content.res.Resources: int getColor(int,Theme)>","<android.content.res.Resources: int getColor(int,Theme)>",0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            mTmpValue = value;
            return value.data;
        } else if (value.type != TypedValue.TYPE_STRING) {
            throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
        }
        mTmpValue = null;
    }
    final ColorStateList csl = loadColorStateList(value, id, theme);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return csl.getDefaultColor();
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data;
        } else if (value.type != TypedValue.TYPE_STRING) {
            throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
        }
        final ColorStateList csl = impl.loadColorStateList(this, value, id, theme);
        return csl.getDefaultColor();
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Returns a themed color integer associated with a particular resource ID.
 * If the resource holds a complex {@link ColorStateList}, then the default
 * color from the set is returned.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param theme The theme used to style the color attributes, may be
 * {@code null}.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 *
 * @return A single color value in the form 0xAARRGGBB.
 */
","/**
 * Returns a themed color integer associated with a particular resource ID.
 * If the resource holds a complex {@link ColorStateList}, then the default
 * color from the set is returned.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param theme The theme used to style the color attributes, may be
 * {@code null}.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 *
 * @return A single color value in the form 0xAARRGGBB.
 */
",-1,[@ColorInt],[@ColorInt],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The method implementation underwent several changes: (1) In the early version, the method used a synchronized block and static `mTmpValue`, while the late version removes the synchronized block and static value, (2) exception handling has changed from catching and logging a `NotFoundException` to throwing it directly, and (3) control flow has changed due to the removal of the synchronized block and conditional statements managing `mTmpValue`. These changes result in code change type 1,2,3,4.","Changes in exception handling and control flow potentially cause the API to return different values or types and throw different exceptions under certain circumstances, leading to Compatibility Issues of type 1 and 2."
278,<android.preference.PreferenceGroup: boolean addPreference(Preference)>,23,24,<android.preference.PreferenceGroup: boolean addPreference(Preference)>,<android.preference.PreferenceGroup: boolean addPreference(Preference)>,0,"{
    if (mPreferenceList.contains(preference)) {
        // Exists
        return true;
    }
    if (preference.getOrder() == Preference.DEFAULT_ORDER) {
        if (mOrderingAsAdded) {
            preference.setOrder(mCurrentPreferenceOrder++);
        }
        if (preference instanceof PreferenceGroup) {
            // TODO: fix (method is called tail recursively when inflating,
            // so we won't end up properly passing this flag down to children
            ((PreferenceGroup) preference).setOrderingAsAdded(mOrderingAsAdded);
        }
    }
    int insertionIndex = Collections.binarySearch(mPreferenceList, preference);
    if (insertionIndex < 0) {
        insertionIndex = insertionIndex * -1 - 1;
    }
    if (!onPrepareAddPreference(preference)) {
        return false;
    }
    synchronized (this) {
        mPreferenceList.add(insertionIndex, preference);
    }
    preference.onAttachedToHierarchy(getPreferenceManager());
    if (mAttachedToActivity) {
        preference.onAttachedToActivity();
    }
    notifyHierarchyChanged();
    return true;
}","{
    if (mPreferenceList.contains(preference)) {
        // Exists
        return true;
    }
    if (preference.getOrder() == Preference.DEFAULT_ORDER) {
        if (mOrderingAsAdded) {
            preference.setOrder(mCurrentPreferenceOrder++);
        }
        if (preference instanceof PreferenceGroup) {
            // TODO: fix (method is called tail recursively when inflating,
            // so we won't end up properly passing this flag down to children
            ((PreferenceGroup) preference).setOrderingAsAdded(mOrderingAsAdded);
        }
    }
    if (!onPrepareAddPreference(preference)) {
        return false;
    }
    synchronized (this) {
        int insertionIndex = Collections.binarySearch(mPreferenceList, preference);
        if (insertionIndex < 0) {
            insertionIndex = insertionIndex * -1 - 1;
        }
        mPreferenceList.add(insertionIndex, preference);
    }
    preference.onAttachedToHierarchy(getPreferenceManager());
    if (mAttachedToActivity) {
        preference.onAttachedToActivity();
    }
    notifyHierarchyChanged();
    return true;
}",1,"/**
 * Adds a {@link Preference} at the correct position based on the
 * preference's order.
 *
 * @param preference The preference to add.
 * @return Whether the preference is now in this group.
 */
","/**
 * Adds a {@link Preference} at the correct position based on the
 * preference's order.
 *
 * @param preference The preference to add.
 * @return Whether the preference is now in this group.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 4",0,"The change is within the synchronized block, where the initialization and calculation of the insertionIndex are moved inside the synchronized block. It is considered a control dependency change (3) because the scope of synchronization has increased, which denotes a structural change in terms of concurrency control. Additionally, statements have been reorganized (4) to enhance thread safety, but the statements themselves have not fundamentally changed in functionality.","There is no Compatibility Issue here because the functional behavior and the return value of the method have not been altered. The method's contract remains the same, and it will return the same result given the same conditions as before. The synchronization change ensures thread safety but does not affect the external behavior visible to the API consumers."
279,<android.view.View.MeasureSpec: int getMode(int)>,23,24,<android.view.View.MeasureSpec: int getMode(int)>,<android.view.View.MeasureSpec: int getMode(int)>,0,"{
    return (measureSpec & MODE_MASK);
}","{
    // noinspection ResourceType
    return (measureSpec & MODE_MASK);
}",1,"/**
 * Extracts the mode from the supplied measure specification.
 *
 * @param measureSpec the measure specification to extract the mode from
 * @return {@link android.view.View.MeasureSpec#UNSPECIFIED},
 * {@link android.view.View.MeasureSpec#AT_MOST} or
 * {@link android.view.View.MeasureSpec#EXACTLY}
 */
","/**
 * Extracts the mode from the supplied measure specification.
 *
 * @param measureSpec the measure specification to extract the mode from
 * @return {@link android.view.View.MeasureSpec#UNSPECIFIED},
 * {@link android.view.View.MeasureSpec#AT_MOST} or
 * {@link android.view.View.MeasureSpec#EXACTLY}
 */
",-1,,[@MeasureSpecMode],-1,-1,-1,-1,-1,-1,0,0,There is no change in the functional part of the code. Annotations change or comments addition does not affect the execution or outcome of the method.,There is no Compatibility Issue since the implementation of the method has not changed.
281,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,23,24,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return 0;
    }
    try {
        return sGlobals.mService.getHeightHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getHeightHint();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the desired minimum height for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum height.
 *
 * If the returned value is <= 0, the caller should use the height of
 * the default display instead.
 *
 * @return The desired minimum height for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
","/**
 * Returns the desired minimum height for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum height.
 *
 * If the returned value is <= 0, the caller should use the height of
 * the default display instead.
 *
 * @return The desired minimum height for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"Exception handling statement changed from returning 0 to throwing a new RuntimeException when `sGlobals.mService` is null. Moreover, the catch statement has changed from returning 0 to throwing e.rethrowFromSystemServer(), which relates to a Dependent API change as well because the behavior of the service has changed and this can affect the exception thrown. Therefore, the code changes involve type 2 and type 5 (due to the behavior of the RemoteException).","Compatibility Issue type 2 is detected because the early version returns a value of 0 when an exception is caught or when the service is null, while the late version throws an exception in both of these cases. This leads to a change in exception handling that can break existing client code which relies on the method returning a value rather than throwing an exception."
282,"<android.app.admin.DevicePolicyManager: void setAutoTimeRequired(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setAutoTimeRequired(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setAutoTimeRequired(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setAutoTimeRequired(admin, required);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setAutoTimeRequired"");
    if (mService != null) {
        try {
            mService.setAutoTimeRequired(admin, required);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a device owner to set whether auto time is required. If auto time is
 * required the user cannot set the date and time, but has to use network date and time.
 *
 * <p>Note: if auto time is required the user can still manually set the time zone.
 *
 * <p>The calling device admin must be a device owner. If it is not, a security exception will
 * be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param required Whether auto time is set required or not.
 */
","/**
 * Called by a device owner to set whether auto time is required. If auto time is required the
 * user cannot set the date and time, but has to use network date and time.
 * <p>
 * Note: if auto time is required the user can still manually set the time zone.
 * <p>
 * The calling device admin must be a device owner. If it is not, a security exception will be
 * thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param required Whether auto time is set required or not.
 * @throws SecurityException if {@code admin} is not a device owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The late version introduces a new throw statement with throwIfParentInstance(""setAutoTimeRequired"") and modifies the exception handling by changing Log.w(TAG, ""Failed talking with device policy service"", e); to throw e.rethrowFromSystemServer(); which indicates changes in type 2, 4. The method mService.setAutoTimeRequired(admin, required) is also part of a dependent API as the try-catch wraps around its invocation which is checked for exceptions, so the change is also of type 5.","The early version of the API catches all exceptions and logs them, avoiding the propagation of RemoteException. The late version throws the RemoteException via e.rethrowFromSystemServer() which changes the exception handling behavior of the API, introducing a CI of type 2. The addition of the throwIfParentInstance method call before the try block could also result in a new Runtime exception being thrown, which wasn't present in the early version, so the late version may also throw an exception before reaching the previous logic. This also contributes to the CI of type 2."
283,<android.nfc.cardemulation.CardEmulation: CardEmulation getInstance(NfcAdapter)>,23,24,<android.nfc.cardemulation.CardEmulation: CardEmulation getInstance(NfcAdapter)>,<android.nfc.cardemulation.CardEmulation: CardEmulation getInstance(NfcAdapter)>,0,"{
    if (adapter == null)
        throw new NullPointerException(""NfcAdapter is null"");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, ""NfcAdapter context is null."");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, ""Cannot get PackageManager"");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
                Log.e(TAG, ""This device does not support card emulation"");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, ""PackageManager query failed."");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        if (service == null) {
            Log.e(TAG, ""This device does not implement the INfcCardEmulation interface."");
            throw new UnsupportedOperationException();
        }
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}","{
    if (adapter == null)
        throw new NullPointerException(""NfcAdapter is null"");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, ""NfcAdapter context is null."");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, ""Cannot get PackageManager"");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION, 0)) {
                Log.e(TAG, ""This device does not support card emulation"");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, ""PackageManager query failed."");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        if (service == null) {
            Log.e(TAG, ""This device does not implement the INfcCardEmulation interface."");
            throw new UnsupportedOperationException();
        }
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}",1,"/**
 * Helper to get an instance of this class.
 *
 * @param adapter A reference to an NfcAdapter object.
 * @return
 */
","/**
 * Helper to get an instance of this class.
 *
 * @param adapter A reference to an NfcAdapter object.
 * @return
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method `pm.hasSystemFeature()` has had a parameter added in its call, changing from `pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)` to `pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION, 0)`. This signifies a change in a dependent API, so the code change type is 5.","There is no compatibility issue detected as the additional parameter `0` for the method `hasSystemFeature()` does not change the method's behavior in a way that affects the control flow or output of the `getInstance()` method. The supplied `0` is likely a default or version parameter that doesn't modify the semantic of the feature check for card emulation capability, and thus the existing application using this API would not be broken by this change. Therefore, the CI type is 0."
284,<android.app.Fragment: void performActivityCreated(Bundle)>,23,24,<android.app.Fragment: void performActivityCreated(Bundle)>,<android.app.Fragment: void performActivityCreated(Bundle)>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
    }
    mCalled = false;
    onActivityCreated(savedInstanceState);
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onActivityCreated()"");
    }
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchActivityCreated();
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
    }
    mState = ACTIVITY_CREATED;
    mCalled = false;
    onActivityCreated(savedInstanceState);
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onActivityCreated()"");
    }
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchActivityCreated();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is the introduction of a new statement `mState = ACTIVITY_CREATED;`. Therefore, the code change type is 4.","This newly introduced statement `mState = ACTIVITY_CREATED;` does not seem to affect the API's return value or the exception it might throw. Its purpose appears to handle the internal state change of the Fragment, which does not constitute a change in the behavior as perceived through the method's contract. As such, there should be no Compatibility Issue; the CI type is 0."
285,<android.widget.TextView: boolean canShare()>,23,24,<android.widget.TextView: boolean canShare()>,<android.widget.TextView: boolean canShare()>,0,"{
    return canCopy();
}","{
    if (!getContext().canStartActivityForResult() || !isDeviceProvisioned()) {
        return false;
    }
    return canCopy();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The late version implementation adds new control dependency statements `if` before calling `canCopy()`, which checks additional conditions, so the code change type is 3.","The newly added control statements entail a check that was not performed in the early version. If `getContext().canStartActivityForResult()` or `isDeviceProvisioned()` returns false, the late version will return false instead of possibly returning true. This change to control flow can lead to different return values based on new conditions, hence a CI of type 1."
286,"<android.view.ViewGroup: boolean onNestedPreFling(View,float,float)>",23,24,"<android.view.ViewGroup: boolean onNestedPreFling(View,float,float)>","<android.view.ViewGroup: boolean onNestedPreFling(View,float,float)>",0,"{
    return false;
}","{
    // Re-dispatch up the tree by default
    return dispatchNestedPreFling(velocityX, velocityY);
}",1,"/**
 * @inheritDoc
 */
","/**
 * @inheritDoc
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement is changed from a constant ""return false;"" to ""return dispatchNestedPreFling(velocityX, velocityY);"" which is a call to another method. This represents both a return statement change (1) and a dependency on another method, which means a Dependent API change (5).","The late version of the API will return the result of dispatchNestedPreFling(), which could be different from the constant false returned in the early version. Therefore, this is a compatibility issue of type 1, caused by a potential different return value."
287,"<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>",23,24,"<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>","<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>",0,"{
    checkPendingIntent(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
    }
}","{
    checkPendingIntent(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Registers a PendingIntent to be sent when a network is available which satisfies the given
 * {@link NetworkRequest}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)}.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 */
","/**
 * Registers a PendingIntent to be sent when a network is available which satisfies the given
 * {@link NetworkRequest}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)}.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from an empty catch block to one that throws a new exception (throw e.rethrowFromSystemServer()), so the code change type is 2.","This change introduces a different exception handling behavior because the late version of the API throws an exception while the early version does not. This could affect the calling code that may not expect an exception to be thrown. Hence, the CI type is 2."
288,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,23,24,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,0,"{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, ""text/*"", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, ""UTF-8"");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w(""ClippedData"", ""Failure loading text"", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // probably serves fairly well as a textual representation.
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return """";
}","{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, ""text/*"", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, ""UTF-8"");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w(""ClipData"", ""Failure loading text"", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // probably serves fairly well as a textual representation.
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return """";
}",1,"// BEGIN_INCLUDE(coerceToText)
","// BEGIN_INCLUDE(coerceToText)
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no changes in the implementation between the early version and the late version.,"Since there are no changes in the API implementation, no Compatibility Issue could arise."
290,<android.app.NotificationManager: void setNotificationPolicy(Policy)>,23,24,<android.app.NotificationManager: void setNotificationPolicy(Policy)>,<android.app.NotificationManager: void setNotificationPolicy(Policy)>,0,"{
    checkRequired(""policy"", policy);
    INotificationManager service = getService();
    try {
        service.setNotificationPolicy(mContext.getOpPackageName(), policy);
    } catch (RemoteException e) {
    }
}","{
    checkRequired(""policy"", policy);
    INotificationManager service = getService();
    try {
        service.setNotificationPolicy(mContext.getOpPackageName(), policy);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the current notification policy.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 *
 * @param policy The new desired policy.
 */
","/**
 * Sets the current notification policy.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 *
 * @param policy The new desired policy.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from an empty catch block to throwing an exception (throw e.rethrowFromSystemServer()), so the change type is 2.","Because the late version may throw an exception where the early version does not, this could lead to different exception handlings and cause a Compatibility Issue of type 2."
291,"<android.speech.tts.TextToSpeechService.AudioOutputParams: AudioOutputParams createFromV1ParamsBundle(Bundle,boolean)>",23,24,"<android.speech.tts.TextToSpeechService.AudioOutputParams: AudioOutputParams createFromV1ParamsBundle(Bundle,boolean)>","<android.speech.tts.TextToSpeechService.AudioOutputParams: AudioOutputParams createFromV1ParamsBundle(Bundle,boolean)>",0,"{
    if (paramsBundle == null) {
        return new AudioOutputParams();
    }
    AudioAttributes audioAttributes = (AudioAttributes) paramsBundle.getParcelable(Engine.KEY_PARAM_AUDIO_ATTRIBUTES);
    if (audioAttributes == null) {
        int streamType = paramsBundle.getInt(Engine.KEY_PARAM_STREAM, Engine.DEFAULT_STREAM);
        audioAttributes = (new AudioAttributes.Builder()).setLegacyStreamType(streamType).setContentType((isSpeech ? AudioAttributes.CONTENT_TYPE_SPEECH : AudioAttributes.CONTENT_TYPE_SONIFICATION)).build();
    }
    return new AudioOutputParams(paramsBundle.getInt(Engine.KEY_PARAM_SESSION_ID, AudioSystem.AUDIO_SESSION_ALLOCATE), paramsBundle.getFloat(Engine.KEY_PARAM_VOLUME, Engine.DEFAULT_VOLUME), paramsBundle.getFloat(Engine.KEY_PARAM_PAN, Engine.DEFAULT_PAN), audioAttributes);
}","{
    if (paramsBundle == null) {
        return new AudioOutputParams();
    }
    AudioAttributes audioAttributes = (AudioAttributes) paramsBundle.getParcelable(Engine.KEY_PARAM_AUDIO_ATTRIBUTES);
    if (audioAttributes == null) {
        int streamType = paramsBundle.getInt(Engine.KEY_PARAM_STREAM, Engine.DEFAULT_STREAM);
        audioAttributes = (new AudioAttributes.Builder()).setLegacyStreamType(streamType).setContentType((isSpeech ? AudioAttributes.CONTENT_TYPE_SPEECH : AudioAttributes.CONTENT_TYPE_SONIFICATION)).build();
    }
    return new AudioOutputParams(paramsBundle.getInt(Engine.KEY_PARAM_SESSION_ID, AudioManager.AUDIO_SESSION_ID_GENERATE), paramsBundle.getFloat(Engine.KEY_PARAM_VOLUME, Engine.DEFAULT_VOLUME), paramsBundle.getFloat(Engine.KEY_PARAM_PAN, Engine.DEFAULT_PAN), audioAttributes);
}",1,"/**
 * Create AudioOutputParams from A {@link SynthesisRequest#getParams()} bundle
 */
","/**
 * Create AudioOutputParams from A {@link SynthesisRequest#getParams()} bundle
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only in a constant value from `AudioSystem.AUDIO_SESSION_ALLOCATE` to `AudioManager.AUDIO_SESSION_ID_GENERATE` within the new `AudioOutputParams` object creation. This is a change in a constant value passed as a parameter, so the change type is 4.","Since the change is just in the default value for the session ID parameter, and it doesn't change the semantics of how the method behaves (it still returns an `AudioOutputParams` object with expected fields), it does not cause any API to throw a different exception or return a different variable(value or type), thus there is No Compatibility Issue."
293,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumSymbols(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumSymbols(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of symbols required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of symbols required in the
 * password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the minimum number of
 * symbols required in the password. After setting this, the user will not be able to enter a
 * new password that is not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does not take place
 * immediately. To prompt the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is
 * only imposed if the administrator has also requested {@link #PASSWORD_QUALITY_COMPLEX} with
 * {@link #setPasswordQuality}. The default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of symbols required in the password. A value of
 * 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The method setPasswordMinimumSymbols called within the try block has changed number of parameters by including an additional parameter mParentInstance. Also, the RemoteException catch block now throws an exception instead of just logging it. This includes exception handling statement changed (2), other statement changed (4) because of the new parameter, and dependent API changed (5) due to the change in the dependent method signature.","The change in the exception handling could cause a different behavior since now the method rethrows the exception instead of logging it, which could cause the caller of this API to have to handle this exception differently or crash if not caught. Therefore, the type of CI is 2."
295,<android.app.Notification.WearableExtender: Builder extend(Builder)>,23,24,<android.app.Notification.WearableExtender: Builder extend(Builder)>,<android.app.Notification.WearableExtender: Builder extend(Builder)>,0,"{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    if (mHintScreenTimeout != 0) {
        wearableBundle.putInt(KEY_HINT_SCREEN_TIMEOUT, mHintScreenTimeout);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}","{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    if (mHintScreenTimeout != 0) {
        wearableBundle.putInt(KEY_HINT_SCREEN_TIMEOUT, mHintScreenTimeout);
    }
    if (mDismissalId != null) {
        wearableBundle.putString(KEY_DISMISSAL_ID, mDismissalId);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}",1,"/**
 * Apply wearable extensions to a notification that is being built. This is typically
 * called by the {@link android.app.Notification.Builder#extend} method of
 * {@link android.app.Notification.Builder}.
 */
","/**
 * Apply wearable extensions to a notification that is being built. This is typically
 * called by the {@link android.app.Notification.Builder#extend} method of
 * {@link android.app.Notification.Builder}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"One new bundle put operation (wearableBundle.putString(KEY_DISMISSAL_ID, mDismissalId);) has been added in the late version without changing any other logic. Thus, the change type is 1 for the new return statement and 4 for the additional bundle operation, which involves no control flow or exception handling changes.","The addition of a new bundle entry with key KEY_DISMISSAL_ID can lead to a different state of the Bundle object that is put into the builder's extras. Therefore, the API potentially returns a different value (the modified Builder object) compared to the earlier version. This qualifies as a Compatibility Issue type 1."
296,<android.content.pm.LauncherApps: void unregisterCallback(Callback)>,23,24,<android.content.pm.LauncherApps: void unregisterCallback(Callback)>,<android.content.pm.LauncherApps: void unregisterCallback(Callback)>,0,"{
    synchronized (this) {
        removeCallbackLocked(callback);
        if (mCallbacks.size() == 0) {
            try {
                mService.removeOnAppsChangedListener(mAppsChangedListener);
            } catch (RemoteException re) {
            }
        }
    }
}","{
    synchronized (this) {
        removeCallbackLocked(callback);
        if (mCallbacks.size() == 0) {
            try {
                mService.removeOnAppsChangedListener(mAppsChangedListener);
            } catch (RemoteException re) {
                throw re.rethrowFromSystemServer();
            }
        }
    }
}",1,"/**
 * Unregisters a callback that was previously registered.
 *
 * @param callback The callback to unregister.
 * @see #registerCallback(Callback)
 */
","/**
 * Unregisters a callback that was previously registered.
 *
 * @param callback The callback to unregister.
 * @see #registerCallback(Callback)
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling has changed from doing nothing in case of a RemoteException to throwing the exception using re.rethrowFromSystemServer(), which represents a change in exception handling, hence the code change type is 2.","The change in the exception handling statement means that RemoteExceptions could potentially be propagated outside the method, whereas previously they were ignored. This results in a difference in behavior when an exception occurs, therefore the CI is of type 2."
298,<android.app.Notification.Builder: Notification build()>,23,24,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    if (mSmallIcon != null) {
        mSmallIcon.convertToAshmem();
    }
    if (mLargeIcon != null) {
        mLargeIcon.convertToAshmem();
    }
    mOriginatingUserId = mContext.getUserId();
    mHasThreeLines = hasThreeLines();
    Notification n = buildUnstyled();
    if (mStyle != null) {
        mStyle.purgeResources();
        n = mStyle.buildStyled(n);
    }
    if (mExtras != null) {
        n.extras.putAll(mExtras);
    }
    if (mRebuildBundle.size() > 0) {
        n.extras.putAll(mRebuildBundle);
        mRebuildBundle.clear();
    }
    populateExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    mHasThreeLines = false;
    return n;
}","{
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.buildStyled(mN);
    }
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (mStyle == null || !mStyle.displayCustomViewInline())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    return mN;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The build method has significant changes in the implementation: changes in the way extras are added, the process of building 'Notification n' object has been altered, a creation time has been added, and the workflow of the method has overall been restructured which includes changes in control flow and other statements. This indicates changes of type 1 (Return statement changed), 3 (Control dependency changed), and 4 (Other statement changed).","The changes in the build method would lead to different 'Notification' objects being returned. For instance, the setting of 'creationTime' and the new way of adding extras can lead to 'Notification' objects with different content. As a result, the potential behavior of the API will differ, which means the CI type is 1 (CI caused by potential different return values or types)."
299,"<android.app.Dialog: boolean onPreparePanel(int,View,Menu)>",23,24,"<android.app.Dialog: boolean onPreparePanel(int,View,Menu)>","<android.app.Dialog: boolean onPreparePanel(int,View,Menu)>",0,"{
    if (featureId == Window.FEATURE_OPTIONS_PANEL && menu != null) {
        boolean goforit = onPrepareOptionsMenu(menu);
        return goforit && menu.hasVisibleItems();
    }
    return true;
}","{
    if (featureId == Window.FEATURE_OPTIONS_PANEL && menu != null) {
        return onPrepareOptionsMenu(menu) && menu.hasVisibleItems();
    }
    return true;
}",1,"/**
 * @see Activity#onPreparePanel(int, View, Menu)
 */
","/**
 * @see Activity#onPreparePanel(int, View, Menu)
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change consists of removing the temporary boolean variable ""goforit"" and returning the result of the method call and boolean expression directly. This is just a simplification of the code without changing the logic, thus the change type is 4.","There is no compatibility issue here because this change does not affect the behavior of the method. The conditions that determine the return value remain unchanged and thus will yield the same result in both versions. Therefore, the CI type is 0."
300,<android.text.style.SuggestionSpan: String getLocale()>,23,24,<android.text.style.SuggestionSpan: String getLocale()>,<android.text.style.SuggestionSpan: String getLocale()>,0,"{
    return mLocaleString;
}","{
    return mLocaleStringForCompatibility;
}",1,"/**
 * @return the locale of the suggestions
 */
","/**
 * @deprecated use {@link #getLocaleObject()} instead.
 * @return the locale of the suggestions. An empty string is returned if no locale is specified.
 */
",-1,,"[@NonNull, @Deprecated]",-1,-1,-1,-1,-1,-1,"1,4",1,"The field from which the return value is obtained has changed from mLocaleString to mLocaleStringForCompatibility. This is a change in the return statement and in a field within the same class, so it is classified as types 1 and 4.","The change in the field from which the value is returned (`mLocaleString` to `mLocaleStringForCompatibility`) will make the API potentially return a different value; therefore, there is a Compatibility Issue caused by potential different return values or types, which is CI type 1."
301,<android.content.ContentProviderClient: void finalize()>,23,24,<android.content.ContentProviderClient: void finalize()>,<android.content.ContentProviderClient: void finalize()>,0,"{
    if (mGuard != null) {
        mGuard.warnIfOpen();
    }
}","{
    try {
        mCloseGuard.warnIfOpen();
        close();
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The implementation has changed with the addition of a try-finally block, a call to close(), and a call to super.finalize(). Moreover, there is an alteration in the method called on the guard object: from mGuard.warnIfOpen() to mCloseGuard.warnIfOpen(). These are classified under 'Other statement changed.' Additionally, the addition of the try-finally block introduces exception handling statements, so it is also classified as 'Exception handling statement changed.'","The introduction of the close() method inside the try block could potentially throw exceptions that were not thrown in the early version, this creates a Compatibility Issue. Furthermore, calling super.finalize() changes the behavior of the finalization process, which also potentially affects how exceptions are handled. Therefore, the CI type is 2."
302,<android.os.Environment: File getDownloadCacheDirectory()>,23,24,<android.os.Environment: File getDownloadCacheDirectory()>,<android.os.Environment: File getDownloadCacheDirectory()>,0,"{
    return DOWNLOAD_CACHE_DIRECTORY;
}","{
    return DIR_DOWNLOAD_CACHE;
}",1,"/**
 * Return the download/cache content directory.
 */
","/**
 * Return the download/cache content directory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The return value has changed from DOWNLOAD_CACHE_DIRECTORY to DIR_DOWNLOAD_CACHE, which is an instance of a different variable, therefore representing another statement change; the change type is 4.","Although the code change is minimal, it alters the actual File object being returned as the variable name has changed, so there's the possibility of a different return value. Therefore, the potential for a Compatibility Issue is identified as type 1."
304,"<android.view.LayoutInflater: View createViewFromTag(View,String,Context,AttributeSet,boolean)>",23,24,"<android.view.LayoutInflater: View createViewFromTag(View,String,Context,AttributeSet,boolean)>","<android.view.LayoutInflater: View createViewFromTag(View,String,Context,AttributeSet,boolean)>",0,"{
    if (name.equals(""view"")) {
        name = attrs.getAttributeValue(null, ""class"");
    }
    // Apply a theme wrapper, if allowed and one is specified.
    if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
    }
    if (name.equals(TAG_1995)) {
        // Let's party like it's 1995!
        return new BlinkLayout(context, attrs);
    }
    try {
        View view;
        if (mFactory2 != null) {
            view = mFactory2.onCreateView(parent, name, context, attrs);
        } else if (mFactory != null) {
            view = mFactory.onCreateView(name, context, attrs);
        } else {
            view = null;
        }
        if (view == null && mPrivateFactory != null) {
            view = mPrivateFactory.onCreateView(parent, name, context, attrs);
        }
        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf('.')) {
                    view = onCreateView(parent, name, attrs);
                } else {
                    view = createView(name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }
        return view;
    } catch (InflateException e) {
        throw e;
    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name);
        ie.initCause(e);
        throw ie;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name);
        ie.initCause(e);
        throw ie;
    }
}","{
    if (name.equals(""view"")) {
        name = attrs.getAttributeValue(null, ""class"");
    }
    // Apply a theme wrapper, if allowed and one is specified.
    if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
    }
    if (name.equals(TAG_1995)) {
        // Let's party like it's 1995!
        return new BlinkLayout(context, attrs);
    }
    try {
        View view;
        if (mFactory2 != null) {
            view = mFactory2.onCreateView(parent, name, context, attrs);
        } else if (mFactory != null) {
            view = mFactory.onCreateView(name, context, attrs);
        } else {
            view = null;
        }
        if (view == null && mPrivateFactory != null) {
            view = mPrivateFactory.onCreateView(parent, name, context, attrs);
        }
        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf('.')) {
                    view = onCreateView(parent, name, attrs);
                } else {
                    view = createView(name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }
        return view;
    } catch (InflateException e) {
        throw e;
    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    }
}",1,"/**
 * Creates a view from a tag name using the supplied attribute set.
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 *
 * @param parent the parent view, used to inflate layout params
 * @param name the name of the XML tag used to define the view
 * @param context the inflation context for the view, typically the
 * {@code parent} or base layout inflater context
 * @param attrs the attribute set for the XML tag used to define the view
 * @param ignoreThemeAttr {@code true} to ignore the {@code android:theme}
 * attribute (if set) for the view being inflated,
 * {@code false} otherwise
 */
","/**
 * Creates a view from a tag name using the supplied attribute set.
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 *
 * @param parent the parent view, used to inflate layout params
 * @param name the name of the XML tag used to define the view
 * @param context the inflation context for the view, typically the
 * {@code parent} or base layout inflater context
 * @param attrs the attribute set for the XML tag used to define the view
 * @param ignoreThemeAttr {@code true} to ignore the {@code android:theme}
 * attribute (if set) for the view being inflated,
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The code change involves the exception handling for `ClassNotFoundException` and `Exception` where the constructors for `InflateException` are modified to include the exception cause directly, and setting the stack trace to `EMPTY_STACK_TRACE` is added. This classifies as an Exception handling statement changed (2), and also an Other statement changed (4), due to the additional method call `setStackTrace(EMPTY_STACK_TRACE)`.","When a `ClassNotFoundException` or other `Exception` is thrown, the handling of the exception has changed, potentially causing a different stack trace to be produced in the thrown `InflateException`. Therefore, this constitutes a Compatibility Issue caused by potential different exception handlings (2), as the stack trace information consumers receive from the exception can be different."
307,"<android.app.admin.DevicePolicyManager: boolean resetPassword(String,int)>",23,24,"<android.app.admin.DevicePolicyManager: boolean resetPassword(String,int)>","<android.app.admin.DevicePolicyManager: boolean resetPassword(String,int)>",0,"{
    if (mService != null) {
        try {
            return mService.resetPassword(password, flags);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""resetPassword"");
    if (mService != null) {
        try {
            return mService.resetPassword(password, flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Force a new device unlock password (the password needed to access the
 * entire device, not for individual accounts) on the user.  This takes
 * effect immediately.
 * The given password must be sufficient for the
 * current password quality and length constraints as returned by
 * {@link #getPasswordQuality(ComponentName)} and
 * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet
 * these constraints, then it will be rejected and false returned.  Note
 * that the password may be a stronger quality (containing alphanumeric
 * characters when the requested quality is only numeric), in which case
 * the currently active quality will be increased to match.
 *
 * <p>Calling with a null or empty password will clear any existing PIN,
 * pattern or password if the current password constraints allow it.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * <p>Calling this from a managed profile will throw a security exception.
 *
 * @param password The new password for the user. Null or empty clears the password.
 * @param flags May be 0 or combination of {@link #RESET_PASSWORD_REQUIRE_ENTRY} and
 * {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT}.
 * @return Returns true if the password was applied, or false if it is
 * not acceptable for the current constraints.
 */
","/**
 * Force a new device unlock password (the password needed to access the entire device, not for
 * individual accounts) on the user. This takes effect immediately.
 * <p>
 * <em>Note: This API has been limited as of {@link android.os.Build.VERSION_CODES#N} for
 * device admins that are not device owner and not profile owner.
 * The password can now only be changed if there is currently no password set.  Device owner
 * and profile owner can still do this when user is unlocked and does not have a managed
 * profile.</em>
 * <p>
 * The given password must be sufficient for the current password quality and length constraints
 * as returned by {@link #getPasswordQuality(ComponentName)} and
 * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet these constraints, then
 * it will be rejected and false returned. Note that the password may be a stronger quality
 * (containing alphanumeric characters when the requested quality is only numeric), in which
 * case the currently active quality will be increased to match.
 * <p>
 * Calling with a null or empty password will clear any existing PIN, pattern or password if the
 * current password constraints allow it. <em>Note: This will not work in
 * {@link android.os.Build.VERSION_CODES#N} and later for managed profiles, or for device admins
 * that are not device owner or profile owner.  Once set, the password cannot be changed to null
 * or empty except by these admins.</em>
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 *
 * @param password The new password for the user. Null or empty clears the password.
 * @param flags May be 0 or combination of {@link #RESET_PASSWORD_REQUIRE_ENTRY} and
 * {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT}.
 * @return Returns true if the password was applied, or false if it is not acceptable for the
 * current constraints or if the user has not been decrypted yet.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD}
 * @throws IllegalStateException if the calling user is locked or has a managed profile.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early and late implementations have an additional method call, `throwIfParentInstance(""resetPassword"")`, before the main `if` block, which constitutes type 4. Additionally, a dependent method `throwIfParentInstance` is called, which is classified as type 5.","The newly introduced statement `throwIfParentInstance(""resetPassword"")` does not cause a compatibility issue because it is a precondition check and if successful, the rest of the code executes as in the previous version. The return values and exception handling remain unchanged assuming the precondition check passes. Therefore, there is no compatibility issue in this change, which is type 0."
308,"<android.content.res.Resources: CharSequence getText(int,CharSequence)>",23,24,"<android.content.res.Resources: CharSequence getText(int,CharSequence)>","<android.content.res.Resources: CharSequence getText(int,CharSequence)>",0,"{
    CharSequence res = id != 0 ? mAssets.getResourceText(id) : null;
    return res != null ? res : def;
}","{
    CharSequence res = id != 0 ? mResourcesImpl.getAssets().getResourceText(id) : null;
    return res != null ? res : def;
}",1,"/**
 * Return the string value associated with a particular resource ID.  The
 * returned object will be a String if this is a plain string; it will be
 * some other type of CharSequence if it is styled.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @param def The default CharSequence to return.
 *
 * @return CharSequence The string data associated with the resource, plus
 * possibly styled text information, or def if id is 0 or not found.
 */
","/**
 * Return the string value associated with a particular resource ID.  The
 * returned object will be a String if this is a plain string; it will be
 * some other type of CharSequence if it is styled.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @param def The default CharSequence to return.
 *
 * @return CharSequence The string data associated with the resource, plus
 * possibly styled text information, or def if id is 0 or not found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call mAssets.getResourceText(id) has been changed to mResourcesImpl.getAssets().getResourceText(id). This indicates a change to the way the assets are accessed, which could be a change to a dependent API. Therefore, the code change type is 4 for the other statement changed, and 5 for the dependent API changed.","Although there is a change to the dependent API, there is no indication that the behavior of getResourceText(id) has been altered. Both the early and late versions return 'res' if it is not null and 'def' if 'res' is null. Hence, there is no compatibility issue based on the provided information, so the CI type is 0."
309,<android.content.pm.LauncherApps.CallbackMessageHandler: void handleMessage(Message)>,23,24,<android.content.pm.LauncherApps.CallbackMessageHandler: void handleMessage(Message)>,<android.content.pm.LauncherApps.CallbackMessageHandler: void handleMessage(Message)>,0,"{
    if (mCallback == null || !(msg.obj instanceof CallbackInfo)) {
        return;
    }
    CallbackInfo info = (CallbackInfo) msg.obj;
    switch(msg.what) {
        case MSG_ADDED:
            mCallback.onPackageAdded(info.packageName, info.user);
            break;
        case MSG_REMOVED:
            mCallback.onPackageRemoved(info.packageName, info.user);
            break;
        case MSG_CHANGED:
            mCallback.onPackageChanged(info.packageName, info.user);
            break;
        case MSG_AVAILABLE:
            mCallback.onPackagesAvailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_UNAVAILABLE:
            mCallback.onPackagesUnavailable(info.packageNames, info.user, info.replacing);
            break;
    }
}","{
    if (mCallback == null || !(msg.obj instanceof CallbackInfo)) {
        return;
    }
    CallbackInfo info = (CallbackInfo) msg.obj;
    switch(msg.what) {
        case MSG_ADDED:
            mCallback.onPackageAdded(info.packageName, info.user);
            break;
        case MSG_REMOVED:
            mCallback.onPackageRemoved(info.packageName, info.user);
            break;
        case MSG_CHANGED:
            mCallback.onPackageChanged(info.packageName, info.user);
            break;
        case MSG_AVAILABLE:
            mCallback.onPackagesAvailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_UNAVAILABLE:
            mCallback.onPackagesUnavailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_SUSPENDED:
            mCallback.onPackagesSuspended(info.packageNames, info.user);
            break;
        case MSG_UNSUSPENDED:
            mCallback.onPackagesUnsuspended(info.packageNames, info.user);
            break;
        case MSG_SHORTCUT_CHANGED:
            mCallback.onShortcutsChanged(info.packageName, info.shortcuts, info.user);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"New 'case' statements for MSG_SUSPENDED, MSG_UNSUSPENDED, and MSG_SHORTCUT_CHANGED are added to the 'switch' control structure, which represents a control dependency change. Additionally, new callback method calls are introduced within those cases, contributing to other statement changes; hence, the code change types are 3 and 4.","Despite the added functionality through the new 'case' blocks, the behavior of the existing API has not changed when existing cases are matched. The modifications do not impact existing code paths and only provide additional behaviors for new cases that would previously have no effect. As such, there is no Compatibility Issue as existing clients invoking this API will observe the same behavior for previously handled 'msg.what' values. The added functionality does not introduce incompatibilities with previous versions for calls to handleMessage with previously known 'msg.what' values."
310,<android.content.res.Resources.Theme: int getAppliedStyleResId()>,23,24,<android.content.res.Resources.Theme: int getAppliedStyleResId()>,<android.content.res.Resources.Theme: int getAppliedStyleResId()>,0,"{
    return mThemeResId;
}","{
    return mThemeImpl.getAppliedStyleResId();
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from directly returning a member variable mThemeResId to calling a method of another object mThemeImpl.getAppliedStyleResId(), so the code change type is 1,5.","This change in the return statement will make the API potentially return a different value since it no longer returns the direct member variable but the result of a method call on another object, so the CI type is 1."
311,"<android.content.pm.PackageInstaller: void updateSessionAppLabel(int,CharSequence)>",23,24,"<android.content.pm.PackageInstaller: void updateSessionAppLabel(int,CharSequence)>","<android.content.pm.PackageInstaller: void updateSessionAppLabel(int,CharSequence)>",0,"{
    try {
        final String val = (appLabel != null) ? appLabel.toString() : null;
        mInstaller.updateSessionAppLabel(sessionId, val);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        final String val = (appLabel != null) ? appLabel.toString() : null;
        mInstaller.updateSessionAppLabel(sessionId, val);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Update the label representing the app being installed in a specific
 * session.
 *
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
","/**
 * Update the label representing the app being installed in a specific
 * session.
 *
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement change from ""throw e.rethrowAsRuntimeException();"" in the early version to ""throw e.rethrowFromSystemServer();"" in the late version. Thus, the change type is 2.","The way of handling the RemoteException has been changed which may lead the method to throw a different exception than before. Therefore, a Compatibility Issue caused by potential different exception handlings could arise, indicated by the CI type 2."
312,<android.view.inputmethod.InputMethodManager: boolean isFullscreenMode()>,23,24,<android.view.inputmethod.InputMethodManager: boolean isFullscreenMode()>,<android.view.inputmethod.InputMethodManager: boolean isFullscreenMode()>,0,"{
    return mFullscreenMode;
}","{
    synchronized (mH) {
        return mFullscreenMode;
    }
}",1,"/**
 * Allows you to discover whether the attached input method is running
 * in fullscreen mode.  Return true if it is fullscreen, entirely covering
 * your UI, else returns false.
 */
","/**
 * Allows you to discover whether the attached input method is running
 * in fullscreen mode.  Return true if it is fullscreen, entirely covering
 * your UI, else returns false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is the addition of a synchronized block around the return statement. So, the change type is 4 (Other statement changed).","The introduction of synchronization does not alter the behavior or the output of the method itself; the returned value remains the same. Therefore, there is no Compatibility Issue, as the method still returns the same value (mFullscreenMode). The synchronization only affects the thread-safety of the method access."
314,"<android.os.DropBoxManager: Entry getNextEntry(String,long)>",23,24,"<android.os.DropBoxManager: Entry getNextEntry(String,long)>","<android.os.DropBoxManager: Entry getNextEntry(String,long)>",0,"{
    try {
        return mService.getNextEntry(tag, msec);
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return mService.getNextEntry(tag, msec);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the next entry from the drop box <em>after</em> the specified time.
 * Requires <code>android.permission.READ_LOGS</code>.  You must always call
 * {@link Entry#close()} on the return value!
 *
 * @param tag of entry to look for, null for all tags
 * @param msec time of the last entry seen
 * @return the next entry, or null if there are no more entries
 */
","/**
 * Gets the next entry from the drop box <em>after</em> the specified time.
 * Requires <code>android.permission.READ_LOGS</code>.  You must always call
 * {@link Entry#close()} on the return value!
 *
 * @param tag of entry to look for, null for all tags
 * @param msec time of the last entry seen
 * @return the next entry, or null if there are no more entries
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed: the late version throws a RuntimeException wrapping the RemoteException instead of returning null when RemoteException is caught, so the code change type is 2.","Given that the late version of the method now throws an exception instead of returning null, the behavior when an exception is encountered has changed. Consequently, this introduces a potential Compatibility Issue related to exception handling. The API in the late version can result in an application crash instead of handling a null return value, so the CI type is 2."
315,<android.app.admin.DevicePolicyManager: long getPasswordExpirationTimeout(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: long getPasswordExpirationTimeout(ComponentName)>,<android.app.admin.DevicePolicyManager: long getPasswordExpirationTimeout(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordExpirationTimeout(admin, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    if (mService != null) {
        try {
            return mService.getPasswordExpirationTimeout(admin, myUserId(), mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}",1,"/**
 * Get the password expiration timeout for the given admin. The expiration timeout is the
 * recurring expiration timeout provided in the call to
 * {@link #setPasswordExpirationTimeout(ComponentName, long)} for the given admin or the
 * aggregate of all policy administrators if {@code admin} is null.
 *
 * @param admin The name of the admin component to check, or {@code null} to aggregate all admins.
 * @return The timeout for the given admin or the minimum of all timeouts
 */
","/**
 * Get the password expiration timeout for the given admin. The expiration timeout is the
 * recurring expiration timeout provided in the call to
 * {@link #setPasswordExpirationTimeout(ComponentName, long)} for the given admin or the
 * aggregate of all participating policy administrators if {@code admin} is null. Admins that
 * have set restrictions on profiles that have a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to aggregate all admins.
 * @return The timeout for the given admin or the minimum of all timeouts
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The method signature of the call inside the try block has changed to include an additional argument (mService.getPasswordExpirationTimeout(admin, myUserId(), mParentInstance)) and the catch block no longer logs the exception, it now throws it with a different method (throw e.rethrowFromSystemServer()). Therefore, there are changes in the dependent API as well as the exception handling statement, resulting in the change types being 2,5.","The change in the method signature could potentially lead to a different behavior since an extra argument is passed now, and the way the exception is handled has also changed from logging to throwing, which means the exceptions will be propagated differently. This could cause the API to both return different values or types (due to the method signature change) and throw exceptions differently, hence the CI type is 1,2."
316,<android.app.Notification.Builder: Builder addPerson(String)>,23,24,<android.app.Notification.Builder: Builder addPerson(String)>,<android.app.Notification.Builder: Builder addPerson(String)>,0,"{
    mPeople.add(uri);
    return this;
}","{
    mPersonList.add(uri);
    return this;
}",1,"/**
 * Add a person that is relevant to this notification.
 *
 * <P>
 * Depending on user preferences, this annotation may allow the notification to pass
 * through interruption filters, and to appear more prominently in the user interface.
 * </P>
 *
 * <P>
 * The person should be specified by the {@code String} representation of a
 * {@link android.provider.ContactsContract.Contacts#CONTENT_LOOKUP_URI}.
 * </P>
 *
 * <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema
 * URIs.  The path part of these URIs must exist in the contacts database, in the
 * appropriate column, or the reference will be discarded as invalid. Telephone schema
 * URIs will be resolved by {@link android.provider.ContactsContract.PhoneLookup}.
 * </P>
 *
 * @param uri A URI for the person.
 * @see Notification#EXTRA_PEOPLE
 */
","/**
 * Add a person that is relevant to this notification.
 *
 * <P>
 * Depending on user preferences, this annotation may allow the notification to pass
 * through interruption filters, and to appear more prominently in the user interface.
 * </P>
 *
 * <P>
 * The person should be specified by the {@code String} representation of a
 * {@link android.provider.ContactsContract.Contacts#CONTENT_LOOKUP_URI}.
 * </P>
 *
 * <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema
 * URIs.  The path part of these URIs must exist in the contacts database, in the
 * appropriate column, or the reference will be discarded as invalid. Telephone schema
 * URIs will be resolved by {@link android.provider.ContactsContract.PhoneLookup}.
 * </P>
 *
 * @param uri A URI for the person.
 * @see Notification#EXTRA_PEOPLE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The name of the list that the URI gets added to has changed from 'mPeople' to 'mPersonList', which is classified as Other statement changed. Since the method's functionality of adding a person to a list remains the same with a different internal representation, it means there is a Dependent API changed as well.","Although there is a change in the internal state by renaming the list, this does not affect the external behavior of the API with respect to the method signature, return type or exceptions thrown. As the method would still perform the same action and return 'this' builder object allowing for method chaining, it does not introduce any Compatibility Issue."
317,"<android.app.FragmentManagerImpl: boolean popBackStackState(Handler,String,int,int)>",23,24,"<android.app.FragmentManagerImpl: boolean popBackStackState(Handler,String,int,int)>","<android.app.FragmentManagerImpl: boolean popBackStackState(Handler,String,int,int)>",0,"{
    if (mBackStack == null) {
        return false;
    }
    if (name == null && id < 0 && (flags & POP_BACK_STACK_INCLUSIVE) == 0) {
        int last = mBackStack.size() - 1;
        if (last < 0) {
            return false;
        }
        final BackStackRecord bss = mBackStack.remove(last);
        SparseArray<Fragment> firstOutFragments = new SparseArray<Fragment>();
        SparseArray<Fragment> lastInFragments = new SparseArray<Fragment>();
        bss.calculateBackFragments(firstOutFragments, lastInFragments);
        bss.popFromBackStack(true, null, firstOutFragments, lastInFragments);
        reportBackStackChanged();
    } else {
        int index = -1;
        if (name != null || id >= 0) {
            // If a name or ID is specified, look for that place in
            // the stack.
            index = mBackStack.size() - 1;
            while (index >= 0) {
                BackStackRecord bss = mBackStack.get(index);
                if (name != null && name.equals(bss.getName())) {
                    break;
                }
                if (id >= 0 && id == bss.mIndex) {
                    break;
                }
                index--;
            }
            if (index < 0) {
                return false;
            }
            if ((flags & POP_BACK_STACK_INCLUSIVE) != 0) {
                index--;
                // Consume all following entries that match.
                while (index >= 0) {
                    BackStackRecord bss = mBackStack.get(index);
                    if ((name != null && name.equals(bss.getName())) || (id >= 0 && id == bss.mIndex)) {
                        index--;
                        continue;
                    }
                    break;
                }
            }
        }
        if (index == mBackStack.size() - 1) {
            return false;
        }
        final ArrayList<BackStackRecord> states = new ArrayList<BackStackRecord>();
        for (int i = mBackStack.size() - 1; i > index; i--) {
            states.add(mBackStack.remove(i));
        }
        final int LAST = states.size() - 1;
        SparseArray<Fragment> firstOutFragments = new SparseArray<Fragment>();
        SparseArray<Fragment> lastInFragments = new SparseArray<Fragment>();
        for (int i = 0; i <= LAST; i++) {
            states.get(i).calculateBackFragments(firstOutFragments, lastInFragments);
        }
        BackStackRecord.TransitionState state = null;
        for (int i = 0; i <= LAST; i++) {
            if (DEBUG)
                Log.v(TAG, ""Popping back stack state: "" + states.get(i));
            state = states.get(i).popFromBackStack(i == LAST, state, firstOutFragments, lastInFragments);
        }
        reportBackStackChanged();
    }
    return true;
}","{
    if (mBackStack == null) {
        return false;
    }
    if (name == null && id < 0 && (flags & POP_BACK_STACK_INCLUSIVE) == 0) {
        int last = mBackStack.size() - 1;
        if (last < 0) {
            return false;
        }
        final BackStackRecord bss = mBackStack.remove(last);
        SparseArray<Fragment> firstOutFragments = new SparseArray<Fragment>();
        SparseArray<Fragment> lastInFragments = new SparseArray<Fragment>();
        if (mCurState >= Fragment.CREATED) {
            bss.calculateBackFragments(firstOutFragments, lastInFragments);
        }
        bss.popFromBackStack(true, null, firstOutFragments, lastInFragments);
        reportBackStackChanged();
    } else {
        int index = -1;
        if (name != null || id >= 0) {
            // If a name or ID is specified, look for that place in
            // the stack.
            index = mBackStack.size() - 1;
            while (index >= 0) {
                BackStackRecord bss = mBackStack.get(index);
                if (name != null && name.equals(bss.getName())) {
                    break;
                }
                if (id >= 0 && id == bss.mIndex) {
                    break;
                }
                index--;
            }
            if (index < 0) {
                return false;
            }
            if ((flags & POP_BACK_STACK_INCLUSIVE) != 0) {
                index--;
                // Consume all following entries that match.
                while (index >= 0) {
                    BackStackRecord bss = mBackStack.get(index);
                    if ((name != null && name.equals(bss.getName())) || (id >= 0 && id == bss.mIndex)) {
                        index--;
                        continue;
                    }
                    break;
                }
            }
        }
        if (index == mBackStack.size() - 1) {
            return false;
        }
        final ArrayList<BackStackRecord> states = new ArrayList<BackStackRecord>();
        for (int i = mBackStack.size() - 1; i > index; i--) {
            states.add(mBackStack.remove(i));
        }
        final int LAST = states.size() - 1;
        SparseArray<Fragment> firstOutFragments = new SparseArray<Fragment>();
        SparseArray<Fragment> lastInFragments = new SparseArray<Fragment>();
        if (mCurState >= Fragment.CREATED) {
            for (int i = 0; i <= LAST; i++) {
                states.get(i).calculateBackFragments(firstOutFragments, lastInFragments);
            }
        }
        BackStackRecord.TransitionState state = null;
        for (int i = 0; i <= LAST; i++) {
            if (DEBUG)
                Log.v(TAG, ""Popping back stack state: "" + states.get(i));
            state = states.get(i).popFromBackStack(i == LAST, state, firstOutFragments, lastInFragments);
        }
        reportBackStackChanged();
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
318,<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int[])>,23,24,<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int[])>,<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int[])>,0,"{
    final int len = attrs.length;
    final TypedArray array = TypedArray.obtain(Resources.this, len);
    array.mTheme = this;
    AssetManager.applyStyle(mTheme, 0, 0, 0, attrs, array.mData, array.mIndices);
    return array;
}","{
    return mThemeImpl.obtainStyledAttributes(this, null, attrs, 0, 0);
}",1,"/**
 * Return a TypedArray holding the values defined by
 * <var>Theme</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param attrs The desired attributes.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int, int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
","/**
 * Return a TypedArray holding the values defined by
 * <var>Theme</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param attrs The desired attributes.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int, int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation is changed completely with different method calls: `TypedArray.obtain` and `AssetManager.applyStyle` are replaced with `mThemeImpl.obtainStyledAttributes`. Since the underlying implementation is shifted to another object (`mThemeImpl`), this change falls under the 'Other statement changed' and 'Dependent API changed' categories.","There is no specific change in the method's contract regarding the return type or exception handling. The return type remains `TypedArray` in both versions, and there is no evidence from the given code that exceptions thrown or values returned might be different. It appears that the internal implementation details have been refactored. Thus, there would be no Compatibility Issue as per the provided information."
319,<android.app.WallpaperManager: void setStream(InputStream)>,23,24,<android.app.WallpaperManager: void setStream(InputStream)>,<android.app.WallpaperManager: void setStream(InputStream)>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName());
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    setStream(bitmapData, null, true);
}",1,"/**
 * Change the current system wallpaper to a specific byte stream.  The
 * give InputStream is copied into persistent storage and will now be
 * used as the wallpaper.  Currently it must be either a JPEG or PNG
 * image.  On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param data A stream containing the raw data to install as a wallpaper.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to a specific byte stream.  The
 * give InputStream is copied into persistent storage and will now be
 * used as the wallpaper.  Currently it must be either a JPEG or PNG
 * image.  On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * <p>This method is equivalent to calling
 * {@link #setStream(InputStream, Rect, boolean)} and passing {@code null} for the
 * {@code visibleCrop} rectangle and {@code true} for the {@code allowBackup}
 * parameter.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmapData A stream containing the raw data to install as a wallpaper.  This
 * data can be in any format handled by {@link BitmapRegionDecoder}.
 *
 * @throws IOException If an error occurs when attempting to set the wallpaper
 * based on the provided image data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has significantly changed, replacing the entire block of code with a single method call to setStream(bitmapData, null, true), so the code change type is 1,5.","The old implementation and the new implementation differ greatly, changing from direct interaction with the WallpaperService and file streams to internal handling with a different method call. Since it's impossible to determine the internal implementation of `setStream(bitmapData, null, true)`, we must assume it contains a different logic, therefore the CI type is 1 due to the different potential return values or types."
320,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",23,24,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",0,"{
    if (DBG)
        Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""],"" + offset + "","" + length + "")"");
    if (length > getMaxBufferSize() || length <= 0) {
        throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)"");
    }
    SynthesisPlaybackQueueItem item = null;
    synchronized (mStateLock) {
        if (mItem == null) {
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            return errorCodeOnStop();
        }
        item = mItem;
    }
    // Sigh, another copy.
    final byte[] bufferCopy = new byte[length];
    System.arraycopy(buffer, offset, bufferCopy, 0, length);
    // be consumed.
    try {
        item.put(bufferCopy);
    } catch (InterruptedException ie) {
        synchronized (mStateLock) {
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
    }
    mLogger.onEngineDataReceived();
    return TextToSpeech.SUCCESS;
}","{
    if (DBG)
        Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""],"" + offset + "","" + length + "")"");
    if (length > getMaxBufferSize() || length <= 0) {
        throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)"");
    }
    SynthesisPlaybackQueueItem item = null;
    synchronized (mStateLock) {
        if (mItem == null) {
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            return errorCodeOnStop();
        }
        item = mItem;
    }
    // Sigh, another copy.
    final byte[] bufferCopy = new byte[length];
    System.arraycopy(buffer, offset, bufferCopy, 0, length);
    mDispatcher.dispatchOnAudioAvailable(bufferCopy);
    // be consumed.
    try {
        item.put(bufferCopy);
    } catch (InterruptedException ie) {
        synchronized (mStateLock) {
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
    }
    mLogger.onEngineDataReceived();
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change between these two versions is the addition of the method call `mDispatcher.dispatchOnAudioAvailable(bufferCopy);`. This code change is an addition of a method call that is not a return statement, exception handling statement, or a control dependency change, so the code change type is 4.","The addition of the `mDispatcher.dispatchOnAudioAvailable(bufferCopy);` method call does not alter the return value or exception throwing behavior of the `audioAvailable` method. It seems to be a callback that notifies an event dispatcher that audio is available, which should not affect the success or error state of this method. Therefore, this change does not introduce a compatibility issue, and the CI type is 0."
322,<android.service.notification.ZenModeConfig.ScheduleInfo: boolean equals(Object)>,23,24,<android.service.notification.ZenModeConfig.ScheduleInfo: boolean equals(Object)>,<android.service.notification.ZenModeConfig.ScheduleInfo: boolean equals(Object)>,0,"{
    if (!(o instanceof ScheduleInfo))
        return false;
    final ScheduleInfo other = (ScheduleInfo) o;
    return toDayList(days).equals(toDayList(other.days)) && startHour == other.startHour && startMinute == other.startMinute && endHour == other.endHour && endMinute == other.endMinute;
}","{
    if (!(o instanceof ScheduleInfo))
        return false;
    final ScheduleInfo other = (ScheduleInfo) o;
    return toDayList(days).equals(toDayList(other.days)) && startHour == other.startHour && startMinute == other.startMinute && endHour == other.endHour && endMinute == other.endMinute && exitAtAlarm == other.exitAtAlarm;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"A new condition 'exitAtAlarm == other.exitAtAlarm' is added to the return statement, therefore there's a change in the Other statement and the Return statement, which is classified as types 1 and 4.","The addition of a new condition in the return statement will alter the behavior of the equals method, potentially causing a change in the boolean result returned, thereby causing a Compatibility Issue of type 1."
324,<android.widget.TextView: float getLeftFadingEdgeStrength()>,23,24,<android.widget.TextView: float getLeftFadingEdgeStrength()>,<android.widget.TextView: float getLeftFadingEdgeStrength()>,0,"{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                final float scroll = marquee.getScroll();
                return scroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    final int textDirection = mLayout.getParagraphDirection(0);
                    if (textDirection == Layout.DIR_LEFT_TO_RIGHT) {
                        return 0.0f;
                    } else {
                        return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                    }
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}","{
    if (isMarqueeFadeEnabled() && mMarquee != null && !mMarquee.isStopped()) {
        final Marquee marquee = mMarquee;
        if (marquee.shouldDrawLeftFade()) {
            return getHorizontalFadingEdgeStrength(marquee.getScroll(), 0.0f);
        } else {
            return 0.0f;
        }
    } else if (getLineCount() == 1) {
        final float lineLeft = getLayout().getLineLeft(0);
        if (lineLeft > mScrollX)
            return 0.0f;
        return getHorizontalFadingEdgeStrength(mScrollX, lineLeft);
    }
    return super.getLeftFadingEdgeStrength();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The control dependency and return statement changed by replacing mEllipsize comparison to the new method call isMarqueeFadeEnabled, modifying the way the horizontal fading edge strength is computed, and changing mLayout.getLineRight(0) to getLayout().getLineLeft(0). Additionally, method calls to getHorizontalFadingEdgeLength() has been changed to getHorizontalFadingEdgeStrength(). Finally, some constants and granular conditional checks (such as the switch-case and certain conditions) have been removed or altered. Dependent API calls changed (e.g., getHorizontalFadingEdgeStrength() with different parameters). The code change type is therefore 1,3,5.",These changes to control dependencies and the logic to calculate the fade strength could potentially change the return value of the method. The CI type is 1.
325,<android.view.inputmethod.InputMethodManager: void focusInLocked(View)>,23,24,<android.view.inputmethod.InputMethodManager: void focusInLocked(View)>,<android.view.inputmethod.InputMethodManager: void focusInLocked(View)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""focusIn: "" + view);
    if (mCurRootView != view.getRootView()) {
        // IME focus, so ignore it.
        if (DEBUG)
            Log.v(TAG, ""Not IME target window, ignoring"");
        return;
    }
    mNextServedView = view;
    scheduleCheckFocusLocked(view);
}","{
    if (DEBUG)
        Log.v(TAG, ""focusIn: "" + dumpViewInfo(view));
    if (view != null && view.isTemporarilyDetached()) {
        // This is a request from a view that is temporarily detached from a window.
        if (DEBUG)
            Log.v(TAG, ""Temporarily detached view, ignoring"");
        return;
    }
    if (mCurRootView != view.getRootView()) {
        // IME focus, so ignore it.
        if (DEBUG)
            Log.v(TAG, ""Not IME target window, ignoring"");
        return;
    }
    mNextServedView = view;
    scheduleCheckFocusLocked(view);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependencies and the return statements have been modified. An additional if condition (checking if view is not null and is temporarily detached) with an associated return statement was introduced. Additionally, the log message inside the debug statement changed as well, therefore the change type is 1,3.","Since a new condition has been added that can cause the method to exit early and with a different path, it could lead to the method returning earlier without setting 'mNextServedView' or calling 'scheduleCheckFocusLocked(view)' in situations where 'view.isTemporarilyDetached()' is true. Hence, this is a behavior change and could potentially return a different result when 'view' meets the new condition. The CI type is 1."
326,"<android.app.admin.DevicePolicyManager: void setMasterVolumeMuted(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setMasterVolumeMuted(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setMasterVolumeMuted(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setMasterVolumeMuted(admin, on);
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed to setMasterMute on device policy service"");
        }
    }
}","{
    throwIfParentInstance(""setMasterVolumeMuted"");
    if (mService != null) {
        try {
            mService.setMasterVolumeMuted(admin, on);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by profile or device owners to set the master volume mute on or off.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param on {@code true} to mute master volume, {@code false} to turn mute off.
 */
","/**
 * Called by profile or device owners to set the master volume mute on or off.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param on {@code true} to mute master volume, {@code false} to turn mute off.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The late implementation version added a new method call `throwIfParentInstance(""setMasterVolumeMuted"")` at the beginning of the method, and the exception handling logic changed from logging a warning to throwing an exception using `rethrowFromSystemServer()`. Hence, the changes are 2 (Exception handling statement changed) and 4 (Other statement changed).","With the addition of a new method call that could potentially throw an exception, and the change in exception handling from logging an error to throwing an exception on a RemoteException, there is a possibility of different exception behavior. This constitutes a CI of type 2, caused by the potential different exception handlings."
327,<android.widget.Editor.Blink: void run()>,23,24,<android.widget.Editor.Blink: void run()>,<android.widget.Editor.Blink: void run()>,0,"{
    if (mCancelled) {
        return;
    }
    removeCallbacks(Blink.this);
    if (shouldBlink()) {
        if (mTextView.getLayout() != null) {
            mTextView.invalidateCursorPath();
        }
        postAtTime(this, SystemClock.uptimeMillis() + BLINK);
    }
}","{
    if (mCancelled) {
        return;
    }
    mTextView.removeCallbacks(this);
    if (shouldBlink()) {
        if (mTextView.getLayout() != null) {
            mTextView.invalidateCursorPath();
        }
        mTextView.postDelayed(this, BLINK);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from using a general 'removeCallbacks' method to 'mTextView.removeCallbacks(this)', and from 'postAtTime(this, SystemClock.uptimeMillis() + BLINK)' to 'mTextView.postDelayed(this, BLINK)'. While these changes imply that the methods called are specific to mTextView, the behavior and logic of the API remain the same. These changes fall under 'Other statement changed' and 'Dependent API changed', which are code change types 4 and 5.","There is no Compatibility Issue detected because the logic of the code has not changed. The use of 'mTextView' is more explicit in terms of where the callbacks are added and removed, but it does not affect the behavior seen by the end-user of the API. The timing and condition for the blink functionality remain the same."
329,"<android.app.FragmentHostCallback: ArrayMap<String, LoaderManager> retainLoaderNonConfig()>",23,24,"<android.app.FragmentHostCallback: ArrayMap<String, LoaderManager> retainLoaderNonConfig()>","<android.app.FragmentHostCallback: ArrayMap<String, LoaderManager> retainLoaderNonConfig()>",0,"{
    boolean retainLoaders = false;
    if (mAllLoaderManagers != null) {
        // prune out any loader managers that were already stopped and so
        // have nothing useful to retain.
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = (LoaderManagerImpl) mAllLoaderManagers.valueAt(i);
        }
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            if (lm.mRetaining) {
                retainLoaders = true;
            } else {
                lm.doDestroy();
                mAllLoaderManagers.remove(lm.mWho);
            }
        }
    }
    if (retainLoaders) {
        return mAllLoaderManagers;
    }
    return null;
}","{
    boolean retainLoaders = false;
    if (mAllLoaderManagers != null) {
        // Restart any loader managers that were already stopped so that they
        // will be ready to retain
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = (LoaderManagerImpl) mAllLoaderManagers.valueAt(i);
        }
        final boolean doRetainLoaders = getRetainLoaders();
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            if (!lm.mRetaining && doRetainLoaders) {
                if (!lm.mStarted) {
                    lm.doStart();
                }
                lm.doRetain();
            }
            if (lm.mRetaining) {
                retainLoaders = true;
            } else {
                lm.doDestroy();
                mAllLoaderManagers.remove(lm.mWho);
            }
        }
    }
    if (retainLoaders) {
        return mAllLoaderManagers;
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The early version has no handling for starting and retaining loaders if they weren't already retaining, whereas the late version checks with getRetainLoaders() and may start and retain loaders. The late version also adds calls to doStart() and doRetain() methods on LoaderManagerImpl, which are new behaviors. The main structure of the method including the return statements is unchanged, but the operations performed within the loops are different. The change type is 3 due to control dependency change within the loops and 4 because of other statements introduced that alter behavior.","Even though there are changes in the inner workings of the method (with new calls to doStart() and doRetain()), the method's signature and its return type remain the same, and the decision paths leading to its return values have not been altered. The behavior of returning either mAllLoaderManagers or null is consistent in both implementations, so these changes do not necessarily lead to a compatibility issue since they don't affect the return type or value from an external perspective. Hence, there's no compatibility issue detected."
330,<android.app.admin.DevicePolicyManager: boolean getBluetoothContactSharingDisabled(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean getBluetoothContactSharingDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getBluetoothContactSharingDisabled(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getBluetoothContactSharingDisabled(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return true;
}","{
    throwIfParentInstance(""getBluetoothContactSharingDisabled"");
    if (mService != null) {
        try {
            return mService.getBluetoothContactSharingDisabled(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return true;
}",1,"/**
 * Called by a profile owner of a managed profile to determine whether or
 * not Bluetooth devices cannot access enterprise contacts.
 * <p>
 * The calling device admin must be a profile owner. If it is not, a
 * security exception will be thrown.
 * <p>
 * This API works on managed profile only.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 */
","/**
 * Called by a profile owner of a managed profile to determine whether or not Bluetooth devices
 * cannot access enterprise contacts.
 * <p>
 * The calling device admin must be a profile owner. If it is not, a security exception will be
 * thrown.
 * <p>
 * This API works on managed profile only.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"A new method throwIfParentInstance(""getBluetoothContactSharingDisabled"") has been introduced in the beginning of the late version, and exception handling statement changed from logging the exception to throwing it, which results in code change types 2 and 4.","The introduction of a throw statement at the beginning of the late version implementation can cause a new exception to be thrown, which did not occur in the early version. Furthermore, the change from logging an exception to re-throwing it with rethrowFromSystemServer() could also change the exception handling behavior, therefore, the CI type is 2."
331,"<android.app.admin.DevicePolicyManager: void setRestrictionsProvider(ComponentName,ComponentName)>",23,24,"<android.app.admin.DevicePolicyManager: void setRestrictionsProvider(ComponentName,ComponentName)>","<android.app.admin.DevicePolicyManager: void setRestrictionsProvider(ComponentName,ComponentName)>",0,"{
    if (mService != null) {
        try {
            mService.setRestrictionsProvider(admin, provider);
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed to set permission provider on device policy service"");
        }
    }
}","{
    throwIfParentInstance(""setRestrictionsProvider"");
    if (mService != null) {
        try {
            mService.setRestrictionsProvider(admin, provider);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Designates a specific service component as the provider for
 * making permission requests of a local or remote administrator of the user.
 * <p/>
 * Only a profile owner can designate the restrictions provider.
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param provider The component name of the service that implements
 * {@link RestrictionsReceiver}. If this param is null,
 * it removes the restrictions provider previously assigned.
 */
","/**
 * Designates a specific service component as the provider for making permission requests of a
 * local or remote administrator of the user.
 * <p/>
 * Only a profile owner can designate the restrictions provider.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param provider The component name of the service that implements
 * {@link RestrictionsReceiver}. If this param is null, it removes the restrictions
 * provider previously assigned.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"There is a new call to `throwIfParentInstance(""setRestrictionsProvider"");` inserted before the existing `if` statement, and an exception handling statement changed from logging an exception to throwing it. The new direct throw statement can affect the flow by directly throwing an exception where previously it was caught and logged. Therefore, the change types are 2 (Exception handling statement changed), 3 (Control dependency changed because a new method call that affects the flow of the program has been introduced), and 4 (Other statement changed with the introduction of a throw statement before the if condition).","The Compatibility Issue is caused by potential different exception handlings: the late version now throws an exception instead of logging it as in the early version. Additionally, the introduction of `throwIfParentInstance(""setRestrictionsProvider"");` could throw an exception before the `if` statement is evaluated, which could alter the flow of the method. Thus, the CI type is 2."
332,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean containsMetaDataAt(int)>,23,24,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean containsMetaDataAt(int)>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean containsMetaDataAt(int)>,0,"{
    return mIndexMetaData.containsKey(position);
}","{
    return mIndexMetaData.indexOfKey(position) >= 0;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement to check the existence of metadata at a certain position in the cache has changed from using `containsKey(position)` to `indexOfKey(position) >= 0`, which reflects a change in the method of querying the presence of a key within a data structure. Therefore, the code change type is 4 (Other statement changed).","There is no compatibility issue detected between these implementations because both versions effectively check for the presence of 'position' in 'mIndexMetaData.' Even though the method of checking is different, the end result (whether the key 'position' exists or not) remains consistent across both versions, which would not lead to a change in behavior from the perspective of an API consumer. Hence, the CI type is 0 (No Compatibility Issue)."
333,<android.widget.TimePickerClockDelegate: Parcelable onSaveInstanceState(Parcelable)>,23,24,<android.widget.TimePickerClockDelegate: Parcelable onSaveInstanceState(Parcelable)>,<android.widget.TimePickerClockDelegate: Parcelable onSaveInstanceState(Parcelable)>,0,"{
    return new SavedState(superState, getCurrentHour(), getCurrentMinute(), is24HourView(), inKbMode(), getTypedTimes(), getCurrentItemShowing());
}","{
    return new SavedState(superState, getHour(), getMinute(), is24Hour(), getCurrentItemShowing());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameters passed to the new SavedState constructor have changed between the two versions. The early implementation had parameters (superState, getCurrentHour(), getCurrentMinute(), is24HourView(), inKbMode(), getTypedTimes(), getCurrentItemShowing()). In contrast, the late implementation has parameters (superState, getHour(), getMinute(), is24Hour(), getCurrentItemShowing()). The methods used to retrieve the hour and minute values as well as the 24-hour mode status have been changed, and two parameters (inKbMode() and getTypedTimes()) have been removed entirely. The code change is 1 because the return value will be different with different parameters, and 5 because the underlying dependent APIs called have changed (getCurrentHour() -> getHour(), getCurrentMinute() -> getMinute(), is24HourView() -> is24Hour()). ","The change will lead to a different return value, since the number and nature of the parameters for the SavedState constructor have changed, leading to a SavedState instance that is constructed differently. Therefore, the CI type is 1 due to the different return values."
334,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,23,24,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,0,"{
    int[] rawInfoArray = getArrayStringInfo(id);
    int rawInfoArrayLen = rawInfoArray.length;
    final int infoArrayLen = rawInfoArrayLen / 2;
    int block;
    int index;
    CharSequence[] retArray = new CharSequence[infoArrayLen];
    for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
        block = rawInfoArray[i];
        index = rawInfoArray[i + 1];
        retArray[j] = index >= 0 ? mStringBlocks[block].get(index) : null;
    }
    return retArray;
}","{
    final int[] rawInfoArray = getArrayStringInfo(resId);
    final int rawInfoArrayLen = rawInfoArray.length;
    final int infoArrayLen = rawInfoArrayLen / 2;
    int block;
    int index;
    final CharSequence[] retArray = new CharSequence[infoArrayLen];
    for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
        block = rawInfoArray[i];
        index = rawInfoArray[i + 1];
        retArray[j] = index >= 0 ? mStringBlocks[block].get(index) : null;
    }
    return retArray;
}",1,"/*package*/
","/**
 * Retrieve the text array associated with a particular resource
 * identifier.
 *
 * @param resId the resource id of the string array
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The only change in the implementation is making some local variables final (`rawInfoArray`, `rawInfoArrayLen`, `infoArrayLen`, `retArray`), which is a change in the variable declaration but does not alter behavior. The logic, control flow, and return statement remain the same. Therefore, there is no change in the behavior of the code.",There is no Compatibility Issue since the changes in declarations with `final` keyword do not affect the return values or the exception handling of the API. The behavior remains identical between the two versions.
335,"<android.widget.Editor.TextActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",23,24,"<android.widget.Editor.TextActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>","<android.widget.Editor.TextActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",0,"{
    mode.setTitle(null);
    mode.setSubtitle(null);
    mode.setTitleOptionalHint(true);
    populateMenuWithItems(menu);
    Callback customCallback = getCustomCallback();
    if (customCallback != null) {
        if (!customCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode, dismiss selection.
            Selection.setSelection((Spannable) mTextView.getText(), mTextView.getSelectionEnd());
            return false;
        }
    }
    if (mTextView.canProcessText()) {
        mProcessTextIntentActionsHandler.onInitializeMenu(menu);
    }
    if (menu.hasVisibleItems() || mode.getCustomView() != null) {
        mTextView.setHasTransientState(true);
        return true;
    } else {
        return false;
    }
}","{
    mode.setTitle(null);
    mode.setSubtitle(null);
    mode.setTitleOptionalHint(true);
    populateMenuWithItems(menu);
    Callback customCallback = getCustomCallback();
    if (customCallback != null) {
        if (!customCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode, dismiss selection.
            Selection.setSelection((Spannable) mTextView.getText(), mTextView.getSelectionEnd());
            return false;
        }
    }
    if (mTextView.canProcessText()) {
        mProcessTextIntentActionsHandler.onInitializeMenu(menu);
    }
    if (menu.hasVisibleItems() || mode.getCustomView() != null) {
        if (mHasSelection && !mTextView.hasTransientState()) {
            mTextView.setHasTransientState(true);
        }
        return true;
    } else {
        return false;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"An additional control dependency has been introduced in the form of an 'if' statement, which checks (mHasSelection && !mTextView.hasTransientState()) before calling mTextView.setHasTransientState(true). Thus, it is a control dependency change.","There is no change in what the method potentially returns or the exceptions it throws. The added condition merely restricts when setHasTransientState(true) is called, but it will not change the return value or exception throwing behavior of the method. Therefore, there is no Compatibility Issue."
339,"<android.app.FragmentManagerImpl: View onCreateView(View,String,Context,AttributeSet)>",23,24,"<android.app.FragmentManagerImpl: View onCreateView(View,String,Context,AttributeSet)>","<android.app.FragmentManagerImpl: View onCreateView(View,String,Context,AttributeSet)>",0,"{
    if (!""fragment"".equals(name)) {
        return null;
    }
    String fname = attrs.getAttributeValue(null, ""class"");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Must specify unique android:id, android:tag, or have a parent with"" + "" an id for "" + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, ""onCreateView: id=0x"" + Integer.toHexString(id) + "" fname="" + fname + "" existing="" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(context, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = this;
        fragment.mHost = mHost;
        fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Duplicate id 0x"" + Integer.toHexString(id) + "", tag "" + tag + "", or parent id 0x"" + Integer.toHexString(containerId) + "" with another fragment for "" + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        }
    }
    // push the inflated child fragment along.
    if (mCurState < Fragment.CREATED && fragment.mFromLayout) {
        moveToState(fragment, Fragment.CREATED, 0, 0, false);
    } else {
        moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException(""Fragment "" + fname + "" did not create a view."");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}","{
    if (!""fragment"".equals(name)) {
        return null;
    }
    String fname = attrs.getAttributeValue(null, ""class"");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Must specify unique android:id, android:tag, or have a parent with"" + "" an id for "" + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, ""onCreateView: id=0x"" + Integer.toHexString(id) + "" fname="" + fname + "" existing="" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(context, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = this;
        fragment.mHost = mHost;
        fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Duplicate id 0x"" + Integer.toHexString(id) + "", tag "" + tag + "", or parent id 0x"" + Integer.toHexString(containerId) + "" with another fragment for "" + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        fragment.mHost = mHost;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        }
    }
    // push the inflated child fragment along.
    if (mCurState < Fragment.CREATED && fragment.mFromLayout) {
        moveToState(fragment, Fragment.CREATED, 0, 0, false);
    } else {
        moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException(""Fragment "" + fname + "" did not create a view."");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
340,"<android.app.WallpaperManager: Drawable getBuiltInDrawable(int,int,boolean,float,float)>",23,24,"<android.app.WallpaperManager: Drawable getBuiltInDrawable(int,int,boolean,float,float)>","<android.app.WallpaperManager: Drawable getBuiltInDrawable(int,int,boolean,float,float)>",0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return null;
    }
    Resources resources = mContext.getResources();
    horizontalAlignment = Math.max(0, Math.min(1, horizontalAlignment));
    verticalAlignment = Math.max(0, Math.min(1, verticalAlignment));
    InputStream is = new BufferedInputStream(openDefaultWallpaper(mContext));
    if (is == null) {
        Log.e(TAG, ""default wallpaper input stream is null"");
        return null;
    } else {
        if (outWidth <= 0 || outHeight <= 0) {
            Bitmap fullSize = BitmapFactory.decodeStream(is, null, null);
            return new BitmapDrawable(resources, fullSize);
        } else {
            int inWidth;
            int inHeight;
            {
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeStream(is, null, options);
                if (options.outWidth != 0 && options.outHeight != 0) {
                    inWidth = options.outWidth;
                    inHeight = options.outHeight;
                } else {
                    Log.e(TAG, ""default wallpaper dimensions are 0"");
                    return null;
                }
            }
            is = new BufferedInputStream(openDefaultWallpaper(mContext));
            RectF cropRectF;
            outWidth = Math.min(inWidth, outWidth);
            outHeight = Math.min(inHeight, outHeight);
            if (scaleToFit) {
                cropRectF = getMaxCropRect(inWidth, inHeight, outWidth, outHeight, horizontalAlignment, verticalAlignment);
            } else {
                float left = (inWidth - outWidth) * horizontalAlignment;
                float right = left + outWidth;
                float top = (inHeight - outHeight) * verticalAlignment;
                float bottom = top + outHeight;
                cropRectF = new RectF(left, top, right, bottom);
            }
            Rect roundedTrueCrop = new Rect();
            cropRectF.roundOut(roundedTrueCrop);
            if (roundedTrueCrop.width() <= 0 || roundedTrueCrop.height() <= 0) {
                Log.w(TAG, ""crop has bad values for full size image"");
                return null;
            }
            // See how much we're reducing the size of the image
            int scaleDownSampleSize = Math.min(roundedTrueCrop.width() / outWidth, roundedTrueCrop.height() / outHeight);
            // Attempt to open a region decoder
            BitmapRegionDecoder decoder = null;
            try {
                decoder = BitmapRegionDecoder.newInstance(is, true);
            } catch (IOException e) {
                Log.w(TAG, ""cannot open region decoder for default wallpaper"");
            }
            Bitmap crop = null;
            if (decoder != null) {
                // Do region decoding to get crop bitmap
                BitmapFactory.Options options = new BitmapFactory.Options();
                if (scaleDownSampleSize > 1) {
                    options.inSampleSize = scaleDownSampleSize;
                }
                crop = decoder.decodeRegion(roundedTrueCrop, options);
                decoder.recycle();
            }
            if (crop == null) {
                // BitmapRegionDecoder has failed, try to crop in-memory
                is = new BufferedInputStream(openDefaultWallpaper(mContext));
                Bitmap fullSize = null;
                if (is != null) {
                    BitmapFactory.Options options = new BitmapFactory.Options();
                    if (scaleDownSampleSize > 1) {
                        options.inSampleSize = scaleDownSampleSize;
                    }
                    fullSize = BitmapFactory.decodeStream(is, null, options);
                }
                if (fullSize != null) {
                    crop = Bitmap.createBitmap(fullSize, roundedTrueCrop.left, roundedTrueCrop.top, roundedTrueCrop.width(), roundedTrueCrop.height());
                }
            }
            if (crop == null) {
                Log.w(TAG, ""cannot decode default wallpaper"");
                return null;
            }
            // Scale down if necessary
            if (outWidth > 0 && outHeight > 0 && (crop.getWidth() != outWidth || crop.getHeight() != outHeight)) {
                Matrix m = new Matrix();
                RectF cropRect = new RectF(0, 0, crop.getWidth(), crop.getHeight());
                RectF returnRect = new RectF(0, 0, outWidth, outHeight);
                m.setRectToRect(cropRect, returnRect, Matrix.ScaleToFit.FILL);
                Bitmap tmp = Bitmap.createBitmap((int) returnRect.width(), (int) returnRect.height(), Bitmap.Config.ARGB_8888);
                if (tmp != null) {
                    Canvas c = new Canvas(tmp);
                    Paint p = new Paint();
                    p.setFilterBitmap(true);
                    c.drawBitmap(crop, m, p);
                    crop = tmp;
                }
            }
            return new BitmapDrawable(resources, crop);
        }
    }
}","{
    return getBuiltInDrawable(outWidth, outHeight, scaleToFit, horizontalAlignment, verticalAlignment, FLAG_SYSTEM);
}",1,"/**
 * Returns a drawable for the system built-in static wallpaper. Based on the parameters, the
 * drawable can be cropped and scaled
 *
 * @param outWidth The width of the returned drawable
 * @param outWidth The height of the returned drawable
 * @param scaleToFit If true, scale the wallpaper down rather than just cropping it
 * @param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
 * 0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
 * @param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
 * 0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
 */
","/**
 * Returns a drawable for the system built-in static wallpaper. Based on the parameters, the
 * drawable can be cropped and scaled
 *
 * @param outWidth The width of the returned drawable
 * @param outWidth The height of the returned drawable
 * @param scaleToFit If true, scale the wallpaper down rather than just cropping it
 * @param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
 * 0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
 * @param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
 * 0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
 * @return A Drawable presenting the built-in default system wallpaper image,
 * or {@code null} if no such default image is defined on this device.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
342,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,23,24,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,0,"{
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return toDeviceSet(mService.getBondedDevices());
        }
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return toDeviceSet(mService.getBondedDevices());
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}",1,"/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
","/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"3,4",0,"There's a change in the method of acquiring the lock from a simple synchronized block to using a ReentrantReadWriteLock (with mServiceLock.readLock().lock() and mServiceLock.readLock().unlock()). The return statements and exception handling statements remain unchanged. So the change types are 3 for the added control dependency of the locking mechanism, and 4 for the statements managing the locking mechanism.","No Compatibility Issue arises from these changes because they don't affect the return values or the exception handling of the method. The return values are the same when the Bluetooth state is not STATE_ON and when mService is not null. The method still returns null at the end and handles RemoteException the same way. The changes only introduce a different locking mechanism, which does not change how the method behaves from the perspective of an API consumer. Hence, the CI type is 0."
343,<android.hardware.radio.RadioManager.FmBandConfig.Builder: FmBandConfig build()>,23,24,<android.hardware.radio.RadioManager.FmBandConfig.Builder: FmBandConfig build()>,<android.hardware.radio.RadioManager.FmBandConfig.Builder: FmBandConfig build()>,0,"{
    FmBandConfig config = new FmBandConfig(mDescriptor.getRegion(), mDescriptor.getType(), mDescriptor.getLowerLimit(), mDescriptor.getUpperLimit(), mDescriptor.getSpacing(), mStereo, mRds, mTa, mAf);
    return config;
}","{
    FmBandConfig config = new FmBandConfig(mDescriptor.getRegion(), mDescriptor.getType(), mDescriptor.getLowerLimit(), mDescriptor.getUpperLimit(), mDescriptor.getSpacing(), mStereo, mRds, mTa, mAf, mEa);
    return config;
}",1,"/**
 * Combines all of the parameters that have been set and return a new
 * {@link FmBandConfig} object.
 * @return a new {@link FmBandConfig} object
 */
","/**
 * Combines all of the parameters that have been set and return a new
 * {@link FmBandConfig} object.
 * @return a new {@link FmBandConfig} object
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The constructor for `FmBandConfig` class has changed with the addition of a new parameter `mEa`. No return statement or exception handling statements have been changed, however, the construction of the `FmBandConfig` object with the new parameter may cause a different object to be created, so the code change type is 4,5.","Since the new constructor includes an additional parameter (`mEa`), this can result in the API returning an `FmBandConfig` object with different properties than in the earlier version, causing a CI type of 1."
344,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,23,24,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"{
    CameraCharacteristics characteristics = null;
    synchronized (mLock) {
        if (!getOrCreateDeviceIdListLocked().contains(cameraId)) {
            throw new IllegalArgumentException(String.format(""Camera id %s does not match any"" + "" currently connected camera device"", cameraId));
        }
        int id = Integer.valueOf(cameraId);
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                String[] outParameters = new String[1];
                cameraService.getLegacyParameters(id, /*out*/
                outParameters);
                String parameters = outParameters[0];
                CameraInfo info = new CameraInfo();
                cameraService.getCameraInfo(id, /*out*/
                info);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = new CameraMetadataNative();
                cameraService.getCameraCharacteristics(id, info);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}","{
    CameraCharacteristics characteristics = null;
    synchronized (mLock) {
        if (!getOrCreateDeviceIdListLocked().contains(cameraId)) {
            throw new IllegalArgumentException(String.format(""Camera id %s does not match any"" + "" currently connected camera device"", cameraId));
        }
        int id = Integer.parseInt(cameraId);
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(id);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4,5",0,There are both control dependency changes and other statement changes as well as dependent API changes. This includes:,- The change from catching `CameraRuntimeException` to `ServiceSpecificException` and corresponding handling change (other statement changed);
345,<android.app.ActivityManager.AppTask: void setExcludeFromRecents(boolean)>,23,24,<android.app.ActivityManager.AppTask: void setExcludeFromRecents(boolean)>,<android.app.ActivityManager.AppTask: void setExcludeFromRecents(boolean)>,0,"{
    try {
        mAppTaskImpl.setExcludeFromRecents(exclude);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Invalid AppTask"", e);
    }
}","{
    try {
        mAppTaskImpl.setExcludeFromRecents(exclude);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Modify the {@link Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS} flag in the root
 * Intent of this AppTask.
 *
 * @param exclude If true, {@link Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS} will
 * be set; otherwise, it will be cleared.
 */
","/**
 * Modify the {@link Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS} flag in the root
 * Intent of this AppTask.
 *
 * @param exclude If true, {@link Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS} will
 * be set; otherwise, it will be cleared.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. In the early version, it logs an error, while in the late version, it rethrows the exception with throw e.rethrowFromSystemServer(), so the change type is 2.","The change in exception handling could cause the late version of the API to throw a new exception where the early version did not, leading to a Compatibility Issue of type 2."
346,<android.util.Pair: boolean equals(Object)>,23,24,<android.util.Pair: boolean equals(Object)>,<android.util.Pair: boolean equals(Object)>,0,"{
    if (!(o instanceof Pair)) {
        return false;
    }
    Pair<?, ?> p = (Pair<?, ?>) o;
    return Objects.equal(p.first, first) && Objects.equal(p.second, second);
}","{
    if (!(o instanceof Pair)) {
        return false;
    }
    Pair<?, ?> p = (Pair<?, ?>) o;
    return Objects.equals(p.first, first) && Objects.equals(p.second, second);
}",1,"/**
 * Checks the two objects for equality by delegating to their respective
 * {@link Object#equals(Object)} methods.
 *
 * @param o the {@link Pair} to which this one is to be checked for equality
 * @return true if the underlying objects of the Pair are both considered
 * equal
 */
","/**
 * Checks the two objects for equality by delegating to their respective
 * {@link Object#equals(Object)} methods.
 *
 * @param o the {@link Pair} to which this one is to be checked for equality
 * @return true if the underlying objects of the Pair are both considered
 * equal
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method call within the return statement has changed from Objects.equal to Objects.equals, which represents a change in the dependent APIs being used, so the code change type is 5.","There is no compatibility issue because the change from Objects.equal to Objects.equals does not affect the outcome of the method as both are equivalent methods of comparing objects for equality in Java (Objects.equals is the correct static method in the Objects class). The change is likely an improvement of the code to use the correct method name. Therefore, the CI type is 0."
347,<android.content.res.ColorStateList: int getChangingConfigurations()>,23,24,<android.content.res.ColorStateList: int getChangingConfigurations()>,<android.content.res.ColorStateList: int getChangingConfigurations()>,0,"{
    return mChangingConfigurations;
}","{
    return super.getChangingConfigurations() | mChangingConfigurations;
}",1,"/**
 * Returns a mask of the configuration parameters for which this color
 * state list may change, requiring that it be re-created.
 *
 * @return a mask of the changing configuration parameters, as defined by
 * {@link android.content.pm.ActivityInfo}
 *
 * @see android.content.pm.ActivityInfo
 */
","/**
 * Returns a mask of the configuration parameters for which this color
 * state list may change, requiring that it be re-created.
 *
 * @return a mask of the changing configuration parameters, as defined by
 * {@link android.content.pm.ActivityInfo}
 *
 * @see android.content.pm.ActivityInfo
 */
",-1,,[@Config],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed from directly returning the member variable mChangingConfigurations to returning a bitwise OR between super.getChangingConfigurations() and mChangingConfigurations, which is also an application of the bitwise OR operator. Hence, it is classified as 1,4.","The change in the return statement could potentially lead to the method returning a different value in the late version because super.getChangingConfigurations() might add additional configuration bits not included in just mChangingConfigurations. Therefore, it's a CI of type 1 caused by potential different return values."
348,<android.app.Notification.Builder: Builder setSortKey(String)>,23,24,<android.app.Notification.Builder: Builder setSortKey(String)>,<android.app.Notification.Builder: Builder setSortKey(String)>,0,"{
    mSortKey = sortKey;
    return this;
}","{
    mN.mSortKey = sortKey;
    return this;
}",1,"/**
 * Set a sort key that orders this notification among other notifications from the
 * same package. This can be useful if an external sort was already applied and an app
 * would like to preserve this. Notifications will be sorted lexicographically using this
 * value, although providing different priorities in addition to providing sort key may
 * cause this value to be ignored.
 *
 * <p>This sort key can also be used to order members of a notification group. See
 * {@link #setGroup}.
 *
 * @see String#compareTo(String)
 */
","/**
 * Set a sort key that orders this notification among other notifications from the
 * same package. This can be useful if an external sort was already applied and an app
 * would like to preserve this. Notifications will be sorted lexicographically using this
 * value, although providing different priorities in addition to providing sort key may
 * cause this value to be ignored.
 *
 * <p>This sort key can also be used to order members of a notification group. See
 * {@link #setGroup}.
 *
 * @see String#compareTo(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The assignment statement has changed from directly assigning to the 'mSortKey' variable to assigning to 'mN.mSortKey'. This indicates a structure change in the class by which the 'sortKey' is encapsulated, therefore the code change type is 5.","As the assignment to 'sortKey' is still done within the same method and assuming the 'this' object's reference behavior is unchanged (just its internal structuring is refactored), it is unlikely that there is a compatibility issue related to different return values or exceptions thrown. Thus, the CI type is 0."
349,"<android.os.Binder: void dump(FileDescriptor,String[])>",23,24,"<android.os.Binder: void dump(FileDescriptor,String[])>","<android.os.Binder: void dump(FileDescriptor,String[])>",0,"{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    try {
        final String disabled;
        synchronized (Binder.class) {
            disabled = sDumpDisabled;
        }
        if (disabled == null) {
            try {
                dump(fd, pw, args);
            } catch (SecurityException e) {
                pw.println(""Security exception: "" + e.getMessage());
                throw e;
            } catch (Throwable e) {
                // Unlike usual calls, in this case if an exception gets thrown
                // back to us we want to print it back in to the dump data, since
                // that is where the caller expects all interesting information to
                // go.
                pw.println();
                pw.println(""Exception occurred while dumping:"");
                e.printStackTrace(pw);
            }
        } else {
            pw.println(sDumpDisabled);
        }
    } finally {
        pw.flush();
    }
}","{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    try {
        doDump(fd, pw, args);
    } finally {
        pw.flush();
    }
}",1,"/**
 * Implemented to call the more convenient version
 * {@link #dump(FileDescriptor, PrintWriter, String[])}.
 */
","/**
 * Implemented to call the more convenient version
 * {@link #dump(FileDescriptor, PrintWriter, String[])}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2",The code change includes:,- Removing exception handling for `SecurityException` and general `Throwable`.
351,<android.os.UserManager: boolean isUserRunningOrStopping(UserHandle)>,23,24,<android.os.UserManager: boolean isUserRunningOrStopping(UserHandle)>,<android.os.UserManager: boolean isUserRunningOrStopping(UserHandle)>,0,"{
    try {
        return ActivityManagerNative.getDefault().isUserRunning(user.getIdentifier(), true);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        // TODO: reconcile stopped vs stopping?
        return ActivityManagerNative.getDefault().isUserRunning(user.getIdentifier(), ActivityManager.FLAG_OR_STOPPED);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Return whether the given user is actively running <em>or</em> stopping.
 * This is like {@link #isUserRunning(UserHandle)}, but will also return
 * true if the user had been running but is in the process of being stopped
 * (but is not yet fully stopped, and still running some code).
 * @param user The user to retrieve the running state for.
 */
","/**
 * Return whether the given user is actively running <em>or</em> stopping.
 * This is like {@link #isUserRunning(UserHandle)}, but will also return
 * true if the user had been running but is in the process of being stopped
 * (but is not yet fully stopped, and still running some code).
 * @param user The user to retrieve the running state for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The parameters of the method call ActivityManagerNative.getDefault().isUserRunning() have changed, which is a change to a dependent API (5). The exception handling in the late version changes by throwing the exception upwards instead of simply returning false (2). Additionally, a previously existing return false statement is deleted in a try-catch block, which impacts what is returned (1). Thus, the code change type is 1,2,5.","The code change will make the API throw an exception where it would previously have caught the exception and returned false, creating a difference in exception handling (2). The API may also return a different value because ActivityManager.FLAG_OR_STOPPED may change the return value of isUserRunning compared to the boolean 'true' in the early implementation (1). Hence the CI type is 1,2."
352,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,23,24,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,0,"{
    FullBackup.BackupScheme backupScheme = FullBackup.getBackupScheme(this);
    if (!backupScheme.isFullBackupContentEnabled()) {
        return;
    }
    Map<String, Set<String>> manifestIncludeMap;
    ArraySet<String> manifestExcludeSet;
    try {
        manifestIncludeMap = backupScheme.maybeParseAndGetCanonicalIncludePaths();
        manifestExcludeSet = backupScheme.maybeParseAndGetCanonicalExcludePaths();
    } catch (IOException | XmlPullParserException e) {
        if (Log.isLoggable(FullBackup.TAG_XML_PARSER, Log.VERBOSE)) {
            Log.v(FullBackup.TAG_XML_PARSER, ""Exception trying to parse fullBackupContent xml file!"" + "" Aborting full backup."", e);
        }
        return;
    }
    final String packageName = getPackageName();
    final ApplicationInfo appInfo = getApplicationInfo();
    String rootDir = new File(appInfo.dataDir).getCanonicalPath();
    String filesDir = getFilesDir().getCanonicalPath();
    String nobackupDir = getNoBackupFilesDir().getCanonicalPath();
    String databaseDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    String sharedPrefsDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
    String cacheDir = getCacheDir().getCanonicalPath();
    String codeCacheDir = getCodeCacheDir().getCanonicalPath();
    String libDir = (appInfo.nativeLibraryDir != null) ? new File(appInfo.nativeLibraryDir).getCanonicalPath() : null;
    // Maintain a set of excluded directories so that as we traverse the tree we know we're not
    // going places we don't expect, and so the manifest includes can't take precedence over
    // what the framework decides is not to be included.
    final ArraySet<String> traversalExcludeSet = new ArraySet<String>();
    // Add the directories we always exclude.
    traversalExcludeSet.add(cacheDir);
    traversalExcludeSet.add(codeCacheDir);
    traversalExcludeSet.add(nobackupDir);
    if (libDir != null) {
        traversalExcludeSet.add(libDir);
    }
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.add(filesDir);
    // Root dir first.
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(rootDir);
    // Data dir next.
    traversalExcludeSet.remove(filesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DATA_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(filesDir);
    // Database directory.
    traversalExcludeSet.remove(databaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(databaseDir);
    // SharedPrefs.
    traversalExcludeSet.remove(sharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(sharedPrefsDir);
    // the log.
    if (Process.myUid() != Process.SYSTEM_UID) {
        File efLocation = getExternalFilesDir(null);
        if (efLocation != null) {
            applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.MANAGED_EXTERNAL_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
        }
    }
}","{
    FullBackup.BackupScheme backupScheme = FullBackup.getBackupScheme(this);
    if (!backupScheme.isFullBackupContentEnabled()) {
        return;
    }
    Map<String, Set<String>> manifestIncludeMap;
    ArraySet<String> manifestExcludeSet;
    try {
        manifestIncludeMap = backupScheme.maybeParseAndGetCanonicalIncludePaths();
        manifestExcludeSet = backupScheme.maybeParseAndGetCanonicalExcludePaths();
    } catch (IOException | XmlPullParserException e) {
        if (Log.isLoggable(FullBackup.TAG_XML_PARSER, Log.VERBOSE)) {
            Log.v(FullBackup.TAG_XML_PARSER, ""Exception trying to parse fullBackupContent xml file!"" + "" Aborting full backup."", e);
        }
        return;
    }
    final String packageName = getPackageName();
    final ApplicationInfo appInfo = getApplicationInfo();
    // System apps have control over where their default storage context
    // is pointed, so we're always explicit when building paths.
    final Context ceContext = createCredentialProtectedStorageContext();
    final String rootDir = ceContext.getDataDir().getCanonicalPath();
    final String filesDir = ceContext.getFilesDir().getCanonicalPath();
    final String noBackupDir = ceContext.getNoBackupFilesDir().getCanonicalPath();
    final String databaseDir = ceContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String sharedPrefsDir = ceContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final String cacheDir = ceContext.getCacheDir().getCanonicalPath();
    final String codeCacheDir = ceContext.getCodeCacheDir().getCanonicalPath();
    final Context deContext = createDeviceProtectedStorageContext();
    final String deviceRootDir = deContext.getDataDir().getCanonicalPath();
    final String deviceFilesDir = deContext.getFilesDir().getCanonicalPath();
    final String deviceNoBackupDir = deContext.getNoBackupFilesDir().getCanonicalPath();
    final String deviceDatabaseDir = deContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String deviceSharedPrefsDir = deContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final String deviceCacheDir = deContext.getCacheDir().getCanonicalPath();
    final String deviceCodeCacheDir = deContext.getCodeCacheDir().getCanonicalPath();
    final String libDir = (appInfo.nativeLibraryDir != null) ? new File(appInfo.nativeLibraryDir).getCanonicalPath() : null;
    // Maintain a set of excluded directories so that as we traverse the tree we know we're not
    // going places we don't expect, and so the manifest includes can't take precedence over
    // what the framework decides is not to be included.
    final ArraySet<String> traversalExcludeSet = new ArraySet<String>();
    // Add the directories we always exclude.
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.add(noBackupDir);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.add(cacheDir);
    traversalExcludeSet.add(codeCacheDir);
    traversalExcludeSet.add(deviceFilesDir);
    traversalExcludeSet.add(deviceNoBackupDir);
    traversalExcludeSet.add(deviceDatabaseDir);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    traversalExcludeSet.add(deviceCacheDir);
    traversalExcludeSet.add(deviceCodeCacheDir);
    if (libDir != null) {
        traversalExcludeSet.add(libDir);
    }
    // Root dir first.
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(rootDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceRootDir);
    // Data dir next.
    traversalExcludeSet.remove(filesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.remove(deviceFilesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceFilesDir);
    // Database directory.
    traversalExcludeSet.remove(databaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.remove(deviceDatabaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceDatabaseDir);
    // SharedPrefs.
    traversalExcludeSet.remove(sharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.remove(deviceSharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    // the log.
    if (Process.myUid() != Process.SYSTEM_UID) {
        File efLocation = getExternalFilesDir(null);
        if (efLocation != null) {
            applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.MANAGED_EXTERNAL_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
        }
    }
}",1,"/**
 * The application is having its entire file system contents backed up.  {@code data}
 * points to the backup destination, and the app has the opportunity to choose which
 * files are to be stored.  To commit a file as part of the backup, call the
 * {@link #fullBackupFile(File, FullBackupDataOutput)} helper method.  After all file
 * data is written to the output, the agent returns from this method and the backup
 * operation concludes.
 *
 * <p>Certain parts of the app's data are never backed up even if the app explicitly
 * sends them to the output:
 *
 * <ul>
 * <li>The contents of the {@link #getCacheDir()} directory</li>
 * <li>The contents of the {@link #getCodeCacheDir()} directory</li>
 * <li>The contents of the {@link #getNoBackupFilesDir()} directory</li>
 * <li>The contents of the app's shared library directory</li>
 * </ul>
 *
 * <p>The default implementation of this method backs up the entirety of the
 * application's ""owned"" file system trees to the output other than the few exceptions
 * listed above.  Apps only need to override this method if they need to impose special
 * limitations on which files are being stored beyond the control that
 * {@link #getNoBackupFilesDir()} offers.
 * Alternatively they can provide an xml resource to specify what data to include or exclude.
 *
 * @param data A structured wrapper pointing to the backup destination.
 * @throws IOException
 *
 * @see Context#getNoBackupFilesDir()
 * @see ApplicationInfo#fullBackupContent
 * @see #fullBackupFile(File, FullBackupDataOutput)
 * @see #onRestoreFile(ParcelFileDescriptor, long, File, int, long, long)
 */
","/**
 * The application is having its entire file system contents backed up.  {@code data}
 * points to the backup destination, and the app has the opportunity to choose which
 * files are to be stored.  To commit a file as part of the backup, call the
 * {@link #fullBackupFile(File, FullBackupDataOutput)} helper method.  After all file
 * data is written to the output, the agent returns from this method and the backup
 * operation concludes.
 *
 * <p>Certain parts of the app's data are never backed up even if the app explicitly
 * sends them to the output:
 *
 * <ul>
 * <li>The contents of the {@link #getCacheDir()} directory</li>
 * <li>The contents of the {@link #getCodeCacheDir()} directory</li>
 * <li>The contents of the {@link #getNoBackupFilesDir()} directory</li>
 * <li>The contents of the app's shared library directory</li>
 * </ul>
 *
 * <p>The default implementation of this method backs up the entirety of the
 * application's ""owned"" file system trees to the output other than the few exceptions
 * listed above.  Apps only need to override this method if they need to impose special
 * limitations on which files are being stored beyond the control that
 * {@link #getNoBackupFilesDir()} offers.
 * Alternatively they can provide an xml resource to specify what data to include or exclude.
 *
 * @param data A structured wrapper pointing to the backup destination.
 * @throws IOException
 *
 * @see Context#getNoBackupFilesDir()
 * @see ApplicationInfo#fullBackupContent
 * @see #fullBackupFile(File, FullBackupDataOutput)
 * @see #onRestoreFile(ParcelFileDescriptor, long, File, int, long, long)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
354,<android.bluetooth.BluetoothAdapter: boolean isOffloadedScanBatchingSupported()>,23,24,<android.bluetooth.BluetoothAdapter: boolean isOffloadedScanBatchingSupported()>,<android.bluetooth.BluetoothAdapter: boolean isOffloadedScanBatchingSupported()>,0,"{
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedScanBatchingSupported, error: "", e);
    }
    return false;
}","{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedScanBatchingSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if offloaded scan batching is supported
 *
 * @return true if chipset supports on-chip scan batching
 */
","/**
 * Return true if offloaded scan batching is supported
 *
 * @return true if chipset supports on-chip scan batching
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A lock mechanism is added using `mServiceLock.readLock().lock()` and `mServiceLock.readLock().unlock()` which indicates changes in control dependency (code change type 3), and with a `finally` block to ensure the unlocking which is an other statement change (code change type 4).","Although there has been a change in the usage of a locking mechanism, the semantics of the method behavior have not changed: the method still returns `false` if `getLeAccess()` is `false`, returns the result of `mService.isOffloadedScanBatchingSupported()` if no exception is thrown, and returns `false` if a `RemoteException` is caught. Given that the fundamental behavior and return values of this method have not been altered from the perspective of the caller, there is no compatibility issue (CI type 0)."
356,<android.net.ConnectivityManager: NetworkInfo getNetworkInfo(Network)>,23,24,<android.net.ConnectivityManager: NetworkInfo getNetworkInfo(Network)>,<android.net.ConnectivityManager: NetworkInfo getNetworkInfo(Network)>,0,"{
    try {
        return mService.getNetworkInfoForNetwork(network);
    } catch (RemoteException e) {
        return null;
    }
}","{
    return getNetworkInfoForUid(network, Process.myUid(), false);
}",1,"/**
 * Returns connection status information about a particular
 * Network.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param network {@link Network} specifying which network
 * in which you're interested.
 * @return a {@link NetworkInfo} object for the requested
 * network or {@code null} if the {@code Network}
 * is not valid.
 */
","/**
 * Returns connection status information about a particular
 * Network.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param network {@link Network} specifying which network
 * in which you're interested.
 * @return a {@link NetworkInfo} object for the requested
 * network or {@code null} if the {@code Network}
 * is not valid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation which calls another API has changed. The early version invokes mService.getNetworkInfoForNetwork(network) while the late version calls getNetworkInfoForUid(network, Process.myUid(), false), which is a different method with different parameters. Therefore, the code change type includes 1 (return statement changed) and 5 (dependent API changed).","Change in the dependent method being called (from getNetworkInfoForNetwork to getNetworkInfoForUid with additional parameters) potentially leads to different returned values. Thus, there is a compatibility issue caused by potential different return values, and the CI type is 1."
357,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,23,24,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int missingMethods = msg.arg1;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext, missingMethods) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int missingMethods = msg.arg1;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext, missingMethods) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
358,<android.app.ActivityManager: MemoryInfo[] getProcessMemoryInfo(int[])>,23,24,<android.app.ActivityManager: MemoryInfo[] getProcessMemoryInfo(int[])>,<android.app.ActivityManager: MemoryInfo[] getProcessMemoryInfo(int[])>,0,"{
    try {
        return ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return information about the memory usage of one or more processes.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @param pids The pids of the processes whose memory usage is to be
 * retrieved.
 * @return Returns an array of memory information, one for each
 * requested pid.
 */
","/**
 * Return information about the memory usage of one or more processes.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @param pids The pids of the processes whose memory usage is to be
 * retrieved.
 * @return Returns an array of memory information, one for each
 * requested pid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed: in the early version it returns null, while in the late version it throws a new exception, so the change type is 2.","Given that the exception handling behavior has altered—where it previously returned null, it now throws an exception—this change could lead to a different type of exception being thrown. As a result, the CI type is 2."
359,<android.net.LocalSocketImpl: void listen(int)>,23,24,<android.net.LocalSocketImpl: void listen(int)>,<android.net.LocalSocketImpl: void listen(int)>,0,"{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    listen_native(fd, backlog);
}","{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    try {
        Os.listen(fd, backlog);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The dependent API has changed from `listen_native(fd, backlog)` to `Os.listen(fd, backlog)` with an additional try-catch block that captures and re-throws an `ErrnoException` as an `IOException`. This results in an exception handling statement change and a dependent API change, so the code change type is 2,5.","The introduction of new exception handling for `ErrnoException` which didn't exist in the early version has the potential to alter the exceptions thrown by the API. Thus, the API could potentially throw different exceptions, and the CI type is 2."
361,"<android.view.View: boolean startDrag(ClipData,DragShadowBuilder,Object,int)>",23,24,"<android.view.View: boolean startDrag(ClipData,DragShadowBuilder,Object,int)>","<android.view.View: boolean startDrag(ClipData,DragShadowBuilder,Object,int)>",0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDrag: data="" + data + "" flags="" + flags);
    }
    boolean okay = false;
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    Surface surface = new Surface();
    try {
        IBinder token = mAttachInfo.mSession.prepareDrag(mAttachInfo.mWindow, flags, shadowSize.x, shadowSize.y, surface);
        if (ViewDebug.DEBUG_DRAG)
            Log.d(VIEW_LOG_TAG, ""prepareDrag returned token="" + token + "" surface="" + surface);
        if (token != null) {
            Canvas canvas = surface.lockCanvas(null);
            try {
                canvas.drawColor(0, PorterDuff.Mode.CLEAR);
                shadowBuilder.onDrawShadow(canvas);
            } finally {
                surface.unlockCanvasAndPost(canvas);
            }
            final ViewRootImpl root = getViewRootImpl();
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
            // repurpose 'shadowSize' for the last touch point
            root.getLastTouchPoint(shadowSize);
            okay = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, token, shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
            if (ViewDebug.DEBUG_DRAG)
                Log.d(VIEW_LOG_TAG, ""performDrag returned "" + okay);
            // Off and running!  Release our local surface instance; the drag
            // shadow surface is now managed by the system process.
            surface.release();
        }
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        surface.destroy();
    }
    return okay;
}","{
    return startDragAndDrop(data, shadowBuilder, myLocalState, flags);
}",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke startDrag() on any attached View object. The View object does not
 * need to be the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to
 * be related to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. This Object is put into every DragEvent object sent by the system during the
 * current drag.
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. No flags are currently defined,
 * so the parameter should be set to 0.
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag, and so no drag operation is in progress.
 */
","/**
 * @deprecated Use {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object, int)
 * startDragAndDrop()} for newer platform versions.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire method body of 'startDrag' has been replaced by a single return statement which calls startDragAndDrop(), so both the return statements and dependent API are changed. That's why the change type is 1,5.","This change might potentially return different values since the prior implementation did a lot of work and error handling before returning a value, and the new version delegates all work to startDragAndDrop() which could have a different implementation. Hence, there is the potential for Compatibility Issues due to different return values, making the CI type 1."
362,<android.net.LocalSocketImpl: void shutdownOutput()>,23,24,<android.net.LocalSocketImpl: void shutdownOutput()>,<android.net.LocalSocketImpl: void shutdownOutput()>,0,"{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    shutdown(fd, false);
}","{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    try {
        Os.shutdown(fd, OsConstants.SHUT_WR);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Shuts down the output side of the socket.
 *
 * @throws IOException
 */
","/**
 * Shuts down the output side of the socket.
 *
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","Exception handling statement has changed with the addition of a try-catch block, and there is a change in the dependent API call from shutdown(fd, false) to Os.shutdown(fd, OsConstants.SHUT_WR), so the change types are 2 and 5.","The code introduces a new way of handling an exception (ErrnoException) and translates it to an IOException. There is also a change in the method used to shut down the output of the socket which could potentially lead to different exceptions being thrown. Hence, the CI type is 1 for the return type because of the new dependent API potentially altering behavior, and 2 for the different exception handling."
363,"<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>",23,24,"<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>","<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>",0,"{
    if (DEBUG) {
        Log.i(TAG, ""StartMainActivity "" + component + "" "" + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
    // Oops!
    }
}","{
    if (DEBUG) {
        Log.i(TAG, ""StartMainActivity "" + component + "" "" + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts a Main activity in the specified profile.
 *
 * @param component The ComponentName of the activity to launch
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
","/**
 * Starts a Main activity in the specified profile.
 *
 * @param component The ComponentName of the activity to launch
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement after 'catch' has changed from a no-operation comment to a throw statement (throw re.rethrowFromSystemServer()), so the code change type is 2.","The new throw statement introduced in the catch block will cause the late version of the API to potentially throw a new exception back to the caller instead of simply ignoring the exception. Therefore, compatibility issue (CI) type is 2."
364,<android.appwidget.AppWidgetHost: void stopListening()>,23,24,<android.appwidget.AppWidgetHost: void stopListening()>,<android.appwidget.AppWidgetHost: void stopListening()>,0,"{
    try {
        sService.stopListening(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}","{
    try {
        sService.stopListening(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
","/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method clearViews() call at the end of the early version of the method is removed in the late version, so the code change type is 4 (Other statement changed).","The removal of the clearViews() call doesn't cause a change in the return value or the exception thrown because the method is void and doesn't have a return statement, and the exception handling for RemoteException has not been altered. Hence, there is no Compatibility Issue; the CI type is 0."
366,"<android.content.res.Resources: String getString(int,Object)>",23,24,"<android.content.res.Resources: String getString(int,Object)>","<android.content.res.Resources: String getString(int,Object)>",0,"{
    final String raw = getString(id);
    return String.format(mConfiguration.locale, raw, formatArgs);
}","{
    final String raw = getString(id);
    return String.format(mResourcesImpl.getConfiguration().getLocales().get(0), raw, formatArgs);
}",1,"/**
 * Return the string value associated with a particular resource ID,
 * substituting the format arguments as defined in {@link java.util.Formatter}
 * and {@link java.lang.String#format}. It will be stripped of any styled text
 * information.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @param formatArgs The format arguments that will be used for substitution.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
","/**
 * Return the string value associated with a particular resource ID,
 * substituting the format arguments as defined in {@link java.util.Formatter}
 * and {@link java.lang.String#format}. It will be stripped of any styled text
 * information.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @param formatArgs The format arguments that will be used for substitution.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the argument passed to the String.format() method where the locale resolution method has been updated. There is no change in the return statement, exception handling statement, or control dependency, but there is a change in accessing the configuration via the mResourcesImpl object instead of directly via mConfiguration, so the code change type is 4,5.","There is no Compatibility Issue here because the behavior of the API has not changed in a way that could lead to different variable return types or values, nor does it change exception handling. It still returns a formatted string as before, albeit with a potentially updated locale from the resources implementation. The apparent intention behind these changes is to provide a more accurate locale for string formatting, which should maintain compatibility with existing calls."
367,<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,23,24,<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getDeviceConfigurationInfo();
    } catch (RemoteException e) {
    }
    return null;
}","{
    try {
        return ActivityManagerNative.getDefault().getDeviceConfigurationInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the device configuration attributes.
 */
","/**
 * Get the device configuration attributes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"Exception handling statement has changed, there is a 'throw' statement introduced in the late version that throws a new exception instead of returning null in case of a RemoteException.","As the early version returns null when there's a RemoteException, while the late version throws an exception, a Compatibility Issue arises due to the different exception handling behavior; the late version will never return null in this scenario, causing a different behavior when an exception occurs. Thus, the CI type is 2."
368,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,23,24,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mWindowAdded="" + mWindowAdded + "" mWindowCreated="" + mWindowCreated + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    try {
        mWindowWasVisible = mWindowVisible;
        mInShowWindow = true;
        showWindowInner(showInput);
    } finally {
        mWindowWasVisible = true;
        mInShowWindow = false;
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mWindowAdded="" + mWindowAdded + "" mWindowCreated="" + mWindowCreated + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted + "" mShowInputFlags="" + mShowInputFlags);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    try {
        mWindowWasVisible = mWindowVisible;
        mInShowWindow = true;
        showWindowInner(showInput);
    } catch (BadTokenException e) {
        // while there is a DO_SHOW_SOFT_INPUT message in the IIMethodWrapper queue.
        if (DEBUG)
            Log.v(TAG, ""BadTokenException: IME is done."");
        mWindowVisible = false;
        mWindowAdded = false;
        // InputMethodManager#showSoftInputFromInputMethod() should always be used instead.
        throw e;
    } finally {
        // TODO: Is it OK to set true when we get BadTokenException?
        mWindowWasVisible = true;
        mInShowWindow = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling for `BadTokenException` has been added and a new log statement is introduced. The changes are the addition of a catch block for `BadTokenException` and changes to a log statement, so the code change types are 2 and 4.","The addition of the `catch (BadTokenException e)` block introduces a new exception handling flow where the method can now throw a `BadTokenException` where it previously could not. Therefore, the changes could lead to different exception handlings and the CI type is 2."
369,<android.app.admin.DevicePolicyManager: int getPasswordMinimumSymbols(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPasswordMinimumSymbols(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumSymbols(ComponentName)>,0,"{
    return getPasswordMinimumSymbols(admin, UserHandle.myUserId());
}","{
    return getPasswordMinimumSymbols(admin, myUserId());
}",1,"/**
 * Retrieve the current number of symbols required in the password for all
 * admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumSymbols(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of symbols required in the password.
 */
","/**
 * Retrieve the current number of symbols required in the password
 * for a particular admin or all admins that set retrictions on this user
 * and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account. This is the same value as
 * set by {@link #setPasswordMinimumSymbols(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of symbols required in the password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from using UserHandle.myUserId() to myUserId(), which means that a dependent API has changed; hence, the code change type is 5.","There is no Compatibility Issue detected because the change in the dependent API does not alter the behavior of the getPasswordMinimumSymbols method itself in terms of different return values, types, or exception handling. Therefore, the CI type is 0."
370,<android.hardware.camera2.legacy.RequestHolder.Builder: RequestHolder build(long)>,23,24,<android.hardware.camera2.legacy.RequestHolder.Builder: RequestHolder build(long)>,<android.hardware.camera2.legacy.RequestHolder.Builder: RequestHolder build(long)>,0,"{
    return new RequestHolder(mRequestId, mSubsequenceId, mRequest, mRepeating, frameNumber, mNumJpegTargets, mNumPreviewTargets);
}","{
    return new RequestHolder(mRequestId, mSubsequenceId, mRequest, mRepeating, frameNumber, mNumJpegTargets, mNumPreviewTargets, mJpegSurfaceIds);
}",1,"/**
 * Build a new {@link RequestHolder} using with parameters generated from this
 * {@link Builder}.
 *
 * @param frameNumber the {@code framenumber} to generate in the {@link RequestHolder}.
 * @return a {@link RequestHolder} constructed with the {@link Builder}'s parameters.
 */
","/**
 * Build a new {@link RequestHolder} using with parameters generated from this
 * {@link Builder}.
 *
 * @param frameNumber the {@code framenumber} to generate in the {@link RequestHolder}.
 * @return a {@link RequestHolder} constructed with the {@link Builder}'s parameters.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor of `RequestHolder` in the return statement is called with an additional parameter `mJpegSurfaceIds`, so the change type is 1,5.","This change introduces another field to the `RequestHolder` object's creation which could change the behavior or state of the `RequestHolder` object returned. Therefore, the CI type is 1."
371,<android.content.res.TypedArray: int getChangingConfigurations()>,23,24,<android.content.res.TypedArray: int getChangingConfigurations()>,<android.content.res.TypedArray: int getChangingConfigurations()>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * AssetManager.STYLE_NUM_ENTRIES;
        final int type = data[index + AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
    }
    return changingConfig;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    @Config int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * AssetManager.STYLE_NUM_ENTRIES;
        final int type = data[index + AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= ActivityInfo.activityInfoConfigNativeToJava(data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS]);
    }
    return changingConfig;
}",1,"/**
 * Return a mask of the configuration parameters for which the values in
 * this typed array may change.
 *
 * @return Returns a mask of the changing configuration parameters, as
 * defined by {@link android.content.pm.ActivityInfo}.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @see android.content.pm.ActivityInfo
 */
","/**
 * Return a mask of the configuration parameters for which the values in
 * this typed array may change.
 *
 * @return Returns a mask of the changing configuration parameters, as
 * defined by {@link android.content.pm.ActivityInfo}.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @see android.content.pm.ActivityInfo
 */
",-1,,[@Config],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation in the loop uses a new method, `ActivityInfo.activityInfoConfigNativeToJava`, to process the changingConfig value. It also includes an annotation change, using `@Config` for the `changingConfig` variable. Since the method name is the only thing that's changed and the actual computation appears related to converting configuration constants, the change could be just an internal refactoring without changing the behavior. This would therefore only be considered other statement changed (4) and dependent API changed (5).","There is no direct evidence that the behavior has changed since we do not have information on what `ActivityInfo.activityInfoConfigNativeToJava` actually does. The assumption here is the conversion method should return the equivalent value as the previous implementation. Hence, there's no apparent CI as the return type and potential return values are assumed to be the same."
372,<android.app.ContextImpl: File getFilesDir()>,23,24,<android.app.ContextImpl: File getFilesDir()>,<android.app.ContextImpl: File getFilesDir()>,0,"{
    synchronized (mSync) {
        if (mFilesDir == null) {
            mFilesDir = new File(getDataDirFile(), ""files"");
        }
        return createFilesDirLocked(mFilesDir);
    }
}","{
    synchronized (mSync) {
        if (mFilesDir == null) {
            mFilesDir = new File(getDataDir(), ""files"");
        }
        return ensurePrivateDirExists(mFilesDir);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",0,"The return statement invokes a different method in the late implementation (ensurePrivateDirExists instead of createFilesDirLocked), and the method getDataDir() has replaced getDataDirFile(), so the code change types are 1 and 5.","Despite the implementation changes, there's no indication that these changes will cause the method to return different results. Both methods `createFilesDirLocked` and `ensurePrivateDirExists` appear to serve a similar purpose: ensuring that a private directory exists and then returning it. Also, the change from `getDataDirFile()` to `getDataDir()` does not inherently suggest a different return value, assuming both methods are intended to provide the same location (just differently named in the API). So, based on the information given and the method naming conventions, I would infer no Compatibility Issue."
373,<android.view.View: boolean removeCallbacks(Runnable)>,23,24,<android.view.View: boolean removeCallbacks(Runnable)>,<android.view.View: boolean removeCallbacks(Runnable)>,0,"{
    if (action != null) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            attachInfo.mHandler.removeCallbacks(action);
            attachInfo.mViewRootImpl.mChoreographer.removeCallbacks(Choreographer.CALLBACK_ANIMATION, action, null);
        }
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().removeCallbacks(action);
    }
    return true;
}","{
    if (action != null) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            attachInfo.mHandler.removeCallbacks(action);
            attachInfo.mViewRootImpl.mChoreographer.removeCallbacks(Choreographer.CALLBACK_ANIMATION, action, null);
        }
        getRunQueue().removeCallbacks(action);
    }
    return true;
}",1,"/**
 * <p>Removes the specified Runnable from the message queue.</p>
 *
 * @param action The Runnable to remove from the message handling queue
 *
 * @return true if this view could ask the Handler to remove the Runnable,
 * false otherwise. When the returned value is true, the Runnable
 * may or may not have been actually removed from the message queue
 * (for instance, if the Runnable was not in the queue already.)
 *
 * @see #post
 * @see #postDelayed
 * @see #postOnAnimation
 * @see #postOnAnimationDelayed
 */
","/**
 * <p>Removes the specified Runnable from the message queue.</p>
 *
 * @param action The Runnable to remove from the message handling queue
 *
 * @return true if this view could ask the Handler to remove the Runnable,
 * false otherwise. When the returned value is true, the Runnable
 * may or may not have been actually removed from the message queue
 * (for instance, if the Runnable was not in the queue already.)
 *
 * @see #post
 * @see #postDelayed
 * @see #postOnAnimation
 * @see #postOnAnimationDelayed
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call `ViewRootImpl.getRunQueue().removeCallbacks(action);` was refactored to `getRunQueue().removeCallbacks(action);` without a change in functionality because `getRunQueue()` is likely a shorthand for what `ViewRootImpl.getRunQueue()` used to represent or due to an invisible change in class structure. Since no behavior changes are apparent, this is categorized as 4 (Other statement changed).",There is no Compatibility Issue since the actual behavior of the API has not been altered; it still removes callbacks and returns true identically as in the earlier version.
374,<android.hardware.usb.UsbManager: UsbAccessory[] getAccessoryList()>,23,24,<android.hardware.usb.UsbManager: UsbAccessory[] getAccessoryList()>,<android.hardware.usb.UsbManager: UsbAccessory[] getAccessoryList()>,0,"{
    try {
        UsbAccessory accessory = mService.getCurrentAccessory();
        if (accessory == null) {
            return null;
        } else {
            return new UsbAccessory[] { accessory };
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in getAccessoryList"", e);
        return null;
    }
}","{
    try {
        UsbAccessory accessory = mService.getCurrentAccessory();
        if (accessory == null) {
            return null;
        } else {
            return new UsbAccessory[] { accessory };
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a list of currently attached USB accessories.
 * (in the current implementation there can be at most one)
 *
 * @return list of USB accessories, or null if none are attached.
 */
","/**
 * Returns a list of currently attached USB accessories.
 * (in the current implementation there can be at most one)
 *
 * @return list of USB accessories, or null if none are attached.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,The exception handling statement has changed. The `catch` block in the late version uses `throw e.rethrowFromSystemServer();` instead of logging the error and returning null.,"Because of the change in the exception handling, the late version of the method potentially throws a different exception rather than simply logging an error and returning null as in the early version, which can lead to a different behavior when exceptions occur. Therefore, the CI type is 2."
376,<android.app.Notification.Builder: Builder setContent(RemoteViews)>,23,24,<android.app.Notification.Builder: Builder setContent(RemoteViews)>,<android.app.Notification.Builder: Builder setContent(RemoteViews)>,0,"{
    mContentView = views;
    return this;
}","{
    return setCustomContentView(views);
}",1,"/**
 * Supply a custom RemoteViews to use instead of the platform template.
 *
 * @see Notification#contentView
 */
","/**
 * Supply a custom RemoteViews to use instead of the platform template.
 *
 * Use {@link #setCustomContentView(RemoteViews)} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The method setContent(RemoteViews) is delegating its work to setCustomContentView(views) method in the late version instead of directly assigning the views to mContentView, and there's also introduction of the @Deprecated annotation, implying a change in the recommended usage. These changes indicate that a dependent API has been modified, changing the internal implementation. Therefore, the code change types are 1 and 5.","Since the implementation of the method has changed to call another method (setCustomContentView), this could potentially lead to a different behavior because setCustomContentView might have additional logic or side effects that were not present in the direct assignment. This qualifies as a potential different return value or type, which is CI type 1."
377,<android.util.StateSet: String dump(int[])>,23,24,<android.util.StateSet: String dump(int[])>,<android.util.StateSet: String dump(int[])>,0,"{
    StringBuilder sb = new StringBuilder();
    int count = states.length;
    for (int i = 0; i < count; i++) {
        switch(states[i]) {
            case R.attr.state_window_focused:
                sb.append(""W "");
                break;
            case R.attr.state_pressed:
                sb.append(""P "");
                break;
            case R.attr.state_selected:
                sb.append(""S "");
                break;
            case R.attr.state_focused:
                sb.append(""F "");
                break;
            case R.attr.state_enabled:
                sb.append(""E "");
                break;
        }
    }
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    int count = states.length;
    for (int i = 0; i < count; i++) {
        switch(states[i]) {
            case R.attr.state_window_focused:
                sb.append(""W "");
                break;
            case R.attr.state_pressed:
                sb.append(""P "");
                break;
            case R.attr.state_selected:
                sb.append(""S "");
                break;
            case R.attr.state_focused:
                sb.append(""F "");
                break;
            case R.attr.state_enabled:
                sb.append(""E "");
                break;
            case R.attr.state_checked:
                sb.append(""C "");
                break;
            case R.attr.state_activated:
                sb.append(""A "");
                break;
        }
    }
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The switch statement has been expanded with two new cases: R.attr.state_checked and R.attr.state_activated. This is adding new logic to the method, so the code change types are 3 and 4.","Due to the additional cases in the switch statement, the method now potentially returns a string with new characters (""C "" for checked, ""A "" for activated) that represent new states. This means the return value can be different from the early version, thus there is a compatibility issue of type 1."
378,<android.os.UserManager: String getUserName()>,23,24,<android.os.UserManager: String getUserName()>,<android.os.UserManager: String getUserName()>,0,"{
    try {
        return mService.getUserInfo(getUserHandle()).name;
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not get user name"", re);
        return """";
    }
}","{
    try {
        return mService.getUserInfo(getUserHandle()).name;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the user name of the user making this call.  This call is only
 * available to applications on the system image; it requires the
 * MANAGE_USERS permission.
 * @return the user name
 */
","/**
 * Returns the user name of the user making this call.  This call is only
 * available to applications on the system image; it requires the
 * MANAGE_USERS permission.
 * @return the user name
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. In the early version, it logs the exception and returns an empty string, while in the late version, it throws a new exception. So the change type is 2.","The change in the exception handling statement could lead to different behaviors when handling RemoteException. The early version will not throw an exception but return an empty string, and the late version will throw an exception. This can cause clients of the API to behave differently if they are not expecting an exception, thus the CI type is 2."
379,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onClientRegistered(int,int)>",23,24,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onClientRegistered(int,int)>","<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onClientRegistered(int,int)>",0,"{
    Log.d(TAG, ""onClientRegistered() - status="" + status + "" clientIf="" + clientIf);
    synchronized (this) {
        if (mClientIf == -1) {
            if (DBG)
                Log.d(TAG, ""onClientRegistered LE scan canceled"");
        }
        if (status == BluetoothGatt.GATT_SUCCESS) {
            mClientIf = clientIf;
            try {
                mBluetoothGatt.startScan(mClientIf, false, mSettings, mFilters, mResultStorages, ActivityThread.currentOpPackageName());
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mClientIf = -1;
            }
        } else {
            // registration failed
            mClientIf = -1;
        }
        notifyAll();
    }
}","{
    Log.d(TAG, ""onClientRegistered() - status="" + status + "" clientIf="" + clientIf + "" mClientIf="" + mClientIf);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mClientIf == -1) {
                    // Registration succeeds after timeout, unregister client.
                    mBluetoothGatt.unregisterClient(clientIf);
                } else {
                    mClientIf = clientIf;
                    mBluetoothGatt.startScan(mClientIf, false, mSettings, mFilters, mWorkSource, mResultStorages, ActivityThread.currentOpPackageName());
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mClientIf = -1;
            }
        } else {
            // registration failed
            mClientIf = -1;
        }
        notifyAll();
    }
}",1,"/**
 * Application interface registered - app is ready to go
 */
","/**
 * Application interface registered - app is ready to go
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The implementation in the late version has changes including control dependency change and exception handling statement change. There is also a change in the dependent API with the addition of the `mWorkSource` parameter to `mBluetoothGatt.startScan()` and the introduction of `mBluetoothGatt.unregisterClient(clientIf)`. Accordingly, the code change types are 2, 3, and 5.","The modification in control flow with the change in the condition to check `mClientIf` before performing actions results in a different behavior of the API, potentially returning a different result. Additionally, the handling of exceptions has changed from logging an error message to actively unregistering the client in certain conditions and changing the client identifier (`mClientIf`) which can alter the exception throwing behavior of the API. Thus, the CI types due to these changes are 1 for the potential different return values, and 2 for the potential different exception handling."
380,"<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>",23,24,"<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>","<android.provider.DocumentsProvider: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>",0,"{
    enforceTree(uri);
    if (opts != null && opts.containsKey(ContentResolver.EXTRA_SIZE)) {
        final Point sizeHint = opts.getParcelable(ContentResolver.EXTRA_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, signal);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts, signal);
    }
}","{
    return openTypedAssetFileImpl(uri, mimeTypeFilter, opts, signal);
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 */
","/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 * @see #openTypedDocument(String, String, Bundle, CancellationSignal)
 * @see #getDocumentStreamTypes(String, String)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,The entire implementation of the method has been changed to delegate the call to a different method (openTypedAssetFileImpl) instead of using inline implementation. This is an example of Dependent API changed.,"Since the method is delegating to a new internal method, without information on what openTypedAssetFileImpl does, we can't determine if there is a compatibility issue. Hence, we assume there is no compatibility issue since the signature remains unchanged and the call is simply delegated elsewhere."
381,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,23,24,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getActionMasked();
    if (mEditor != null && action == MotionEvent.ACTION_DOWN) {
        // Detect double tap and inform the Editor.
        if (mFirstTouch && (SystemClock.uptimeMillis() - mLastTouchUpTime) <= ViewConfiguration.getDoubleTapTimeout()) {
            mEditor.mDoubleTap = true;
            mFirstTouch = false;
        } else {
            mEditor.mDoubleTap = false;
            mFirstTouch = true;
        }
    }
    if (action == MotionEvent.ACTION_UP) {
        mLastTouchUpTime = SystemClock.uptimeMillis();
    }
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!textIsSelectable && mEditor.mShowSoftInputOnFocus) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!textIsSelectable && mEditor.mShowSoftInputOnFocus) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
382,<android.widget.AnalogClock: void onAttachedToWindow()>,23,24,<android.widget.AnalogClock: void onAttachedToWindow()>,<android.widget.AnalogClock: void onAttachedToWindow()>,0,"{
    super.onAttachedToWindow();
    if (!mAttached) {
        mAttached = true;
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_TIME_TICK);
        filter.addAction(Intent.ACTION_TIME_CHANGED);
        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
        // OK, this is gross but needed. This class is supported by the
        // remote views machanism and as a part of that the remote views
        // can be inflated by a context for another user without the app
        // having interact users permission - just for loading resources.
        // For exmaple, when adding widgets from a user profile to the
        // home screen. Therefore, we register the receiver as the current
        // user not the one the context is for.
        getContext().registerReceiverAsUser(mIntentReceiver, android.os.Process.myUserHandle(), filter, null, mHandler);
    }
    // NOTE: It's safe to do these after registering the receiver since the receiver always runs
    // in the main thread, therefore the receiver can't run before this method returns.
    // The time zone may have changed while the receiver wasn't registered, so update the Time
    mCalendar = new Time();
    // Make sure we update to the current time
    onTimeChanged();
}","{
    super.onAttachedToWindow();
    if (!mAttached) {
        mAttached = true;
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_TIME_TICK);
        filter.addAction(Intent.ACTION_TIME_CHANGED);
        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
        // OK, this is gross but needed. This class is supported by the
        // remote views machanism and as a part of that the remote views
        // can be inflated by a context for another user without the app
        // having interact users permission - just for loading resources.
        // For exmaple, when adding widgets from a user profile to the
        // home screen. Therefore, we register the receiver as the current
        // user not the one the context is for.
        getContext().registerReceiverAsUser(mIntentReceiver, android.os.Process.myUserHandle(), filter, null, getHandler());
    }
    // NOTE: It's safe to do these after registering the receiver since the receiver always runs
    // in the main thread, therefore the receiver can't run before this method returns.
    // The time zone may have changed while the receiver wasn't registered, so update the Time
    mCalendar = new Time();
    // Make sure we update to the current time
    onTimeChanged();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a change from 'mHandler' to 'getHandler()' within the method invocation of 'getContext().registerReceiverAsUser()'. This is an internal method call change, so the code change type is 4.","The change from using a direct reference 'mHandler' to calling a method 'getHandler()' will not cause a Compatibility Issue as long as 'getHandler()' returns the same handler that was previously referred to directly by 'mHandler'. Since 'mHandler' is not being modified in any way and assuming 'getHandler()' is a correct and equivalent accessor for 'mHandler', the behavior of the method would remain consistent; thus there is no Compatibility Issue."
383,<android.app.ContextImpl: File[] getExternalMediaDirs()>,23,24,<android.app.ContextImpl: File[] getExternalMediaDirs()>,<android.app.ContextImpl: File[] getExternalMediaDirs()>,0,"{
    synchronized (mSync) {
        if (mExternalMediaDirs == null) {
            mExternalMediaDirs = Environment.buildExternalStorageAppMediaDirs(getPackageName());
        }
        // Create dirs if needed
        return ensureDirsExistOrFilter(mExternalMediaDirs);
    }
}","{
    synchronized (mSync) {
        if (mExternalMediaDirs == null) {
            mExternalMediaDirs = Environment.buildExternalStorageAppMediaDirs(getPackageName());
        }
        // Create dirs if needed
        return ensureExternalDirsExistOrFilter(mExternalMediaDirs);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method ensureDirsExistOrFilter(mExternalMediaDirs) has been changed to ensureExternalDirsExistOrFilter(mExternalMediaDirs) in the late version. This represents a change in the dependent API being called which leads to a code change of type 4,5.","Since the API used to ensure directories exist or are filtered has changed, this could potentially return a different set of File objects, which may represent different directories or enforce different filtering criteria in the late version, leading to a CI of type 1."
384,<android.app.SearchManager: ComponentName getGlobalSearchActivity()>,23,24,<android.app.SearchManager: ComponentName getGlobalSearchActivity()>,<android.app.SearchManager: ComponentName getGlobalSearchActivity()>,0,"{
    try {
        return mService.getGlobalSearchActivity();
    } catch (RemoteException ex) {
        Log.e(TAG, ""getGlobalSearchActivity() failed: "" + ex);
        return null;
    }
}","{
    try {
        return mService.getGlobalSearchActivity();
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the name of the global search activity.
 */
","/**
 * Gets the name of the global search activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has been changed. In the early version, the exception is caught and logged, then null is returned. In the late version, the exception is re-thrown, so the change type is 2.","Since the exception handling has changed in the way that the RemoteException is no longer caught and logged (with a return of null), but re-thrown instead, this will lead to different exception behavior from the API's method. Therefore, the CI type is 2."
385,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,23,24,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,0,"{
    try {
        return getService().getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return getService().getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */
","/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed, where the early version returns null and the late version throws a rethrown exception, so the change type is 2.","Due to the modification in the exception handling, where previously an exception would result in a return of null but now throws an exception instead, it can potentially lead to different behavior when the API encounters an error. Therefore, there is a compatibility issue related to different exception handling, and the CI type is 2."
388,"<android.view.View: boolean pointInView(float,float)>",23,24,"<android.view.View: boolean pointInView(float,float)>","<android.view.View: boolean pointInView(float,float)>",0,"{
    return localX >= 0 && localX < (mRight - mLeft) && localY >= 0 && localY < (mBottom - mTop);
}","{
    return pointInView(localX, localY, 0);
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the method has changed completely; it no longer contains an explicit computation but calls an overload of the method with an additional parameter. This implies there is a change in the dependent API, so the code change types are 4 and 5.","The change from an inline comparison to a method call that likely computes the same comparison but with an added ""slop"" factor (parameter in the new method call) can lead to different return values. Even though we don't know what the value of the ""slop"" parameter is, the fact that the method is now being called with an additional parameter that was not present before potentially allows for different behavior. Thus, this is a Compatibility Issue of the type 1."
389,<android.app.FragmentController: List<Fragment> retainNonConfig()>,23,24,<android.app.FragmentController: List<Fragment> retainNonConfig()>,<android.app.FragmentController: List<Fragment> retainNonConfig()>,0,"{
    return mHost.mFragmentManager.retainNonConfig();
}","{
    return mHost.mFragmentManager.retainNonConfig().getFragments();
}",1,"/**
 * Returns a list of Fragments that have opted to retain their instance across
 * configuration changes.
 */
","/**
 * Returns a list of Fragments that have opted to retain their instance across
 * configuration changes.
 *
 * @deprecated use {@link #retainNestedNonConfig()} to also track retained
 * nested child fragments
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed to include a method call on the object returned by retainNonConfig(), changing from returning the result of mHost.mFragmentManager.retainNonConfig() to mHost.mFragmentManager.retainNonConfig().getFragments(). This change in the return statement indicates a dependency on a changed API as well, so the change types are 1,5.","Since the return statement now includes an additional method call (getFragments()), the API could potentially return different values. This is because previously the API returned a value directly from retainNonConfig(), and now it is returning a value from a method call on the object returned by retainNonConfig(). Thus, the CI type is 1."
390,<android.widget.Editor.SuggestionsPopupWindow: int getTextOffset()>,23,24,<android.widget.Editor.SuggestionsPopupWindow: int getTextOffset()>,<android.widget.Editor.SuggestionsPopupWindow: int getTextOffset()>,0,"{
    return mTextView.getSelectionStart();
}","{
    return (mTextView.getSelectionStart() + mTextView.getSelectionStart()) / 2;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement's expression has been modified, changing from mTextView.getSelectionStart() to (mTextView.getSelectionStart() + mTextView.getSelectionStart()) / 2, so the code change type is 1.","The change in the return expression means that the API will return a different value, leading to a CI of type 1 because the behavior of the API in terms of returned value has been altered."
391,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",23,24,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>","<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",0,"{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess();
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess(this);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5","1,2","The method `prepareToLeaveProcess` in the late version has been changed to include the `this` parameter, and the exception handling has been changed from throwing a new RuntimeException to throwing the result of `e.rethrowFromSystemServer()`, which means there's both a change in a dependent API (5) as well as a change in an exception handling statement (1).","Adding an argument to the `prepareToLeaveProcess` method could potentially change the behavior of how the `fillInIntent` is processed, which in turn can affect the return value or the normal behavior of the API (1). Furthermore, changing the exception handling from a generic RuntimeException to throwing `e.rethrowFromSystemServer()` can potentially change the exception behavior that caller of the API needs to handle (2). Therefore, the CI types are 1 and 2."
392,<android.app.usage.UsageStats: void add(UsageStats)>,23,24,<android.app.usage.UsageStats: void add(UsageStats)>,<android.app.usage.UsageStats: void add(UsageStats)>,0,"{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    if (right.mEndTimeStamp > mEndTimeStamp) {
        mLastEvent = right.mLastEvent;
        mEndTimeStamp = right.mEndTimeStamp;
        mLastTimeUsed = right.mLastTimeUsed;
        mBeginIdleTime = right.mBeginIdleTime;
        mLastTimeSystemUsed = right.mLastTimeSystemUsed;
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
}","{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // The incoming UsageStat begins after this one, so use its last time used fields
        // as the source of truth.
        // We use the mBeginTimeStamp due to a bug where UsageStats files can overlap with
        // regards to their mEndTimeStamp.
        mLastEvent = right.mLastEvent;
        mLastTimeUsed = right.mLastTimeUsed;
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
}",1,"/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
","/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency of the if statement has changed, as the condition changed from comparing `right.mEndTimeStamp` to `mEndTimeStamp`, to comparing `right.mBeginTimeStamp` to `mBeginTimeStamp`. Also, several assignments in the conditional block have been removed ('mEndTimeStamp = right.mEndTimeStamp', 'mBeginIdleTime = right.mBeginIdleTime', 'mLastTimeSystemUsed = right.mLastTimeSystemUsed'), therefore the change includes types 3 and 4.","Despite the changes to the control dependency and the update of certain fields, these changes do not lead to a Compatibility Issue with different return values or exception handlings. The modified fields and removed assignments only affect the internal state of the UsageStats object. Additionally, since the method's signature is `void add(UsageStats)`, it does not return a value, and no exception handling has changed. Therefore, there's no Compatibility Issue as per the definitions provided."
393,<android.content.res.Resources: String getResourceTypeName(int)>,23,24,<android.content.res.Resources: String getResourceTypeName(int)>,<android.content.res.Resources: String getResourceTypeName(int)>,0,"{
    String str = mAssets.getResourceTypeName(resid);
    if (str != null)
        return str;
    throw new NotFoundException(""Unable to find resource ID #0x"" + Integer.toHexString(resid));
}","{
    return mResourcesImpl.getResourceTypeName(resid);
}",1,"/**
 * Return the type name for a given resource identifier.
 *
 * @param resid The resource identifier whose type name is to be
 * retrieved.
 *
 * @return A string holding the type name of the resource.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getResourceName
 */
","/**
 * Return the type name for a given resource identifier.
 *
 * @param resid The resource identifier whose type name is to be
 * retrieved.
 *
 * @return A string holding the type name of the resource.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getResourceName
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has changed completely from invoking getResourceTypeName on mAssets to mResourcesImpl, and there is no longer a condition check for null or throwing of NotFoundException, hence the code change types are 1,5.","Given that the late version no longer checks for null and doesn't throw NotFoundException, this could lead to the method returning different values compared to the early version under certain circumstances (specifically, if mResourcesImpl.getResourceTypeName(resid) returns null or when resid is not found). Therefore, a Compatibility Issue of type 1 for potential different return values is present."
394,<android.os.storage.StorageManager: boolean isObbMounted(String)>,23,24,<android.os.storage.StorageManager: boolean isObbMounted(String)>,<android.os.storage.StorageManager: boolean isObbMounted(String)>,0,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mMountService.isObbMounted(rawPath);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to check if OBB is mounted"", e);
    }
    return false;
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mMountService.isObbMounted(rawPath);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Check whether an Opaque Binary Blob (OBB) is mounted or not.
 *
 * @param rawPath path to OBB image
 * @return true if OBB is mounted; false if not mounted or on error
 */
","/**
 * Check whether an Opaque Binary Blob (OBB) is mounted or not.
 *
 * @param rawPath path to OBB image
 * @return true if OBB is mounted; false if not mounted or on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"There is no changed in the return statements but the exception handling statements have changed. The earlier version logged the RemoteException and returned false, while the later version throws the exception wrapped by rethrowFromSystemServer. Hence, the change type is 2.","Since the later version of the API throws an exception instead of returning false when the RemoteException occurs, the behavior in terms of exception handling has changed between these versions. This constitutes a potential Compatibility Issue due to different exception handling, so the CI type is 2."
395,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,23,24,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,0,"{
    final INotificationManager service = getService();
    try {
        return zenModeToInterruptionFilter(service.getZenMode());
    } catch (RemoteException e) {
        Log.e(TAG, ""Unable to talk to notification manager. Woe!"", e);
    }
    return INTERRUPTION_FILTER_UNKNOWN;
}","{
    final INotificationManager service = getService();
    try {
        return zenModeToInterruptionFilter(service.getZenMode());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */
","/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 */
",-1,,[@InterruptionFilter],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from logging the `RemoteException` to throwing it with `throw e.rethrowFromSystemServer()`, so the code change type is 2.","The late version now throws the exception instead of catching it and logging. This means that the behavior in terms of exception handling is altered and clients of the API now need to handle the thrown exception themselves, which was not the case before. Hence, the CI type is 2."
396,<android.os.Bundle: boolean hasFileDescriptors()>,23,24,<android.os.Bundle: boolean hasFileDescriptors()>,<android.os.Bundle: boolean hasFileDescriptors()>,0,"{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        Parcelable p = array[n];
                        if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        Parcelable p = array.valueAt(n);
                        if (p != null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}","{
    if ((mFlags & FLAG_HAS_FDS_KNOWN) == 0) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        Parcelable p = array[n];
                        if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        Parcelable p = array.valueAt(n);
                        if (p != null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (fdFound) {
            mFlags |= FLAG_HAS_FDS;
        } else {
            mFlags &= ~FLAG_HAS_FDS;
        }
        mFlags |= FLAG_HAS_FDS_KNOWN;
    }
    return (mFlags & FLAG_HAS_FDS) != 0;
}",1,"/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
","/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control structure for checking if file descriptors are known has changed from using a separate boolean flag (mFdsKnown) to using flag bits (mFlags & FLAG_HAS_FDS_KNOWN). The way file descriptor presence is stored changed as well, from using a boolean variable (mHasFds) to setting or clearing a flag bit (mFlags |= FLAG_HAS_FDS or mFlags &= ~FLAG_HAS_FDS). The final return statement also changed accordingly from `return mHasFds` in the early version to `return (mFlags & FLAG_HAS_FDS) != 0;` in the late version. This constitutes code changes of return statement changed (1), control dependency changed (3), and other statement changed (4).","The change in logic for storing and retrieving the 'file descriptors known' state can lead to a different return value. For example, if the implementation of the flag bit manipulation is incorrect, it could return a wrong indication of the presence of file descriptors. Thus, the CI type is 1."
397,"<android.app.ContextImpl: void grantUriPermission(String,Uri,int)>",23,24,"<android.app.ContextImpl: void grantUriPermission(String,Uri,int)>","<android.app.ContextImpl: void grantUriPermission(String,Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().grantUriPermission(mMainThread.getApplicationThread(), toPackage, ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().grantUriPermission(mMainThread.getApplicationThread(), toPackage, ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has been changed with the addition of the throw e.rethrowFromSystemServer() call in the late version, so the code change type is 2.","The late implementation will now throw an exception, where the early implementation did not, so this change could potentially cause a different exception to be thrown, and the CI type is 2."
398,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,23,24,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,0,"{
    try {
        WindowManagerGlobal.getWindowSession().setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        WindowManagerGlobal.getWindowSession().setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Clear the offsets previously associated with this window through
 * {@link #setWallpaperOffsets(IBinder, float, float)}.  This reverts
 * the window to its default state, where it does not cause the wallpaper
 * to scroll from whatever its last offsets were.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 */
","/**
 * Clear the offsets previously associated with this window through
 * {@link #setWallpaperOffsets(IBinder, float, float)}.  This reverts
 * the window to its default state, where it does not cause the wallpaper
 * to scroll from whatever its last offsets were.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"Exception handling statement changed from a comment indicating to ignore the exception to rethrowing the exception with throw e.rethrowFromSystemServer(), so the code change type is 2.","The late version of the API throws the exception whereas the early version ignored it, this could lead to different exception handling behavior for the clients of the API. Hence, the CI type is 2."
400,<android.app.Notification.Builder: Builder setCategory(String)>,23,24,<android.app.Notification.Builder: Builder setCategory(String)>,<android.app.Notification.Builder: Builder setCategory(String)>,0,"{
    mCategory = category;
    return this;
}","{
    mN.category = category;
    return this;
}",1,"/**
 * Set the notification category.
 *
 * @see Notification#category
 */
","/**
 * Set the notification category.
 *
 * @see Notification#category
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The assignment statement has been changed from a direct field assignment to an assignment within an object field, hence there is a change in the internal code structure, hence a change type 4. Additionally, if `mN` is a different object or has different behavior related to 'category' property access, this is a change in a dependent API, hence a change type 5.","Despite the internal change, the overall behavior and contract of the API `setCategory(String)` seem to be preserved. The method still sets the category and returns the same Builder object without indicating that a different value would be returned; neither does it indicate a change in the exception thrown. Hence, there is no Compatibility Issue."
401,"<android.app.admin.DevicePolicyManager: boolean removeUser(ComponentName,UserHandle)>",23,24,"<android.app.admin.DevicePolicyManager: boolean removeUser(ComponentName,UserHandle)>","<android.app.admin.DevicePolicyManager: boolean removeUser(ComponentName,UserHandle)>",0,"{
    try {
        return mService.removeUser(admin, userHandle);
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not remove user "", re);
        return false;
    }
}","{
    throwIfParentInstance(""removeUser"");
    try {
        return mService.removeUser(admin, userHandle);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by a device owner to remove a user and all associated data. The primary user can
 * not be removed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param userHandle the user to remove.
 * @return {@code true} if the user was removed, {@code false} otherwise.
 */
","/**
 * Called by a device owner to remove a user and all associated data. The primary user can not
 * be removed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param userHandle the user to remove.
 * @return {@code true} if the user was removed, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The addition of ""throwIfParentInstance(""removeUser"");"" before the 'try' block and the change in the exception handling from logging and returning 'false' to throwing the exception with 'throw re.rethrowFromSystemServer();' are changes of type 2 and 4 due to exception handling statement change and other statement changed, respectively. Additionally, throwIfParentInstance(""removeUser""); adds a new control flow dependency which is type 3 because this statement could prevent the method from reaching the try block under certain conditions.","There could be a Compatibility Issue caused by potential different return values due to the new control flow check, which could throw an exception before the method proceeds (CI type 1). Also, the change in exception handling from returning 'false' to throwing an exception could lead to a different exception being thrown by the method (CI type 2)."
403,"<android.text.Layout: int getOffsetForHorizontal(int,float)>",23,24,"<android.text.Layout: int getOffsetForHorizontal(int,float)>","<android.text.Layout: int getOffsetForHorizontal(int,float)>",0,"{
    // TODO: use Paint.getOffsetForAdvance to avoid binary search
    int max = getLineEnd(line) - 1;
    int min = getLineStart(line);
    Directions dirs = getLineDirections(line);
    if (line == getLineCount() - 1)
        max++;
    int best = min;
    float bestdist = Math.abs(getPrimaryHorizontal(best) - horiz);
    for (int i = 0; i < dirs.mDirections.length; i += 2) {
        int here = min + dirs.mDirections[i];
        int there = here + (dirs.mDirections[i + 1] & RUN_LENGTH_MASK);
        int swap = (dirs.mDirections[i + 1] & RUN_RTL_FLAG) != 0 ? -1 : 1;
        if (there > max)
            there = max;
        int high = there - 1 + 1, low = here + 1 - 1, guess;
        while (high - low > 1) {
            guess = (high + low) / 2;
            int adguess = getOffsetAtStartOf(guess);
            if (getPrimaryHorizontal(adguess) * swap >= horiz * swap)
                high = guess;
            else
                low = guess;
        }
        if (low < here + 1)
            low = here + 1;
        if (low < there) {
            low = getOffsetAtStartOf(low);
            float dist = Math.abs(getPrimaryHorizontal(low) - horiz);
            int aft = TextUtils.getOffsetAfter(mText, low);
            if (aft < there) {
                float other = Math.abs(getPrimaryHorizontal(aft) - horiz);
                if (other < dist) {
                    dist = other;
                    low = aft;
                }
            }
            if (dist < bestdist) {
                bestdist = dist;
                best = low;
            }
        }
        float dist = Math.abs(getPrimaryHorizontal(here) - horiz);
        if (dist < bestdist) {
            bestdist = dist;
            best = here;
        }
    }
    float dist = Math.abs(getPrimaryHorizontal(max) - horiz);
    if (dist <= bestdist) {
        bestdist = dist;
        best = max;
    }
    return best;
}","{
    return getOffsetForHorizontal(line, horiz, true);
}",1,"/**
 * Get the character offset on the specified line whose position is
 * closest to the specified horizontal position.
 */
","/**
 * Get the character offset on the specified line whose position is
 * closest to the specified horizontal position.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method implementation has changed from a complex algorithm to a simple proxy call to another method (getOffsetForHorizontal(line, horiz, true)), thus the code change type is 5.","There is no Compatibility Issue since the new implementation defers the mechanism to another method within the same class, expecting the same behavior given that the parameters match and the underlying logic is maintained in the now-delegated method. Therefore, there is no behavior change that leads to different return values or exceptions being thrown."
404,<android.hardware.usb.UsbManager: boolean hasPermission(UsbDevice)>,23,24,<android.hardware.usb.UsbManager: boolean hasPermission(UsbDevice)>,<android.hardware.usb.UsbManager: boolean hasPermission(UsbDevice)>,0,"{
    try {
        return mService.hasDevicePermission(device);
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in hasPermission"", e);
        return false;
    }
}","{
    try {
        return mService.hasDevicePermission(device);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the caller has permission to access the device.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbDevice, PendingIntent)} or
 * by the user choosing the caller as the default application for the device.
 *
 * @param device to check permissions for
 * @return true if caller has permission
 */
","/**
 * Returns true if the caller has permission to access the device.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbDevice, PendingIntent)} or
 * by the user choosing the caller as the default application for the device.
 *
 * @param device to check permissions for
 * @return true if caller has permission
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"There is a change in the exception handling code. Previously, a RemoteException was logged and false was returned. In the late version, the RemoteException is now rethrown.","The exception handling has changed such that if a RemoteException occurs, it no longer returns false and logs the error, but instead rethrows the exception. This could potentially introduce a different exception being thrown to the caller, leading to a different behavior in error scenarios. Thus, the CI type is 2."
407,"<android.app.admin.DevicePolicyManager: void addUserRestriction(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: void addUserRestriction(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void addUserRestriction(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            mService.setUserRestriction(admin, key, true);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""addUserRestriction"");
    if (mService != null) {
        try {
            mService.setUserRestriction(admin, key, true);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile or device owner to set a user restriction specified by the key.
 * <p>
 * The calling device admin must be a profile or device owner; if it is not,
 * a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param key The key of the restriction. See the constants in
 * {@link android.os.UserManager} for the list of keys.
 */
","/**
 * Called by a profile or device owner to set a user restriction specified by the key.
 * <p>
 * The calling device admin must be a profile or device owner; if it is not, a security
 * exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param key The key of the restriction. See the constants in {@link android.os.UserManager}
 * for the list of keys.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","There is a new method call (throwIfParentInstance(""addUserRestriction"")) which is an 'other statement changed'(4), and there is also a new throw statement inside the catch block (throw e.rethrowFromSystemServer()), which is an 'exception handling statement changed'(2). Moreover, due to the introduction of throwIfParentInstance() call, the API could throw a new exception which it did not in the earlier version, leading to a 'return statement changed'(1) since it might prevent the subsequent code from executing in certain conditions.","There are two potential compatibility issues: The new method call can throw an exception that was not present in the early version, potentially leading to a failure without executing the setUserRestriction method, and this affects the return type or value (CI type 1). The new throw statement inside the catch block might also lead to a different exception being raised than in the earlier version (CI type 2). This can alter the exception handling behavior of the API."
408,<android.widget.AbsListView.InputConnectionWrapper: boolean performEditorAction(int)>,23,24,<android.widget.AbsListView.InputConnectionWrapper: boolean performEditorAction(int)>,<android.widget.AbsListView.InputConnectionWrapper: boolean performEditorAction(int)>,0,"{
    // the one that does this.
    if (editorAction == EditorInfo.IME_ACTION_DONE) {
        InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm != null) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
        return true;
    }
    return false;
}","{
    // the one that does this.
    if (editorAction == EditorInfo.IME_ACTION_DONE) {
        InputMethodManager imm = getContext().getSystemService(InputMethodManager.class);
        if (imm != null) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
        return true;
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method for retrieving the InputMethodManager service from the context has been changed from getContext().getSystemService(Context.INPUT_METHOD_SERVICE) to getContext().getSystemService(InputMethodManager.class). This change is a dependent API change, so the code change type is 5.","Even though there is a change in how the service is retrieved, this change does not affect the return value or the exceptions thrown by the performEditorAction method. Therefore, no compatibility issue is introduced, and the CI type is 0."
409,"<android.view.View: void measure(int,int)>",23,24,"<android.view.View: void measure(int,int)>","<android.view.View: void measure(int,int)>",0,"{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    // Suppress sign extension for the low bytes
    long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;
    if (mMeasureCache == null)
        mMeasureCache = new LongSparseLongArray(2);
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        int cacheIndex = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex < 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimensionRaw((int) (value >> 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""View with id "" + getId() + "": "" + getClass().getName() + ""#onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 | // suppress sign extension
    (long) mMeasuredHeight & 0xffffffffL);
}","{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    // Suppress sign extension for the low bytes
    long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;
    if (mMeasureCache == null)
        mMeasureCache = new LongSparseLongArray(2);
    final boolean forceLayout = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;
    // Optimize layout by avoiding an extra EXACTLY pass when the view is
    // already measured as the correct size. In API 23 and below, this
    // extra pass is required to make LinearLayout re-distribute weight.
    final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec;
    final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY && MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;
    final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) && getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);
    final boolean needsLayout = specChanged && (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);
    if (forceLayout || needsLayout) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex < 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimensionRaw((int) (value >> 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""View with id "" + getId() + "": "" + getClass().getName() + ""#onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 | // suppress sign extension
    (long) mMeasuredHeight & 0xffffffffL);
}",1,"/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
","/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
410,<android.app.NotificationManager.Policy: boolean equals(Object)>,23,24,<android.app.NotificationManager.Policy: boolean equals(Object)>,<android.app.NotificationManager.Policy: boolean equals(Object)>,0,"{
    if (!(o instanceof Policy))
        return false;
    if (o == this)
        return true;
    final Policy other = (Policy) o;
    return other.priorityCategories == priorityCategories && other.priorityCallSenders == priorityCallSenders && other.priorityMessageSenders == priorityMessageSenders;
}","{
    if (!(o instanceof Policy))
        return false;
    if (o == this)
        return true;
    final Policy other = (Policy) o;
    return other.priorityCategories == priorityCategories && other.priorityCallSenders == priorityCallSenders && other.priorityMessageSenders == priorityMessageSenders && other.suppressedVisualEffects == suppressedVisualEffects;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method 'equals' has introduced a new condition check (other.suppressedVisualEffects == suppressedVisualEffects) in the return statement. Therefore, the return statement has been changed, which is type 1, and a new field comparison is introduced (other.suppressedVisualEffects == suppressedVisualEffects), which is also a type 4 change.","Considering the equals method is comparing an additional field in the late version, this could potentially lead to different comparison results. Specifically, objects that would have been considered equal in the early version (despite differing in the new suppressedVisualEffects field) would not be so in the late version. Thus, the CI type is 1."
411,<android.app.admin.DevicePolicyManager: String getCertInstallerPackage(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: String getCertInstallerPackage(ComponentName)>,<android.app.admin.DevicePolicyManager: String getCertInstallerPackage(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getCertInstallerPackage(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return null;
}","{
    throwIfParentInstance(""getCertInstallerPackage"");
    if (mService != null) {
        try {
            return mService.getCertInstallerPackage(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Called by a profile owner or device owner to retrieve the certificate installer for the
 * current user. null if none is set.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return The package name of the current delegated certificate installer, or {@code null}
 * if none is set.
 */
","/**
 * Called by a profile owner or device owner to retrieve the certificate installer for the user.
 * null if none is set.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return The package name of the current delegated certificate installer, or {@code null} if
 * none is set.
 * @throws SecurityException if {@code admin} is not a device or a profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is a new call to throwIfParentInstance(""getCertInstallerPackage"") at the beginning of the method and the exception handling has changed from logging the error to re-throwing the exception, so the change types are 2 (exception handling statement changed) and 4 (other statement changed).","There is a potential Compatibility Issue due to different exception handling because the previous implementation logged the error, while the new implementation throws the exception, causing the API to potentially throw different exceptions at runtime. Therefore, the CI type is 2."
412,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",23,24,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The method call ""intent.prepareToLeaveProcess();"" has been changed to ""intent.prepareToLeaveProcess(this);"" adding a new parameter, and the exception handling statement has also changed from throwing a new RuntimeException to throwing with ""throw e.rethrowFromSystemServer();"", which leads to the change type 2,4.","While the other API call changes should not affect the behaviour of this method, the change in exception handling could lead to a different exception being thrown and not caught within the method, changing the exception thrown by the method, which could potentially be a compatibility issue as per rule number 2. Thus, the CI type is 2."
413,"<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean)>",23,24,"<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean)>","<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean)>",0,"{
    // A HandleView relies on the layout, which may be nulled by external methods
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        // Will update controllers' state, hiding them and stopping selection mode if needed
        prepareCursorControllers();
        return;
    }
    layout = getActiveLayout();
    boolean offsetChanged = offset != mPreviousOffset;
    if (offsetChanged || parentScrolled) {
        if (offsetChanged) {
            updateSelection(offset);
            addPositionToTouchUpFilter(offset);
        }
        final int line = layout.getLineForOffset(offset);
        mPrevLine = line;
        mPositionX = (int) (layout.getPrimaryHorizontal(offset) - 0.5f - mHotspotX - getHorizontalOffset() + getCursorOffset());
        mPositionY = layout.getLineBottom(line);
        // Take TextView's padding and scroll into account.
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionY += mTextView.viewportToContentVerticalOffset();
        mPreviousOffset = offset;
        mPositionHasChanged = true;
    }
}","{
    // A HandleView relies on the layout, which may be nulled by external methods
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        // Will update controllers' state, hiding them and stopping selection mode if needed
        prepareCursorControllers();
        return;
    }
    layout = mTextView.getLayout();
    boolean offsetChanged = offset != mPreviousOffset;
    if (offsetChanged || forceUpdatePosition) {
        if (offsetChanged) {
            updateSelection(offset);
            addPositionToTouchUpFilter(offset);
        }
        final int line = layout.getLineForOffset(offset);
        mPrevLine = line;
        mPositionX = getCursorHorizontalPosition(layout, offset) - mHotspotX - getHorizontalOffset() + getCursorOffset();
        mPositionY = layout.getLineBottom(line);
        // Take TextView's padding and scroll into account.
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionY += mTextView.viewportToContentVerticalOffset();
        mPreviousOffset = offset;
        mPositionHasChanged = true;
    }
}",1,,"/**
 * @param offset Cursor offset. Must be in [-1, length].
 * @param forceUpdatePosition whether to force update the position.  This should be true
 * when If the parent has been scrolled, for example.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The method `getActiveLayout()` call was replaced with `mTextView.getLayout()` and the variable `parentScrolled` was changed to `forceUpdatePosition`. Also, the calculation of `mPositionX` was changed from using an arithmetic expression to calling the method `getCursorHorizontalPosition(layout, offset)`. These changes are Code Change Types 1, 3, and 4: return statement changed due to a different calculation and potentially different result, control dependency change due to the change of variable in the condition, and other statement change for the modified calculation.","Despite these changes, there is no compatibility issue since the changes do not affect the API's return type or return value - the method is void, and it does not throw an exception; hence there is no potential change in exception handling. The behavior inside the method has changed, but the impact of these changes does not result in a different behavior observable by the method's caller concerning its return type/value or exceptions thrown, thus it's CI type 0."
414,<android.app.admin.DevicePolicyManager: void wipeData(int)>,23,24,<android.app.admin.DevicePolicyManager: void wipeData(int)>,<android.app.admin.DevicePolicyManager: void wipeData(int)>,0,"{
    if (mService != null) {
        try {
            mService.wipeData(flags, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""wipeData"");
    if (mService != null) {
        try {
            mService.wipeData(flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Ask the user data be wiped.  Wiping the primary user will cause the
 * device to reboot, erasing all user data while next booting up.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently supported flags
 * are {@link #WIPE_EXTERNAL_STORAGE} and
 * {@link #WIPE_RESET_PROTECTION_DATA}.
 */
","/**
 * Ask the user data be wiped. Wiping the primary user will cause the device to reboot, erasing
 * all user data while next booting up.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 * be able to call this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently supported flags are
 * {@link #WIPE_EXTERNAL_STORAGE} and {@link #WIPE_RESET_PROTECTION_DATA}.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The new method call throwIfParentInstance(""wipeData"") has been added before the existing check for the service, which means a potential exception can be thrown earlier. The arguments passed to the method mService.wipeData have changed; previously it took two arguments, now it only takes one. The RemoteException is no longer simply logged; it is now rethrown as a RuntimeException using e.rethrowFromSystemServer(), changing the way exceptions are handled. This results in changes of type 2, 3, 4, and 5.","Because of the added throwIfParentInstance call, an exception might be thrown where previously the code would proceed. This is a CI because it alters the possible exceptions thrown (CI type 2). The RemoteException is also now propagated using rethrowFromSystemServer(), which again changes the exception handling behavior (CI type 2). The removal of the UserHandle.myUserId() parameter in the call to mService.wipeData(flags) may affect behavior depending on the implementation of the wipeData method in mService, leading to a difference in the wiping procedure (CI type 1), which is a potential difference in the return value (although the method's return type is void, the side effects can be considered as return value changes in this context)."
415,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",23,24,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>","<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",0,"{
    // Set it to 3 for backward compatibility.
    if (sensor.mType == Sensor.TYPE_ROTATION_VECTOR && sdkLevel <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        return 3;
    }
    int offset = sensor.mType;
    if (offset >= sSensorReportingModes.length) {
        // sensor
        return 16;
    }
    return sSensorReportingModes[offset];
}","{
    // Set it to 3 for backward compatibility.
    if (sensor.mType == Sensor.TYPE_ROTATION_VECTOR && sdkLevel <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        return 3;
    }
    int offset = sensor.mType;
    if (offset >= sSensorReportingModes.length) {
        // FIXME: sensor HAL should advertise how much data is returned per sensor
        return 16;
    }
    return sSensorReportingModes[offset];
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between these two versions is a comment, which does not affect the API's behavior. So the code change type is 4.","Since there is no change in the actual implementation that affects the behavior of the API, there is no Compatibility Issue. The API would behave the same way in both versions in all situations."
416,"<android.app.admin.DevicePolicyManager: boolean installCaCert(ComponentName,byte[])>",23,24,"<android.app.admin.DevicePolicyManager: boolean installCaCert(ComponentName,byte[])>","<android.app.admin.DevicePolicyManager: boolean installCaCert(ComponentName,byte[])>",0,"{
    if (mService != null) {
        try {
            return mService.installCaCert(admin, certBuffer);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""installCaCert"");
    if (mService != null) {
        try {
            return mService.installCaCert(admin, certBuffer);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Installs the given certificate as a user CA.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to install.
 *
 * @return false if the certBuffer cannot be parsed or installation is
 * interrupted, true otherwise.
 */
","/**
 * Installs the given certificate as a user CA.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to install.
 *
 * @return false if the certBuffer cannot be parsed or installation is
 * interrupted, true otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional method call 'throwIfParentInstance(""installCaCert"")' is introduced before the existing control and try-catch blocks. This is Other statement change, so the code change type is 4.","The new method call 'throwIfParentInstance(""installCaCert"")' could throw an exception before any of the previous logic is executed if certain conditions are met (when the instance is a parent instance). However, since it is not changing how 'installCaCert' behaves in terms of return values or exceptions once inside its original logic, it doesn't inherently lead to a Compatibility Issue as defined. The API's control flow, return values, or exception pattern remains unchanged post-invocation of this method. Therefore, there's no Compatibility Issue, so the CI type is 0."
417,"<android.app.admin.DevicePolicyManager: void setAccountManagementDisabled(ComponentName,String,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setAccountManagementDisabled(ComponentName,String,boolean)>","<android.app.admin.DevicePolicyManager: void setAccountManagementDisabled(ComponentName,String,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setAccountManagementDisabled(admin, accountType, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setAccountManagementDisabled"");
    if (mService != null) {
        try {
            mService.setAccountManagementDisabled(admin, accountType, disabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a device owner or profile owner to disable account management for a specific type
 * of account.
 *
 * <p>The calling device admin must be a device owner or profile owner. If it is not, a
 * security exception will be thrown.
 *
 * <p>When account management is disabled for an account type, adding or removing an account
 * of that type will not be possible.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param accountType For which account management is disabled or enabled.
 * @param disabled The boolean indicating that account management will be disabled (true) or
 * enabled (false).
 */
","/**
 * Called by a device owner or profile owner to disable account management for a specific type
 * of account.
 * <p>
 * The calling device admin must be a device owner or profile owner. If it is not, a security
 * exception will be thrown.
 * <p>
 * When account management is disabled for an account type, adding or removing an account of
 * that type will not be possible.
 * <p>
 * From {@link android.os.Build.VERSION_CODES#N} the profile or device owner can still use
 * {@link android.accounts.AccountManager} APIs to add or remove accounts when account
 * management for a specific type is disabled.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param accountType For which account management is disabled or enabled.
 * @param disabled The boolean indicating that account management will be disabled (true) or
 * enabled (false).
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","The late implementation introduces a new method call, throwIfParentInstance(""setAccountManagementDisabled""), before the existing control flow, which is an 'Other statement changed' (4). Additionally, the exception handling statement changed from logging the exception to rethrowing a new exception (throw e.rethrowFromSystemServer()), which is a 'Exception handling statement changed' (2). Also, these changes impact the method behavior which can cause the method to possibly throw an exception before executing the rest of its code.","There is a 'Compatibility Issue' due to the new 'throw' statement (throwIfParentInstance), which introduces a new exception that was not present in the early version, leading to type 2 CI. Furthermore, changing the exception handling also leads to a 'Compatibility Issue' due to the potential change in exception thrown when encountering a RemoteException (type 2 CI). Additionally, since the execution path could be altered by the new throw statement, it can affect the return of the method, causing a type 1 CI."
418,"<android.content.res.Resources: void getValue(String,TypedValue,boolean)>",23,24,"<android.content.res.Resources: void getValue(String,TypedValue,boolean)>","<android.content.res.Resources: void getValue(String,TypedValue,boolean)>",0,"{
    int id = getIdentifier(name, ""string"", null);
    if (id != 0) {
        getValue(id, outValue, resolveRefs);
        return;
    }
    throw new NotFoundException(""String resource name "" + name);
}","{
    mResourcesImpl.getValue(name, outValue, resolveRefs);
}",1,"/**
 * Return the raw data associated with a particular resource ID.
 * See getIdentifier() for information on how names are mapped to resource
 * IDs, and getString(int) for information on how string resources are
 * retrieved.
 *
 * <p>Note: use of this function is discouraged.  It is much more
 * efficient to retrieve resources by identifier than by name.
 *
 * @param name The name of the desired resource.  This is passed to
 * getIdentifier() with a default type of ""string"".
 * @param outValue Object in which to place the resource data.
 * @param resolveRefs If true, a resource that is a reference to another
 * resource will be followed so that you receive the
 * actual final resource data.  If false, the TypedValue
 * will be filled in with the reference itself.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Return the raw data associated with a particular resource ID.
 * See getIdentifier() for information on how names are mapped to resource
 * IDs, and getString(int) for information on how string resources are
 * retrieved.
 *
 * <p>Note: use of this function is discouraged.  It is much more
 * efficient to retrieve resources by identifier than by name.
 *
 * @param name The name of the desired resource.  This is passed to
 * getIdentifier() with a default type of ""string"".
 * @param outValue Object in which to place the resource data.
 * @param resolveRefs If true, a resource that is a reference to another
 * resource will be followed so that you receive the
 * actual final resource data.  If false, the TypedValue
 * will be filled in with the reference itself.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","The implementation of the method has been changed entirely from using getIdentifier and manually throwing `NotFoundException` to delegating the call to mResourcesImpl.getValue, which hints at a refactor towards using a dependent method that handles the logic. This denotes both a change in the return statement (since an intermediate return is removed) and reliance on possibly new or modified behavior of the dependent API (mResourcesImpl.getValue). Therefore, the code change types are 1 and 5.","Since the early version throws an exception explicitly and the late version does not, but delegates the responsibility to another method, there might be a change in the exception handling, which can potentially lead to a different value returned (if the new method does not throw an exception for the same situation) as well as differences in the exceptions that may be thrown. Therefore, CI types are 1 and 2."
419,<android.app.AppOpsManager: String permissionToOp(String)>,23,24,<android.app.AppOpsManager: String permissionToOp(String)>,<android.app.AppOpsManager: String permissionToOp(String)>,0,"{
    final Integer opCode = sPermToOp.get(permission);
    if (opCode == null) {
        return null;
    }
    return sOpToString[opCode];
}","{
    final Integer opCode = sRuntimePermToOp.get(permission);
    if (opCode == null) {
        return null;
    }
    return sOpToString[opCode];
}",1,"/**
 * Gets the app op name associated with a given permission.
 * The app op name is one of the public constants defined
 * in this class such as {@link #OPSTR_COARSE_LOCATION}.
 *
 * @param permission The permission.
 * @return The app op associated with the permission or null.
 */
","/**
 * Gets the app op name associated with a given permission.
 * The app op name is one of the public constants defined
 * in this class such as {@link #OPSTR_COARSE_LOCATION}.
 * This API is intended to be used for mapping runtime
 * permissions to the corresponding app op.
 *
 * @param permission The permission.
 * @return The app op associated with the permission or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from `sPermToOp.get(permission)` to `sRuntimePermToOp.get(permission)`, which indicates that the source of the operation code mapping has been altered. Thus,the change type is 5.","Despite the change in the mapping source, both versions return `null` if `opCode` is `null` and `sOpToString[opCode]` otherwise. Since the general behavior of returning a corresponding operation string or `null` hasn't changed, there is no Compatibility Issue."
420,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,23,24,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,0,"{
    if (networkCallback == null || networkCallback.networkRequest == null || networkCallback.networkRequest.requestId == REQUEST_ID_UNSET) {
        throw new IllegalArgumentException(""Invalid NetworkCallback"");
    }
    try {
        mService.releaseNetworkRequest(networkCallback.networkRequest);
    } catch (RemoteException e) {
    }
}","{
    if (networkCallback == null || networkCallback.networkRequest == null || networkCallback.networkRequest.requestId == REQUEST_ID_UNSET) {
        throw new IllegalArgumentException(""Invalid NetworkCallback"");
    }
    try {
        mService.releaseNetworkRequest(networkCallback.networkRequest);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    synchronized (sNetworkCallback) {
        sNetworkCallback.remove(networkCallback.networkRequest);
    }
}",1,"/**
 * Unregisters callbacks about and possibly releases networks originating from
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and {@link #registerNetworkCallback}
 * calls.  If the given {@code NetworkCallback} had previously been used with
 * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request
 * will be disconnected.
 *
 * @param networkCallback The {@link NetworkCallback} used when making the request.
 */
","/**
 * Unregisters callbacks about and possibly releases networks originating from
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and
 * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} calls.
 * If the given {@code NetworkCallback} had previously been used with
 * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request
 * will be disconnected.
 *
 * @param networkCallback The {@link NetworkCallback} used when making the request.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is a new exception handling statement (throw e.rethrowFromSystemServer()), and a new block of code (synchronized block with sNetworkCallback.remove()) that has been added, so the change type is 2,4.","The late version introduces new behavior that, if a RemoteException occurs, it will now throw an exception instead of just catching it and doing nothing. This could cause compatibility issues for callers not expecting an exception, so the CI type is 2."
421,<android.print.PrinterId: int hashCode()>,23,24,<android.print.PrinterId: int hashCode()>,<android.print.PrinterId: int hashCode()>,0,"{
    final int prime = 31;
    int hashCode = 1;
    hashCode = prime * hashCode + ((mServiceName != null) ? mServiceName.hashCode() : 1);
    hashCode = prime * hashCode + mLocalId.hashCode();
    return hashCode;
}","{
    final int prime = 31;
    int hashCode = 1;
    hashCode = prime * hashCode + mServiceName.hashCode();
    hashCode = prime * hashCode + mLocalId.hashCode();
    return hashCode;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The change is in the calculation of the hashCode. The ternary check for null (`mServiceName != null`) before calling `hashCode()` on `mServiceName` has been removed, so the change types are 1 and 4.","Since the null check is removed, there is a change in the return statement, and if `mServiceName` is null in the new version, a NullPointerException would be thrown which is a change in behavior, so the CI type is 1."
422,"<android.app.Notification.Builder: Builder setSound(Uri,int)>",23,24,"<android.app.Notification.Builder: Builder setSound(Uri,int)>","<android.app.Notification.Builder: Builder setSound(Uri,int)>",0,"{
    mSound = sound;
    mAudioStreamType = streamType;
    return this;
}","{
    mN.sound = sound;
    mN.audioStreamType = streamType;
    return this;
}",1,"/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 * @deprecated use {@link #setSound(Uri, AudioAttributes)} instead.
 * @see Notification#sound
 */
","/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 * @deprecated use {@link #setSound(Uri, AudioAttributes)} instead.
 * @see Notification#sound
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The code change is that the instance variables 'mSound' and 'mAudioStreamType' have been changed to 'mN.sound' and 'mN.audioStreamType'. The assignment statements are altered, but they're just updating a different, yet equivalent, set of instance variables within the object, so the change type is 4.","There's no Compatibility Issue since the method still behaves the same from the caller's perspective. It sets the sound and audio stream type for the notification and returns the same Builder object. As long as the 'mN' object is equivalent to the 'this' object with regards to notification settings, the functionality observed by the API user is unchanged. Therefore, there is no compatibility issue (CI type is 0)."
423,<android.app.admin.DevicePolicyManager: int getStorageEncryptionStatus()>,23,24,<android.app.admin.DevicePolicyManager: int getStorageEncryptionStatus()>,<android.app.admin.DevicePolicyManager: int getStorageEncryptionStatus()>,0,"{
    return getStorageEncryptionStatus(UserHandle.myUserId());
}","{
    throwIfParentInstance(""getStorageEncryptionStatus"");
    return getStorageEncryptionStatus(myUserId());
}",1,"/**
 * Called by an application that is administering the device to
 * determine the current encryption status of the device.
 *
 * Depending on the returned status code, the caller may proceed in different
 * ways.  If the result is {@link #ENCRYPTION_STATUS_UNSUPPORTED}, the
 * storage system does not support encryption.  If the
 * result is {@link #ENCRYPTION_STATUS_INACTIVE}, use {@link
 * #ACTION_START_ENCRYPTION} to begin the process of encrypting or decrypting the
 * storage.  If the result is {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY}, the
 * storage system has enabled encryption but no password is set so further action
 * may be required.  If the result is {@link #ENCRYPTION_STATUS_ACTIVATING} or
 * {@link #ENCRYPTION_STATUS_ACTIVE}, no further action is required.
 *
 * @return current status of encryption. The value will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE},
 * {@link #ENCRYPTION_STATUS_ACTIVATING}, {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY},
 * or {@link #ENCRYPTION_STATUS_ACTIVE}.
 */
","/**
 * Called by an application that is administering the device to
 * determine the current encryption status of the device.
 *
 * Depending on the returned status code, the caller may proceed in different
 * ways.  If the result is {@link #ENCRYPTION_STATUS_UNSUPPORTED}, the
 * storage system does not support encryption.  If the
 * result is {@link #ENCRYPTION_STATUS_INACTIVE}, use {@link
 * #ACTION_START_ENCRYPTION} to begin the process of encrypting or decrypting the
 * storage.  If the result is {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY}, the
 * storage system has enabled encryption but no password is set so further action
 * may be required.  If the result is {@link #ENCRYPTION_STATUS_ACTIVATING} or
 * {@link #ENCRYPTION_STATUS_ACTIVE}, no further action is required.
 *
 * @return current status of encryption. The value will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE},
 * {@link #ENCRYPTION_STATUS_ACTIVATING}, {@link #ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY},
 * or {@link #ENCRYPTION_STATUS_ACTIVE}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The late version contains a new method invocation 'throwIfParentInstance(""getStorageEncryptionStatus"")', and a different method 'myUserId()' instead of 'UserHandle.myUserId()' has been used, so the code change types are 2, 4, and 5.","Introducing a new method call 'throwIfParentInstance(""getStorageEncryptionStatus"")' could potentially throw a new exception that wasn't thrown in the early version, which will cause a different exception handling. The change of the method name from 'UserHandle.myUserId()' to 'myUserId()' might indicate a change in the underlying implementation, although it is not certain if it leads to different behavior. Based on the information that the 'myUserId()' method call differs from 'UserHandle.myUserId()', it is a potential dependent API change, so the CI type is 2 due to the potential for different exception handling behavior."
425,<android.animation.AnimatorSet: Builder play(Animator)>,23,24,<android.animation.AnimatorSet: Builder play(Animator)>,<android.animation.AnimatorSet: Builder play(Animator)>,0,"{
    if (anim != null) {
        mNeedsSort = true;
        return new Builder(anim);
    }
    return null;
}","{
    if (anim != null) {
        return new Builder(anim);
    }
    return null;
}",1,"/**
 * This method creates a <code>Builder</code> object, which is used to
 * set up playing constraints. This initial <code>play()</code> method
 * tells the <code>Builder</code> the animation that is the dependency for
 * the succeeding commands to the <code>Builder</code>. For example,
 * calling <code>play(a1).with(a2)</code> sets up the AnimatorSet to play
 * <code>a1</code> and <code>a2</code> at the same time,
 * <code>play(a1).before(a2)</code> sets up the AnimatorSet to play
 * <code>a1</code> first, followed by <code>a2</code>, and
 * <code>play(a1).after(a2)</code> sets up the AnimatorSet to play
 * <code>a2</code> first, followed by <code>a1</code>.
 *
 * <p>Note that <code>play()</code> is the only way to tell the
 * <code>Builder</code> the animation upon which the dependency is created,
 * so successive calls to the various functions in <code>Builder</code>
 * will all refer to the initial parameter supplied in <code>play()</code>
 * as the dependency of the other animations. For example, calling
 * <code>play(a1).before(a2).before(a3)</code> will play both <code>a2</code>
 * and <code>a3</code> when a1 ends; it does not set up a dependency between
 * <code>a2</code> and <code>a3</code>.</p>
 *
 * @param anim The animation that is the dependency used in later calls to the
 * methods in the returned <code>Builder</code> object. A null parameter will result
 * in a null <code>Builder</code> return value.
 * @return Builder The object that constructs the AnimatorSet based on the dependencies
 * outlined in the calls to <code>play</code> and the other methods in the
 * <code>Builder</code object.
 */
","/**
 * This method creates a <code>Builder</code> object, which is used to
 * set up playing constraints. This initial <code>play()</code> method
 * tells the <code>Builder</code> the animation that is the dependency for
 * the succeeding commands to the <code>Builder</code>. For example,
 * calling <code>play(a1).with(a2)</code> sets up the AnimatorSet to play
 * <code>a1</code> and <code>a2</code> at the same time,
 * <code>play(a1).before(a2)</code> sets up the AnimatorSet to play
 * <code>a1</code> first, followed by <code>a2</code>, and
 * <code>play(a1).after(a2)</code> sets up the AnimatorSet to play
 * <code>a2</code> first, followed by <code>a1</code>.
 *
 * <p>Note that <code>play()</code> is the only way to tell the
 * <code>Builder</code> the animation upon which the dependency is created,
 * so successive calls to the various functions in <code>Builder</code>
 * will all refer to the initial parameter supplied in <code>play()</code>
 * as the dependency of the other animations. For example, calling
 * <code>play(a1).before(a2).before(a3)</code> will play both <code>a2</code>
 * and <code>a3</code> when a1 ends; it does not set up a dependency between
 * <code>a2</code> and <code>a3</code>.</p>
 *
 * @param anim The animation that is the dependency used in later calls to the
 * methods in the returned <code>Builder</code> object. A null parameter will result
 * in a null <code>Builder</code> return value.
 * @return Builder The object that constructs the AnimatorSet based on the dependencies
 * outlined in the calls to <code>play</code> and the other methods in the
 * <code>Builder</code object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The line 'mNeedsSort = true;' present in the early version has been removed in the late version, without any changes to the control flow or the method's returned value. Therefore, the change type is 4 (Other statement changed).","The removal of the 'mNeedsSort = true;' does not affect the return value or the exception handling of the method. As such, the behaviour of the method remains consistent between the two versions, resulting in No Compatibility Issue (0)."
426,<android.app.LoadedApk.ReceiverDispatcher.Args: void run()>,23,24,<android.app.LoadedApk.ReceiverDispatcher.Args: void run()>,<android.app.LoadedApk.ReceiverDispatcher.Args: void run()>,0,"{
    final BroadcastReceiver receiver = mReceiver;
    final boolean ordered = mOrdered;
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
        Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
    }
    final IActivityManager mgr = ActivityManagerNative.getDefault();
    final Intent intent = mCurIntent;
    mCurIntent = null;
    if (receiver == null || mForgotten) {
        if (mRegistered && ordered) {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
            sendFinished(mgr);
        }
        return;
    }
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        setExtrasClassLoader(cl);
        receiver.setPendingResult(this);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && ordered) {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
            sendFinished(mgr);
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (receiver.getPendingResult() != null) {
        finish();
    }
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
}","{
    final BroadcastReceiver receiver = mReceiver;
    final boolean ordered = mOrdered;
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
        Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
    }
    final IActivityManager mgr = ActivityManagerNative.getDefault();
    final Intent intent = mCurIntent;
    if (intent == null) {
        Log.wtf(TAG, ""Null intent being dispatched, mDispatched="" + mDispatched);
    }
    mCurIntent = null;
    mDispatched = true;
    if (receiver == null || intent == null || mForgotten) {
        if (mRegistered && ordered) {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
            sendFinished(mgr);
        }
        return;
    }
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        intent.prepareToEnterProcess();
        setExtrasClassLoader(cl);
        receiver.setPendingResult(this);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && ordered) {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
            sendFinished(mgr);
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (receiver.getPendingResult() != null) {
        finish();
    }
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The code changes include the addition of a new check for the `intent` being `null` right after its assignment, the addition of `intent.prepareToEnterProcess();` before setting the class loader, and the setting of `mDispatched` to `true`, which affects the control flow and other statements, so the change types are 1 (because the null check for `intent` could cause a new path that returns early), 3 (modification of the while loop's condition), and 4 (other statement change).","The new null check for `intent` and the early return if it's null along with setting a boolean flag `mDispatched` potentially affects the behavior of the method by changing the flow of execution, causing the method to potentially return without executing further code that it would have in the previous version. Therefore, it introduces a new path that can cause a different return behavior (early exit if `intent` is null), leading to a compatibility issue of type 1."
429,"<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordHistoryLength(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordHistoryLength(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the length
 * of the password history. After setting this, the user will not be able to
 * enter a new password that is the same as any password in the history. Note
 * that the current password will remain until the user has set a new one, so
 * the change does not take place immediately. To prompt the user for a new
 * password, use {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 * This constraint is only imposed if the administrator has also requested
 * either {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, or {@link #PASSWORD_QUALITY_ALPHANUMERIC}
 * with {@link #setPasswordQuality}.
 *
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired length of password history. A value of 0
 * means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the length of the password
 * history. After setting this, the user will not be able to enter a new password that is the
 * same as any password in the history. Note that the current password will remain until the
 * user has set a new one, so the change does not take place immediately. To prompt the user for
 * a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is
 * only imposed if the administrator has also requested either {@link #PASSWORD_QUALITY_NUMERIC}
 * , {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX} {@link #PASSWORD_QUALITY_ALPHABETIC}, or
 * {@link #PASSWORD_QUALITY_ALPHANUMERIC} with {@link #setPasswordQuality}.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired length of password history. A value of 0 means there is no
 * restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The method `setPasswordHistoryLength` has changed to include an additional parameter (`mParentInstance`), which is a change in the dependent API. Also, the catch block now throws an exception instead of logging it, so there is a change in the exception handling statement as well. Therefore, the code change types are 2 and 5.","With the new throw in the catch block, this method will propagate exceptions that it did not before, which is a compatibility issue. Additionally, since it relies on a dependent API that has changed, if the parent instance impacts the behavior of `setPasswordHistoryLength`, it may result in different effects when called. The CI type is 2 due to the change in exception handling behavior."
430,<android.inputmethodservice.InputMethodService: void onUpdateExtractingViews(EditorInfo)>,23,24,<android.inputmethodservice.InputMethodService: void onUpdateExtractingViews(EditorInfo)>,<android.inputmethodservice.InputMethodService: void onUpdateExtractingViews(EditorInfo)>,0,"{
    if (!isExtractViewShown()) {
        return;
    }
    if (mExtractAccessories == null) {
        return;
    }
    final boolean hasAction = ei.actionLabel != null || ((ei.imeOptions & EditorInfo.IME_MASK_ACTION) != EditorInfo.IME_ACTION_NONE && (ei.imeOptions & EditorInfo.IME_FLAG_NO_ACCESSORY_ACTION) == 0 && ei.inputType != InputType.TYPE_NULL);
    if (hasAction) {
        mExtractAccessories.setVisibility(View.VISIBLE);
        if (mExtractAction != null) {
            if (ei.actionLabel != null) {
                mExtractAction.setText(ei.actionLabel);
            } else {
                mExtractAction.setText(getTextForImeAction(ei.imeOptions));
            }
            mExtractAction.setOnClickListener(mActionClickListener);
        }
    } else {
        mExtractAccessories.setVisibility(View.GONE);
        if (mExtractAction != null) {
            mExtractAction.setOnClickListener(null);
        }
    }
}","{
    if (!isExtractViewShown()) {
        return;
    }
    if (mExtractAccessories == null) {
        return;
    }
    final boolean hasAction = ei.actionLabel != null || ((ei.imeOptions & EditorInfo.IME_MASK_ACTION) != EditorInfo.IME_ACTION_NONE && (ei.imeOptions & EditorInfo.IME_FLAG_NO_ACCESSORY_ACTION) == 0 && ei.inputType != InputType.TYPE_NULL);
    if (hasAction) {
        mExtractAccessories.setVisibility(View.VISIBLE);
        if (mExtractAction != null) {
            if (mExtractAction instanceof ImageButton) {
                ((ImageButton) mExtractAction).setImageResource(getIconForImeAction(ei.imeOptions));
                if (ei.actionLabel != null) {
                    mExtractAction.setContentDescription(ei.actionLabel);
                } else {
                    mExtractAction.setContentDescription(getTextForImeAction(ei.imeOptions));
                }
            } else {
                if (ei.actionLabel != null) {
                    ((TextView) mExtractAction).setText(ei.actionLabel);
                } else {
                    ((TextView) mExtractAction).setText(getTextForImeAction(ei.imeOptions));
                }
            }
            mExtractAction.setOnClickListener(mActionClickListener);
        }
    } else {
        mExtractAccessories.setVisibility(View.GONE);
        if (mExtractAction != null) {
            mExtractAction.setOnClickListener(null);
        }
    }
}",1,"/**
 * Called when the fullscreen-mode extracting editor info has changed,
 * to update the state of its UI such as the action buttons shown.
 * You do not need to deal with this if you are using the standard
 * full screen extract UI.  If replacing it, you will need to re-implement
 * this to put the appropriate action button in your own UI and handle it,
 * and perform any other changes.
 *
 * <p>The standard implementation turns on or off its accessory area
 * depending on whether there is an action button, and hides or shows
 * the entire extract area depending on whether it makes sense for the
 * current editor.  In particular, a {@link InputType#TYPE_NULL} or
 * {@link InputType#TYPE_TEXT_VARIATION_FILTER} input type will turn off the
 * extract area since there is no text to be shown.
 */
","/**
 * Called when the fullscreen-mode extracting editor info has changed,
 * to update the state of its UI such as the action buttons shown.
 * You do not need to deal with this if you are using the standard
 * full screen extract UI.  If replacing it, you will need to re-implement
 * this to put the appropriate action button in your own UI and handle it,
 * and perform any other changes.
 *
 * <p>The standard implementation turns on or off its accessory area
 * depending on whether there is an action button, and hides or shows
 * the entire extract area depending on whether it makes sense for the
 * current editor.  In particular, a {@link InputType#TYPE_NULL} or
 * {@link InputType#TYPE_TEXT_VARIATION_FILTER} input type will turn off the
 * extract area since there is no text to be shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change involves an additional type check and casting for `mExtractAction`. If `mExtractAction` is an instance of `ImageButton`, it sets an image resource and content description; otherwise, it behaves similarly to the earlier version for a `TextView`. Additionally, instead of directly setting `mExtractAction`'s text, it now checks the type of the view which is an `Other statement changed`. There are no modifications to return statements or exception handling, but the control dependency has changed, so the code change types are 3 and 4.","Despite the control dependency change and additional instance checks, these changes do not modify the behavior in a way that leads to returning different variables or throwing different exceptions. The behavior is enhanced or altered based on the type of the view, but the essential functionality remains the same, and the main flow (what the method does when it's executed) doesn't lead to a different outcome. Thus, there is no Compatibility Issue in this context."
431,"<android.app.admin.DevicePolicyManager: boolean setPermittedAccessibilityServices(ComponentName,List<String>)>",23,24,"<android.app.admin.DevicePolicyManager: boolean setPermittedAccessibilityServices(ComponentName,List<String>)>","<android.app.admin.DevicePolicyManager: boolean setPermittedAccessibilityServices(ComponentName,List<String>)>",0,"{
    if (mService != null) {
        try {
            return mService.setPermittedAccessibilityServices(admin, packageNames);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""setPermittedAccessibilityServices"");
    if (mService != null) {
        try {
            return mService.setPermittedAccessibilityServices(admin, packageNames);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by a profile or device owner to set the permitted accessibility services. When
 * set by a device owner or profile owner the restriction applies to all profiles of the
 * user the device owner or profile owner is an admin for.
 *
 * By default the user can use any accessiblity service. When zero or more packages have
 * been added, accessiblity services that are not in the list and not part of the system
 * can not be enabled by the user.
 *
 * <p> Calling with a null value for the list disables the restriction so that all services
 * can be used, calling with an empty list only allows the builtin system's services.
 *
 * <p> System accesibility services are always available to the user the list can't modify
 * this.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageNames List of accessibility service package names.
 *
 * @return true if setting the restriction succeeded. It fail if there is
 * one or more non-system accessibility services enabled, that are not in the list.
 */
","/**
 * Called by a profile or device owner to set the permitted accessibility services. When set by
 * a device owner or profile owner the restriction applies to all profiles of the user the
 * device owner or profile owner is an admin for. By default the user can use any accessiblity
 * service. When zero or more packages have been added, accessiblity services that are not in
 * the list and not part of the system can not be enabled by the user.
 * <p>
 * Calling with a null value for the list disables the restriction so that all services can be
 * used, calling with an empty list only allows the builtin system's services.
 * <p>
 * System accesibility services are always available to the user the list can't modify this.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageNames List of accessibility service package names.
 * @return true if setting the restriction succeeded. It fail if there is one or more non-system
 * accessibility services enabled, that are not in the list.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The late implementation has added a new throw statement at the beginning (`throwIfParentInstance(""setPermittedAccessibilityServices"");`), and the exception handling has changed from logging the exception to rethrowing it (`throw e.rethrowFromSystemServer();`).  Moreover, the control flow structure remains the same, but with the additional throw statement outside existing control statements. Therefore, the change types are 2 for the exception handling change, 3 for being a control dependency change since the throw introduces a new potential exit point before the previous control flow, and 4 for introducing a new other statement at the beginning.","There is a CI related to exception handling since the late implementation introduces a new throw statement which can throw a new exception that wasn't thrown previously, so the CI type is 2."
432,<android.net.ConnectivityManager: Network[] getAllNetworks()>,23,24,<android.net.ConnectivityManager: Network[] getAllNetworks()>,<android.net.ConnectivityManager: Network[] getAllNetworks()>,0,"{
    try {
        return mService.getAllNetworks();
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return mService.getAllNetworks();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns an array of all {@link Network} currently tracked by the
 * framework.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of {@link Network} objects.
 */
","/**
 * Returns an array of all {@link Network} currently tracked by the
 * framework.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of {@link Network} objects.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from returning null to throwing an exception, so the change type is 2.","Because of the change in the exception handling statement, where the old implementation returned null on RemoteException but the new implementation throws the exception, the behaviour of the API will change when an exception is encountered. This change can cause a Compatibility Issue due to different exception handling, so the CI type is 2."
433,"<android.widget.AbsListView: boolean performLongPress(View,int,long)>",23,24,"<android.widget.AbsListView: boolean performLongPress(View,int,long)>","<android.widget.AbsListView: boolean performLongPress(View,int,long)>",0,"{
    // CHOICE_MODE_MULTIPLE_MODAL takes over long press.
    if (mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) {
        if (mChoiceActionMode == null && (mChoiceActionMode = startActionMode(mMultiChoiceModeCallback)) != null) {
            setItemChecked(longPressPosition, true);
            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        }
        return true;
    }
    boolean handled = false;
    if (mOnItemLongClickListener != null) {
        handled = mOnItemLongClickListener.onItemLongClick(AbsListView.this, child, longPressPosition, longPressId);
    }
    if (!handled) {
        mContextMenuInfo = createContextMenuInfo(child, longPressPosition, longPressId);
        handled = super.showContextMenuForChild(AbsListView.this);
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    return handled;
}","{
    return performLongPress(child, longPressPosition, longPressId, CheckForLongPress.INVALID_COORD, CheckForLongPress.INVALID_COORD);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early implementation contains a significant block of logic and conditional statements that can trigger various behaviors. In the late implementation, all of this has been replaced by a single method call to another method performLongPress with different parameters. This is a major change that encompasses ‘Return statement changed’ (1) because the source of the return value has fundamentally shifted to a new method. It may also be classified as 'Other statement changed' (4) because the specific implementation details have completely changed.","The late version of the method delegates the action to a completely different method. This could lead to a change in behavior, potentially resulting in a different value being returned. There's no guarantee the new method will account for all the logic previously contained within the early version of the method, hence a CI related to potentially different return values is identified (1)."
434,<android.hardware.ConsumerIrManager: boolean hasIrEmitter()>,23,24,<android.hardware.ConsumerIrManager: boolean hasIrEmitter()>,<android.hardware.ConsumerIrManager: boolean hasIrEmitter()>,0,"{
    if (mService == null) {
        Log.w(TAG, ""no consumer ir service."");
        return false;
    }
    try {
        return mService.hasIrEmitter();
    } catch (RemoteException e) {
    }
    return false;
}","{
    if (mService == null) {
        Log.w(TAG, ""no consumer ir service."");
        return false;
    }
    try {
        return mService.hasIrEmitter();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Check whether the device has an infrared emitter.
 *
 * @return true if the device has an infrared emitter, else false.
 */
","/**
 * Check whether the device has an infrared emitter.
 *
 * @return true if the device has an infrared emitter, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has changed by adding a throw statement `throw e.rethrowFromSystemServer();` instead of just swallowing the exception, so the change type is 2.","Because the late version of the API throws an exception instead of returning false in case of a RemoteException, clients calling this method will experience a different behavior if an exception occurs, which could represent a compatibility issue. Therefore, the CI type is 2."
435,"<android.app.admin.DevicePolicyManager: void setCrossProfileCallerIdDisabled(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setCrossProfileCallerIdDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setCrossProfileCallerIdDisabled(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setCrossProfileCallerIdDisabled(admin, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setCrossProfileCallerIdDisabled"");
    if (mService != null) {
        try {
            mService.setCrossProfileCallerIdDisabled(admin, disabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile owner of a managed profile to set whether caller-Id information from
 * the managed profile will be shown in the parent profile, for incoming calls.
 *
 * <p>The calling device admin must be a profile owner. If it is not, a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled If true caller-Id information in the managed profile is not displayed.
 */
","/**
 * Called by a profile owner of a managed profile to set whether caller-Id information from the
 * managed profile will be shown in the parent profile, for incoming calls.
 * <p>
 * The calling device admin must be a profile owner. If it is not, a security exception will be
 * thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled If true caller-Id information in the managed profile is not displayed.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",2,"There's a new statement ""throwIfParentInstance(""setCrossProfileCallerIdDisabled"");"" introduced, which is not a control or return statement, and it's also not an exception handling statement, and the implementation of the method does not rely on another API. However, it introduces a potential new place where an exception could be thrown. Thus, it falls under 'Other statement changed' category (4). In addition, it is a modification to the execution of the method which could potentially affect the outcome in terms of exception throwing (5).",The new line may introduce a new throw statement execution-flow which might potentially result into this method throwing a different exception and that's why the CI type is 2.
436,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",23,24,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    int initialScrollX = -1;
    int initialScrollY = -1;
    final int action = event.getAction();
    final boolean isMouse = event.isFromSource(InputDevice.SOURCE_MOUSE);
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.didTouchFocusSelect() && !isMouse) {
        return handled;
    }
    if (action == MotionEvent.ACTION_DOWN) {
        // For touch events, the code should run only when selection is active.
        if (isMouse || isTouchSelecting(isMouse, buffer)) {
            if (!widget.isFocused()) {
                if (!widget.requestFocus()) {
                    return handled;
                }
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
            // Disallow intercepting of the touch events, so that
            // users can scroll and select at the same time.
            // without this, users would get booted out of select
            // mode once the view detected it needed to scroll.
            widget.getParent().requestDisallowInterceptTouchEvent(true);
        }
    } else if (widget.isFocused()) {
        if (action == MotionEvent.ACTION_MOVE) {
            // text selection will start from mouse pointer location.
            if (isMouse && Touch.isSelectionStarted(buffer)) {
                int offset = buffer.getSpanStart(LAST_TAP_DOWN);
                Selection.setSelection(buffer, offset);
            }
            if (isTouchSelecting(isMouse, buffer) && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            if (isTouchSelecting(isMouse, buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}","{
    int initialScrollX = -1;
    int initialScrollY = -1;
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean wasTouchSelecting = isSelecting(buffer);
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.didTouchFocusSelect()) {
        return handled;
    }
    if (action == MotionEvent.ACTION_DOWN) {
        // For touch events, the code should run only when selection is active.
        if (isSelecting(buffer)) {
            if (!widget.isFocused()) {
                if (!widget.requestFocus()) {
                    return handled;
                }
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
            // Disallow intercepting of the touch events, so that
            // users can scroll and select at the same time.
            // without this, users would get booted out of select
            // mode once the view detected it needed to scroll.
            widget.getParent().requestDisallowInterceptTouchEvent(true);
        }
    } else if (widget.isFocused()) {
        if (action == MotionEvent.ACTION_MOVE) {
            if (isSelecting(buffer) && handled) {
                final int startOffset = buffer.getSpanStart(LAST_TAP_DOWN);
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                final int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.setSelection(buffer, Math.min(startOffset, offset), Math.max(startOffset, offset));
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            if (wasTouchSelecting) {
                final int startOffset = buffer.getSpanStart(LAST_TAP_DOWN);
                final int endOffset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.setSelection(buffer, Math.min(startOffset, endOffset), Math.max(startOffset, endOffset));
                buffer.removeSpan(LAST_TAP_DOWN);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
438,<android.print.PrinterInfo: String toString()>,23,24,<android.print.PrinterInfo: String toString()>,<android.print.PrinterInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrinterInfo{"");
    builder.append(""id="").append(mId);
    builder.append("", name="").append(mName);
    builder.append("", status="").append(mStatus);
    builder.append("", description="").append(mDescription);
    builder.append("", capabilities="").append(mCapabilities);
    builder.append(""\""}"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrinterInfo{"");
    builder.append(""id="").append(mId);
    builder.append("", name="").append(mName);
    builder.append("", status="").append(mStatus);
    builder.append("", description="").append(mDescription);
    builder.append("", capabilities="").append(mCapabilities);
    builder.append("", iconResId="").append(mIconResourceId);
    builder.append("", hasCustomPrinterIcon="").append(mHasCustomPrinterIcon);
    builder.append("", customPrinterIconGen="").append(mCustomPrinterIconGen);
    builder.append("", infoIntent="").append(mInfoIntent);
    builder.append(""\""}"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation of the method has been augmented with additional data (iconResId, hasCustomPrinterIcon, customPrinterIconGen, infoIntent) being appended to the StringBuilder, and hence the string representation of the PrinterInfo object will be different in the late version. Since these changes are appending additional information to a string, the change type is 4.","There is no Compatibility Issue as the method's behavior has not changed in a way that it would return a different type, and it does not throw a different exception based on the change. It consistently returns a String representation of the object in both versions; only the content of that string has been enriched with more detail."
439,<android.animation.AnimatorSet: ArrayList<Animator> getChildAnimations()>,23,24,<android.animation.AnimatorSet: ArrayList<Animator> getChildAnimations()>,<android.animation.AnimatorSet: ArrayList<Animator> getChildAnimations()>,0,"{
    ArrayList<Animator> childList = new ArrayList<Animator>();
    for (Node node : mNodes) {
        childList.add(node.animation);
    }
    return childList;
}","{
    ArrayList<Animator> childList = new ArrayList<Animator>();
    int size = mNodes.size();
    for (int i = 0; i < size; i++) {
        Node node = mNodes.get(i);
        if (node != mRootNode) {
            childList.add(node.mAnimation);
        }
    }
    return childList;
}",1,"/**
 * Returns the current list of child Animator objects controlled by this
 * AnimatorSet. This is a copy of the internal list; modifications to the returned list
 * will not affect the AnimatorSet, although changes to the underlying Animator objects
 * will affect those objects being managed by the AnimatorSet.
 *
 * @return ArrayList<Animator> The list of child animations of this AnimatorSet.
 */
","/**
 * Returns the current list of child Animator objects controlled by this
 * AnimatorSet. This is a copy of the internal list; modifications to the returned list
 * will not affect the AnimatorSet, although changes to the underlying Animator objects
 * will affect those objects being managed by the AnimatorSet.
 *
 * @return ArrayList<Animator> The list of child animations of this AnimatorSet.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,The method implementation has changed in several ways:,3. The variable used within the node has changed from `node.animation` to `node.mAnimation`.
441,<android.widget.TabWidget: void setCurrentTab(int)>,23,24,<android.widget.TabWidget: void setCurrentTab(int)>,<android.widget.TabWidget: void setCurrentTab(int)>,0,"{
    if (index < 0 || index >= getTabCount() || index == mSelectedTab) {
        return;
    }
    if (mSelectedTab != -1) {
        getChildTabViewAt(mSelectedTab).setSelected(false);
    }
    mSelectedTab = index;
    getChildTabViewAt(mSelectedTab).setSelected(true);
    mStripMoved = true;
    if (isShown()) {
        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
    }
}","{
    if (index < 0 || index >= getTabCount() || index == mSelectedTab) {
        return;
    }
    if (mSelectedTab != -1) {
        getChildTabViewAt(mSelectedTab).setSelected(false);
    }
    mSelectedTab = index;
    getChildTabViewAt(mSelectedTab).setSelected(true);
    mStripMoved = true;
}",1,"/**
 * Sets the current tab.
 * This method is used to bring a tab to the front of the Widget,
 * and is used to post to the rest of the UI that a different tab
 * has been brought to the foreground.
 *
 * Note, this is separate from the traditional ""focus"" that is
 * employed from the view logic.
 *
 * For instance, if we have a list in a tabbed view, a user may be
 * navigating up and down the list, moving the UI focus (orange
 * highlighting) through the list items.  The cursor movement does
 * not effect the ""selected"" tab though, because what is being
 * scrolled through is all on the same tab.  The selected tab only
 * changes when we navigate between tabs (moving from the list view
 * to the next tabbed view, in this example).
 *
 * To move both the focus AND the selected tab at once, please use
 * {@link #setCurrentTab}. Normally, the view logic takes care of
 * adjusting the focus, so unless you're circumventing the UI,
 * you'll probably just focus your interest here.
 *
 * @param index The tab that you want to indicate as the selected
 * tab (tab brought to the front of the widget)
 *
 * @see #focusCurrentTab
 */
","/**
 * Sets the current tab.
 * <p>
 * This method is used to bring a tab to the front of the Widget,
 * and is used to post to the rest of the UI that a different tab
 * has been brought to the foreground.
 * <p>
 * Note, this is separate from the traditional ""focus"" that is
 * employed from the view logic.
 * <p>
 * For instance, if we have a list in a tabbed view, a user may be
 * navigating up and down the list, moving the UI focus (orange
 * highlighting) through the list items.  The cursor movement does
 * not effect the ""selected"" tab though, because what is being
 * scrolled through is all on the same tab.  The selected tab only
 * changes when we navigate between tabs (moving from the list view
 * to the next tabbed view, in this example).
 * <p>
 * To move both the focus AND the selected tab at once, please use
 * {@link #setCurrentTab}. Normally, the view logic takes care of
 * adjusting the focus, so unless you're circumventing the UI,
 * you'll probably just focus your interest here.
 *
 * @param index the index of the tab that you want to indicate as the
 * selected tab (tab brought to the front of the widget)
 * @see #focusCurrentTab
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code that sends an accessibility event when the tab widget is shown is removed, hence it is classified as 4.","The removal of the accessibility event sending will not lead to different return values or types, nor will it result in an exception being thrown because it was a side effect that does not affect the main API functionality. Therefore, no compatibility issue arises from this change."
442,<android.os.Looper: void loop()>,23,24,<android.os.Looper: void loop()>,<android.os.Looper: void loop()>,0,"{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        msg.target.dispatchMessage(msg);
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}","{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        final long traceTag = me.mTraceTag;
        if (traceTag != 0) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        try {
            msg.target.dispatchMessage(msg);
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The early and late versions of the implementation introduce a new variable (final long traceTag = me.mTraceTag), a new control statement (if (traceTag != 0)), and additional method calls within a try-finally block (Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); and Trace.traceEnd(traceTag);). These changes are related to control dependencies as they introduce new conditional execution paths and alter the execution flow within the loop. Therefore, the change type is 3.","Although there has been a change in the control flow with the addition of new tracing capabilities, these changes do not affect the return values or exceptions that the method could produce since they are contained within a control statement that does not change the method's external behavior. The tracing is for internal monitoring and does not have an impact on the API contract from the caller's perspective. Consequently, no Compatibility Issue is expected to arise, giving the CI type 0."
444,"<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>",23,24,"<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>","<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>",0,"{
    try {
        mService.updateStatusIcon(imeToken, packageName, iconId);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        mService.updateStatusIcon(imeToken, packageName, iconId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. In the early version, a general RuntimeException is thrown, while in the late version, it specifically calls rethrowFromSystemServer() on the RemoteException, so the code change type is 2.","The change in exception handling could potentially lead to different exceptions being thrown when RemoteException occurs. The late version now throws the exception returned by rethrowFromSystemServer(), which likely results in a different exception type from RuntimeException. Hence, the CI type is 2."
445,"<android.os.UserManager: void setUserRestrictions(Bundle,UserHandle)>",23,24,"<android.os.UserManager: void setUserRestrictions(Bundle,UserHandle)>","<android.os.UserManager: void setUserRestrictions(Bundle,UserHandle)>",0,"{
    try {
        mService.setUserRestrictions(restrictions, userHandle.getIdentifier());
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not set user restrictions"", re);
    }
}","{
    throw new UnsupportedOperationException(""This method is no longer supported"");
}",1,"/**
 * Sets all the user-wide restrictions for the specified user.
 * Requires the MANAGE_USERS permission.
 * @param restrictions the Bundle containing all the restrictions.
 * @param userHandle the UserHandle of the user for whom to set the restrictions.
 * @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(
 * android.content.ComponentName, String)} or
 * {@link android.app.admin.DevicePolicyManager#clearUserRestriction(
 * android.content.ComponentName, String)} instead.
 */
","// System apps should use UserManager.setUserRestriction() instead.
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the method has completely changed from trying to set user restrictions to always throwing an UnsupportedOperationException, which is a change in the return statement and an other statement change, so the code change type is 1,4.","Since there's a new throw statement in the late version, all calls to this method will result in an UnsupportedOperationException being thrown, whereas the early version attempted to perform an action and catch a RemoteException. This is a compatibility issue caused by potential different exception handlings, so the CI type is 1."
446,<android.app.Notification.Builder: Builder setDeleteIntent(PendingIntent)>,23,24,<android.app.Notification.Builder: Builder setDeleteIntent(PendingIntent)>,<android.app.Notification.Builder: Builder setDeleteIntent(PendingIntent)>,0,"{
    mDeleteIntent = intent;
    return this;
}","{
    mN.deleteIntent = intent;
    return this;
}",1,"/**
 * Supply a {@link PendingIntent} to send when the notification is cleared explicitly by the user.
 *
 * @see Notification#deleteIntent
 */
","/**
 * Supply a {@link PendingIntent} to send when the notification is cleared explicitly by the user.
 *
 * @see Notification#deleteIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The field being set has changed from `mDeleteIntent` to `mN.deleteIntent`, but this doesn't directly affect what the method returns or throws, so the code change type is 4.","There is no Compatibility Issue since the method's return value is 'this', which remains the same, and the method does not throw any exception in both versions. Therefore, the behavior clients rely on does not change."
447,"<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>",23,24,"<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>","<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>",0,"{
    try {
        mService.setInputMethodAndSubtype(token, id, subtype);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        mService.setInputMethodAndSubtype(token, id, subtype);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Force switch to a new input method and subtype. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 * @param subtype The new subtype of the new input method to be switched to.
 */
","/**
 * Force switch to a new input method and subtype. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 * @param subtype The new subtype of the new input method to be switched to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing the exception rethrown from the system server, so the change type is 2.","This change in exception handling could lead to the API throwing a different exception in the later version, hence the CI type is 2."
449,<android.content.res.Resources: int getInteger(int)>,23,24,<android.content.res.Resources: int getInteger(int)>,<android.content.res.Resources: int getInteger(int)>,0,"{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data;
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        mResourcesImpl.getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data;
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Return an integer associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns the integer value contained in the resource.
 */
","/**
 * Return an integer associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns the integer value contained in the resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The implementation has changed to use the methods obtainTempTypedValue() and releaseTempTypedValue() instead of using the previous mTmpValue directly, and the method getValue(...) has been updated to mResourcesImpl.getValue(...). The synchronization implementation has also been replaced with try-finally block around the new methods. This represents control dependency change, other statement change, and dependent API change, so the code change type is 3,4,5.","Despite the changes in how the TypedValue is obtained and released, and how the value is fetched (now from mResourcesImpl), there is no change that could cause the API to return a different value or throw an exception under a different condition as compared to the early version. All possible pathways for return values and thrown exceptions are the same, so there is no compatibility issue, and the CI type is 0."
450,<android.app.job.JobInfo: long getIntervalMillis()>,23,24,<android.app.job.JobInfo: long getIntervalMillis()>,<android.app.job.JobInfo: long getIntervalMillis()>,0,"{
    return intervalMillis;
}","{
    return intervalMillis >= getMinPeriodMillis() ? intervalMillis : getMinPeriodMillis();
}",1,"/**
 * Set to the interval between occurrences of this job. This value is <b>not</b> set if the
 * job does not recur periodically.
 */
","/**
 * Set to the interval between occurrences of this job. This value is <b>not</b> set if the
 * job does not recur periodically.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The expression returning the value of intervalMillis has been changed to include a conditional check against a minimum period, so the code change type is 3 for the newly introduced control dependency (ternary conditional expression), and 4 for the other statement changed (comparison and invocation of getMinPeriodMillis()).","The change in the return statement introduces a new control dependency and alters the return value of the method based on a comparison. This could lead to the method returning a different value under certain conditions. Therefore, a potential Compatibility Issue arises due to potential different return values or types, which is indicated by CI type 1."
451,<android.widget.PopupMenu: OnTouchListener getDragToOpenListener()>,23,24,<android.widget.PopupMenu: OnTouchListener getDragToOpenListener()>,<android.widget.PopupMenu: OnTouchListener getDragToOpenListener()>,0,"{
    if (mDragListener == null) {
        mDragListener = new ForwardingListener(mAnchor) {

            @Override
            protected boolean onForwardingStarted() {
                show();
                return true;
            }

            @Override
            protected boolean onForwardingStopped() {
                dismiss();
                return true;
            }

            @Override
            public ListPopupWindow getPopup() {
                // This will be null until show() is called.
                return mPopup.getPopup();
            }
        };
    }
    return mDragListener;
}","{
    if (mDragListener == null) {
        mDragListener = new ForwardingListener(mAnchor) {

            @Override
            protected boolean onForwardingStarted() {
                show();
                return true;
            }

            @Override
            protected boolean onForwardingStopped() {
                dismiss();
                return true;
            }

            @Override
            public ShowableListMenu getPopup() {
                // This will be null until show() is called.
                return mPopup.getPopup();
            }
        };
    }
    return mDragListener;
}",1,"/**
 * Returns an {@link OnTouchListener} that can be added to the anchor view
 * to implement drag-to-open behavior.
 * <p>
 * When the listener is set on a view, touching that view and dragging
 * outside of its bounds will open the popup window. Lifting will select the
 * currently touched list item.
 * <p>
 * Example usage:
 * <pre>
 * PopupMenu myPopup = new PopupMenu(context, myAnchor);
 * myAnchor.setOnTouchListener(myPopup.getDragToOpenListener());
 * </pre>
 *
 * @return a touch listener that controls drag-to-open behavior
 */
","/**
 * Returns an {@link OnTouchListener} that can be added to the anchor view
 * to implement drag-to-open behavior.
 * <p>
 * When the listener is set on a view, touching that view and dragging
 * outside of its bounds will open the popup window. Lifting will select
 * the currently touched list item.
 * <p>
 * Example usage:
 * <pre>
 * PopupMenu myPopup = new PopupMenu(context, myAnchor);
 * myAnchor.setOnTouchListener(myPopup.getDragToOpenListener());
 * </pre>
 *
 * @return a touch listener that controls drag-to-open behavior
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"In the method getDragToOpenListener(), only the return type of the overridden method getPopup() within the new ForwardingListener() has changed from ListPopupWindow to ShowableListMenu without altering the control flow or the return behavior of the getDragToOpenListener() method itself, so the code change type is 5.","There is no compatibility issue since the method getDragToOpenListener() still returns the same ForwardingListener mDragListener, which is assigned once and reused. The behavior of the getDragToOpenListener() method has not changed even though the return type of an internal method getPopup() has changed, which can be considered an internal detail rather than a change in external behavior. Therefore, the API does not exhibit a compatibility issue."
452,<android.net.ConnectivityManager: LinkProperties getLinkProperties(Network)>,23,24,<android.net.ConnectivityManager: LinkProperties getLinkProperties(Network)>,<android.net.ConnectivityManager: LinkProperties getLinkProperties(Network)>,0,"{
    try {
        return mService.getLinkProperties(network);
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return mService.getLinkProperties(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the {@link LinkProperties} for the given {@link Network}.  This
 * will return {@code null} if the network is unknown.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param network The {@link Network} object identifying the network in question.
 * @return The {@link LinkProperties} for the network, or {@code null}.
 */
","/**
 * Get the {@link LinkProperties} for the given {@link Network}.  This
 * will return {@code null} if the network is unknown.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param network The {@link Network} object identifying the network in question.
 * @return The {@link LinkProperties} for the network, or {@code null}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling has changed from returning `null` to throwing an exception with `throw e.rethrowFromSystemServer()`, so the change type is 2.","Since the API now throws an exception instead of returning null in case of a `RemoteException`, this leads to a potential different exception handling behavior between the two versions. Hence, the CI type is 2."
453,<android.accounts.AccountManager: String getPassword(Account)>,23,24,<android.accounts.AccountManager: String getPassword(Account)>,<android.accounts.AccountManager: String getPassword(Account)>,0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to query for a password. Must not be {@code null}.
 * @return The account's password, null if none or if the account doesn't exist
 */
","/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to query for a password. Must not be {@code null}.
 * @return The account's password, null if none or if the account doesn't exist
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has been changed. In the early version, a new RuntimeException is thrown while in the late version, rethrowFromSystemServer() is called on the RemoteException object. Therefore, the change type is 2.","The change in the exception handling can lead to a different type of exception being thrown in the case of a RemoteException. The early version throws RuntimeException, while the late version rethrows the original RemoteException with additional context. Hence, there's a potential Compatibility Issue caused by different exception handlings and the CI type is 2."
454,<android.os.PowerManager: boolean isWakeLockLevelSupported(int)>,23,24,<android.os.PowerManager: boolean isWakeLockLevelSupported(int)>,<android.os.PowerManager: boolean isWakeLockLevelSupported(int)>,0,"{
    try {
        return mService.isWakeLockLevelSupported(level);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return mService.isWakeLockLevelSupported(level);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the specified wake lock level is supported.
 *
 * @param level The wake lock level to check.
 * @return True if the specified wake lock level is supported.
 */
","/**
 * Returns true if the specified wake lock level is supported.
 *
 * @param level The wake lock level to check.
 * @return True if the specified wake lock level is supported.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has changed, as the RemoteException is no longer caught to return false; it now throws a new exception with throw e.rethrowFromSystemServer(). The change type is 2.","The earlier version would catch the RemoteException and return false, while the later version throws a new wrapper exception, which can affect the flow of the calling program since it will have to handle the exception instead of just receiving a false return value. Thus, it's a Compatibility Issue caused by potential different exception handlings, and the CI type is 2."
455,<android.app.backup.FullBackup.BackupScheme: String tokenToDirectoryPath(String)>,23,24,<android.app.backup.FullBackup.BackupScheme: String tokenToDirectoryPath(String)>,<android.app.backup.FullBackup.BackupScheme: String tokenToDirectoryPath(String)>,0,"{
    try {
        if (domainToken.equals(FullBackup.DATA_TREE_TOKEN)) {
            return FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DATABASE_TREE_TOKEN)) {
            return DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.ROOT_TREE_TOKEN)) {
            return ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
            return SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.CACHE_TREE_TOKEN)) {
            return CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
            if (EXTERNAL_DIR != null) {
                return EXTERNAL_DIR.getCanonicalPath();
            } else {
                return null;
            }
        } else if (domainToken.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
            return NOBACKUP_DIR.getCanonicalPath();
        }
        // Not a supported location
        Log.i(TAG, ""Unrecognized domain "" + domainToken);
        return null;
    } catch (IOException e) {
        Log.i(TAG, ""Error reading directory for domain: "" + domainToken);
        return null;
    }
}","{
    try {
        if (domainToken.equals(FullBackup.FILES_TREE_TOKEN)) {
            return FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DATABASE_TREE_TOKEN)) {
            return DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.ROOT_TREE_TOKEN)) {
            return ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
            return SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.CACHE_TREE_TOKEN)) {
            return CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
            return NOBACKUP_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_FILES_TREE_TOKEN)) {
            return DEVICE_FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_DATABASE_TREE_TOKEN)) {
            return DEVICE_DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_ROOT_TREE_TOKEN)) {
            return DEVICE_ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN)) {
            return DEVICE_SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_CACHE_TREE_TOKEN)) {
            return DEVICE_CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_NO_BACKUP_TREE_TOKEN)) {
            return DEVICE_NOBACKUP_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
            if (EXTERNAL_DIR != null) {
                return EXTERNAL_DIR.getCanonicalPath();
            } else {
                return null;
            }
        }
        // Not a supported location
        Log.i(TAG, ""Unrecognized domain "" + domainToken);
        return null;
    } catch (IOException e) {
        Log.i(TAG, ""Error reading directory for domain: "" + domainToken);
        return null;
    }
}",1,"/**
 * Parse out the semantic domains into the correct physical location.
 */
","/**
 * Parse out the semantic domains into the correct physical location.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,Several changes between the two implementations:,- Dependent API token FullBackup.DATA_TREE_TOKEN seems to be removed or replaced.
456,<android.widget.Editor.SuggestionsPopupWindow: int getVerticalLocalPosition(int)>,23,24,<android.widget.Editor.SuggestionsPopupWindow: int getVerticalLocalPosition(int)>,<android.widget.Editor.SuggestionsPopupWindow: int getVerticalLocalPosition(int)>,0,"{
    return mTextView.getLayout().getLineBottom(line);
}","{
    return mTextView.getLayout().getLineBottom(line) - mContainerMarginTop;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The implementation has changed with the subtraction of mContainerMarginTop from the returned value, so the code change type is 4.","The method now returns a different value due to the subtraction of mContainerMarginTop, which can affect the behavior of the method. Thus, the CI type is 1."
457,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,23,24,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,0,"{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess();
        }
        getService().setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
    }
}","{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess(true);
        }
        getService().setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */
","/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The method call prepareToLeaveProcess() has been changed to prepareToLeaveProcess(true) indicating a change in the method signature (5). An exception handling statement has also been changed from an empty catch block to a throw statement (2), and therefore, there is also a change in exception handling statement (2).","The change in the method call could cause the method to behave differently (1) if the implementation of prepareToLeaveProcess(boolean) is different from prepareToLeaveProcess(), thus potentially affecting the return value or the outcome. Additionally, the change from an empty catch block to throwing an exception (rethrowFromSystemServer) could cause a different exception to be thrown to the caller (2), which was not the case in the earlier version."
459,<android.animation.AnimatorSet.Builder: Builder before(Animator)>,23,24,<android.animation.AnimatorSet.Builder: Builder before(Animator)>,<android.animation.AnimatorSet.Builder: Builder before(Animator)>,0,"{
    mReversible = false;
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(mCurrentNode, Dependency.AFTER);
    node.addDependency(dependency);
    return this;
}","{
    mReversible = false;
    Node node = getNodeForAnimation(anim);
    mCurrentNode.addChild(node);
    return this;
}",1,"/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * ends.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method ends.
 */
","/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * ends.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method ends.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The implementation has changed significantly. It uses a new method `getNodeForAnimation(anim)` instead of directly manipulating the map and list. Also, the call `mCurrentNode.addChild(node)` replaces the mechanism used previously for setting up dependencies. So, there are changes in control dependencies (due to restructuring the code) and other statements (introduction of new methods and removal of old code). The change is represented by 3,4,5.","Although the implementation details have changed, the purpose of the `before(Animator)` method, which is to define ordering of animations, remains consistent. A new dependency is added to the graph that represents the animator set, but the semantics of the builder's chainable `before` command have not changed. These implementation details do not appear to affect the API's contract from the viewpoint of the caller who would receive the same `Builder` object back. Hence, it does not indicate a Compatibility Issue, so the CI type is 0."
460,<android.inputmethodservice.InputMethodService: boolean onEvaluateInputViewShown()>,23,24,<android.inputmethodservice.InputMethodService: boolean onEvaluateInputViewShown()>,<android.inputmethodservice.InputMethodService: boolean onEvaluateInputViewShown()>,0,"{
    Configuration config = getResources().getConfiguration();
    return config.keyboard == Configuration.KEYBOARD_NOKEYS || config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES;
}","{
    if (mSettingsObserver == null) {
        Log.w(TAG, ""onEvaluateInputViewShown: mSettingsObserver must not be null here."");
        return false;
    }
    if (mSettingsObserver.shouldShowImeWithHardKeyboard()) {
        return true;
    }
    Configuration config = getResources().getConfiguration();
    return config.keyboard == Configuration.KEYBOARD_NOKEYS || config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES;
}",1,"/**
 * Override this to control when the soft input area should be shown to
 * the user.  The default implementation only shows the input view when
 * there is no hard keyboard or the keyboard is hidden.  If you change what
 * this returns, you will need to call {@link #updateInputViewShown()}
 * yourself whenever the returned value may have changed to have it
 * re-evaluated and applied.
 */
","/**
 * Override this to control when the soft input area should be shown to the user.  The default
 * implementation returns {@code false} when there is no hard keyboard or the keyboard is hidden
 * unless the user shows an intention to use software keyboard.  If you change what this
 * returns, you will need to call {@link #updateInputViewShown()} yourself whenever the returned
 * value may have changed to have it re-evaluated and applied.
 *
 * <p>When you override this method, it is recommended to call
 * {@code super.onEvaluateInputViewShown()} and return {@code true} when {@code true} is
 * returned.</p>
 */
",-1,,[@CallSuper],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The code change includes adding condition checks for 'mSettingsObserver', adding a different return path, and logging. These additions represent the change types 1,3,4.","Since there's a new return statement (return false) and a new condition check before the existing logic, there is a potential for a different return value, and thus it's a CI of type 1."
461,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,23,24,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,0,"{
    final int iconRes = mResolveInfo.getIconResource();
    Drawable icon = getDrawableForDensity(iconRes, density);
    // Get the default density icon
    if (icon == null) {
        icon = mResolveInfo.loadIcon(mPm);
    }
    return icon;
}","{
    final int iconRes = mActivityInfo.getIconResource();
    Drawable icon = null;
    // Get the preferred density icon from the app's resources
    if (density != 0 && iconRes != 0) {
        try {
            final Resources resources = mPm.getResourcesForApplication(mActivityInfo.applicationInfo);
            icon = resources.getDrawableForDensity(iconRes, density);
        } catch (NameNotFoundException | Resources.NotFoundException exc) {
        }
    }
    // Get the default density icon
    if (icon == null) {
        icon = mActivityInfo.loadIcon(mPm);
    }
    return icon;
}",1,"/**
 * Returns the icon for this activity, without any badging for the profile.
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 * @see #getBadgedIcon(int)
 * @see DisplayMetrics
 * @return The drawable associated with the activity.
 */
","/**
 * Returns the icon for this activity, without any badging for the profile.
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 * @see #getBadgedIcon(int)
 * @see DisplayMetrics
 * @return The drawable associated with the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The variable from which `iconRes` is obtained has changed, the conditional logic to get `icon` has changed, and there's a new try-catch block that handles exceptions when trying to get resources for the application which indicates changes in exception handling, dependent APIs, and other statements. The control dependency has also changed by adding a new conditional check for `density != 0 && iconRes != 0` before attempting to get the drawable. So the change types are 1,3,4,5.","Since the resource acquisition method and the conditions under which it fetches the icon have changed, the late version may return a different Drawable compared to the early version in some scenarios, especially when the density or iconRes is different. Furthermore, if an exception occurs while attempting to get the drawable, the late version will not log the exception and will fall back to getting the default icon instead, which could also lead to different behavior. These differences could lead to compatibility issues from potentially different return values, so the CI type is 1."
465,<android.view.inputmethod.CursorAnchorInfo.Builder: Builder setMatrix(Matrix)>,23,24,<android.view.inputmethod.CursorAnchorInfo.Builder: Builder setMatrix(Matrix)>,<android.view.inputmethod.CursorAnchorInfo.Builder: Builder setMatrix(Matrix)>,0,"{
    mMatrix.set(matrix != null ? matrix : Matrix.IDENTITY_MATRIX);
    mMatrixInitialized = true;
    return this;
}","{
    if (mMatrixValues == null) {
        mMatrixValues = new float[9];
    }
    (matrix != null ? matrix : Matrix.IDENTITY_MATRIX).getValues(mMatrixValues);
    mMatrixInitialized = true;
    return this;
}",1,"/**
 * Sets the matrix that transforms local coordinates into screen coordinates.
 * @param matrix transformation matrix from local coordinates into screen coordinates. null
 * is interpreted as an identity matrix.
 */
","/**
 * Sets the matrix that transforms local coordinates into screen coordinates.
 * @param matrix transformation matrix from local coordinates into screen coordinates. null
 * is interpreted as an identity matrix.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the way the matrix is being handled: instead of setting `mMatrix` directly, the late version uses an intermediate float array `mMatrixValues`. However, this does not change the behavior of the return statement or exception handling, so the code change type is 4.","The modification does not lead to different return values or types nor does it introduce different exceptions being thrown because the end effect on `mMatrix` and `mMatrixInitialized` remains the same, especially since the builder pattern is used to return `this` for method chaining. Hence, there is no compatibility issue detected."
466,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",23,24,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object.
        CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, stableProvider != null ? stableProvider : acquireProvider(uri));
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object.
        final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri);
        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}",1,"/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with optional support for cancellation.
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
","/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with optional support for cancellation.
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,0,0,"There are no changes between the early and late implementations of the API method, except for the refactoring of the CursorWrapperInner creation and the redundant declaration of `provider` which does not affect the logic or the behavior of the method. So, there is no change in the categories provided.","Since there are no changes that affect the behavior of the method, there are no compatibility issues between the two versions. The cursor is wrapped in the same way, and the variables `stableProvider` and `unstableProvider` are handled in the same manner. Hence, there's no difference in return values, types, or the exceptions thrown."
468,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>",23,24,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>","<android.content.res.Configuration: void writeToParcel(Parcel,int)>",0,"{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
    dest.writeInt(uiMode);
    dest.writeInt(screenWidthDp);
    dest.writeInt(screenHeightDp);
    dest.writeInt(smallestScreenWidthDp);
    dest.writeInt(densityDpi);
    dest.writeInt(compatScreenWidthDp);
    dest.writeInt(compatScreenHeightDp);
    dest.writeInt(compatSmallestScreenWidthDp);
    dest.writeInt(seq);
}","{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    fixUpLocaleList();
    final int localeListSize = mLocaleList.size();
    dest.writeInt(localeListSize);
    for (int i = 0; i < localeListSize; ++i) {
        final Locale l = mLocaleList.get(i);
        dest.writeString(l.toLanguageTag());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
    dest.writeInt(uiMode);
    dest.writeInt(screenWidthDp);
    dest.writeInt(screenHeightDp);
    dest.writeInt(smallestScreenWidthDp);
    dest.writeInt(densityDpi);
    dest.writeInt(compatScreenWidthDp);
    dest.writeInt(compatScreenHeightDp);
    dest.writeInt(compatSmallestScreenWidthDp);
    dest.writeInt(seq);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method's implementation has changed the way locales are written to the Parcel: the early version writes a single locale if it is not null, while the late version applies a fixUpLocaleList() method before writing a potentially longer list of locales, each converted to a language tag with toLanguageTag(). The control flow for locale serialization has changed, as have other statements not tied to a control structure (e.g., the for loop). Also, the use of the new API, mLocaleList.size() and mLocaleList.get(i) implies a dependent API change. Hence, the change types are 1,3,4,5.","This change in how the locale list is serialized to the Parcel can cause the method to produce different output for each Configuration object, potentially leading to a different behavior downstream as applications or the Android system itself reads the serialized data. Therefore, the compatibility issue type is 1."
469,<android.hardware.SystemSensorManager.BaseEventQueue: boolean removeAllSensors()>,23,24,<android.hardware.SystemSensorManager.BaseEventQueue: boolean removeAllSensors()>,<android.hardware.SystemSensorManager.BaseEventQueue: boolean removeAllSensors()>,0,"{
    for (int i = 0; i < mActiveSensors.size(); i++) {
        if (mActiveSensors.valueAt(i) == true) {
            int handle = mActiveSensors.keyAt(i);
            Sensor sensor = mManager.mHandleToSensor.get(handle);
            if (sensor != null) {
                disableSensor(sensor);
                mActiveSensors.put(handle, false);
                removeSensorEvent(sensor);
            } else {
            // it should never happen -- just ignore.
            }
        }
    }
    return true;
}","{
    for (int i = 0; i < mActiveSensors.size(); i++) {
        if (mActiveSensors.valueAt(i) == true) {
            int handle = mActiveSensors.keyAt(i);
            Sensor sensor = mManager.mHandleToSensor.get(handle);
            if (sensor != null) {
                disableSensor(sensor);
                mActiveSensors.put(handle, false);
                removeSensorEvent(sensor);
            } else {
            // sensor just disconnected -- just ignore.
            }
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the comment section, where the text has been modified from // it should never happen -- just ignore. to // sensor just disconnected -- just ignore. This change is not related to code logic but rather to documentation, so the type is 4 (Other statement changed).","The change is only in the comments and it does not affect the program's behaviour in any way. There is no Compatibility Issue, and so the CI type is 0 (No Compatibility Issue)."
471,<android.net.ConnectivityManager: NetworkInfo getActiveNetworkInfo()>,23,24,<android.net.ConnectivityManager: NetworkInfo getActiveNetworkInfo()>,<android.net.ConnectivityManager: NetworkInfo getActiveNetworkInfo()>,0,"{
    try {
        return mService.getActiveNetworkInfo();
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return mService.getActiveNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns details about the currently active default data network. When
 * connected, this network is the default route for outgoing connections.
 * You should always check {@link NetworkInfo#isConnected()} before initiating
 * network traffic. This may return {@code null} when there is no default
 * network.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return a {@link NetworkInfo} object for the current default network
 * or {@code null} if no default network is currently active
 */
","/**
 * Returns details about the currently active default data network. When
 * connected, this network is the default route for outgoing connections.
 * You should always check {@link NetworkInfo#isConnected()} before initiating
 * network traffic. This may return {@code null} when there is no default
 * network.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return a {@link NetworkInfo} object for the current default network
 * or {@code null} if no default network is currently active
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed: the early version returns null when a RemoteException is caught, while the late version throws a rethrown exception instead. Thus, the change type is 2.","The change in exception handling could lead to a different behavior when the late version API encounters a RemoteException. Instead of returning null, it now propagates the exception, which is a change in API behavior and can cause a Compatibility Issue of type 2."
473,"<android.view.View: void setLayerType(int,Paint)>",23,24,"<android.view.View: void setLayerType(int,Paint)>","<android.view.View: void setLayerType(int,Paint)>",0,"{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    boolean typeChanged = mRenderNode.setLayerType(layerType);
    if (!typeChanged) {
        setLayerPaint(paint);
        return;
    }
    // Destroy any previous software drawing cache if needed
    if (mLayerType == LAYER_TYPE_SOFTWARE) {
        destroyDrawingCache();
    }
    mLayerType = layerType;
    final boolean layerDisabled = (mLayerType == LAYER_TYPE_NONE);
    mLayerPaint = layerDisabled ? null : (paint == null ? new Paint() : paint);
    mRenderNode.setLayerPaint(mLayerPaint);
    // draw() behaves differently if we are on a layer, so we need to
    // invalidate() here
    invalidateParentCaches();
    invalidate(true);
}","{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    boolean typeChanged = mRenderNode.setLayerType(layerType);
    if (!typeChanged) {
        setLayerPaint(paint);
        return;
    }
    if (layerType != LAYER_TYPE_SOFTWARE) {
        // Destroy any previous software drawing cache if present
        // NOTE: even if previous layer type is HW, we do this to ensure we've cleaned up
        // drawing cache created in View#draw when drawing to a SW canvas.
        destroyDrawingCache();
    }
    mLayerType = layerType;
    mLayerPaint = mLayerType == LAYER_TYPE_NONE ? null : paint;
    mRenderNode.setLayerPaint(mLayerPaint);
    // draw() behaves differently if we are on a layer, so we need to
    // invalidate() here
    invalidateParentCaches();
    invalidate(true);
}",1,"/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is superseded
 * by this view's alpha value.</p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE},
 * {@link #LAYER_TYPE_SOFTWARE} and {@link #LAYER_TYPE_HARDWARE}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The type of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
","/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is superseded
 * by this view's alpha value.</p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE},
 * {@link #LAYER_TYPE_SOFTWARE} and {@link #LAYER_TYPE_HARDWARE}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The type of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a change in the control dependency, specifically the if condition inside the early implementation has been modified. The body for the if statement has changed to include comments and tweaked the condition by removing the specific check for mLayerType being SOFTWARE. Additionally, the assignment of mLayerPaint has also changed slightly. As none of these changes directly affect the return statement or exception throwing, the changes are 3 (Control dependency changed) and 4 (Other statement changed).","The changes in the conditional checks and the slight alteration in assignments do not lead to a compatibility issue as they do not change how the method behaves externally in terms of returned results or thrown exceptions. Removing the specific check for SOFTWARE is a refactor to clean the cache more broadly, while the mLayerPaint assignment change merely streamlines the assignment process without altering functionality. No compatibility issue is present, so the CI type is 0."
474,<android.widget.Editor.SelectionModifierCursorController: void show()>,23,24,<android.widget.Editor.SelectionModifierCursorController: void show()>,<android.widget.Editor.SelectionModifierCursorController: void show()>,0,"{
    if (mTextView.isInBatchEditMode()) {
        return;
    }
    initDrawables();
    initHandles();
    hideInsertionPointCursorController();
}","{
    if (mTextView.isInBatchEditMode()) {
        return;
    }
    initDrawables();
    initHandles();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method hideInsertionPointCursorController() call has been removed, so the code change type is 4.","The removal of the hideInsertionPointCursorController() method call does not directly affect the return type, value, or the exceptions thrown by the show() method. Thus, there is no Compatibility Issue; the CI type is 0."
475,<android.app.ActivityManager: List<ProcessErrorStateInfo> getProcessesInErrorState()>,23,24,<android.app.ActivityManager: List<ProcessErrorStateInfo> getProcessesInErrorState()>,<android.app.ActivityManager: List<ProcessErrorStateInfo> getProcessesInErrorState()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getProcessesInErrorState();
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getProcessesInErrorState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a list of any processes that are currently in an error condition.  The result
 * will be null if all processes are running properly at this time.
 *
 * @return Returns a list of ProcessErrorStateInfo records, or null if there are no
 * current error conditions (it will not return an empty list).  This list ordering is not
 * specified.
 */
","/**
 * Returns a list of any processes that are currently in an error condition.  The result
 * will be null if all processes are running properly at this time.
 *
 * @return Returns a list of ProcessErrorStateInfo records, or null if there are no
 * current error conditions (it will not return an empty list).  This list ordering is not
 * specified.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has chnaged. Previously, it was returning null, but now it throws the RemoteException returned by `rethrowFromSystemServer()`. Therefore, the code change type is 2.","Due to the change in exception handling, the late version of the API could throw an exception where it previously returned null. This is a change in the behavior with regards to exception handling, hence the CI type is 2."
476,<android.content.SyncRequest.Builder: SyncRequest build()>,23,24,<android.content.SyncRequest.Builder: SyncRequest build()>,<android.content.SyncRequest.Builder: SyncRequest build()>,0,"{
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException(""Illegal extras were set"");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException(""Must specify an adapter with"" + "" setSyncAdapter(Account, String"");
    }
    return new SyncRequest(this);
}","{
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mRequiresCharging) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_REQUIRE_CHARGING, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException(""Illegal extras were set"");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException(""Must specify an adapter with"" + "" setSyncAdapter(Account, String"");
    }
    return new SyncRequest(this);
}",1,"/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */
","/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the addition of a condition that sets the ""ContentResolver.SYNC_EXTRAS_REQUIRE_CHARGING"" boolean in the mSyncConfigExtras bundle if mRequiresCharging is true. This change is not related to return statements, exception handling statements, or control dependencies. It's an addition of functionality without altering the existing control flow or logic surrounding the return of values or the throwing of exceptions.",There's no Compatibility Issue for the following reasons:
477,"<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler,String)>",23,24,"<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler,String)>","<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler,String)>",0,"{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = mTarget.send(code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}","{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManagerNative.getDefault().sendIntentSender(mTarget, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}",1,"/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */
","/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has a change in the way the intent sender is sent: initially it calls mTarget.send(), but the later version calls ActivityManagerNative.getDefault().sendIntentSender(mTarget, ...). This means there is a change in a dependent API, so the code change type is 5.","Despite the change in the dependent API there is no Compatibility Issue here since the behavior of the method, in terms of return values and exception handling, remains unchanged. The method signature stays the same, and the exception handling is still catching RemoteException and throwing SendIntentException, regardless of how the internal call is made. So, there is no Compatibility Issue, type 0."
478,"<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>",23,24,"<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>","<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>",0,"{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetProvider(provider, views);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetProvider(provider, views);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Set the RemoteViews to use for all AppWidget instances for the supplied AppWidget provider.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * @param provider      The {@link ComponentName} for the {@link
 * android.content.BroadcastReceiver BroadcastReceiver} provider
 * for your AppWidget.
 * @param views         The RemoteViews object to show.
 */
","/**
 * Set the RemoteViews to use for all AppWidget instances for the supplied AppWidget provider.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * @param provider      The {@link ComponentName} for the {@link
 * android.content.BroadcastReceiver BroadcastReceiver} provider
 * for your AppWidget.
 * @param views         The RemoteViews object to show.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The catch clause has been changed from throwing a new RuntimeException to throwing e.rethrowFromSystemServer(), so the code change type is 2.","This change in the exception handling could lead to a different exception being thrown. Instead of wrapping the RemoteException into a new RuntimeException, the late version directly rethrows it with some additional framework-specific context. As a result, the CI type is 2."
479,"<android.widget.Editor.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>",23,24,"<android.widget.Editor.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>","<android.widget.Editor.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>",0,"{
    Editable editable = (Editable) mTextView.getText();
    SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    if (suggestionInfo.suggestionIndex == DELETE_TEXT) {
        final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
        int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
        if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
            // Do not leave two adjacent spaces after deletion, or one at beginning of text
            if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                spanUnionEnd = spanUnionEnd + 1;
            }
            mTextView.deleteText_internal(spanUnionStart, spanUnionEnd);
        }
        hide();
        return;
    }
    final int spanStart = editable.getSpanStart(suggestionInfo.suggestionSpan);
    final int spanEnd = editable.getSpanEnd(suggestionInfo.suggestionSpan);
    if (spanStart < 0 || spanEnd <= spanStart) {
        // Span has been removed
        hide();
        return;
    }
    final String originalText = editable.toString().substring(spanStart, spanEnd);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY) {
        Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
        intent.putExtra(""word"", originalText);
        intent.putExtra(""locale"", mTextView.getTextServicesLocale().toString());
        // Put a listener to replace the original text with a word which the user
        // modified in a user dictionary dialog.
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        mTextView.getContext().startActivity(intent);
        // There is no way to know if the word was indeed added. Re-check.
        // TODO The ExtractEditText should remove the span in the original text instead
        editable.removeSpan(suggestionInfo.suggestionSpan);
        Selection.setSelection(editable, spanEnd);
        updateSpellCheckSpans(spanStart, spanEnd, false);
    } else {
        // SuggestionSpans are removed by replace: save them before
        SuggestionSpan[] suggestionSpans = editable.getSpans(spanStart, spanEnd, SuggestionSpan.class);
        final int length = suggestionSpans.length;
        int[] suggestionSpansStarts = new int[length];
        int[] suggestionSpansEnds = new int[length];
        int[] suggestionSpansFlags = new int[length];
        for (int i = 0; i < length; i++) {
            final SuggestionSpan suggestionSpan = suggestionSpans[i];
            suggestionSpansStarts[i] = editable.getSpanStart(suggestionSpan);
            suggestionSpansEnds[i] = editable.getSpanEnd(suggestionSpan);
            suggestionSpansFlags[i] = editable.getSpanFlags(suggestionSpan);
            // Remove potential misspelled flags
            int suggestionSpanFlags = suggestionSpan.getFlags();
            if ((suggestionSpanFlags & SuggestionSpan.FLAG_MISSPELLED) > 0) {
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_MISSPELLED;
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_EASY_CORRECT;
                suggestionSpan.setFlags(suggestionSpanFlags);
            }
        }
        final int suggestionStart = suggestionInfo.suggestionStart;
        final int suggestionEnd = suggestionInfo.suggestionEnd;
        final String suggestion = suggestionInfo.text.subSequence(suggestionStart, suggestionEnd).toString();
        mTextView.replaceText_internal(spanStart, spanEnd, suggestion);
        // Notify source IME of the suggestion pick. Do this before
        // swaping texts.
        suggestionInfo.suggestionSpan.notifySelection(mTextView.getContext(), originalText, suggestionInfo.suggestionIndex);
        // Swap text content between actual text and Suggestion span
        String[] suggestions = suggestionInfo.suggestionSpan.getSuggestions();
        suggestions[suggestionInfo.suggestionIndex] = originalText;
        // Restore previous SuggestionSpans
        final int lengthDifference = suggestion.length() - (spanEnd - spanStart);
        for (int i = 0; i < length; i++) {
            // way to assign them a valid range after replacement
            if (suggestionSpansStarts[i] <= spanStart && suggestionSpansEnds[i] >= spanEnd) {
                mTextView.setSpan_internal(suggestionSpans[i], suggestionSpansStarts[i], suggestionSpansEnds[i] + lengthDifference, suggestionSpansFlags[i]);
            }
        }
        // Move cursor at the end of the replaced word
        final int newCursorPosition = spanEnd + lengthDifference;
        mTextView.setCursorPosition_internal(newCursorPosition, newCursorPosition);
    }
    hide();
}","{
    SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    replaceWithSuggestion(suggestionInfo);
    hideWithCleanUp();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
481,<android.app.ContextImpl: String[] fileList()>,23,24,<android.app.ContextImpl: String[] fileList()>,<android.app.ContextImpl: String[] fileList()>,0,"{
    final String[] list = getFilesDir().list();
    return (list != null) ? list : EMPTY_STRING_ARRAY;
}","{
    return FileUtils.listOrEmpty(getFilesDir());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has been refactored to use the FileUtils.listOrEmpty(...) method instead of directly handling the potential null list and returning an empty array. This change is of type 4, as the statement within the method body has changed, and type 5, because the API now depends on the FileUtils.listOrEmpty(...) method.","There's no Compatibility Issue in this case because the behavior of the API remains consistent despite the change in implementation. The refactoring ensures that the API will still return a non-null array, either a list of filenames or an empty one, preserving the same behavior and return values as before."
482,"<android.os.RecoverySystem: void installPackage(Context,File)>",23,24,"<android.os.RecoverySystem: void installPackage(Context,File)>","<android.os.RecoverySystem: void installPackage(Context,File)>",0,"{
    String filename = packageFile.getCanonicalPath();
    FileWriter uncryptFile = new FileWriter(UNCRYPT_FILE);
    try {
        uncryptFile.write(filename + ""\n"");
    } finally {
        uncryptFile.close();
    }
    Log.w(TAG, ""!!! REBOOTING TO INSTALL "" + filename + "" !!!"");
    // into COMMAND_FILE instead.
    if (filename.startsWith(""/data/"")) {
        filename = ""@/cache/recovery/block.map"";
    }
    final String filenameArg = ""--update_package="" + filename;
    final String localeArg = ""--locale="" + Locale.getDefault().toString();
    bootCommand(context, filenameArg, localeArg);
}","{
    installPackage(context, packageFile, false);
}",1,"/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Must be on
 * a partition mountable by recovery.  (The set of partitions
 * known to recovery may vary from device to device.  Generally,
 * /cache and /data are safe.)
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */
","/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Must be on
 * a partition mountable by recovery.  (The set of partitions
 * known to recovery may vary from device to device.  Generally,
 * /cache and /data are safe.)
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The late implementation redirects the operation to another overloaded method installPackage(context, packageFile, false) with an additional boolean parameter. Since the actual logic of the method is now moved to the new method, the change is classified as 5 (Dependent API changed).","Without additional context about the behavior of installPackage(context, packageFile, false), we cannot determine if the late implementation will introduce a Compatibility Issue. However, as it delegates to another method, it can be assumed that the designers intended to maintain compatibility (especially since the boolean parameter is a constant false which suggests no difference in expected behavior). Therefore, the classification is 0 (No Compatibility Issue)."
484,<android.net.TrafficStats: long getUidRxPackets(int)>,23,24,<android.net.TrafficStats: long getUidRxPackets(int)>,<android.net.TrafficStats: long getUidRxPackets(int)>,0,"{
    return nativeGetUidStat(uid, TYPE_RX_PACKETS);
}","{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_RX_PACKETS);
    } else {
        return UNSUPPORTED;
    }
}",1,"/**
 * Return number of packets received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of packets received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"There is a new control dependency with an if-else statement checking the calling UID, and the dependent native method call to `nativeGetUidStat(uid, TYPE_RX_PACKETS)` now only occurs under certain conditions, which is a change type 3. Moreover, the dependent API `nativeGetUidStat` is not changed, but the way it is called is now conditional based on the UID check, which means this is also of type 5.","The newly introduced control dependency on the UID check could lead to a different return value -- 'UNSUPPORTED' instead of what `nativeGetUidStat` would return for UIDs that do not match the conditions. Consequently, this change may lead to different behavior for non-matching UIDs, representing a CI type of 1."
485,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",23,24,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>","<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",0,"{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        final boolean restricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, new UserHandle(UserHandle.getUserId(application.uid)), restricted, mDisplay, null, Display.INVALID_DISPLAY);
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}","{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, new UserHandle(UserHandle.getUserId(application.uid)), flags, mDisplay, null, Display.INVALID_DISPLAY);
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes modifying the way a 'restricted' variable is created and used. In the early version, 'restricted' is explicitly created and evaluated based on whether 'flags' contains 'CONTEXT_RESTRICTED'. In the late version, the 'flags' variable is directly passed to the 'ContextImpl' constructor without checking if it contains 'CONTEXT_RESTRICTED'. This is both a control dependency change (3) since the condition to determine 'restricted' is removed, and an other statement change (4) because of the different approach to passing parameters.","There is no Compatibility Issue caused by the changes; the logic to create a 'ContextImpl' object and the conditions to throw a 'PackageManager.NameNotFoundException' remain the same between versions. The flags variable is still being checked within the 'ContextImpl' constructor as prior, it's just that the explicit check for the 'CONTEXT_RESTRICTED' flag is now happening within that constructor rather than before calling it. Thus, the behavior in terms of returning a value or throwing an exception has not changed."
486,<android.widget.Gallery: boolean showContextMenuForChild(View)>,23,24,<android.widget.Gallery: boolean showContextMenuForChild(View)>,<android.widget.Gallery: boolean showContextMenuForChild(View)>,0,"{
    final int longPressPosition = getPositionForView(originalView);
    if (longPressPosition < 0) {
        return false;
    }
    final long longPressId = mAdapter.getItemId(longPressPosition);
    return dispatchLongPress(originalView, longPressPosition, longPressId);
}","{
    if (isShowingContextMenuWithCoords()) {
        return false;
    }
    return showContextMenuForChildInternal(originalView, 0, 0, false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The method implementation has changed significantly, with the complete removal of previous conditions and logic, and has been replaced with a new logic involving the 'isShowingContextMenuWithCoords()' check and calling 'showContextMenuForChildInternal()' instead of 'dispatchLongPress()'. Additionally, the new implementation does not compute 'longPressPosition' or 'longPressId' anymore. The change includes different control flow (change type 3) and other statements (change type 4).","The API behavior is potentially different because the previous version could result in different boolean values based on the position and ID of a long-pressed item, while the new version's result is unaffected by the item's position or ID but depends on whether the context menu with coordinates is being shown. Thus, the late version may return different boolean values compared to the early version, resulting in a different behavior. The CI type is caused by potential different return values, which is 1."
487,<android.os.PowerManager.WakeLock: void finalize()>,23,24,<android.os.PowerManager.WakeLock: void finalize()>,<android.os.PowerManager.WakeLock: void finalize()>,0,"{
    synchronized (mToken) {
        if (mHeld) {
            Log.wtf(TAG, ""WakeLock finalized while still held: "" + mTag);
            Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0);
            try {
                mService.releaseWakeLock(mToken, 0);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    synchronized (mToken) {
        if (mHeld) {
            Log.wtf(TAG, ""WakeLock finalized while still held: "" + mTag);
            Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0);
            try {
                mService.releaseWakeLock(mToken, 0);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, because in the early version, the RemoteException is caught and ignored, while in the late version, it is re-thrown as an unchecked exception. This is a change of type 2.","A Compatibility Issue arises due to potential different exception handlings, since the late version of the API can throw an unchecked exception where the early version did not, leading to potentially different behavior when the exception occurs. This is a CI type 2."
488,<android.provider.Settings.System: boolean canWrite(Context)>,23,24,<android.provider.Settings.System: boolean canWrite(Context)>,<android.provider.Settings.System: boolean canWrite(Context)>,0,"{
    int uid = Binder.getCallingUid();
    return isCallingPackageAllowedToWriteSettings(context, uid, getPackageNameForUid(context, uid), false);
}","{
    return isCallingPackageAllowedToWriteSettings(context, Process.myUid(), context.getOpPackageName(), false);
}",1,"/**
 * An app can use this method to check if it is currently allowed to write or modify system
 * settings. In order to gain write access to the system settings, an app must declare the
 * {@link android.Manifest.permission#WRITE_SETTINGS} permission in its manifest. If it is
 * currently disallowed, it can prompt the user to grant it this capability through a
 * management UI by sending an Intent with action
 * {@link android.provider.Settings#ACTION_MANAGE_WRITE_SETTINGS}.
 *
 * @param context A context
 * @return true if the calling app can write to system settings, false otherwise
 */
","/**
 * Checks if the specified app can modify system settings. As of API
 * level 23, an app cannot modify system settings unless it declares the
 * {@link android.Manifest.permission#WRITE_SETTINGS}
 * permission in its manifest, <em>and</em> the user specifically grants
 * the app this capability. To prompt the user to grant this approval,
 * the app must send an intent with the action {@link
 * android.provider.Settings#ACTION_MANAGE_WRITE_SETTINGS}, which causes
 * the system to display a permission management screen.
 *
 * @param context App context.
 * @return true if the calling app can write to system settings, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method of obtaining the UID has changed from calling `Binder.getCallingUid()` to `Process.myUid()` and instead of using the `getPackageNameForUid` method, the `context.getOpPackageName()` method is being used. This is an ""Other statement changed"" as it changes method calls, but it doesn't necessarily alter control flow or exception handling, so the code change type is 4. The change type is also considered ""Dependent API changed"" because the implementations rely on different methods to obtain the package name and UID, making it a 5.","Despite the method call to obtain the UID and package name has changed, the aim of the API is to check whether the calling package is allowed to write system settings. Both methods should return the UID of the calling package and its name correctly in the respective context, so the change should not cause a Compatibility Issue. The main functionality of the method, which is to check the ability of a calling package to write settings, remains the same and does not return a different value or throw a different exception because of these changes. Therefore, there is no Compatibility Issue, which is classified as 0."
489,<android.print.PrinterInfo.Builder: Builder setCapabilities(PrinterCapabilitiesInfo)>,23,24,<android.print.PrinterInfo.Builder: Builder setCapabilities(PrinterCapabilitiesInfo)>,<android.print.PrinterInfo.Builder: Builder setCapabilities(PrinterCapabilitiesInfo)>,0,"{
    mPrototype.mCapabilities = capabilities;
    return this;
}","{
    mCapabilities = capabilities;
    return this;
}",1,"/**
 * Sets the printer capabilities.
 *
 * @param capabilities The capabilities.
 * @return This builder.
 */
","/**
 * Sets the printer capabilities.
 *
 * @param capabilities The capabilities.
 * @return This builder.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The implementation has a slight change where a direct assignment to the member variable `mCapabilities` is used instead of using `mPrototype.mCapabilities`. The method signature and return type remain unchanged, so the code change type is 4 (Other statement changed).","There's no indication that the behavior of the API has changed since the method still assigns the capabilities to an internal variable and returns the Builder object. Therefore, there is no Compatibility Issue, which means the CI type is 0 (No Compatibility Issue)."
490,<android.view.ContextThemeWrapper: void applyOverrideConfiguration(Configuration)>,23,24,<android.view.ContextThemeWrapper: void applyOverrideConfiguration(Configuration)>,<android.view.ContextThemeWrapper: void applyOverrideConfiguration(Configuration)>,0,"{
    if (mResources != null) {
        throw new IllegalStateException(""getResources() has already been called"");
    }
    if (mOverrideConfiguration != null) {
        throw new IllegalStateException(""Override configuration has already been set"");
    }
    mOverrideConfiguration = new Configuration(overrideConfiguration);
}","{
    if (mResources != null) {
        throw new IllegalStateException(""getResources() or getAssets() has already been called"");
    }
    if (mOverrideConfiguration != null) {
        throw new IllegalStateException(""Override configuration has already been set"");
    }
    mOverrideConfiguration = new Configuration(overrideConfiguration);
}",1,"/**
 * Call to set an ""override configuration"" on this context -- this is
 * a configuration that replies one or more values of the standard
 * configuration that is applied to the context.  See
 * {@link Context#createConfigurationContext(Configuration)} for more
 * information.
 *
 * <p>This method can only be called once, and must be called before any
 * calls to {@link #getResources()} are made.
 */
","/**
 * Call to set an ""override configuration"" on this context -- this is
 * a configuration that replies one or more values of the standard
 * configuration that is applied to the context.  See
 * {@link Context#createConfigurationContext(Configuration)} for more
 * information.
 *
 * <p>This method can only be called once, and must be called before any
 * calls to {@link #getResources()} or {@link #getAssets()} are made.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the exception message text from ""getResources() has already been called"" to ""getResources() or getAssets() has already been called"". Since this is a message string change within an exception being thrown, the code change type is 4.","There is no compatibility issue because the behavior of throwing an exception under the same conditions has not changed; only the message contained in the exception has been updated. The logic remains the same, so the API will behave identically with respect to how it functions, hence no CI."
491,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>",23,24,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The call to intent.prepareToLeaveProcess has been changed to include 'this' as an argument, it constitutes a change in a method invocation argument, which is classified as type 4.","Sending an intent is a process that involves IPC (inter-process communication), and adding 'this' as a context for the IPC doesn't affect the intent's delivery or the type/values that the API itself returns or the exceptions it throws. It's an internal detail of how the intent is prepared, which will not cause a different value to be returned by the method or a different exception to be thrown. Thus, there is no Compatibility Issue detected."
492,"<android.view.View: boolean requestRectangleOnScreen(Rect,boolean)>",23,24,"<android.view.View: boolean requestRectangleOnScreen(Rect,boolean)>","<android.view.View: boolean requestRectangleOnScreen(Rect,boolean)>",0,"{
    if (mParent == null) {
        return false;
    }
    View child = this;
    RectF position = (mAttachInfo != null) ? mAttachInfo.mTmpTransformRect : new RectF();
    position.set(rectangle);
    ViewParent parent = mParent;
    boolean scrolled = false;
    while (parent != null) {
        rectangle.set((int) position.left, (int) position.top, (int) position.right, (int) position.bottom);
        scrolled |= parent.requestChildRectangleOnScreen(child, rectangle, immediate);
        if (!child.hasIdentityMatrix()) {
            child.getMatrix().mapRect(position);
        }
        position.offset(child.mLeft, child.mTop);
        if (!(parent instanceof View)) {
            break;
        }
        View parentView = (View) parent;
        position.offset(-parentView.getScrollX(), -parentView.getScrollY());
        child = parentView;
        parent = child.getParent();
    }
    return scrolled;
}","{
    if (mParent == null) {
        return false;
    }
    View child = this;
    RectF position = (mAttachInfo != null) ? mAttachInfo.mTmpTransformRect : new RectF();
    position.set(rectangle);
    ViewParent parent = mParent;
    boolean scrolled = false;
    while (parent != null) {
        rectangle.set((int) position.left, (int) position.top, (int) position.right, (int) position.bottom);
        scrolled |= parent.requestChildRectangleOnScreen(child, rectangle, immediate);
        if (!(parent instanceof View)) {
            break;
        }
        // move it from child's content coordinate space to parent's content coordinate space
        position.offset(child.mLeft - child.getScrollX(), child.mTop - child.getScrollY());
        child = (View) parent;
        parent = child.getParent();
    }
    return scrolled;
}",1,"/**
 * Request that a rectangle of this view be visible on the screen,
 * scrolling if necessary just enough.
 *
 * <p>A View should call this if it maintains some notion of which part
 * of its content is interesting.  For example, a text editing view
 * should call this when its cursor moves.
 *
 * <p>When <code>immediate</code> is set to true, scrolling will not be
 * animated.
 *
 * @param rectangle The rectangle.
 * @param immediate True to forbid animated scrolling, false otherwise
 * @return Whether any parent scrolled.
 */
","/**
 * Request that a rectangle of this view be visible on the screen,
 * scrolling if necessary just enough.
 *
 * <p>A View should call this if it maintains some notion of which part
 * of its content is interesting.  For example, a text editing view
 * should call this when its cursor moves.
 * <p>The Rectangle passed into this method should be in the View's content coordinate space.
 * It should not be affected by which part of the View is currently visible or its scroll
 * position.
 * <p>When <code>immediate</code> is set to true, scrolling will not be
 * animated.
 *
 * @param rectangle The rectangle in the View's content coordinate space
 * @param immediate True to forbid animated scrolling, false otherwise
 * @return Whether any parent scrolled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency changed because the condition in which the matrix mapping is applied (`if (!child.hasIdentityMatrix())`) has been removed. Additionally, an update to how the `position` is offset has been made, which qualifies as another statement changed. So the change types are 3 (Control dependency changed) and 4 (Other statement changed).","Although the implementation has changed, both versions ultimately address the same functionality: they request a rectangle on the screen within the view's content space, and the behavior of returning whether scrolling occurred remains unchanged. The removal of the matrix-related code only simplifies the transformation process as it won't be performed, but this doesn't inherently change the functionality of the method in terms of its expected outcome for the given rectangle. The result of the underlying `requestChildRectangleOnScreen()` is used the same way, and therefore, there's no compatibility issue, i.e., the method should not return a different result or throw a different exception due to the changes."
493,<android.widget.ProgressBar: void startAnimation()>,23,24,<android.widget.ProgressBar: void startAnimation()>,<android.widget.ProgressBar: void startAnimation()>,0,"{
    if (getVisibility() != VISIBLE) {
        return;
    }
    if (mIndeterminateDrawable instanceof Animatable) {
        mShouldStartAnimationDrawable = true;
        mHasAnimation = false;
    } else {
        mHasAnimation = true;
        if (mInterpolator == null) {
            mInterpolator = new LinearInterpolator();
        }
        if (mTransformation == null) {
            mTransformation = new Transformation();
        } else {
            mTransformation.clear();
        }
        if (mAnimation == null) {
            mAnimation = new AlphaAnimation(0.0f, 1.0f);
        } else {
            mAnimation.reset();
        }
        mAnimation.setRepeatMode(mBehavior);
        mAnimation.setRepeatCount(Animation.INFINITE);
        mAnimation.setDuration(mDuration);
        mAnimation.setInterpolator(mInterpolator);
        mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
    }
    postInvalidate();
}","{
    if (getVisibility() != VISIBLE || getWindowVisibility() != VISIBLE) {
        return;
    }
    if (mIndeterminateDrawable instanceof Animatable) {
        mShouldStartAnimationDrawable = true;
        mHasAnimation = false;
    } else {
        mHasAnimation = true;
        if (mInterpolator == null) {
            mInterpolator = new LinearInterpolator();
        }
        if (mTransformation == null) {
            mTransformation = new Transformation();
        } else {
            mTransformation.clear();
        }
        if (mAnimation == null) {
            mAnimation = new AlphaAnimation(0.0f, 1.0f);
        } else {
            mAnimation.reset();
        }
        mAnimation.setRepeatMode(mBehavior);
        mAnimation.setRepeatCount(Animation.INFINITE);
        mAnimation.setDuration(mDuration);
        mAnimation.setInterpolator(mInterpolator);
        mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
    }
    postInvalidate();
}",1,"/**
 * <p>Start the indeterminate progress animation.</p>
 */
","/**
 * <p>Start the indeterminate progress animation.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"In the late version implementation, there is an additional condition check for getWindowVisibility() != VISIBLE in the if statement. This is a change in the control dependency, so the code change type is 3.","Although there is a code change related to an additional visibility check, this does not introduce a compatibility issue because it does not alter the behavior in a way that would affect the return value or the exceptions thrown. The return statement still executes when the view is not visible, and the addition of the getWindowVisibility check only reinforces that condition without changing the semantics of when the return statement would be executed. Thus, there is no compatibility issue, so the CI type is 0."
494,<android.animation.ValueAnimator: boolean isRunning()>,23,24,<android.animation.ValueAnimator: boolean isRunning()>,<android.animation.ValueAnimator: boolean isRunning()>,0,"{
    return (mPlayingState == RUNNING || mRunning);
}","{
    return mRunning;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been simplified and no longer checks for mPlayingState, therefore the code change type is 1.","The late version of the API only checks mRunning, while the early version also considers mPlayingState. If mPlayingState == RUNNING, but mRunning is false, the early version would return true while the late version would return false. This means the API could potentially return different values, so the CI type is 1."
495,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,23,24,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,0,"{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightness == other.screenBrightness && screenAutoBrightnessAdjustment == other.screenAutoBrightnessAdjustment && brightnessSetByUser == other.brightnessSetByUser && useAutoBrightness == other.useAutoBrightness && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}","{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightness == other.screenBrightness && screenAutoBrightnessAdjustment == other.screenAutoBrightnessAdjustment && brightnessSetByUser == other.brightnessSetByUser && useAutoBrightness == other.useAutoBrightness && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState && useTwilight == other.useTwilight;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new condition `useTwilight == other.useTwilight` is appended to the return statement, which is a boolean condition check for equality, therefore the type of change is 4.","Although there is a new condition in the return statement, this change does not introduce a new behavior in terms of return type or exception handling. It merely adds another field to check for equality, so as long as the method is used as intended (comparing DisplayPowerRequest objects), this should not cause a Compatibility Issue. Hence, there is no CI detected."
496,<android.app.admin.DeviceAdminInfo: String getPackageName()>,23,24,<android.app.admin.DeviceAdminInfo: String getPackageName()>,<android.app.admin.DeviceAdminInfo: String getPackageName()>,0,"{
    return mReceiver.activityInfo.packageName;
}","{
    return mActivityInfo.packageName;
}",1,"/**
 * Return the .apk package that implements this device admin.
 */
","/**
 * Return the .apk package that implements this device admin.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The reference to the `packageName` changed from `mReceiver.activityInfo.packageName` to `mActivityInfo.packageName`, which is an internal reference change, resulting in the code change type being 4.","Assuming that `mActivityInfo` is correctly initialized to `mReceiver.activityInfo`, the actual value returned by the method has not changed. The behavior of the API remains consistent between versions assuming correct internal state initialization, so there is no compatibility issue and the CI type is 0."
497,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,23,24,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,0,"{
    if (mView == null || !mAdded) {
        Slog.w(TAG, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    } else if ((!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) || mStopped || (mPausedForTransition && !isBack(q.mEvent))) {
        // but the window has lost focus or stopped in the meantime.
        if (isTerminalInputEvent(q.mEvent)) {
            // Don't drop terminal input events, however mark them as canceled.
            q.mEvent.cancel();
            Slog.w(TAG, ""Cancelling event due to no window focus: "" + q.mEvent);
            return false;
        }
        // Drop non-terminal input events.
        Slog.w(TAG, ""Dropping event due to no window focus: "" + q.mEvent);
        return true;
    }
    return false;
}","{
    if (mView == null || !mAdded) {
        Slog.w(mTag, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    } else if ((!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) || mStopped || (mIsAmbientMode && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_BUTTON)) || (mPausedForTransition && !isBack(q.mEvent))) {
        // but the window has lost focus or stopped in the meantime.
        if (isTerminalInputEvent(q.mEvent)) {
            // Don't drop terminal input events, however mark them as canceled.
            q.mEvent.cancel();
            Slog.w(mTag, ""Cancelling event due to no window focus: "" + q.mEvent);
            return false;
        }
        // Drop non-terminal input events.
        Slog.w(mTag, ""Dropping event due to no window focus: "" + q.mEvent);
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control statements have been changed with an additional condition `(mIsAmbientMode && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_BUTTON))` in the 'else if' block, which is a change in control dependencies (type 3). Also, `Slog.w(TAG, ...)` has been updated to `Slog.w(mTag, ...)`, which is a change in a logging statement, classified as other statement changed (type 4).","Despite the additional condition and change in the logging statement, these modifications do not affect the return values or thrown exceptions in a way that would cause a compatibility issue. The method still only returns either `true` or `false`, based on the event state, and the new condition simply refines the decision process without introducing a new behavior that differs from the previous ones. Therefore, there is no compatibility issue (0)."
498,"<android.util.Log: int e(String,String,Throwable)>",23,24,"<android.util.Log: int e(String,String,Throwable)>","<android.util.Log: int e(String,String,Throwable)>",0,"{
    return println_native(LOG_ID_MAIN, ERROR, tag, msg + '\n' + getStackTraceString(tr));
}","{
    return printlns(LOG_ID_MAIN, ERROR, tag, msg, tr);
}",1,"/**
 * Send a {@link #ERROR} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #ERROR} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from using println_native with string concatenation to using printlns with separate parameters for the message and the Throwable. Additionally, the dependent API has changed from println_native to printlns, which is another method with different parameters. Therefore, the change types are 1 (Return statement changed) and 5 (Dependent API changed).","The refactored implementation no longer concatenates the Throwable's stack trace to the message and instead directly passes the Throwable object to the printlns method. This difference in handling the Throwable could potentially affect the behavior of how the exception is printed, logged, or processed. Therefore, there is potential for a different return value because the underlying implementation of log printing could have changed, resulting in a type 1 CI (Compatibility Issue caused by potential different return values or types)."
499,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",23,24,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>","<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",0,"{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException(""signedData is null"");
        }
        List<Certificate> encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException(""encCerts is empty"");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator<Certificate> it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            InputStream is = new ByteArrayInputStream(it.next().getEncoded());
            cert = (X509Certificate) cf.generateCertificate(is);
        } else {
            throw new SignatureException(""signature contains no certificates"");
        }
        List<SignerInfo> sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException(""no signer infos!"");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<X509Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (X509Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery only handles SHA1withRSA and
        // SHA256withRSA signatures.  SignApk chooses which to use
        // based on the signature algorithm of the cert:
        // 
        // ""SHA256withRSA"" cert -> ""SHA256withRSA"" signature
        // ""SHA1withRSA"" cert   -> ""SHA1withRSA"" signature
        // ""MD5withRSA"" cert    -> ""SHA1withRSA"" signature (for backwards compatibility)
        // any other cert       -> SignApk fails
        // 
        // Here we ignore whatever the cert says, and instead use
        // whatever algorithm is used by the signature.
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + ""with"" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
}","{
    final long fileLen = packageFile.length();
    final RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        final long startTimeMillis = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(0);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        final int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        final int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // Parse the signature
        PKCS7 block = new PKCS7(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        // Take the first certificate from the signature (packages
        // should contain only one).
        X509Certificate[] certificates = block.getCertificates();
        if (certificates == null || certificates.length == 0) {
            throw new SignatureException(""signature contains no certificates"");
        }
        X509Certificate cert = certificates[0];
        PublicKey signatureKey = cert.getPublicKey();
        SignerInfo[] signerInfos = block.getSignerInfos();
        if (signerInfos == null || signerInfos.length == 0) {
            throw new SignatureException(""signature contains no signedData"");
        }
        SignerInfo signerInfo = signerInfos[0];
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        boolean verified = false;
        HashSet<X509Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        for (X509Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        raf.seek(0);
        final ProgressListener listenerForInner = listener;
        SignerInfo verifyResult = block.verify(signerInfo, new InputStream() {

            // The signature covers all of the OTA package except the
            // archive comment and its 2-byte length.
            long toRead = fileLen - commentSize - 2;

            long soFar = 0;

            int lastPercent = 0;

            long lastPublishTime = startTimeMillis;

            @Override
            public int read() throws IOException {
                throw new UnsupportedOperationException();
            }

            @Override
            public int read(byte[] b, int off, int len) throws IOException {
                if (soFar >= toRead) {
                    return -1;
                }
                if (Thread.currentThread().isInterrupted()) {
                    return -1;
                }
                int size = len;
                if (soFar + size > toRead) {
                    size = (int) (toRead - soFar);
                }
                int read = raf.read(b, off, size);
                soFar += read;
                if (listenerForInner != null) {
                    long now = System.currentTimeMillis();
                    int p = (int) (soFar * 100 / toRead);
                    if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                        lastPercent = p;
                        lastPublishTime = now;
                        listenerForInner.onProgress(lastPercent);
                    }
                }
                return read;
            }
        });
        final boolean interrupted = Thread.interrupted();
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (verifyResult == null) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
}",1,"/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
","/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
500,<android.app.SearchManager: SearchableInfo getSearchableInfo(ComponentName)>,23,24,<android.app.SearchManager: SearchableInfo getSearchableInfo(ComponentName)>,<android.app.SearchManager: SearchableInfo getSearchableInfo(ComponentName)>,0,"{
    try {
        return mService.getSearchableInfo(componentName);
    } catch (RemoteException ex) {
        Log.e(TAG, ""getSearchableInfo() failed: "" + ex);
        return null;
    }
}","{
    try {
        return mService.getSearchableInfo(componentName);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets information about a searchable activity.
 *
 * @param componentName The activity to get searchable information for.
 * @return Searchable information, or <code>null</code> if the activity does not
 * exist, or is not searchable.
 */
","/**
 * Gets information about a searchable activity.
 *
 * @param componentName The activity to get searchable information for.
 * @return Searchable information, or <code>null</code> if the activity does not
 * exist, or is not searchable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"Exception handling statement has changed from logging the exception and returning null, to rethrowing the exception, so the code change type is 2.","Since the exception handling strategy has changed from catching the RemoteException and returning null to throwing the exception, the behavior of the API when an exception is caught is different between the two versions. Therefore, it can lead to a potential Compatibility Issue due to the API throwing a different exception in the late version; thus, the CI type is 2."
501,"<android.animation.AnimatorInflater: StateListAnimator loadStateListAnimator(Context,int)>",23,24,"<android.animation.AnimatorInflater: StateListAnimator loadStateListAnimator(Context,int)>","<android.animation.AnimatorInflater: StateListAnimator loadStateListAnimator(Context,int)>",0,"{
    final Resources resources = context.getResources();
    final ConfigurationBoundResourceCache<StateListAnimator> cache = resources.getStateListAnimatorCache();
    final Theme theme = context.getTheme();
    StateListAnimator animator = cache.getInstance(id, theme);
    if (animator != null) {
        return animator;
    }
    XmlResourceParser parser = null;
    try {
        parser = resources.getAnimation(id);
        animator = createStateListAnimatorFromXml(context, parser, Xml.asAttributeSet(parser));
        if (animator != null) {
            animator.appendChangingConfigurations(getChangingConfigs(resources, id));
            final ConstantState<StateListAnimator> constantState = animator.createConstantState();
            if (constantState != null) {
                cache.put(id, theme, constantState);
                // return a clone so that the animator in constant state is never used.
                animator = constantState.newInstance(resources, theme);
            }
        }
        return animator;
    } catch (XmlPullParserException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null) {
            parser.close();
        }
    }
}","{
    final Resources resources = context.getResources();
    final ConfigurationBoundResourceCache<StateListAnimator> cache = resources.getStateListAnimatorCache();
    final Theme theme = context.getTheme();
    StateListAnimator animator = cache.getInstance(id, resources, theme);
    if (animator != null) {
        return animator;
    }
    XmlResourceParser parser = null;
    try {
        parser = resources.getAnimation(id);
        animator = createStateListAnimatorFromXml(context, parser, Xml.asAttributeSet(parser));
        if (animator != null) {
            animator.appendChangingConfigurations(getChangingConfigs(resources, id));
            final ConstantState<StateListAnimator> constantState = animator.createConstantState();
            if (constantState != null) {
                cache.put(id, theme, constantState);
                // return a clone so that the animator in constant state is never used.
                animator = constantState.newInstance(resources, theme);
            }
        }
        return animator;
    } catch (XmlPullParserException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null) {
            parser.close();
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The parameter list for cache.getInstance(id, theme) has changed to cache.getInstance(id, resources, theme), which involves passing a new parameter (resources) to the method. Thus, the code change type is 5.","Since an additional parameter (resources) is simply being passed to the cache.getInstance method and it does not alter the control flow, return values, or exception handling of the method, there is no Compatibility Issue detected. Thus, the CI type is 0."
502,"<com.android.server.backup.PreferredActivityBackupHelper: void applyRestoredPayload(String,byte[])>",23,24,"<com.android.server.backup.PreferredActivityBackupHelper: void applyRestoredPayload(String,byte[])>","<com.android.server.backup.PreferredActivityBackupHelper: void applyRestoredPayload(String,byte[])>",0,"{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        switch(key) {
            case KEY_PREFERRED:
                pm.restorePreferredActivities(payload, UserHandle.USER_OWNER);
                break;
            case KEY_DEFAULT_APPS:
                pm.restoreDefaultApps(payload, UserHandle.USER_OWNER);
                break;
            case KEY_INTENT_VERIFICATION:
                pm.restoreIntentFilterVerification(payload, UserHandle.USER_OWNER);
                break;
            default:
                Slog.w(TAG, ""Unexpected restore key "" + key);
        }
    } catch (Exception e) {
        Slog.w(TAG, ""Unable to restore key "" + key);
    }
}","{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        // TODO: http://b/22388012
        switch(key) {
            case KEY_PREFERRED:
                pm.restorePreferredActivities(payload, UserHandle.USER_SYSTEM);
                break;
            case KEY_DEFAULT_APPS:
                pm.restoreDefaultApps(payload, UserHandle.USER_SYSTEM);
                break;
            case KEY_INTENT_VERIFICATION:
                pm.restoreIntentFilterVerification(payload, UserHandle.USER_SYSTEM);
                break;
            default:
                Slog.w(TAG, ""Unexpected restore key "" + key);
        }
    } catch (Exception e) {
        Slog.w(TAG, ""Unable to restore key "" + key);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The code change involves passing a different constant (UserHandle.USER_SYSTEM instead of UserHandle.USER_OWNER) as an argument to the methods restorePreferredActivities, restoreDefaultApps, and restoreIntentFilterVerification. The modified constant represents a different user handle ID but does not affect the method signatures, so the code change type is 5.","The change in the argument passed into the methods does not constitute a behavioral change that would amount to a Compatibility Issue since these methods are designed to handle different user IDs correctly. The functionality remains intact for the restore operations, just for a different user. Therefore, there is no Compatibility Issue."
503,<android.app.admin.DeviceAdminInfo: ActivityInfo getActivityInfo()>,23,24,<android.app.admin.DeviceAdminInfo: ActivityInfo getActivityInfo()>,<android.app.admin.DeviceAdminInfo: ActivityInfo getActivityInfo()>,0,"{
    return mReceiver.activityInfo;
}","{
    return mActivityInfo;
}",1,"/**
 * Return the raw information about the receiver implementing this
 * device admin.  Do not modify the returned object.
 */
","/**
 * Return the raw information about the receiver implementing this
 * device admin.  Do not modify the returned object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method still returns an ActivityInfo object, but the source of this object has changed from mReceiver.activityInfo to mActivityInfo. This change is cosmetic and does not affect the return type or value as long as mActivityInfo is internally set to mReceiver.activityInfo. Hence the code change type is 4.","Since both versions of the method return an ActivityInfo and there's no indication that the value of mActivityInfo differs from mReceiver.activityInfo, there's no compatibility issue—assuming mActivityInfo properly reflects the activity info of the receiver. Thus, the compatibility issue type is 0."
504,"<android.app.ContextImpl: SQLiteDatabase openOrCreateDatabase(String,int,CursorFactory,DatabaseErrorHandler)>",23,24,"<android.app.ContextImpl: SQLiteDatabase openOrCreateDatabase(String,int,CursorFactory,DatabaseErrorHandler)>","<android.app.ContextImpl: SQLiteDatabase openOrCreateDatabase(String,int,CursorFactory,DatabaseErrorHandler)>",0,"{
    File f = validateFilePath(name, true);
    int flags = SQLiteDatabase.CREATE_IF_NECESSARY;
    if ((mode & MODE_ENABLE_WRITE_AHEAD_LOGGING) != 0) {
        flags |= SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING;
    }
    SQLiteDatabase db = SQLiteDatabase.openDatabase(f.getPath(), factory, flags, errorHandler);
    setFilePermissionsFromMode(f.getPath(), mode, 0);
    return db;
}","{
    checkMode(mode);
    File f = getDatabasePath(name);
    int flags = SQLiteDatabase.CREATE_IF_NECESSARY;
    if ((mode & MODE_ENABLE_WRITE_AHEAD_LOGGING) != 0) {
        flags |= SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING;
    }
    if ((mode & MODE_NO_LOCALIZED_COLLATORS) != 0) {
        flags |= SQLiteDatabase.NO_LOCALIZED_COLLATORS;
    }
    SQLiteDatabase db = SQLiteDatabase.openDatabase(f.getPath(), factory, flags, errorHandler);
    setFilePermissionsFromMode(f.getPath(), mode, 0);
    return db;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There's a new call to the method checkMode(mode), a new condition checking for MODE_NO_LOCALIZED_COLLATORS, and related flags modification; so the code change types are 3 (control dependency change due to the new condition) and 4 (other statement changed due to the addition of a new method call and a new flag assignment).","Despite the changes, there is no Compatibility Issue as none of these changes would cause the API to return a different value or throw a different exception. The method still essentially opens a database and returns the SQLiteDatabase object. The flags altered and the additional checkMode call don't directly affect the return value but instead change configurations and validations within the intended use of the API."
505,"<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>",23,24,"<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>","<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>",0,"{
    int rank = getRank(key);
    outRanking.populate(key, rank, isAmbient(key), !isIntercepted(key), getVisibilityOverride(key));
    return rank >= 0;
}","{
    int rank = getRank(key);
    outRanking.populate(key, rank, !isIntercepted(key), getVisibilityOverride(key), getSuppressedVisualEffects(key), getImportance(key), getImportanceExplanation(key), getOverrideGroupKey(key));
    return rank >= 0;
}",1,"/**
 * Populates outRanking with ranking information for the notification
 * with the given key.
 *
 * @return true if a valid key has been passed and outRanking has
 * been populated; false otherwise
 */
","/**
 * Populates outRanking with ranking information for the notification
 * with the given key.
 *
 * @return true if a valid key has been passed and outRanking has
 * been populated; false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method `outRanking.populate()` has changed in the number of parameters, which indicates that the dependent API `populate()` has undergone changes. Therefore, this is a change of type 4 and 5.","Despite the change in the `populate()` method signature, the API still uses `rank >= 0` as the condition for its return value. The actual functionality of `getRanking()` and the return value are unaffected by the additional parameters to `populate()`. The final return value is a boolean indicating whether the rank is non-negative or not. Thus, there is no Compatibility Issue in the sense of changing return value or exception behavior, and the CI type is 0."
506,<android.hardware.radio.RadioManager.FmBandDescriptor: int hashCode()>,23,24,<android.hardware.radio.RadioManager.FmBandDescriptor: int hashCode()>,<android.hardware.radio.RadioManager.FmBandDescriptor: int hashCode()>,0,"{
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + (mStereo ? 1 : 0);
    result = prime * result + (mRds ? 1 : 0);
    result = prime * result + (mTa ? 1 : 0);
    result = prime * result + (mAf ? 1 : 0);
    return result;
}","{
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + (mStereo ? 1 : 0);
    result = prime * result + (mRds ? 1 : 0);
    result = prime * result + (mTa ? 1 : 0);
    result = prime * result + (mAf ? 1 : 0);
    result = prime * result + (mEa ? 1 : 0);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"An additional statement is added to calculate the 'result' which includes a new field 'mEa', the other statements remained unchanged. So the code change type is 4.","The addition of a new component in the hashCode computation (mEa ? 1 : 0) will change the returned hashCode value when mEa is true. This is a behavior the client code could rely on, hence it poses a CI in terms of a potentially different return value. The CI type is 1."
507,"<android.content.res.Resources: String getQuantityString(int,int,Object)>",23,24,"<android.content.res.Resources: String getQuantityString(int,int,Object)>","<android.content.res.Resources: String getQuantityString(int,int,Object)>",0,"{
    String raw = getQuantityText(id, quantity).toString();
    return String.format(mConfiguration.locale, raw, formatArgs);
}","{
    String raw = getQuantityText(id, quantity).toString();
    return String.format(mResourcesImpl.getConfiguration().getLocales().get(0), raw, formatArgs);
}",1,"/**
 * Formats the string necessary for grammatically correct pluralization
 * of the given resource ID for the given quantity, using the given arguments.
 * Note that the string is selected based solely on grammatical necessity,
 * and that such rules differ between languages. Do not assume you know which string
 * will be returned for a given quantity. See
 * <a href=""{@docRoot}guide/topics/resources/string-resource.html#Plurals"">String Resources</a>
 * for more detail.
 *
 * <p>Substitution of format arguments works as if using
 * {@link java.util.Formatter} and {@link java.lang.String#format}.
 * The resulting string will be stripped of any styled text information.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param quantity The number used to get the correct string for the current language's
 * plural rules.
 * @param formatArgs The format arguments that will be used for substitution.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
","/**
 * Formats the string necessary for grammatically correct pluralization
 * of the given resource ID for the given quantity, using the given arguments.
 * Note that the string is selected based solely on grammatical necessity,
 * and that such rules differ between languages. Do not assume you know which string
 * will be returned for a given quantity. See
 * <a href=""{@docRoot}guide/topics/resources/string-resource.html#Plurals"">String Resources</a>
 * for more detail.
 *
 * <p>Substitution of format arguments works as if using
 * {@link java.util.Formatter} and {@link java.lang.String#format}.
 * The resulting string will be stripped of any styled text information.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param quantity The number used to get the correct string for the current language's
 * plural rules.
 * @param formatArgs The format arguments that will be used for substitution.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API mConfiguration.locale has been changed to mResourcesImpl.getConfiguration().getLocales().get(0). This change indicates that now there is a different method of obtaining the locale used for formatting the string, so the change types are 1,5.","The different method to obtain the locale may cause the API to return different formatted string values, because the locale may be different between the early version and the late version. The change could result in a different return value, so the CI type is 1."
508,"<android.app.admin.DevicePolicyManager: boolean isApplicationHidden(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: boolean isApplicationHidden(ComponentName,String)>","<android.app.admin.DevicePolicyManager: boolean isApplicationHidden(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            return mService.isApplicationHidden(admin, packageName);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""isApplicationHidden"");
    if (mService != null) {
        try {
            return mService.isApplicationHidden(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by profile or device owners to determine if a package is hidden.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to retrieve the hidden status of.
 * @return boolean {@code true} if the package is hidden, {@code false} otherwise.
 */
","/**
 * Called by profile or device owners to determine if a package is hidden.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to retrieve the hidden status of.
 * @return boolean {@code true} if the package is hidden, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4","1,2","A new statement, `throwIfParentInstance(""isApplicationHidden"");`, has been added at the beginning of the method, and a new exception handling statement has been introduced (throw e.rethrowFromSystemServer()), so the code change type is 2,4.","The introduction of a new method call, `throwIfParentInstance(""isApplicationHidden"");`, could lead to a different behavior, as it might throw an exception that was not thrown before, leading to a different exception handling behavior. Also, the new exception handling replacing the logging with `throw e.rethrowFromSystemServer();` could also lead to a different exception being thrown by the API. Therefore, the CI type is 1,2."
509,<android.widget.LinearLayout: LayoutParams generateLayoutParams(LayoutParams)>,23,24,<android.widget.LinearLayout: LayoutParams generateLayoutParams(LayoutParams)>,<android.widget.LinearLayout: LayoutParams generateLayoutParams(LayoutParams)>,0,"{
    return new LayoutParams(p);
}","{
    if (lp instanceof LayoutParams) {
        return new LayoutParams((LayoutParams) lp);
    } else if (lp instanceof MarginLayoutParams) {
        return new LayoutParams((MarginLayoutParams) lp);
    } else {
        return new LayoutParams(lp);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method implementation has been expanded with conditional checks and new instantiation patterns for different layout parameter types. The change now includes a control dependency (an 'if-else' construct), and the instantiation logic for `LayoutParams` has been branched to handle different input types specifically, resulting in other statements being changed as well. Thus, the change type is 1,3,4.","The addition of type checks and branching instantiation of `LayoutParams` can potentially lead to the method returning different subclasses of `LayoutParams` depending upon the exact runtime type of the input parameters. This constitutes a return statement change with the potential to return different values. Hence, the CI type is 1."
510,<android.app.SearchManager: List<SearchableInfo> getSearchablesInGlobalSearch()>,23,24,<android.app.SearchManager: List<SearchableInfo> getSearchablesInGlobalSearch()>,<android.app.SearchManager: List<SearchableInfo> getSearchablesInGlobalSearch()>,0,"{
    try {
        return mService.getSearchablesInGlobalSearch();
    } catch (RemoteException e) {
        Log.e(TAG, ""getSearchablesInGlobalSearch() failed: "" + e);
        return null;
    }
}","{
    try {
        return mService.getSearchablesInGlobalSearch();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a list of the searchable activities that can be included in global search.
 *
 * @return a list containing searchable information for all searchable activities
 * that have the <code>android:includeInGlobalSearch</code> attribute set
 * in their searchable meta-data.
 */
","/**
 * Returns a list of the searchable activities that can be included in global search.
 *
 * @return a list containing searchable information for all searchable activities
 * that have the <code>android:includeInGlobalSearch</code> attribute set
 * in their searchable meta-data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling has changed. In the early version, RemoteException is caught and logged, then null is returned. In the late version, the exception is re-thrown using throw e.rethrowFromSystemServer(), so the code change type is 2.","The change in exception handling means that where the early version would return null upon a RemoteException, the late version will now throw the exception to the caller. This can affect the behavior of any client code that was depending on catching the specific exception or checking for a null return value, which is a CI caused by different exception handling (type 2)."
511,<android.content.res.AssetManager: String[] getResourceStringArray(int)>,23,24,<android.content.res.AssetManager: String[] getResourceStringArray(int)>,<android.content.res.AssetManager: String[] getResourceStringArray(int)>,0,"{
    String[] retArray = getArrayStringResource(id);
    return retArray;
}","{
    return getArrayStringResource(resId);
}",1,"/*package*/
","/**
 * Retrieves the string array associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier of the string array
 * @return the string array, or {@code null}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The only change is the removal of the local variable retArray. The method used for getting the resource, getArrayStringResource, has the same name and presumably the same behavior. The late implementation simply returns the result of the method directly. This constitutes an other statement changed.","No Compatibility Issue arises due to this change, because it doesn't affect the behavior from the caller's perspective. The method still returns a string array as before, and the introduction of a nullable annotation doesn't imply a change in the actual method's behavior - it could merely be a clarification for the developers using this API."
513,<android.app.ActivityThread.H: void handleMessage(Message)>,23,24,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, (msg.arg1 & 1) != 0, msg.arg2, (msg.arg1 & 2) != 0);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, (msg.arg1 & 1) != 0, msg.arg2, (msg.arg1 & 1) != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, ""LAUNCH_ACTIVITY"");
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, false, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                maybeSnapshot();
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY_FINISHING:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, true, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_SHOW:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_HIDE:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            SomeArgs args = (SomeArgs) msg.obj;
            handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true, args.argi3, ""RESUME_ACTIVITY"");
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, msg.arg1 == 1 ? REPORT_TO_ACTIVITY : !REPORT_TO_ACTIVITY);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case MULTI_WINDOW_MODE_CHANGED:
            handleMultiWindowModeChanged((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case PICTURE_IN_PICTURE_MODE_CHANGED:
            handlePictureInPictureModeChanged((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
514,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,23,24,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,0,"{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            return ic;
        }
    }
    return null;
}","{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            return ic;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
515,<android.app.NotificationManager.Policy: String toString()>,23,24,<android.app.NotificationManager.Policy: String toString()>,<android.app.NotificationManager.Policy: String toString()>,0,"{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + ""]"";
}","{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been changed by appending ""+ ',suppressedVisualEffects=' + suppressedEffectsToString(suppressedVisualEffects)"" to the string. Therefore, the code change type is 1.","The change of return statement by adding new information to the returned string indicates that the API will return a different value in the late version. Hence, the CI type is 1."
516,<android.view.ViewGroup.HoverTarget: void recycle()>,23,24,<android.view.ViewGroup.HoverTarget: void recycle()>,<android.view.ViewGroup.HoverTarget: void recycle()>,0,"{
    synchronized (sRecycleLock) {
        if (sRecycledCount < MAX_RECYCLED) {
            next = sRecycleBin;
            sRecycleBin = this;
            sRecycledCount += 1;
        } else {
            next = null;
        }
        child = null;
    }
}","{
    if (child == null) {
        throw new IllegalStateException(""already recycled once"");
    }
    synchronized (sRecycleLock) {
        if (sRecycledCount < MAX_RECYCLED) {
            next = sRecycleBin;
            sRecycleBin = this;
            sRecycledCount += 1;
        } else {
            next = null;
        }
        child = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An exception handling statement ""throw new IllegalStateException(""already recycled once"")"" and a control statement ""if (child == null)"" have been added before the existing synchronized block, so the change type is 2,3.","The newly introduced if condition checks if the 'child' is null, and if so, throws an IllegalStateException. This is a change in exception handling and could cause a Compatibility Issue since the previous version did not throw an exception in this case, so the CI type is 2."
519,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,23,24,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,0,"{
    try {
        return mInstaller.createSession(params, mInstallerPackageName, mUserId);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        return mInstaller.createSession(params, mInstallerPackageName, mUserId);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Create a new session using the given parameters, returning a unique ID
 * that represents the session. Once created, the session can be opened
 * multiple times across multiple device boots.
 * <p>
 * The system may automatically destroy sessions that have not been
 * finalized (either committed or abandoned) within a reasonable period of
 * time, typically on the order of a day.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when installation services are unavailable,
 * such as when called from a restricted user.
 * @throws IllegalArgumentException when {@link SessionParams} is invalid.
 * @return positive, non-zero unique ID that represents the created session.
 * This ID remains consistent across device reboots until the
 * session is finalized. IDs are not reused during a given boot.
 */
","/**
 * Create a new session using the given parameters, returning a unique ID
 * that represents the session. Once created, the session can be opened
 * multiple times across multiple device boots.
 * <p>
 * The system may automatically destroy sessions that have not been
 * finalized (either committed or abandoned) within a reasonable period of
 * time, typically on the order of a day.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when installation services are unavailable,
 * such as when called from a restricted user.
 * @throws IllegalArgumentException when {@link SessionParams} is invalid.
 * @return positive, non-zero unique ID that represents the created session.
 * This ID remains consistent across device reboots until the
 * session is finalized. IDs are not reused during a given boot.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement for RemoteException has changed from rethrowAsRuntimeException() to rethrowFromSystemServer(), so the code change type is 2.","Since the handling of the RemoteException has changed, it could lead to the API throwing different exceptions under certain circumstances, hence the CI type is 2."
520,"<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>",23,24,"<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>","<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>",0,"{
    try {
        mService.setInputMethod(token, id);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        mService.setInputMethod(token, id);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Force switch to a new input method component. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 */
","/**
 * Force switch to a new input method component. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to calling e.rethrowFromSystemServer(), so the change type is 2.","Because of the change in the exception handling block, such that the exception thrown is different between the two versions, this could lead to a different exception handling behavior for the calling code. Therefore, the CI type is 2."
521,<android.app.admin.DevicePolicyManager: boolean getStorageEncryption(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean getStorageEncryption(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getStorageEncryption(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getStorageEncryption(admin, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""getStorageEncryption"");
    if (mService != null) {
        try {
            return mService.getStorageEncryption(admin, myUserId());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by an application that is administering the device to
 * determine the requested setting for secure storage.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.  If null,
 * this will return the requested encryption setting as an aggregate of all active
 * administrators.
 * @return true if the admin(s) are requesting encryption, false if not.
 */
","/**
 * Called by an application that is administering the device to
 * determine the requested setting for secure storage.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.  If null,
 * this will return the requested encryption setting as an aggregate of all active
 * administrators.
 * @return true if the admin(s) are requesting encryption, false if not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"There's a new method call throwIfParentInstance(""getStorageEncryption""), a change in the method called within the try block from UserHandle.myUserId() to myUserId(), and a change in the exception handling from logging the exception to throwing it with throw e.rethrowFromSystemServer(). The code changes are 2 (exception handling statement changed), 4 (other statement changed - addition of a new method call), and 5 (dependent API changed - change in the method call within try block).","The addition of throwIfParentInstance() method could potentially throw an exception before reaching the original logic, and also the change from a logged exception to a rethrown exception with throw e.rethrowFromSystemServer() will lead to different exception handling. As a result, the compatibility issue is 2 (Compatibility Issue caused by potential different exception handlings)."
522,<android.app.Notification.Builder: Builder setPublicVersion(Notification)>,23,24,<android.app.Notification.Builder: Builder setPublicVersion(Notification)>,<android.app.Notification.Builder: Builder setPublicVersion(Notification)>,0,"{
    mPublicVersion = n;
    return this;
}","{
    if (n != null) {
        mN.publicVersion = new Notification();
        n.cloneInto(mN.publicVersion, /*heavy=*/
        true);
    } else {
        mN.publicVersion = null;
    }
    return this;
}",1,"/**
 * Supply a replacement Notification whose contents should be shown in insecure contexts
 * (i.e. atop the secure lockscreen). See {@link #visibility} and {@link #VISIBILITY_PUBLIC}.
 * @param n A replacement notification, presumably with some or all info redacted.
 * @return The same Builder.
 */
","/**
 * Supply a replacement Notification whose contents should be shown in insecure contexts
 * (i.e. atop the secure lockscreen). See {@link #visibility} and {@link #VISIBILITY_PUBLIC}.
 * @param n A replacement notification, presumably with some or all info redacted.
 * @return The same Builder.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has changed from directly assigning the Notification object to the mPublicVersion field in the early version to creating a new Notification object and cloning the passed Notification into it in the late version, so the code change type is 4. Additionally, the condition check for the parameter 'n' is also new.","This change does not introduce a new return variable nor does it change the exception handling, and since the method's behavior and contract remain the same (it's setting a public version of a Notification), which user-set internals are used for storage is an internal implementation detail. Therefore, there's no Compatibility Issue, indicated by 0."
524,"<com.android.server.backup.SystemBackupAgent: void onBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>",23,24,"<com.android.server.backup.SystemBackupAgent: void onBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>","<com.android.server.backup.SystemBackupAgent: void onBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>",0,"{
    // We only back up the data under the current ""wallpaper"" schema with metadata
    IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
    String[] files = new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO };
    String[] keys = new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY };
    if (wallpaper != null) {
        try {
            final String wallpaperName = wallpaper.getName();
            if (wallpaperName != null && wallpaperName.length() > 0) {
                // When the wallpaper has a name, back up the info by itself.
                // TODO: Don't rely on the innards of the service object like this!
                // TODO: Send a delete for any stored wallpaper image in this case?
                files = new String[] { WALLPAPER_INFO };
                keys = new String[] { WALLPAPER_INFO_KEY };
            }
        } catch (RemoteException re) {
            Slog.e(TAG, ""Couldn't get wallpaper name\n"" + re);
        }
    }
    addHelper(WALLPAPER_HELPER, new WallpaperBackupHelper(this, files, keys));
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    super.onBackup(oldState, data, newState);
}","{
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    addHelper(PERMISSION_HELPER, new PermissionBackupHelper());
    addHelper(USAGE_STATS_HELPER, new UsageStatsBackupHelper(this));
    addHelper(SHORTCUT_MANAGER_HELPER, new ShortcutBackupHelper());
    super.onBackup(oldState, data, newState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code has changed by removing the entire section that deals with the wallpaper service and the keys and files associated with it, and by adding new helpers for permissions, usage stats, and shortcut manager. These changes are part of ""Other statement changed,"" so the code change type is 4.","There is no Compatibility Issue detected because the behavior of how backups are performed with the additional helpers does not change the expected outcome of the method, which is to backup certain settings. There are no changes in the return type or exceptions thrown, the control flow remains the same, and the changes are internal implementation details that shouldn't affect how clients interact with the method. Thus, there should be no compatibility issue as per the definitions."
526,<android.app.ContextImpl: File[] getExternalFilesDirs(String)>,23,24,<android.app.ContextImpl: File[] getExternalFilesDirs(String)>,<android.app.ContextImpl: File[] getExternalFilesDirs(String)>,0,"{
    synchronized (mSync) {
        if (mExternalFilesDirs == null) {
            mExternalFilesDirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());
        }
        // Splice in requested type, if any
        File[] dirs = mExternalFilesDirs;
        if (type != null) {
            dirs = Environment.buildPaths(dirs, type);
        }
        // Create dirs if needed
        return ensureDirsExistOrFilter(dirs);
    }
}","{
    synchronized (mSync) {
        if (mExternalFilesDirs == null) {
            mExternalFilesDirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());
        }
        // Splice in requested type, if any
        File[] dirs = mExternalFilesDirs;
        if (type != null) {
            dirs = Environment.buildPaths(dirs, type);
        }
        // Create dirs if needed
        return ensureExternalDirsExistOrFilter(dirs);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method name called within the return statement has changed from `ensureDirsExistOrFilter` to `ensureExternalDirsExistOrFilter`. This indicates a change in the dependent API, classifying as code change type 5.","There is no Compatibility Issue despite the change in the dependent method name, because this change is internal and does not modify the behavior that callers of `getExternalFilesDirs` rely on. It is assumed that `ensureExternalDirsExistOrFilter` is intended to replace `ensureDirsExistOrFilter` with the same external behavior, just with a different name."
527,<android.view.ViewGroup.TouchTarget: void recycle()>,23,24,<android.view.ViewGroup.TouchTarget: void recycle()>,<android.view.ViewGroup.TouchTarget: void recycle()>,0,"{
    synchronized (sRecycleLock) {
        if (sRecycledCount < MAX_RECYCLED) {
            next = sRecycleBin;
            sRecycleBin = this;
            sRecycledCount += 1;
        } else {
            next = null;
        }
        child = null;
    }
}","{
    if (child == null) {
        throw new IllegalStateException(""already recycled once"");
    }
    synchronized (sRecycleLock) {
        if (sRecycledCount < MAX_RECYCLED) {
            next = sRecycleBin;
            sRecycleBin = this;
            sRecycledCount += 1;
        } else {
            next = null;
        }
        child = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An exception handling statement, specifically an IllegalStateException, is introduced, checking if 'child' is null before the synchronized block, and a control dependency change occurs due to the added if-condition. Thus, the change type is 2,3.","The newly added exception handling can cause a new exception to be thrown which was not present in the early version, leading to different exception behavior. Therefore, the CI type is 2."
528,<android.accounts.AccountManager: Account[] getAccounts()>,23,24,<android.accounts.AccountManager: Account[] getAccounts()>,<android.accounts.AccountManager: Account[] getAccounts()>,0,"{
    try {
        return mService.getAccounts(null, mContext.getOpPackageName());
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    try {
        return mService.getAccounts(null, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Lists all accounts of any type registered on the device.
 * Equivalent to getAccountsByType(null).
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>Clients of this method that have not been granted the
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission,
 * will only see those accounts managed by AbstractAccountAuthenticators whose
 * signature matches the client.
 *
 * @return An array of {@link Account}, one for each account.  Empty
 * (never null) if no accounts have been added.
 */
","/**
 * Lists all accounts of any type registered on the device.
 * Equivalent to getAccountsByType(null).
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>Clients of this method that have not been granted the
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission,
 * will only see those accounts managed by AbstractAccountAuthenticators whose
 * signature matches the client.
 *
 * @return An array of {@link Account}, one for each account.  Empty
 * (never null) if no accounts have been added.
 */
",-1,[@RequiresPermission(GET_ACCOUNTS)],"[@NonNull, @RequiresPermission(GET_ACCOUNTS)]",-1,-1,-1,-1,-1,-1,2,2,"The only difference between the two versions is the exception handling statement. In the early version, a new RuntimeException is thrown with the caught exception as its cause, and in the late version, the RemoteException is rethrown with rethrowFromSystemServer(). Therefore, the code change type is 2.","The late version could potentially throw a different exception than the early version, as RemoteException is wrapped in a RuntimeException in the early version, but rethrown directly in the late version. This could lead to a different exception handling flow in the client code, which constitutes a compatibility issue, so the CI type is 2."
529,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>",23,24,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>","<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>",0,"{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    return new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY);
}","{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    return new ContextImpl(null, mainThread, packageInfo, null, null, 0, null, null, Display.INVALID_DISPLAY);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is only a change in the parameter value from 'false' to '0' for the ContextImpl constructor. However, since 'false' is typically represented by '0' in Java (it's a boolean to int change), this doesn't translate to a functional change in behavior because the underlying code is most likely using these as flags where '0' and 'false' would equate to the same condition: 'not set' or 'disabled'. Therefore, the code change type is 4.","As this change is from a boolean to its equivalent integer representation in the context of flag setting, this would not cause a Compatibility Issue. It is likely that the internal implementation of 'ContextImpl' would handle both 'false' and '0' the same way. Therefore, there is no potential for the API to return different values or throw new exceptions due to this change alone. The CI type is 0."
530,<android.app.Instrumentation: UiAutomation getUiAutomation()>,23,24,<android.app.Instrumentation: UiAutomation getUiAutomation()>,<android.app.Instrumentation: UiAutomation getUiAutomation()>,0,"{
    if (mUiAutomationConnection != null) {
        if (mUiAutomation == null) {
            mUiAutomation = new UiAutomation(getTargetContext().getMainLooper(), mUiAutomationConnection);
            mUiAutomation.connect();
        }
        return mUiAutomation;
    }
    return null;
}","{
    return getUiAutomation(0);
}",1,"/**
 * Gets the {@link UiAutomation} instance.
 * <p>
 * <strong>Note:</strong> The APIs exposed via the returned {@link UiAutomation}
 * work across application boundaries while the APIs exposed by the instrumentation
 * do not. For example, {@link Instrumentation#sendPointerSync(MotionEvent)} will
 * not allow you to inject the event in an app different from the instrumentation
 * target, while {@link UiAutomation#injectInputEvent(android.view.InputEvent, boolean)}
 * will work regardless of the current application.
 * </p>
 * <p>
 * A typical test case should be using either the {@link UiAutomation} or
 * {@link Instrumentation} APIs. Using both APIs at the same time is not
 * a mistake by itself but a client has to be aware of the APIs limitations.
 * </p>
 * @return The UI automation instance.
 *
 * @see UiAutomation
 */
","/**
 * Gets the {@link UiAutomation} instance with no flags set.
 * <p>
 * <strong>Note:</strong> The APIs exposed via the returned {@link UiAutomation}
 * work across application boundaries while the APIs exposed by the instrumentation
 * do not. For example, {@link Instrumentation#sendPointerSync(MotionEvent)} will
 * not allow you to inject the event in an app different from the instrumentation
 * target, while {@link UiAutomation#injectInputEvent(android.view.InputEvent, boolean)}
 * will work regardless of the current application.
 * </p>
 * <p>
 * A typical test case should be using either the {@link UiAutomation} or
 * {@link Instrumentation} APIs. Using both APIs at the same time is not
 * a mistake by itself but a client has to be aware of the APIs limitations.
 * </p>
 * <p>
 * Equivalent to {@code getUiAutomation(0)}. If a {@link UiAutomation} exists with different
 * flags, the flags on that instance will be changed, and then it will be returned.
 * </p>
 * @return The UI automation instance.
 *
 * @see UiAutomation
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method body has been replaced with a call to getUiAutomation(int). Since this is a different method (even though it's an overloaded version), this is a change in the dependent API, so the change type is 5.","Considering that getUiAutomation(0) should be returning the same UiAutomation instance that was previously returned by the earlier method implementation, there should be no compatibility issue due to this change alone. Therefore, as long as getUiAutomation(int) is correctly implemented to maintain the same behavior, no CI is introduced. The CI type is 0."
531,"<android.app.admin.DevicePolicyManager: Bundle getApplicationRestrictions(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: Bundle getApplicationRestrictions(ComponentName,String)>","<android.app.admin.DevicePolicyManager: Bundle getApplicationRestrictions(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            return mService.getApplicationRestrictions(admin, packageName);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return null;
}","{
    throwIfParentInstance(""getApplicationRestrictions"");
    if (mService != null) {
        try {
            return mService.getApplicationRestrictions(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Called by a profile or device owner to get the application restrictions for a given target
 * application running in the profile.
 *
 * <p>The calling device admin must be a profile or device owner; if it is not, a security
 * exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to fetch restricted settings of.
 * @return {@link Bundle} of settings corresponding to what was set last time
 * {@link DevicePolicyManager#setApplicationRestrictions} was called, or an empty {@link Bundle}
 * if no restrictions have been set.
 */
","/**
 * Retrieves the application restrictions for a given target application running in the calling
 * user.
 * <p>
 * The caller must be a profile or device owner on that user, or the package allowed to manage
 * application restrictions via {@link #setApplicationRestrictionsManagingPackage}; otherwise a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if called by the application restrictions managing package.
 * @param packageName The name of the package to fetch restricted settings of.
 * @return {@link Bundle} of settings corresponding to what was set last time
 * {@link DevicePolicyManager#setApplicationRestrictions} was called, or an empty
 * {@link Bundle} if no restrictions have been set.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see {@link #setApplicationRestrictionsManagingPackage}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The early version contains a logging statement within the catch block, while the late version throws an exception with `e.rethrowFromSystemServer()`. There is also an additional method call `throwIfParentInstance(""getApplicationRestrictions"")` at the beginning of the method that is not present in the early version, so the changes are of types 2 and 4.","The modified exception handling (replacing Log.w with throw e.rethrowFromSystemServer()) indicates a CI of type 2 because it changes the way exceptions are propagated. Instead of logging and swallowing the RemoteException, it is now being thrown, potentially affecting the caller who has to handle this exception differently in the late version."
532,<android.content.pm.PackageInstaller.Session: void setStagingProgress(float)>,23,24,<android.content.pm.PackageInstaller.Session: void setStagingProgress(float)>,<android.content.pm.PackageInstaller.Session: void setStagingProgress(float)>,0,"{
    try {
        mSession.setClientProgress(progress);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        mSession.setClientProgress(progress);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Set current progress of staging this session. Valid values are
 * anywhere between 0 and 1.
 * <p>
 * Note that this progress may not directly correspond to the value
 * reported by {@link SessionCallback#onProgressChanged(int, float)}, as
 * the system may carve out a portion of the overall progress to
 * represent its own internal installation work.
 */
","/**
 * Set current progress of staging this session. Valid values are
 * anywhere between 0 and 1.
 * <p>
 * Note that this progress may not directly correspond to the value
 * reported by {@link SessionCallback#onProgressChanged(int, float)}, as
 * the system may carve out a portion of the overall progress to
 * represent its own internal installation work.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from rethrowAsRuntimeException() to rethrowFromSystemServer(), so the code change type is 2.","The change in exception handling could cause the method to potentially throw a different type of exception or handle the exception in a different manner, resulting in a different response when the API encounters an error. This means the Compatibility Issue is of type 2."
533,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",23,24,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",0,"{
    if (DBG)
        Log.d(TAG, ""start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    int channelConfig = BlockingAudioTrack.getChannelConfig(channelCount);
    synchronized (mStateLock) {
        if (channelConfig == 0) {
            Log.e(TAG, ""Unsupported number of channels :"" + channelCount);
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""stop() called before start(), returning."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mItem != null) {
            Log.e(TAG, ""Start called twice"");
            return TextToSpeech.ERROR;
        }
        SynthesisPlaybackQueueItem item = new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger);
        mAudioTrackHandler.enqueue(item);
        mItem = item;
    }
    return TextToSpeech.SUCCESS;
}","{
    if (DBG)
        Log.d(TAG, ""start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    if (audioFormat != AudioFormat.ENCODING_PCM_8BIT && audioFormat != AudioFormat.ENCODING_PCM_16BIT && audioFormat != AudioFormat.ENCODING_PCM_FLOAT) {
        Log.w(TAG, ""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT"");
    }
    mDispatcher.dispatchOnBeginSynthesis(sampleRateInHz, audioFormat, channelCount);
    int channelConfig = BlockingAudioTrack.getChannelConfig(channelCount);
    synchronized (mStateLock) {
        if (channelConfig == 0) {
            Log.e(TAG, ""Unsupported number of channels :"" + channelCount);
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""stop() called before start(), returning."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mItem != null) {
            Log.e(TAG, ""Start called twice"");
            return TextToSpeech.ERROR;
        }
        SynthesisPlaybackQueueItem item = new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger);
        mAudioTrackHandler.enqueue(item);
        mItem = item;
    }
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There is a new check for audioFormat introduced and a call to mDispatcher.dispatchOnBeginSynthesis() added before the synchronized block. Additionally, the logging level for audio format not supported has changed from error logging (Log.e) to warning logging (Log.w), constituting an 'Other statement changed' classification. Hence, the change types are 3 for control dependency changes and 4 for other statement changes.","The added check for audioFormat and the dispatch method call may result in new behaviors for different input parameters or states of the system. Since audio formats not supported by earlier versions would have been processed without specific checks, the late version could return a different value (an error if the format is not supported), leading to a CI type of 1. The logging level change from error to warning doesn't inherently affect the method's return value or exception throwing behavior; however, the new check and dispatch call influence the execution flow and potentially the return value."
535,<android.text.StaticLayout: int getLineDescent(int)>,23,24,<android.text.StaticLayout: int getLineDescent(int)>,<android.text.StaticLayout: int getLineDescent(int)>,0,"{
    int descent = mLines[mColumns * line + DESCENT];
    if (// -1 intended
    mMaximumVisibleLineCount > 0 && line >= mMaximumVisibleLineCount - 1 && line != mLineCount) {
        descent += getBottomPadding();
    }
    return descent;
}","{
    return mLines[mColumns * line + DESCENT];
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The early version of the implementation has additional statements to potentially alter the value of the 'descent' before returning it, whereas the late version directly returns a value from the 'mLines' array. The control dependency has been removed, with no subsequent adjustment or addition of the 'getBottomPadding()' in the late version, indicating that the return statement has changed.","This change may cause the late version of the API to return different values compared to the early version, especially when the condition inside the 'if' statement was met in the early version. Therefore, there is a potential Compatibility Issue due to different return values, and hence the CI type is 1."
536,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,23,24,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    removeTimeoutMilliseconds = o.removeTimeoutMilliseconds;
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
538,<android.app.ContextImpl: File[] getObbDirs()>,23,24,<android.app.ContextImpl: File[] getObbDirs()>,<android.app.ContextImpl: File[] getObbDirs()>,0,"{
    synchronized (mSync) {
        if (mExternalObbDirs == null) {
            mExternalObbDirs = Environment.buildExternalStorageAppObbDirs(getPackageName());
        }
        // Create dirs if needed
        return ensureDirsExistOrFilter(mExternalObbDirs);
    }
}","{
    synchronized (mSync) {
        if (mExternalObbDirs == null) {
            mExternalObbDirs = Environment.buildExternalStorageAppObbDirs(getPackageName());
        }
        // Create dirs if needed
        return ensureExternalDirsExistOrFilter(mExternalObbDirs);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed from calling ensureDirsExistOrFilter(mExternalObbDirs) to ensureExternalDirsExistOrFilter(mExternalObbDirs), and this reflects a change in the dependent API being called to ensure the existence of directories, so the change type is 1,5.","Since a different method is being called which might have a different implementation, the API could potentially return a different value; thus the CI type is 1."
539,<android.app.WallpaperManager: boolean hasResourceWallpaper(int)>,23,24,<android.app.WallpaperManager: boolean hasResourceWallpaper(int)>,<android.app.WallpaperManager: boolean hasResourceWallpaper(int)>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return false;
    }
    try {
        Resources resources = mContext.getResources();
        String name = ""res:"" + resources.getResourceName(resid);
        return sGlobals.mService.hasNamedWallpaper(name);
    } catch (RemoteException e) {
        return false;
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        Resources resources = mContext.getResources();
        String name = ""res:"" + resources.getResourceName(resid);
        return sGlobals.mService.hasNamedWallpaper(name);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return whether any users are currently set to use the wallpaper
 * with the given resource ID.  That is, their wallpaper has been
 * set through {@link #setResource(int)} with the same resource id.
 */
","/**
 * Return whether any users are currently set to use the wallpaper
 * with the given resource ID.  That is, their wallpaper has been
 * set through {@link #setResource(int)} with the same resource id.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"There is a change in the exception handling statement. In the early version, the method returns 'false' when `sGlobals.mService` is null or a `RemoteException` is caught. In the latest version, it throws a new RuntimeException with `DeadSystemException` when `sGlobals.mService` is null, and it throws a `rethrowFromSystemServer` when a `RemoteException` is caught, instead of returning 'false'. Therefore, the change type is 2.","The modification in the exception handling statements could lead to a potential different behavior in terms of the exceptions thrown by the method. In the early version, no exceptions are thrown under certain conditions, while in the late version, exceptions are explicitly thrown in these cases, leading to a different exception flow. This is a Compatibility Issue of type 2."
540,"<android.app.Notification.Builder: Builder setFullScreenIntent(PendingIntent,boolean)>",23,24,"<android.app.Notification.Builder: Builder setFullScreenIntent(PendingIntent,boolean)>","<android.app.Notification.Builder: Builder setFullScreenIntent(PendingIntent,boolean)>",0,"{
    mFullScreenIntent = intent;
    setFlag(FLAG_HIGH_PRIORITY, highPriority);
    return this;
}","{
    mN.fullScreenIntent = intent;
    setFlag(FLAG_HIGH_PRIORITY, highPriority);
    return this;
}",1,"/**
 * An intent to launch instead of posting the notification to the status bar.
 * Only for use with extremely high-priority notifications demanding the user's
 * <strong>immediate</strong> attention, such as an incoming phone call or
 * alarm clock that the user has explicitly set to a particular time.
 * If this facility is used for something else, please give the user an option
 * to turn it off and use a normal notification, as this can be extremely
 * disruptive.
 *
 * <p>
 * The system UI may choose to display a heads-up notification, instead of
 * launching this intent, while the user is using the device.
 * </p>
 *
 * @param intent The pending intent to launch.
 * @param highPriority Passing true will cause this notification to be sent
 * even if other notifications are suppressed.
 *
 * @see Notification#fullScreenIntent
 */
","/**
 * An intent to launch instead of posting the notification to the status bar.
 * Only for use with extremely high-priority notifications demanding the user's
 * <strong>immediate</strong> attention, such as an incoming phone call or
 * alarm clock that the user has explicitly set to a particular time.
 * If this facility is used for something else, please give the user an option
 * to turn it off and use a normal notification, as this can be extremely
 * disruptive.
 *
 * <p>
 * The system UI may choose to display a heads-up notification, instead of
 * launching this intent, while the user is using the device.
 * </p>
 *
 * @param intent The pending intent to launch.
 * @param highPriority Passing true will cause this notification to be sent
 * even if other notifications are suppressed.
 *
 * @see Notification#fullScreenIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The field being set has changed from mFullScreenIntent to mN.fullScreenIntent, which suggests that there's a change in the internal representation or structure of the object fields in the Notification Builder class. This type of change falls under the category of a dependent API changed.","While there is a change in how a field within the Notification builder is being referenced, this change in itself doesn't constitute a Compatibility Issue, as it doesn't affect the API's external behavior. Clients calling setFullScreenIntent() would not notice any change in how they use the method, nor the result that it produces. Therefore, there's no compatibility issue introduced by this change."
541,<android.view.WindowManager.LayoutParams: String toString()>,23,24,<android.view.WindowManager.LayoutParams: String toString()>,<android.view.WindowManager.LayoutParams: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (preferredRefreshRate != 0) {
        sb.append("" preferredRefreshRate="");
        sb.append(preferredRefreshRate);
    }
    if (preferredDisplayModeId != 0) {
        sb.append("" preferredDisplayMode="");
        sb.append(preferredDisplayModeId);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    if (surfaceInsets.left != 0 || surfaceInsets.top != 0 || surfaceInsets.right != 0 || surfaceInsets.bottom != 0 || hasManualSurfaceInsets) {
        sb.append("" surfaceInsets="").append(surfaceInsets);
        if (hasManualSurfaceInsets) {
            sb.append("" (manual)"");
        }
    }
    if (needsMenuKey != NEEDS_MENU_UNSET) {
        sb.append("" needsMenuKey="");
        sb.append(needsMenuKey);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (preferredRefreshRate != 0) {
        sb.append("" preferredRefreshRate="");
        sb.append(preferredRefreshRate);
    }
    if (preferredDisplayModeId != 0) {
        sb.append("" preferredDisplayMode="");
        sb.append(preferredDisplayModeId);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    if (surfaceInsets.left != 0 || surfaceInsets.top != 0 || surfaceInsets.right != 0 || surfaceInsets.bottom != 0 || hasManualSurfaceInsets || !preservePreviousSurfaceInsets) {
        sb.append("" surfaceInsets="").append(surfaceInsets);
        if (hasManualSurfaceInsets) {
            sb.append("" (manual)"");
        }
        if (!preservePreviousSurfaceInsets) {
            sb.append("" (!preservePreviousSurfaceInsets)"");
        }
    }
    if (needsMenuKey != NEEDS_MENU_UNSET) {
        sb.append("" needsMenuKey="");
        sb.append(needsMenuKey);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
542,<android.app.admin.DevicePolicyManager: boolean isMasterVolumeMuted(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean isMasterVolumeMuted(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean isMasterVolumeMuted(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.isMasterVolumeMuted(admin);
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed to get isMasterMute on device policy service"");
        }
    }
    return false;
}","{
    throwIfParentInstance(""isMasterVolumeMuted"");
    if (mService != null) {
        try {
            return mService.isMasterVolumeMuted(admin);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by profile or device owners to check whether the master volume mute is on or off.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return {@code true} if master volume is muted, {@code false} if it's not.
 */
","/**
 * Called by profile or device owners to check whether the master volume mute is on or off.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return {@code true} if master volume is muted, {@code false} if it's not.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is a new method call (throwIfParentInstance) at the beginning of the method and a change in exception handling from logging to rethrowing the exception, thus the change type is 2,4.","The new method call at the start of the method could potentially throw a new RuntimeException that wasn't thrown in the earlier version, constituting a potential Compatibility Issue of type 2. Additionally, the exception handling changed from logging to rethrowing RuntimeExceptions, which could cause the late version of the API to throw an exception where the earlier version would not have, also indicating a potential Compatibility Issue of type 2."
543,<android.content.pm.LauncherActivityInfo: Drawable getBadgedIcon(int)>,23,24,<android.content.pm.LauncherActivityInfo: Drawable getBadgedIcon(int)>,<android.content.pm.LauncherActivityInfo: Drawable getBadgedIcon(int)>,0,"{
    Drawable originalIcon = getOriginalIcon(density);
    if (originalIcon instanceof BitmapDrawable) {
        return mPm.getUserBadgedIcon(originalIcon, mUser);
    } else {
        Log.e(TAG, ""Unable to create badged icon for "" + mActivityInfo);
    }
    return originalIcon;
}","{
    Drawable originalIcon = getIcon(density);
    if (originalIcon instanceof BitmapDrawable) {
        return mPm.getUserBadgedIcon(originalIcon, mUser);
    } else {
        Log.e(TAG, ""Unable to create badged icon for "" + mActivityInfo);
    }
    return originalIcon;
}",1,"/**
 * Returns the activity icon with badging appropriate for the profile.
 * @param density Optional density for the icon, or 0 to use the default density. Use
 * {@link DisplayMetrics} for DPI values.
 * @see DisplayMetrics
 * @return A badged icon for the activity.
 */
","/**
 * Returns the activity icon with badging appropriate for the profile.
 * @param density Optional density for the icon, or 0 to use the default density. Use
 * {@link DisplayMetrics} for DPI values.
 * @see DisplayMetrics
 * @return A badged icon for the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method from which `originalIcon` is obtained has changed from `getOriginalIcon(density)` to `getIcon(density)`. This is a change in the dependent API being used, so the code change type is 4,5.","Despite the change in the dependent API, the API contract for `getBadgedIcon` doesn't seem to have changed because both are returning the same type of object (`Drawable`). There is no indication that this change would lead to a different return value or an exception being thrown as the handling of the `originalIcon` (checking instance type and logging) remains the same. Therefore, there is no compatibility issue, and the CI type is 0."
544,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,23,24,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,0,"{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.addLikelySubtags(locale).getScript();
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}","{
    return ((locale != null && !locale.equals(Locale.ROOT) && ULocale.forLocale(locale).isRightToLeft()) || // If forcing into RTL layout mode, return RTL as default
    SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false)) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}",1,"/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
","/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The early version includes a block of code handling `null` checks, comparison with `Locale.ROOT`, and a call to `ICU.addLikelySubtags(locale).getScript()` to determine the script subtag followed by conditional checks for certain script subtags. This logic is completely removed in the late version and replaced with a call to `ULocale.forLocale(locale).isRightToLeft()` which directly evaluates if the locale is right-to-left. Additionally, the nested if conditions have been replaced with a single return statement. Other parts of the control flow that determine the final layout direction value have been simplified and consolidated into a ternary operation. This includes the call to `SystemProperties.getBoolean()` that checks a system property for forced RTL layout. Since the logic for determining the layout direction is fundamentally altered and a dependent method `ULocale.forLocale(locale).isRightToLeft()` call is introduced, multiple change types apply. ","Given that the method used to determine the layout direction from a locale has changed, there are new potential behavior changes in the late version due to the newly introduced dependent API call and the change in the logic flow used to decide the layout direction. This can lead to the API potentially returning different values in different cases. Thus, a CI related to return values has been introduced."
545,<android.app.Notification.Builder: Builder setSubText(CharSequence)>,23,24,<android.app.Notification.Builder: Builder setSubText(CharSequence)>,<android.app.Notification.Builder: Builder setSubText(CharSequence)>,0,"{
    mSubText = safeCharSequence(text);
    return this;
}","{
    mN.extras.putCharSequence(EXTRA_SUB_TEXT, safeCharSequence(text));
    return this;
}",1,"/**
 * Set the third line of text in the platform notification template.
 * Don't use if you're also using {@link #setProgress(int, int, boolean)}; they occupy the
 * same location in the standard template.
 */
","/**
 * This provides some additional information that is displayed in the notification. No
 * guarantees are given where exactly it is displayed.
 *
 * <p>This information should only be provided if it provides an essential
 * benefit to the understanding of the notification. The more text you provide the
 * less readable it becomes. For example, an email client should only provide the account
 * name here if more than one email account has been added.</p>
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#N} this information is displayed in the
 * notification header area.
 *
 * On Android versions before {@link android.os.Build.VERSION_CODES#N}
 * this will be shown in the third line of text in the platform notification template.
 * You should not be using {@link #setProgress(int, int, boolean)} at the
 * same time on those versions; they occupy the same place.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation changed from directly setting a field value to putting a value into a Bundle with a specific key. Additionally, the mechanism to set the sub-text is now using a dependent API, 'putCharSequence', with a different approach. This is an ""Other statement changed"" since it is a member assignment change, and also a ""Dependent API changed"" as it now relies on 'putCharSequence'. So the code change type is 4,5.","Although the implementation detail to handle the sub-text was changed, clients using the 'setSubText' method should expect the same behavior – to set the sub-text of the notification. There is no change in the method signature, return type, nor the expected side-effects from the perspective of the client code. Therefore, there is no Compatibility Issue caused by this change; hence the CI type is 0."
546,"<android.app.admin.DevicePolicyManager: int enableSystemApp(ComponentName,Intent)>",23,24,"<android.app.admin.DevicePolicyManager: int enableSystemApp(ComponentName,Intent)>","<android.app.admin.DevicePolicyManager: int enableSystemApp(ComponentName,Intent)>",0,"{
    if (mService != null) {
        try {
            return mService.enableSystemAppWithIntent(admin, intent);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed to install packages matching filter: "" + intent);
        }
    }
    return 0;
}","{
    throwIfParentInstance(""enableSystemApp"");
    if (mService != null) {
        try {
            return mService.enableSystemAppWithIntent(admin, intent);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}",1,"/**
 * Called by profile or device owners to re-enable system apps by intent that were disabled
 * by default when the user was initialized.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param intent An intent matching the app(s) to be installed. All apps that resolve for this
 * intent will be re-enabled in the current profile.
 * @return int The number of activities that matched the intent and were installed.
 */
","/**
 * Called by profile or device owners to re-enable system apps by intent that were disabled by
 * default when the user was initialized.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param intent An intent matching the app(s) to be installed. All apps that resolve for this
 * intent will be re-enabled in the calling profile.
 * @return int The number of activities that matched the intent and were installed.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is an addition of new method call throwIfParentInstance(""enableSystemApp"") at the beginning and a change in the exception handling (replacement of log with throw statement). It includes the addition of throwIfParentInstance, which is not related to return or exception handling, so it is an 'Other statement changed' (4). For the exception handling, the logging is replaced by throwing, so it is an 'Exception handling statement changed' (2).","The added method call to throwIfParentInstance could potentially result in an exception being thrown before the method logic is executed, causing a new operational behavior and therefore a compatibility issue, which is represented by code 2. Additionally, by replacing a log statement with a throw statement within the catch block, the method behavior changes from absorbing an exception to propagating it. This also results in a 'Compatibility Issue caused by potential different exception handlings' (2)."
547,"<android.transition.ArcMotion: Path getPath(float,float,float,float)>",23,24,"<android.transition.ArcMotion: Path getPath(float,float,float,float)>","<android.transition.ArcMotion: Path getPath(float,float,float,float)>",0,"{
    // Here's a little ascii art to show how this is calculated:
    // c---------- b
    // \        / |
    // \     d  |
    // \  /   e
    // a----f
    // This diagram assumes that the horizontal distance is less than the vertical
    // distance between The start point (a) and end point (b).
    // d is the midpoint between a and b. c is the center point of the circle with
    // This path is formed by assuming that start and end points are in
    // an arc on a circle. The end point is centered in the circle vertically
    // and start is a point on the circle.
    // Triangles bfa and bde form similar right triangles. The control points
    // for the cubic Bezier arc path are the midpoints between a and e and e and b.
    Path path = new Path();
    path.moveTo(startX, startY);
    float ex;
    float ey;
    if (startY == endY) {
        ex = (startX + endX) / 2;
        ey = startY + mMinimumHorizontalTangent * Math.abs(endX - startX) / 2;
    } else if (startX == endX) {
        ex = startX + mMinimumVerticalTangent * Math.abs(endY - startY) / 2;
        ey = (startY + endY) / 2;
    } else {
        float deltaX = endX - startX;
        // Y is inverted compared to diagram above.
        float deltaY = startY - endY;
        // hypotenuse squared.
        float h2 = deltaX * deltaX + deltaY * deltaY;
        // Midpoint between start and end
        float dx = (startX + endX) / 2;
        float dy = (startY + endY) / 2;
        // Distance squared between end point and mid point is (1/2 hypotenuse)^2
        float midDist2 = h2 * 0.25f;
        float minimumArcDist2 = 0;
        if (Math.abs(deltaX) < Math.abs(deltaY)) {
            // Similar triangles bfa and bde mean that (ab/fb = eb/bd)
            // Therefore, eb = ab * bd / fb
            // ab = hypotenuse
            // bd = hypotenuse/2
            // fb = deltaY
            float eDistY = h2 / (2 * deltaY);
            ey = endY + eDistY;
            ex = endX;
            minimumArcDist2 = midDist2 * mMinimumVerticalTangent * mMinimumVerticalTangent;
        } else {
            // Same as above, but flip X & Y
            float eDistX = h2 / (2 * deltaX);
            ex = endX + eDistX;
            ey = endY;
            minimumArcDist2 = midDist2 * mMinimumHorizontalTangent * mMinimumHorizontalTangent;
        }
        float arcDistX = dx - ex;
        float arcDistY = dy - ey;
        float arcDist2 = arcDistX * arcDistX + arcDistY * arcDistY;
        float maximumArcDist2 = midDist2 * mMaximumTangent * mMaximumTangent;
        float newArcDistance2 = 0;
        if (arcDist2 < minimumArcDist2) {
            newArcDistance2 = minimumArcDist2;
        } else if (arcDist2 > maximumArcDist2) {
            newArcDistance2 = maximumArcDist2;
        }
        if (newArcDistance2 != 0) {
            float ratio2 = newArcDistance2 / arcDist2;
            float ratio = (float) Math.sqrt(ratio2);
            ex = dx + (ratio * (ex - dx));
            ey = dy + (ratio * (ey - dy));
        }
    }
    float controlX1 = (startX + ex) / 2;
    float controlY1 = (startY + ey) / 2;
    float controlX2 = (ex + endX) / 2;
    float controlY2 = (ey + endY) / 2;
    path.cubicTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
    return path;
}","{
    // Here's a little ascii art to show how this is calculated:
    // c---------- b
    // \        / |
    // \     d  |
    // \  /   e
    // a----f
    // This diagram assumes that the horizontal distance is less than the vertical
    // distance between The start point (a) and end point (b).
    // d is the midpoint between a and b. c is the center point of the circle with
    // This path is formed by assuming that start and end points are in
    // an arc on a circle. The end point is centered in the circle vertically
    // and start is a point on the circle.
    // Triangles bfa and bde form similar right triangles. The control points
    // for the cubic Bezier arc path are the midpoints between a and e and e and b.
    Path path = new Path();
    path.moveTo(startX, startY);
    float ex;
    float ey;
    if (startY == endY) {
        ex = (startX + endX) / 2;
        ey = startY + mMinimumHorizontalTangent * Math.abs(endX - startX) / 2;
    } else if (startX == endX) {
        ex = startX + mMinimumVerticalTangent * Math.abs(endY - startY) / 2;
        ey = (startY + endY) / 2;
    } else {
        float deltaX = endX - startX;
        float deltaY = endY - startY;
        // hypotenuse squared.
        float h2 = deltaX * deltaX + deltaY * deltaY;
        // Midpoint between start and end
        float dx = (startX + endX) / 2;
        float dy = (startY + endY) / 2;
        // Distance squared between end point and mid point is (1/2 hypotenuse)^2
        float midDist2 = h2 * 0.25f;
        float minimumArcDist2 = 0;
        boolean isQuadrant1Or3 = (deltaX * deltaY) > 0;
        if ((Math.abs(deltaX) < Math.abs(deltaY))) {
            // Similar triangles bfa and bde mean that (ab/fb = eb/bd)
            // Therefore, eb = ab * bd / fb
            // ab = hypotenuse
            // bd = hypotenuse/2
            // fb = deltaY
            float eDistY = h2 / (2 * deltaY);
            if (isQuadrant1Or3) {
                ey = startY + eDistY;
                ex = startX;
            } else {
                ey = endY - eDistY;
                ex = endX;
            }
            minimumArcDist2 = midDist2 * mMinimumVerticalTangent * mMinimumVerticalTangent;
        } else {
            // Same as above, but flip X & Y
            float eDistX = h2 / (2 * deltaX);
            if (isQuadrant1Or3) {
                ex = endX - eDistX;
                ey = endY;
            } else {
                ex = startX + eDistX;
                ey = startY;
            }
            minimumArcDist2 = midDist2 * mMinimumHorizontalTangent * mMinimumHorizontalTangent;
        }
        float arcDistX = dx - ex;
        float arcDistY = dy - ey;
        float arcDist2 = arcDistX * arcDistX + arcDistY * arcDistY;
        float maximumArcDist2 = midDist2 * mMaximumTangent * mMaximumTangent;
        float newArcDistance2 = 0;
        if (arcDist2 < minimumArcDist2) {
            newArcDistance2 = minimumArcDist2;
        } else if (arcDist2 > maximumArcDist2) {
            newArcDistance2 = maximumArcDist2;
        }
        if (newArcDistance2 != 0) {
            float ratio2 = newArcDistance2 / arcDist2;
            float ratio = (float) Math.sqrt(ratio2);
            ex = dx + (ratio * (ex - dx));
            ey = dy + (ratio * (ey - dy));
        }
    }
    float controlX1 = (startX + ex) / 2;
    float controlY1 = (startY + ey) / 2;
    float controlX2 = (ex + endX) / 2;
    float controlY2 = (ey + endY) / 2;
    path.cubicTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
    return path;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
549,<android.app.UiModeManager: int getCurrentModeType()>,23,24,<android.app.UiModeManager: int getCurrentModeType()>,<android.app.UiModeManager: int getCurrentModeType()>,0,"{
    if (mService != null) {
        try {
            return mService.getCurrentModeType();
        } catch (RemoteException e) {
            Log.e(TAG, ""getCurrentModeType: RemoteException"", e);
        }
    }
    return Configuration.UI_MODE_TYPE_NORMAL;
}","{
    if (mService != null) {
        try {
            return mService.getCurrentModeType();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return Configuration.UI_MODE_TYPE_NORMAL;
}",1,"/**
 * Return the current running mode type.  May be one of
 * {@link Configuration#UI_MODE_TYPE_NORMAL Configuration.UI_MODE_TYPE_NORMAL},
 * {@link Configuration#UI_MODE_TYPE_DESK Configuration.UI_MODE_TYPE_DESK},
 * {@link Configuration#UI_MODE_TYPE_CAR Configuration.UI_MODE_TYPE_CAR},
 * {@link Configuration#UI_MODE_TYPE_TELEVISION Configuration.UI_MODE_TYPE_TELEVISION},
 * {@link Configuration#UI_MODE_TYPE_APPLIANCE Configuration.UI_MODE_TYPE_APPLIANCE}, or
 * {@link Configuration#UI_MODE_TYPE_WATCH Configuration.UI_MODE_TYPE_WATCH}.
 */
","/**
 * Return the current running mode type.  May be one of
 * {@link Configuration#UI_MODE_TYPE_NORMAL Configuration.UI_MODE_TYPE_NORMAL},
 * {@link Configuration#UI_MODE_TYPE_DESK Configuration.UI_MODE_TYPE_DESK},
 * {@link Configuration#UI_MODE_TYPE_CAR Configuration.UI_MODE_TYPE_CAR},
 * {@link Configuration#UI_MODE_TYPE_TELEVISION Configuration.UI_MODE_TYPE_TELEVISION},
 * {@link Configuration#UI_MODE_TYPE_APPLIANCE Configuration.UI_MODE_TYPE_APPLIANCE}, or
 * {@link Configuration#UI_MODE_TYPE_WATCH Configuration.UI_MODE_TYPE_WATCH}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed with the catch block now throwing an exception instead of logging it, so the code change type is 2.","Since the RemoteException previously logged an exception and now throws one, this change can affect the behavior of the API by potentially throwing a different exception than before. Therefore, the CI type is 2."
550,<android.view.ViewOverlay.OverlayViewGroup: void add(Drawable)>,23,24,<android.view.ViewOverlay.OverlayViewGroup: void add(Drawable)>,<android.view.ViewOverlay.OverlayViewGroup: void add(Drawable)>,0,"{
    if (mDrawables == null) {
        mDrawables = new ArrayList<Drawable>();
    }
    if (!mDrawables.contains(drawable)) {
        // Make each drawable unique in the overlay; can't add it more than once
        mDrawables.add(drawable);
        invalidate(drawable.getBounds());
        drawable.setCallback(this);
    }
}","{
    if (drawable == null) {
        throw new IllegalArgumentException(""drawable must be non-null"");
    }
    if (mDrawables == null) {
        mDrawables = new ArrayList<>();
    }
    if (!mDrawables.contains(drawable)) {
        // Make each drawable unique in the overlay; can't add it more than once
        mDrawables.add(drawable);
        invalidate(drawable.getBounds());
        drawable.setCallback(this);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","There is an introduction of a new null check and exception throwing (IllegalArgumentException if 'drawable' is null), along with an Other statement changed (modification of the generic ArrayList declaration) and the Control dependency changed (introduction of a new 'if' control structure at the beginning of the method). The change type is 2,3,4.","The additional null check on 'drawable' results in a new exception that can be thrown, which was not possible in the early version. Additionally, the change also affects the behavior of what is added to 'mDrawables'. If 'drawable' is null, the late version will throw an exception and prevent adding null to the list, unlike the early version, which would have allowed it (null check was not present). This is a potential different return behavior (since the method no longer progresses to adding null elements and setting callbacks), as well as a different exception handling. Thus, the CI type is 1,2."
551,<android.view.WindowManager.LayoutParams: CharSequence getTitle()>,23,24,<android.view.WindowManager.LayoutParams: CharSequence getTitle()>,<android.view.WindowManager.LayoutParams: CharSequence getTitle()>,0,"{
    return mTitle;
}","{
    return mTitle != null ? mTitle : """";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has been changed from returning 'mTitle' directly to returning 'mTitle' or an empty string if 'mTitle' is null, so the code change type is 1.","The change in return statement logic means the method could potentially return a different value (empty string instead of null) compared to the early version, which is why the CI type is 1."
553,<android.content.pm.PackageInstaller.Session: InputStream openRead(String)>,23,24,<android.content.pm.PackageInstaller.Session: InputStream openRead(String)>,<android.content.pm.PackageInstaller.Session: InputStream openRead(String)>,0,"{
    try {
        final ParcelFileDescriptor pfd = mSession.openRead(name);
        return new ParcelFileDescriptor.AutoCloseInputStream(pfd);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        final ParcelFileDescriptor pfd = mSession.openRead(name);
        return new ParcelFileDescriptor.AutoCloseInputStream(pfd);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Open a stream to read an APK file from the session.
 * <p>
 * This is only valid for names which have been previously written
 * through {@link #openWrite(String, long, long)} as part of this
 * session. For example, this stream may be used to calculate a
 * {@link MessageDigest} of a written APK before committing.
 *
 * @throws SecurityException if called after the session has been
 * committed or abandoned.
 */
","/**
 * Open a stream to read an APK file from the session.
 * <p>
 * This is only valid for names which have been previously written
 * through {@link #openWrite(String, long, long)} as part of this
 * session. For example, this stream may be used to calculate a
 * {@link MessageDigest} of a written APK before committing.
 *
 * @throws SecurityException if called after the session has been
 * committed or abandoned.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The way how the RemoteException is handled has changed, as it now uses the `rethrowFromSystemServer()` method instead of `rethrowAsRuntimeException()`, resulting in a different type of exception possibly being thrown. This change is therefore categorized as 2.","Since the exception handling logic has changed, the API potentially throws a different exception in the new version. Thus, this is a potential Compatibility Issue because of different exception handling and the CI type is 2."
554,<android.widget.PopupWindow: void update()>,23,24,<android.widget.PopupWindow: void update()>,<android.widget.PopupWindow: void update()>,0,"{
    if (!isShowing() || mContentView == null) {
        return;
    }
    final WindowManager.LayoutParams p = (WindowManager.LayoutParams) mDecorView.getLayoutParams();
    boolean update = false;
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mDecorView, p);
    }
}","{
    if (!isShowing() || mContentView == null) {
        return;
    }
    final WindowManager.LayoutParams p = (WindowManager.LayoutParams) mDecorView.getLayoutParams();
    boolean update = false;
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    final int newGravity = computeGravity();
    if (newGravity != p.gravity) {
        p.gravity = newGravity;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mDecorView, p);
    }
}",1,"/**
 * Updates the state of the popup window, if it is currently being displayed,
 * from the currently set state.
 * <p>
 * This includes:
 * <ul>
 * <li>{@link #setClippingEnabled(boolean)}</li>
 * <li>{@link #setFocusable(boolean)}</li>
 * <li>{@link #setIgnoreCheekPress()}</li>
 * <li>{@link #setInputMethodMode(int)}</li>
 * <li>{@link #setTouchable(boolean)}</li>
 * <li>{@link #setAnimationStyle(int)}</li>
 * </ul>
 */
","/**
 * Updates the state of the popup window, if it is currently being displayed,
 * from the currently set state.
 * <p>
 * This includes:
 * <ul>
 * <li>{@link #setClippingEnabled(boolean)}</li>
 * <li>{@link #setFocusable(boolean)}</li>
 * <li>{@link #setIgnoreCheekPress()}</li>
 * <li>{@link #setInputMethodMode(int)}</li>
 * <li>{@link #setTouchable(boolean)}</li>
 * <li>{@link #setAnimationStyle(int)}</li>
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is an addition of a block that computes a value 'newGravity' and sets it on 'p.gravity' and a new variable declaration, so the change type is 3 for the control dependency change and 4 for other statement changes.","There's no Compatibility Issue because these changes don't affect the return value or the exception handling of the method; the method still does not return any value nor throw different exceptions. The new code simply alters the internal state, provided it goes through the same control flow, and performs additional updates on an internal data structure which would not cause any existing code relying on previous API behavior to fail or behave differently."
556,"<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>",23,24,"<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>",0,"{
    NetworkTemplate template = createTemplate(networkType, subscriberId);
    if (template == null) {
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startSummaryEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startSummaryEnumeration();
    return result;
}",1,"/**
 * Query network usage statistics summaries. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over time, hence all buckets will have the same start and
 * end timestamps. Not aggregated over state or uid. This means buckets' start and end
 * timestamps are going to be the same as the 'startTime' and 'endTime' parameters, state and
 * uid are going to vary.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over time, hence all buckets will have the same start and
 * end timestamps. Not aggregated over state or uid. This means buckets' start and end
 * timestamps are going to be the same as the 'startTime' and 'endTime' parameters.
 * State and uid are going to vary, and tag is going to be the same.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","0,2","An exception handling for IllegalArgumentException has been introduced with a try-catch block around the creation of `NetworkTemplate`, and an if control structure linked to debug logging was added. Also, the dependent API `createTemplate` might have changed its behavior since it’s now surrounded by try-catch. So the changes are 2,3,5.","Though there's a new catch block introduced which handles IllegalArgumentException by returning null, this will only affect the output if the exception occurs. If the exception doesn't occur, the method behaves as in the previous version. So, potentially there's no change in returned values if the exception is not thrown. However, since a new exception is being caught and logged instead of propagated, there is a Compatibility Issue due to potential different exception handling; therefore, type 2 is applicable."
557,<android.view.ViewGroup: boolean showContextMenuForChild(View)>,23,24,<android.view.ViewGroup: boolean showContextMenuForChild(View)>,<android.view.ViewGroup: boolean showContextMenuForChild(View)>,0,"{
    return mParent != null && mParent.showContextMenuForChild(originalView);
}","{
    if (isShowingContextMenuWithCoords()) {
        // with coordinates recurse up.
        return false;
    }
    return mParent != null && mParent.showContextMenuForChild(originalView);
}",1,"/**
 * {@inheritDoc}
 */
",,-1,,[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a new control dependency and a new statement (return false;) introduced under the 'if' clause in the late version, leading to classifications 3 (Control dependency change) and 4 (Other statement changed).","Although there is a new control statement and a related 'return false;' statement introduced in the late version, it does not result in a Compatibility Issue. The added condition is a preliminary check before reaching the same logical decision point as the early version: if the preliminary check (`isShowingContextMenuWithCoords()`) fails, the subsequent logic is identical to that of the early version. Therefore, there is no potential for different return values or exceptions between the versions in the context of functionality provided by this API."
558,<android.app.DownloadManager.CursorTranslator: String getString(int)>,23,24,<android.app.DownloadManager.CursorTranslator: String getString(int)>,<android.app.DownloadManager.CursorTranslator: String getString(int)>,0,"{
    return (getColumnName(columnIndex).equals(COLUMN_LOCAL_URI)) ? getLocalUri() : super.getString(columnIndex);
}","{
    final String columnName = getColumnName(columnIndex);
    switch(columnName) {
        case COLUMN_LOCAL_URI:
            return getLocalUri();
        case COLUMN_LOCAL_FILENAME:
            if (!mAccessFilename) {
                throw new SecurityException(""COLUMN_LOCAL_FILENAME is deprecated;"" + "" use ContentResolver.openFileDescriptor() instead"");
            }
        default:
            return super.getString(columnIndex);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The method changes from a simple conditional statement to a `switch` with additional case handling. A new case condition (COLUMN_LOCAL_FILENAME) is added that throws a new `SecurityException`. There's also an added `default` return statement, which replaces the original single line return. These changes reflect modifications of return statements, control dependency changes, and other statement changes.","The changes could lead to both different return values and different exceptions being thrown. The new case can throw a `SecurityException` which did not exist previously, and the control flow has changed potentially leading to different return values, hence the CI type is 1,2."
559,<android.net.ConnectivityManager: Network getActiveNetwork()>,23,24,<android.net.ConnectivityManager: Network getActiveNetwork()>,<android.net.ConnectivityManager: Network getActiveNetwork()>,0,"{
    try {
        return mService.getActiveNetwork();
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return mService.getActiveNetwork();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a {@link Network} object corresponding to the currently active
 * default data network.  In the event that the current active default data
 * network disconnects, the returned {@code Network} object will no longer
 * be usable.  This will return {@code null} when there is no default
 * network.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return a {@link Network} object for the current default network or
 * {@code null} if no default network is currently active
 */
","/**
 * Returns a {@link Network} object corresponding to the currently active
 * default data network.  In the event that the current active default data
 * network disconnects, the returned {@code Network} object will no longer
 * be usable.  This will return {@code null} when there is no default
 * network.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return a {@link Network} object for the current default network or
 * {@code null} if no default network is currently active
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from catching and returning null to rethrowing the exception, so the code change type is 2.","Since the exception handling is modified from returning null to throwing an exception, it represents a Compatibility Issue caused due to potential different exception handlings. Thus, the CI type is 2."
561,"<android.net.LocalSocketImpl: void setOption(int,Object)>",23,24,"<android.net.LocalSocketImpl: void setOption(int,Object)>","<android.net.LocalSocketImpl: void setOption(int,Object)>",0,"{
    /*
         * Boolean.FALSE is used to disable some options, so it
         * is important to distinguish between FALSE and unset.
         * We define it here that -1 is unset, 0 is FALSE, and 1
         * is TRUE.
         */
    int boolValue = -1;
    int intValue = 0;
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    if (value instanceof Integer) {
        intValue = (Integer) value;
    } else if (value instanceof Boolean) {
        boolValue = ((Boolean) value) ? 1 : 0;
    } else {
        throw new IOException(""bad value: "" + value);
    }
    setOption_native(fd, optID, boolValue, intValue);
}","{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    /*
         * Boolean.FALSE is used to disable some options, so it
         * is important to distinguish between FALSE and unset.
         * We define it here that -1 is unset, 0 is FALSE, and 1
         * is TRUE.
         */
    int boolValue = -1;
    int intValue = 0;
    if (value instanceof Integer) {
        intValue = (Integer) value;
    } else if (value instanceof Boolean) {
        boolValue = ((Boolean) value) ? 1 : 0;
    } else {
        throw new IOException(""bad value: "" + value);
    }
    try {
        switch(optID) {
            case SocketOptions.SO_LINGER:
                StructLinger linger = new StructLinger(boolValue, intValue);
                Os.setsockoptLinger(fd, OsConstants.SOL_SOCKET, OsConstants.SO_LINGER, linger);
                break;
            case SocketOptions.SO_TIMEOUT:
                /*
                     * SO_TIMEOUT from the core library gets converted to
                     * SO_SNDTIMEO, but the option is supposed to set both
                     * send and receive timeouts. Note: The incoming timeout
                     * value is in milliseconds.
                     */
                StructTimeval timeval = StructTimeval.fromMillis(intValue);
                Os.setsockoptTimeval(fd, OsConstants.SOL_SOCKET, OsConstants.SO_SNDTIMEO, timeval);
                break;
            case SocketOptions.SO_RCVBUF:
            case SocketOptions.SO_SNDBUF:
            case SocketOptions.SO_REUSEADDR:
                int osOpt = javaSoToOsOpt(optID);
                Os.setsockoptInt(fd, OsConstants.SOL_SOCKET, osOpt, intValue);
                break;
            case SocketOptions.TCP_NODELAY:
                Os.setsockoptInt(fd, OsConstants.IPPROTO_TCP, OsConstants.TCP_NODELAY, intValue);
                break;
            default:
                throw new IOException(""Unknown option: "" + optID);
        }
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5","1,2",The changes in this case include:,"- A call to new methods from class `Os` that were not present in the previous version, which represents a Dependent API changed."
562,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,23,24,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,0,"{
    if (VDBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method call within the try block has been changed from passing multiple details of the service, characteristic, and descriptor in the early version to passing fewer arguments in the late version (specifically the `device.getAddress()`, `service.getType()`, `service.getInstanceId()`, `new ParcelUuid(service.getUuid())`, `characteristic.getInstanceId()`, and `new ParcelUuid(characteristic.getUuid())` arguments have been removed). In addition to the return statement change, this constitutes a change in the dependent API because the signature of `mService.readDescriptor()` being called has changed, leading also to the category of other changes due to these modifications. So, the code change types are 1,4,5.","Due to the change in the number of arguments passed to `mService.readDescriptor()`, the method might behave differently, potentially leading to different return values or handling by the service. Hence, a Compatibility Issue could arise with a returned value difference, and the CI type is 1."
563,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getCurrentInputMethodSubtype()>,23,24,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getCurrentInputMethodSubtype()>,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getCurrentInputMethodSubtype()>,0,"{
    synchronized (mH) {
        try {
            return mService.getCurrentInputMethodSubtype();
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
            return null;
        }
    }
}","{
    synchronized (mH) {
        try {
            return mService.getCurrentInputMethodSubtype();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Returns the current input method subtype. This subtype is one of the subtypes in
 * the current input method. This method returns null when the current input method doesn't
 * have any input method subtype.
 */
","/**
 * Returns the current input method subtype. This subtype is one of the subtypes in
 * the current input method. This method returns null when the current input method doesn't
 * have any input method subtype.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from logging the exception and returning null to throwing the exception (throw e.rethrowFromSystemServer()), so the code change type is 2.","The change in exception handling will lead to a different behavior. In the early version, any RemoteException would be caught and logged, and the method would return null, while in the late version the same exception causes an exception to be thrown. Hence, the CI type is 2."
565,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNonLetter(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNonLetter(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNonLetter(ComponentName)>,0,"{
    return getPasswordMinimumNonLetter(admin, UserHandle.myUserId());
}","{
    return getPasswordMinimumNonLetter(admin, myUserId());
}",1,"/**
 * Retrieve the current number of non-letter characters required in the
 * password for all admins of this user and its profiles or a particular one.
 * This is the same value as set by
 * {#link {@link #setPasswordMinimumNonLetter(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of letters required in the password.
 */
","/**
 * Retrieve the current number of non-letter characters required in the password
 * for a particular admin or all admins that set retrictions on this user
 * and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 * This is the same value as set by
 * {@link #setPasswordMinimumNonLetter(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of letters required in the password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from calling getPasswordMinimumNonLetter with UserHandle.myUserId() to calling it with myUserId() directly. This indicates there is an internal change, possibly due to a change in the structure or scope of available methods. Therefore, the change type is a Dependent API changed (5).","This change in method call does not necessarily indicate a change in behavior or return value because the final output value is determined by the underlying implementation of getPasswordMinimumNonLetter, which we cannot see directly here. Therefore, based on the provided information, no Compatibility Issue has been indicated (0)."
566,"<android.widget.TextView: boolean onKeyMultiple(int,int,KeyEvent)>",23,24,"<android.widget.TextView: boolean onKeyMultiple(int,int,KeyEvent)>","<android.widget.TextView: boolean onKeyMultiple(int,int,KeyEvent)>",0,"{
    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
    int which = doKeyDown(keyCode, down, event);
    if (which == 0) {
        // Go through default dispatching.
        return super.onKeyMultiple(keyCode, repeatCount, event);
    }
    if (which == -1) {
        // Consumed the whole thing.
        return true;
    }
    repeatCount--;
    // We are going to dispatch the remaining events to either the input
    // or movement method.  To do this, we will just send a repeated stream
    // of down and up events until we have done the complete repeatCount.
    // It would be nice if those interfaces had an onKeyMultiple() method,
    // but adding that is a more complicated change.
    KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
    if (which == 1) {
        // mEditor and mEditor.mInput are not null from doKeyDown
        mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mEditor.mKeyListener.onKeyDown(this, (Editable) mText, keyCode, down);
            mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        }
        hideErrorIfUnchanged();
    } else if (which == 2) {
        // mMovement is not null from doKeyDown
        mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mMovement.onKeyDown(this, (Spannable) mText, keyCode, down);
            mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        }
    }
    return true;
}","{
    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
    final int which = doKeyDown(keyCode, down, event);
    if (which == KEY_EVENT_NOT_HANDLED) {
        // Go through default dispatching.
        return super.onKeyMultiple(keyCode, repeatCount, event);
    }
    if (which == KEY_EVENT_HANDLED) {
        // Consumed the whole thing.
        return true;
    }
    repeatCount--;
    // We are going to dispatch the remaining events to either the input
    // or movement method.  To do this, we will just send a repeated stream
    // of down and up events until we have done the complete repeatCount.
    // It would be nice if those interfaces had an onKeyMultiple() method,
    // but adding that is a more complicated change.
    KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
    if (which == KEY_DOWN_HANDLED_BY_KEY_LISTENER) {
        // mEditor and mEditor.mInput are not null from doKeyDown
        mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mEditor.mKeyListener.onKeyDown(this, (Editable) mText, keyCode, down);
            mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        }
        hideErrorIfUnchanged();
    } else if (which == KEY_DOWN_HANDLED_BY_MOVEMENT_METHOD) {
        // mMovement is not null from doKeyDown
        mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mMovement.onKeyDown(this, (Spannable) mText, keyCode, down);
            mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation changes from using literal integer values (0, -1, 1, 2) to named constants (KEY_EVENT_NOT_HANDLED, KEY_EVENT_HANDLED, KEY_DOWN_HANDLED_BY_KEY_LISTENER, KEY_DOWN_HANDLED_BY_MOVEMENT_METHOD), without behavior modification. This is classified under two categories: 4 for changes that do not affect the control flow, return statements or exception handling; and 5 for changes that indicate the values used might actually be defined in a dependent API (constants).","There is no Compatibility Issue detected because the refactor from literals to constants does not affect the behavior of the method. The method should still return the same values under the same conditions regardless of using literal integers or named constants. Hence, the method's behavior remains consistent between versions."
567,<android.app.admin.DevicePolicyManager: List<byte[]> getInstalledCaCerts(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: List<byte[]> getInstalledCaCerts(ComponentName)>,<android.app.admin.DevicePolicyManager: List<byte[]> getInstalledCaCerts(ComponentName)>,0,"{
    List<byte[]> certs = new ArrayList<byte[]>();
    if (mService != null) {
        try {
            mService.enforceCanManageCaCerts(admin);
            final TrustedCertificateStore certStore = new TrustedCertificateStore();
            for (String alias : certStore.userAliases()) {
                try {
                    certs.add(certStore.getCertificate(alias).getEncoded());
                } catch (CertificateException ce) {
                    Log.w(TAG, ""Could not encode certificate: "" + alias, ce);
                }
            }
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed talking with device policy service"", re);
        }
    }
    return certs;
}","{
    List<byte[]> certs = new ArrayList<byte[]>();
    throwIfParentInstance(""getInstalledCaCerts"");
    if (mService != null) {
        try {
            mService.enforceCanManageCaCerts(admin);
            final TrustedCertificateStore certStore = new TrustedCertificateStore();
            for (String alias : certStore.userAliases()) {
                try {
                    certs.add(certStore.getCertificate(alias).getEncoded());
                } catch (CertificateException ce) {
                    Log.w(TAG, ""Could not encode certificate: "" + alias, ce);
                }
            }
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return certs;
}",1,"/**
 * Returns all CA certificates that are currently trusted, excluding system CA certificates.
 * If a user has installed any certificates by other means than device policy these will be
 * included too.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @return a List of byte[] arrays, each encoding one user CA certificate.
 */
","/**
 * Returns all CA certificates that are currently trusted, excluding system CA certificates.
 * If a user has installed any certificates by other means than device policy these will be
 * included too.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @return a List of byte[] arrays, each encoding one user CA certificate.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The change between the two versions involves adding a new exception throw at the beginning of the method with the statement throwIfParentInstance(""getInstalledCaCerts"") and altering the RemoteException catch block to throw the exception instead of logging it. This constitutes a change to other statements as well as to exception handling statements, hence the code change types are 2,4.","These changes in exception handling could lead to different behavior when exceptions occur. In the early version, certain exceptions are logged and execution continues, potentially returning a list of certificates. In the late version, a new check might throw an exception before the method proceeds, and RemoteExceptions are now thrown instead of being logged. These changes can cause the late version of the API to throw an exception where the early version would not, leading to different control flow and possible failure in client code that is not expecting an exception at that point. Thus, the CI type is 2."
569,<android.os.Environment: File getDataDirectory()>,23,24,<android.os.Environment: File getDataDirectory()>,<android.os.Environment: File getDataDirectory()>,0,"{
    return DATA_DIRECTORY;
}","{
    return DIR_ANDROID_DATA;
}",1,"/**
 * Return the user data directory.
 */
","/**
 * Return the user data directory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed to return a different constant (from DATA_DIRECTORY to DIR_ANDROID_DATA), so the code change type is 1,5.","The two constants may represent different file paths, so this change may lead to the API returning a different value, which constitutes a Compatibility Issue of type 1."
570,<android.app.admin.DevicePolicyManager: List<String> getPermittedInputMethods(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: List<String> getPermittedInputMethods(ComponentName)>,<android.app.admin.DevicePolicyManager: List<String> getPermittedInputMethods(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPermittedInputMethods(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return null;
}","{
    throwIfParentInstance(""getPermittedInputMethods"");
    if (mService != null) {
        try {
            return mService.getPermittedInputMethods(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Returns the list of permitted input methods set by this device or profile owner.
 *
 * <p>An empty list means no input methods except system input methods are allowed.
 * Null means all input methods are allowed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return List of input method package names.
 */
","/**
 * Returns the list of permitted input methods set by this device or profile owner.
 * <p>
 * An empty list means no input methods except system input methods are allowed. Null means all
 * input methods are allowed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return List of input method package names.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The introduction of ""throwIfParentInstance"" and change in exception handling (from logging the exception to throwing it) are notable. Additionally, there's a check for the mService which hasn't changed, but due to the new method ""throwIfParentInstance"" being introduced and the change in exception handling, the change types are 2,3,4,5.","The introduction of ""throwIfParentInstance"" can lead to a new exception being thrown which wasn't there before, which could lead to CI type 2. Moreover, the change from catching and logging the RemoteException to rethrowing it could lead to different exception handling for callers, also leading to CI type 2. Since ""throwIfParentInstance"" could potentially prevent the method from returning null (by throwing an exception before reaching the return statement) or alter the flow before getService() is called, there also could be a CI type 1."
571,<android.bluetooth.BluetoothAdapter: int getState()>,23,24,<android.bluetooth.BluetoothAdapter: int getState()>,<android.bluetooth.BluetoothAdapter: int getState()>,0,"{
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + state);
                // consider all internal states as OFF
                if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
                    if (VDBG)
                        Log.d(TAG, ""Consider internal state as OFF"");
                    state = BluetoothAdapter.STATE_OFF;
                }
                return state;
            }
        // TODO(BT) there might be a small gap during STATE_TURNING_ON that
        // mService is null, handle that case
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return STATE_OFF;
}","{
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    // Consider all internal states as OFF
    if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        if (VDBG)
            Log.d(TAG, ""Consider internal state as OFF"");
        state = BluetoothAdapter.STATE_OFF;
    }
    if (VDBG)
        Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + state);
    return state;
}",1,"/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 */
","/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 */
",-1,"[@RequiresPermission(Manifest.permission.BLUETOOTH), @AdapterState]","[@RequiresPermission(Manifest.permission.BLUETOOTH), @AdapterState]",-1,-1,-1,-1,-1,-1,"1,3,4",1,"There is a control dependency change with different synchronization mechanisms (from `synchronized` block to using a `ReadWriteLock`), a change in the location of the logging and returning the state (moved out of the synchronized block to after the finally block), and the way the default state is handled (moved to be set at the start of the method). So, the change type is 1,3,4.","The state variable is now initialized at the beginning of the method, and the synchronization mechanism change could lead to different timing and exposure to concurrent modifications, which ultimately could result in returning different state values. Therefore, the CI type is 1."
572,"<android.widget.ScrollView: void onMeasure(int,int)>",23,24,"<android.widget.ScrollView: void onMeasure(int,int)>","<android.widget.ScrollView: void onMeasure(int,int)>",0,"{
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    if (!mFillViewport) {
        return;
    }
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.UNSPECIFIED) {
        return;
    }
    if (getChildCount() > 0) {
        final View child = getChildAt(0);
        final int height = getMeasuredHeight();
        if (child.getMeasuredHeight() < height) {
            final int widthPadding;
            final int heightPadding;
            final FrameLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
            if (targetSdkVersion >= VERSION_CODES.M) {
                widthPadding = mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin;
                heightPadding = mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin;
            } else {
                widthPadding = mPaddingLeft + mPaddingRight;
                heightPadding = mPaddingTop + mPaddingBottom;
            }
            final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, widthPadding, lp.width);
            final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height - heightPadding, MeasureSpec.EXACTLY);
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
    }
}","{
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    if (!mFillViewport) {
        return;
    }
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.UNSPECIFIED) {
        return;
    }
    if (getChildCount() > 0) {
        final View child = getChildAt(0);
        final int widthPadding;
        final int heightPadding;
        final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
        final FrameLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams();
        if (targetSdkVersion >= VERSION_CODES.M) {
            widthPadding = mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin;
            heightPadding = mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin;
        } else {
            widthPadding = mPaddingLeft + mPaddingRight;
            heightPadding = mPaddingTop + mPaddingBottom;
        }
        final int desiredHeight = getMeasuredHeight() - heightPadding;
        if (child.getMeasuredHeight() < desiredHeight) {
            final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, widthPadding, lp.width);
            final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(desiredHeight, MeasureSpec.EXACTLY);
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The order and grouping of statements have been changed, which is a type 3 change. Additionally, a local variable was added (`desiredHeight`), and its value is used in a later calculation rather than using an inline statement, making it a type 4 change as well.","There is no Compatibility Issue detected because these changes do not affect the external behavior of the method. The final outcome remains the same; `desiredHeight` is assigned the same value as the expression used directly in the early version. Since no return statement, exception handling, dependent API, or control flow has been fundamentally altered so as to potentially produce a different outcome, there is no change that will affect callers of the method."
574,"<android.widget.AbsListView: View obtainView(int,boolean[])>",23,24,"<android.widget.AbsListView: View obtainView(int,boolean[])>","<android.widget.AbsListView: View obtainView(int,boolean[])>",0,"{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }
        isScrap[0] = true;
        // Finish the temporary detach started in addScrapView().
        transientView.dispatchFinishTemporaryDetach();
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;
            // Finish the temporary detach started in addScrapView().
            child.dispatchFinishTemporaryDetach();
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    setItemViewLayoutParams(child, position);
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}","{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }
        isScrap[0] = true;
        // Finish the temporary detach started in addScrapView().
        transientView.dispatchFinishTemporaryDetach();
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            if (child.isTemporarilyDetached()) {
                isScrap[0] = true;
                // Finish the temporary detach started in addScrapView().
                child.dispatchFinishTemporaryDetach();
            } else {
                // we set isScrap to ""true"" only if the view is temporarily detached.
                // if the view is fully detached, it is as good as a view created by the
                // adapter
                isScrap[0] = false;
            }
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    setItemViewLayoutParams(child, position);
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}",1,"/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
","/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the ""temporary detached"" scrap heap, false if
 * otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
575,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUid(int,String,long,long,int)>",23,24,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUid(int,String,long,long,int)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUid(int,String,long,long,int)>",0,"{
    NetworkTemplate template = createTemplate(networkType, subscriberId);
    if (template == null) {
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startHistoryEnumeration(uid);
    return result;
}","{
    return queryDetailsForUidTag(networkType, subscriberId, startTime, endTime, uid, NetworkStats.Bucket.TAG_NONE);
}",1,"/**
 * Query network usage statistics details. Only usable for uids belonging to calling user.
 * Result is aggregated over state but not aggregated over time. This means buckets' start and
 * end timestamps are going to be between 'startTime' and 'endTime' parameters, state is going
 * to be {@link NetworkStats.Bucket#STATE_ALL} and uid the same as the 'uid' parameter.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param uid UID of app
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics details for a given uid.
 *
 * #see queryDetailsForUidTag(int, String, long, long, int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method's implementation has been completely changed to return the result of a call to a different method, queryDetailsForUidTag. Additionally, a dependent API, `queryDetailsForUidTag`, is now being used in the late version, which has different parameters than the original method. Therefore, the code change type is 1,5.","The change in the implementation method to use a different API `queryDetailsForUidTag` with an additional parameter `NetworkStats.Bucket.TAG_NONE` could result in a different return value. Thus, the CI type is 1."
577,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,23,24,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative templatedRequest = new CameraMetadataNative();
        try {
            mRemoteDevice.createDefaultRequest(templateType, /*out*/
            templatedRequest);
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return null;
        }
        CaptureRequest.Builder builder = new CaptureRequest.Builder(templatedRequest, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE);
        return builder;
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative templatedRequest = null;
        templatedRequest = mRemoteDevice.createDefaultRequest(templateType);
        CaptureRequest.Builder builder = new CaptureRequest.Builder(templatedRequest, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE);
        return builder;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of createCaptureRequest has been changed. The early version includes try-catch statements for exceptions from mRemoteDevice.createDefaultRequest while the late version omits this try-catch block. Also, the method signature of mRemoteDevice.createDefaultRequest seems to be changed since the ""/*out*/ templatedRequest"" parameter is no longer passed in the late version, suggesting that templatedRequest is directly assigned the return value of the method call. Hence, the code change types are 1 (return statement changed) and 5 (dependent API changed).","The change in the method signature means the dependent API has changed, and the exception handling has been altered. The previous `catch` blocks for both `CameraRuntimeException` and `RemoteException` are removed. In the early version, a `RemoteException` resulted in a return `null`, now that catch block is omitted and will cause a different behavior. Also, since there's a direct assignment from a changed API method to templatedRequest without a try-catch block, which was previously in place to catch and rethrow exceptions, this could result in the late version throwing an unchecked exception directly whereas the early version would throw a checked exception or return `null`. As such, there's a potential compatibility issue with different return types/values and exception handlings, classified as types 1 (potential different return values or types) and 2 (potential different exception handlings)."
578,"<android.app.Notification: void writeToParcel(Parcel,int)>",23,24,"<android.app.Notification: void writeToParcel(Parcel,int)>","<android.app.Notification: void writeToParcel(Parcel,int)>",0,"{
    parcel.writeInt(1);
    parcel.writeLong(when);
    if (mSmallIcon == null && icon != 0) {
        // you snuck an icon in here without using the builder; let's try to keep it
        mSmallIcon = Icon.createWithResource("""", icon);
    }
    if (mSmallIcon != null) {
        parcel.writeInt(1);
        mSmallIcon.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(number);
    if (contentIntent != null) {
        parcel.writeInt(1);
        contentIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (deleteIntent != null) {
        parcel.writeInt(1);
        deleteIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (tickerText != null) {
        parcel.writeInt(1);
        TextUtils.writeToParcel(tickerText, parcel, flags);
    } else {
        parcel.writeInt(0);
    }
    if (tickerView != null) {
        parcel.writeInt(1);
        tickerView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (contentView != null) {
        parcel.writeInt(1);
        contentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (mLargeIcon != null) {
        parcel.writeInt(1);
        mLargeIcon.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(defaults);
    parcel.writeInt(this.flags);
    if (sound != null) {
        parcel.writeInt(1);
        sound.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(audioStreamType);
    if (audioAttributes != null) {
        parcel.writeInt(1);
        audioAttributes.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeLongArray(vibrate);
    parcel.writeInt(ledARGB);
    parcel.writeInt(ledOnMS);
    parcel.writeInt(ledOffMS);
    parcel.writeInt(iconLevel);
    if (fullScreenIntent != null) {
        parcel.writeInt(1);
        fullScreenIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(priority);
    parcel.writeString(category);
    parcel.writeString(mGroupKey);
    parcel.writeString(mSortKey);
    // null ok
    parcel.writeBundle(extras);
    // null ok
    parcel.writeTypedArray(actions, 0);
    if (bigContentView != null) {
        parcel.writeInt(1);
        bigContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (headsUpContentView != null) {
        parcel.writeInt(1);
        headsUpContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(visibility);
    if (publicVersion != null) {
        parcel.writeInt(1);
        publicVersion.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(color);
}","{
    // We need to mark all pending intents getting into the notification
    // system as being put there to later allow the notification ranker
    // to launch them and by doing so add the app to the battery saver white
    // list for a short period of time. The problem is that the system
    // cannot look into the extras as there may be parcelables there that
    // the platform does not know how to handle. To go around that we have
    // an explicit list of the pending intents in the extras bundle.
    final boolean collectPendingIntents = (allPendingIntents == null);
    if (collectPendingIntents) {
        PendingIntent.setOnMarshaledListener((PendingIntent intent, Parcel out, int outFlags) -> {
            if (parcel == out) {
                if (allPendingIntents == null) {
                    allPendingIntents = new ArraySet<>();
                }
                allPendingIntents.add(intent);
            }
        });
    }
    try {
        // IMPORTANT: Add marshaling code in writeToParcelImpl as we
        // want to intercept all pending events written to the pacel.
        writeToParcelImpl(parcel, flags);
        // Must be written last!
        parcel.writeArraySet(allPendingIntents);
    } finally {
        if (collectPendingIntents) {
            PendingIntent.setOnMarshaledListener(null);
        }
    }
}",1,"/**
 * Flatten this notification into a parcel.
 */
","/**
 * Flatten this notification into a parcel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation of writing to a parcel has been encapsulated into a separate method (writeToParcelImpl), and there is additional handling for pending intents via a listener mechanism. This change does not modify any existing contract or functionality of the API but instead adds additional side-effects, hence, it is classified under other statement changed (4).","There is no change in the return type (void in both early and late version) nor in the method signature, and all changes happen within the method that does not affect the final parcel structure as expected by the caller. Because of this, the method's external behavior and contracts with the caller remain the same, there are no compatibility issues concerning the return value or exception handling, thus the CI type is 0."
579,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",23,24,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>","<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",0,"{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    if (isSelf) {
        long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
        // Our own user's settings data uses a client-side cache
        synchronized (this) {
            if (mValuesVersion != newValuesVersion) {
                if (LOCAL_LOGV || false) {
                    Log.v(TAG, ""invalidate ["" + mUri.getLastPathSegment() + ""]: current "" + newValuesVersion + "" != cached "" + mValuesVersion);
                }
                mValues.clear();
                mValuesVersion = newValuesVersion;
            }
            if (mValues.containsKey(name)) {
                // Could be null, that's OK -- negative caching
                return mValues.get(name);
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = lazyGetProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            Bundle b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
            if (b != null) {
                String value = b.getPairValue();
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (this) {
                        mValues.put(name, value);
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER, new String[] { name }, null, null);
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}","{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = lazyGetProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                            }
                        }
                        mValues.put(name, value);
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER, new String[] { name }, null, null);
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
580,<android.net.NetworkCapabilities: String toString()>,23,24,<android.net.NetworkCapabilities: String toString()>,<android.net.NetworkCapabilities: String toString()>,0,"{
    int[] types = getTransportTypes();
    String transports = (types.length > 0 ? "" Transports: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case TRANSPORT_CELLULAR:
                transports += ""CELLULAR"";
                break;
            case TRANSPORT_WIFI:
                transports += ""WIFI"";
                break;
            case TRANSPORT_BLUETOOTH:
                transports += ""BLUETOOTH"";
                break;
            case TRANSPORT_ETHERNET:
                transports += ""ETHERNET"";
                break;
            case TRANSPORT_VPN:
                transports += ""VPN"";
                break;
        }
        if (++i < types.length)
            transports += ""|"";
    }
    types = getCapabilities();
    String capabilities = (types.length > 0 ? "" Capabilities: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case NET_CAPABILITY_MMS:
                capabilities += ""MMS"";
                break;
            case NET_CAPABILITY_SUPL:
                capabilities += ""SUPL"";
                break;
            case NET_CAPABILITY_DUN:
                capabilities += ""DUN"";
                break;
            case NET_CAPABILITY_FOTA:
                capabilities += ""FOTA"";
                break;
            case NET_CAPABILITY_IMS:
                capabilities += ""IMS"";
                break;
            case NET_CAPABILITY_CBS:
                capabilities += ""CBS"";
                break;
            case NET_CAPABILITY_WIFI_P2P:
                capabilities += ""WIFI_P2P"";
                break;
            case NET_CAPABILITY_IA:
                capabilities += ""IA"";
                break;
            case NET_CAPABILITY_RCS:
                capabilities += ""RCS"";
                break;
            case NET_CAPABILITY_XCAP:
                capabilities += ""XCAP"";
                break;
            case NET_CAPABILITY_EIMS:
                capabilities += ""EIMS"";
                break;
            case NET_CAPABILITY_NOT_METERED:
                capabilities += ""NOT_METERED"";
                break;
            case NET_CAPABILITY_INTERNET:
                capabilities += ""INTERNET"";
                break;
            case NET_CAPABILITY_NOT_RESTRICTED:
                capabilities += ""NOT_RESTRICTED"";
                break;
            case NET_CAPABILITY_TRUSTED:
                capabilities += ""TRUSTED"";
                break;
            case NET_CAPABILITY_NOT_VPN:
                capabilities += ""NOT_VPN"";
                break;
            case NET_CAPABILITY_VALIDATED:
                capabilities += ""VALIDATED"";
                break;
            case NET_CAPABILITY_CAPTIVE_PORTAL:
                capabilities += ""CAPTIVE_PORTAL"";
                break;
        }
        if (++i < types.length)
            capabilities += ""&"";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? "" LinkUpBandwidth>="" + mLinkUpBandwidthKbps + ""Kbps"" : """");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? "" LinkDnBandwidth>="" + mLinkDownBandwidthKbps + ""Kbps"" : """");
    String specifier = (mNetworkSpecifier == null ? """" : "" Specifier: <"" + mNetworkSpecifier + "">"");
    return ""["" + transports + capabilities + upBand + dnBand + specifier + ""]"";
}","{
    int[] types = getTransportTypes();
    String transports = (types.length > 0) ? "" Transports: "" + transportNamesOf(types) : """";
    types = getCapabilities();
    String capabilities = (types.length > 0 ? "" Capabilities: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case NET_CAPABILITY_MMS:
                capabilities += ""MMS"";
                break;
            case NET_CAPABILITY_SUPL:
                capabilities += ""SUPL"";
                break;
            case NET_CAPABILITY_DUN:
                capabilities += ""DUN"";
                break;
            case NET_CAPABILITY_FOTA:
                capabilities += ""FOTA"";
                break;
            case NET_CAPABILITY_IMS:
                capabilities += ""IMS"";
                break;
            case NET_CAPABILITY_CBS:
                capabilities += ""CBS"";
                break;
            case NET_CAPABILITY_WIFI_P2P:
                capabilities += ""WIFI_P2P"";
                break;
            case NET_CAPABILITY_IA:
                capabilities += ""IA"";
                break;
            case NET_CAPABILITY_RCS:
                capabilities += ""RCS"";
                break;
            case NET_CAPABILITY_XCAP:
                capabilities += ""XCAP"";
                break;
            case NET_CAPABILITY_EIMS:
                capabilities += ""EIMS"";
                break;
            case NET_CAPABILITY_NOT_METERED:
                capabilities += ""NOT_METERED"";
                break;
            case NET_CAPABILITY_INTERNET:
                capabilities += ""INTERNET"";
                break;
            case NET_CAPABILITY_NOT_RESTRICTED:
                capabilities += ""NOT_RESTRICTED"";
                break;
            case NET_CAPABILITY_TRUSTED:
                capabilities += ""TRUSTED"";
                break;
            case NET_CAPABILITY_NOT_VPN:
                capabilities += ""NOT_VPN"";
                break;
            case NET_CAPABILITY_VALIDATED:
                capabilities += ""VALIDATED"";
                break;
            case NET_CAPABILITY_CAPTIVE_PORTAL:
                capabilities += ""CAPTIVE_PORTAL"";
                break;
        }
        if (++i < types.length)
            capabilities += ""&"";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? "" LinkUpBandwidth>="" + mLinkUpBandwidthKbps + ""Kbps"" : """");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? "" LinkDnBandwidth>="" + mLinkDownBandwidthKbps + ""Kbps"" : """");
    String specifier = (mNetworkSpecifier == null ? """" : "" Specifier: <"" + mNetworkSpecifier + "">"");
    String signalStrength = (hasSignalStrength() ? "" SignalStrength: "" + mSignalStrength : """");
    return ""["" + transports + capabilities + upBand + dnBand + specifier + signalStrength + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
583,<android.app.WallpaperManager: Drawable getDrawable()>,23,24,<android.app.WallpaperManager: Drawable getDrawable()>,<android.app.WallpaperManager: Drawable getDrawable()>,0,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}","{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true, FLAG_SYSTEM);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}",1,"/**
 * Retrieve the current system wallpaper; if
 * no wallpaper is set, the system built-in static wallpaper is returned.
 * This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */
","/**
 * Retrieve the current system wallpaper; if
 * no wallpaper is set, the system built-in static wallpaper is returned.
 * This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed but only in the parameter list of the call to peekWallpaperBitmap(), the addition of FLAG_SYSTEM. Thus, only a dependent API has been changed, so the code change type is 5.","There is no potential CI as the modification doesn't affect the return value of getDrawable() directly nor introduce any new exceptions. The alteration seems to ensure a specific flag is set when peeking the wallpaper bitmap, which is an internal detail likely not affecting the external behavior of this API. Thus, no compatibility issue is predicted."
584,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",23,24,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>","<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",0,"{
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""inflate"");
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (Exception e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        return result;
    }
}","{
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""inflate"");
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            final InflateException ie = new InflateException(e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } catch (Exception e) {
            final InflateException ie = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
        return result;
    }
}",1,"/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
","/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
585,<android.widget.ListView: void layoutChildren()>,23,24,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }
    mBlockLayoutRequests = true;
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only from "" + ""the UI thread. Make sure your adapter calls notifyDataSetChanged() "" + ""when its content changes. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();
            if (focusHost != null) {
                final View focusChild = getAccessibilityFocusedChild(focusHost);
                if (focusChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(focusChild) || focusChild.hasTransientState() || mAdapterHasStableIds) {
                        // The views won't be changing, so try to maintain
                        // focus on the current host and virtual view.
                        accessibilityFocusLayoutRestoreView = focusHost;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    }
                    // If all else fails, maintain focus at the same
                    // position.
                    accessibilityFocusPosition = getPositionForView(focusChild);
                }
            }
        }
        View focusLayoutRestoreDirectChild = null;
        View focusLayoutRestoreView = null;
        // Take focus back to us temporarily to avoid the eventual call to
        // clear focus when removing the focused child below from messing
        // things up when ViewAncestor assigns focus back to someone else.
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // header or footer.
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild) || focusedChild.hasTransientState() || mAdapterHasStableIds) {
                focusLayoutRestoreDirectChild = focusedChild;
                // Remember the specific view that had focus.
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // Tell it we are going to mess with it.
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // focusable.
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // Selected item didn't take focus, but we still want to
                    // make sure something else outside of the selected view
                    // has focus.
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING;
            if (inTouchMode) {
                // If the user's finger is down, select the motion position.
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else if (mSelectorPosition != INVALID_POSITION) {
                // If we had previously positioned the selector somewhere,
                // put it back there. It might not match up with the data,
                // but it's transitioning out so it's not a big deal.
                final View child = getChildAt(mSelectorPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mSelectorPosition, child);
                }
            } else {
                // Otherwise, clear selection.
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // restore focus (i.e. something focusable in touch mode).
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus, if necessary.
        if (viewRootImpl != null) {
            final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (newAccessibilityFocusedView == null) {
                if (accessibilityFocusLayoutRestoreView != null && accessibilityFocusLayoutRestoreView.isAttachedToWindow()) {
                    final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
                    if (accessibilityFocusLayoutRestoreNode != null && provider != null) {
                        final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                        provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
                    } else {
                        accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
                    }
                } else if (accessibilityFocusPosition != INVALID_POSITION) {
                    // Bound the position within the visible children.
                    final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                    final View restoreView = getChildAt(position);
                    if (restoreView != null) {
                        restoreView.requestAccessibilityFocus();
                    }
                }
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }
    mBlockLayoutRequests = true;
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only from "" + ""the UI thread. Make sure your adapter calls notifyDataSetChanged() "" + ""when its content changes. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();
            if (focusHost != null) {
                final View focusChild = getAccessibilityFocusedChild(focusHost);
                if (focusChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(focusChild) || focusChild.hasTransientState() || mAdapterHasStableIds) {
                        // The views won't be changing, so try to maintain
                        // focus on the current host and virtual view.
                        accessibilityFocusLayoutRestoreView = focusHost;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    }
                    // If all else fails, maintain focus at the same
                    // position.
                    accessibilityFocusPosition = getPositionForView(focusChild);
                }
            }
        }
        View focusLayoutRestoreDirectChild = null;
        View focusLayoutRestoreView = null;
        // Take focus back to us temporarily to avoid the eventual call to
        // clear focus when removing the focused child below from messing
        // things up when ViewAncestor assigns focus back to someone else.
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // header or footer.
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild) || focusedChild.hasTransientState() || mAdapterHasStableIds) {
                focusLayoutRestoreDirectChild = focusedChild;
                // Remember the specific view that had focus.
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // Tell it we are going to mess with it.
                    focusLayoutRestoreView.dispatchStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                final int selectedPosition = reconcileSelectedPosition();
                sel = fillSpecific(selectedPosition, mSpecificTop);
                /**
                 * When ListView is resized, FocusSelector requests an async selection for the
                 * previously focused item to make sure it is still visible. If the item is not
                 * selectable, it won't regain focus so instead we call FocusSelector
                 * to directly request focus on the view after it is visible.
                 */
                if (sel == null && mFocusSelector != null) {
                    final Runnable focusRunnable = mFocusSelector.setupFocusIfValid(selectedPosition);
                    if (focusRunnable != null) {
                        post(focusRunnable);
                    }
                }
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        // remove any header/footer that has been temp detached and not re-attached
        removeUnusedFixedViews(mHeaderViewInfos);
        removeUnusedFixedViews(mFooterViewInfos);
        if (sel != null) {
            // focusable.
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // Selected item didn't take focus, but we still want to
                    // make sure something else outside of the selected view
                    // has focus.
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING;
            if (inTouchMode) {
                // If the user's finger is down, select the motion position.
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else if (mSelectorPosition != INVALID_POSITION) {
                // If we had previously positioned the selector somewhere,
                // put it back there. It might not match up with the data,
                // but it's transitioning out so it's not a big deal.
                final View child = getChildAt(mSelectorPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mSelectorPosition, child);
                }
            } else {
                // Otherwise, clear selection.
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // restore focus (i.e. something focusable in touch mode).
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus, if necessary.
        if (viewRootImpl != null) {
            final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (newAccessibilityFocusedView == null) {
                if (accessibilityFocusLayoutRestoreView != null && accessibilityFocusLayoutRestoreView.isAttachedToWindow()) {
                    final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
                    if (accessibilityFocusLayoutRestoreNode != null && provider != null) {
                        final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                        provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
                    } else {
                        accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
                    }
                } else if (accessibilityFocusPosition != INVALID_POSITION) {
                    // Bound the position within the visible children.
                    final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                    final View restoreView = getChildAt(position);
                    if (restoreView != null) {
                        restoreView.requestAccessibilityFocus();
                    }
                }
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.dispatchFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (mFocusSelector != null) {
            mFocusSelector.onLayoutComplete();
        }
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
586,"<android.hardware.camera2.legacy.LegacyResultMapper: CameraMetadataNative cachedConvertResultMetadata(LegacyRequest,long)>",23,24,"<android.hardware.camera2.legacy.LegacyResultMapper: CameraMetadataNative cachedConvertResultMetadata(LegacyRequest,long)>","<android.hardware.camera2.legacy.LegacyResultMapper: CameraMetadataNative cachedConvertResultMetadata(LegacyRequest,long)>",0,"{
    CameraMetadataNative result;
    boolean cached;
    /*
         * Attempt to look up the result from the cache if the parameters haven't changed
         */
    if (mCachedRequest != null && legacyRequest.parameters.same(mCachedRequest.parameters)) {
        result = new CameraMetadataNative(mCachedResult);
        cached = true;
    } else {
        result = convertResultMetadata(legacyRequest);
        cached = false;
        // Always cache a *copy* of the metadata result,
        // since api2's client side takes ownership of it after it receives a result
        mCachedRequest = legacyRequest;
        mCachedResult = new CameraMetadataNative(result);
    }
    /*
         * Unconditionally set fields that change in every single frame
         */
    {
        // sensor.timestamp
        result.set(SENSOR_TIMESTAMP, timestamp);
    }
    if (DEBUG) {
        Log.v(TAG, ""cachedConvertResultMetadata - cached? "" + cached + "" timestamp = "" + timestamp);
        Log.v(TAG, ""----- beginning of result dump ------"");
        result.dumpToLog();
        Log.v(TAG, ""----- end of result dump ------"");
    }
    return result;
}","{
    CameraMetadataNative result;
    boolean cached;
    /*
         * Attempt to look up the result from the cache if the parameters haven't changed
         */
    if (mCachedRequest != null && legacyRequest.parameters.same(mCachedRequest.parameters) && legacyRequest.captureRequest.equals(mCachedRequest.captureRequest)) {
        result = new CameraMetadataNative(mCachedResult);
        cached = true;
    } else {
        result = convertResultMetadata(legacyRequest);
        cached = false;
        // Always cache a *copy* of the metadata result,
        // since api2's client side takes ownership of it after it receives a result
        mCachedRequest = legacyRequest;
        mCachedResult = new CameraMetadataNative(result);
    }
    /*
         * Unconditionally set fields that change in every single frame
         */
    {
        // sensor.timestamp
        result.set(SENSOR_TIMESTAMP, timestamp);
    }
    if (DEBUG) {
        Log.v(TAG, ""cachedConvertResultMetadata - cached? "" + cached + "" timestamp = "" + timestamp);
        Log.v(TAG, ""----- beginning of result dump ------"");
        result.dumpToLog();
        Log.v(TAG, ""----- end of result dump ------"");
    }
    return result;
}",1,"/**
 * Generate capture result metadata from the legacy camera request.
 *
 * <p>This method caches and reuses the result from the previous call to this method if
 * the {@code parameters} of the subsequent {@link LegacyRequest} passed to this method
 * have not changed.</p>
 *
 * @param legacyRequest a non-{@code null} legacy request containing the latest parameters
 * @param timestamp the timestamp to use for this result in nanoseconds.
 *
 * @return {@link CameraMetadataNative} object containing result metadata.
 */
","/**
 * Generate capture result metadata from the legacy camera request.
 *
 * <p>This method caches and reuses the result from the previous call to this method if
 * the {@code parameters} of the subsequent {@link LegacyRequest} passed to this method
 * have not changed.</p>
 *
 * @param legacyRequest a non-{@code null} legacy request containing the latest parameters
 * @param timestamp the timestamp to use for this result in nanoseconds.
 *
 * @return {@link CameraMetadataNative} object containing result metadata.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency has changed due to the addition of `legacyRequest.captureRequest.equals(mCachedRequest.captureRequest)` in the `if` condition, indicating a change in the logic that determines when to use cached results. So, the code change type is 3.","With the new conditional check, the late version of the method might not use the cached result when it would have previously, leading to a potentially different value being returned. The introduction of an additional requirement (`legacyRequest.captureRequest.equals(mCachedRequest.captureRequest)`) for the cache to be used introduces a potential change in behavior. Therefore, the change may cause a Compatibility Issue due to potentially different return values, so the CI type is 1."
587,<android.net.ConnectivityManager: void releaseNetworkRequest(PendingIntent)>,23,24,<android.net.ConnectivityManager: void releaseNetworkRequest(PendingIntent)>,<android.net.ConnectivityManager: void releaseNetworkRequest(PendingIntent)>,0,"{
    checkPendingIntent(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
    }
}","{
    checkPendingIntent(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Removes a request made via {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)}
 * <p>
 * This method has the same behavior as {@link #unregisterNetworkCallback} with respect to
 * releasing network resources and disconnecting.
 *
 * @param operation A PendingIntent equal (as defined by {@link Intent#filterEquals}) to the
 * PendingIntent passed to
 * {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)} with the
 * corresponding NetworkRequest you'd like to remove. Cannot be null.
 */
","/**
 * Removes a request made via {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)}
 * <p>
 * This method has the same behavior as
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)} with respect to
 * releasing network resources and disconnecting.
 *
 * @param operation A PendingIntent equal (as defined by {@link Intent#filterEquals}) to the
 * PendingIntent passed to
 * {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)} with the
 * corresponding NetworkRequest you'd like to remove. Cannot be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, where the new version adds throwing an exception with `throw e.rethrowFromSystemServer()`, so the change is of type 2.","The change in the exception handling statement could lead to the late version throwing a RuntimeException when a RemoteException occurs, where the early version would not, so the CI type is 2."
589,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,23,24,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,0,"{
    if (mEnteringNames == null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, mEnteringNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                decor.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                    @Override
                    public boolean onPreDraw() {
                        finalDecor.getViewTreeObserver().removeOnPreDrawListener(this);
                        if (mReturnExitCoordinator != null) {
                            mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                        }
                        return true;
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}","{
    if (mEnteringNames == null || mCalledExitCoordinator != null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, mEnteringNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                decor.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                    @Override
                    public boolean onPreDraw() {
                        finalDecor.getViewTreeObserver().removeOnPreDrawListener(this);
                        if (mReturnExitCoordinator != null) {
                            mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                        }
                        return true;
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The if condition at the beginning of the function has changed from checking only if `mEnteringNames == null` to if `mEnteringNames == null || mCalledExitCoordinator != null`. This is a control dependency change because the control flow statement (if condition) has changed (3). Moreover, this change directly affects a return statement, thus it's also categorized under return statement changed (1).","The change in the condition potentially affects the return value of the method. Where previously the method would only return false when `mEnteringNames` is null, in the late version it will additionally return false when `mCalledExitCoordinator` is not null. This difference in behavior could potentially cause backward incompatibility, thus there's a Compatibility Issue due to a potential different return value (1)."
590,<android.os.UserManager: List<UserHandle> getUserProfiles()>,23,24,<android.os.UserManager: List<UserHandle> getUserProfiles()>,<android.os.UserManager: List<UserHandle> getUserProfiles()>,0,"{
    ArrayList<UserHandle> profiles = new ArrayList<UserHandle>();
    List<UserInfo> users = new ArrayList<UserInfo>();
    try {
        users = mService.getProfiles(UserHandle.myUserId(), true);
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not get user list"", re);
        return null;
    }
    for (UserInfo info : users) {
        UserHandle userHandle = new UserHandle(info.id);
        profiles.add(userHandle);
    }
    return profiles;
}","{
    int[] userIds = getProfileIds(UserHandle.myUserId(), true);
    List<UserHandle> result = new ArrayList<>(userIds.length);
    for (int userId : userIds) {
        result.add(UserHandle.of(userId));
    }
    return result;
}",1,"/**
 * Returns a list of UserHandles for profiles associated with the user that the calling process
 * is running on, including the user itself.
 *
 * @return A non-empty list of UserHandles associated with the calling user.
 */
","/**
 * Returns a list of UserHandles for profiles associated with the user that the calling process
 * is running on, including the user itself.
 *
 * @return A non-empty list of UserHandles associated with the calling user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The implementation of the method has been significantly refactored between the early and late version:,- The early implementation initializes an `ArrayList<UserInfo>` which is not present in the late implementation.
591,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",23,24,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>","<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",0,"{
    if (!method.startsWith(""android:"")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException(""Requested authority "" + authority + "" doesn't match provider "" + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException(""Method not supported "" + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
    return out;
}","{
    if (!method.startsWith(""android:"")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    try {
        return callUnchecked(method, arg, extras);
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
}",1,"/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */
","/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */
",-1,"[@CallSuper, @Override]","[@CallSuper, @Override]",-1,-1,-1,-1,-1,-1,"1,3,5","1,2","The return statement has been changed, control statements are removed, the large block of implementation code is encapsulated in a new method 'callUnchecked', and exception handling is preserved. Additionally, a dependency on a new method 'callUnchecked' which is not shown in this context has been introduced. So the change type is 1,3,5.","Since the implementation details inside 'callUnchecked' are not visible, we cannot definitively say what the exact changes are. However, since the previous implementation had different branches that could return different bundles containing different URIs and there is a change in the try block (with a new method call), this could lead to different behavior. Therefore, we can suspect different return values or types, causing a potential CI type of 1. The exception handling remains similar, but because it now wraps all of the functionality inside 'callUnchecked' which might include new FileNotFoundException cases, there's a possibility for different exception handling as well, causing a potential CI type of 2."
592,<android.content.res.Resources: int[] getIntArray(int)>,23,24,<android.content.res.Resources: int[] getIntArray(int)>,<android.content.res.Resources: int[] getIntArray(int)>,0,"{
    int[] res = mAssets.getArrayIntResource(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""Int array resource ID #0x"" + Integer.toHexString(id));
}","{
    int[] res = mResourcesImpl.getAssets().getArrayIntResource(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""Int array resource ID #0x"" + Integer.toHexString(id));
}",1,"/**
 * Return the int array associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return The int array associated with the resource.
 */
","/**
 * Return the int array associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return The int array associated with the resource.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The way to get the resource array changed from mAssets.getArrayIntResource(id) to mResourcesImpl.getAssets().getArrayIntResource(id), implying a changed dependent API, so the code change type is 5.","Although the implementation invokes a different method from another class (mResourcesImpl), the overall behavior of the API has not changed in respect to what it returns or the exceptions it may throw. Therefore, there is no compatibility issue as per the given definitions, hence the CI type is 0."
594,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",23,24,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mOutsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound());
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mOutsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
595,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,23,24,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.setName(name);
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setName(name);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param name a valid Bluetooth name
 * @return     true if the name was set, false otherwise
 */
","/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param name a valid Bluetooth name
 * @return     true if the name was set, false otherwise
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,"3,4",0,"The change is related to the synchronization mechanism, from a `synchronized` block on `mManagerCallback` to a read lock mechanism (`mServiceLock.readLock().lock()`). Additionally, a new `finally` block was added to ensure that the read lock is unlocked. So the code change types are 3 (control dependency change due to the modification of how the synchronization is done) and 4 (other statement changed due to the addition of the finally block and the lock/unlock statements).","Despite the change in the synchronization mechanism, this will not lead to a different behavior of the API since it will return the same value or throw same exceptions under the same conditions as before. The changes simply alters the way the thread-safety is handled internally without affecting the API's semantic contract. Thus, there is no Compatibility Issue."
598,<android.app.WallpaperManager: void setResource(int)>,23,24,<android.app.WallpaperManager: void setResource(int)>,<android.app.WallpaperManager: void setResource(int)>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid), mContext.getOpPackageName());
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(resources.openRawResource(resid), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    setResource(resid, FLAG_SYSTEM);
}",1,"/**
 * Change the current system wallpaper to the bitmap in the given resource.
 * The resource is opened as a raw data stream and copied into the
 * wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param resid The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to the bitmap in the given resource.
 * The resource is opened as a raw data stream and copied into the
 * wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param resid The resource ID of the bitmap to be used as the wallpaper image
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The late version of the implementation calls a method setResource with two arguments instead of the series of statements in the early version, which includes checks, resource obtaining, setting wallpaper, and exception handling. Because of the replaced implementation with a call to another method, the change type is 4,5.","Since the early version contains a set of instructions that are entirely replaced by a different method call in the late version, this leads to a potential difference in behavior due to the different implementations, which could result in the method returning different values or handling exceptions differently. Therefore, the API has a compatibility issue of type 1."
600,"<android.app.AppOpsManager: void checkPackage(int,String)>",23,24,"<android.app.AppOpsManager: void checkPackage(int,String)>","<android.app.AppOpsManager: void checkPackage(int,String)>",0,"{
    try {
        if (mService.checkPackage(uid, packageName) != MODE_ALLOWED) {
            throw new SecurityException(""Package "" + packageName + "" does not belong to "" + uid);
        }
    } catch (RemoteException e) {
        throw new SecurityException(""Unable to verify package ownership"", e);
    }
}","{
    try {
        if (mService.checkPackage(uid, packageName) != MODE_ALLOWED) {
            throw new SecurityException(""Package "" + packageName + "" does not belong to "" + uid);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Do a quick check to validate if a package name belongs to a UID.
 *
 * @throws SecurityException if the package name doesn't belong to the given
 * UID, or if ownership cannot be verified.
 */
","/**
 * Do a quick check to validate if a package name belongs to a UID.
 *
 * @throws SecurityException if the package name doesn't belong to the given
 * UID, or if ownership cannot be verified.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The change is within the catch block, where the thrown exception type has changed from a new SecurityException to the result of calling e.rethrowFromSystemServer(), so the code change type is 2.","This change could cause the API to throw a different exception type since RemoteException is now being propagated using e.rethrowFromSystemServer(), which could potentially rethrow as one of the subclasses of RuntimeException, instead of always wrapping it inside a SecurityException. This constitutes a change in exception handling behavior, thus the CI type is 2."
601,<android.text.Html: String toHtml(Spanned)>,23,24,<android.text.Html: String toHtml(Spanned)>,<android.text.Html: String toHtml(Spanned)>,0,"{
    StringBuilder out = new StringBuilder();
    withinHtml(out, text);
    return out.toString();
}","{
    return toHtml(text, TO_HTML_PARAGRAPH_LINES_CONSECUTIVE);
}",1,"/**
 * Returns an HTML representation of the provided Spanned text. A best effort is
 * made to add HTML tags corresponding to spans. Also note that HTML metacharacters
 * (such as ""&lt;"" and ""&amp;"") within the input text are escaped.
 *
 * @param text input text to convert
 * @return string containing input converted to HTML
 */
","/**
 * @deprecated use {@link #toHtml(Spanned, int)} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has completely changed from using `withinHtml(out, text)` and returning the result of `out.toString()` to using `toHtml(text, TO_HTML_PARAGRAPH_LINES_CONSECUTIVE)`, indicating both a Return statement changed and Dependent API changed (since the method now relies on a different method, `toHtml` with an extra parameter), so the code change type is 1,5.","The change in method implementation fundamentally alters how the return value is produced, thus there is a Compatibility Issue due to the altered data returned, and the CI type is 1. The method is also marked as deprecated, so it suggests a potential behavioral change or a recommendation against usage, but deprecation itself does not cause a compatibility issue, therefore it is not indicated in the CI type."
602,<android.app.Notification.Builder: Builder setContentIntent(PendingIntent)>,23,24,<android.app.Notification.Builder: Builder setContentIntent(PendingIntent)>,<android.app.Notification.Builder: Builder setContentIntent(PendingIntent)>,0,"{
    mContentIntent = intent;
    return this;
}","{
    mN.contentIntent = intent;
    return this;
}",1,"/**
 * Supply a {@link PendingIntent} to be sent when the notification is clicked.
 *
 * As of {@link android.os.Build.VERSION_CODES#HONEYCOMB}, if this field is unset and you
 * have specified a custom RemoteViews with {@link #setContent(RemoteViews)}, you can use
 * {@link RemoteViews#setOnClickPendingIntent RemoteViews.setOnClickPendingIntent(int,PendingIntent)}
 * to assign PendingIntents to individual views in that custom layout (i.e., to create
 * clickable buttons inside the notification view).
 *
 * @see Notification#contentIntent Notification.contentIntent
 */
","/**
 * Supply a {@link PendingIntent} to be sent when the notification is clicked.
 *
 * As of {@link android.os.Build.VERSION_CODES#HONEYCOMB}, if this field is unset and you
 * have specified a custom RemoteViews with {@link #setContent(RemoteViews)}, you can use
 * {@link RemoteViews#setOnClickPendingIntent RemoteViews.setOnClickPendingIntent(int,PendingIntent)}
 * to assign PendingIntents to individual views in that custom layout (i.e., to create
 * clickable buttons inside the notification view).
 *
 * @see Notification#contentIntent Notification.contentIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the assignment of the intent to a different object field (from mContentIntent to mN.contentIntent), which is an internal detail not affecting the method's observable behavior, hence the change type is 4.","There's no change in the API's behavior or contract. It still accepts a PendingIntent and returns a Builder object, so there's no Compatibility Issue. The fact that the field where the PendingIntent is stored internally has changed doesn't affect how the method works from the perspective of the API user."
603,<android.print.PrintManager: List<PrintJob> getPrintJobs()>,23,24,<android.print.PrintManager: List<PrintJob> getPrintJobs()>,<android.print.PrintManager: List<PrintJob> getPrintJobs()>,0,"{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return Collections.emptyList();
    }
    try {
        List<PrintJobInfo> printJobInfos = mService.getPrintJobInfos(mAppId, mUserId);
        if (printJobInfos == null) {
            return Collections.emptyList();
        }
        final int printJobCount = printJobInfos.size();
        List<PrintJob> printJobs = new ArrayList<PrintJob>(printJobCount);
        for (int i = 0; i < printJobCount; i++) {
            printJobs.add(new PrintJob(printJobInfos.get(i), this));
        }
        return printJobs;
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error getting print jobs"", re);
    }
    return Collections.emptyList();
}","{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return Collections.emptyList();
    }
    try {
        List<PrintJobInfo> printJobInfos = mService.getPrintJobInfos(mAppId, mUserId);
        if (printJobInfos == null) {
            return Collections.emptyList();
        }
        final int printJobCount = printJobInfos.size();
        List<PrintJob> printJobs = new ArrayList<PrintJob>(printJobCount);
        for (int i = 0; i < printJobCount; i++) {
            printJobs.add(new PrintJob(printJobInfos.get(i), this));
        }
        return printJobs;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the print jobs for this application.
 *
 * @return The print job list.
 * @see PrintJob
 */
","/**
 * Gets the print jobs for this application.
 *
 * @return The print job list.
 * @see PrintJob
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from logging an error to throwing an exception, so the code change type is 2.",Throwing the exception instead of returning an empty list could potentially lead to a different exception being thrown in the late version of API compared to the early version. This indicates a CI type of 2.
604,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,23,24,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessiiblity focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessiiblity focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
",,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
605,<android.app.WallpaperManager: Drawable peekFastDrawable()>,23,24,<android.app.WallpaperManager: Drawable peekFastDrawable()>,<android.app.WallpaperManager: Drawable peekFastDrawable()>,0,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}","{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}",1,"/**
 * Like {@link #getFastDrawable()}, but if there is no wallpaper set,
 * a null pointer is returned.
 *
 * @return Returns an optimized Drawable object that will draw the
 * wallpaper or a null pointer if these is none.
 */
","/**
 * Like {@link #getFastDrawable()}, but if there is no wallpaper set,
 * a null pointer is returned.
 *
 * @return Returns an optimized Drawable object that will draw the
 * wallpaper or a null pointer if these is none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change in the dependent API call from peekWallpaperBitmap(mContext, false) to peekWallpaperBitmap(mContext, false, FLAG_SYSTEM) indicates an addition of an argument in the API call, which is thus classified as a change in a dependent API, code change type 5.","As the additional argument does not change the return type and does not handle exceptions differently, it does not necessarily lead to a compatibility issue as long as the underlying functionality of peekWallpaperBitmap() retains the same behavioral contract with respect to the existing parameters. Without further information indicating a change in behavior, we can only assume that the additional flag is handled in a backward-compatible manner, and thus there is no compatibility issue, CI type 0."
606,"<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>",23,24,"<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>","<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>",0,"{
    final Sensor sensor = mManager.mHandleToSensor.get(handle);
    TriggerEvent t = null;
    synchronized (mTriggerEvents) {
        t = mTriggerEvents.get(handle);
    }
    if (t == null) {
        Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}","{
    final Sensor sensor = mManager.mHandleToSensor.get(handle);
    if (sensor == null) {
        // sensor disconnected
        return;
    }
    TriggerEvent t = null;
    synchronized (mTriggerEvents) {
        t = mTriggerEvents.get(handle);
    }
    if (t == null) {
        Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}",1,"// Called from native code.
","// Called from native code.
",-1,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",-1,-1,-1,-1,-1,-1,"1,3",1,"An additional check is introduced for `sensor == null`, which results in a new return statement and the code being under new control dependency. This change is classified as type 1 and 3.","The introduction of a new check for `sensor == null` and corresponding return statement could lead to different return behavior (returning early) when the `sensor` is `null`. As the method now potentially returns earlier than it did previously, there is a Compatibility Issue of type 1, caused by potentially different return values."
607,<android.net.ConnectivityManager: boolean isActiveNetworkMetered()>,23,24,<android.net.ConnectivityManager: boolean isActiveNetworkMetered()>,<android.net.ConnectivityManager: boolean isActiveNetworkMetered()>,0,"{
    try {
        return mService.isActiveNetworkMetered();
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return mService.isActiveNetworkMetered();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns if the currently active data network is metered. A network is
 * classified as metered when the user is sensitive to heavy data usage on
 * that connection due to monetary costs, data limitations or
 * battery/performance issues. You should check this before doing large
 * data transfers, and warn the user or delay the operation until another
 * network is available.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return {@code true} if large transfers should be avoided, otherwise
 * {@code false}.
 */
","/**
 * Returns if the currently active data network is metered. A network is
 * classified as metered when the user is sensitive to heavy data usage on
 * that connection due to monetary costs, data limitations or
 * battery/performance issues. You should check this before doing large
 * data transfers, and warn the user or delay the operation until another
 * network is available.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return {@code true} if large transfers should be avoided, otherwise
 * {@code false}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"Exception handling has changed from returning a default value 'false' to throwing the exception using 'throw e.rethrowFromSystemServer()', so the code change type is 2.","The behavior of the method in the scenario when a RemoteException occurs is different. Previously, the method would return false in case of a RemoteException, but in the new implementation, it will now throw an exception. This constitutes a compatibility issue as the exception handling behavior has been altered, hence the CI type is 2."
608,"<android.app.ActivityManagerProxy: ParceledListSlice<UriPermission> getPersistedUriPermissions(String,boolean)>",23,24,"<android.app.ActivityManagerProxy: RecentTaskInfo> getRecentTasks(int,int,int)>","<android.app.ActivityManagerProxy: ParceledListSlice<UriPermission> getPersistedUriPermissions(String,boolean)>",0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeInt(maxNum);
    data.writeInt(flags);
    data.writeInt(userId);
    mRemote.transact(GET_RECENT_TASKS_TRANSACTION, data, reply, 0);
    reply.readException();
    ArrayList<ActivityManager.RecentTaskInfo> list = reply.createTypedArrayList(ActivityManager.RecentTaskInfo.CREATOR);
    data.recycle();
    reply.recycle();
    return list;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeString(packageName);
    data.writeInt(incoming ? 1 : 0);
    mRemote.transact(GET_PERSISTED_URI_PERMISSIONS_TRANSACTION, data, reply, 0);
    reply.readException();
    @SuppressWarnings(""unchecked"") final ParceledListSlice<UriPermission> perms = ParceledListSlice.CREATOR.createFromParcel(reply);
    data.recycle();
    reply.recycle();
    return perms;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method logic, parameter types, transaction codes, and return types have changed, which implies a change in the dependent API since the method is interacting with a different transaction (GET_PERSISTED_URI_PERMISSIONS_TRANSACTION instead of GET_RECENT_TASKS_TRANSACTION) and returning a different type (ParceledListSlice<UriPermission> instead of ArrayList<ActivityManager.RecentTaskInfo>), so the code change type is 1,4,5.","The early version of the method returned an ArrayList of RecentTaskInfo objects, while the late version returns a ParceledListSlice containing UriPermission objects. The difference in returned data types represents a compatibility issue; thus, CI type is 1."
609,"<android.app.ActivityManagerProxy: RecentTaskInfo> getRecentTasks(int,int,int)>",23,24,"<android.app.ActivityManagerProxy: ParceledListSlice<UriPermission> getPersistedUriPermissions(String,boolean)>","<android.app.ActivityManagerProxy: RecentTaskInfo> getRecentTasks(int,int,int)>",0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeString(packageName);
    data.writeInt(incoming ? 1 : 0);
    mRemote.transact(GET_PERSISTED_URI_PERMISSIONS_TRANSACTION, data, reply, 0);
    reply.readException();
    final ParceledListSlice<UriPermission> perms = ParceledListSlice.CREATOR.createFromParcel(reply);
    data.recycle();
    reply.recycle();
    return perms;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeInt(maxNum);
    data.writeInt(flags);
    data.writeInt(userId);
    mRemote.transact(GET_RECENT_TASKS_TRANSACTION, data, reply, 0);
    reply.readException();
    final ParceledListSlice<ActivityManager.RecentTaskInfo> list = ParceledListSlice.CREATOR.createFromParcel(reply);
    data.recycle();
    reply.recycle();
    return list;
}",1,,,-1,[@Override],,-1,-1,-1,-1,-1,-1,"1,4,5",1,"There is a substantial change in what the method writes to `data` (different data is being transmitted), and the type of object that is being received is also changed - from a `ParceledListSlice<UriPermission>` to `ParceledListSlice<ActivityManager.RecentTaskInfo>`. Additionally, the method signature suggests that it should return `RecentTaskInfo`; however, in the early version, the return type appears to have been different (`UriPermission`). The late implementation aligns with the expected return type (`RecentTaskInfo`). This suggests changes not only in the implementation but potentially in the overall behavior and contract of the method, hence the change types are 1 (Return statement changed), 4 (Other statement changed), and 5 (Dependent API changed).","Since the type of the returned object has changed and the method now returns a different type of `ParceledListSlice`, there is a clear compatibility issue due to different return values or types. The API is no longer returning a list of permissions but instead is returning a list of recent tasks, thus the CI type is 1."
610,"<android.app.Notification.Builder: Builder setProgress(int,int,boolean)>",23,24,"<android.app.Notification.Builder: Builder setProgress(int,int,boolean)>","<android.app.Notification.Builder: Builder setProgress(int,int,boolean)>",0,"{
    mProgressMax = max;
    mProgress = progress;
    mProgressIndeterminate = indeterminate;
    return this;
}","{
    mN.extras.putInt(EXTRA_PROGRESS, progress);
    mN.extras.putInt(EXTRA_PROGRESS_MAX, max);
    mN.extras.putBoolean(EXTRA_PROGRESS_INDETERMINATE, indeterminate);
    return this;
}",1,"/**
 * Set the progress this notification represents.
 *
 * The platform template will represent this using a {@link ProgressBar}.
 */
","/**
 * Set the progress this notification represents.
 *
 * The platform template will represent this using a {@link ProgressBar}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The way progress is stored has changed from setting local variables directly to putting values in a Bundle (`mN.extras`). The affected fields of the Notification are EXTRA_PROGRESS, EXTRA_PROGRESS_MAX, and EXTRA_PROGRESS_INDETERMINATE. So, the code change type is 4,5.","Despite the internal handling of progress values changing, the method signature remains the same and it is still chainable as it returns 'this'. As the API contract regarding the method's input and output has not changed from a user's point of view and no exceptions are involved in either version, there should be no Compatibility Issue; therefore, the CI type is 0."
611,<android.app.DownloadManager.Request: ContentValues toContentValues(String)>,23,24,<android.app.DownloadManager.Request: ContentValues toContentValues(String)>,<android.app.DownloadManager.Request: ContentValues toContentValues(String)>,0,"{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, (this.mUseSystemCache) ? Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION : Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}","{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, (this.mUseSystemCache) ? Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION : Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_FLAGS, mFlags);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}",1,"/**
 * @return ContentValues to be passed to DownloadProvider.insert()
 */
","/**
 * @return ContentValues to be passed to DownloadProvider.insert()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the two implementations is the addition of a single line of code: `values.put(Downloads.Impl.COLUMN_FLAGS, mFlags);`. This represents an 'Other statement changed' which is under category 4.","There is no Compatibility Issue as the additional line does not affect the control flow, exception handling, or the method's return type. It only adds an additional key-value pair to the ContentValues object, which will not fundamentally change the behavior of the method in a way that would cause problems for existing clients of the API. It represents an added feature or property for the ContentValues returned."
612,<android.content.RestrictionsManager: Intent createLocalApprovalIntent()>,23,24,<android.content.RestrictionsManager: Intent createLocalApprovalIntent()>,<android.content.RestrictionsManager: Intent createLocalApprovalIntent()>,0,"{
    try {
        if (mService != null) {
            return mService.createLocalApprovalIntent();
        }
    } catch (RemoteException re) {
        Log.w(TAG, ""Couldn't reach service"");
    }
    return null;
}","{
    try {
        if (mService != null) {
            return mService.createLocalApprovalIntent();
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The change from logging the RemoteException to throwing it by using rethrowFromSystemServer() constitutes an exception handling statement change, hence the code change type is 2.","By altering the catch block to throw the exception, the method's behavior changes in how it handles errors; specifically, it doesn't just log the exception anymore but now throws it, potentially affecting the caller with an unhandled exception where there wasn't one before. This leads to a potential Compatibility Issue caused by different exception handlings, making the CI type 2."
614,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLength(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLength(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum allowed password length.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.  This
 * constraint is only imposed if the administrator has also requested either
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX},
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, {@link #PASSWORD_QUALITY_ALPHANUMERIC},
 * or {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum password length.  A value of 0
 * means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the minimum allowed password
 * length. After setting this, the user will not be able to enter a new password that is not at
 * least as restrictive as what has been set. Note that the current password will remain until
 * the user has set a new one, so the change does not take place immediately. To prompt the user
 * for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is
 * only imposed if the administrator has also requested either {@link #PASSWORD_QUALITY_NUMERIC}
 * , {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}, {@link #PASSWORD_QUALITY_ALPHABETIC},
 * {@link #PASSWORD_QUALITY_ALPHANUMERIC}, or {@link #PASSWORD_QUALITY_COMPLEX} with
 * {@link #setPasswordQuality}.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum password length. A value of 0 means there is no
 * restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The implementation has seen changes with the introduction of a new parameter 'mParentInstance' in the method call mService.setPasswordMinimumLength(admin, length, mParentInstance). Additionally, exception handling has changed from logging a warning to rethrowing the exception, so the change type includes 2 for exception handling statement changed, 4 for other statement changed (due to adding the parameter), and 5 for the change in the dependent API method signature.","The change in exception handling could result in different exception propagation in case of a RemoteException, leading to a CI type of 2 since the previous behavior was to log the exception rather than throwing it up the call stack."
615,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,23,24,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_WINDOW_ANIMATION_STARTED:
            return ""MSG_DISPATCH_WINDOW_ANIMATION_STARTED"";
        case MSG_DISPATCH_WINDOW_ANIMATION_STOPPED:
            return ""MSG_DISPATCH_WINDOW_ANIMATION_STOPPED"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version's switch case has added a new case MSG_UPDATE_POINTER_ICON with a corresponding return statement. This is a control dependency change type (3), and it also affects the return statement (1).",The addition of a new switch case (MSG_UPDATE_POINTER_ICON) with a corresponding return statement could lead to different return values if the message.what value equals MSG_UPDATE_POINTER_ICON. This is a Compatibility Issue caused by potential different return values (1).
616,<android.net.NetworkCapabilities: boolean equals(Object)>,23,24,<android.net.NetworkCapabilities: boolean equals(Object)>,<android.net.NetworkCapabilities: boolean equals(Object)>,0,"{
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSpecifier(that));
}","{
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement within the method has changed because a new condition 'equalsSignalStrength(that)' has been added to the logical AND operation in return expression, which affects the final returned value based on the new signal strength comparison functionality. So, the code change type is 1,4, which includes a return statement change and another statement changed that is not a control dependency or exception.",The addition of the new condition in the return statement can potentially cause this API to return different boolean values when comparing the signal strengths of two NetworkCapabilities objects in the late version. Hence the CI type is 1.
617,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViews getRemoteViewsAt(int)>,23,24,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViews getRemoteViewsAt(int)>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViews getRemoteViewsAt(int)>,0,"{
    if (mIndexRemoteViews.containsKey(position)) {
        return mIndexRemoteViews.get(position);
    }
    return null;
}","{
    return mIndexRemoteViews.get(position);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,0,"The control statement checking if the key is contained within mIndexRemoteViews before getting the value is removed. Now, the method directly returns the value associated with the key or null if the key is not found, which is the original behavior of the Map.get() method. This change simplifies the logic as the removed 'if' statement is redundant, hence the code change is of type 1.","The behavior of Map.get(key) includes returning null if the key does not exist in the map, which is identical to the behavior of the early version implementation. The change does not alter the return type or the value of what is returned, and therefore, there is no Compatibility Issue, resulting in type 0."
619,"<android.util.Log: int w(String,String,Throwable)>",23,24,"<android.util.Log: int w(String,String,Throwable)>","<android.util.Log: int w(String,String,Throwable)>",0,"{
    return println_native(LOG_ID_MAIN, WARN, tag, msg + '\n' + getStackTraceString(tr));
}","{
    return printlns(LOG_ID_MAIN, WARN, tag, msg, tr);
}",1,"/**
 * Send a {@link #WARN} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #WARN} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method has changed from println_native to printlns and the way parameters are passed has also changed (concatenated strings vs. separate parameters), therefore, the code change type is 1,5.","The change in the method and parameter format potentially changes how the method behaves, especially how the message and throwable stack trace are formatted and logged. This could result in a variant output. Hence, the CI type is 1."
620,"<android.accounts.AccountManager: void invalidateAuthToken(String,String)>",23,24,"<android.accounts.AccountManager: void invalidateAuthToken(String,String)>","<android.accounts.AccountManager: void invalidateAuthToken(String,String)>",0,"{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    try {
        if (authToken != null) {
            mService.invalidateAuthToken(accountType, authToken);
        }
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    try {
        if (authToken != null) {
            mService.invalidateAuthToken(accountType, authToken);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Removes an auth token from the AccountManager's cache.  Does nothing if
 * the auth token is not currently in the cache.  Applications must call this
 * method when the auth token is found to have expired or otherwise become
 * invalid for authenticating requests.  The AccountManager does not validate
 * or expire cached auth tokens otherwise.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS or USE_CREDENTIALS permission is needed for those
 * platforms. See docs for this function in API level 22.
 *
 * @param accountType The account type of the auth token to invalidate, must not be null
 * @param authToken The auth token to invalidate, may be null
 */
","/**
 * Removes an auth token from the AccountManager's cache.  Does nothing if
 * the auth token is not currently in the cache.  Applications must call this
 * method when the auth token is found to have expired or otherwise become
 * invalid for authenticating requests.  The AccountManager does not validate
 * or expire cached auth tokens otherwise.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS or USE_CREDENTIALS permission is needed for those
 * platforms. See docs for this function in API level 22.
 *
 * @param accountType The account type of the auth token to invalidate, must not be null
 * @param authToken The auth token to invalidate, may be null
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from throwing a new RuntimeException to throwing a rethrowFromSystemServer exception, so the code change type is 2.","The change in exception handling could lead to a different exception being thrown, so the CI type is 2."
621,<android.app.Notification.Builder: Builder setNumber(int)>,23,24,<android.app.Notification.Builder: Builder setNumber(int)>,<android.app.Notification.Builder: Builder setNumber(int)>,0,"{
    mNumber = number;
    return this;
}","{
    mN.number = number;
    return this;
}",1,"/**
 * Set the large number at the right-hand side of the notification.  This is
 * equivalent to setContentInfo, although it might show the number in a different
 * font size for readability.
 */
","/**
 * Set the large number at the right-hand side of the notification.  This is
 * equivalent to setContentInfo, although it might show the number in a different
 * font size for readability.
 *
 * @deprecated this number is not shown anywhere anymore
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The assignment statement has changed from directly setting the mNumber field to setting the number field of the object referenced by mN. So the code change type is 4.,"There is no compatibility issue because the method's contract has not changed. It still accepts an integer number, assigns it to an internal field, and returns the Builder object. The internal handling of the number assignment does not affect the public method's behavior. Thus, no CI is detected."
623,"<android.app.admin.DevicePolicyManager: List<PersistableBundle> getTrustAgentConfiguration(ComponentName,ComponentName)>",23,24,"<android.app.admin.DevicePolicyManager: List<PersistableBundle> getTrustAgentConfiguration(ComponentName,ComponentName)>","<android.app.admin.DevicePolicyManager: List<PersistableBundle> getTrustAgentConfiguration(ComponentName,ComponentName)>",0,"{
    return getTrustAgentConfiguration(admin, agent, UserHandle.myUserId());
}","{
    return getTrustAgentConfiguration(admin, agent, myUserId());
}",1,"/**
 * Gets configuration for the given trust agent based on aggregating all calls to
 * {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)} for
 * all device admins.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with. If null,
 * this function returns a list of configurations for all admins that declare
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS}. If any admin declares
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} but doesn't call
 * {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)}
 * for this {@param agent} or calls it with a null configuration, null is returned.
 * @param agent Which component to get enabled features for.
 * @return configuration for the given trust agent.
 */
","/**
 * Gets configuration for the given trust agent based on aggregating all calls to
 * {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)} for
 * all device admins.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to retrieve the configuration set
 * on the parent profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with. If null,
 * this function returns a list of configurations for all admins that declare
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS}. If any admin declares
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} but doesn't call
 * {@link #setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)}
 * for this {@param agent} or calls it with a null configuration, null is returned.
 * @param agent Which component to get enabled features for.
 * @return configuration for the given trust agent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method being called changed from getTrustAgentConfiguration(admin, agent, UserHandle.myUserId()) to getTrustAgentConfiguration(admin, agent, myUserId()). This indicates a change in how the user ID is obtained, likely due to a change in the dependent API (UserHandle.myUserId() to myUserId()), so the code change type is 5.","Assuming myUserId() is merely a shorthand for UserHandle.myUserId() and returns the same value, this change should not cause any difference in behavior or returned values from the API, so there is no Compatibility Issue, thus CI type is 0."
624,<android.widget.RelativeLayout: LayoutParams generateLayoutParams(LayoutParams)>,23,24,<android.widget.RelativeLayout: LayoutParams generateLayoutParams(LayoutParams)>,<android.widget.RelativeLayout: LayoutParams generateLayoutParams(LayoutParams)>,0,"{
    return new LayoutParams(p);
}","{
    if (lp instanceof LayoutParams) {
        return new LayoutParams((LayoutParams) lp);
    } else if (lp instanceof MarginLayoutParams) {
        return new LayoutParams((MarginLayoutParams) lp);
    } else {
        return new LayoutParams(lp);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method now includes control statements to check the type of the passed parameter 'lp' and creates a new LayoutParams accordingly, which did not exist in the earlier version. Additionally, the passed parameter itself has changed (from 'p' to 'lp'), and there is a new casting to ‘LayoutParams’ and 'MarginLayoutParams', so the code change types are 1, 3, and 5.","Considering that the method in the late version checks the type of 'lp' and creates different 'LayoutParams' based on this type, it can potentially return different values than the early version. Therefore, the CI type is 1."
625,"<android.os.DropBoxManager: void addData(String,byte[],int)>",23,24,"<android.os.DropBoxManager: void addData(String,byte[],int)>","<android.os.DropBoxManager: void addData(String,byte[],int)>",0,"{
    if (data == null)
        throw new NullPointerException(""data == null"");
    try {
        mService.add(new Entry(tag, 0, data, flags));
    } catch (RemoteException e) {
    }
}","{
    if (data == null)
        throw new NullPointerException(""data == null"");
    try {
        mService.add(new Entry(tag, 0, data, flags));
    } catch (RemoteException e) {
        if (e instanceof TransactionTooLargeException && mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data, so it was ignored"", e);
            return;
        }
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Stores binary data, which may be ignored or discarded as with {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 * @param flags describing the data
 */
","/**
 * Stores binary data, which may be ignored or discarded as with {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 * @param flags describing the data
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An additional condition check and handling for a specific type of RemoteException (TransactionTooLargeException) has been added in the late version. No return statements or dependent APIs have changed, but since there is a change in exception handling, the code change type is 2.","The late version adds specific behavior when a TransactionTooLargeException occurs and the target SDK version is below Android N (Nougat); it logs the error and returns early without throwing an exception. In the early version, all RemoteExceptions were caught silently, and execution continued. Thus, there is a potential different exception handling, and the CI type is 2."
626,<android.widget.TextView: float getRightFadingEdgeStrength()>,23,24,<android.widget.TextView: float getRightFadingEdgeStrength()>,<android.widget.TextView: float getRightFadingEdgeStrength()>,0,"{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            final float maxFadeScroll = marquee.getMaxFadeScroll();
            final float scroll = marquee.getScroll();
            return (maxFadeScroll - scroll) / getHorizontalFadingEdgeLength();
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    final int textWidth = (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight();
                    final float lineWidth = mLayout.getLineWidth(0);
                    return (lineWidth - textWidth) / getHorizontalFadingEdgeLength();
                case Gravity.RIGHT:
                    return 0.0f;
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    final int textDirection = mLayout.getParagraphDirection(0);
                    if (textDirection == Layout.DIR_RIGHT_TO_LEFT) {
                        return 0.0f;
                    } else {
                        return (mLayout.getLineWidth(0) - ((mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight())) / getHorizontalFadingEdgeLength();
                    }
            }
        }
    }
    return super.getRightFadingEdgeStrength();
}","{
    if (isMarqueeFadeEnabled() && mMarquee != null && !mMarquee.isStopped()) {
        final Marquee marquee = mMarquee;
        return getHorizontalFadingEdgeStrength(marquee.getMaxFadeScroll(), marquee.getScroll());
    } else if (getLineCount() == 1) {
        final float rightEdge = mScrollX + (getWidth() - getCompoundPaddingLeft() - getCompoundPaddingRight());
        final float lineRight = getLayout().getLineRight(0);
        if (lineRight < rightEdge)
            return 0.0f;
        return getHorizontalFadingEdgeStrength(rightEdge, lineRight);
    }
    return super.getRightFadingEdgeStrength();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The return statement has been altered significantly, with the removal of a branch checking mEllipsize and mMarqueeFadeMode, as well as removal of the switch statement that checks various gravities. This change affects the calculation of the returned value. There has been a change involving control dependency, as the checks and the switch statement are no longer present, and there are other statement changes, particularly in how the horizontal fading edge strength is calculated. Therefore, the change type is 1,3,4.","The change in return statements and the removal of the condition checking ensure that the API might now return a different value based on the new conditions and calculations introduced. This represents a potential compatibility issue caused by the potential return of different values, and the CI type is 1."
627,<android.os.UserManager: void setUserRestrictions(Bundle)>,23,24,<android.os.UserManager: void setUserRestrictions(Bundle)>,<android.os.UserManager: void setUserRestrictions(Bundle)>,0,"{
    setUserRestrictions(restrictions, Process.myUserHandle());
}","{
    throw new UnsupportedOperationException(""This method is no longer supported"");
}",1,"/**
 * Sets all the user-wide restrictions for this user.
 * Requires the MANAGE_USERS permission.
 * @param restrictions the Bundle containing all the restrictions.
 * @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(
 * android.content.ComponentName, String)} or
 * {@link android.app.admin.DevicePolicyManager#clearUserRestriction(
 * android.content.ComponentName, String)} instead.
 */
","// System apps should use UserManager.setUserRestriction() instead.
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,2,2,"The method implementation has changed completely. It's now throwing an UnsupportedOperationException, where before it was calling setUserRestrictions(restrictions, Process.myUserHandle()). So the code change type is 2.","Since all calls to this method will result in an UnsupportedOperationException in the late version, which is a clear and direct change from its previous functionality, the CI type is 2."
628,<android.widget.Editor.SuggestionsPopupWindow: void initContentView()>,23,24,<android.widget.Editor.SuggestionsPopupWindow: void initContentView()>,<android.widget.Editor.SuggestionsPopupWindow: void initContentView()>,0,"{
    ListView listView = new ListView(mTextView.getContext());
    mSuggestionsAdapter = new SuggestionAdapter();
    listView.setAdapter(mSuggestionsAdapter);
    listView.setOnItemClickListener(this);
    mContentView = listView;
    // Inflate the suggestion items once and for all. + 2 for add to dictionary and delete
    mSuggestionInfos = new SuggestionInfo[MAX_NUMBER_SUGGESTIONS + 2];
    for (int i = 0; i < mSuggestionInfos.length; i++) {
        mSuggestionInfos[i] = new SuggestionInfo();
    }
}","{
    final LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    mContentView = (ViewGroup) inflater.inflate(mTextView.mTextEditSuggestionContainerLayout, null);
    mContainerView = (LinearLayout) mContentView.findViewById(com.android.internal.R.id.suggestionWindowContainer);
    ViewGroup.MarginLayoutParams lp = (ViewGroup.MarginLayoutParams) mContainerView.getLayoutParams();
    mContainerMarginWidth = lp.leftMargin + lp.rightMargin;
    mContainerMarginTop = lp.topMargin;
    mClippingLimitLeft = lp.leftMargin;
    mClippingLimitRight = lp.rightMargin;
    mSuggestionListView = (ListView) mContentView.findViewById(com.android.internal.R.id.suggestionContainer);
    mSuggestionsAdapter = new SuggestionAdapter();
    mSuggestionListView.setAdapter(mSuggestionsAdapter);
    mSuggestionListView.setOnItemClickListener(this);
    // Inflate the suggestion items once and for all.
    mSuggestionInfos = new SuggestionInfo[MAX_NUMBER_SUGGESTIONS];
    for (int i = 0; i < mSuggestionInfos.length; i++) {
        mSuggestionInfos[i] = new SuggestionInfo();
    }
    mAddToDictionaryButton = (TextView) mContentView.findViewById(com.android.internal.R.id.addToDictionaryButton);
    mAddToDictionaryButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            final SuggestionSpan misspelledSpan = findEquivalentSuggestionSpan(mMisspelledSpanInfo);
            if (misspelledSpan == null) {
                // Span has been removed.
                return;
            }
            final Editable editable = (Editable) mTextView.getText();
            final int spanStart = editable.getSpanStart(misspelledSpan);
            final int spanEnd = editable.getSpanEnd(misspelledSpan);
            if (spanStart < 0 || spanEnd <= spanStart) {
                return;
            }
            final String originalText = TextUtils.substring(editable, spanStart, spanEnd);
            final Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
            intent.putExtra(USER_DICTIONARY_EXTRA_WORD, originalText);
            intent.putExtra(USER_DICTIONARY_EXTRA_LOCALE, mTextView.getTextServicesLocale().toString());
            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
            mTextView.getContext().startActivity(intent);
            // There is no way to know if the word was indeed added. Re-check.
            // TODO The ExtractEditText should remove the span in the original text instead
            editable.removeSpan(mMisspelledSpanInfo.mSuggestionSpan);
            Selection.setSelection(editable, spanEnd);
            updateSpellCheckSpans(spanStart, spanEnd, false);
            hideWithCleanUp();
        }
    });
    mDeleteButton = (TextView) mContentView.findViewById(com.android.internal.R.id.deleteButton);
    mDeleteButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            final Editable editable = (Editable) mTextView.getText();
            final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
            int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
            if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
                // text
                if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                    spanUnionEnd = spanUnionEnd + 1;
                }
                mTextView.deleteText_internal(spanUnionStart, spanUnionEnd);
            }
            hideWithCleanUp();
        }
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The entire implementation of the initContentView() method has been rewritten, which includes changes to the instantiation process of the ListView and its associated SuggestionAdapter, as well as the organization of components within the contentView. There are numerous statements including variable assignments and method invocations that have been added or removed. This constitutes a control dependency change because the flow of how components are initialized has been altered, and an other statement changed because the specific instructions that achieve the method's outcome have been altered.","Despite the extensive changes in the method's implementation, there is no indication that these changes would lead to a Compatibility Issue. The method's responsibility is to initialize a view content, and as long as the resulting view is correctly initialized, these internal changes should not affect the behavior as observed by the method caller. The method's signature remains the same, it still does not return a value (it's a void method), and it does not throw any new checked exceptions. Therefore, based on the information provided, the changes should not introduce compatibility issues."
629,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,23,24,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,0,"{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        try {
            mRemoteDevice.tearDown(streamId);
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return;
        }
    }
}","{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.tearDown(streamId);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement for RemoteException has been removed, which is of the category 2.","This code change might lead to a different exception thrown in the situation where a RemoteException occurs. In the early version, catching this exception results in a simple return, while in the late version, the exception is no longer caught, which potentially allows it to propagate up the call stack. Hence, the CI type is 2, suggesting a possible difference in exception handling between the two versions."
630,<android.accessibilityservice.AccessibilityService: boolean performGlobalAction(int)>,23,24,<android.accessibilityservice.AccessibilityService: boolean performGlobalAction(int)>,<android.accessibilityservice.AccessibilityService: boolean performGlobalAction(int)>,0,"{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.performGlobalAction(action);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while calling performGlobalAction"", re);
        }
    }
    return false;
}","{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.performGlobalAction(action);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while calling performGlobalAction"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Performs a global action. Such an action can be performed
 * at any moment regardless of the current application or user
 * location in that application. For example going back, going
 * home, opening recents, etc.
 *
 * @param action The action to perform.
 * @return Whether the action was successfully performed.
 *
 * @see #GLOBAL_ACTION_BACK
 * @see #GLOBAL_ACTION_HOME
 * @see #GLOBAL_ACTION_NOTIFICATIONS
 * @see #GLOBAL_ACTION_RECENTS
 */
","/**
 * Performs a global action. Such an action can be performed
 * at any moment regardless of the current application or user
 * location in that application. For example going back, going
 * home, opening recents, etc.
 *
 * @param action The action to perform.
 * @return Whether the action was successfully performed.
 *
 * @see #GLOBAL_ACTION_BACK
 * @see #GLOBAL_ACTION_HOME
 * @see #GLOBAL_ACTION_NOTIFICATIONS
 * @see #GLOBAL_ACTION_RECENTS
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has been added (re.rethrowFromSystemServer()), so the code change type is 2.","The addition of the statement (re.rethrowFromSystemServer()) after catching a RemoteException introduces a behavior where an unchecked exception is likely to be thrown, rather than just logging the error as in the earlier version. Hence, this change may cause a different exception handling in the API usage and the CI type is 2."
632,"<android.view.FocusFinder.SequentialFocusComparator: int compare(View,View)>",23,24,"<android.view.FocusFinder.SequentialFocusComparator: int compare(View,View)>","<android.view.FocusFinder.SequentialFocusComparator: int compare(View,View)>",0,"{
    if (first == second) {
        return 0;
    }
    getRect(first, mFirstRect);
    getRect(second, mSecondRect);
    if (mFirstRect.top < mSecondRect.top) {
        return -1;
    } else if (mFirstRect.top > mSecondRect.top) {
        return 1;
    } else if (mFirstRect.left < mSecondRect.left) {
        return mIsLayoutRtl ? 1 : -1;
    } else if (mFirstRect.left > mSecondRect.left) {
        return mIsLayoutRtl ? -1 : 1;
    } else if (mFirstRect.bottom < mSecondRect.bottom) {
        return -1;
    } else if (mFirstRect.bottom > mSecondRect.bottom) {
        return 1;
    } else if (mFirstRect.right < mSecondRect.right) {
        return mIsLayoutRtl ? 1 : -1;
    } else if (mFirstRect.right > mSecondRect.right) {
        return mIsLayoutRtl ? -1 : 1;
    } else {
        // means that the views will retain their layout order relative to one another.
        return 0;
    }
}","{
    if (first == second) {
        return 0;
    }
    // Order between views within a chain is immaterial -- next/previous is
    // within a chain is handled elsewhere.
    View firstHead = mHeadsOfChains.get(first);
    View secondHead = mHeadsOfChains.get(second);
    if (firstHead == secondHead && firstHead != null) {
        if (first == firstHead) {
            // first is the head, it should be first
            return -1;
        } else if (second == firstHead) {
            // second is the head, it should be first
            return 1;
        } else if (isValidId(first.getNextFocusForwardId())) {
            // first is not the end of the chain
            return -1;
        } else {
            // first is end of chain
            return 1;
        }
    }
    if (firstHead != null) {
        first = firstHead;
    }
    if (secondHead != null) {
        second = secondHead;
    }
    // First see if they belong to the same focus chain.
    getRect(first, mFirstRect);
    getRect(second, mSecondRect);
    if (mFirstRect.top < mSecondRect.top) {
        return -1;
    } else if (mFirstRect.top > mSecondRect.top) {
        return 1;
    } else if (mFirstRect.left < mSecondRect.left) {
        return mIsLayoutRtl ? 1 : -1;
    } else if (mFirstRect.left > mSecondRect.left) {
        return mIsLayoutRtl ? -1 : 1;
    } else if (mFirstRect.bottom < mSecondRect.bottom) {
        return -1;
    } else if (mFirstRect.bottom > mSecondRect.bottom) {
        return 1;
    } else if (mFirstRect.right < mSecondRect.right) {
        return mIsLayoutRtl ? 1 : -1;
    } else if (mFirstRect.right > mSecondRect.right) {
        return mIsLayoutRtl ? -1 : 1;
    } else {
        // means that the views will retain their layout order relative to one another.
        return 0;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3, 4",1,"Control dependency has changed due to the new logic related to the handling of the 'heads of chains', and also some statements within the control statements are different. Additionally, although the majority of the logic past the initial chain head checks remains the same, the addition of the checks for 'heads of chains' could cause the method to return different values. Therefore, it's a combination of code change types 3 and 4.","The new checks introduced at the beginning of the 'compare' method could lead to a different outcome, potentially changing the return value when comparing two View objects in certain conditions. This means that the API will return a different value for cases that were not previously accounted for, hence the CI type is 1."
633,<android.os.PowerManager: boolean isIgnoringBatteryOptimizations(String)>,23,24,<android.os.PowerManager: boolean isIgnoringBatteryOptimizations(String)>,<android.os.PowerManager: boolean isIgnoringBatteryOptimizations(String)>,0,"{
    synchronized (this) {
        if (mIDeviceIdleController == null) {
            mIDeviceIdleController = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
        }
    }
    try {
        return mIDeviceIdleController.isPowerSaveWhitelistApp(packageName);
    } catch (RemoteException e) {
        return false;
    }
}","{
    synchronized (this) {
        if (mIDeviceIdleController == null) {
            mIDeviceIdleController = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
        }
    }
    try {
        return mIDeviceIdleController.isPowerSaveWhitelistApp(packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return whether the given application package name is on the device's power whitelist.
 * Apps can be placed on the whitelist through the settings UI invoked by
 * {@link android.provider.Settings#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS}.
 */
","/**
 * Return whether the given application package name is on the device's power whitelist.
 * Apps can be placed on the whitelist through the settings UI invoked by
 * {@link android.provider.Settings#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, with the late version throwing a new exception (`e.rethrowFromSystemServer()`) rather than returning false, so the change type is 2.","As the late version throws a new exception rather than returning false in the case of RemoteException, it could lead to a different exception being thrown, and the client code that depends on this API may break if it expects a boolean result. Therefore, the CI type is 2."
634,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,23,24,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,0,"{
    if (LOGD)
        Log.d(TAG, ""updateAppWidget called mOld="" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext();
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, ""was able to recycled existing layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, ""had to inflate new layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, ""updateAppWidget couldn't find any view, using error view"", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}","{
    applyRemoteViews(remoteViews);
}",1,"/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
","/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire block of code inside the early version's method has been replaced by a single method call to applyRemoteViews(remoteViews) in the late version, so the code change types are: 1 (the `return` logic within the method has changed due to refactoring), 4 (the other statements within the method are no longer present, representing a change), and 5 (the change represents a dependent API change, as the implementation now depends on the applyRemoteViews method).","A Compatibility Issue can arise because the return value or type may have changed due to the refactoring of the code into a new method, applyRemoteViews(remoteViews). The new method could have different logic for returning or handling views, thus CI type is 1."
635,<android.app.admin.DevicePolicyManager: int getPasswordQuality(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPasswordQuality(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordQuality(ComponentName)>,0,"{
    return getPasswordQuality(admin, UserHandle.myUserId());
}","{
    return getPasswordQuality(admin, myUserId());
}",1,"/**
 * Retrieve the current minimum password quality for all admins of this user
 * and its profiles or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
","/**
 * Retrieve the current minimum password quality for a particular admin or all admins that set
 * retrictions on this user and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from calling UserHandle.myUserId() to calling myUserId() directly, which indicates a dependent API change, so the code change type is 5.","There is no new return statement or exception handling statement introduced and no old return statement or exception handling statement deleted. The change is purely a dependent API call change, which does not necessarily mean the behaviour of the API has changed. Therefore, there is no CI detected here, and the CI type is 0."
636,<android.service.notification.ZenModeConfig.ZenRule: boolean equals(Object)>,23,24,<android.service.notification.ZenModeConfig.ZenRule: boolean equals(Object)>,<android.service.notification.ZenModeConfig.ZenRule: boolean equals(Object)>,0,"{
    if (!(o instanceof ZenRule))
        return false;
    if (o == this)
        return true;
    final ZenRule other = (ZenRule) o;
    return other.enabled == enabled && other.snoozing == snoozing && Objects.equals(other.name, name) && other.zenMode == zenMode && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.condition, condition) && Objects.equals(other.component, component);
}","{
    if (!(o instanceof ZenRule))
        return false;
    if (o == this)
        return true;
    final ZenRule other = (ZenRule) o;
    return other.enabled == enabled && other.snoozing == snoozing && Objects.equals(other.name, name) && other.zenMode == zenMode && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.condition, condition) && Objects.equals(other.component, component) && Objects.equals(other.id, id) && other.creationTime == creationTime;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There were additional comparisons added to the return statement. Specifically, `Objects.equals(other.id, id)` and `other.creationTime == creationTime` were added in the late implementation. This change is of type 4 because it involves comparisons but does not fit the criteria for return statement changed, exception handling statement changed, control dependency changed, or dependent API changed strictly as defined.","The added comparisons to `other.id` and `other.creationTime` can potentially result in the method returning a different value, since equals could now return false in cases where it would have previously returned true due to different `id` or `creationTime`. Therefore, the CI type is 1."
637,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraLooper: int waitForOpen(int)>,23,24,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraLooper: int waitForOpen(int)>,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraLooper: int waitForOpen(int)>,0,"{
    // Block until the camera is open asynchronously
    if (!mStartDone.block(timeoutMs)) {
        Log.e(TAG, ""waitForOpen - Camera failed to open after timeout of "" + OPEN_CAMERA_TIMEOUT_MS + "" ms"");
        try {
            mCamera.release();
        } catch (RuntimeException e) {
            Log.e(TAG, ""connectBinderShim - Failed to release camera after timeout "", e);
        }
        throw new CameraRuntimeException(CameraAccessException.CAMERA_ERROR);
    }
    return mInitErrors;
}","{
    // Block until the camera is open asynchronously
    if (!mStartDone.block(timeoutMs)) {
        Log.e(TAG, ""waitForOpen - Camera failed to open after timeout of "" + OPEN_CAMERA_TIMEOUT_MS + "" ms"");
        try {
            mCamera.release();
        } catch (RuntimeException e) {
            Log.e(TAG, ""connectBinderShim - Failed to release camera after timeout "", e);
        }
        throw new ServiceSpecificException(ICameraService.ERROR_INVALID_OPERATION);
    }
    return mInitErrors;
}",1,"/**
 * Block until the camera opens; then return its initialization error code (if any).
 *
 * @param timeoutMs timeout in milliseconds
 *
 * @return int error code
 *
 * @throws CameraRuntimeException if the camera open times out with ({@code CAMERA_ERROR})
 */
","/**
 * Block until the camera opens; then return its initialization error code (if any).
 *
 * @param timeoutMs timeout in milliseconds
 *
 * @return int error code
 *
 * @throws ServiceSpecificException if the camera open times out with ({@code CAMERA_ERROR})
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The exception thrown has changed from CameraRuntimeException to ServiceSpecificException, which means both the return statements and exception handling statements have been changed. Therefore, the code change type is 1,2.","The change from throwing CameraRuntimeException to ServiceSpecificException leads to a different exception being thrown under the same circumstances, so this is a CI caused by potential different exception handlings. This, combined with the fact that no other changes have been made to the return values, amounts to CI type 1 for potential different return values (even though the returned values are the same, the control flow change due to exception type alters the behavior) and CI type 2 for potential different exception handlings."
638,<android.hardware.camera2.legacy.LegacyExceptionUtils: int throwOnError(int)>,23,24,<android.hardware.camera2.legacy.LegacyExceptionUtils: int throwOnError(int)>,<android.hardware.camera2.legacy.LegacyExceptionUtils: int throwOnError(int)>,0,"{
    switch(errorFlag) {
        case CameraBinderDecorator.NO_ERROR:
            {
                return CameraBinderDecorator.NO_ERROR;
            }
        case CameraBinderDecorator.BAD_VALUE:
            {
                throw new BufferQueueAbandonedException();
            }
    }
    if (errorFlag < 0) {
        throw new UnsupportedOperationException(""Unknown error "" + errorFlag);
    }
    return errorFlag;
}","{
    if (errorFlag == NO_ERROR) {
        return NO_ERROR;
    } else if (errorFlag == -ENODEV) {
        throw new BufferQueueAbandonedException();
    }
    if (errorFlag < 0) {
        throw new UnsupportedOperationException(""Unknown error "" + errorFlag);
    }
    return errorFlag;
}",1,"/**
 * Throw error codes used by legacy device methods as exceptions.
 *
 * <p>Non-negative return values are passed through, negative return values are thrown as
 * exceptions.</p>
 *
 * @param errorFlag error to throw as an exception.
 * @throws {@link BufferQueueAbandonedException} for {@link CameraBinderDecorator#ENODEV}.
 * @throws {@link UnsupportedOperationException} for an unknown negative error code.
 * @return {@code errorFlag} if the value was non-negative, throws otherwise.
 */
","/**
 * Throw error codes used by legacy device methods as exceptions.
 *
 * <p>Non-negative return values are passed through, negative return values are thrown as
 * exceptions.</p>
 *
 * @param errorFlag error to throw as an exception.
 * @throws {@link BufferQueueAbandonedException} for -ENODEV.
 * @throws {@link UnsupportedOperationException} for an unknown negative error code.
 * @return {@code errorFlag} if the value was non-negative, throws otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The switch case has been replaced by if-else conditions in the late version, which constitutes a control dependency change (3). Also, the CameraBinderDecorator.BAD_VALUE constant is replaced by -ENODEV in the error check, and the condition CameraBinderDecorator.NO_ERROR is changed to NO_ERROR which may potentially be a different constant (though we cannot confirm without additional context). It also seems a dependent API change, but since NO_ERROR and -ENODEV are not explicitly described as being from a different API, we only consider it a return statement changed (1) due to the restructuring of control flow and possible introduce of a new value for error check.","Compatibility Issue could arise due to the change in control flow—the removal of the switch statement and introduction of if-else statements—and the potential introduction of a new comparison value (-ENODEV in place of CameraBinderDecorator.BAD_VALUE) could alter which exceptions are thrown under certain conditions, leading to a different exception being thrown for the same error condition received. It also alters the scenario when 'return' is executed. Thus, the CI type is 1."
639,<android.hardware.camera2.impl.CameraDeviceImpl: void setRemoteDevice(ICameraDeviceUser)>,23,24,<android.hardware.camera2.impl.CameraDeviceImpl: void setRemoteDevice(ICameraDeviceUser)>,<android.hardware.camera2.impl.CameraDeviceImpl: void setRemoteDevice(ICameraDeviceUser)>,0,"{
    synchronized (mInterfaceLock) {
        // If setRemoteFailure already called, do nothing
        if (mInError)
            return;
        mRemoteDevice = CameraBinderDecorator.newInstance(remoteDevice);
        mDeviceHandler.post(mCallOnOpened);
        mDeviceHandler.post(mCallOnUnconfigured);
    }
}","{
    synchronized (mInterfaceLock) {
        // If setRemoteFailure already called, do nothing
        if (mInError)
            return;
        mRemoteDevice = new ICameraDeviceUserWrapper(remoteDevice);
        IBinder remoteDeviceBinder = remoteDevice.asBinder();
        // asBinder returns NULL.
        if (remoteDeviceBinder != null) {
            try {
                remoteDeviceBinder.linkToDeath(this, /*flag*/
                0);
            } catch (RemoteException e) {
                CameraDeviceImpl.this.mDeviceHandler.post(mCallOnDisconnected);
                throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""The camera device has encountered a serious error"");
            }
        }
        mDeviceHandler.post(mCallOnOpened);
        mDeviceHandler.post(mCallOnUnconfigured);
    }
}",1,,"/**
 * Set remote device, which triggers initial onOpened/onUnconfigured callbacks
 *
 * <p>This function may post onDisconnected and throw CAMERA_DISCONNECTED if remoteDevice dies
 * during setup.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",The late version introduces several changes:,"- Inside the if statement, there's a call to linkToDeath with exception handling in a try-catch block, where in case of a RemoteException, it posts mCallOnDisconnected and throws a new CameraAccessException."
640,<android.app.ContextImpl: File getCodeCacheDir()>,23,24,<android.app.ContextImpl: File getCodeCacheDir()>,<android.app.ContextImpl: File getCodeCacheDir()>,0,"{
    synchronized (mSync) {
        if (mCodeCacheDir == null) {
            mCodeCacheDir = new File(getDataDirFile(), ""code_cache"");
        }
        return createFilesDirLocked(mCodeCacheDir);
    }
}","{
    synchronized (mSync) {
        if (mCodeCacheDir == null) {
            mCodeCacheDir = new File(getDataDir(), ""code_cache"");
        }
        return ensurePrivateDirExists(mCodeCacheDir);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The name of the function called to obtain the data directory has changed from getDataDirFile() to getDataDir(), and the name of the function called to ensure the directory exists has changed from createFilesDirLocked() to ensurePrivateDirExists(). Therefore, the change type is 4,5.","The change does not imply that the API will return a different value or throw a different exception because the semantic of those method calls are likely to be the same: both are aimed at getting the data directory and ensuring the code cache directory exists. Thus, the compatibility issue type is 0."
641,<android.app.NativeActivity: void onCreate(Bundle)>,23,24,<android.app.NativeActivity: void onCreate(Bundle)>,<android.app.NativeActivity: void onCreate(Bundle)>,0,"{
    String libname = ""main"";
    String funcname = ""ANativeActivity_onCreate"";
    ActivityInfo ai;
    mIMM = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
    getWindow().takeSurface(this);
    getWindow().takeInputQueue(this);
    getWindow().setFormat(PixelFormat.RGB_565);
    getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
    mNativeContentView = new NativeContentView(this);
    mNativeContentView.mActivity = this;
    setContentView(mNativeContentView);
    mNativeContentView.requestFocus();
    mNativeContentView.getViewTreeObserver().addOnGlobalLayoutListener(this);
    try {
        ai = getPackageManager().getActivityInfo(getIntent().getComponent(), PackageManager.GET_META_DATA);
        if (ai.metaData != null) {
            String ln = ai.metaData.getString(META_DATA_LIB_NAME);
            if (ln != null)
                libname = ln;
            ln = ai.metaData.getString(META_DATA_FUNC_NAME);
            if (ln != null)
                funcname = ln;
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException(""Error getting activity info"", e);
    }
    String path = null;
    File libraryFile = new File(ai.applicationInfo.nativeLibraryDir, System.mapLibraryName(libname));
    if (libraryFile.exists()) {
        path = libraryFile.getPath();
    }
    if (path == null) {
        throw new IllegalArgumentException(""Unable to find native library: "" + libname);
    }
    byte[] nativeSavedState = savedInstanceState != null ? savedInstanceState.getByteArray(KEY_NATIVE_SAVED_STATE) : null;
    mNativeHandle = loadNativeCode(path, funcname, Looper.myQueue(), getAbsolutePath(getFilesDir()), getAbsolutePath(getObbDir()), getAbsolutePath(getExternalFilesDir(null)), Build.VERSION.SDK_INT, getAssets(), nativeSavedState);
    if (mNativeHandle == 0) {
        throw new IllegalArgumentException(""Unable to load native library: "" + path);
    }
    super.onCreate(savedInstanceState);
}","{
    String libname = ""main"";
    String funcname = ""ANativeActivity_onCreate"";
    ActivityInfo ai;
    mIMM = getSystemService(InputMethodManager.class);
    getWindow().takeSurface(this);
    getWindow().takeInputQueue(this);
    getWindow().setFormat(PixelFormat.RGB_565);
    getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
    mNativeContentView = new NativeContentView(this);
    mNativeContentView.mActivity = this;
    setContentView(mNativeContentView);
    mNativeContentView.requestFocus();
    mNativeContentView.getViewTreeObserver().addOnGlobalLayoutListener(this);
    try {
        ai = getPackageManager().getActivityInfo(getIntent().getComponent(), PackageManager.GET_META_DATA);
        if (ai.metaData != null) {
            String ln = ai.metaData.getString(META_DATA_LIB_NAME);
            if (ln != null)
                libname = ln;
            ln = ai.metaData.getString(META_DATA_FUNC_NAME);
            if (ln != null)
                funcname = ln;
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException(""Error getting activity info"", e);
    }
    BaseDexClassLoader classLoader = (BaseDexClassLoader) getClassLoader();
    String path = classLoader.findLibrary(libname);
    if (path == null) {
        throw new IllegalArgumentException(""Unable to find native library "" + libname + "" using classloader: "" + classLoader.toString());
    }
    byte[] nativeSavedState = savedInstanceState != null ? savedInstanceState.getByteArray(KEY_NATIVE_SAVED_STATE) : null;
    mNativeHandle = loadNativeCode(path, funcname, Looper.myQueue(), getAbsolutePath(getFilesDir()), getAbsolutePath(getObbDir()), getAbsolutePath(getExternalFilesDir(null)), Build.VERSION.SDK_INT, getAssets(), nativeSavedState, classLoader, classLoader.getLdLibraryPath());
    if (mNativeHandle == 0) {
        throw new UnsatisfiedLinkError(""Unable to load native library \"""" + path + ""\"": "" + getDlError());
    }
    super.onCreate(savedInstanceState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2",The code changes are as follows:,"3. The parameters for the loadNativeCode method call have changed, adding two new parameters: classLoader and classLoader.getLdLibraryPath() (5)."
642,<android.app.Notification.Builder: Builder setSound(Uri)>,23,24,<android.app.Notification.Builder: Builder setSound(Uri)>,<android.app.Notification.Builder: Builder setSound(Uri)>,0,"{
    mSound = sound;
    mAudioAttributes = AUDIO_ATTRIBUTES_DEFAULT;
    return this;
}","{
    mN.sound = sound;
    mN.audioAttributes = AUDIO_ATTRIBUTES_DEFAULT;
    return this;
}",1,"/**
 * Set the sound to play.
 *
 * It will be played using the {@link #AUDIO_ATTRIBUTES_DEFAULT default audio attributes}
 * for notifications.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 *
 * @see Notification#sound
 */
","/**
 * Set the sound to play.
 *
 * It will be played using the {@link #AUDIO_ATTRIBUTES_DEFAULT default audio attributes}
 * for notifications.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 *
 * @see Notification#sound
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignments have changed to refer different variables (mSound to mN.sound and mAudioAttributes to mN.audioAttributes), thus the change type is 4.","Since the variables mSound and mAudioAttributes appear to be fields of the Builder class, and these fields are changed to mN.sound and mN.audioAttributes (likely fields of an encapsulating type mN), as long as mN is correctly referring to the Notification object inside Builder, the behavior remains the same. Therefore, no Compatibility Issue should arise because the method still sets the sound on the Notification being built and returns 'this' Builder."
643,"<android.content.res.TypedArray: TypedArray obtain(Resources,int)>",23,24,"<android.content.res.TypedArray: TypedArray obtain(Resources,int)>","<android.content.res.TypedArray: TypedArray obtain(Resources,int)>",0,"{
    final TypedArray attrs = res.mTypedArrayPool.acquire();
    if (attrs != null) {
        attrs.mLength = len;
        attrs.mRecycled = false;
        final int fullLen = len * AssetManager.STYLE_NUM_ENTRIES;
        if (attrs.mData.length >= fullLen) {
            return attrs;
        }
        attrs.mData = new int[fullLen];
        attrs.mIndices = new int[1 + len];
        return attrs;
    }
    return new TypedArray(res, new int[len * AssetManager.STYLE_NUM_ENTRIES], new int[1 + len], len);
}","{
    final TypedArray attrs = res.mTypedArrayPool.acquire();
    if (attrs != null) {
        attrs.mLength = len;
        attrs.mRecycled = false;
        // Reset the assets, which may have changed due to configuration changes
        // or further resource loading.
        attrs.mAssets = res.getAssets();
        final int fullLen = len * AssetManager.STYLE_NUM_ENTRIES;
        if (attrs.mData.length >= fullLen) {
            return attrs;
        }
        attrs.mData = new int[fullLen];
        attrs.mIndices = new int[1 + len];
        return attrs;
    }
    return new TypedArray(res, new int[len * AssetManager.STYLE_NUM_ENTRIES], new int[1 + len], len);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an additional statement added that sets attrs.mAssets to res.getAssets(). This is not part of the return, exception handling, or control dependency statements, so the code change type is 4.","The change is an assignment to a field of the object `attrs` that does not affect the API's return value or exception handling; it only alters the internal state of `attrs`. Therefore, this does not introduce a Compatibility Issue, and the CI type is 0."
645,<android.widget.CalendarViewLegacyDelegate: int getUnfocusedMonthDateColor()>,23,24,<android.widget.CalendarViewLegacyDelegate: int getUnfocusedMonthDateColor()>,<android.widget.CalendarViewLegacyDelegate: int getUnfocusedMonthDateColor()>,0,"{
    return mFocusedMonthDateColor;
}","{
    return mUnfocusedMonthDateColor;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning mFocusedMonthDateColor to mUnfocusedMonthDateColor, so the code change type is 1.","The change in the return statement means the API now returns a different variable, resulting in a different behavior, so the CI type is 1."
647,"<android.hardware.camera2.legacy.SurfaceTextureRenderer: void configureSurfaces(Collection<Pair<Surface, Size>>)>",23,24,"<android.hardware.camera2.legacy.SurfaceTextureRenderer: void configureSurfaces(Collection<Pair<Surface, Size>>)>","<android.hardware.camera2.legacy.SurfaceTextureRenderer: void configureSurfaces(Collection<Pair<Surface, Size>>)>",0,"{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, ""No output surfaces configured for GL drawing."");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, ""Surface abandoned, skipping configuration... "", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}","{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, ""No output surfaces configured for GL drawing."");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
                // LegacyCameraDevice is the producer of surfaces if it's not handled by EGL,
                // so LegacyCameraDevice needs to connect to the surfaces.
                LegacyCameraDevice.connectSurface(s);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, ""Surface abandoned, skipping configuration... "", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}",1,"/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */
","/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes the addition of a new method call (LegacyCameraDevice.connectSurface(s)) inside an existing 'if' block, so the change type is 4. This change is also an addition to a dependent API (LegacyCameraDevice), so it is classified as 5 as well.","There is no return value change nor any exception handling change at the API usage level in the implementation, so there is no compatibility issue. The new method call to connectSurface(s) most likely prepares the surface internally, but since it does not change the behavior from the caller's perspective in terms of return values or thrown exceptions, we assume there is no compatibility issue and classify it as 0."
648,"<android.app.admin.DevicePolicyManager: boolean addCrossProfileWidgetProvider(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: boolean addCrossProfileWidgetProvider(ComponentName,String)>","<android.app.admin.DevicePolicyManager: boolean addCrossProfileWidgetProvider(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            return mService.addCrossProfileWidgetProvider(admin, packageName);
        } catch (RemoteException re) {
            Log.w(TAG, ""Error calling addCrossProfileWidgetProvider"", re);
        }
    }
    return false;
}","{
    throwIfParentInstance(""addCrossProfileWidgetProvider"");
    if (mService != null) {
        try {
            return mService.addCrossProfileWidgetProvider(admin, packageName);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by the profile owner of a managed profile to enable widget providers from a
 * given package to be available in the parent profile. As a result the user will be able to
 * add widgets from the white-listed package running under the profile to a widget
 * host which runs under the parent profile, for example the home screen. Note that
 * a package may have zero or more provider components, where each component
 * provides a different widget type.
 * <p>
 * <strong>Note:</strong> By default no widget provider package is white-listed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The package from which widget providers are white-listed.
 * @return Whether the package was added.
 *
 * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)
 * @see #getCrossProfileWidgetProviders(android.content.ComponentName)
 */
","/**
 * Called by the profile owner of a managed profile to enable widget providers from a given
 * package to be available in the parent profile. As a result the user will be able to add
 * widgets from the white-listed package running under the profile to a widget host which runs
 * under the parent profile, for example the home screen. Note that a package may have zero or
 * more provider components, where each component provides a different widget type.
 * <p>
 * <strong>Note:</strong> By default no widget provider package is white-listed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The package from which widget providers are white-listed.
 * @return Whether the package was added.
 * @throws SecurityException if {@code admin} is not a profile owner.
 * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)
 * @see #getCrossProfileWidgetProviders(android.content.ComponentName)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The method now starts with a call to ""throwIfParentInstance"" which is a new method call (Other statement changed), and the original exception handling logic for `RemoteException` has been modified to throw the exception instead of logging it (Exception handling statement changed), so the code change type is 2,4.","As the exception handling for `RemoteException` now throws the exception rather than just logging it, this could lead to different behavior if an exception occurs, and therefore the CI type is 2."
651,<android.app.Fragment: void performResume()>,23,24,<android.app.Fragment: void performResume()>,<android.app.Fragment: void performResume()>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
        mChildFragmentManager.execPendingActions();
    }
    mCalled = false;
    onResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onResume()"");
    }
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchResume();
        mChildFragmentManager.execPendingActions();
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
        mChildFragmentManager.execPendingActions();
    }
    mState = RESUMED;
    mCalled = false;
    onResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onResume()"");
    }
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchResume();
        mChildFragmentManager.execPendingActions();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new statement `mState = RESUMED;` added to the late version, which is neither a return statement, exception handling statement, nor a control dependency change. So, the code change type is 4.","The additional assignment `mState = RESUMED;` does not lead to different return values or exceptions, as it is an internal state change and the method return type is `void`. Therefore, there is no compatibility issue, and the CI type is 0."
652,<android.app.WallpaperManager: boolean isWallpaperSupported()>,23,24,<android.app.WallpaperManager: boolean isWallpaperSupported()>,<android.app.WallpaperManager: boolean isWallpaperSupported()>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
    } else {
        try {
            return sGlobals.mService.isWallpaperSupported(mContext.getOpPackageName());
        } catch (RemoteException e) {
        // Ignore
        }
    }
    return false;
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    } else {
        try {
            return sGlobals.mService.isWallpaperSupported(mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Returns whether wallpapers are supported for the calling user. If this function returns
 * false, any attempts to changing the wallpaper will have no effect.
 */
","/**
 * Returns whether wallpapers are supported for the calling user. If this function returns
 * {@code false}, any attempts to changing the wallpaper will have no effect,
 * and any attempt to obtain of the wallpaper will return {@code null}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the early version, if `sGlobals.mService` is `null`, it logs a warning and returns `false`. In the late version, it throws a `RuntimeException` if `sGlobals.mService` is `null`. Additionally, the exception handling for `RemoteException` has changed from ignoring it to throwing it with the use of `e.rethrowFromSystemServer()`. Therefore, both a return statement and an exception handling statement have changed, indicated by change type 1,2.","The introduction of a new `throw` statement causes a change in the exception handling behavior if the `WallpaperService` is not running. Moreover, for RemoteException handling, it now throws `e.rethrowFromSystemServer()`, which can propagate the exception to the calling code and alter the flow of the program. Both of these changes can lead to a `Compatibility Issue` due to different return values (since the method may not return `false` anymore when the service isn't running) and different exception handlings (since it now throws an exception where it previously did not). So, the CI type is 1,2."
653,"<android.widget.Editor.SuggestionsPopupWindow.SuggestionAdapter: View getView(int,View,ViewGroup)>",23,24,"<android.widget.Editor.SuggestionsPopupWindow.SuggestionAdapter: View getView(int,View,ViewGroup)>","<android.widget.Editor.SuggestionsPopupWindow.SuggestionAdapter: View getView(int,View,ViewGroup)>",0,"{
    TextView textView = (TextView) convertView;
    if (textView == null) {
        textView = (TextView) mInflater.inflate(mTextView.mTextEditSuggestionItemLayout, parent, false);
    }
    final SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    textView.setText(suggestionInfo.text);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY || suggestionInfo.suggestionIndex == DELETE_TEXT) {
        textView.setBackgroundColor(Color.TRANSPARENT);
    } else {
        textView.setBackgroundColor(Color.WHITE);
    }
    return textView;
}","{
    TextView textView = (TextView) convertView;
    if (textView == null) {
        textView = (TextView) mInflater.inflate(mTextView.mTextEditSuggestionItemLayout, parent, false);
    }
    final SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    textView.setText(suggestionInfo.mText);
    return textView;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The code change includes a deletion of an if-else statement that alters the background color of the TextView, so the change types are 1 for the altered return value (different appearance of the TextView), and 4 for the other statement (setting background color) changed.","Since the change in the code modifies how the TextView's background color is set, this could lead to different visual appearances for the rows in the suggestions popup window. Thus, the change may potentially return a different value (the TextView with possibly a different color), which classes as a CI type 1."
654,<android.hardware.soundtrigger.SoundTrigger.RecognitionEvent: boolean equals(Object)>,23,24,<android.hardware.soundtrigger.SoundTrigger.RecognitionEvent: boolean equals(Object)>,<android.hardware.soundtrigger.SoundTrigger.RecognitionEvent: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    RecognitionEvent other = (RecognitionEvent) obj;
    if (captureAvailable != other.captureAvailable)
        return false;
    if (captureDelayMs != other.captureDelayMs)
        return false;
    if (capturePreambleMs != other.capturePreambleMs)
        return false;
    if (captureSession != other.captureSession)
        return false;
    if (!Arrays.equals(data, other.data))
        return false;
    if (soundModelHandle != other.soundModelHandle)
        return false;
    if (status != other.status)
        return false;
    if (triggerInData != other.triggerInData)
        return false;
    if (captureFormat.getSampleRate() != other.captureFormat.getSampleRate())
        return false;
    if (captureFormat.getEncoding() != other.captureFormat.getEncoding())
        return false;
    if (captureFormat.getChannelMask() != other.captureFormat.getChannelMask())
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    RecognitionEvent other = (RecognitionEvent) obj;
    if (captureAvailable != other.captureAvailable)
        return false;
    if (captureDelayMs != other.captureDelayMs)
        return false;
    if (capturePreambleMs != other.capturePreambleMs)
        return false;
    if (captureSession != other.captureSession)
        return false;
    if (!Arrays.equals(data, other.data))
        return false;
    if (soundModelHandle != other.soundModelHandle)
        return false;
    if (status != other.status)
        return false;
    if (triggerInData != other.triggerInData)
        return false;
    if (captureFormat == null) {
        if (other.captureFormat != null)
            return false;
    } else {
        if (other.captureFormat == null)
            return false;
        if (captureFormat.getSampleRate() != other.captureFormat.getSampleRate())
            return false;
        if (captureFormat.getEncoding() != other.captureFormat.getEncoding())
            return false;
        if (captureFormat.getChannelMask() != other.captureFormat.getChannelMask())
            return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The late implementation introduced additional null checks for the `captureFormat` field before comparing its internal values. This alters the control flow of the method to account for the case where `captureFormat` could be `null`. So, the code change is related to a control dependency change, which is type 3.","The newly introduced null check for `captureFormat` does not introduce a compatibility issue because its purpose is to prevent a NullPointerException that would occur in the early version when calling methods on a `null` `captureFormat`. This change makes the method more robust and maintains the logical equivalence of the condition checks. Therefore, the behavior of the `equals` method is not fundamentally different, meaning that no compatibility issue arises, so the CI type is 0."
655,<android.accessibilityservice.AccessibilityService: AccessibilityServiceInfo getServiceInfo()>,23,24,<android.accessibilityservice.AccessibilityService: AccessibilityServiceInfo getServiceInfo()>,<android.accessibilityservice.AccessibilityService: AccessibilityServiceInfo getServiceInfo()>,0,"{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.getServiceInfo();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while getting AccessibilityServiceInfo"", re);
        }
    }
    return null;
}","{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.getServiceInfo();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while getting AccessibilityServiceInfo"", re);
            re.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Gets the an {@link AccessibilityServiceInfo} describing this
 * {@link AccessibilityService}. This method is useful if one wants
 * to change some of the dynamically configurable properties at
 * runtime.
 *
 * @return The accessibility service info.
 *
 * @see AccessibilityServiceInfo
 */
","/**
 * Gets the an {@link AccessibilityServiceInfo} describing this
 * {@link AccessibilityService}. This method is useful if one wants
 * to change some of the dynamically configurable properties at
 * runtime.
 *
 * @return The accessibility service info.
 *
 * @see AccessibilityServiceInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has been changed by adding a line that rethrows the RemoteException as a RuntimeException from the system server in the catch block. Since nothing else has been altered, the code change type is 2.","The previous version logged the RemoteException and continued, ultimately returning null. The late version rethrows the exception, which changes the exception handling behavior of the API. This could lead to a potential Compatibility Issue since a previously caught exception is now propagated, thus the CI type is 2."
657,<android.os.Parcel: Object readValue(ClassLoader)>,23,24,<android.os.Parcel: Object readValue(ClassLoader)>,<android.os.Parcel: Object readValue(ClassLoader)>,0,"{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable(loader);
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        case VAL_PERSISTABLEBUNDLE:
            return readPersistableBundle(loader);
        case VAL_SIZE:
            return readSize();
        case VAL_SIZEF:
            return readSizeF();
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException(""Parcel "" + this + "": Unmarshalling unknown type code "" + type + "" at offset "" + off);
    }
}","{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable(loader);
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        case VAL_PERSISTABLEBUNDLE:
            return readPersistableBundle(loader);
        case VAL_SIZE:
            return readSize();
        case VAL_SIZEF:
            return readSizeF();
        case VAL_DOUBLEARRAY:
            return createDoubleArray();
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException(""Parcel "" + this + "": Unmarshalling unknown type code "" + type + "" at offset "" + off);
    }
}",1,"/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */
","/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The change in the switch statement with the addition of the case `VAL_DOUBLEARRAY` and the associated method call to `createDoubleArray()` is a change in another statement (which is not related to return, exception handling, or control dependency), so the code change type is 4. Additionally, since `createDoubleArray()` is a method potentially not present in the early version (assuming based on the context of the question), this indicates a change in the dependent API, therefore, type 5 is also applicable.","The added case for `VAL_DOUBLEARRAY` indicates that the new version of the API can now return an additional type of object (an array of doubles), which was not possible in the early version. This means that the late version API could potentially return a different value when the `VAL_DOUBLEARRAY` case is encountered, leading to a Compatibility Issue with type 1."
658,<android.app.ActivityManager.AppTask: RecentTaskInfo getTaskInfo()>,23,24,<android.app.ActivityManager.AppTask: RecentTaskInfo getTaskInfo()>,<android.app.ActivityManager.AppTask: RecentTaskInfo getTaskInfo()>,0,"{
    try {
        return mAppTaskImpl.getTaskInfo();
    } catch (RemoteException e) {
        Slog.e(TAG, ""Invalid AppTask"", e);
        return null;
    }
}","{
    try {
        return mAppTaskImpl.getTaskInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the RecentTaskInfo associated with this task.
 *
 * @return The RecentTaskInfo for this task, or null if the task no longer exists.
 */
","/**
 * Get the RecentTaskInfo associated with this task.
 *
 * @return The RecentTaskInfo for this task, or null if the task no longer exists.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from catching and logging the RemoteException to re-throwing it using e.rethrowFromSystemServer(), hence the code change is of type 2.","The removal of the catch block that returns null and the introduction of a new throw statement could lead to different behavior, as in the late version, the method propagates the exception instead of swallowing it and returning null. Therefore, this represents a CI of type 2 caused by potentially different exception handlings."
659,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,23,24,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,0,"{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final float x = event.getX();
        final float y = event.getY();
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
            final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                if (preorderedList != null)
                    preorderedList.clear();
                return true;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}","{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final float x = event.getX();
        final float y = event.getY();
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                if (preorderedList != null)
                    preorderedList.clear();
                return true;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
",,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"There are changes in the loop where `childIndex` and `child` are assigned their values. The direct assignments have been replaced with calls to `getAndVerifyPreorderedIndex` and `getAndVerifyPreorderedView`. However, since there are no changes in the return statements or exception handling, and the logic and control flow remains essentially the same (the loop continues to iterate over children in reverse order and dispatch events), the change type is 3 for control dependency change and 5 for dependent API changed because it now relies on new methods `getAndVerifyPreorderedIndex` and `getAndVerifyPreorderedView`. ","As there is no change in the behavior or outcome of the method -- the event dispatch logic has not changed, no new exceptions have been thrown, and the way the return value is calculated remains the same despite the refactoring -- there is no compatibility issue, and therefore the CI type is 0."
660,<android.content.res.Resources: AssetFileDescriptor openRawResourceFd(int)>,23,24,<android.content.res.Resources: AssetFileDescriptor openRawResourceFd(int)>,<android.content.res.Resources: AssetFileDescriptor openRawResourceFd(int)>,0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValue(id, value, true);
    }
    try {
        return mAssets.openNonAssetFd(value.assetCookie, value.string.toString());
    } catch (Exception e) {
        NotFoundException rnf = new NotFoundException(""File "" + value.string.toString() + "" from drawable resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(e);
        throw rnf;
    } finally {
        synchronized (mAccessLock) {
            if (mTmpValue == null) {
                mTmpValue = value;
            }
        }
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        return mResourcesImpl.openRawResourceFd(id, value);
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Open a file descriptor for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset files -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * <p>This function only works for resources that are stored in the package
 * as uncompressed data, which typically includes things like mp3 files
 * and png images.
 *
 * @param id The resource identifier to open, as generated by the appt
 * tool.
 *
 * @return AssetFileDescriptor A new file descriptor you can use to read
 * the resource.  This includes the file descriptor itself, as well as the
 * offset and length of data where the resource appears in the file.  A
 * null is returned if the file exists but is compressed.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Open a file descriptor for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset files -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * <p>This function only works for resources that are stored in the package
 * as uncompressed data, which typically includes things like mp3 files
 * and png images.
 *
 * @param id The resource identifier to open, as generated by the appt
 * tool.
 *
 * @return AssetFileDescriptor A new file descriptor you can use to read
 * the resource.  This includes the file descriptor itself, as well as the
 * offset and length of data where the resource appears in the file.  A
 * null is returned if the file exists but is compressed.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The implementation of the method has been significantly refactored, with a new method obtainTempTypedValue used to get a temporary TypedValue, and now the method delegates the open operation to mResourcesImpl.openRawResourceFd. A new try-finally block is introduced to ensure releaseTempTypedValue is called. These result in changes classified as 1 (Return statement changed), 4 (Other statement changed), and 5 (Dependent API changed)","With the method delegation and new object management, the return value of the method could potentially change. Additionally, the previous instance caught a generic Exception, but in the late version, it is not clear what exceptions the new method mResourcesImpl.openRawResourceFd could throw. Both changes could introduce different return values or types, and exception handlings, respectively. Therefore, the CI type is 1,2."
661,<android.view.SurfaceControl.PhysicalDisplayInfo: boolean equals(PhysicalDisplayInfo)>,23,24,<android.view.SurfaceControl.PhysicalDisplayInfo: boolean equals(PhysicalDisplayInfo)>,<android.view.SurfaceControl.PhysicalDisplayInfo: boolean equals(PhysicalDisplayInfo)>,0,"{
    return other != null && width == other.width && height == other.height && refreshRate == other.refreshRate && density == other.density && xDpi == other.xDpi && yDpi == other.yDpi && secure == other.secure && appVsyncOffsetNanos == other.appVsyncOffsetNanos && presentationDeadlineNanos == other.presentationDeadlineNanos;
}","{
    return other != null && width == other.width && height == other.height && refreshRate == other.refreshRate && density == other.density && xDpi == other.xDpi && yDpi == other.yDpi && secure == other.secure && appVsyncOffsetNanos == other.appVsyncOffsetNanos && presentationDeadlineNanos == other.presentationDeadlineNanos && colorTransform == other.colorTransform;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The equals method in the late version includes a new check for the field colorTransform == other.colorTransform that was not present in the early version, which is a change in the return statement.","This change potentially alters the behavior of the method, as comparisons that would have previously resulted in true could now result in false if the colorTransform fields are not equal. Hence, this is a Compatibility Issue caused by potential different return values."
662,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLetters(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLetters(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLetters(ComponentName)>,0,"{
    return getPasswordMinimumLetters(admin, UserHandle.myUserId());
}","{
    return getPasswordMinimumLetters(admin, myUserId());
}",1,"/**
 * Retrieve the current number of letters required in the password for all
 * admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumLetters(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of letters required in the password.
 */
","/**
 * Retrieve the current number of letters required in the password
 * for a particular admin or all admins that set retrictions on this user
 * and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 * This is the same value as set by
 * {@link #setPasswordMinimumLetters(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of letters required in the password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getPasswordMinimumLetters in the late version is calling myUserId() instead of UserHandle.myUserId(), which is indicative of a change in the dependent API (though the method name remains the same, the utilization context or the definition of myUserId() may have changed). Therefore, the code change type is 5. ","Despite the change in how the user ID is retrieved, there's no change in the return type or value, or exception handling by this method itself; it still returns the result of getPasswordMinimumLetters with an admin component and a user ID as input. Unless there's a change in the implementation of myUserId() that affects the return value (which isn't specified here), there would be no Compatibility Issue, and the CI type is 0."
663,"<android.app.ContextImpl: File getDir(String,int)>",23,24,"<android.app.ContextImpl: File getDir(String,int)>","<android.app.ContextImpl: File getDir(String,int)>",0,"{
    name = ""app_"" + name;
    File file = makeFilename(getDataDirFile(), name);
    if (!file.exists()) {
        file.mkdir();
        setFilePermissionsFromMode(file.getPath(), mode, FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH);
    }
    return file;
}","{
    checkMode(mode);
    name = ""app_"" + name;
    File file = makeFilename(getDataDir(), name);
    if (!file.exists()) {
        file.mkdir();
        setFilePermissionsFromMode(file.getPath(), mode, FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH);
    }
    return file;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes the addition of a new method call checkMode(mode) and changing getDataDirFile() to getDataDir(). These changes are in the statements that do not involve control structures, return values, or exceptions, making the code change type 4. Additionally, the change from getDataDirFile() to getDataDir() implies a modification in the called API, which signals a type 5 change.","The introduction of checkMode(mode) does not influence the return value or the exception handling, assuming it is for validation purpose and does not affect the file being returned; thus, it doesn't cause a compatibility issue. Also, assuming getDataDir() is an equivalent call to getDataDirFile() and returns the same file object, even though it is a dependent API change, this would not cause the method to behave differently. Therefore, considering these assumptions, there is no compatibility issue."
664,<android.widget.MediaController: void hide()>,23,24,<android.widget.MediaController: void hide()>,<android.widget.MediaController: void hide()>,0,"{
    if (mAnchor == null)
        return;
    if (mShowing) {
        try {
            mHandler.removeMessages(SHOW_PROGRESS);
            mWindowManager.removeView(mDecor);
        } catch (IllegalArgumentException ex) {
            Log.w(""MediaController"", ""already removed"");
        }
        mShowing = false;
    }
}","{
    if (mAnchor == null)
        return;
    if (mShowing) {
        try {
            removeCallbacks(mShowProgress);
            mWindowManager.removeView(mDecor);
        } catch (IllegalArgumentException ex) {
            Log.w(""MediaController"", ""already removed"");
        }
        mShowing = false;
    }
}",1,"/**
 * Remove the controller from the screen.
 */
","/**
 * Remove the controller from the screen.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call within the 'try' block has changed from mHandler.removeMessages(SHOW_PROGRESS) to removeCallbacks(mShowProgress), which is not a change in a return statement, exception handling statement, or a change in control dependency. Therefore, it falls under the category of other statement changed.","As only an internal method call has been changed, which does not affect the method's return value or the exceptions it may throw, there's no Compatibility Issue."
667,<android.view.View: void getLocationInWindow(int[])>,23,24,<android.view.View: void getLocationInWindow(int[])>,<android.view.View: void getLocationInWindow(int[])>,0,"{
    if (location == null || location.length < 2) {
        throw new IllegalArgumentException(""location must be an array of two integers"");
    }
    if (mAttachInfo == null) {
        // When the view is not attached to a window, this method does not make sense
        location[0] = location[1] = 0;
        return;
    }
    float[] position = mAttachInfo.mTmpTransformLocation;
    position[0] = position[1] = 0.0f;
    if (!hasIdentityMatrix()) {
        getMatrix().mapPoints(position);
    }
    position[0] += mLeft;
    position[1] += mTop;
    ViewParent viewParent = mParent;
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        position[0] -= view.mScrollX;
        position[1] -= view.mScrollY;
        if (!view.hasIdentityMatrix()) {
            view.getMatrix().mapPoints(position);
        }
        position[0] += view.mLeft;
        position[1] += view.mTop;
        viewParent = view.mParent;
    }
    if (viewParent instanceof ViewRootImpl) {
        // *cough*
        final ViewRootImpl vr = (ViewRootImpl) viewParent;
        position[1] -= vr.mCurScrollY;
    }
    location[0] = (int) (position[0] + 0.5f);
    location[1] = (int) (position[1] + 0.5f);
}","{
    if (outLocation == null || outLocation.length < 2) {
        throw new IllegalArgumentException(""outLocation must be an array of two integers"");
    }
    outLocation[0] = 0;
    outLocation[1] = 0;
    transformFromViewToWindowSpace(outLocation);
}",1,"/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
","/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param outLocation an array of two integers in which to hold the coordinates
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"There is a change in the parameter name from `location` to `outLocation`, modification in logic and method call within the method itself, and a dependent API `transformFromViewToWindowSpace(outLocation)` has been introduced replacing the original computations. An exception message text has also been modified. There is no change in control flow (no new or removed if or loop statements). So the code change type is 1 for the parameter and message change, 4 for the logic modification, and 5 for introducing a dependent API change.","These changes are likely to return a different value because the method of calculating the location in the window has been fundamentally altered, and a new API call `transformFromViewToWindowSpace` has been introduced which might have a different implementation. Thus, CI type is 1."
668,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,23,24,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,0,"{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY);
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetricsLocked());
    return context;
}","{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, 0, null, null, Display.INVALID_DISPLAY);
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetrics());
    return context;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes involve the calling of different constructors for `ContextImpl` and methods on `ResourcesManager`. The parameter `false` is changed to `0` in the `ContextImpl` constructor, and the method `getDisplayMetricsLocked()` is changed to `getDisplayMetrics()` on `ResourcesManager`. These changes are neither affecting return statements, exception handling, control dependency, nor dependent APIs, so the change type is 4.","The changes do not seem to introduce a Compatibility Issue as the API still returns a `ContextImpl` object and no exceptions or return values/types are affected by this change directly. The difference in calling `getDisplayMetrics()` instead of `getDisplayMetricsLocked()` might be an internal change to the way metrics are retrieved, without changing the behavior seen by code using this API. The change in the flag from `false` to `0` likely represents a change in the internal handling of flags (e.g., from a boolean to an int-based flag system) without altering the contract of the method. Therefore, there's no Compatibility Issue."
669,"<android.app.admin.DevicePolicyManager: boolean hasGrantedPolicy(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: boolean hasGrantedPolicy(ComponentName,int)>","<android.app.admin.DevicePolicyManager: boolean hasGrantedPolicy(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            return mService.hasGrantedPolicy(admin, usesPolicy, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""hasGrantedPolicy"");
    if (mService != null) {
        try {
            return mService.hasGrantedPolicy(admin, usesPolicy, myUserId());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Returns true if an administrator has been granted a particular device policy.  This can
 * be used to check whether the administrator was activated under an earlier set of policies,
 * but requires additional policies after an upgrade.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.  Must be
 * an active administrator, or an exception will be thrown.
 * @param usesPolicy Which uses-policy to check, as defined in {@link DeviceAdminInfo}.
 */
","/**
 * Returns true if an administrator has been granted a particular device policy. This can be
 * used to check whether the administrator was activated under an earlier set of policies, but
 * requires additional policies after an upgrade.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Must be an
 * active administrator, or an exception will be thrown.
 * @param usesPolicy Which uses-policy to check, as defined in {@link DeviceAdminInfo}.
 * @throws SecurityException if {@code admin} is not an active administrator.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement has been changed; there's a new throw statement (throwIfParentInstance(""hasGrantedPolicy"")), so the change type is 2 for the new exception handling, and 4 for the other statement changed because the implementation now calls myUserId() directly instead of UserHandle.myUserId().","The API will behave differently when encountering RemoteException (earlier it was logged, now it throws the exception) and when invoked on a parent instance (now throws an IllegalStateException because of throwIfParentInstance(""hasGrantedPolicy"")), and there's a potential difference from the change to how the current user ID is acquired. Therefore, the CI type is 2 due to the different exception handlings."
671,<android.net.ConnectivityManager: void removeDefaultNetworkActiveListener(OnNetworkActiveListener)>,23,24,<android.net.ConnectivityManager: void removeDefaultNetworkActiveListener(OnNetworkActiveListener)>,<android.net.ConnectivityManager: void removeDefaultNetworkActiveListener(OnNetworkActiveListener)>,0,"{
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    if (rl == null) {
        throw new IllegalArgumentException(""Listener not registered: "" + l);
    }
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
    }
}","{
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    if (rl == null) {
        throw new IllegalArgumentException(""Listener not registered: "" + l);
    }
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Remove network active listener previously registered with
 * {@link #addDefaultNetworkActiveListener}.
 *
 * @param l Previously registered listener.
 */
","/**
 * Remove network active listener previously registered with
 * {@link #addDefaultNetworkActiveListener}.
 *
 * @param l Previously registered listener.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement is changed. In the late version, a RemoteException will be thrown using throw e.rethrowFromSystemServer(), while in the early version, the RemoteException is caught and not rethrown.","This change introduces a different exception handling behavior that can lead to a potential Compatibility Issue of type 2. Before, the RemoteException was silently ignored; after the change, it is rethrown, affecting the caller’s exception handling logic."
672,<android.content.res.Resources.Theme: int getChangingConfigurations()>,23,24,<android.content.res.Resources.Theme: int getChangingConfigurations()>,<android.content.res.Resources.Theme: int getChangingConfigurations()>,0,"{
    final int nativeChangingConfig = AssetManager.getThemeChangingConfigurations(mTheme);
    return ActivityInfo.activityInfoConfigNativeToJava(nativeChangingConfig);
}","{
    return mThemeImpl.getChangingConfigurations();
}",1,"/**
 * Returns a bit mask of configuration changes that will impact this
 * theme (and thus require completely reloading it).
 *
 * @return a bit mask of configuration changes, as defined by
 * {@link ActivityInfo}
 * @see ActivityInfo
 */
","/**
 * Returns a bit mask of configuration changes that will impact this
 * theme (and thus require completely reloading it).
 *
 * @return a bit mask of configuration changes, as defined by
 * {@link ActivityInfo}
 * @see ActivityInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has changed significantly, with the late implementation now calling a different method (mThemeImpl.getChangingConfigurations()) instead of the combination of AssetManager.getThemeChangingConfigurations(mTheme) and ActivityInfo.activityInfoConfigNativeToJava(nativeChangingConfig), so the code change type is 1,5.","The change to the implementation means the API could potentially return a different value, as it no longer translates the native configuration through ActivityInfo.activityInfoConfigNativeToJava(). As such, this is a CI caused by potential different return values. The CI type is 1."
676,<android.bluetooth.le.BluetoothLeAdvertiser.AdvertiseCallbackWrapper: void startRegisteration()>,23,24,<android.bluetooth.le.BluetoothLeAdvertiser.AdvertiseCallbackWrapper: void startRegisteration()>,<android.bluetooth.le.BluetoothLeAdvertiser.AdvertiseCallbackWrapper: void startRegisteration()>,0,"{
    synchronized (this) {
        if (mClientIf == -1)
            return;
        try {
            UUID uuid = UUID.randomUUID();
            mBluetoothGatt.registerClient(new ParcelUuid(uuid), this);
            wait(LE_CALLBACK_TIMEOUT_MILLIS);
        } catch (InterruptedException | RemoteException e) {
            Log.e(TAG, ""Failed to start registeration"", e);
        }
        if (mClientIf > 0 && mIsAdvertising) {
            mLeAdvertisers.put(mAdvertiseCallback, this);
        } else if (mClientIf <= 0) {
            // Post internal error if registration failed.
            postStartFailure(mAdvertiseCallback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        } else {
            // Unregister application if it's already registered but advertise failed.
            try {
                mBluetoothGatt.unregisterClient(mClientIf);
                mClientIf = -1;
            } catch (RemoteException e) {
                Log.e(TAG, ""remote exception when unregistering"", e);
            }
        }
    }
}","{
    synchronized (this) {
        if (mClientIf == -1)
            return;
        try {
            UUID uuid = UUID.randomUUID();
            mBluetoothGatt.registerClient(new ParcelUuid(uuid), this);
            wait(LE_CALLBACK_TIMEOUT_MILLIS);
        } catch (InterruptedException | RemoteException e) {
            Log.e(TAG, ""Failed to start registeration"", e);
        }
        if (mClientIf > 0 && mIsAdvertising) {
            mLeAdvertisers.put(mAdvertiseCallback, this);
        } else if (mClientIf <= 0) {
            // proceed.
            if (mClientIf == 0)
                mClientIf = -1;
            // Post internal error if registration failed.
            postStartFailure(mAdvertiseCallback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        } else {
            // Unregister application if it's already registered but advertise failed.
            try {
                mBluetoothGatt.unregisterClient(mClientIf);
                mClientIf = -1;
            } catch (RemoteException e) {
                Log.e(TAG, ""remote exception when unregistering"", e);
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is an added control flow branch (if (mClientIf == 0) mClientIf = -1;) which changes the control dependency, and also the addition qualifies as an 'other statement changed',  so the code change type is 3,4.","In the late implementation, there is a new condition that sets `mClientIf` to -1 if it is equal to 0. This was not present in the early version, and could lead to a change in behavior, for instance, the `postStartFailure` could be reached in a condition where it wasn't before because of the change in value of `mClientIf`. Therefore, there is a Compatibility Issue caused by potentially different return values, and the CI type is 1."
677,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,23,24,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,0,"{
    try {
        mService.updateStatusIcon(imeToken, null, 0);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        mService.updateStatusIcon(imeToken, null, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"There is a change in the way the exception is re-thrown. The exception handling statement has changed from throwing a new RuntimeException to calling `e.rethrowFromSystemServer()`, so the change type is 2.","This change will result in different exception types being thrown. The late version of the method throws the exception returned from `e.rethrowFromSystemServer()`, while the early version wraps the exception in a new RuntimeException. Therefore, the CI type is 2."
678,<android.view.inputmethod.InputMethodManager: void showInputMethodAndSubtypeEnabler(String)>,23,24,<android.view.inputmethod.InputMethodManager: void showInputMethodAndSubtypeEnabler(String)>,<android.view.inputmethod.InputMethodManager: void showInputMethodAndSubtypeEnabler(String)>,0,"{
    synchronized (mH) {
        try {
            mService.showInputMethodAndSubtypeEnablerFromClient(mClient, imiId);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    synchronized (mH) {
        try {
            mService.showInputMethodAndSubtypeEnablerFromClient(mClient, imiId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Show the settings for enabling subtypes of the specified input method.
 * @param imiId An input method, whose subtypes settings will be shown. If imiId is null,
 * subtypes of all input methods will be shown.
 */
","/**
 * Show the settings for enabling subtypes of the specified input method.
 * @param imiId An input method, whose subtypes settings will be shown. If imiId is null,
 * subtypes of all input methods will be shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement inside the catch block has been changed. In the early version, an exception is logged, whereas in the late version the exception is rethrown using throw e.rethrowFromSystemServer(), so the change type is 2.","The change in exception handling will lead to different behavior when an exception occurs. In the early version, the exception is caught and logged, but in the late version, the exception is rethrown, which differs from the original exception flow. As this new approach could lead to uncaught exceptions bubbling up in the caller's context, the CI type is 2."
680,"<android.content.pm.LauncherApps: List<LauncherActivityInfo> getActivityList(String,UserHandle)>",23,24,"<android.content.pm.LauncherApps: List<LauncherActivityInfo> getActivityList(String,UserHandle)>","<android.content.pm.LauncherApps: List<LauncherActivityInfo> getActivityList(String,UserHandle)>",0,"{
    List<ResolveInfo> activities = null;
    try {
        activities = mService.getLauncherActivities(packageName, user);
    } catch (RemoteException re) {
        throw new RuntimeException(""Failed to call LauncherAppsService"");
    }
    if (activities == null) {
        return Collections.EMPTY_LIST;
    }
    ArrayList<LauncherActivityInfo> lais = new ArrayList<LauncherActivityInfo>();
    final int count = activities.size();
    for (int i = 0; i < count; i++) {
        ResolveInfo ri = activities.get(i);
        long firstInstallTime = 0;
        try {
            firstInstallTime = mPm.getPackageInfo(ri.activityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
        } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        }
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri, user, firstInstallTime);
        if (DEBUG) {
            Log.v(TAG, ""Returning activity for profile "" + user + "" : "" + lai.getComponentName());
        }
        lais.add(lai);
    }
    return lais;
}","{
    ParceledListSlice<ResolveInfo> activities = null;
    try {
        activities = mService.getLauncherActivities(packageName, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    if (activities == null) {
        return Collections.EMPTY_LIST;
    }
    ArrayList<LauncherActivityInfo> lais = new ArrayList<LauncherActivityInfo>();
    for (ResolveInfo ri : activities.getList()) {
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri.activityInfo, user);
        if (DEBUG) {
            Log.v(TAG, ""Returning activity for profile "" + user + "" : "" + lai.getComponentName());
        }
        lais.add(lai);
    }
    return lais;
}",1,"/**
 * Retrieves a list of launchable activities that match {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER}, for a specified user.
 *
 * @param packageName The specific package to query. If null, it checks all installed packages
 * in the profile.
 * @param user The UserHandle of the profile.
 * @return List of launchable activities. Can be an empty list but will not be null.
 */
","/**
 * Retrieves a list of launchable activities that match {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER}, for a specified user.
 *
 * @param packageName The specific package to query. If null, it checks all installed packages
 * in the profile.
 * @param user The UserHandle of the profile.
 * @return List of launchable activities. Can be an empty list but will not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The early version API uses a List<ResolveInfo> type for 'activities', while the late version uses ParceledListSlice<ResolveInfo> and then calls getList() on 'activities' instead of just using it directly. The exception handling has also changed from throwing a new RuntimeException to rethrowing RemoteException using rethrowFromSystemServer(). The control flow has been slightly altered by eliminating the loop counter 'count' and replacing it with an enhanced for-loop. Besides these, a call to mPm.getPackageInfo() inside the loop is removed, together with the try-catch block that was catching NameNotFoundException. The construction of LauncherActivityInfo has also changed, with the early version passing an additional parameter 'firstInstallTime' that is no longer there in the late version. Thus, the code change involves return statements, exception handling, control flow, other statements, and the usage of dependent APIs.","A Compatibility Issue may arise because the API may throw a different exception in case of a RemoteException (rethrown instead of a new RuntimeException), causing a CI related to exception handling. Due to the removal of the package installation time retrieval and the modified return statement (through the use of the getList() method on the ParceledListSlice), the values returned by the API could be different, potentially causing a Compatibility Issue related to different return values or types."
681,<android.content.ClipboardManager: boolean hasText()>,23,24,<android.content.ClipboardManager: boolean hasText()>,<android.content.ClipboardManager: boolean hasText()>,0,"{
    try {
        return getService().hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return getService().hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
","/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from returning false to throwing the exception, so the change type is 2.","The behavior of the API can change upon encountering a RemoteException; previously, it would return false, but now it throws an exception. Thus, the CI type is 2 due to changed exception handling."
682,"<android.app.admin.DevicePolicyManager: boolean hasCaCertInstalled(ComponentName,byte[])>",23,24,"<android.app.admin.DevicePolicyManager: boolean hasCaCertInstalled(ComponentName,byte[])>","<android.app.admin.DevicePolicyManager: boolean hasCaCertInstalled(ComponentName,byte[])>",0,"{
    if (mService != null) {
        try {
            mService.enforceCanManageCaCerts(admin);
            return getCaCertAlias(certBuffer) != null;
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed talking with device policy service"", re);
        } catch (CertificateException ce) {
            Log.w(TAG, ""Could not parse certificate"", ce);
        }
    }
    return false;
}","{
    throwIfParentInstance(""hasCaCertInstalled"");
    if (mService != null) {
        try {
            mService.enforceCanManageCaCerts(admin);
            return getCaCertAlias(certBuffer) != null;
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        } catch (CertificateException ce) {
            Log.w(TAG, ""Could not parse certificate"", ce);
        }
    }
    return false;
}",1,"/**
 * Returns whether this certificate is installed as a trusted CA.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to look up.
 */
","/**
 * Returns whether this certificate is installed as a trusted CA.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to look up.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The code change includes modifications to exception handling; the RemoteException is no longer logged, but thrown again using `throw re.rethrowFromSystemServer()`. Additionally, a method call to `throwIfParentInstance(""hasCaCertInstalled"")` is added at the beginning of the late version, so the code change type is 2,4.","Since a RemoteException is now thrown again in the late version, while it was just logged in the early version, this can cause a Compatibility Issue due to different exception handlings. The CI type is 2."
683,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,0,"{
    return getCameraDisabled(admin, UserHandle.myUserId());
}","{
    throwIfParentInstance(""getCameraDisabled"");
    return getCameraDisabled(admin, myUserId());
}",1,"/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the current admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
","/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the calling admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The late implementation introduces a new method call throwIfParentInstance(""getCameraDisabled"") before the existing code and modifies the parameter of the getCameraDisabled method from UserHandle.myUserId() to myUserId(), so the code change is classified as 2 (exception handling statement changed because of the newly introduced throw statement), 4 (other statement changed), and 5 (dependent API changed, since the method used to acquire the user ID has been changed).","The exception handling statement throwing a new exception before the actual functionality can cause a new exception handling flow in circumstances where throwIfParentInstance finds the invocation context inappropriate, which was not the case in the earlier version, thus making the compatibility issue type 2 (Compatibility Issue caused by potential different exception handlings)."
685,"<android.app.admin.DevicePolicyManager: void setPasswordExpirationTimeout(ComponentName,long)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordExpirationTimeout(ComponentName,long)>","<android.app.admin.DevicePolicyManager: void setPasswordExpirationTimeout(ComponentName,long)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordExpirationTimeout(admin, timeout);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordExpirationTimeout(admin, timeout, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a device admin to set the password expiration timeout. Calling this method
 * will restart the countdown for password expiration for the given admin, as will changing
 * the device password (for all admins).
 *
 * <p>The provided timeout is the time delta in ms and will be added to the current time.
 * For example, to have the password expire 5 days from now, timeout would be
 * 5 * 86400 * 1000 = 432000000 ms for timeout.
 *
 * <p>To disable password expiration, a value of 0 may be used for timeout.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * <p> Note that setting the password will automatically reset the expiration time for all
 * active admins. Active admins do not need to explicitly call this method in that case.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeout The limit (in ms) that a password can remain in effect. A value of 0
 * means there is no restriction (unlimited).
 */
","/**
 * Called by a device admin to set the password expiration timeout. Calling this method will
 * restart the countdown for password expiration for the given admin, as will changing the
 * device password (for all admins).
 * <p>
 * The provided timeout is the time delta in ms and will be added to the current time. For
 * example, to have the password expire 5 days from now, timeout would be 5 * 86400 * 1000 =
 * 432000000 ms for timeout.
 * <p>
 * To disable password expiration, a value of 0 may be used for timeout.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * Note that setting the password will automatically reset the expiration time for all active
 * admins. Active admins do not need to explicitly call this method in that case.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeout The limit (in ms) that a password can remain in effect. A value of 0 means
 * there is no restriction (unlimited).
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5","1,2","The exception handling statement has changed, as it now throws the exception rather than logging it. Additionally, there is a change in the arguments passed to the method mService.setPasswordExpirationTimeout, where a new parameter 'mParentInstance' has been added. These changes indicate change types 2, 4, and 5.","The changed exception handling statement could lead to the late version throwing a RemoteException where the early version would not have, resulting in a change in behavior. The addition of the new parameter could result in different behavior as well, and this dependent API change could cause the method to behave differently if the implementation of mService.setPasswordExpirationTimeout(admin, timeout, mParentInstance) has different semantics or side effects. Therefore, the CI types are 1 and 2."
686,<android.hardware.radio.RadioManager.FmBandDescriptor: String toString()>,23,24,<android.hardware.radio.RadioManager.FmBandDescriptor: String toString()>,<android.hardware.radio.RadioManager.FmBandDescriptor: String toString()>,0,"{
    return ""FmBandDescriptor [ "" + super.toString() + "" mStereo="" + mStereo + "", mRds="" + mRds + "", mTa="" + mTa + "", mAf="" + mAf + ""]"";
}","{
    return ""FmBandDescriptor [ "" + super.toString() + "" mStereo="" + mStereo + "", mRds="" + mRds + "", mTa="" + mTa + "", mAf="" + mAf + "", mEa ="" + mEa + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been modified to include "", mEa ="" + mEa""; the method now returns a string with an additional field appended to it. This also constitutes ""Other statement changed"" because it is a change in the method body that is neither a control structure change nor an exception handling change.","The API now potentially returns a different string value by including additional information (mEa) in the output, which may affect the behavior of the code that relies on the format of the string returned by toString(). Hence, this could lead to a Compatibility Issue due to a potential different return value."
687,<android.app.ActivityManagerProxy: ActivityOptions getActivityOptions(IBinder)>,23,24,<android.app.ActivityManagerProxy: ActivityOptions getActivityOptions(IBinder)>,<android.app.ActivityManagerProxy: ActivityOptions getActivityOptions(IBinder)>,0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(token);
    mRemote.transact(GET_ACTIVITY_OPTIONS_TRANSACTION, data, reply, 0);
    reply.readException();
    Bundle bundle = reply.readBundle();
    ActivityOptions options = bundle == null ? null : new ActivityOptions(bundle);
    data.recycle();
    reply.recycle();
    return options;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(token);
    mRemote.transact(GET_ACTIVITY_OPTIONS_TRANSACTION, data, reply, 0);
    reply.readException();
    ActivityOptions options = ActivityOptions.fromBundle(reply.readBundle());
    data.recycle();
    reply.recycle();
    return options;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is the instantiation of the ActivityOptions object using a static method (fromBundle) instead of the new keyword. This is a change in the object creation pattern, which falls under 'Other statement changed', so the code change type is 4.","This change does not lead to Compatibility Issues since the returned object 'options' should behave the same way regardless of whether it's created directly through the constructor or via the static factory method 'fromBundle'. The return type and the possible values remain unchanged, and there's no change in exception handling, so the CI type is 0."
688,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",23,24,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.addAccount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn);
        }
    }.start();
}","{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.addAccount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn);
        }
    }.start();
}",1,"/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process or adding accounts
 * (of this type) has been disabled by policy
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */
","/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process or adding accounts
 * (of this type) has been disabled by policy
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the actual implementation code. The only difference is the addition of the @Override annotation above the doWork() method, which does not affect the behavior of the method.","Since there's no change in the implementation that would affect behavior, there is no Compatibility Issue."
689,<android.print.PrintAttributes.MediaSize: String getLabel(PackageManager)>,23,24,<android.print.PrintAttributes.MediaSize: String getLabel(PackageManager)>,<android.print.PrintAttributes.MediaSize: String getLabel(PackageManager)>,0,"{
    if (!TextUtils.isEmpty(mPackageName) && mLabelResId > 0) {
        try {
            return packageManager.getResourcesForApplication(mPackageName).getString(mLabelResId);
        } catch (NotFoundException nfe) {
            Log.w(LOG_TAG, ""Could not load resouce"" + mLabelResId + "" from package "" + mPackageName);
        } catch (NameNotFoundException nnfee) {
            Log.w(LOG_TAG, ""Could not load resouce"" + mLabelResId + "" from package "" + mPackageName);
        }
    }
    return mLabel;
}","{
    if (!TextUtils.isEmpty(mPackageName) && mLabelResId > 0) {
        try {
            return packageManager.getResourcesForApplication(mPackageName).getString(mLabelResId);
        } catch (NotFoundException | NameNotFoundException e) {
            Log.w(LOG_TAG, ""Could not load resouce"" + mLabelResId + "" from package "" + mPackageName);
        }
    }
    return mLabel;
}",1,"/**
 * Gets the human readable media size label.
 *
 * @param packageManager The package manager for loading the label.
 * @return The human readable label.
 */
","/**
 * Gets the human readable media size label.
 *
 * @param packageManager The package manager for loading the label.
 * @return The human readable label.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The exception handling within the if block has been refactored to use multi-catch instead of catching exceptions individually. This is classified as ""Other statement changed"" due to the consolidation of the two catch blocks into one.","There is no compatibility issue arising from this change, since the behavior remains the same when an exception is thrown. It will still log the warning and proceed to return 'mLabel' as before."
691,<android.app.admin.DevicePolicyManager: void clearCrossProfileIntentFilters(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: void clearCrossProfileIntentFilters(ComponentName)>,<android.app.admin.DevicePolicyManager: void clearCrossProfileIntentFilters(ComponentName)>,0,"{
    if (mService != null) {
        try {
            mService.clearCrossProfileIntentFilters(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""clearCrossProfileIntentFilters"");
    if (mService != null) {
        try {
            mService.clearCrossProfileIntentFilters(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile owner of a managed profile to remove the cross-profile intent filters
 * that go from the managed profile to the parent, or from the parent to the managed profile.
 * Only removes those that have been set by the profile owner.
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 */
","/**
 * Called by a profile owner of a managed profile to remove the cross-profile intent filters
 * that go from the managed profile to the parent, or from the parent to the managed profile.
 * Only removes those that have been set by the profile owner.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The code has introduced a new method call ""throwIfParentInstance(""clearCrossProfileIntentFilters"")"", an exception handling statement ""throw e.rethrowFromSystemServer();"" has been introduced and the existing exception logging statement ""Log.w(TAG, ""Failed talking with device policy service"", e);"" has been removed. The changes are 3 for control dependency, 4 for other statement (introduction of the new method call), and 2 for exception handling statement.","The addition of the method ""throwIfParentInstance"" may throw a new exception which could lead to a compatibility issue because the behavior when calling ""clearCrossProfileIntentFilters"" may differ if an exception occurs within that new method. Moreover, changing the exception handling strategy from logging the exception to rethrowing it changes the way the method deals with exceptions, thus potentially leading to a different exception being thrown up the call stack instead of just logging it. Therefore, the CI type is 2."
692,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,23,24,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,0,"{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    List<Fragment> fragments = mFragments.retainNonConfig();
    ArrayMap<String, LoaderManager> loaders = mFragments.retainLoaderNonConfig();
    if (activity == null && children == null && fragments == null && loaders == null && mVoiceInteractor == null) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = loaders;
    if (mVoiceInteractor != null) {
        mVoiceInteractor.retainInstance();
        nci.voiceInteractor = mVoiceInteractor;
    }
    return nci;
}","{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();
    // We're already stopped but we've been asked to retain.
    // Our fragments are taken care of but we need to mark the loaders for retention.
    // In order to do this correctly we need to restart the loaders first before
    // handing them off to the next activity.
    mFragments.doLoaderStart();
    mFragments.doLoaderStop(true);
    ArrayMap<String, LoaderManager> loaders = mFragments.retainLoaderNonConfig();
    if (activity == null && children == null && fragments == null && loaders == null && mVoiceInteractor == null) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = loaders;
    if (mVoiceInteractor != null) {
        mVoiceInteractor.retainInstance();
        nci.voiceInteractor = mVoiceInteractor;
    }
    return nci;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The way fragments are retained has changed from `mFragments.retainNonConfig()` to `mFragments.retainNestedNonConfig()`, and new loader management methods (`doLoaderStart()` and `doLoaderStop(true)`) are called before loaders retention. The method return type remains `NonConfigurationInstances`, and the return value depends on the conditions, which have not been altered. The change in how fragments and loaders are handled is a `Control dependency change (3)`, `Other statement changed (4)` because additional method invocations (`doLoaderStart()` and `doLoaderStop(true)`) are added for loader management, and a `Dependent API changed (5)` because `retainNonConfig()` is replaced with `retainNestedNonConfig()`. However, all these changes are internal to the implementation and do not affect the return type or the potential thrown exception types.","Although there are changes in control dependencies and other statements, as well as a change in the dependent API, there is no change that would directly affect the values that could be returned since the structure of the resulting `NonConfigurationInstances` object and the condition for returning `null` are the same. Therefore, there is no Compatibility Issue (`0`)."
693,<android.app.UiModeManager: void setNightMode(int)>,23,24,<android.app.UiModeManager: void setNightMode(int)>,<android.app.UiModeManager: void setNightMode(int)>,0,"{
    if (mService != null) {
        try {
            mService.setNightMode(mode);
        } catch (RemoteException e) {
            Log.e(TAG, ""setNightMode: RemoteException"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setNightMode(mode);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Sets the night mode.  Changes to the night mode are only effective when
 * the car or desk mode is enabled on a device.
 *
 * <p>The mode can be one of:
 * <ul>
 * <li><em>{@link #MODE_NIGHT_NO}<em> - sets the device into notnight
 * mode.</li>
 * <li><em>{@link #MODE_NIGHT_YES}</em> - sets the device into night mode.
 * </li>
 * <li><em>{@link #MODE_NIGHT_AUTO}</em> - automatic night/notnight switching
 * depending on the location and certain other sensors.</li>
 * </ul>
 */
","/**
 * Sets the night mode.
 * <p>
 * The mode can be one of:
 * <ul>
 * <li><em>{@link #MODE_NIGHT_NO}<em> sets the device into
 * {@code notnight} mode</li>
 * <li><em>{@link #MODE_NIGHT_YES}</em> sets the device into
 * {@code night} mode</li>
 * <li><em>{@link #MODE_NIGHT_AUTO}</em> automatically switches between
 * {@code night} and {@code notnight} based on the device's current
 * location and certain other sensors</li>
 * </ul>
 * <p>
 * <strong>Note:</strong> On API 22 and below, changes to the night mode
 * are only effective when the {@link Configuration#UI_MODE_TYPE_CAR car}
 * or {@link Configuration#UI_MODE_TYPE_DESK desk} mode is enabled on a
 * device. Starting in API 23, changes to night mode are always effective.
 *
 * @param mode the night mode to set
 * @see #getNightMode()
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The catch block has changed from logging the exception to throwing it. Specifically, the RemoteException is being re-thrown using the rethrowFromSystemServer method in the later version. Therefore, the type of statement changed is 2.","The change in exception handling could potentially lead to a difference in behavior, as the method in the early version does not throw any exception, but in the late version, it can throw an exception in case of a RemoteException. So, the compatibility issue would be 2."
694,<android.net.ConnectivityManager: NetworkCapabilities getNetworkCapabilities(Network)>,23,24,<android.net.ConnectivityManager: NetworkCapabilities getNetworkCapabilities(Network)>,<android.net.ConnectivityManager: NetworkCapabilities getNetworkCapabilities(Network)>,0,"{
    try {
        return mService.getNetworkCapabilities(network);
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return mService.getNetworkCapabilities(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the {@link android.net.NetworkCapabilities} for the given {@link Network}.  This
 * will return {@code null} if the network is unknown.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param network The {@link Network} object identifying the network in question.
 * @return The {@link android.net.NetworkCapabilities} for the network, or {@code null}.
 */
","/**
 * Get the {@link android.net.NetworkCapabilities} for the given {@link Network}.  This
 * will return {@code null} if the network is unknown.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param network The {@link Network} object identifying the network in question.
 * @return The {@link android.net.NetworkCapabilities} for the network, or {@code null}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The change is only in the exception handling statement, where instead of returning null in the case of a RemoteException, the late version now throws the exception using e.rethrowFromSystemServer(). So the code change type is 2.","As the API now throws a checked exception instead of returning null as in the earlier version, this could lead to a Compatibility Issue for the calling code that is not expecting an exception at this point and instead is expecting possibly a null return value. Therefore, the CI type is 2."
695,"<android.net.ConnectivityManager: void reportNetworkConnectivity(Network,boolean)>",23,24,"<android.net.ConnectivityManager: void reportNetworkConnectivity(Network,boolean)>","<android.net.ConnectivityManager: void reportNetworkConnectivity(Network,boolean)>",0,"{
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Report to the framework whether a network has working connectivity.
 * This provides a hint to the system that a particular network is providing
 * working connectivity or not.  In response the framework may re-evaluate
 * the network's connectivity and might take further action thereafter.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @param hasConnectivity {@code true} if the application was able to successfully access the
 * Internet using {@code network} or {@code false} if not.
 */
","/**
 * Report to the framework whether a network has working connectivity.
 * This provides a hint to the system that a particular network is providing
 * working connectivity or not.  In response the framework may re-evaluate
 * the network's connectivity and might take further action thereafter.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @param hasConnectivity {@code true} if the application was able to successfully access the
 * Internet using {@code network} or {@code false} if not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception statement in the catch block has been modified to throw an exception instead of swallowing it, so the code change type is 2.","Because the late version of the API can potentially throw a new exception (rethrowFromSystemServer) that the early version did not throw, the CI type is 2."
697,"<android.content.res.Resources: TypedArray obtainAttributes(AttributeSet,int[])>",23,24,"<android.content.res.Resources: TypedArray obtainAttributes(AttributeSet,int[])>","<android.content.res.Resources: TypedArray obtainAttributes(AttributeSet,int[])>",0,"{
    int len = attrs.length;
    TypedArray array = TypedArray.obtain(this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mAssets.retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
    array.mXml = parser;
    return array;
}","{
    int len = attrs.length;
    TypedArray array = TypedArray.obtain(this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mResourcesImpl.getAssets().retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
    array.mXml = parser;
    return array;
}",1,"/**
 * Retrieve a set of basic attribute values from an AttributeSet, not
 * performing styling of them using a theme and/or style resources.
 *
 * @param set The current attribute values to retrieve.
 * @param attrs The specific attributes to be retrieved.
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
 */
","/**
 * Retrieve a set of basic attribute values from an AttributeSet, not
 * performing styling of them using a theme and/or style resources.
 *
 * @param set The current attribute values to retrieve.
 * @param attrs The specific attributes to be retrieved.
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is from a direct field access (`mAssets`) to a method call (`mResourcesImpl.getAssets()`).  This indicates a change in the dependent API, so the change type is 5.","Since this change does not alter the method's control flow or the values it processes or returns, it does not introduce a compatibility issue. The underlying implementation still performs the same task, fetching attributes from the assets. Therefore, there is no compatibility issue, hence the CI type is 0."
698,<android.util.ArraySet: boolean add(E)>,23,24,<android.util.ArraySet: boolean add(E)>,<android.util.ArraySet: boolean add(E)>,0,"{
    final int hash;
    int index;
    if (value == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = value.hashCode();
        index = indexOf(value, hash);
    }
    if (index >= 0) {
        return false;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""add: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""add: copy 0-"" + mSize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG)
            Log.d(TAG, ""add: move "" + index + ""-"" + (mSize - index) + "" to "" + (index + 1));
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index, mArray, index + 1, mSize - index);
    }
    mHashes[index] = hash;
    mArray[index] = value;
    mSize++;
    return true;
}","{
    final int hash;
    int index;
    if (value == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(value) : value.hashCode();
        index = indexOf(value, hash);
    }
    if (index >= 0) {
        return false;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""add: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""add: copy 0-"" + mSize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG)
            Log.d(TAG, ""add: move "" + index + ""-"" + (mSize - index) + "" to "" + (index + 1));
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index, mArray, index + 1, mSize - index);
    }
    mHashes[index] = hash;
    mArray[index] = value;
    mSize++;
    return true;
}",1,"/**
 * Adds the specified object to this set. The set is not modified if it
 * already contains the object.
 *
 * @param value the object to add.
 * @return {@code true} if this set is modified, {@code false} otherwise.
 * @throws ClassCastException
 * when the class of the object is inappropriate for this set.
 */
","/**
 * Adds the specified object to this set. The set is not modified if it
 * already contains the object.
 *
 * @param value the object to add.
 * @return {@code true} if this set is modified, {@code false} otherwise.
 * @throws ClassCastException
 * when the class of the object is inappropriate for this set.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The statement to calculate the hash value of the provided object `value` has been changed to conditionally use either `System.identityHashCode(value)` or `value.hashCode()` based on the boolean flag `mIdentityHashCode`. This constitutes a change of type 4 (Other statement changed). Also, it involves a change in the dependent API call `System.identityHashCode(value)` instead of `value.hashCode()` which is a type 5 (Dependent API changed).","There is no Compatibility Issue here. The logic to determine the index and whether to add the object to the ArraySet remains the same. The method's behavior changes only in how it computes the hash of the object, which is an internal detail and does not affect the method's contract or observable behavior. It calculates a hash code to determine object uniqueness within the ArraySet but does not change the ultimate behavior of adding the object to the ArraySet. Thus, it doesn't constitute a Compatibility Issue."
703,<android.animation.ValueAnimator: void cancel()>,23,24,<android.animation.ValueAnimator: void cancel()>,<android.animation.ValueAnimator: void cancel()>,0,"{
    // Only cancel if the animation is actually running or has been started and is about
    // to run
    AnimationHandler handler = getOrCreateAnimationHandler();
    if (mPlayingState != STOPPED || handler.mPendingAnimations.contains(this) || handler.mDelayedAnims.contains(this)) {
        // Only notify listeners if the animator has actually started
        if ((mStarted || mRunning) && mListeners != null) {
            if (!mRunning) {
                // If it's not yet running, then start listeners weren't called. Call them now.
                notifyStartListeners();
            }
            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            for (AnimatorListener listener : tmpListeners) {
                listener.onAnimationCancel(this);
            }
        }
        endAnimation(handler);
    }
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be run on Looper threads"");
    }
    // until animation starts again.
    if (mAnimationEndRequested) {
        return;
    }
    // Only notify listeners if the animator has actually started
    if ((mStarted || mRunning) && mListeners != null) {
        if (!mRunning) {
            // If it's not yet running, then start listeners weren't called. Call them now.
            notifyStartListeners();
        }
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        for (AnimatorListener listener : tmpListeners) {
            listener.onAnimationCancel(this);
        }
    }
    endAnimation();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The early version checks several conditions before possibly calling endAnimation(handler), whereas the late version introduces a new exception throwing if there's no Looper, checks for a different condition (mAnimationEndRequested), and calls endAnimation() without passing a handler. The control dependencies have changed due to different checks and conditions, new exception handling is introduced, and return statements are potentially affected as well. Thus, the change type is 1,2,3.","The introduction of a new exception (AndroidRuntimeException) might cause incompatibility due to different exception behavior, and the removal of checks before ending the animation could potentially lead to a different return behavior when the method is interrupted, for instance, ending the animation prematurely or not ending it at all. Therefore, the CI type is 1,2."
704,<android.widget.TimePicker: int getHour()>,23,24,<android.widget.TimePicker: int getHour()>,<android.widget.TimePicker: int getHour()>,0,"{
    return mDelegate.getCurrentHour();
}","{
    return mDelegate.getHour();
}",1,"/**
 * Returns the currently selected hour using 24-hour time.
 *
 * @return the currently selected hour, in the range (0-23)
 * @see #setHour(int)
 */
","/**
 * Returns the currently selected hour using 24-hour time.
 *
 * @return the currently selected hour, in the range (0-23)
 * @see #setHour(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is a change in the method called on the `mDelegate` object, from `getCurrentHour()` to `getHour()`, which indicates a dependent API change, so the code change type is 5.","There is no Compatibility Issue detected because the method's signature has not changed and the return type remains the same. This change appears to reflect a refactor or renaming within the `mDelegate` object rather than a change that would affect behavior. Without additional information suggesting that the behavior of `getHour()` is different from `getCurrentHour()`, we consider there to be no Compatibility Issue, so the CI type is 0."
705,<android.hardware.radio.RadioManager.FmBandConfig: boolean equals(Object)>,23,24,<android.hardware.radio.RadioManager.FmBandConfig: boolean equals(Object)>,<android.hardware.radio.RadioManager.FmBandConfig: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (!super.equals(obj))
        return false;
    if (!(obj instanceof FmBandConfig))
        return false;
    FmBandConfig other = (FmBandConfig) obj;
    if (mStereo != other.mStereo)
        return false;
    if (mRds != other.mRds)
        return false;
    if (mTa != other.mTa)
        return false;
    if (mAf != other.mAf)
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (!super.equals(obj))
        return false;
    if (!(obj instanceof FmBandConfig))
        return false;
    FmBandConfig other = (FmBandConfig) obj;
    if (mStereo != other.mStereo)
        return false;
    if (mRds != other.mRds)
        return false;
    if (mTa != other.mTa)
        return false;
    if (mAf != other.mAf)
        return false;
    if (mEa != other.mEa)
        return false;
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"A new comparison for the field 'mEa' has been added into the method implementation, which changes the condition for returning the boolean result. Since this is a part of the sequence of checks, this is classified as type 4 (Other statement changed). Type 1 (Return statement changed) applies because a new 'if' check may cause the method to return a different value (false instead of true in the case where mEa != other.mEa).","The additional comparison for 'mEa' could potentially cause this method to return a different boolean result in the case where `this.mEa` is not equal to `other.mEa`, which did not exist in the previous implementation, and hence is considered a CI of type 1 (Compatibility Issue caused by potential different return values or types)."
707,"<android.view.inputmethod.InputMethodManager: boolean switchToNextInputMethod(IBinder,boolean)>",23,24,"<android.view.inputmethod.InputMethodManager: boolean switchToNextInputMethod(IBinder,boolean)>","<android.view.inputmethod.InputMethodManager: boolean switchToNextInputMethod(IBinder,boolean)>",0,"{
    synchronized (mH) {
        try {
            return mService.switchToNextInputMethod(imeToken, onlyCurrentIme);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
            return false;
        }
    }
}","{
    synchronized (mH) {
        try {
            return mService.switchToNextInputMethod(imeToken, onlyCurrentIme);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Force switch to the next input method and subtype. If there is no IME enabled except
 * current IME and subtype, do nothing.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @param onlyCurrentIme if true, the framework will find the next subtype which
 * belongs to the current IME
 * @return true if the current input method and subtype was successfully switched to the next
 * input method and subtype.
 */
","/**
 * Force switch to the next input method and subtype. If there is no IME enabled except
 * current IME and subtype, do nothing.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @param onlyCurrentIme if true, the framework will find the next subtype which
 * belongs to the current IME
 * @return true if the current input method and subtype was successfully switched to the next
 * input method and subtype.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. The catch block was logging the exception and returning false in the early version, but in the late version, it throws a new RuntimeException (rethrowFromSystemServer()), so the code change type is 2.","The change in exception handling means the method now throws a RuntimeException in situations where it previously returned false. This is a change in the behavior of how exceptions are handled, so the CI type is 2."
709,"<android.text.Layout: T[] getParagraphSpans(Spanned,int,int,Class<T>)>",23,24,"<android.text.Layout: T[] getParagraphSpans(Spanned,int,int,Class<T>)>","<android.text.Layout: T[] getParagraphSpans(Spanned,int,int,Class<T>)>",0,"{
    if (start == end && start > 0) {
        return ArrayUtils.emptyArray(type);
    }
    return text.getSpans(start, end, type);
}","{
    if (start == end && start > 0) {
        return ArrayUtils.emptyArray(type);
    }
    if (text instanceof SpannableStringBuilder) {
        return ((SpannableStringBuilder) text).getSpans(start, end, type, false);
    } else {
        return text.getSpans(start, end, type);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"A new control flow statement, an `if` condition, checking if `text` is an instance of `SpannableStringBuilder`, has been introduced. This changes the method of fetching spans when the condition is true. The `getSpans` method used for a `SpannableStringBuilder` now includes an additional parameter `false`, which is not present in the earlier version. Therefore, the code change types are 3 and 5.","The introduction of a new condition check and a different method of getting spans can potentially lead to the API returning different values, as the method of getting spans when `text` is an instance of `SpannableStringBuilder` changed. Thus, there is a Compatibility Issue caused by potential different return values, which is type 1."
710,<android.app.admin.DeviceAdminInfo: Drawable loadIcon(PackageManager)>,23,24,<android.app.admin.DeviceAdminInfo: Drawable loadIcon(PackageManager)>,<android.app.admin.DeviceAdminInfo: Drawable loadIcon(PackageManager)>,0,"{
    return mReceiver.loadIcon(pm);
}","{
    return mActivityInfo.loadIcon(pm);
}",1,"/**
 * Load the user-displayed icon for this device admin.
 *
 * @param pm Supply a PackageManager used to load the device admin's
 * resources.
 */
","/**
 * Load the user-displayed icon for this device admin.
 *
 * @param pm Supply a PackageManager used to load the device admin's
 * resources.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changed from using mReceiver.loadIcon(pm) to mActivityInfo.loadIcon(pm), which indicates that the loadIcon method is being called on a different object. This change is a dependent API change, therefore the code change type is 5.","Despite the change in which object is calling the loadIcon method, there is no indication that this will lead to a different outcome (Drawable object) as both are supposed to represent the same administrative component and should return the same icon. Thus, there is no compatibility issue in this case, and the CI type is 0."
711,<android.net.NetworkCapabilities: int hashCode()>,23,24,<android.net.NetworkCapabilities: int hashCode()>,<android.net.NetworkCapabilities: int hashCode()>,0,"{
    return ((int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mTransportTypes & 0xFFFFFFFF) * 5) + ((int) (mTransportTypes >> 32) * 7) + (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + (TextUtils.isEmpty(mNetworkSpecifier) ? 0 : mNetworkSpecifier.hashCode() * 17));
}","{
    return ((int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mTransportTypes & 0xFFFFFFFF) * 5) + ((int) (mTransportTypes >> 32) * 7) + (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + (TextUtils.isEmpty(mNetworkSpecifier) ? 0 : mNetworkSpecifier.hashCode() * 17) + (mSignalStrength * 19));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"A new term is added to the calculation of the hashCode, specifically (mSignalStrength * 19). This indicates that a new field is now being considered in the hash calculation, so the return statement has changed.","The addition of the mSignalStrength in the hash calculation can change the result of the hashCode method, potentially causing a different value to be returned. Therefore, this introduces a Compatibility Issue of type 1, as it can affect the behavior when objects of this class are used in collections relying on hashCode values, like HashMap, HashSet, etc."
715,"<android.widget.AbsListView: void setItemChecked(int,boolean)>",23,24,"<android.widget.AbsListView: void setItemChecked(int,boolean)>","<android.widget.AbsListView: void setItemChecked(int,boolean)>",0,"{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    // Start selection mode if needed. We don't need to if we're unchecking something.
    if (value && mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode == null) {
        if (mMultiChoiceModeCallback == null || !mMultiChoiceModeCallback.hasWrappedCallback()) {
            throw new IllegalStateException(""AbsListView: attempted to start selection mode "" + ""for CHOICE_MODE_MULTIPLE_MODAL but no choice mode callback was "" + ""supplied. Call setMultiChoiceModeListener to set a callback."");
        }
        mChoiceActionMode = startActionMode(mMultiChoiceModeCallback);
    }
    if (mChoiceMode == CHOICE_MODE_MULTIPLE || mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) {
        boolean oldValue = mCheckStates.get(position);
        mCheckStates.put(position, value);
        if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
            if (value) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            } else {
                mCheckedIdStates.delete(mAdapter.getItemId(position));
            }
        }
        if (oldValue != value) {
            if (value) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
        }
        if (mChoiceActionMode != null) {
            final long id = mAdapter.getItemId(position);
            mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, value);
        }
    } else {
        boolean updateIds = mCheckedIdStates != null && mAdapter.hasStableIds();
        // selected item
        if (value || isItemChecked(position)) {
            mCheckStates.clear();
            if (updateIds) {
                mCheckedIdStates.clear();
            }
        }
        // we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on
        if (value) {
            mCheckStates.put(position, true);
            if (updateIds) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            }
            mCheckedItemCount = 1;
        } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
            mCheckedItemCount = 0;
        }
    }
    // Do not generate a data change while we are in the layout phase
    if (!mInLayout && !mBlockLayoutRequests) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}","{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    // Start selection mode if needed. We don't need to if we're unchecking something.
    if (value && mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode == null) {
        if (mMultiChoiceModeCallback == null || !mMultiChoiceModeCallback.hasWrappedCallback()) {
            throw new IllegalStateException(""AbsListView: attempted to start selection mode "" + ""for CHOICE_MODE_MULTIPLE_MODAL but no choice mode callback was "" + ""supplied. Call setMultiChoiceModeListener to set a callback."");
        }
        mChoiceActionMode = startActionMode(mMultiChoiceModeCallback);
    }
    final boolean itemCheckChanged;
    if (mChoiceMode == CHOICE_MODE_MULTIPLE || mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) {
        boolean oldValue = mCheckStates.get(position);
        mCheckStates.put(position, value);
        if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
            if (value) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            } else {
                mCheckedIdStates.delete(mAdapter.getItemId(position));
            }
        }
        itemCheckChanged = oldValue != value;
        if (itemCheckChanged) {
            if (value) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
        }
        if (mChoiceActionMode != null) {
            final long id = mAdapter.getItemId(position);
            mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, value);
        }
    } else {
        boolean updateIds = mCheckedIdStates != null && mAdapter.hasStableIds();
        // Clear all values if we're checking something, or unchecking the currently
        // selected item
        itemCheckChanged = isItemChecked(position) != value;
        if (value || isItemChecked(position)) {
            mCheckStates.clear();
            if (updateIds) {
                mCheckedIdStates.clear();
            }
        }
        // we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on
        if (value) {
            mCheckStates.put(position, true);
            if (updateIds) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            }
            mCheckedItemCount = 1;
        } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
            mCheckedItemCount = 0;
        }
    }
    // Do not generate a data change while we are in the layout phase or data has not changed
    if (!mInLayout && !mBlockLayoutRequests && itemCheckChanged) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}",1,"/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked state for the item
 */
","/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked state for the item
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
717,"<android.content.RestrictionsManager: void requestPermission(String,String,PersistableBundle)>",23,24,"<android.content.RestrictionsManager: void requestPermission(String,String,PersistableBundle)>","<android.content.RestrictionsManager: void requestPermission(String,String,PersistableBundle)>",0,"{
    if (requestType == null) {
        throw new NullPointerException(""requestType cannot be null"");
    }
    if (requestId == null) {
        throw new NullPointerException(""requestId cannot be null"");
    }
    if (request == null) {
        throw new NullPointerException(""request cannot be null"");
    }
    try {
        if (mService != null) {
            mService.requestPermission(mContext.getPackageName(), requestType, requestId, request);
        }
    } catch (RemoteException re) {
        Log.w(TAG, ""Couldn't reach service"");
    }
}","{
    if (requestType == null) {
        throw new NullPointerException(""requestType cannot be null"");
    }
    if (requestId == null) {
        throw new NullPointerException(""requestId cannot be null"");
    }
    if (request == null) {
        throw new NullPointerException(""request cannot be null"");
    }
    try {
        if (mService != null) {
            mService.requestPermission(mContext.getPackageName(), requestType, requestId, request);
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by an application to request permission for an operation. The contents of the
 * request are passed in a Bundle that contains several pieces of data depending on the
 * chosen request type.
 *
 * @param requestType The type of request. The type could be one of the
 * predefined types specified here or a custom type that the specific
 * Restrictions Provider might understand. For custom types, the type name should be
 * namespaced to avoid collisions with predefined types and types specified by
 * other Restrictions Providers.
 * @param requestId A unique id generated by the app that contains sufficient information
 * to identify the parameters of the request when it receives the id in the response.
 * @param request A PersistableBundle containing the data corresponding to the specified request
 * type. The keys for the data in the bundle depend on the request type.
 *
 * @throws IllegalArgumentException if any of the required parameters are missing.
 */
","/**
 * Called by an application to request permission for an operation. The contents of the
 * request are passed in a Bundle that contains several pieces of data depending on the
 * chosen request type.
 *
 * @param requestType The type of request. The type could be one of the
 * predefined types specified here or a custom type that the specific
 * Restrictions Provider might understand. For custom types, the type name should be
 * namespaced to avoid collisions with predefined types and types specified by
 * other Restrictions Providers.
 * @param requestId A unique id generated by the app that contains sufficient information
 * to identify the parameters of the request when it receives the id in the response.
 * @param request A PersistableBundle containing the data corresponding to the specified request
 * type. The keys for the data in the bundle depend on the request type.
 *
 * @throws IllegalArgumentException if any of the required parameters are missing.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has been changed from logging the RemoteException to rethrowing it with rethrowFromSystemServer(), which indicates a significant change in how exceptions are handled. Therefore, the code change is identified as type 2.","Previously, when the RemoteException occurred, it was logged and the method execution continued, potentially returning normally. In the late version, that same exception will result in the method throwing a new RuntimeException, which is a significant change in behavior. This introduces a Compatibility Issue caused by potential different exception handlings, falling into CI type 2."
718,<android.app.admin.DevicePolicyManager: List<ComponentName> getActiveAdmins()>,23,24,<android.app.admin.DevicePolicyManager: List<ComponentName> getActiveAdmins()>,<android.app.admin.DevicePolicyManager: List<ComponentName> getActiveAdmins()>,0,"{
    return getActiveAdminsAsUser(UserHandle.myUserId());
}","{
    throwIfParentInstance(""getActiveAdmins"");
    return getActiveAdminsAsUser(myUserId());
}",1,"/**
 * Return a list of all currently active device administrators' component
 * names.  If there are no administrators {@code null} may be
 * returned.
 */
","/**
 * Return a list of all currently active device administrators' component
 * names.  If there are no administrators {@code null} may be
 * returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",2,"A new call to throwIfParentInstance(""getActiveAdmins"") has been introduced, and the method to retrieve the user's ID has been changed from UserHandle.myUserId() to myUserId(). Therefore, the change type is 4,5.","The addition of throwIfParentInstance(""getActiveAdmins"") introduces a new potential exception handling pathway, which can lead to a different exception being thrown. This constitutes a CI type of 2."
719,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,23,24,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,0,"{
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.isEnabled();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isEnabled();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if Bluetooth is currently enabled and ready for use.
 * <p>Equivalent to:
 * <code>getBluetoothState() == STATE_ON</code>
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return true if the local adapter is turned on
 */
","/**
 * Return true if Bluetooth is currently enabled and ready for use.
 * <p>Equivalent to:
 * <code>getBluetoothState() == STATE_ON</code>
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return true if the local adapter is turned on
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a change in how the mServiceLock is being accessed, replacing a 'synchronized' block with a 'readLock().lock()' and 'readLock().unlock()' in a try-finally construct. Also, the addition of the 'finally' block is considered an 'other statement changed'. Hence, the code change types are 3 for control dependency change and 4 for other statement changed.","Despite the code modification in synchronization logic, there's no change in the behavior of the API related to what the method potentially returns or the exceptions it might throw. The return and exception behavior remains the same in both versions (returning the result of mService.isEnabled() or false, and logging in case of a RemoteException). The locking mechanism changes don't affect the external behavior; they affect the method's internal concurrency handling, not the API's external behavior. Hence, there is no Compatibility Issue."
720,"<android.view.ViewGroup.TouchTarget: TouchTarget obtain(View,int)>",23,24,"<android.view.ViewGroup.TouchTarget: TouchTarget obtain(View,int)>","<android.view.ViewGroup.TouchTarget: TouchTarget obtain(View,int)>",0,"{
    final TouchTarget target;
    synchronized (sRecycleLock) {
        if (sRecycleBin == null) {
            target = new TouchTarget();
        } else {
            target = sRecycleBin;
            sRecycleBin = target.next;
            sRecycledCount--;
            target.next = null;
        }
    }
    target.child = child;
    target.pointerIdBits = pointerIdBits;
    return target;
}","{
    if (child == null) {
        throw new IllegalArgumentException(""child must be non-null"");
    }
    final TouchTarget target;
    synchronized (sRecycleLock) {
        if (sRecycleBin == null) {
            target = new TouchTarget();
        } else {
            target = sRecycleBin;
            sRecycleBin = target.next;
            sRecycledCount--;
            target.next = null;
        }
    }
    target.child = child;
    target.pointerIdBits = pointerIdBits;
    return target;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The late version introduces a new argument check with an exception-throwing statement (""throw new IllegalArgumentException"") at the beginning of the method, and this introduces both a new control statement and a new exception handling statement, so the change type is 2,3.","This change could lead to an IllegalArgumentException being thrown when 'child' is null, where in the early version it would have led to normal execution and return of a 'TouchTarget'. Thus, this represents a CI of types 1 and 2 for potential different return values or types and different exception handlings."
721,<android.content.res.Resources.Theme: long getNativeTheme()>,23,24,<android.content.res.Resources.Theme: long getNativeTheme()>,<android.content.res.Resources.Theme: long getNativeTheme()>,0,"{
    return mTheme;
}","{
    return mThemeImpl.getNativeTheme();
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method from where the return value is fetched has changed from a direct member access 'mTheme' to calling another method 'mThemeImpl.getNativeTheme()', which shows there’s a dependency on another internal API that has been changed. Thus, the code change type is 5.","The returned value is now dependent on a different method 'getNativeTheme()' which indicates that the return value could be different. Therefore, this change has a potential Compatibility Issue of type 1."
722,"<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>",23,24,"<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>","<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>",0,"{
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;
    switch(specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
    }
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}","{
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;
    switch(specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
    }
    // noinspection ResourceType
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}",1,"/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 * margins, if applicable
 * @param childDimension How big the child wants to be in the current
 * dimension
 * @return a MeasureSpec integer for the child
 */
","/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 * margins, if applicable
 * @param childDimension How big the child wants to be in the current
 * dimension
 * @return a MeasureSpec integer for the child
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
724,<android.hardware.camera2.legacy.CaptureCollector.CaptureHolder: void tryComplete()>,23,24,<android.hardware.camera2.legacy.CaptureCollector.CaptureHolder: void tryComplete()>,<android.hardware.camera2.legacy.CaptureCollector.CaptureHolder: void tryComplete()>,0,"{
    if (!mPreviewCompleted && needsPreview && isPreviewCompleted()) {
        CaptureCollector.this.onPreviewCompleted();
        mPreviewCompleted = true;
    }
    if (isCompleted() && !mCompleted) {
        if (mFailedPreview || mFailedJpeg) {
            if (!mHasStarted) {
                // Send a request error if the capture has not yet started.
                mRequest.failRequest();
                CaptureCollector.this.mDeviceState.setCaptureStart(mRequest, mTimestamp, CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_REQUEST);
            } else {
                // started.
                if (mFailedPreview) {
                    Log.w(TAG, ""Preview buffers dropped for request: "" + mRequest.getRequestId());
                    for (int i = 0; i < mRequest.numPreviewTargets(); i++) {
                        CaptureCollector.this.mDeviceState.setCaptureResult(mRequest, /*result*/
                        null, CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_BUFFER);
                    }
                }
                if (mFailedJpeg) {
                    Log.w(TAG, ""Jpeg buffers dropped for request: "" + mRequest.getRequestId());
                    for (int i = 0; i < mRequest.numJpegTargets(); i++) {
                        CaptureCollector.this.mDeviceState.setCaptureResult(mRequest, /*result*/
                        null, CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_BUFFER);
                    }
                }
            }
        }
        CaptureCollector.this.onRequestCompleted(CaptureHolder.this);
        mCompleted = true;
    }
}","{
    if (!mPreviewCompleted && needsPreview && isPreviewCompleted()) {
        CaptureCollector.this.onPreviewCompleted();
        mPreviewCompleted = true;
    }
    if (isCompleted() && !mCompleted) {
        if (mFailedPreview || mFailedJpeg) {
            if (!mHasStarted) {
                // Send a request error if the capture has not yet started.
                mRequest.failRequest();
                CaptureCollector.this.mDeviceState.setCaptureStart(mRequest, mTimestamp, CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_REQUEST);
            } else {
                // started.
                for (Surface targetSurface : mRequest.getRequest().getTargets()) {
                    try {
                        if (mRequest.jpegType(targetSurface)) {
                            if (mFailedJpeg) {
                                CaptureCollector.this.mDeviceState.setCaptureResult(mRequest, /*result*/
                                null, CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_BUFFER, targetSurface);
                            }
                        } else {
                            // preview buffer
                            if (mFailedPreview) {
                                CaptureCollector.this.mDeviceState.setCaptureResult(mRequest, /*result*/
                                null, CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_BUFFER, targetSurface);
                            }
                        }
                    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                        Log.e(TAG, ""Unexpected exception when querying Surface: "" + e);
                    }
                }
            }
        }
        CaptureCollector.this.onRequestCompleted(CaptureHolder.this);
        mCompleted = true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The for-loop and logging statements for mFailedPreview and mFailedJpeg detection have been replaced with a for-each loop that iterates over all target surfaces and checks their type. There is now a try-catch block that handles a LegacyExceptionUtils.BufferQueueAbandonedException, which is a new exception handling change. Additionally, underneath the if block for checking mFailedJpeg and mFailedPreview, the method setCaptureResult now receives the targetSurface, which wasn't in the previous implementation; this constitutes an other statement change. Thus, the changes are of type 2,3,4.","Since there is a new try-catch block for a specific exception, it introduces a different exception handling behavior as the exception is no longer swallowed and logged but potentially propagated upward. This could cause a method that previously did not throw now to throw an exception, which indicates a potential Compatibility Issue of type 2. The alteration of logic in the for-loop and how CaptureResult is set for the different surfaces (including the addition of targetSurface as a parameter) has affected the control flow and may lead to different return behavior. This may result in different outcomes when the method completes, thus leading to a potential Compatibility Issue of type 1."
726,"<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraMetadataNative createRequestTemplate(CameraCharacteristics,int)>",23,24,"<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraMetadataNative createRequestTemplate(CameraCharacteristics,int)>","<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraMetadataNative createRequestTemplate(CameraCharacteristics,int)>",0,"{
    if (!ArrayUtils.contains(sAllowedTemplates, templateId)) {
        throw new IllegalArgumentException(""templateId out of range"");
    }
    CameraMetadataNative m = new CameraMetadataNative();
    /*
         * NOTE: If adding new code here and it needs to query the static info,
         * query the camera characteristics, so we can reuse this for api2 code later
         * to create our own templates in the framework
         */
    /*
         * control.*
         */
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CameraMetadata.CONTROL_AWB_MODE_AUTO);
    // AWB is always unconditionally available in API1 devices
    // control.aeAntibandingMode
    m.set(CaptureRequest.CONTROL_AE_ANTIBANDING_MODE, CONTROL_AE_ANTIBANDING_MODE_AUTO);
    // control.aeExposureCompensation
    m.set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, 0);
    // control.aeLock
    m.set(CaptureRequest.CONTROL_AE_LOCK, false);
    // control.aePrecaptureTrigger
    m.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CONTROL_AE_PRECAPTURE_TRIGGER_IDLE);
    // control.afTrigger
    m.set(CaptureRequest.CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CONTROL_AWB_MODE_AUTO);
    // control.awbLock
    m.set(CaptureRequest.CONTROL_AWB_LOCK, false);
    // control.aeRegions, control.awbRegions, control.afRegions
    {
        Rect activeArray = c.get(SENSOR_INFO_ACTIVE_ARRAY_SIZE);
        MeteringRectangle[] activeRegions = new MeteringRectangle[] { new MeteringRectangle(/*x*/
        0, /*y*/
        0, /*width*/
        activeArray.width() - 1, /*height*/
        activeArray.height() - 1, /*weight*/
        0) };
        m.set(CaptureRequest.CONTROL_AE_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AWB_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AF_REGIONS, activeRegions);
    }
    // control.captureIntent
    {
        int captureIntent;
        switch(templateId) {
            case CameraDevice.TEMPLATE_PREVIEW:
                captureIntent = CONTROL_CAPTURE_INTENT_PREVIEW;
                break;
            case CameraDevice.TEMPLATE_STILL_CAPTURE:
                captureIntent = CONTROL_CAPTURE_INTENT_STILL_CAPTURE;
                break;
            case CameraDevice.TEMPLATE_RECORD:
                captureIntent = CONTROL_CAPTURE_INTENT_VIDEO_RECORD;
                break;
            default:
                // Can't get anything else since it's guarded by the IAE check
                throw new AssertionError(""Impossible; keep in sync with sAllowedTemplates"");
        }
        m.set(CaptureRequest.CONTROL_CAPTURE_INTENT, captureIntent);
    }
    // control.aeMode
    m.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);
    // AE is always unconditionally available in API1 devices
    // control.mode
    m.set(CaptureRequest.CONTROL_MODE, CONTROL_MODE_AUTO);
    // control.afMode
    {
        Float minimumFocusDistance = c.get(LENS_INFO_MINIMUM_FOCUS_DISTANCE);
        int afMode;
        if (minimumFocusDistance != null && minimumFocusDistance == LENS_INFO_MINIMUM_FOCUS_DISTANCE_FIXED_FOCUS) {
            // Cannot control auto-focus with fixed-focus cameras
            afMode = CameraMetadata.CONTROL_AF_MODE_OFF;
        } else {
            // If a minimum focus distance is reported; the camera must have AF
            afMode = CameraMetadata.CONTROL_AF_MODE_AUTO;
            if (templateId == CameraDevice.TEMPLATE_RECORD || templateId == CameraDevice.TEMPLATE_VIDEO_SNAPSHOT) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_VIDEO)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO;
                }
            } else if (templateId == CameraDevice.TEMPLATE_PREVIEW || templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_PICTURE)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
                }
            }
        }
        if (DEBUG) {
            Log.v(TAG, ""createRequestTemplate (templateId="" + templateId + ""),"" + "" afMode="" + afMode + "", minimumFocusDistance="" + minimumFocusDistance);
        }
        m.set(CaptureRequest.CONTROL_AF_MODE, afMode);
    }
    {
        // control.aeTargetFpsRange
        Range<Integer>[] availableFpsRange = c.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);
        // Pick FPS range with highest max value, tiebreak on higher min value
        Range<Integer> bestRange = availableFpsRange[0];
        for (Range<Integer> r : availableFpsRange) {
            if (bestRange.getUpper() < r.getUpper()) {
                bestRange = r;
            } else if (bestRange.getUpper() == r.getUpper() && bestRange.getLower() < r.getLower()) {
                bestRange = r;
            }
        }
        m.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, bestRange);
    }
    // control.sceneMode -- DISABLED is always available
    m.set(CaptureRequest.CONTROL_SCENE_MODE, CONTROL_SCENE_MODE_DISABLED);
    /*
         * statistics.*
         */
    // statistics.faceDetectMode
    m.set(CaptureRequest.STATISTICS_FACE_DETECT_MODE, STATISTICS_FACE_DETECT_MODE_OFF);
    /*
         * flash.*
         */
    // flash.mode
    m.set(CaptureRequest.FLASH_MODE, FLASH_MODE_OFF);
    /*
         * noiseReduction.*
         */
    m.set(CaptureRequest.NOISE_REDUCTION_MODE, NOISE_REDUCTION_MODE_FAST);
    /*
         * lens.*
         */
    // lens.focalLength
    m.set(CaptureRequest.LENS_FOCAL_LENGTH, c.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS)[0]);
    /*
         * jpeg.*
         */
    // jpeg.thumbnailSize - set smallest non-zero size if possible
    Size[] sizes = c.get(CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES);
    m.set(CaptureRequest.JPEG_THUMBNAIL_SIZE, (sizes.length > 1) ? sizes[1] : sizes[0]);
    // TODO: map other request template values
    return m;
}","{
    if (!ArrayUtils.contains(sAllowedTemplates, templateId)) {
        throw new IllegalArgumentException(""templateId out of range"");
    }
    CameraMetadataNative m = new CameraMetadataNative();
    /*
         * NOTE: If adding new code here and it needs to query the static info,
         * query the camera characteristics, so we can reuse this for api2 code later
         * to create our own templates in the framework
         */
    /*
         * control.*
         */
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CameraMetadata.CONTROL_AWB_MODE_AUTO);
    // AWB is always unconditionally available in API1 devices
    // control.aeAntibandingMode
    m.set(CaptureRequest.CONTROL_AE_ANTIBANDING_MODE, CONTROL_AE_ANTIBANDING_MODE_AUTO);
    // control.aeExposureCompensation
    m.set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, 0);
    // control.aeLock
    m.set(CaptureRequest.CONTROL_AE_LOCK, false);
    // control.aePrecaptureTrigger
    m.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CONTROL_AE_PRECAPTURE_TRIGGER_IDLE);
    // control.afTrigger
    m.set(CaptureRequest.CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CONTROL_AWB_MODE_AUTO);
    // control.awbLock
    m.set(CaptureRequest.CONTROL_AWB_LOCK, false);
    // control.aeRegions, control.awbRegions, control.afRegions
    {
        Rect activeArray = c.get(SENSOR_INFO_ACTIVE_ARRAY_SIZE);
        MeteringRectangle[] activeRegions = new MeteringRectangle[] { new MeteringRectangle(/*x*/
        0, /*y*/
        0, /*width*/
        activeArray.width() - 1, /*height*/
        activeArray.height() - 1, /*weight*/
        0) };
        m.set(CaptureRequest.CONTROL_AE_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AWB_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AF_REGIONS, activeRegions);
    }
    // control.captureIntent
    {
        int captureIntent;
        switch(templateId) {
            case CameraDevice.TEMPLATE_PREVIEW:
                captureIntent = CONTROL_CAPTURE_INTENT_PREVIEW;
                break;
            case CameraDevice.TEMPLATE_STILL_CAPTURE:
                captureIntent = CONTROL_CAPTURE_INTENT_STILL_CAPTURE;
                break;
            case CameraDevice.TEMPLATE_RECORD:
                captureIntent = CONTROL_CAPTURE_INTENT_VIDEO_RECORD;
                break;
            default:
                // Can't get anything else since it's guarded by the IAE check
                throw new AssertionError(""Impossible; keep in sync with sAllowedTemplates"");
        }
        m.set(CaptureRequest.CONTROL_CAPTURE_INTENT, captureIntent);
    }
    // control.aeMode
    m.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);
    // AE is always unconditionally available in API1 devices
    // control.mode
    m.set(CaptureRequest.CONTROL_MODE, CONTROL_MODE_AUTO);
    // control.afMode
    {
        Float minimumFocusDistance = c.get(LENS_INFO_MINIMUM_FOCUS_DISTANCE);
        int afMode;
        if (minimumFocusDistance != null && minimumFocusDistance == LENS_INFO_MINIMUM_FOCUS_DISTANCE_FIXED_FOCUS) {
            // Cannot control auto-focus with fixed-focus cameras
            afMode = CameraMetadata.CONTROL_AF_MODE_OFF;
        } else {
            // If a minimum focus distance is reported; the camera must have AF
            afMode = CameraMetadata.CONTROL_AF_MODE_AUTO;
            if (templateId == CameraDevice.TEMPLATE_RECORD || templateId == CameraDevice.TEMPLATE_VIDEO_SNAPSHOT) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_VIDEO)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO;
                }
            } else if (templateId == CameraDevice.TEMPLATE_PREVIEW || templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_PICTURE)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
                }
            }
        }
        if (DEBUG) {
            Log.v(TAG, ""createRequestTemplate (templateId="" + templateId + ""),"" + "" afMode="" + afMode + "", minimumFocusDistance="" + minimumFocusDistance);
        }
        m.set(CaptureRequest.CONTROL_AF_MODE, afMode);
    }
    {
        // control.aeTargetFpsRange
        Range<Integer>[] availableFpsRange = c.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);
        // Pick FPS range with highest max value, tiebreak on higher min value
        Range<Integer> bestRange = availableFpsRange[0];
        for (Range<Integer> r : availableFpsRange) {
            if (bestRange.getUpper() < r.getUpper()) {
                bestRange = r;
            } else if (bestRange.getUpper() == r.getUpper() && bestRange.getLower() < r.getLower()) {
                bestRange = r;
            }
        }
        m.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, bestRange);
    }
    // control.sceneMode -- DISABLED is always available
    m.set(CaptureRequest.CONTROL_SCENE_MODE, CONTROL_SCENE_MODE_DISABLED);
    /*
         * statistics.*
         */
    // statistics.faceDetectMode
    m.set(CaptureRequest.STATISTICS_FACE_DETECT_MODE, STATISTICS_FACE_DETECT_MODE_OFF);
    /*
         * flash.*
         */
    // flash.mode
    m.set(CaptureRequest.FLASH_MODE, FLASH_MODE_OFF);
    /*
         * noiseReduction.*
         */
    if (templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
        m.set(CaptureRequest.NOISE_REDUCTION_MODE, NOISE_REDUCTION_MODE_HIGH_QUALITY);
    } else {
        m.set(CaptureRequest.NOISE_REDUCTION_MODE, NOISE_REDUCTION_MODE_FAST);
    }
    /*
        * colorCorrection.*
        */
    if (templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
        m.set(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE, COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY);
    } else {
        m.set(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE, COLOR_CORRECTION_ABERRATION_MODE_FAST);
    }
    /*
         * lens.*
         */
    // lens.focalLength
    m.set(CaptureRequest.LENS_FOCAL_LENGTH, c.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS)[0]);
    /*
         * jpeg.*
         */
    // jpeg.thumbnailSize - set smallest non-zero size if possible
    Size[] sizes = c.get(CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES);
    m.set(CaptureRequest.JPEG_THUMBNAIL_SIZE, (sizes.length > 1) ? sizes[1] : sizes[0]);
    // TODO: map other request template values
    return m;
}",1,"/**
 * Create a request template
 *
 * @param c a non-{@code null} camera characteristics for this camera
 * @param templateId a non-negative template ID
 *
 * @return a non-{@code null} request template
 *
 * @throws IllegalArgumentException if {@code templateId} was invalid
 *
 * @see android.hardware.camera2.CameraDevice#TEMPLATE_MANUAL
 */
","/**
 * Create a request template
 *
 * @param c a non-{@code null} camera characteristics for this camera
 * @param templateId a non-negative template ID
 *
 * @return a non-{@code null} request template
 *
 * @throws IllegalArgumentException if {@code templateId} was invalid
 *
 * @see android.hardware.camera2.CameraDevice#TEMPLATE_MANUAL
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
727,<android.app.admin.DevicePolicyManager: int getKeyguardDisabledFeatures(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getKeyguardDisabledFeatures(ComponentName)>,<android.app.admin.DevicePolicyManager: int getKeyguardDisabledFeatures(ComponentName)>,0,"{
    return getKeyguardDisabledFeatures(admin, UserHandle.myUserId());
}","{
    return getKeyguardDisabledFeatures(admin, myUserId());
}",1,"/**
 * Determine whether or not features have been disabled in keyguard either by the current
 * admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled features in keyguard.
 * @return bitfield of flags. See {@link #setKeyguardDisabledFeatures(ComponentName, int)}
 * for a list.
 */
","/**
 * Determine whether or not features have been disabled in keyguard either by the calling
 * admin, if specified, or all admins that set retrictions on this user and its participating
 * profiles. Restrictions on profiles that have a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to check whether any
 * admins have disabled features in keyguard.
 * @return bitfield of flags. See {@link #setKeyguardDisabledFeatures(ComponentName, int)}
 * for a list.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change involves a call to a different method for retrieving the user ID: from UserHandle.myUserId() to myUserId(). This is an external method call change, corresponding to code change type 5 (Dependent API changed).","There is no definitive Compatibility Issue since the method getKeyguardDisabledFeatures likely depends on the current user ID. The change in how the user ID is obtained does not inherently imply that the behavior of getKeyguardDisabledFeatures will be different, assuming both UserHandle.myUserId() and myUserId() methods return the same user ID. Therefore, there's no expectation of a change in either return values or exception handling caused specifically by this difference."
728,<android.app.Notification.Builder: Builder setShowWhen(boolean)>,23,24,<android.app.Notification.Builder: Builder setShowWhen(boolean)>,<android.app.Notification.Builder: Builder setShowWhen(boolean)>,0,"{
    mShowWhen = show;
    return this;
}","{
    mN.extras.putBoolean(EXTRA_SHOW_WHEN, show);
    return this;
}",1,"/**
 * Control whether the timestamp set with {@link #setWhen(long) setWhen} is shown
 * in the content view.
 */
","/**
 * Control whether the timestamp set with {@link #setWhen(long) setWhen} is shown
 * in the content view.
 * For apps targeting {@link android.os.Build.VERSION_CODES#N} and above, this defaults to
 * {@code false}. For earlier apps, the default is {@code true}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method body has changed, as the property is now set using mN.extras.putBoolean instead of directly setting mShowWhen. This is an internal implementation detail that changed, and it also involves a dependent API (putBoolean method of 'extras'). The code change type is 4,5.","This change could lead to a compatibility issue because the mechanism for setting the 'show' state has changed, which could potentially affect the behavior of the Notification built by this Builder. If the handling of mN.extras in other methods has changed or in case 'mShowWhen' was expected to be directly modified (for example, if any reflection based code was dependent on the direct field modification), the new implementation would not meet that expectation. This means that the API could exhibit different behavior, and thus, there is a compatibility issue of type 1."
729,"<android.hardware.camera2.legacy.LegacyCameraDevice: boolean containsSurfaceId(Surface,Collection<Long>)>",23,24,"<android.hardware.camera2.legacy.LegacyCameraDevice: boolean containsSurfaceId(Surface,Collection<Long>)>","<android.hardware.camera2.legacy.LegacyCameraDevice: boolean containsSurfaceId(Surface,Collection<Long>)>",0,"{
    long id = getSurfaceId(s);
    return ids.contains(id);
}","{
    long id = 0;
    try {
        id = getSurfaceId(s);
    } catch (BufferQueueAbandonedException e) {
        // If surface is abandoned, return false.
        return false;
    }
    return ids.contains(id);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,5",2,"The late implementation includes an additional try-catch block for handling `BufferQueueAbandonedException`, so if this exception occurs, the early version would have propagated it, but the late version now catches it and returns false. This represents a change in exception handling (type 2), a control dependency change since the flow of the code is modified with the try-catch block (type 3), and the dependent API `getSurfaceId(s)` is the same but the handling of exceptions it may throw has changed (type 5).","The change indeed results in a potential CI due to different exception handling. In the late version, if `BufferQueueAbandonedException` is thrown by `getSurfaceId(s)`, the method will now catch this exception and return false, whereas previously it would have allowed the exception to propagate up to the caller. This is a Compatibility Issue caused by different exception handling behavior (type 2)."
730,<android.app.admin.DeviceAdminInfo: CharSequence loadLabel(PackageManager)>,23,24,<android.app.admin.DeviceAdminInfo: CharSequence loadLabel(PackageManager)>,<android.app.admin.DeviceAdminInfo: CharSequence loadLabel(PackageManager)>,0,"{
    return mReceiver.loadLabel(pm);
}","{
    return mActivityInfo.loadLabel(pm);
}",1,"/**
 * Load the user-displayed label for this device admin.
 *
 * @param pm Supply a PackageManager used to load the device admin's
 * resources.
 */
","/**
 * Load the user-displayed label for this device admin.
 *
 * @param pm Supply a PackageManager used to load the device admin's
 * resources.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method being called has changed from mReceiver.loadLabel(pm) to mActivityInfo.loadLabel(pm), indicating that the dependent API used inside the method implementation has changed. Thus, the code change type is 5.","Although a dependent API has been changed, assuming mReceiver and mActivityInfo both refer to the component that provides the label, this would not necessarily lead to a change in behavior from the perspective of the method's contract. Thus, we cannot conclude that this change definitely leads to a Compatibility Issue based on the information given, so the CI type is 0."
732,"<android.view.accessibility.AccessibilityNodeInfo.RangeInfo: RangeInfo obtain(int,float,float,float)>",23,24,"<android.view.accessibility.AccessibilityNodeInfo.RangeInfo: RangeInfo obtain(int,float,float,float)>","<android.view.accessibility.AccessibilityNodeInfo.RangeInfo: RangeInfo obtain(int,float,float,float)>",0,"{
    RangeInfo info = sPool.acquire();
    return (info != null) ? info : new RangeInfo(type, min, max, current);
}","{
    RangeInfo info = sPool.acquire();
    if (info == null) {
        return new RangeInfo(type, min, max, current);
    }
    info.mType = type;
    info.mMin = min;
    info.mMax = max;
    info.mCurrent = current;
    return info;
}",1,"/**
 * Obtains a pooled instance.
 *
 * @param type The type of the range.
 * @param min The min value.
 * @param max The max value.
 * @param current The current value.
 */
","/**
 * Obtains a pooled instance.
 *
 * @param type The type of the range.
 * @param min The min value.
 * @param max The max value.
 * @param current The current value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Control dependency changed, because of the introduction of a new 'if' condition structure for assigning values to 'info'. Additionally, a return statement changed because the process of returning an acquired 'info' or a new 'RangeInfo' differs, which is updating the fields of 'info' in case it is acquired from the pool. Therefore, the code change types are 1,3.","The change in return statement results in different behavior of the method. In the early version, a new RangeInfo is created only when 'info' is null, without modifying the acquired 'info' in any way. In the late version, the object properties of 'info' are updated if 'info' is not null before returning it. Hence, the API potentially returns objects with different states, which leads to a CI, and the type is 1."
733,"<android.app.ActivityTransitionCoordinator: Transition configureTransition(Transition,boolean)>",23,24,"<android.app.ActivityTransitionCoordinator: Transition configureTransition(Transition,boolean)>","<android.app.ActivityTransitionCoordinator: Transition configureTransition(Transition,boolean)>",0,"{
    if (transition != null) {
        transition = transition.clone();
        transition.setEpicenterCallback(mEpicenterCallback);
        transition = setTargets(transition, includeTransitioningViews);
    }
    return transition;
}","{
    if (transition != null) {
        transition = transition.clone();
        transition.setEpicenterCallback(mEpicenterCallback);
        transition = setTargets(transition, includeTransitioningViews);
    }
    noLayoutSuppressionForVisibilityTransitions(transition);
    return transition;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new method call ""noLayoutSuppressionForVisibilityTransitions(transition);"" before the return statement in the late version, which counts as an Other statement changed (code change type 4).","Since this newly introduced method call does not affect the control flow nor does it change the returned value or the exceptions that could be thrown by the method, it does not cause a Compatibility Issue (CI type 0)."
734,"<android.util.Log: int i(String,String,Throwable)>",23,24,"<android.util.Log: int i(String,String,Throwable)>","<android.util.Log: int i(String,String,Throwable)>",0,"{
    return println_native(LOG_ID_MAIN, INFO, tag, msg + '\n' + getStackTraceString(tr));
}","{
    return printlns(LOG_ID_MAIN, INFO, tag, msg, tr);
}",1,"/**
 * Send a {@link #INFO} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #INFO} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method used within the return statement has changed from println_native to printlns, and the way parameters are passed is also different, which indicates a change in the dependent API (the method called has changed). Therefore, the code change type is 1,5.","Since there is a change in the method invocation including the method name and the way parameters are handled, this can lead to a different return value. Thus, the CI type is 1."
735,"<android.text.Html: Spanned fromHtml(String,ImageGetter,TagHandler)>",23,24,"<android.text.Html: Spanned fromHtml(String,ImageGetter,TagHandler)>","<android.text.Html: Spanned fromHtml(String,ImageGetter,TagHandler)>",0,"{
    Parser parser = new Parser();
    try {
        parser.setProperty(Parser.schemaProperty, HtmlParser.schema);
    } catch (org.xml.sax.SAXNotRecognizedException e) {
        // Should not happen.
        throw new RuntimeException(e);
    } catch (org.xml.sax.SAXNotSupportedException e) {
        // Should not happen.
        throw new RuntimeException(e);
    }
    HtmlToSpannedConverter converter = new HtmlToSpannedConverter(source, imageGetter, tagHandler, parser);
    return converter.convert();
}","{
    return fromHtml(source, FROM_HTML_MODE_LEGACY, imageGetter, tagHandler);
}",1,"/**
 * Returns displayable styled text from the provided HTML string.
 * Any &lt;img&gt; tags in the HTML will use the specified ImageGetter
 * to request a representation of the image (use null if you don't
 * want this) and the specified TagHandler to handle unknown tags
 * (specify null if you don't want this).
 *
 * <p>This uses TagSoup to handle real HTML, including all of the brokenness found in the wild.
 */
","/**
 * Returns displayable styled text from the provided HTML string with the legacy flags
 * {@link #FROM_HTML_MODE_LEGACY}.
 *
 * @deprecated use {@link #fromHtml(String, int, ImageGetter, TagHandler)} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation in the late version calls a different method fromHtml() with different arguments from the early version, which indicates that the dependent API has changed. Additionally, the actual conversion logic is not visible in the late version, which means the return statement has effectively changed. So the code change types are 1,5.","Since the implementation is changed to invoke a different method that likely has its own conversion logic, there is a potential for the returned Spanned object to be different. Consequently, this constitutes a compatibility issue caused by potential different return values or types. The CI type is 1."
736,<android.content.res.Resources: String getResourcePackageName(int)>,23,24,<android.content.res.Resources: String getResourcePackageName(int)>,<android.content.res.Resources: String getResourcePackageName(int)>,0,"{
    String str = mAssets.getResourcePackageName(resid);
    if (str != null)
        return str;
    throw new NotFoundException(""Unable to find resource ID #0x"" + Integer.toHexString(resid));
}","{
    return mResourcesImpl.getResourcePackageName(resid);
}",1,"/**
 * Return the package name for a given resource identifier.
 *
 * @param resid The resource identifier whose package name is to be
 * retrieved.
 *
 * @return A string holding the package name of the resource.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getResourceName
 */
","/**
 * Return the package name for a given resource identifier.
 *
 * @param resid The resource identifier whose package name is to be
 * retrieved.
 *
 * @return A string holding the package name of the resource.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getResourceName
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method used to get the resource package name has changed from mAssets.getResourcePackageName to mResourcesImpl.getResourcePackageName, and there's no longer a null check or throw statement, so the change type is 1,5.","Because the early version API would throw an exception if str is null and the late version API does not have this check, this could lead to a different behavior, hence a potential different return value or type. Additionally, the early version API throws NotFoundException which the late version does not seem to throw anymore, meaning there is a change in the type of exceptions thrown. So the CI type is 1."
737,<android.app.Notification.Builder: Builder setTicker(CharSequence)>,23,24,<android.app.Notification.Builder: Builder setTicker(CharSequence)>,<android.app.Notification.Builder: Builder setTicker(CharSequence)>,0,"{
    mTickerText = safeCharSequence(tickerText);
    return this;
}","{
    mN.tickerText = safeCharSequence(tickerText);
    return this;
}",1,"/**
 * Set the ""ticker"" text which is sent to accessibility services.
 *
 * @see Notification#tickerText
 */
","/**
 * Set the ""ticker"" text which is sent to accessibility services.
 *
 * @see Notification#tickerText
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has changed, where the ticker text is being set to a different variable. The early version sets `mTickerText` directly, while the late version sets `mN.tickerText`. This doesn't affect the method's return type, but it does represent a change in what object or field the data is being assigned to—hence the appropriate change type is 4.","There is no compatibility issue that could arise from this change as the return type remains a reference to the `Builder` object (`this`), and no additional behavior (like exception throwing or return value change) is introduced."
738,"<android.content.res.ColorStateList.ColorStateListFactory: ColorStateList newInstance(Resources,Theme)>",23,24,"<android.content.res.ColorStateList.ColorStateListFactory: ColorStateList newInstance(Resources,Theme)>","<android.content.res.ColorStateList.ColorStateListFactory: ColorStateList newInstance(Resources,Theme)>",0,"{
    return mSrc.obtainForTheme(theme);
}","{
    return (ColorStateList) mSrc.obtainForTheme(theme);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is the addition of a type cast to (ColorStateList). This is an internal detail and doesn't affect the logic of the method, so the code change type is 4.",The addition of a type cast does not modify the behavior of the method as it is returning the same type as before and will not cause the API to return a different value or throw a different exception. No Compatibility Issues should arise from this; the CI type is 0.
739,<android.app.Activity: void setTaskDescription(TaskDescription)>,23,24,<android.app.Activity: void setTaskDescription(TaskDescription)>,<android.app.Activity: void setTaskDescription(TaskDescription)>,0,"{
    ActivityManager.TaskDescription td;
    // Scale the icon down to something reasonable if it is provided
    if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
        final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
        final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
        td = new ActivityManager.TaskDescription(taskDescription.getLabel(), icon, taskDescription.getPrimaryColor());
    } else {
        td = taskDescription;
    }
    try {
        ActivityManagerNative.getDefault().setTaskDescription(mToken, td);
    } catch (RemoteException e) {
    }
}","{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFrom(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(icon);
        }
    }
    try {
        ActivityManagerNative.getDefault().setTaskDescription(mToken, mTaskDescription);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
","/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"The code changes include adding new control statements, changing some of the logic for assigning the task description, and altering which object is sent to the ActivityManagerNative. Specifically, in the early version, a new `ActivityManager.TaskDescription` object is created directly and passed to `ActivityManagerNative.getDefault().setTaskDescription`, while in the late version, the existing `mTaskDescription` object is updated with `copyFrom` and `setIcon` methods, and then passed to `ActivityManagerNative.getDefault().setTaskDescription`. This is reflected in the conditions and use of the object, so the change types include 1 (new return statement in terms of the usage of the object), 3 (change in control dependency within if conditions), 4 (other statements such as the assignment of the `icon` and the change of the object that receives the method call), and 5 (dependent API changed due to the `copyFrom` and `setIcon` method calls).","There is no Compatibility Issue detected since the behavior of the method is preserved. The method's intent is still to set the task description for the activity; it's just that the implementation of this process has been updated. The same operations are being performed, albeit in a slightly different way, and the method doesn't return any value (it's `void`) nor does it change the way exceptions are handled between versions."
740,"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>",23,24,"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>","<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>",0,"{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess();
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()), myContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return binder;
}","{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess(myContext);
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()), myContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return binder;
}",1,"/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */
","/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed by adding a parameter to the method call service.prepareToLeaveProcess(myContext). This means that a dependent API service.prepareToLeaveProcess() has been changed (the number of parameters it takes has been altered). Hence, the code change type is 5.","There is no Compatibility Issue arising from this particular code change. Although the dependent API has undergone a change, this does not inherently affect the return value or the exception handling of the peekService() API, assuming the new parameter does not alter the exceptional conditions or outcomes of the prepareToLeaveProcess call. Given the nature of prepareToLeaveProcess, which is typically for cleanup and preparatory work, it is unlikely to influence the return value of the peekService() method, which is intended to return a binder object to a service. Thus, we can infer it as 0 (No Compatibility Issue)."
742,"<android.content.res.TypedArray: float getFraction(int,int,int,float)>",23,24,"<android.content.res.TypedArray: float getFraction(int,int,int,float)>","<android.content.res.TypedArray: float getFraction(int,int,int,float)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to fraction: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to fraction: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */
","/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version implementation, a new local variable `attrIndex` is introduced to hold the value of `index` before it gets multiplied. This is just a rename of the variable for clarity within the scope of the method and doesn't change the logic of the existing control flow or external behavior of the method. Additionally, the text of the exception message is modified to include this variable rather than the modified index, but this message text does not constitute a compatibility concern as it doesn't affect the functional outcome of the method. Thus, the code change type is 4.","Despite the change in the variable name and the update to the exception message, the functionality, the return type, and values remain unchanged. There are no changes to the return statements or exception handling that change the fundamental behavior encountered by users of the method. Therefore, there is no compatibility issue, and the CI type is 0."
743,<android.widget.Editor.SuggestionsPopupWindow: void show()>,23,24,<android.widget.Editor.SuggestionsPopupWindow: void show()>,<android.widget.Editor.SuggestionsPopupWindow: void show()>,0,"{
    if (!(mTextView.getText() instanceof Editable))
        return;
    if (updateSuggestions()) {
        mCursorWasVisibleBeforeSuggestions = mCursorVisible;
        mTextView.setCursorVisible(false);
        mIsShowingUp = true;
        super.show();
    }
}","{
    if (!(mTextView.getText() instanceof Editable))
        return;
    if (extractedTextModeWillBeStarted()) {
        return;
    }
    if (updateSuggestions()) {
        mCursorWasVisibleBeforeSuggestions = mCursorVisible;
        mTextView.setCursorVisible(false);
        mIsShowingUp = true;
        super.show();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late implementation adds a new if-statement that invokes extractedTextModeWillBeStarted() and returns early from the method if the condition is true. Therefore, this could potentially alter the flow of the method, resulting in other statements not executing. So, the changes are classified as a control dependency change (3) and another statement changed with the introduction of a new if-statement (4).","However, these changes do not affect the return value of the method since it is a void method, nor do they introduce new exceptions or change existing exception handling. Thus, no compatibility issue is introduced by this change, and the CI type is 0."
744,<android.content.res.Resources: boolean getBoolean(int)>,23,24,<android.content.res.Resources: boolean getBoolean(int)>,<android.content.res.Resources: boolean getBoolean(int)>,0,"{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data != 0;
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        mResourcesImpl.getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data != 0;
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Return a boolean associated with a particular resource ID.  This can be
 * used with any integral resource value, and will return true if it is
 * non-zero.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns the boolean value contained in the resource.
 */
","/**
 * Return a boolean associated with a particular resource ID.  This can be
 * used with any integral resource value, and will return true if it is
 * non-zero.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns the boolean value contained in the resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The code has been changed to use a new method (obtainTempTypedValue) for retrieving a TypedValue and releasing it with another new method (releaseTempTypedValue) which is surrounded by a try-finally block. The call to getValue is now made on an object named mResourcesImpl instead of directly, which could be due to an internal structure change. This is reflected in changes of control dependency (introduction of try-finally block), other statements (the way TypedValue is obtained and released), and dependent API (the call to getValue now being made on a new object mResourcesImpl). Therefore, the code change types are 3, 4,5.","The behavior of the API in terms of what it returns has not changed; it still returns the same boolean value based on the condition checked. The change to the code structure is for internal resource management and does not have an impact on the behavior observed by the external callers of the API. Therefore, there appears to be no compatibility issue in terms of different return values or exception handlings; the CI type is 0."
745,<android.widget.TextView: boolean selectAllText()>,23,24,<android.widget.TextView: boolean selectAllText()>,<android.widget.TextView: boolean selectAllText()>,0,"{
    // selection.
    if (mEditor != null) {
        mEditor.hideInsertionPointCursorController();
    }
    final int length = mText.length();
    Selection.setSelection((Spannable) mText, 0, length);
    return length > 0;
}","{
    final int length = mText.length();
    Selection.setSelection((Spannable) mText, 0, length);
    return length > 0;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The if statement checking for mEditor's nullability and calling hideInsertionPointCursorController() has been removed. So, there's a control dependency change (code change type 3) and other statements change, specifically the removal of method call inside if statement (code change type 4).","There is no change in the return statement or in exception handling, so there should be no Compatibility Issue; thus, CI type is 0. The behavior of selectAllText() regarding its return value is still based on the length of mText, which remains unchanged between the versions."
746,<android.service.notification.ZenModeConfig.ScheduleInfo: ScheduleInfo copy()>,23,24,<android.service.notification.ZenModeConfig.ScheduleInfo: ScheduleInfo copy()>,<android.service.notification.ZenModeConfig.ScheduleInfo: ScheduleInfo copy()>,0,"{
    final ScheduleInfo rt = new ScheduleInfo();
    if (days != null) {
        rt.days = new int[days.length];
        System.arraycopy(days, 0, rt.days, 0, days.length);
    }
    rt.startHour = startHour;
    rt.startMinute = startMinute;
    rt.endHour = endHour;
    rt.endMinute = endMinute;
    return rt;
}","{
    final ScheduleInfo rt = new ScheduleInfo();
    if (days != null) {
        rt.days = new int[days.length];
        System.arraycopy(days, 0, rt.days, 0, days.length);
    }
    rt.startHour = startHour;
    rt.startMinute = startMinute;
    rt.endHour = endHour;
    rt.endMinute = endMinute;
    rt.exitAtAlarm = exitAtAlarm;
    rt.nextAlarm = nextAlarm;
    return rt;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"Two new statements have been added to the method that set values for fields `exitAtAlarm` and `nextAlarm`, so the code change type is 4.","The additional fields `exitAtAlarm` and `nextAlarm` being set means that the object returned from the method in the late version has additional state being carried with it. Therefore, since the method potentially returns objects with different values in the late version, the CI type is 1."
747,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",23,24,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call of `intent.prepareToLeaveProcess()` has been changed to `intent.prepareToLeaveProcess(context)` in the late version, showing that the `prepareToLeaveProcess` method has been overloaded or its signature has changed to require a `Context` parameter. This is a type of dependent API change (5) and also qualifies as an other statement change (4) as the call to method is altered but it doesn't directly affect return, exception handling, or control flow statements.","There are no new return statements or exception handling changes that would lead to a different value being returned, or a different exception being thrown. Therefore, no compatibility issue should arise from this change, as the API's behavior is intended to remain consistent with the prior version. The change in the method `prepareToLeaveProcess` is internal to the implementation and is not expected to alter the contract of the `getActivity` method. Hence, the CI type is 0."
748,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLength(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLength(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLength(ComponentName)>,0,"{
    return getPasswordMinimumLength(admin, UserHandle.myUserId());
}","{
    return getPasswordMinimumLength(admin, myUserId());
}",1,"/**
 * Retrieve the current minimum password length for all admins of this
 * user and its profiles or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
","/**
 * Retrieve the current minimum password length for a particular admin or all admins that set
 * retrictions on this user and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * user and its profiles or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation calls a different version of the 'getPasswordMinimumLength' method by replacing 'UserHandle.myUserId()' with 'myUserId()'. This is a dependent API change, so the change type is 5.","Despite the change in the dependent method being called, if the behavior of 'myUserId()' is equivalent to that of 'UserHandle.myUserId()' regarding the returned user ID, there would not be a CI as the returned value of 'getPasswordMinimumLength' would remain consistent. Thus it's classified as no compatibility issue, 0."
749,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",23,24,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The code change includes a change in the method call `intent.prepareToLeaveProcess(this)` which has an additional parameter compared to the early version `intent.prepareToLeaveProcess()`, and also the exception handling statement changed from throwing a new RuntimeException to using `throw e.rethrowFromSystemServer()`. These changes count as a change to a dependent API (the method `prepareToLeaveProcess` being called is different) and an exception handling statement changed. ","The change in the method call can potentially affect the behavior of the API by preparing the `intent` differently for processing which may lead to a different value being returned or different handling when preparing to leave the process. Additionally, the change in exception handling means the late version may throw a different exception (or the same exception but with a potentially altered stack trace) as compared to the early version. Thus, there is a CI due to the potential for different return values being caused by the change in dependent API call, and a difference in exception handling as well."
751,<android.bluetooth.BluetoothAdapter: boolean isMultipleAdvertisementSupported()>,23,24,<android.bluetooth.BluetoothAdapter: boolean isMultipleAdvertisementSupported()>,<android.bluetooth.BluetoothAdapter: boolean isMultipleAdvertisementSupported()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isMultiAdvertisementSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isMultipleAdvertisementSupported, error: "", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isMultiAdvertisementSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isMultipleAdvertisementSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if the multi advertisement is supported by the chipset
 *
 * @return true if Multiple Advertisement feature is supported
 */
","/**
 * Return true if the multi advertisement is supported by the chipset
 *
 * @return true if Multiple Advertisement feature is supported
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version has added a lock mechanism around the call to mService.isMultiAdvertisementSupported() and has also introduced a check if mService is not null. These are Other statement changes and Control dependency changes. The code change type is therefore 3,4.","There is no Compatibility Issue because the behavior of the API has not fundamentally changed with respect to its output. The locking mechanism and null check are used to make the function more safe in a concurrent environment, but these do not change the return value or exception handling, and the API's purpose remains consistent across both versions."
752,<android.widget.AbsListView.PerformClick: void run()>,23,24,<android.widget.AbsListView.PerformClick: void run()>,<android.widget.AbsListView.PerformClick: void run()>,0,"{
    // bail out before bad things happen
    if (mDataChanged)
        return;
    final ListAdapter adapter = mAdapter;
    final int motionPosition = mClickMotionPosition;
    if (adapter != null && mItemCount > 0 && motionPosition != INVALID_POSITION && motionPosition < adapter.getCount() && sameWindow()) {
        final View view = getChildAt(motionPosition - mFirstPosition);
        // screen, etc.) and we should cancel the click
        if (view != null) {
            performItemClick(view, motionPosition, adapter.getItemId(motionPosition));
        }
    }
}","{
    // bail out before bad things happen
    if (mDataChanged)
        return;
    final ListAdapter adapter = mAdapter;
    final int motionPosition = mClickMotionPosition;
    if (adapter != null && mItemCount > 0 && motionPosition != INVALID_POSITION && motionPosition < adapter.getCount() && sameWindow() && adapter.isEnabled(motionPosition)) {
        final View view = getChildAt(motionPosition - mFirstPosition);
        // screen, etc.) and we should cancel the click
        if (view != null) {
            performItemClick(view, motionPosition, adapter.getItemId(motionPosition));
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control flow has been altered by adding an additional condition `adapter.isEnabled(motionPosition)` in the if statement, which is a control dependency change, thus the code change type is 3.","The added condition ensures that the item is enabled before an item click is performed. However, there will not be a compatibility issue arising from this change, since it introduces a safeguard against acting on disabled items, which would not have been actionable before. The behavior is refined but does not introduce a divergent outcome from the perspective of code execution as disabled items would not respond to clicks even if `performItemClick` was called on them."
753,"<android.accounts.AccountManager: String peekAuthToken(Account,String)>",23,24,"<android.accounts.AccountManager: String peekAuthToken(Account,String)>","<android.accounts.AccountManager: String peekAuthToken(Account,String)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    try {
        return mService.peekAuthToken(account, authTokenType);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    try {
        return mService.peekAuthToken(account, authTokenType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets an auth token from the AccountManager's cache.  If no auth
 * token is cached for this account, null will be returned -- a new
 * auth token will not be generated, and the server will not be contacted.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account for which an auth token is to be fetched. Cannot be {@code null}.
 * @param authTokenType The type of auth token to fetch. Cannot be {@code null}.
 * @return The cached auth token for this account and type, or null if
 * no auth token is cached or the account does not exist.
 * @see #getAuthToken
 */
","/**
 * Gets an auth token from the AccountManager's cache.  If no auth
 * token is cached for this account, null will be returned -- a new
 * auth token will not be generated, and the server will not be contacted.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account for which an auth token is to be fetched. Cannot be {@code null}.
 * @param authTokenType The type of auth token to fetch. Cannot be {@code null}.
 * @return The cached auth token for this account and type, or null if
 * no auth token is cached or the account does not exist.
 * @see #getAuthToken
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The only code change is the exception handling statement within the catch block, which changes from `throw new RuntimeException(e);` to `throw e.rethrowFromSystemServer();`, so the change type is 2.","This change specializes the type of exception being thrown from a generic `RuntimeException` to what is likely a more specific system server exception with `rethrowFromSystemServer()`. Consequently, the behavior of the method has changed in regards to exception handling, which constitutes a potential compatibility issue. The CI type is 2."
754,<android.app.ActivityManager.TaskDescription: Bitmap getIcon()>,23,24,<android.app.ActivityManager.TaskDescription: Bitmap getIcon()>,<android.app.ActivityManager.TaskDescription: Bitmap getIcon()>,0,"{
    if (mIcon != null) {
        return mIcon;
    }
    return loadTaskDescriptionIcon(mIconFilename);
}","{
    if (mIcon != null) {
        return mIcon;
    }
    return loadTaskDescriptionIcon(mIconFilename, UserHandle.myUserId());
}",1,"/**
 * @return The icon that represents the current state of this task.
 */
","/**
 * @return The icon that represents the current state of this task.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method loadTaskDescriptionIcon has an added parameter in the late version, thus the change type is 1,5.","The method loadTaskDescriptionIcon with the added UserHandle.myUserId() parameter could potentially return a different Bitmap object since it might have different behavior based on the user ID, leading to CI of type 1."
755,"<android.transition.Fade: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>",23,24,"<android.transition.Fade: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>","<android.transition.Fade: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>",0,"{
    if (DBG) {
        View startView = (startValues != null) ? startValues.view : null;
        Log.d(LOG_TAG, ""Fade.onAppear: startView, startVis, endView, endVis = "" + startView + "", "" + view);
    }
    return createAnimation(view, 0, 1);
}","{
    if (DBG) {
        View startView = (startValues != null) ? startValues.view : null;
        Log.d(LOG_TAG, ""Fade.onAppear: startView, startVis, endView, endVis = "" + startView + "", "" + view);
    }
    float startAlpha = getStartAlpha(startValues, 0);
    if (startAlpha == 1) {
        startAlpha = 0;
    }
    return createAnimation(view, startAlpha, 1);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The change includes the addition of variables `startAlpha` and its initialization with `getStartAlpha(startValues, 0)`, as well as an 'if' statement to modify its value. This leads to a control dependency change and an other statement change, hence the change types are 3,4.","Since the start alpha value can now be different based on the condition checked by the new 'if' statement, which affects the first parameter of the `createAnimation` method, the behaviour of the API when returning the `Animator` object is potentially altered. Particularly, instead of always starting with an alpha of 0, it might start with a different alpha value. This constitutes a potential different return value, so the CI type is 1."
757,"<android.app.Notification.Builder: Builder setSound(Uri,AudioAttributes)>",23,24,"<android.app.Notification.Builder: Builder setSound(Uri,AudioAttributes)>","<android.app.Notification.Builder: Builder setSound(Uri,AudioAttributes)>",0,"{
    mSound = sound;
    mAudioAttributes = audioAttributes;
    return this;
}","{
    mN.sound = sound;
    mN.audioAttributes = audioAttributes;
    return this;
}",1,"/**
 * Set the sound to play, along with specific {@link AudioAttributes audio attributes} to
 * use during playback.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 *
 * @see Notification#sound
 */
","/**
 * Set the sound to play, along with specific {@link AudioAttributes audio attributes} to
 * use during playback.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 *
 * @see Notification#sound
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the assignment of the sound and audio attributes to different members (mSound and mAudioAttributes in the early version to mN.sound and mN.audioAttributes in the late version), so the code change type is 4.","No Compatibility Issue is exposed by this change, because the method still accomplishes the same functionality by just assigning the values to different member variables of the notification object. The method signature remains the same, and the behavior expected by the client code should not change (assuming that the fields mN.sound and mN.audioAttributes are functionally equivalent to mSound and mAudioAttributes respectively), thus there is no CI."
758,<android.net.ConnectivityManager: void addDefaultNetworkActiveListener(OnNetworkActiveListener)>,23,24,<android.net.ConnectivityManager: void addDefaultNetworkActiveListener(OnNetworkActiveListener)>,<android.net.ConnectivityManager: void addDefaultNetworkActiveListener(OnNetworkActiveListener)>,0,"{
    INetworkActivityListener rl = new INetworkActivityListener.Stub() {

        @Override
        public void onNetworkActive() throws RemoteException {
            l.onNetworkActive();
        }
    };
    try {
        getNetworkManagementService().registerNetworkActivityListener(rl);
        mNetworkActivityListeners.put(l, rl);
    } catch (RemoteException e) {
    }
}","{
    INetworkActivityListener rl = new INetworkActivityListener.Stub() {

        @Override
        public void onNetworkActive() throws RemoteException {
            l.onNetworkActive();
        }
    };
    try {
        getNetworkManagementService().registerNetworkActivityListener(rl);
        mNetworkActivityListeners.put(l, rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Start listening to reports when the system's default data network is active, meaning it is
 * a good time to perform network traffic.  Use {@link #isDefaultNetworkActive()}
 * to determine the current state of the system's default network after registering the
 * listener.
 * <p>
 * If the process default network has been set with
 * {@link ConnectivityManager#bindProcessToNetwork} this function will not
 * reflect the process's default, but the system default.
 *
 * @param l The listener to be told when the network is active.
 */
","/**
 * Start listening to reports when the system's default data network is active, meaning it is
 * a good time to perform network traffic.  Use {@link #isDefaultNetworkActive()}
 * to determine the current state of the system's default network after registering the
 * listener.
 * <p>
 * If the process default network has been set with
 * {@link ConnectivityManager#bindProcessToNetwork} this function will not
 * reflect the process's default, but the system default.
 *
 * @param l The listener to be told when the network is active.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The difference between the early and late versions is in the exception handling block. In the late version, an exception is thrown using `throw e.rethrowFromSystemServer();` while in the early version there is an empty catch block. This change implies that an exception handling statement has been added, so the code change type is 2.","The addition of `throw e.rethrowFromSystemServer();` can cause a different behavior because instead of silently catching the `RemoteException`, the late version will now throw an exception under certain conditions. Therefore, a change in exception handling will lead to a Compatibility Issue, and the CI type is 2."
759,<android.app.usage.NetworkStats: void startHistoryEnumeration(int)>,23,24,<android.app.usage.NetworkStats: void startHistoryEnumeration(int)>,<android.app.usage.NetworkStats: void startHistoryEnumeration(int)>,0,"{
    mHistory = null;
    try {
        mHistory = mSession.getHistoryIntervalForUid(mTemplate, uid, android.net.NetworkStats.SET_ALL, android.net.NetworkStats.TAG_NONE, NetworkStatsHistory.FIELD_ALL, mStartTimeStamp, mEndTimeStamp);
        setSingleUid(uid);
    } catch (RemoteException e) {
        Log.w(TAG, e);
    // Leaving mHistory null
    }
    mEnumerationIndex = 0;
}","{
    startHistoryEnumeration(uid, android.net.NetworkStats.TAG_NONE);
}",1,"/**
 * Collects history results for uid and resets history enumeration index.
 */
","/**
 * Collects history results for uid and resets history enumeration index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method `startHistoryEnumeration(int)` has been replaced with another existing method `startHistoryEnumeration(int, int)`. This indicates that the implementation of the method is utilizing an overloaded version of `startHistoryEnumeration` which is a Dependent API change, hence the code change type is 5.",There is no Compatibility Issue since the implementation has been refactored to use a different version of `startHistoryEnumeration` with the same or more specific functionality. The client's use of `startHistoryEnumeration(int)` would not be affected by this change in terms of behavior. The internal implementation change should not have an impact on the method's external behavior as observed by the API users.
760,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>",23,24,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>","<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>",0,"{
    try {
        // Remove all the children of this layout first
        removeAllViews();
        addView(view.apply(getContext(), this, handler));
    } catch (Exception e) {
        Log.e(TAG, ""Failed to apply RemoteViews."");
    }
}","{
    setOnClickHandler(handler);
    applyRemoteViews(view);
}",1,"/**
 * Updates this RemoteViewsFrameLayout depending on the view that was loaded.
 * @param view the RemoteViews that was loaded. If null, the RemoteViews was not loaded
 * successfully.
 */
","/**
 * Updates this RemoteViewsFrameLayout depending on the view that was loaded.
 * @param view the RemoteViews that was loaded. If null, the RemoteViews was not loaded
 * successfully.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The early version calls removeAllViews() and then applies the RemoteViews directly inside the onRemoteViewsLoaded method, whereas the late version sets the OnClickHandler and then calls an external method applyRemoteViews. This is classified as an other statement change.","There is no direct indication of a compatibility issue. Although the method's internal implementation has changed, there is no change to the method signature, return type, exception throwing/handling, or control flow that affects the external behavior. Assuming that setOnClickHandler and applyRemoteViews maintain the same end effect as the original code, the changes should not result in a Compatibility Issue."
761,<android.app.Notification.Builder: Builder setVibrate(long[])>,23,24,<android.app.Notification.Builder: Builder setVibrate(long[])>,<android.app.Notification.Builder: Builder setVibrate(long[])>,0,"{
    mVibrate = pattern;
    return this;
}","{
    mN.vibrate = pattern;
    return this;
}",1,"/**
 * Set the vibration pattern to use.
 *
 * See {@link android.os.Vibrator#vibrate(long[], int)} for a discussion of the
 * <code>pattern</code> parameter.
 *
 * <p>
 * A notification that vibrates is more likely to be presented as a heads-up notification.
 * </p>
 *
 * @see Notification#vibrate
 */
","/**
 * Set the vibration pattern to use.
 *
 * See {@link android.os.Vibrator#vibrate(long[], int)} for a discussion of the
 * <code>pattern</code> parameter.
 *
 * <p>
 * A notification that vibrates is more likely to be presented as a heads-up notification.
 * </p>
 *
 * @see Notification#vibrate
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment statement changed from directly accessing mVibrate to mN.vibrate. This is an internal change and does not affect the method's signature or behavior from an API consumer's perspective; thus, the change type is 4.","There is no Compatibility Issue here because the change does not alter the method's contract or external behavior. The method still accepts a long array for the vibration pattern and returns a Builder object, so the change is internal and does not affect the callers of the API."
762,<android.widget.TimePicker: void setIs24HourView(Boolean)>,23,24,<android.widget.TimePicker: void setIs24HourView(Boolean)>,<android.widget.TimePicker: void setIs24HourView(Boolean)>,0,"{
    if (is24HourView == null) {
        return;
    }
    mDelegate.setIs24HourView(is24HourView);
}","{
    if (is24HourView == null) {
        return;
    }
    mDelegate.setIs24Hour(is24HourView);
}",1,"/**
 * Sets whether this widget displays time in 24-hour mode or 12-hour mode
 * with an AM/PM picker.
 *
 * @param is24HourView {@code true} to display in 24-hour mode,
 * {@code false} for 12-hour mode with AM/PM
 * @see #is24HourView()
 */
","/**
 * Sets whether this widget displays time in 24-hour mode or 12-hour mode
 * with an AM/PM picker.
 *
 * @param is24HourView {@code true} to display in 24-hour mode,
 * {@code false} for 12-hour mode with AM/PM
 * @see #is24HourView()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API that is being called within the method changed from mDelegate.setIs24HourView(is24HourView) to mDelegate.setIs24Hour(is24HourView). This is a change in the dependent API, so the code change type is 5.","There is no Compatibility Issue introduced because the method signature or behavior from the consumer's perspective hasn't changed. The method still takes a single Boolean argument and doesn't produce a different return value or throw a new exception due to the internal change. The delegate method invoked has been renamed, but as long as it behaves the same from the outside, consumers of the TimePicker.setIs24HourView method would not experience any differences. Therefore, there is no CI."
764,"<android.app.admin.DevicePolicyManager: int getPermissionGrantState(ComponentName,String,String)>",23,24,"<android.app.admin.DevicePolicyManager: int getPermissionGrantState(ComponentName,String,String)>","<android.app.admin.DevicePolicyManager: int getPermissionGrantState(ComponentName,String,String)>",0,"{
    try {
        return mService.getPermissionGrantState(admin, packageName, permission);
    } catch (RemoteException re) {
        Log.w(TAG, ""Failed talking with device policy service"", re);
        return PERMISSION_GRANT_STATE_DEFAULT;
    }
}","{
    throwIfParentInstance(""getPermissionGrantState"");
    try {
        return mService.getPermissionGrantState(admin, packageName, permission);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the current grant state of a runtime permission for a specific application.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param packageName The application to check the grant state for.
 * @param permission The permission to check for.
 * @return the current grant state specified by device policy. If the profile or device owner
 * has not set a grant state, the return value is {@link #PERMISSION_GRANT_STATE_DEFAULT}.
 * This does not indicate whether or not the permission is currently granted for the package.
 *
 * <p/>If a grant state was set by the profile or device owner, then the return value will
 * be one of {@link #PERMISSION_GRANT_STATE_DENIED} or {@link #PERMISSION_GRANT_STATE_GRANTED},
 * which indicates if the permission is currently denied or granted.
 *
 * @see #setPermissionGrantState(ComponentName, String, String, int)
 * @see PackageManager#checkPermission(String, String)
 */
","/**
 * Returns the current grant state of a runtime permission for a specific application.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param packageName The application to check the grant state for.
 * @param permission The permission to check for.
 * @return the current grant state specified by device policy. If the profile or device owner
 * has not set a grant state, the return value is
 * {@link #PERMISSION_GRANT_STATE_DEFAULT}. This does not indicate whether or not the
 * permission is currently granted for the package.
 * <p/>
 * If a grant state was set by the profile or device owner, then the return value will
 * be one of {@link #PERMISSION_GRANT_STATE_DENIED} or
 * {@link #PERMISSION_GRANT_STATE_GRANTED}, which indicates if the permission is
 * currently denied or granted.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setPermissionGrantState(ComponentName, String, String, int)
 * @see PackageManager#checkPermission(String, String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5","1,2","The addition of throwIfParentInstance(""getPermissionGrantState"") adds a new control flow that can throw a new RuntimeException before the actual work is done, which is a change in exception handling (2). The new throw statement inside the catch block has changed from logging an exception to rethrowing it (which qualifies as another exception handling statement change). Additionally, there is a new method invocation (throwIfParentInstance) that is not present in the early version, which qualifies as a change in the dependent API (5). The method also has an ""Other statement"" change due to the introduction of the throwIfParentInstance method call (4).","The introduction of the throwIfParentInstance method can raise a new RuntimeException, causing a change in exception handling (CI type 2). Changes in exception handling within the catch block could lead to different behavior in terms of the exceptions thrown by the API (CI type 2). Lastly, the deleted return statement at the end of the catch block that previously returned PERMISSION_GRANT_STATE_DEFAULT removes a potential fall-back return value, which can also cause the API to return different values or no value at all if an exception is thrown (CI type 1)."
769,<android.print.PrintDocumentInfo: String toString()>,23,24,<android.print.PrintDocumentInfo: String toString()>,<android.print.PrintDocumentInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrintDocumentInfo{"");
    builder.append(""name="").append(mName);
    builder.append("", pageCount="").append(mPageCount);
    builder.append("", contentType="").append(contentTyepToString(mContentType));
    builder.append("", dataSize="").append(mDataSize);
    builder.append(""}"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrintDocumentInfo{"");
    builder.append(""name="").append(mName);
    builder.append("", pageCount="").append(mPageCount);
    builder.append("", contentType="").append(contentTypeToString(mContentType));
    builder.append("", dataSize="").append(mDataSize);
    builder.append(""}"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is a correction of a typo in a method name within a string that is being built, from `contentTyepToString` to `contentTypeToString`. This change does not affect the logic of the program or its control flow; it is a simple method name correction within a string operation and does not alter the API's behavior. Therefore, the code change type is 4 (Other statement changed).","There is no Compatibility Issue, as the change does not affect any return values, types or exception handling. The return value of `toString()` will remain a `String` containing the same information. Thus, the method signature, return type, and contract remain unchanged. The output after the typo correction will more accurately reflect the intended method name in the string representation but will not change how the method behaves when it's used by existing clients."
770,<android.hardware.radio.RadioManager.FmBandConfig: String toString()>,23,24,<android.hardware.radio.RadioManager.FmBandConfig: String toString()>,<android.hardware.radio.RadioManager.FmBandConfig: String toString()>,0,"{
    return ""FmBandConfig ["" + super.toString() + "", mStereo="" + mStereo + "", mRds="" + mRds + "", mTa="" + mTa + "", mAf="" + mAf + ""]"";
}","{
    return ""FmBandConfig ["" + super.toString() + "", mStereo="" + mStereo + "", mRds="" + mRds + "", mTa="" + mTa + "", mAf="" + mAf + "", mEa ="" + mEa + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"There is an addition of "", mEa ="" + mEa to the return statement, which means there is a new part of the string being returned, so the code change type is 1.","The return value of the method has changed because it now includes the mEa field in its output. This results in a different return value, so this constitutes a Compatibility Issue of type 1."
772,<android.widget.ImageView: void onDraw(Canvas)>,23,24,<android.widget.ImageView: void onDraw(Canvas)>,<android.widget.ImageView: void onDraw(Canvas)>,0,"{
    super.onDraw(canvas);
    if (mDrawable == null) {
        // couldn't resolve the URI
        return;
    }
    if (mDrawableWidth == 0 || mDrawableHeight == 0) {
        // nothing to draw (empty bounds)
        return;
    }
    if (mDrawMatrix == null && mPaddingTop == 0 && mPaddingLeft == 0) {
        mDrawable.draw(canvas);
    } else {
        int saveCount = canvas.getSaveCount();
        canvas.save();
        if (mCropToPadding) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            canvas.clipRect(scrollX + mPaddingLeft, scrollY + mPaddingTop, scrollX + mRight - mLeft - mPaddingRight, scrollY + mBottom - mTop - mPaddingBottom);
        }
        canvas.translate(mPaddingLeft, mPaddingTop);
        if (mDrawMatrix != null) {
            canvas.concat(mDrawMatrix);
        }
        mDrawable.draw(canvas);
        canvas.restoreToCount(saveCount);
    }
}","{
    super.onDraw(canvas);
    if (mDrawable == null) {
        // couldn't resolve the URI
        return;
    }
    if (mDrawableWidth == 0 || mDrawableHeight == 0) {
        // nothing to draw (empty bounds)
        return;
    }
    if (mDrawMatrix == null && mPaddingTop == 0 && mPaddingLeft == 0) {
        mDrawable.draw(canvas);
    } else {
        final int saveCount = canvas.getSaveCount();
        canvas.save();
        if (mCropToPadding) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            canvas.clipRect(scrollX + mPaddingLeft, scrollY + mPaddingTop, scrollX + mRight - mLeft - mPaddingRight, scrollY + mBottom - mTop - mPaddingBottom);
        }
        canvas.translate(mPaddingLeft, mPaddingTop);
        if (mDrawMatrix != null) {
            canvas.concat(mDrawMatrix);
        }
        mDrawable.draw(canvas);
        canvas.restoreToCount(saveCount);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no significant change in the implementation between the early version and the late version of the method. The only change is the declaration of the variable 'saveCount' from 'int' to 'final int', which does not affect the use of the variable since it is assigned only once and does not change afterwards.","There is no Compatibility Issue since there are no changes in the implementation that could result in different return values, thrown exceptions, or any other behavioral changes in the method when called."
774,<android.app.DownloadManager: Cursor query(Query)>,23,24,<android.app.DownloadManager: Cursor query(Query)>,<android.app.DownloadManager: Cursor query(Query)>,0,"{
    Cursor underlyingCursor = query.runQuery(mResolver, UNDERLYING_COLUMNS, mBaseUri);
    if (underlyingCursor == null) {
        return null;
    }
    return new CursorTranslator(underlyingCursor, mBaseUri);
}","{
    Cursor underlyingCursor = query.runQuery(mResolver, UNDERLYING_COLUMNS, mBaseUri);
    if (underlyingCursor == null) {
        return null;
    }
    return new CursorTranslator(underlyingCursor, mBaseUri, mAccessFilename);
}",1,"/**
 * Query the download manager about downloads that have been requested.
 * @param query parameters specifying filters for this query
 * @return a Cursor over the result set of downloads, with columns consisting of all the
 * COLUMN_* constants.
 */
","/**
 * Query the download manager about downloads that have been requested.
 * @param query parameters specifying filters for this query
 * @return a Cursor over the result set of downloads, with columns consisting of all the
 * COLUMN_* constants.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The constructor for CursorTranslator has an additional parameter in the late version (mAccessFilename), but the signature of the method remains the same, so the change is classified under other statement changed.","While there is a change in how the CursorTranslator is instantiated with an additional parameter, this does not constitute a behavioral change from the perspective of the API consumer. The method signature is the same, and it still returns a Cursor object. Therefore, there is no compatibility issue."
775,<android.app.admin.DevicePolicyManager: void clearDeviceOwnerApp(String)>,23,24,<android.app.admin.DevicePolicyManager: void clearDeviceOwnerApp(String)>,<android.app.admin.DevicePolicyManager: void clearDeviceOwnerApp(String)>,0,"{
    if (mService != null) {
        try {
            mService.clearDeviceOwner(packageName);
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed to clear device owner"");
        }
    }
}","{
    throwIfParentInstance(""clearDeviceOwnerApp"");
    if (mService != null) {
        try {
            mService.clearDeviceOwner(packageName);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Clears the current device owner.  The caller must be the device owner.
 *
 * This function should be used cautiously as once it is called it cannot
 * be undone.  The device owner can only be set as a part of device setup
 * before setup completes.
 *
 * @param packageName The package name of the device owner.
 */
","/**
 * Clears the current device owner. The caller must be the device owner. This function should be
 * used cautiously as once it is called it cannot be undone. The device owner can only be set as
 * a part of device setup before setup completes.
 *
 * @param packageName The package name of the device owner.
 * @throws SecurityException if the caller is not in {@code packageName} or {@code packageName}
 * does not own the current device owner component.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The late version introduces a new method call (throwIfParentInstance(""clearDeviceOwnerApp"")) and changes the exception handling by throwing the exception instead of just logging it as in the early version, so the change type is 2,3,4.","This change introduces a new potential behavior where the method now throws a checked exception (rethrowFromSystemServer) instead of catching the RemoteException and just logging, leading to a Compatibility Issue caused by potential different exception handling. Therefore, the CI type is 2."
776,"<android.util.Log: int wtf(int,String,String,Throwable,boolean,boolean)>",23,24,"<android.util.Log: int wtf(int,String,String,Throwable,boolean,boolean)>","<android.util.Log: int wtf(int,String,String,Throwable,boolean,boolean)>",0,"{
    TerribleFailure what = new TerribleFailure(msg, tr);
    // Only mark this as ERROR, do not use ASSERT since that should be
    // reserved for cases where the system is guaranteed to abort.
    // The onTerribleFailure call does not always cause a crash.
    int bytes = println_native(logId, ERROR, tag, msg + '\n' + getStackTraceString(localStack ? what : tr));
    sWtfHandler.onTerribleFailure(tag, what, system);
    return bytes;
}","{
    TerribleFailure what = new TerribleFailure(msg, tr);
    // Only mark this as ERROR, do not use ASSERT since that should be
    // reserved for cases where the system is guaranteed to abort.
    // The onTerribleFailure call does not always cause a crash.
    int bytes = printlns(logId, ERROR, tag, msg, localStack ? what : tr);
    sWtfHandler.onTerribleFailure(tag, what, system);
    return bytes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called within the return statement changed from println_native to printlns. There is a dependent API change, but without more information about the println_native and printlns methods, we cannot determine if the return value has changed. Hence, the code change type is 4,5 assuming printlns is a different dependent API, or an updated version of println_native.","There is likely no Compatibility Issue because the change does not inherently suggest a difference in behavior that would affect the return values or exceptions thrown by the method, especially if printlns is assumed to be a direct replacement for println_native with the same expected behavior. Therefore, the CI type is 0."
777,<android.app.Fragment: void setRetainInstance(boolean)>,23,24,<android.app.Fragment: void setRetainInstance(boolean)>,<android.app.Fragment: void setRetainInstance(boolean)>,0,"{
    if (retain && mParentFragment != null) {
        throw new IllegalStateException(""Can't retain fragements that are nested in other fragments"");
    }
    mRetainInstance = retain;
}","{
    mRetainInstance = retain;
}",1,"/**
 * Control whether a fragment instance is retained across Activity
 * re-creation (such as from a configuration change).  This can only
 * be used with fragments not in the back stack.  If set, the fragment
 * lifecycle will be slightly different when an activity is recreated:
 * <ul>
 * <li> {@link #onDestroy()} will not be called (but {@link #onDetach()} still
 * will be, because the fragment is being detached from its current activity).
 * <li> {@link #onCreate(Bundle)} will not be called since the fragment
 * is not being re-created.
 * <li> {@link #onAttach(Activity)} and {@link #onActivityCreated(Bundle)} <b>will</b>
 * still be called.
 * </ul>
 */
","/**
 * Control whether a fragment instance is retained across Activity
 * re-creation (such as from a configuration change).  This can only
 * be used with fragments not in the back stack.  If set, the fragment
 * lifecycle will be slightly different when an activity is recreated:
 * <ul>
 * <li> {@link #onDestroy()} will not be called (but {@link #onDetach()} still
 * will be, because the fragment is being detached from its current activity).
 * <li> {@link #onCreate(Bundle)} will not be called since the fragment
 * is not being re-created.
 * <li> {@link #onAttach(Activity)} and {@link #onActivityCreated(Bundle)} <b>will</b>
 * still be called.
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The early version has an if statement that throws an exception, but this exception handling is deleted in the late version. Also, other statement outside the try-catch block is removed, so the code change type is 2,4.","The removal of the exception throwing means that under certain conditions (specifically when retain is true and mParentFragment is not null), the early version will throw an exception while the late version will not. This difference leads to a change in the exception handling behavior of the API, so the CI type is 2."
779,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,23,24,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return 0;
    }
    try {
        return sGlobals.mService.getWidthHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getWidthHint();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the desired minimum width for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum width.
 *
 * If the returned value is <= 0, the caller should use the width of
 * the default display instead.
 *
 * @return The desired minimum width for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
","/**
 * Returns the desired minimum width for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum width.
 *
 * If the returned value is <= 0, the caller should use the width of
 * the default display instead.
 *
 * @return The desired minimum width for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The early version returns 0 when sGlobals.mService is null, whereas the late version throws a RuntimeException. In the catch block, the early version returns 0 upon RemoteException, but the late version rethrows the exception. Hence, there is a change in exception handling statements.","Because of the changes in exception handling, there is a potential compatibility issue caused by different exception handlings. When encountering similar scenarios, the late version will throw exceptions instead of returning a default value."
780,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,23,24,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,0,"{
    return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component);
}","{
    return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() implementation has new fields added to the Objects.hash method, specifically 'id' and 'creationTime', so the change type is 1 (Other statement changed).","The additional fields 'id' and 'creationTime' to the Objects.hash method would change the computed hash code of the object, potentially causing different return values, so the CI type is 1 (Return statement changed)."
782,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",23,24,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>","<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",0,"{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
    // Get the primary color and update the TaskDescription for this activity
    if (theme != null) {
        TypedArray a = theme.obtainStyledAttributes(com.android.internal.R.styleable.Theme);
        int colorPrimary = a.getColor(com.android.internal.R.styleable.Theme_colorPrimary, 0);
        a.recycle();
        if (colorPrimary != 0) {
            ActivityManager.TaskDescription v = new ActivityManager.TaskDescription(null, null, colorPrimary);
            setTaskDescription(v);
        }
    }
}","{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
    // Get the primary color and update the TaskDescription for this activity
    TypedArray a = theme.obtainStyledAttributes(com.android.internal.R.styleable.ActivityTaskDescription);
    if (mTaskDescription.getPrimaryColor() == 0) {
        int colorPrimary = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorPrimary, 0);
        if (colorPrimary != 0 && Color.alpha(colorPrimary) == 0xFF) {
            mTaskDescription.setPrimaryColor(colorPrimary);
        }
    }
    // For dev-preview only.
    if (mTaskDescription.getBackgroundColor() == 0) {
        int colorBackground = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorBackground, 0);
        if (colorBackground != 0 && Color.alpha(colorBackground) == 0xFF) {
            mTaskDescription.setBackgroundColor(colorBackground);
        }
    }
    a.recycle();
    setTaskDescription(mTaskDescription);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late implementation, the method now uses a different set of styled attributes (com.android.internal.R.styleable.ActivityTaskDescription instead of com.android.internal.R.styleable.Theme). Additionally, changes in control structures related to how the primary color is set to the task description and the introduction of setting a background color represent a significant alteration in the logic and procedure of this method. Therefore, the change types are 1, 3, and 4.","These changes could cause the API to potentially return different types of TaskDescription configurations with primary and background colors, which were not present in the early version. This will lead to different behavior in UI elements which is why the CI type is 1."
783,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLetters(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLetters(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of letters required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the minimum number of
 * letters required in the password. After setting this, the user will not be able to enter a
 * new password that is not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does not take place
 * immediately. To prompt the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after setting this value. This constraint is
 * only imposed if the administrator has also requested {@link #PASSWORD_QUALITY_COMPLEX} with
 * {@link #setPasswordQuality}. The default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of letters required in the password. A value of
 * 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The dependent API setPasswordMinimumLetters being called within the try block has an additional parameter in the late version, and a new exception handling strategy 'throw e.rethrowFromSystemServer();' is introduced instead of just logging the exception. Therefore, the compatible change types are 2,5.","Due to the addition of 'throw e.rethrowFromSystemServer();' in the exception handling block, the late version of the API could throw an exception where the early version would not, representing a change in exception handling behavior between the versions. Consequently, the CI type is 2."
784,<android.content.res.Resources: String[] getStringArray(int)>,23,24,<android.content.res.Resources: String[] getStringArray(int)>,<android.content.res.Resources: String[] getStringArray(int)>,0,"{
    String[] res = mAssets.getResourceStringArray(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""String array resource ID #0x"" + Integer.toHexString(id));
}","{
    String[] res = mResourcesImpl.getAssets().getResourceStringArray(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""String array resource ID #0x"" + Integer.toHexString(id));
}",1,"/**
 * Return the string array associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return The string array associated with the resource.
 */
","/**
 * Return the string array associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return The string array associated with the resource.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent method call within the API uses a different chain of methods (mResourcesImpl.getAssets() vs mAssets), indicating a change in the method call hierarchy, hence the code change type is 4 and also 5 since it involved a change in dependent API.","Despite the change in method call hierarchy, the behavior of the API itself in terms of returning a value or throwing an exception has not altered. Therefore, there is no Compatibility Issue, which means the CI type is 0."
785,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setCameraDisabled"");
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to disable all cameras
 * on the device, for this user. After setting this, no applications running as this user
 * will be able to access any cameras on the device.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 */
","/**
 * Called by an application that is administering the device to disable all cameras on the
 * device, for this user. After setting this, no applications running as this user will be able
 * to access any cameras on the device.
 * <p>
 * If the caller is device owner, then the restriction will be applied to all users.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call this method; if it has
 * not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 * @throws SecurityException if {@code admin} is not an active administrator or does not use
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is a new method call at the beginning of the method throwIfParentInstance(""setCameraDisabled""), and an exception handling statement has been changed from logging the exception to throwing it, so the code change type is 2,4.","The new method call does not directly affect the return value or type but the change in the exception handling (throwing the exception instead of just logging it) means that exceptions are now propagated instead of being caught, which leads to a different behavior in the case of an exception occurring. This makes the CI type 2."
788,<android.content.res.Resources: DisplayMetrics getDisplayMetrics()>,23,24,<android.content.res.Resources: DisplayMetrics getDisplayMetrics()>,<android.content.res.Resources: DisplayMetrics getDisplayMetrics()>,0,"{
    if (DEBUG_CONFIG)
        Slog.v(TAG, ""Returning DisplayMetrics: "" + mMetrics.widthPixels + ""x"" + mMetrics.heightPixels + "" "" + mMetrics.density);
    return mMetrics;
}","{
    return mResourcesImpl.getDisplayMetrics();
}",1,"/**
 * Return the current display metrics that are in effect for this resource
 * object.  The returned object should be treated as read-only.
 *
 * @return The resource's current display metrics.
 */
","/**
 * Return the current display metrics that are in effect for this resource
 * object.  The returned object should be treated as read-only.
 *
 * @return The resource's current display metrics.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation has changed from directly returning a member variable (mMetrics) to calling a method on another object (mResourcesImpl.getDisplayMetrics()), so the code change type is 5.","Since the implementation now relies on a method from another object, if the returned value from mResourcesImpl.getDisplayMetrics() is different from the value of mMetrics, the new implementation can lead to a different return value. This change introduces a compatibility issue because the method now potentially returns a different variable, so the CI type is 1."
789,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,23,24,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,0,"{
    if (mService != null) {
        try {
            long deviceId = 0;
            /* TODO: plumb hardware id to FPMS */
            return mService.isHardwareDetected(deviceId, mContext.getOpPackageName());
        } catch (RemoteException e) {
            Log.v(TAG, ""Remote exception in isFingerprintHardwareDetected(): "", e);
        }
    } else {
        Log.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}","{
    if (mService != null) {
        try {
            long deviceId = 0;
            /* TODO: plumb hardware id to FPMS */
            return mService.isHardwareDetected(deviceId, mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Log.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}",1,"/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 */
","/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 */
",-1,[@RequiresPermission(USE_FINGERPRINT)],[@RequiresPermission(USE_FINGERPRINT)],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from logging the exception to throwing the exception, so the code change type is 2.","The change in the code will lead to a potential different exception being thrown. Instead of logging the exception and returning false, the new code throws the exception. Therefore, the CI type is 2."
790,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",23,24,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"1,2,5","1,2",Method sendStickyOrderedBroadcastAsUser's implementation has three changes:,
791,<android.widget.Editor.SelectionModifierCursorController: boolean isDragAcceleratorActive()>,23,24,<android.widget.Editor.SelectionModifierCursorController: boolean isDragAcceleratorActive()>,<android.widget.Editor.SelectionModifierCursorController: boolean isDragAcceleratorActive()>,0,"{
    return mDragAcceleratorActive;
}","{
    return mDragAcceleratorMode != DRAG_ACCELERATOR_MODE_INACTIVE;
}",1,"/**
 * @return true if the user is selecting text using the drag accelerator.
 */
","/**
 * @return true if the user is selecting text using the drag accelerator.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement changed to evaluate a condition rather than returning a direct value, and the logic to determine the return result has changed, so the code change type is 1,4.","The change in the return statement alters the condition under which the method returns true or false. Therefore, the API's behavior could potentially return a different value, so the CI type is 1."
792,"<android.content.res.Resources: void getValue(int,TypedValue,boolean)>",23,24,"<android.content.res.Resources: void getValue(int,TypedValue,boolean)>","<android.content.res.Resources: void getValue(int,TypedValue,boolean)>",0,"{
    boolean found = mAssets.getResourceValue(id, 0, outValue, resolveRefs);
    if (found) {
        return;
    }
    throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id));
}","{
    mResourcesImpl.getValue(id, outValue, resolveRefs);
}",1,"/**
 * Return the raw data associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param outValue Object in which to place the resource data.
 * @param resolveRefs If true, a resource that is a reference to another
 * resource will be followed so that you receive the
 * actual final resource data.  If false, the TypedValue
 * will be filled in with the reference itself.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Return the raw data associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param outValue Object in which to place the resource data.
 * @param resolveRefs If true, a resource that is a reference to another
 * resource will be followed so that you receive the
 * actual final resource data.  If false, the TypedValue
 * will be filled in with the reference itself.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5","1,2","The method body has been completely replaced, where 'mAssets.getResourceValue' is removed and replaced with 'mResourcesImpl.getValue'. The control flow for checking 'found' and throwing NotFoundException has been removed as well. These are changes of type 4, as it's a change in the sequence of operations being done inside the method, and type 5 because the dependent API used inside the method has changed.","These changes could lead to a CI for two reasons: 1) The new version no longer throws NotFoundException manually, thus potentially changing the exception being thrown, so type 2. 2) The method 'mResourcesImpl.getValue' could have a different implementation, possibly causing different return types or values, leading to a potential CI of type 1."
794,"<android.transition.Visibility: Animator onAppear(ViewGroup,TransitionValues,int,TransitionValues,int)>",23,24,"<android.transition.Visibility: Animator onAppear(ViewGroup,TransitionValues,int,TransitionValues,int)>","<android.transition.Visibility: Animator onAppear(ViewGroup,TransitionValues,int,TransitionValues,int)>",0,"{
    if ((mMode & MODE_IN) != MODE_IN || endValues == null) {
        return null;
    }
    if (startValues == null) {
        VisibilityInfo parentVisibilityInfo = null;
        View endParent = (View) endValues.view.getParent();
        TransitionValues startParentValues = getMatchedTransitionValues(endParent, false);
        TransitionValues endParentValues = getTransitionValues(endParent, false);
        parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
        if (parentVisibilityInfo.visibilityChange) {
            return null;
        }
    }
    final boolean isForcedVisibility = mForcedStartVisibility != -1 || mForcedEndVisibility != -1;
    if (isForcedVisibility) {
        // Make sure that we reverse the effect of onDisappear's setTransitionAlpha(0)
        endValues.view.setTransitionAlpha(1);
    }
    return onAppear(sceneRoot, endValues.view, startValues, endValues);
}","{
    if ((mMode & MODE_IN) != MODE_IN || endValues == null) {
        return null;
    }
    if (startValues == null) {
        VisibilityInfo parentVisibilityInfo = null;
        View endParent = (View) endValues.view.getParent();
        TransitionValues startParentValues = getMatchedTransitionValues(endParent, false);
        TransitionValues endParentValues = getTransitionValues(endParent, false);
        parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
        if (parentVisibilityInfo.visibilityChange) {
            return null;
        }
    }
    return onAppear(sceneRoot, endValues.view, startValues, endValues);
}",1,"/**
 * The default implementation of this method calls
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * Subclasses should override this method or
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * if they need to create an Animator when targets appear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
","/**
 * The default implementation of this method calls
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * Subclasses should override this method or
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * if they need to create an Animator when targets appear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"An if statement checking for `isForcedVisibility` and a subsequent operation `endValues.view.setTransitionAlpha(1)` have been removed in the late implementation, thus the change type is 1,4.","The removal of the `isForcedVisibility` condition and the `setTransitionAlpha` operation can lead to the API potentially returning a different Animator object because the visual state of `endValues.view` could remain altered from its previous state, which directly impacts the outcome of the subsequent `onAppear` call. Therefore, the CI type is 1."
795,<com.android.server.backup.NotificationBackupHelper: byte[] getBackupPayload(String)>,23,24,<com.android.server.backup.NotificationBackupHelper: byte[] getBackupPayload(String)>,<com.android.server.backup.NotificationBackupHelper: byte[] getBackupPayload(String)>,0,"{
    byte[] newPayload = null;
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            newPayload = nm.getBackupPayload(UserHandle.USER_OWNER);
        } catch (Exception e) {
            // Treat as no data
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
            newPayload = null;
        }
    }
    return newPayload;
}","{
    byte[] newPayload = null;
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            // TODO: http://b/22388012
            newPayload = nm.getBackupPayload(UserHandle.USER_SYSTEM);
        } catch (Exception e) {
            // Treat as no data
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
            newPayload = null;
        }
    }
    return newPayload;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The method getBackupPayload() from INotificationManager is called with a parameter change from UserHandle.USER_OWNER to UserHandle.USER_SYSTEM, and this denotes a change in the dependent API called within the method, leading to the code change type 5.","Since there is a change in the argument passed to the dependent API, it could potentially return a different payload for the system user compared to the owner user, and this would result in a different value returned by the method getBackupPayload(String). Thus, the CI type is 1."
796,<android.hardware.radio.RadioManager.FmBandDescriptor: boolean equals(Object)>,23,24,<android.hardware.radio.RadioManager.FmBandDescriptor: boolean equals(Object)>,<android.hardware.radio.RadioManager.FmBandDescriptor: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (!super.equals(obj))
        return false;
    if (!(obj instanceof FmBandDescriptor))
        return false;
    FmBandDescriptor other = (FmBandDescriptor) obj;
    if (mStereo != other.isStereoSupported())
        return false;
    if (mRds != other.isRdsSupported())
        return false;
    if (mTa != other.isTaSupported())
        return false;
    if (mAf != other.isAfSupported())
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (!super.equals(obj))
        return false;
    if (!(obj instanceof FmBandDescriptor))
        return false;
    FmBandDescriptor other = (FmBandDescriptor) obj;
    if (mStereo != other.isStereoSupported())
        return false;
    if (mRds != other.isRdsSupported())
        return false;
    if (mTa != other.isTaSupported())
        return false;
    if (mAf != other.isAfSupported())
        return false;
    if (mEa != other.isEaSupported())
        return false;
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"There is an additional check (`if (mEa != other.isEaSupported()) return false;`) in the late version, which is the introduction of a new 'if' statement and a return statement within the method body, so the code change type is 1,4.","The addition of the new 'if' statement with the return false condition introduces the possibility that the late version of the method could return false where the early version would have returned true, resulting in potential different return values or types. Hence, the CI type is 1."
797,"<android.app.LoadedApk.ServiceDispatcher: void death(ComponentName,IBinder)>",23,24,"<android.app.LoadedApk.ServiceDispatcher: void death(ComponentName,IBinder)>","<android.app.LoadedApk.ServiceDispatcher: void death(ComponentName,IBinder)>",0,"{
    ServiceDispatcher.ConnectionInfo old;
    synchronized (this) {
        mDied = true;
        old = mActiveConnections.remove(name);
        if (old == null || old.binder != service) {
            // reported...  just ignore it.
            return;
        }
        old.binder.unlinkToDeath(old.deathMonitor, 0);
    }
    if (mActivityThread != null) {
        mActivityThread.post(new RunConnection(name, service, 1));
    } else {
        doDeath(name, service);
    }
}","{
    ServiceDispatcher.ConnectionInfo old;
    synchronized (this) {
        old = mActiveConnections.remove(name);
        if (old == null || old.binder != service) {
            // reported...  just ignore it.
            return;
        }
        old.binder.unlinkToDeath(old.deathMonitor, 0);
    }
    if (mActivityThread != null) {
        mActivityThread.post(new RunConnection(name, service, 1));
    } else {
        doDeath(name, service);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment `mDied = true;` statement in the synchronized block was removed, so the code change type is 4.","The removal of the `mDied = true;` statement does not affect the return value or the exceptions thrown by the method, as the method's behavior remains consistent in terms of the service connection death handling. Therefore, there's no Compatibility Issue, and the CI type is 0."
799,<android.speech.tts.FileSynthesisCallback: int done()>,23,24,<android.speech.tts.FileSynthesisCallback: int done()>,<android.speech.tts.FileSynthesisCallback: int done()>,0,"{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    FileChannel fileChannel = null;
    int sampleRateInHz = 0;
    int audioFormat = 0;
    int channelCount = 0;
    synchronized (mStateLock) {
        if (mDone) {
            Log.w(TAG, ""Duplicate call to done()"");
            // setStatusCode is set.
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        if (mDispatcher != null && mStatusCode != TextToSpeech.SUCCESS && mStatusCode != TextToSpeech.STOPPED) {
            mDispatcher.dispatchOnError(mStatusCode);
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        mDone = true;
        fileChannel = mFileChannel;
        sampleRateInHz = mSampleRateInHz;
        audioFormat = mAudioFormat;
        channelCount = mChannelCount;
    }
    try {
        // Write WAV header at start of file
        fileChannel.position(0);
        int dataLength = (int) (fileChannel.size() - WAV_HEADER_LENGTH);
        fileChannel.write(makeWavHeader(sampleRateInHz, audioFormat, channelCount, dataLength));
        synchronized (mStateLock) {
            closeFile();
            if (mDispatcher != null) {
                mDispatcher.dispatchOnSuccess();
            }
            return TextToSpeech.SUCCESS;
        }
    } catch (IOException ex) {
        Log.e(TAG, ""Failed to write to output file descriptor"", ex);
        synchronized (mStateLock) {
            cleanUp();
        }
        return TextToSpeech.ERROR;
    }
}","{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    FileChannel fileChannel = null;
    int sampleRateInHz = 0;
    int audioFormat = 0;
    int channelCount = 0;
    synchronized (mStateLock) {
        if (mDone) {
            Log.w(TAG, ""Duplicate call to done()"");
            // setStatusCode is set.
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS && mStatusCode != TextToSpeech.STOPPED) {
            mDispatcher.dispatchOnError(mStatusCode);
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        mDone = true;
        fileChannel = mFileChannel;
        sampleRateInHz = mSampleRateInHz;
        audioFormat = mAudioFormat;
        channelCount = mChannelCount;
    }
    try {
        // Write WAV header at start of file
        fileChannel.position(0);
        int dataLength = (int) (fileChannel.size() - WAV_HEADER_LENGTH);
        fileChannel.write(makeWavHeader(sampleRateInHz, audioFormat, channelCount, dataLength));
        synchronized (mStateLock) {
            closeFile();
            mDispatcher.dispatchOnSuccess();
            return TextToSpeech.SUCCESS;
        }
    } catch (IOException ex) {
        Log.e(TAG, ""Failed to write to output file descriptor"", ex);
        synchronized (mStateLock) {
            cleanUp();
        }
        return TextToSpeech.ERROR;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The code change includes the removal of the null check for mDispatcher which changes the control dependency. Therefore, the control dependency change is identified as type 3. Additionally, mDispatcher.dispatchOnSuccess() is called without a null check, altering an existing behavior, which is a type 4 change. ","With the removal of the null check for mDispatcher, the late version may produce a NullPointerException if mDispatcher is null when calling mDispatcher.dispatchOnSuccess(). This presents a potential Compatibility Issue due to a change in exception handling behavior, which has a possibility of causing the API to throw a different exception from what was thrown previously. Therefore, CI type 1 applies."
800,<android.app.DialogFragment: void onActivityCreated(Bundle)>,23,24,<android.app.DialogFragment: void onActivityCreated(Bundle)>,<android.app.DialogFragment: void onActivityCreated(Bundle)>,0,"{
    super.onActivityCreated(savedInstanceState);
    if (!mShowsDialog) {
        return;
    }
    View view = getView();
    if (view != null) {
        if (view.getParent() != null) {
            throw new IllegalStateException(""DialogFragment can not be attached to a container view"");
        }
        mDialog.setContentView(view);
    }
    mDialog.setOwnerActivity(getActivity());
    mDialog.setCancelable(mCancelable);
    if (!mDialog.takeCancelAndDismissListeners(""DialogFragment"", this, this)) {
        throw new IllegalStateException(""You can not set Dialog's OnCancelListener or OnDismissListener"");
    }
    if (savedInstanceState != null) {
        Bundle dialogState = savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG);
        if (dialogState != null) {
            mDialog.onRestoreInstanceState(dialogState);
        }
    }
}","{
    super.onActivityCreated(savedInstanceState);
    if (!mShowsDialog) {
        return;
    }
    View view = getView();
    if (view != null) {
        if (view.getParent() != null) {
            throw new IllegalStateException(""DialogFragment can not be attached to a container view"");
        }
        mDialog.setContentView(view);
    }
    final Activity activity = getActivity();
    if (activity != null) {
        mDialog.setOwnerActivity(activity);
    }
    mDialog.setCancelable(mCancelable);
    if (!mDialog.takeCancelAndDismissListeners(""DialogFragment"", this, this)) {
        throw new IllegalStateException(""You can not set Dialog's OnCancelListener or OnDismissListener"");
    }
    if (savedInstanceState != null) {
        Bundle dialogState = savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG);
        if (dialogState != null) {
            mDialog.onRestoreInstanceState(dialogState);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"A control dependency has changed with the addition of a null check for the activity object before calling `mDialog.setOwnerActivity(activity);`, which is considered a change of type 3.","The addition of the null check for the activity does not alter the return value or the exception handling of the method. It simply prevents a potential NullPointerException, which would have been an uncaught runtime exception in the early version. However, since this null check does not change the behavior in regards to the return value or exception handling of the method (it corrects a previous potential issue), it does not introduce a compatibility issue, so the CI type is 0."
801,<android.print.PrintJobId: int hashCode()>,23,24,<android.print.PrintJobId: int hashCode()>,<android.print.PrintJobId: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mValue != null) ? mValue.hashCode() : 0);
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + mValue.hashCode();
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The hashCode computation has been simplified by removing a conditional operation, so the code changed types are 3 (control dependency change as the ternary operator was removed) and 4 (other statement changed due to modification in the statement).","This code change has removed the null-check for 'mValue' before calling 'mValue.hashCode()', which means that if 'mValue' is null, the early version returns 0 while the late version will throw a NullPointerException. This could lead to a different behavior (exception vs. normal return) when the method is called with 'mValue' being null. Hence, the CI type is 1."
802,"<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(String,int,int,String)>",23,24,"<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(String,int,int,String)>","<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(String,int,int,String)>",0,"{
    if (id != 0) {
        try {
            // These may be compiled...
            synchronized (mCachedXmlBlockIds) {
                // First see if this block is in our cache.
                final int num = mCachedXmlBlockIds.length;
                for (int i = 0; i < num; i++) {
                    if (mCachedXmlBlockIds[i] == id) {
                        // + id + "", index="" + i);
                        return mCachedXmlBlocks[i].newParser();
                    }
                }
                // Not in the cache, create a new block and put it at
                // the next slot in the cache.
                XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file);
                if (block != null) {
                    int pos = mLastCachedXmlBlockIndex + 1;
                    if (pos >= num)
                        pos = 0;
                    mLastCachedXmlBlockIndex = pos;
                    XmlBlock oldBlock = mCachedXmlBlocks[pos];
                    if (oldBlock != null) {
                        oldBlock.close();
                    }
                    mCachedXmlBlockIds[pos] = id;
                    mCachedXmlBlocks[pos] = block;
                    // + id + "", index="" + pos);
                    return block.newParser();
                }
            }
        } catch (Exception e) {
            NotFoundException rnf = new NotFoundException(""File "" + file + "" from xml type "" + type + "" resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
    }
    throw new NotFoundException(""File "" + file + "" from xml type "" + type + "" resource ID #0x"" + Integer.toHexString(id));
}","{
    return mResourcesImpl.loadXmlResourceParser(file, id, assetCookie, type);
}",1,"/*package*/
","/**
 * Loads an XML parser for the specified file.
 *
 * @param file the path for the XML file to parse
 * @param id the resource identifier for the file
 * @param assetCookie the asset cookie for the file
 * @param type the type of resource (used for logging)
 * @return a parser for the specified XML file
 * @throws NotFoundException if the file could not be loaded
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5","1,2","The implementation of the method changed entirely from its early version to call `mResourcesImpl.loadXmlResourceParser()` in the late version. The early version contained logic to handle caching and opening of `XmlBlock` which has been removed entirely. Hence, both the return statement and the dependent API have changed dramatically, thus the code change types are 1,5.","Given that the implementation has changed to delegate to another method, `mResourcesImpl.loadXmlResourceParser()`, which could have a different implementation, this could potentially cause different return values (CI type 1). Additionally, the specific exception handling (catching `Exception` and throwing `NotFoundException` with the early version) has been removed and potentially replaced with different exception handling by `mResourcesImpl.loadXmlResourceParser()`, which constitutes a change in exception handling (CI type 2). Therefore, there are potential compatibility issues related to both return values and exception handling."
804,<android.print.PrinterInfo: int hashCode()>,23,24,<android.print.PrinterInfo: int hashCode()>,<android.print.PrinterInfo: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mId != null) ? mId.hashCode() : 0);
    result = prime * result + ((mName != null) ? mName.hashCode() : 0);
    result = prime * result + mStatus;
    result = prime * result + ((mDescription != null) ? mDescription.hashCode() : 0);
    result = prime * result + ((mCapabilities != null) ? mCapabilities.hashCode() : 0);
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + mId.hashCode();
    result = prime * result + mName.hashCode();
    result = prime * result + mStatus;
    result = prime * result + ((mDescription != null) ? mDescription.hashCode() : 0);
    result = prime * result + ((mCapabilities != null) ? mCapabilities.hashCode() : 0);
    result = prime * result + mIconResourceId;
    result = prime * result + (mHasCustomPrinterIcon ? 1 : 0);
    result = prime * result + mCustomPrinterIconGen;
    result = prime * result + ((mInfoIntent != null) ? mInfoIntent.hashCode() : 0);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"In the late version implementation, hashCode() includes additional fields (mIconResourceId, mHasCustomPrinterIcon, mCustomPrinterIconGen, mInfoIntent) in the hash code calculation that were not present in the early version. Also, null checks are removed from mId and mName, so this is an other statement changed (4).","The changes will lead to a different value returned by hashCode(), which can impact hash-based collections (like HashSet, HashMap, etc). So the CI type is 1."
805,<android.os.DropBoxManager: boolean isTagEnabled(String)>,23,24,<android.os.DropBoxManager: boolean isTagEnabled(String)>,<android.os.DropBoxManager: boolean isTagEnabled(String)>,0,"{
    try {
        return mService.isTagEnabled(tag);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return mService.isTagEnabled(tag);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Checks any blacklists (set in system settings) to see whether a certain
 * tag is allowed.  Entries with disabled tags will be dropped immediately,
 * so you can save the work of actually constructing and sending the data.
 *
 * @param tag that would be used in {@link #addText} or {@link #addFile}
 * @return whether events with that tag would be accepted
 */
","/**
 * Checks any blacklists (set in system settings) to see whether a certain
 * tag is allowed.  Entries with disabled tags will be dropped immediately,
 * so you can save the work of actually constructing and sending the data.
 *
 * @param tag that would be used in {@link #addText} or {@link #addFile}
 * @return whether events with that tag would be accepted
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed; the catch block no longer returns false and instead throws an exception, so the code change type is 2.","Due to the change in exception handling, where the exception is no longer caught and false returned, but rather re-thrown, this leads to a potential different exception handling, marking it as a CI type 2."
806,<android.view.inputmethod.InputMethodManager: void closeCurrentInput()>,23,24,<android.view.inputmethod.InputMethodManager: void closeCurrentInput()>,<android.view.inputmethod.InputMethodManager: void closeCurrentInput()>,0,"{
    try {
        mService.hideSoftInput(mClient, HIDE_NOT_ALWAYS, null);
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.hideSoftInput(mClient, HIDE_NOT_ALWAYS, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed; instead of catching the exception and doing nothing, the new version throws the caught exception after wrapping it with ""rethrowFromSystemServer()"", so the code change type is 2.","Because the newer version now throws an exception where the previous version did not, this could potentially result in different exception handling when the method is called. Therefore, there is a Compatibility Issue of type 2."
809,"<android.app.admin.DevicePolicyManager: boolean setKeyguardDisabled(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: boolean setKeyguardDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: boolean setKeyguardDisabled(ComponentName,boolean)>",0,"{
    try {
        return mService.setKeyguardDisabled(admin, disabled);
    } catch (RemoteException re) {
        Log.w(TAG, ""Failed talking with device policy service"", re);
        return false;
    }
}","{
    throwIfParentInstance(""setKeyguardDisabled"");
    try {
        return mService.setKeyguardDisabled(admin, disabled);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by a device owner to disable the keyguard altogether.
 *
 * <p>Setting the keyguard to disabled has the same effect as choosing ""None"" as the screen
 * lock type. However, this call has no effect if a password, pin or pattern is currently set.
 * If a password, pin or pattern is set after the keyguard was disabled, the keyguard stops
 * being disabled.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled {@code true} disables the keyguard, {@code false} reenables it.
 *
 * @return {@code false} if attempting to disable the keyguard while a lock password was in
 * place. {@code true} otherwise.
 */
","/**
 * Called by a device owner to disable the keyguard altogether.
 * <p>
 * Setting the keyguard to disabled has the same effect as choosing ""None"" as the screen lock
 * type. However, this call has no effect if a password, pin or pattern is currently set. If a
 * password, pin or pattern is set after the keyguard was disabled, the keyguard stops being
 * disabled.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled {@code true} disables the keyguard, {@code false} reenables it.
 * @return {@code false} if attempting to disable the keyguard while a lock password was in
 * place. {@code true} otherwise.
 * @throws SecurityException if {@code admin} is not a device owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"There is a new method call `throwIfParentInstance(""setKeyguardDisabled"")` at the beginning of the method and the exception handling statement has changed, so the change types are 3,4.","The exception handling has changed from logging and returning false to rethrowing the exception, which means the exception is no longer caught and handled within the method; therefore, calling code could now encounter a thrown exception where previously it did not, indicating a CI type of 2."
810,<android.content.res.Resources: InputStream openRawResource(int)>,23,24,<android.content.res.Resources: InputStream openRawResource(int)>,<android.content.res.Resources: InputStream openRawResource(int)>,0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
    }
    InputStream res = openRawResource(id, value);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        return openRawResource(id, value);
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Open a data stream for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset files -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * @param id The resource identifier to open, as generated by the appt
 * tool.
 *
 * @return InputStream Access to the resource data.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Open a data stream for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset files -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * @param id The resource identifier to open, as generated by the appt
 * tool.
 *
 * @return InputStream Access to the resource data.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The change involves the removal of explicit synchronization on mAccessLock, the removal of code that conditionally creates a new TypedValue or reuses an existing one, the introduction of a try-finally block, and the use of new methods obtainTempTypedValue() and releaseTempTypedValue(value) which indicates the dependent API has changed as well. So the change types are 3,4,5.","Although refactoring is involved that changes how the TypedValue object is obtained and released, the final behavior of the API, which is to open a raw resource and return an InputStream, remains unchanged. The changes have not altered the API's input or output contract, hence there is no compatibility issue."
812,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",23,24,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>","<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",0,"{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt(""sys.max_texture_size"", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt(""sys.max_texture_size"", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
","/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home apps</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An additional 'throw new RuntimeException(new DeadSystemException())' statement in an if condition and change of exception handling from comment to 'throw e.rethrowFromSystemServer()' are introduced, so the code change type is 2,4.","The introduction of a new RuntimeException within the if condition and a different exception handling mechanism in the catch block could lead to different exceptions thrown from this method. Therefore, the CI type is 2."
814,<android.app.Fragment: void performDestroyView()>,23,24,<android.app.Fragment: void performDestroyView()>,<android.app.Fragment: void performDestroyView()>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroyView();
    }
    mCalled = false;
    onDestroyView();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDestroyView()"");
    }
    if (mLoaderManager != null) {
        mLoaderManager.doReportNextStart();
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroyView();
    }
    mState = CREATED;
    mCalled = false;
    onDestroyView();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDestroyView()"");
    }
    if (mLoaderManager != null) {
        mLoaderManager.doReportNextStart();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new assignment statement has been introduced, `mState = CREATED;`, which is not a return statement, not an exception handling change, nor a control dependency change. Therefore, the change is classified as type 4.","The new assignment to `mState` does not inherently affect the return value or exceptions thrown by the method, as it does not alter the flow of control nor the conditions that lead to the throwing of an exception or returning of a value. As the compatibility issue types are strictly about changes that affect the return value or how an exception is thrown, and this assignment to `mState` does not directly relate to those outcomes, there is no compatibility issue as per the given definitions."
815,"<android.view.inputmethod.BaseInputConnection: boolean setComposingText(CharSequence,int)>",23,24,"<android.view.inputmethod.BaseInputConnection: boolean setComposingText(CharSequence,int)>","<android.view.inputmethod.BaseInputConnection: boolean setComposingText(CharSequence,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""setComposingText "" + text);
    replaceText(text, newCursorPosition, true);
    mIMM.notifyUserAction();
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""setComposingText "" + text);
    replaceText(text, newCursorPosition, true);
    return true;
}",1,"/**
 * The default implementation places the given text into the editable,
 * replacing any existing composing text.  The new text is marked as
 * in a composing state with the composing style.
 */
","/**
 * The default implementation places the given text into the editable,
 * replacing any existing composing text.  The new text is marked as
 * in a composing state with the composing style.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call mIMM.notifyUserAction() has been removed, which doesn't affect return statements or exception handling, so the code change type is 4.","There are no changes related to the return type or value and no new exception handling introduced, so there is no Compatibility Issue, which implies CI type 0."
816,"<android.widget.HorizontalScrollView: void onMeasure(int,int)>",23,24,"<android.widget.HorizontalScrollView: void onMeasure(int,int)>","<android.widget.HorizontalScrollView: void onMeasure(int,int)>",0,"{
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    if (!mFillViewport) {
        return;
    }
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.UNSPECIFIED) {
        return;
    }
    if (getChildCount() > 0) {
        final View child = getChildAt(0);
        int width = getMeasuredWidth();
        if (child.getMeasuredWidth() < width) {
            final FrameLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams();
            int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height);
            width -= mPaddingLeft;
            width -= mPaddingRight;
            int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY);
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
    }
}","{
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    if (!mFillViewport) {
        return;
    }
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.UNSPECIFIED) {
        return;
    }
    if (getChildCount() > 0) {
        final View child = getChildAt(0);
        final int widthPadding;
        final int heightPadding;
        final FrameLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams();
        final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
        if (targetSdkVersion >= Build.VERSION_CODES.M) {
            widthPadding = mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin;
            heightPadding = mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin;
        } else {
            widthPadding = mPaddingLeft + mPaddingRight;
            heightPadding = mPaddingTop + mPaddingBottom;
        }
        int desiredWidth = getMeasuredWidth() - widthPadding;
        if (child.getMeasuredWidth() < desiredWidth) {
            final int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(desiredWidth, MeasureSpec.EXACTLY);
            final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, heightPadding, lp.height);
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes the introduction of new variables (widthPadding and heightPadding), reorganization of the calculation of these variables with a condition to check the targetSdkVersion, and a change in the way these variables are used in the calculation of desiredWidth and childHeightMeasureSpec. Hence, the code change types are 3 for the control dependency change and 4 for other statements change.","Even though there are changes in the statements, these changes do not lead to a change in behavior in terms of what the method returns (since it's a 'void' method and does not return anything) or the exceptions it throws. The behavior of `onMeasure()` could be different in terms of how it measures the child view, but this would not constitute a compatibility issue since the method's purpose is to measure a view, and it is expected to do so based on different conditions (like the targetSdkVersion). This is an internal behavioral change that does not affect compatibility."
817,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,23,24,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,0,"{
    synchronized (mH) {
        try {
            return mService.getLastInputMethodSubtype();
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
            return null;
        }
    }
}","{
    synchronized (mH) {
        try {
            return mService.getLastInputMethodSubtype();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has changed, replacing a log and 'return null' in the case of RemoteException with a throw statement, so the code change type is 2.","This change in exception handling will lead to a RuntimeException being thrown in the later version where previously there was none (it used to return null), leading to a change in exceptions thrown by the method. The CI type is 2."
818,"<android.app.admin.DevicePolicyManager: void setRecommendedGlobalProxy(ComponentName,ProxyInfo)>",23,24,"<android.app.admin.DevicePolicyManager: void setRecommendedGlobalProxy(ComponentName,ProxyInfo)>","<android.app.admin.DevicePolicyManager: void setRecommendedGlobalProxy(ComponentName,ProxyInfo)>",0,"{
    if (mService != null) {
        try {
            mService.setRecommendedGlobalProxy(admin, proxyInfo);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setRecommendedGlobalProxy"");
    if (mService != null) {
        try {
            mService.setRecommendedGlobalProxy(admin, proxyInfo);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Set a network-independent global HTTP proxy.  This is not normally what you want
 * for typical HTTP proxies - they are generally network dependent.  However if you're
 * doing something unusual like general internal filtering this may be useful.  On
 * a private network where the proxy is not accessible, you may break HTTP using this.
 *
 * <p>This method requires the caller to be the device owner.
 *
 * <p>This proxy is only a recommendation and it is possible that some apps will ignore it.
 * @see ProxyInfo
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param proxyInfo The a {@link ProxyInfo} object defining the new global
 * HTTP proxy.  A {@code null} value will clear the global HTTP proxy.
 */
","/**
 * Set a network-independent global HTTP proxy. This is not normally what you want for typical
 * HTTP proxies - they are generally network dependent. However if you're doing something
 * unusual like general internal filtering this may be useful. On a private network where the
 * proxy is not accessible, you may break HTTP using this.
 * <p>
 * This method requires the caller to be the device owner.
 * <p>
 * This proxy is only a recommendation and it is possible that some apps will ignore it.
 *
 * @see ProxyInfo
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param proxyInfo The a {@link ProxyInfo} object defining the new global HTTP proxy. A
 * {@code null} value will clear the global HTTP proxy.
 * @throws SecurityException if {@code admin} is not the device owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The introduction of a new method call, throwIfParentInstance(""setRecommendedGlobalProxy""), before the control dependency and a change in exception handling from logging an error to re-throwing the exception constitute the change types 2, and 4.","Due to the introduction of a new exception handling statement that throws the exception instead of logging it, the method's behavior is changed in terms of how it handles exceptions. Thus, it might result in different exception handlings, categorized under CI type 2."
819,<android.webkit.WebViewFactory.RelroFileCreator: void main(String[])>,23,24,<android.webkit.WebViewFactory.RelroFileCreator: void main(String[])>,<android.webkit.WebViewFactory.RelroFileCreator: void main(String[])>,0,"{
    boolean result = false;
    boolean is64Bit = VMRuntime.getRuntime().is64Bit();
    try {
        if (args.length != 2 || args[0] == null || args[1] == null) {
            Log.e(LOGTAG, ""Invalid RelroFileCreator args: "" + Arrays.toString(args));
            return;
        }
        Log.v(LOGTAG, ""RelroFileCreator (64bit = "" + is64Bit + ""), "" + "" 32-bit lib: "" + args[0] + "", 64-bit lib: "" + args[1]);
        if (!sAddressSpaceReserved) {
            Log.e(LOGTAG, ""can't create relro file; address space not reserved"");
            return;
        }
        result = nativeCreateRelroFile(args[0], /* path32 */
        args[1], /* path64 */
        CHROMIUM_WEBVIEW_NATIVE_RELRO_32, CHROMIUM_WEBVIEW_NATIVE_RELRO_64);
        if (result && DEBUG)
            Log.v(LOGTAG, ""created relro file"");
    } finally {
        // We must do our best to always notify the update service, even if something fails.
        try {
            getUpdateService().notifyRelroCreationCompleted(is64Bit, result);
        } catch (RemoteException e) {
            Log.e(LOGTAG, ""error notifying update service"", e);
        }
        if (!result)
            Log.e(LOGTAG, ""failed to create relro file"");
        // Must explicitly exit or else this process will just sit around after we return.
        System.exit(0);
    }
}","{
    boolean result = false;
    boolean is64Bit = VMRuntime.getRuntime().is64Bit();
    try {
        if (args.length != 2 || args[0] == null || args[1] == null) {
            Log.e(LOGTAG, ""Invalid RelroFileCreator args: "" + Arrays.toString(args));
            return;
        }
        Log.v(LOGTAG, ""RelroFileCreator (64bit = "" + is64Bit + ""), "" + "" 32-bit lib: "" + args[0] + "", 64-bit lib: "" + args[1]);
        if (!sAddressSpaceReserved) {
            Log.e(LOGTAG, ""can't create relro file; address space not reserved"");
            return;
        }
        result = nativeCreateRelroFile(args[0], /* path32 */
        args[1], /* path64 */
        CHROMIUM_WEBVIEW_NATIVE_RELRO_32, CHROMIUM_WEBVIEW_NATIVE_RELRO_64);
        if (result && DEBUG)
            Log.v(LOGTAG, ""created relro file"");
    } finally {
        // We must do our best to always notify the update service, even if something fails.
        try {
            getUpdateService().notifyRelroCreationCompleted();
        } catch (RemoteException e) {
            Log.e(LOGTAG, ""error notifying update service"", e);
        }
        if (!result)
            Log.e(LOGTAG, ""failed to create relro file"");
        // Must explicitly exit or else this process will just sit around after we return.
        System.exit(0);
    }
}",1,"// Called in an unprivileged child process to create the relro file.
","// Called in an unprivileged child process to create the relro file.
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is noticed in the method call `getUpdateService().notifyRelroCreationCompleted(is64Bit, result);` where in the late version, the parameters passed to the method have been removed, so the change type is 4,5.","Though the change affects how `notifyRelroCreationCompleted` is called, it doesn't introduce a difference in the behavior of the `main` method itself in terms of the return value or exceptions. The method's return type is void and it ends with `System.exit(0)`, which will terminate the JVM. Moreover, the try block does not return a value or throw an exception based upon the `result` or the completion of the notification. Therefore, there is no Compatibility Issue related to the return value or the exception handling; hence, the CI type is 0."
820,<android.content.res.Configuration: int hashCode()>,23,24,<android.content.res.Configuration: int hashCode()>,<android.content.res.Configuration: int hashCode()>,0,"{
    int result = 17;
    result = 31 * result + Float.floatToIntBits(fontScale);
    result = 31 * result + mcc;
    result = 31 * result + mnc;
    result = 31 * result + (locale != null ? locale.hashCode() : 0);
    result = 31 * result + touchscreen;
    result = 31 * result + keyboard;
    result = 31 * result + keyboardHidden;
    result = 31 * result + hardKeyboardHidden;
    result = 31 * result + navigation;
    result = 31 * result + navigationHidden;
    result = 31 * result + orientation;
    result = 31 * result + screenLayout;
    result = 31 * result + uiMode;
    result = 31 * result + screenWidthDp;
    result = 31 * result + screenHeightDp;
    result = 31 * result + smallestScreenWidthDp;
    result = 31 * result + densityDpi;
    return result;
}","{
    int result = 17;
    result = 31 * result + Float.floatToIntBits(fontScale);
    result = 31 * result + mcc;
    result = 31 * result + mnc;
    result = 31 * result + mLocaleList.hashCode();
    result = 31 * result + touchscreen;
    result = 31 * result + keyboard;
    result = 31 * result + keyboardHidden;
    result = 31 * result + hardKeyboardHidden;
    result = 31 * result + navigation;
    result = 31 * result + navigationHidden;
    result = 31 * result + orientation;
    result = 31 * result + screenLayout;
    result = 31 * result + uiMode;
    result = 31 * result + screenWidthDp;
    result = 31 * result + screenHeightDp;
    result = 31 * result + smallestScreenWidthDp;
    result = 31 * result + densityDpi;
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The hashCode calculation changed from using locale.hashCode() in the early version to mLocaleList.hashCode() in the late version, which implies a dependent API change as the source for the hash calculation has been altered. Therefore, the code change type is 1,5.","The result of the hashCode method could potentially be different between the two versions due to the change in how the locale-related part of the hash is calculated. This is because even if the underlying locale data might be the same, the implementation of hashCode for mLocaleList could produce a different result compared to the hashCode of the individual locale. Therefore, the CI type is 1."
821,<android.service.notification.NotificationListenerService: RankingMap getCurrentRanking()>,23,24,<android.service.notification.NotificationListenerService: RankingMap getCurrentRanking()>,<android.service.notification.NotificationListenerService: RankingMap getCurrentRanking()>,0,"{
    return mRankingMap;
}","{
    synchronized (mLock) {
        return mRankingMap;
    }
}",1,"/**
 * Returns current ranking information.
 *
 * <p>
 * The returned object represents the current ranking snapshot and only
 * applies for currently active notifications.
 * <p>
 * Generally you should use the RankingMap that is passed with events such
 * as {@link #onNotificationPosted(StatusBarNotification, RankingMap)},
 * {@link #onNotificationRemoved(StatusBarNotification, RankingMap)}, and
 * so on. This method should only be used when needing access outside of
 * such events, for example to retrieve the RankingMap right after
 * initialization.
 *
 * @return A {@link RankingMap} object providing access to ranking information
 */
","/**
 * Returns current ranking information.
 *
 * <p>
 * The returned object represents the current ranking snapshot and only
 * applies for currently active notifications.
 * <p>
 * Generally you should use the RankingMap that is passed with events such
 * as {@link #onNotificationPosted(StatusBarNotification, RankingMap)},
 * {@link #onNotificationRemoved(StatusBarNotification, RankingMap)}, and
 * so on. This method should only be used when needing access outside of
 * such events, for example to retrieve the RankingMap right after
 * initialization.
 *
 * <p>The service should wait for the {@link #onListenerConnected()} event
 * before performing this operation.
 *
 * @return A {@link RankingMap} object providing access to ranking information
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The addition of the synchronized block around the return statement is the only change, which is an ""Other statement changed"" (code 4), but this change does not affect the return value or how exceptions are thrown.","There's no Compatibility Issue since the addition of a synchronized block doesn't change the behavior of returning mRankingMap; it only ensures thread safety, so the method behavior is consistent with its specification."
822,<android.os.storage.StorageManager: String getMountedObbPath(String)>,23,24,<android.os.storage.StorageManager: String getMountedObbPath(String)>,<android.os.storage.StorageManager: String getMountedObbPath(String)>,0,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mMountService.getMountedObbPath(rawPath);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to find mounted path for OBB"", e);
    }
    return null;
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mMountService.getMountedObbPath(rawPath);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Check the mounted path of an Opaque Binary Blob (OBB) file. This will
 * give you the path to where you can obtain access to the internals of the
 * OBB.
 *
 * @param rawPath path to OBB image
 * @return absolute path to mounted OBB image data or <code>null</code> if
 * not mounted or exception encountered trying to read status
 */
","/**
 * Check the mounted path of an Opaque Binary Blob (OBB) file. This will
 * give you the path to where you can obtain access to the internals of the
 * OBB.
 *
 * @param rawPath path to OBB image
 * @return absolute path to mounted OBB image data or <code>null</code> if
 * not mounted or exception encountered trying to read status
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The method previously handled the RemoteException with a log message, then returned null. In the late version, instead of logging the exception and returning null, it throws the RemoteException, so the code change type is 2.","Because the exception handling behavior has changed, if RemoteException is encountered, it is no longer logged and null is no longer returned, but the exception is thrown, which could lead to a different exception handling behavior for the caller. Hence, the CI type is 2."
823,<android.app.ActivityManager: List<RunningServiceInfo> getRunningServices(int)>,23,24,<android.app.ActivityManager: List<RunningServiceInfo> getRunningServices(int)>,<android.app.ActivityManager: List<RunningServiceInfo> getRunningServices(int)>,0,"{
    try {
        return ActivityManagerNative.getDefault().getServices(maxNum, 0);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getServices(maxNum, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return a list of the services that are currently running.
 *
 * <p><b>Note: this method is only intended for debugging or implementing
 * service management type user interfaces.</b></p>
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many services
 * are running.
 *
 * @return Returns a list of RunningServiceInfo records describing each of
 * the running tasks.
 */
","/**
 * Return a list of the services that are currently running.
 *
 * <p><b>Note: this method is only intended for debugging or implementing
 * service management type user interfaces.</b></p>
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many services
 * are running.
 *
 * @return Returns a list of RunningServiceInfo records describing each of
 * the running tasks.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling has changed because the catch block no longer returns null but instead throws a RuntimeException, as indicated by the call to e.rethrowFromSystemServer(). The code change type is 2.","Because the exception handling strategy has changed from returning null to throwing a RuntimeException, this can lead to a different behavior when an exception occurs. Previously, the method would return null, swallowing the RemoteException, but in the newer version, the exception is propagated. The CI type is 2."
827,"<android.transition.Slide: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>",23,24,"<android.transition.Slide: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>","<android.transition.Slide: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null) {
        return null;
    }
    int[] position = (int[]) startValues.values.get(PROPNAME_SCREEN_POSITION);
    float startX = view.getTranslationX();
    float startY = view.getTranslationY();
    float endX = mSlideCalculator.getGoneX(sceneRoot, view);
    float endY = mSlideCalculator.getGoneY(sceneRoot, view);
    return TranslationAnimationCreator.createAnimation(view, startValues, position[0], position[1], startX, startY, endX, endY, sAccelerate, this);
}","{
    if (startValues == null) {
        return null;
    }
    int[] position = (int[]) startValues.values.get(PROPNAME_SCREEN_POSITION);
    float startX = view.getTranslationX();
    float startY = view.getTranslationY();
    float endX = mSlideCalculator.getGoneX(sceneRoot, view, mSlideFraction);
    float endY = mSlideCalculator.getGoneY(sceneRoot, view, mSlideFraction);
    return TranslationAnimationCreator.createAnimation(view, startValues, position[0], position[1], startX, startY, endX, endY, sAccelerate, this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The late version of the implementation passes an additional parameter `mSlideFraction` to the methods `mSlideCalculator.getGoneX` and `mSlideCalculator.getGoneY`. This change alters the method call dependencies, hence the code change type is 4,5 (Other statement changed and Dependent API changed).","The introduction of the new parameter `mSlideFraction` in the `getGoneX` and `getGoneY` methods' calls suggests that the calculated values of `endX` and `endY` might differ from those in the early version. These values are directly used in the resulting `Animator` object. Thus, there is a potential for the API to return a different value, making it a CI type 1 (Compatibility Issue caused by potential different return values or types)."
828,<android.app.ActivityView.ActivityViewSurfaceTextureListener: boolean onSurfaceTextureDestroyed(SurfaceTexture)>,23,24,<android.app.ActivityView.ActivityViewSurfaceTextureListener: boolean onSurfaceTextureDestroyed(SurfaceTexture)>,<android.app.ActivityView.ActivityViewSurfaceTextureListener: boolean onSurfaceTextureDestroyed(SurfaceTexture)>,0,"{
    if (mActivityContainer == null) {
        return true;
    }
    if (DEBUG)
        Log.d(TAG, ""onSurfaceTextureDestroyed"");
    mSurface.release();
    mSurface = null;
    try {
        mActivityContainer.setSurface(null, mWidth, mHeight, mMetrics.densityDpi);
    } catch (RemoteException e) {
        throw new RuntimeException(""ActivityView: Unable to set surface of ActivityContainer. "" + e);
    }
    if (mActivityViewCallback != null) {
        mActivityViewCallback.onSurfaceDestroyed(ActivityView.this);
    }
    return true;
}","{
    if (mActivityContainer == null) {
        return true;
    }
    if (DEBUG)
        Log.d(TAG, ""onSurfaceTextureDestroyed"");
    mSurface.release();
    mSurface = null;
    setSurfaceAsync(null, mWidth, mHeight, mDensityDpi, true);
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change from a direct call to mActivityContainer.setSurface(...) wrapped in a try-catch block to handle RemoteException, to a call to setSurfaceAsync(...), which is an indirect way of setting the surface, which could be a wrapper for handling exceptions internally or performing additional logic; and the variable mMetrics.densityDpi is replaced by mDensityDpi. That's why the code change types are 4 for the other statement changes and 5 for the dependent API changed.","The changes in the method do not affect the behavior of exception handling visible to the caller because any exception that would occur is handled internally in the new setSurfaceAsync() method, and it does not involve any change to the return type or exception thrown by the method itself. The return value in both cases is 'true', which remains constant. Thus, no Compatibility Issue is expected: 0."
829,<android.inputmethodservice.InputMethodService: void onConfigurationChanged(Configuration)>,23,24,<android.inputmethodservice.InputMethodService: void onConfigurationChanged(Configuration)>,<android.inputmethodservice.InputMethodService: void onConfigurationChanged(Configuration)>,0,"{
    super.onConfigurationChanged(newConfig);
    boolean visible = mWindowVisible;
    int showFlags = mShowInputFlags;
    boolean showingInput = mShowInputRequested;
    CompletionInfo[] completions = mCurCompletions;
    initViews();
    mInputViewStarted = false;
    mCandidatesViewStarted = false;
    if (mInputStarted) {
        doStartInput(getCurrentInputConnection(), getCurrentInputEditorInfo(), true);
    }
    if (visible) {
        if (showingInput) {
            // If we were last showing the soft keyboard, try to do so again.
            if (onShowInputRequested(showFlags, true)) {
                showWindow(true);
                if (completions != null) {
                    mCurCompletions = completions;
                    onDisplayCompletions(completions);
                }
            } else {
                doHideWindow();
            }
        } else if (mCandidatesVisibility == View.VISIBLE) {
            // If the candidates are currently visible, make sure the
            // window is shown for them.
            showWindow(false);
        } else {
            // Otherwise hide the window.
            doHideWindow();
        }
        // If user uses hard keyboard, IME button should always be shown.
        boolean showing = onEvaluateInputViewShown();
        mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    }
}","{
    super.onConfigurationChanged(newConfig);
    resetStateForNewConfiguration();
}",1,"/**
 * Take care of handling configuration changes.  Subclasses of
 * InputMethodService generally don't need to deal directly with
 * this on their own; the standard implementation here takes care of
 * regenerating the input method UI as a result of the configuration
 * change, so you can rely on your {@link #onCreateInputView} and
 * other methods being called as appropriate due to a configuration change.
 *
 * <p>When a configuration change does happen,
 * {@link #onInitializeInterface()} is guaranteed to be called the next
 * time prior to any of the other input or UI creation callbacks.  The
 * following will be called immediately depending if appropriate for current
 * state: {@link #onStartInput} if input is active, and
 * {@link #onCreateInputView} and {@link #onStartInputView} and related
 * appropriate functions if the UI is displayed.
 */
","/**
 * Take care of handling configuration changes.  Subclasses of
 * InputMethodService generally don't need to deal directly with
 * this on their own; the standard implementation here takes care of
 * regenerating the input method UI as a result of the configuration
 * change, so you can rely on your {@link #onCreateInputView} and
 * other methods being called as appropriate due to a configuration change.
 *
 * <p>When a configuration change does happen,
 * {@link #onInitializeInterface()} is guaranteed to be called the next
 * time prior to any of the other input or UI creation callbacks.  The
 * following will be called immediately depending if appropriate for current
 * state: {@link #onStartInput} if input is active, and
 * {@link #onCreateInputView} and {@link #onStartInputView} and related
 * appropriate functions if the UI is displayed.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"There are changes to the method body with a replaced set of instructions between versions. The whole implementation of the method has been changed to call a different method (resetStateForNewConfiguration()) instead of the original code block. Therefore, this is a clear example of 'Other statement changed' (code change type 4). Moreover, since the entire behavior of the method has changed, which can potentially affect the return behavior of the method (although the method is void, its execution path and state changes are different), we classify this as 'Return statement changed' (code change type 1).","The change in the implementation of the method potentially affects the behavior of the state changes and operations performed within the method. It is not returning a new value or type since it's a void method, but the method's side effects and the system's state after executing the method could be significantly different, leading to a potential 'Compatibility Issue' caused by potential different return values or types (CI type 1). The return here refers to the different execution path and state changes, which are logically treated as 'return behavior' for void methods in this context."
830,<android.content.pm.PackageInstaller.Session: String[] getNames()>,23,24,<android.content.pm.PackageInstaller.Session: String[] getNames()>,<android.content.pm.PackageInstaller.Session: String[] getNames()>,0,"{
    try {
        return mSession.getNames();
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        return mSession.getNames();
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all APK names contained in this session.
 * <p>
 * This returns all names which have been previously written through
 * {@link #openWrite(String, long, long)} as part of this session.
 *
 * @throws SecurityException if called after the session has been
 * committed or abandoned.
 */
","/**
 * Return all APK names contained in this session.
 * <p>
 * This returns all names which have been previously written through
 * {@link #openWrite(String, long, long)} as part of this session.
 *
 * @throws SecurityException if called after the session has been
 * committed or abandoned.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement for RemoteException has changed from throw e.rethrowAsRuntimeException() to throw e.rethrowFromSystemServer(), so the code change type is 2.","This change in exception handling could cause the method to throw a different exception than in the previous version, which constitutes a change in behavior. Hence, the CI type is 2."
832,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: void deactivate()>,23,24,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: void deactivate()>,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: void deactivate()>,0,"{
    mActive = false;
}","{
    if (isFinished()) {
        // reportFinish() will take effect.
        return;
    }
    closeConnection();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation introduces a new control statement (if block) to check whether the input connection is finished or not before calling closeConnection(). It also removed the direct assignment mActive = false;. Hence, the change types are 1 (due to the introduction of a return statement), 3 (introduction of a new control statement), and 4 (removal of a direct assignment).","This change could lead to different return behaviors: the early version always sets mActive to false, while in the late version, closeConnection() might not be called if isFinished() is true, hence, the method could exit early with a return statement. The condition under which the method returns has changed, potentially causing a compatibility issue due to a different return behavior (even though the method is void, the timing of the return is significant), so the CI type is 1."
833,"<android.content.pm.LauncherApps: LauncherActivityInfo resolveActivity(Intent,UserHandle)>",23,24,"<android.content.pm.LauncherApps: LauncherActivityInfo resolveActivity(Intent,UserHandle)>","<android.content.pm.LauncherApps: LauncherActivityInfo resolveActivity(Intent,UserHandle)>",0,"{
    try {
        ResolveInfo ri = mService.resolveActivity(intent, user);
        if (ri != null) {
            long firstInstallTime = 0;
            try {
                firstInstallTime = mPm.getPackageInfo(ri.activityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
            } catch (NameNotFoundException nnfe) {
            // Sorry, can't find package
            }
            LauncherActivityInfo info = new LauncherActivityInfo(mContext, ri, user, firstInstallTime);
            return info;
        }
    } catch (RemoteException re) {
        throw new RuntimeException(""Failed to call LauncherAppsService"");
    }
    return null;
}","{
    try {
        ActivityInfo ai = mService.resolveActivity(intent.getComponent(), user);
        if (ai != null) {
            LauncherActivityInfo info = new LauncherActivityInfo(mContext, ai, user);
            return info;
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    return null;
}",1,"/**
 * Returns the activity info for a given intent and user handle, if it resolves. Otherwise it
 * returns null.
 *
 * @param intent The intent to find a match for.
 * @param user The profile to look in for a match.
 * @return An activity info object if there is a match.
 */
","/**
 * Returns the activity info for a given intent and user handle, if it resolves. Otherwise it
 * returns null.
 *
 * @param intent The intent to find a match for.
 * @param user The profile to look in for a match.
 * @return An activity info object if there is a match.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","There is a change in method parameters from `mService.resolveActivity(intent, user)` to `mService.resolveActivity(intent.getComponent(), user)`, which indicates a Dependent API change (5). Additionally, the removal of the block where `firstInstallTime` is retrieved with associated try-catch for `NameNotFoundException` represents Other statement changed (4), and the creation of `LauncherActivityInfo` object is different with the absence of `firstInstallTime`, thus Return statement changed (1).","The deletion of try-catch block for `NameNotFoundException` and omission of `firstInstallTime` parameter when creating a new instance of `LauncherActivityInfo` can lead to different return values or types, indicating a Compatibility Issue category 1. Furthermore, changing the thrown exception from a generic `RuntimeException` to `rethrowFromSystemServer()` affects exception handling; thus, we have a Compatibility Issue category 2 as well."
834,<android.animation.AnimatorSet: AnimatorSet setDuration(long)>,23,24,<android.animation.AnimatorSet: AnimatorSet setDuration(long)>,<android.animation.AnimatorSet: AnimatorSet setDuration(long)>,0,"{
    if (duration < 0) {
        throw new IllegalArgumentException(""duration must be a value of zero or greater"");
    }
    // Just record the value for now - it will be used later when the AnimatorSet starts
    mDuration = duration;
    return this;
}","{
    if (duration < 0) {
        throw new IllegalArgumentException(""duration must be a value of zero or greater"");
    }
    mDependencyDirty = true;
    // Just record the value for now - it will be used later when the AnimatorSet starts
    mDuration = duration;
    return this;
}",1,"/**
 * Sets the length of each of the current child animations of this AnimatorSet. By default,
 * each child animation will use its own duration. If the duration is set on the AnimatorSet,
 * then each child animation inherits this duration.
 *
 * @param duration The length of the animation, in milliseconds, of each of the child
 * animations of this AnimatorSet.
 */
","/**
 * Sets the length of each of the current child animations of this AnimatorSet. By default,
 * each child animation will use its own duration. If the duration is set on the AnimatorSet,
 * then each child animation inherits this duration.
 *
 * @param duration The length of the animation, in milliseconds, of each of the child
 * animations of this AnimatorSet.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An additional assignment statement has been added (`mDependencyDirty = true;`), so the code change type is 4.","The additional assignment statement does not affect the return value or the exception handling of the method, the method signature has not changed, and the control flow remains identical; hence, there is no Compatibility Issue, CI type is 0."
835,<android.widget.Gallery: void onLongPress(MotionEvent)>,23,24,<android.widget.Gallery: void onLongPress(MotionEvent)>,<android.widget.Gallery: void onLongPress(MotionEvent)>,0,"{
    if (mDownTouchPosition < 0) {
        return;
    }
    performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    long id = getItemIdAtPosition(mDownTouchPosition);
    dispatchLongPress(mDownTouchView, mDownTouchPosition, id);
}","{
    if (mDownTouchPosition < 0) {
        return;
    }
    performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    final long id = getItemIdAtPosition(mDownTouchPosition);
    dispatchLongPress(mDownTouchView, mDownTouchPosition, id, e.getX(), e.getY(), true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"There's an additional method call with more parameters in the late version: `dispatchLongPress(mDownTouchView, mDownTouchPosition, id, e.getX(), e.getY(), true)`. The change in the arguments of the method `dispatchLongPress` including `e.getX()`, `e.getY()`, and `true` indicates an alteration in how the method is called, which is classified as a change in an 'Other statement' and 'Dependent API' since the signature of the 'dispatchLongPress' method that is being called has different parameters, thus the change type is 4,5.","There is no Compatibility Issue since the changes made do not alter the value or existence of the return statement, nor do they change the exception handling of the method. The method still doesn't return any value (it's a void method), and no new exceptions are thrown or old exceptions are changed, so the API's behavior, in terms of its output and exception throwing, remains the same for the given changes."
838,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,23,24,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}","{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
839,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,23,24,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,0,"{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras);
                    break;
                }
            case PREPARED:
                {
                    int streamId = msg.arg1;
                    mCallbacks.onPrepared(streamId);
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}","{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras);
                    break;
                }
            case PREPARED:
                {
                    int streamId = msg.arg1;
                    mCallbacks.onPrepared(streamId);
                    break;
                }
            case REPEATING_REQUEST_ERROR:
                {
                    long lastFrameNumber = msg.arg2 & 0xFFFFFFFFL;
                    lastFrameNumber = (lastFrameNumber << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    mCallbacks.onRepeatingRequestError(lastFrameNumber);
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"A new case 'REPEATING_REQUEST_ERROR' has been added to the switch statement with a new block of code inside it. Additionally, within the scope of that case, there are new variable assignments and a method call on 'mCallbacks'. These changes fall under the control dependency change (3) and the other statement change (4). The introduction of this case changes how messages of type 'REPEATING_REQUEST_ERROR' are handled, adding a new return point in the method where such messages are processed, which classifies as a return statement change (1).","The introduction of a new message case 'REPEATING_REQUEST_ERROR' in the switch statement means the method now has a behavior for a message type that it didn't handle before. This change can cause the API to have a different behavior than before when encountering 'REPEATING_REQUEST_ERROR' messages, which potentially leads to a different return value or action taken by the method. Thus, a Compatibility Issue exists due to the potential for different return values or types (CI type 1)."
840,<android.net.NetworkStats.Entry: boolean equals(Object)>,23,24,<android.net.NetworkStats.Entry: boolean equals(Object)>,<android.net.NetworkStats.Entry: boolean equals(Object)>,0,"{
    if (o instanceof Entry) {
        final Entry e = (Entry) o;
        return uid == e.uid && set == e.set && tag == e.tag && rxBytes == e.rxBytes && rxPackets == e.rxPackets && txBytes == e.txBytes && txPackets == e.txPackets && operations == e.operations && iface.equals(e.iface);
    }
    return false;
}","{
    if (o instanceof Entry) {
        final Entry e = (Entry) o;
        return uid == e.uid && set == e.set && tag == e.tag && roaming == e.roaming && rxBytes == e.rxBytes && rxPackets == e.rxPackets && txBytes == e.txBytes && txPackets == e.txPackets && operations == e.operations && iface.equals(e.iface);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement in the if block has changed; it includes a comparison with an additional field 'roaming == e.roaming', which was not present in the early version, so the code change type is 1.","This change in the return statement of the method 'equals' potentially causes the method to return a different result when comparing two Entry objects, particularly when the 'roaming' field differs, so the CI type is 1."
842,<android.view.View: void onDrawScrollBars(Canvas)>,23,24,<android.view.View: void onDrawScrollBars(Canvas)>,<android.view.View: void onDrawScrollBars(Canvas)>,0,"{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.mutate().setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.mutate().setAlpha(255);
        }
        final int viewFlags = mViewFlags;
        final boolean drawHorizontalScrollBar = (viewFlags & SCROLLBARS_HORIZONTAL) == SCROLLBARS_HORIZONTAL;
        final boolean drawVerticalScrollBar = (viewFlags & SCROLLBARS_VERTICAL) == SCROLLBARS_VERTICAL && !isVerticalScrollBarHidden();
        if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final int width = mRight - mLeft;
            final int height = mBottom - mTop;
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final int inside = (viewFlags & SCROLLBARS_OUTSIDE_MASK) == 0 ? ~0 : 0;
            int left;
            int top;
            int right;
            int bottom;
            if (drawHorizontalScrollBar) {
                int size = scrollBar.getSize(false);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final int verticalScrollBarGap = drawVerticalScrollBar ? getVerticalScrollbarWidth() : 0;
                top = scrollY + height - size - (mUserPaddingBottom & inside);
                left = scrollX + (mPaddingLeft & inside);
                right = scrollX + width - (mUserPaddingRight & inside) - verticalScrollBarGap;
                bottom = top + size;
                onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
            if (drawVerticalScrollBar) {
                int size = scrollBar.getSize(true);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                int verticalScrollbarPosition = mVerticalScrollbarPosition;
                if (verticalScrollbarPosition == SCROLLBAR_POSITION_DEFAULT) {
                    verticalScrollbarPosition = isLayoutRtl() ? SCROLLBAR_POSITION_LEFT : SCROLLBAR_POSITION_RIGHT;
                }
                switch(verticalScrollbarPosition) {
                    default:
                    case SCROLLBAR_POSITION_RIGHT:
                        left = scrollX + width - size - (mUserPaddingRight & inside);
                        break;
                    case SCROLLBAR_POSITION_LEFT:
                        left = scrollX + (mUserPaddingLeft & inside);
                        break;
                }
                top = scrollY + (mPaddingTop & inside);
                right = left + size;
                bottom = scrollY + height - (mUserPaddingBottom & inside);
                onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
        }
    }
}","{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.mutate().setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.mutate().setAlpha(255);
        }
        final boolean drawHorizontalScrollBar = isHorizontalScrollBarEnabled();
        final boolean drawVerticalScrollBar = isVerticalScrollBarEnabled() && !isVerticalScrollBarHidden();
        if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            if (drawHorizontalScrollBar) {
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final Rect bounds = cache.mScrollBarBounds;
                getHorizontalScrollBarBounds(bounds);
                onDrawHorizontalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
            if (drawVerticalScrollBar) {
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                final Rect bounds = cache.mScrollBarBounds;
                getVerticalScrollBarBounds(bounds);
                onDrawVerticalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
        }
    }
}",1,"/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
","/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
845,"<android.view.View: void addFocusables(ArrayList<View>,int,int)>",23,24,"<android.view.View: void addFocusables(ArrayList<View>,int,int)>","<android.view.View: void addFocusables(ArrayList<View>,int,int)>",0,"{
    if (views == null) {
        return;
    }
    if (!isFocusable()) {
        return;
    }
    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {
        return;
    }
    views.add(this);
}","{
    if (views == null) {
        return;
    }
    if (!isFocusable()) {
        return;
    }
    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && !isFocusableInTouchMode()) {
        return;
    }
    views.add(this);
}",1,"/**
 * Adds any focusable views that are descendants of this view (possibly
 * including this view if it is focusable itself) to views. This method
 * adds all focusable views regardless if we are in touch mode or
 * only views focusable in touch mode if we are in touch mode or
 * only views that can take accessibility focus if accessibility is enabled
 * depending on the focusable mode parameter.
 *
 * @param views Focusable views found so far or null if all we are interested is
 * the number of focusables.
 * @param direction The direction of the focus.
 * @param focusableMode The type of focusables to be added.
 *
 * @see #FOCUSABLES_ALL
 * @see #FOCUSABLES_TOUCH_MODE
 */
","/**
 * Adds any focusable views that are descendants of this view (possibly
 * including this view if it is focusable itself) to views. This method
 * adds all focusable views regardless if we are in touch mode or
 * only views focusable in touch mode if we are in touch mode or
 * only views that can take accessibility focus if accessibility is enabled
 * depending on the focusable mode parameter.
 *
 * @param views Focusable views found so far or null if all we are interested is
 * the number of focusables.
 * @param direction The direction of the focus.
 * @param focusableMode The type of focusables to be added.
 *
 * @see #FOCUSABLES_ALL
 * @see #FOCUSABLES_TOUCH_MODE
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The control dependency has changed because the condition checking `isInTouchMode()` has been removed from one of the 'if' statements inside the method. The change type is 3 as it's related to a control statement.,"There is no compatibility issue due to this particular change because the modified control flow condition (`isInTouchMode()`) was removed, thus potentially allowing more views to be added to the `views` ArrayList when the device is not in touch mode. However, this does not constitute a compatibility issue by the standards provided because it neither alters the type nor the value that the API returns under the conditions where it previously would succeed (i.e., when `views` is not null, the view is focusable, and the view is focusable in touch mode when required). The behavior is extended to include adding the view in non-touch mode when `FOCUSABLES_TOUCH_MODE` is set, consistent with the view being focusable. Thus, no different behavior is observed in situations where the API would have previously functioned without error."
846,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder)>",23,24,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder)>","<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder)>",0,"{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        if (mForgotten) {
            // any connection received.
            return;
        }
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            mDied = false;
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is not disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    // If there is a new service, it is now connected.
    if (service != null) {
        mConnection.onServiceConnected(name, service);
    }
}","{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        if (mForgotten) {
            // any connection received.
            return;
        }
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is not disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    // If there is a new service, it is now connected.
    if (service != null) {
        mConnection.onServiceConnected(name, service);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change between the early version and the late version of the implementation.,"As there are no differences between the two versions, no compatibility issue arises."
848,"<android.app.admin.DevicePolicyManager: int setStorageEncryption(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: int setStorageEncryption(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: int setStorageEncryption(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            return mService.setStorageEncryption(admin, encrypt);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return ENCRYPTION_STATUS_UNSUPPORTED;
}","{
    throwIfParentInstance(""setStorageEncryption"");
    if (mService != null) {
        try {
            return mService.setStorageEncryption(admin, encrypt);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return ENCRYPTION_STATUS_UNSUPPORTED;
}",1,"/**
 * Called by an application that is administering the device to
 * request that the storage system be encrypted.
 *
 * <p>When multiple device administrators attempt to control device
 * encryption, the most secure, supported setting will always be
 * used.  If any device administrator requests device encryption,
 * it will be enabled;  Conversely, if a device administrator
 * attempts to disable device encryption while another
 * device administrator has enabled it, the call to disable will
 * fail (most commonly returning {@link #ENCRYPTION_STATUS_ACTIVE}).
 *
 * <p>This policy controls encryption of the secure (application data) storage area.  Data
 * written to other storage areas may or may not be encrypted, and this policy does not require
 * or control the encryption of any other storage areas.
 * There is one exception:  If {@link android.os.Environment#isExternalStorageEmulated()} is
 * {@code true}, then the directory returned by
 * {@link android.os.Environment#getExternalStorageDirectory()} must be written to disk
 * within the encrypted storage area.
 *
 * <p>Important Note:  On some devices, it is possible to encrypt storage without requiring
 * the user to create a device PIN or Password.  In this case, the storage is encrypted, but
 * the encryption key may not be fully secured.  For maximum security, the administrator should
 * also require (and check for) a pattern, PIN, or password.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param encrypt true to request encryption, false to release any previous request
 * @return the new request status (for all active admins) - will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE}, or
 * {@link #ENCRYPTION_STATUS_ACTIVE}.  This is the value of the requests;  Use
 * {@link #getStorageEncryptionStatus()} to query the actual device state.
 */
","/**
 * Called by an application that is administering the device to request that the storage system
 * be encrypted.
 * <p>
 * When multiple device administrators attempt to control device encryption, the most secure,
 * supported setting will always be used. If any device administrator requests device
 * encryption, it will be enabled; Conversely, if a device administrator attempts to disable
 * device encryption while another device administrator has enabled it, the call to disable will
 * fail (most commonly returning {@link #ENCRYPTION_STATUS_ACTIVE}).
 * <p>
 * This policy controls encryption of the secure (application data) storage area. Data written
 * to other storage areas may or may not be encrypted, and this policy does not require or
 * control the encryption of any other storage areas. There is one exception: If
 * {@link android.os.Environment#isExternalStorageEmulated()} is {@code true}, then the
 * directory returned by {@link android.os.Environment#getExternalStorageDirectory()} must be
 * written to disk within the encrypted storage area.
 * <p>
 * Important Note: On some devices, it is possible to encrypt storage without requiring the user
 * to create a device PIN or Password. In this case, the storage is encrypted, but the
 * encryption key may not be fully secured. For maximum security, the administrator should also
 * require (and check for) a pattern, PIN, or password.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param encrypt true to request encryption, false to release any previous request
 * @return the new request status (for all active admins) - will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE}, or
 * {@link #ENCRYPTION_STATUS_ACTIVE}. This is the value of the requests; Use
 * {@link #getStorageEncryptionStatus()} to query the actual device state.
 * @throws SecurityException if {@code admin} is not an active administrator or does not use
 * {@link DeviceAdminInfo#USES_ENCRYPTED_STORAGE}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"A new method call throwIfParentInstance(""setStorageEncryption"") is introduced at the beginning of the method implementation, and an exception statement has been modified from logging an error to throwing a new exception. The changes are 2 and 4.","The newly introduced method call throwIfParentInstance(""setStorageEncryption"") may throw an exception which changes the method's exception handling behavior, resulting in a CI caused by potential different exceptions (CI type 2). Additionally, the modification in the catch block to throw an exception instead of logging it also results in an exception handling behavior change."
850,"<android.app.admin.DevicePolicyManager: void setUninstallBlocked(ComponentName,String,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setUninstallBlocked(ComponentName,String,boolean)>","<android.app.admin.DevicePolicyManager: void setUninstallBlocked(ComponentName,String,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setUninstallBlocked(admin, packageName, uninstallBlocked);
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed to call block uninstall on device policy service"");
        }
    }
}","{
    throwIfParentInstance(""setUninstallBlocked"");
    if (mService != null) {
        try {
            mService.setUninstallBlocked(admin, packageName, uninstallBlocked);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by profile or device owners to change whether a user can uninstall
 * a package.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName package to change.
 * @param uninstallBlocked true if the user shouldn't be able to uninstall the package.
 */
","/**
 * Called by profile or device owners to change whether a user can uninstall a package.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName package to change.
 * @param uninstallBlocked true if the user shouldn't be able to uninstall the package.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The method now includes a call to 'throwIfParentInstance(""setUninstallBlocked"")' which is a new control flow statement, and the exception handling statement has changed from logging the error to throwing an exception, so the code change type is 2,3,4.","The change in exception handling from logging to throwing a new exception means that callers may experience new exceptions they need to handle. Thus, the CI type is 2 due to a change in how exceptions are handled."
851,"<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>",23,24,"<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>","<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>",0,"{
    if (mTemporaryDetach) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    if (mEditor != null)
        mEditor.onFocusChanged(focused, direction);
    if (focused) {
        if (mText instanceof Spannable) {
            Spannable sp = (Spannable) mText;
            MetaKeyKeyListener.resetMetaState(sp);
        }
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}","{
    if (isTemporarilyDetached()) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    if (mEditor != null)
        mEditor.onFocusChanged(focused, direction);
    if (focused) {
        if (mText instanceof Spannable) {
            Spannable sp = (Spannable) mText;
            MetaKeyKeyListener.resetMetaState(sp);
        }
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a change in the implementation where `mTemporaryDetach` is replaced with the method call `isTemporarilyDetached()`. This is a change in the method call, not in the functionality, hence the code change type is 4.","There is no Compatibility Issue caused by potential different return values or types nor by potential different exception handlings because the change does not affect the behavioral aspect of the method. The method `isTemporarilyDetached()` is assumed to encapsulate the same check that was originally done on `mTemporaryDetach`. Thus, the behavior of `onFocusChanged` remains the same."
852,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,23,24,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.startDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.startDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 */
","/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,"3,4",0,"The lock mechanism has been introduced using mServiceLock.readLock(). The 'synchronized' block has been changed to a try-finally block with lock and unlock, which represents changes in other statements (4) and a control dependency change (3), as the synchronization method has been altered from a synchronized block to a read-write lock mechanism.","No Compatibility Issue would arise as the logic of the API has not fundamentally been changed. The locking mechanism changes do not alter the return values or exception handling of the API; it's an internal implementation change to enhance thread safety. Therefore, the behavior from the API consumer's perspective remains consistent between the two versions."
853,"<android.app.ActivityThread.ApplicationThread: void dumpDbInfo(FileDescriptor,String[])>",23,24,"<android.app.ActivityThread.ApplicationThread: void dumpDbInfo(FileDescriptor,String[])>","<android.app.ActivityThread.ApplicationThread: void dumpDbInfo(FileDescriptor,String[])>",0,"{
    if (mSystemThread) {
        // Ensure this invocation is asynchronous to prevent
        // writer waiting due to buffer cannot be consumed.
        AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {

            @Override
            public void run() {
                dumpDatabaseInfo(fd, args);
            }
        });
    } else {
        dumpDatabaseInfo(fd, args);
    }
}","{
    if (mSystemThread) {
        // Ensure this invocation is asynchronous to prevent writer waiting if buffer cannot
        // be consumed. But it must duplicate the file descriptor first, since caller might
        // be closing it.
        final ParcelFileDescriptor dup;
        try {
            dup = ParcelFileDescriptor.dup(fd);
        } catch (IOException e) {
            Log.w(TAG, ""Could not dup FD "" + fd.getInt$());
            return;
        }
        AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    dumpDatabaseInfo(dup.getFileDescriptor(), args);
                } finally {
                    IoUtils.closeQuietly(dup);
                }
            }
        });
    } else {
        dumpDatabaseInfo(fd, args);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",Several changes occurred:,"- Additionally, there's a new call to `IoUtils.closeQuietly(dup)` within a finally block, which ensures the duplicated file descriptor is closed regardless of whether `dumpDatabaseInfo` completes normally or throws an exception."
854,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",23,24,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>","<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",0,"{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = -1;
        final boolean isForcedVisibility = mForcedStartVisibility != -1 || mForcedEndVisibility != -1;
        if (!isForcedVisibility) {
            originalVisibility = viewToKeep.getVisibility();
            viewToKeep.setTransitionVisibility(View.VISIBLE);
        }
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, isForcedVisibility);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else if (!isForcedVisibility) {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}","{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = viewToKeep.getVisibility();
        viewToKeep.setTransitionVisibility(View.VISIBLE);
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, mSuppressLayout);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}",1,"/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
","/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
855,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",23,24,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>","<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",0,"{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}","{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    mRecycler.fullyDetachScrapViews();
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}",1,"/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
","/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
856,"<android.text.TextUtils: String join(CharSequence,Iterable)>",23,24,"<android.text.TextUtils: String join(CharSequence,Iterable)>","<android.text.TextUtils: String join(CharSequence,Iterable)>",0,"{
    StringBuilder sb = new StringBuilder();
    boolean firstTime = true;
    for (Object token : tokens) {
        if (firstTime) {
            firstTime = false;
        } else {
            sb.append(delimiter);
        }
        sb.append(token);
    }
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    Iterator<?> it = tokens.iterator();
    if (it.hasNext()) {
        sb.append(it.next());
        while (it.hasNext()) {
            sb.append(delimiter);
            sb.append(it.next());
        }
    }
    return sb.toString();
}",1,"/**
 * Returns a string containing the tokens joined by delimiters.
 * @param tokens an array objects to be joined. Strings will be formed from
 * the objects by calling object.toString().
 */
","/**
 * Returns a string containing the tokens joined by delimiters.
 * @param tokens an array objects to be joined. Strings will be formed from
 * the objects by calling object.toString().
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has been changed from a for-each loop to using an Iterator to loop over the elements of Iterable. There's a modification in how the iteration over the elements is performed and the decision logic to append the delimiter only when not processing the first element. This change, however, does not affect the output of the function, so it is classified as type 4 (Other statement changed).","There is no compatibility issue here as the change does not affect the produced String result from joining the elements, neither does it introduce any new exceptions or alters the return value's data type. It merely optimizes the traversal mechanism but the overall behavior remains consistent between versions. Therefore, the CI type is 0 (No Compatibility Issue)."
858,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int,Theme)>",23,24,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int,Theme)>","<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int,Theme)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadColorStateList"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    // Handle inline color definitions.
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        final android.content.res.ConstantState<ColorStateList> factory = sPreloadedColorStateLists.get(key);
        if (factory != null) {
            return factory.newInstance();
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, ""color"")) {
                sPreloadedColorStateLists.put(key, csl.getConstantState());
            }
        }
        return csl;
    }
    final ConfigurationBoundResourceCache<ColorStateList> cache = mColorStateListCache;
    csl = cache.getInstance(key, theme);
    if (csl != null) {
        return csl;
    }
    final android.content.res.ConstantState<ColorStateList> factory = sPreloadedColorStateLists.get(key);
    if (factory != null) {
        csl = factory.newInstance(this, theme);
    }
    if (csl == null) {
        csl = loadColorStateListForCookie(value, id, theme);
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, ""color"")) {
                sPreloadedColorStateLists.put(key, csl.getConstantState());
            }
        } else {
            cache.put(key, theme, csl.getConstantState());
        }
    }
    return csl;
}","{
    return mResourcesImpl.loadColorStateList(this, value, id, theme);
}",1,,,-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has been completely refactored; it now simply calls mResourcesImpl.loadColorStateList(this, value, id, theme) instead of the entire logic block provided in the early version. Hence, the code change includes a return statement change and a dependent API change, which are types 1 and 5.","Given that the implementation is now dependent on a different method, the API potentially returns a different variable (value or type) due to the refactored implementation. This results in a Compatibility Issue of type 1 due to the potential different return values or types."
859,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",23,24,"<android.view.View: boolean onKeyDown(int,KeyEvent)>","<android.view.View: boolean onKeyDown(int,KeyEvent)>",0,"{
    boolean result = false;
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        // Long clickable items don't necessarily have to be clickable
        if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
            setPressed(true);
            checkForLongClick(0);
            return true;
        }
    }
    return result;
}","{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        // Long clickable items don't necessarily have to be clickable.
        if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
            // For the purposes of menu anchoring and drawable hotspots,
            // key events are considered to be at the center of the view.
            final float x = getWidth() / 2f;
            final float y = getHeight() / 2f;
            setPressed(true, x, y);
            checkForLongClick(0, x, y);
            return true;
        }
    }
    return false;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 *
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The late version implementation replaces the 'setPressed(true)' method with 'setPressed(true, x, y)' and 'checkForLongClick(0)' with 'checkForLongClick(0, x, y)', indicating that additional information (x and y coordinates) is being passed to these methods. Apart from that there is a change in the final return value from 'result' to 'false'. Hence, these changes represent a Return statement changed and Other statement changed due to the addition of the method parameters and variable usage, indicating change types 1 and 4.","The change in the return value from 'result' to 'false' represents a potential Compatibility Issue due to the return of a different value or variable type, and the CI type is 1. Additionally, changes in the parameters of methods 'setPressed' and 'checkForLongClick' could result in different behavior, but without more context on how these methods use 'x' and 'y' coordinates internally, we can't definitively state that these parameter changes cause a compatibility issue, assuming these methods have overloaded versions to handle the additional parameters without altering behavior."
860,<android.app.ContextImpl: DisplayAdjustments getDisplayAdjustments(int)>,23,24,<android.app.ContextImpl: DisplayAdjustments getDisplayAdjustments(int)>,<android.app.ContextImpl: DisplayAdjustments getDisplayAdjustments(int)>,0,"{
    return mDisplayAdjustments;
}","{
    return mResources.getDisplayAdjustments();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from directly returning the member variable mDisplayAdjustments to returning the result of mResources.getDisplayAdjustments() method call. This involves not only a change in the return statement but also a dependency on another method which may have different behavior. Therefore, the code change types are 1 and 5.","The method is now returning a potentially different value obtained from the resource object instead of the member variable. This could cause the API to return a different result depending on the implementation of getDisplayAdjustments() in the mResources object. Thus, the CI type is 1."
862,<android.bluetooth.le.ScanFilter: int hashCode()>,23,24,<android.bluetooth.le.ScanFilter: int hashCode()>,<android.bluetooth.le.ScanFilter: int hashCode()>,0,"{
    return Objects.hash(mDeviceName, mDeviceAddress, mManufacturerId, mManufacturerData, mManufacturerDataMask, mServiceDataUuid, mServiceData, mServiceDataMask, mServiceUuid, mServiceUuidMask);
}","{
    return Objects.hash(mDeviceName, mDeviceAddress, mManufacturerId, Arrays.hashCode(mManufacturerData), Arrays.hashCode(mManufacturerDataMask), mServiceDataUuid, Arrays.hashCode(mServiceData), Arrays.hashCode(mServiceDataMask), mServiceUuid, mServiceUuidMask);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change involves how the arrays inside the hashCode computation are handled. Specifically, Arrays.hashCode() is used on arrays in the late version, whereas in the early version, arrays were directly passed to Objects.hash(). This change is to properly calculate the hash codes of arrays, but it does not alter the API's functional behavior, therefore this is categorized as 4 (Other statement changed).","There is no compatibility issue because although the implementation has changed for proper array hashCode calculation, it does not affect the API's contract or behavior from a user perspective. Clients that depend on the hashCode method of ScanFilter will receive a hashCode that is consistent with the equals method, which is the expected behavior for hashCode. Therefore, the same output is expected for equivalent values of ScanFilter objects between the two versions. The change does not lead to a CI, so the CI type is 0."
864,"<android.content.pm.PackageInstaller.Session: OutputStream openWrite(String,long,long)>",23,24,"<android.content.pm.PackageInstaller.Session: OutputStream openWrite(String,long,long)>","<android.content.pm.PackageInstaller.Session: OutputStream openWrite(String,long,long)>",0,"{
    try {
        final ParcelFileDescriptor clientSocket = mSession.openWrite(name, offsetBytes, lengthBytes);
        return new FileBridge.FileBridgeOutputStream(clientSocket);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        final ParcelFileDescriptor clientSocket = mSession.openWrite(name, offsetBytes, lengthBytes);
        return new FileBridge.FileBridgeOutputStream(clientSocket);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Open a stream to write an APK file into the session.
 * <p>
 * The returned stream will start writing data at the requested offset
 * in the underlying file, which can be used to resume a partially
 * written file. If a valid file length is specified, the system will
 * preallocate the underlying disk space to optimize placement on disk.
 * It's strongly recommended to provide a valid file length when known.
 * <p>
 * You can write data into the returned stream, optionally call
 * {@link #fsync(OutputStream)} as needed to ensure bytes have been
 * persisted to disk, and then close when finished. All streams must be
 * closed before calling {@link #commit(IntentSender)}.
 *
 * @param name arbitrary, unique name of your choosing to identify the
 * APK being written. You can open a file again for
 * additional writes (such as after a reboot) by using the
 * same name. This name is only meaningful within the context
 * of a single install session.
 * @param offsetBytes offset into the file to begin writing at, or 0 to
 * start at the beginning of the file.
 * @param lengthBytes total size of the file being written, used to
 * preallocate the underlying disk space, or -1 if unknown.
 * The system may clear various caches as needed to allocate
 * this space.
 * @throws IOException if trouble opening the file for writing, such as
 * lack of disk space or unavailable media.
 * @throws SecurityException if called after the session has been
 * committed or abandoned.
 */
","/**
 * Open a stream to write an APK file into the session.
 * <p>
 * The returned stream will start writing data at the requested offset
 * in the underlying file, which can be used to resume a partially
 * written file. If a valid file length is specified, the system will
 * preallocate the underlying disk space to optimize placement on disk.
 * It's strongly recommended to provide a valid file length when known.
 * <p>
 * You can write data into the returned stream, optionally call
 * {@link #fsync(OutputStream)} as needed to ensure bytes have been
 * persisted to disk, and then close when finished. All streams must be
 * closed before calling {@link #commit(IntentSender)}.
 *
 * @param name arbitrary, unique name of your choosing to identify the
 * APK being written. You can open a file again for
 * additional writes (such as after a reboot) by using the
 * same name. This name is only meaningful within the context
 * of a single install session.
 * @param offsetBytes offset into the file to begin writing at, or 0 to
 * start at the beginning of the file.
 * @param lengthBytes total size of the file being written, used to
 * preallocate the underlying disk space, or -1 if unknown.
 * The system may clear various caches as needed to allocate
 * this space.
 * @throws IOException if trouble opening the file for writing, such as
 * lack of disk space or unavailable media.
 * @throws SecurityException if called after the session has been
 * committed or abandoned.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The only change lies in the exception handling for RemoteException. In the early version, the exception is re-thrown as a RuntimeException using the method rethrowAsRuntimeException(), while in the late version, it's re-thrown using the method rethrowFromSystemServer(), so the change type is 2.","The change in exception handling could potentially lead to a different exception being thrown when the API encounters a RemoteException. Because RemoteException is caught and then re-thrown in a different manner (rethrowFromSystemServer instead of rethrowAsRuntimeException), the behavior of the API has changed with respect to exception handling; therefore, the CI type is 2."
865,<android.appwidget.AppWidgetManager: int[] getAppWidgetIds(ComponentName)>,23,24,<android.appwidget.AppWidgetManager: int[] getAppWidgetIds(ComponentName)>,<android.appwidget.AppWidgetManager: int[] getAppWidgetIds(ComponentName)>,0,"{
    if (mService == null) {
        return new int[0];
    }
    try {
        return mService.getAppWidgetIds(provider);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return new int[0];
    }
    try {
        return mService.getAppWidgetIds(provider);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */
","/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"There is a change in the exception handling statement, replacing the generic RuntimeException with the more specific rethrowFromSystemServer method invocation on the RemoteException object, so the code change type is 2.","As the exception handling behavior has changed, where previously a generic RuntimeException was thrown and now a specific system server exception will be rethrown, this change could lead to different exception handling semantics when the API is called. Thus the CI type is 2."
866,"<android.content.pm.PackageInstaller: void updateSessionAppIcon(int,Bitmap)>",23,24,"<android.content.pm.PackageInstaller: void updateSessionAppIcon(int,Bitmap)>","<android.content.pm.PackageInstaller: void updateSessionAppIcon(int,Bitmap)>",0,"{
    try {
        mInstaller.updateSessionAppIcon(sessionId, appIcon);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        mInstaller.updateSessionAppIcon(sessionId, appIcon);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Update the icon representing the app being installed in a specific
 * session. This should be roughly
 * {@link ActivityManager#getLauncherLargeIconSize()} in both dimensions.
 *
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
","/**
 * Update the icon representing the app being installed in a specific
 * session. This should be roughly
 * {@link ActivityManager#getLauncherLargeIconSize()} in both dimensions.
 *
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The catch block has been modified to throw a different type of exception, changing from rethrowAsRuntimeException() to rethrowFromSystemServer(). Therefore, the code change type is 2.","The change in the exception handling code will cause the method to throw a different type of exception under certain circumstances. This constitutes a Compatibility Issue of type 2, caused by potential different exception handlings."
867,<android.app.Fragment: void performDestroy()>,23,24,<android.app.Fragment: void performDestroy()>,<android.app.Fragment: void performDestroy()>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroy();
    }
    mCalled = false;
    onDestroy();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDestroy()"");
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroy();
    }
    mState = INITIALIZING;
    mCalled = false;
    onDestroy();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDestroy()"");
    }
    mChildFragmentManager = null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There are two new statements in the late implementation. The assignment of mState = INITIALIZING and mChildFragmentManager = null are added. That falls under the category of 'Other statement changed', so the code change type is 4.","The addition of these statements does not lead to a difference in the return value or the exceptions thrown by this method, because the performDestroy() method has void return type and new statements are not related to changing exception handling nor control flow that affects existing return or exception points. Therefore, it seems there is no Compatibility Issue, indicated by 0."
868,<android.content.pm.PackageInstaller.Session: void commit(IntentSender)>,23,24,<android.content.pm.PackageInstaller.Session: void commit(IntentSender)>,<android.content.pm.PackageInstaller.Session: void commit(IntentSender)>,0,"{
    try {
        mSession.commit(statusReceiver);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        mSession.commit(statusReceiver);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Attempt to commit everything staged in this session. This may require
 * user intervention, and so it may not happen immediately. The final
 * result of the commit will be reported through the given callback.
 * <p>
 * Once this method is called, no additional mutations may be performed
 * on the session. If the device reboots before the session has been
 * finalized, you may commit the session again.
 *
 * @throws SecurityException if streams opened through
 * {@link #openWrite(String, long, long)} are still open.
 */
","/**
 * Attempt to commit everything staged in this session. This may require
 * user intervention, and so it may not happen immediately. The final
 * result of the commit will be reported through the given callback.
 * <p>
 * Once this method is called, no additional mutations may be performed
 * on the session. If the device reboots before the session has been
 * finalized, you may commit the session again.
 *
 * @throws SecurityException if streams opened through
 * {@link #openWrite(String, long, long)} are still open.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling has changed from rethrowAsRuntimeException() to rethrowFromSystemServer(). Therefore, the code change type is 2.","The change in exception handling means that a different type of exception might be thrown, so the CI type is 2."
869,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,23,24,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,0,"{
    return mResolveInfo.loadLabel(mPm);
}","{
    return mActivityInfo.loadLabel(mPm);
}",1,"/**
 * Retrieves the label for the activity.
 *
 * @return The label for the activity.
 */
","/**
 * Retrieves the label for the activity.
 *
 * @return The label for the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The object from which the method loadLabel() is called has changed from mResolveInfo to mActivityInfo, which indicates a change in the dependent object but not the method signature or parameters. Since the loadLabel() method is being called on a different object, the change type is 4 for Other statement changed and 5 for Dependent API changed.","Since the method loadLabel() is being called on a different object, the value returned by getLabel() could potentially be different if mActivityInfo and mResolveInfo represent different data. Hence, the CI type is 1 for potential different return values."
870,<android.content.ContentProviderClient: boolean release()>,23,24,<android.content.ContentProviderClient: boolean release()>,<android.content.ContentProviderClient: boolean release()>,0,"{
    synchronized (this) {
        if (mReleased) {
            throw new IllegalStateException(""Already released"");
        }
        mReleased = true;
        mGuard.close();
        if (mStable) {
            return mContentResolver.releaseProvider(mContentProvider);
        } else {
            return mContentResolver.releaseUnstableProvider(mContentProvider);
        }
    }
}","{
    return closeInternal();
}",1,"/**
 * Call this to indicate to the system that the associated {@link ContentProvider} is no
 * longer needed by this {@link ContentProviderClient}.
 * @return true if this was release, false if it was already released
 */
","/**
 * @deprecated replaced by {@link #close()}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has significantly changed to call a new method `closeInternal()` instead of the previous code block. This is an indication that internal restructuring might have happened, and the behavior might be encapsulated inside `closeInternal()`. The change type is 4 due to the method invocation change and 5 because `closeInternal()` is a dependent API whose behavior is not visible here and has potentially changed.","No direct evidence of change in return value or exception handling is found, as the `closeInternal()` method is assumed to take over the responsibilities of the old code, including exception handling and return values. However, since we do not know the implementation of `closeInternal()`, we cannot conclude if the outcome of calling `release()` would be different. Assuming `closeInternal()` is correctly implemented to mimic the old behavior, there should be no compatibility issue, so the CI type is 0."
872,"<android.app.admin.DevicePolicyManager: boolean setStatusBarDisabled(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: boolean setStatusBarDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: boolean setStatusBarDisabled(ComponentName,boolean)>",0,"{
    try {
        return mService.setStatusBarDisabled(admin, disabled);
    } catch (RemoteException re) {
        Log.w(TAG, ""Failed talking with device policy service"", re);
        return false;
    }
}","{
    throwIfParentInstance(""setStatusBarDisabled"");
    try {
        return mService.setStatusBarDisabled(admin, disabled);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by device owner to disable the status bar. Disabling the status bar blocks
 * notifications, quick settings and other screen overlays that allow escaping from
 * a single use device.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled {@code true} disables the status bar, {@code false} reenables it.
 *
 * @return {@code false} if attempting to disable the status bar failed.
 * {@code true} otherwise.
 */
","/**
 * Called by device owner to disable the status bar. Disabling the status bar blocks
 * notifications, quick settings and other screen overlays that allow escaping from a single use
 * device.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled {@code true} disables the status bar, {@code false} reenables it.
 * @return {@code false} if attempting to disable the status bar failed. {@code true} otherwise.
 * @throws SecurityException if {@code admin} is not a device owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","The early version contains a catch block that logs the exception and returns false, whereas the late version includes a new statement before the try block (throwIfParentInstance(""setStatusBarDisabled"")), and the catch block is modified to throw the exception instead of logging it and returning false. This results in changes to other statements (new method call), exception handling statements, and return statements.","The added call to throwIfParentInstance before the try block could throw a new exception not present in the earlier version, causing a different exception handling behavior, this indicates a CI of type 2. Additionally, the change in the catch block from logging and returning false to throwing an exception means the method will not suppress the exception and return false anymore but will propagate the exception instead. It alters both the method's normal execution flow and its exceptional flow, hence it is a CI of type 1, 2."
875,"<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>",23,24,"<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>","<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>",0,"{
    try {
        return ActivityManagerNative.getDefault().checkUriPermission(ContentProvider.getUriWithoutUserId(uri), pid, uid, modeFlags, resolveUserId(uri), null);
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().checkUriPermission(ContentProvider.getUriWithoutUserId(uri), pid, uid, modeFlags, resolveUserId(uri), null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. Previously the catch block returned PackageManager.PERMISSION_DENIED, but in the late version, it throws a new exception with throw e.rethrowFromSystemServer(). This is why the code change type is 2.","With the change in the exception handling behavior, where earlier a constant was returned and now an exception is thrown, clients depending on the previous behavior would experience a different behavior leading potentially to an unhandled exception. Therefore, the CI type is 2."
876,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",23,24,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the method called on the `intent` object; it now passes `this` as an argument to `prepareToLeaveProcess()`. The change is related to a dependent API. However, this change does not affect the control flow or the exception handling apart from what is being passed inside a method. The intent object's method `prepareToLeaveProcess` now takes a `Context` as a parameter; this change can be classified as a dependent API change.","The change in the API does not constitute a compatibility issue because the method `sendStickyBroadcastAsUser` is not returning a different value or throwing a new/changed exception. The change within `intent.prepareToLeaveProcess(this)` does not impact the value returned from `sendStickyBroadcastAsUser()` (which is `void`), nor does it change the exceptions that `sendStickyBroadcastAsUser()` is documented or expected to throw. The calling context is being passed inside `intent.prepareToLeaveProcess`, which may alter the behavior within the `Intent`, but the `Intent` implementation is encapsulated and does not impact the behavior of this API directly from a caller's perspective."
877,"<android.app.admin.DevicePolicyManager: void enableSystemApp(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: void enableSystemApp(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void enableSystemApp(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            mService.enableSystemApp(admin, packageName);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed to install package: "" + packageName);
        }
    }
}","{
    throwIfParentInstance(""enableSystemApp"");
    if (mService != null) {
        try {
            mService.enableSystemApp(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by profile or device owners to re-enable a system app that was disabled by default
 * when the user was initialized.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The package to be re-enabled in the current profile.
 */
","/**
 * Called by profile or device owners to re-enable a system app that was disabled by default
 * when the user was initialized.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The package to be re-enabled in the calling profile.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"There's a new method call ""throwIfParentInstance"" before the existing control statement, and an exception handling statement has changed from catching and logging the exception to rethrowing it, so the types of code change are 2,3.","The introduction of ""throwIfParentInstance"" could throw an exception where previously none was thrown. Furthermore, the 'catch' block behavior has been modified to now rethrow a RemoteException, which means that the exception handling has changed. The latter change can lead to a different exception being thrown than in the previous API version. Therefore, the CI type is 2."
878,<android.app.Notification.Builder: Builder setPriority(int)>,23,24,<android.app.Notification.Builder: Builder setPriority(int)>,<android.app.Notification.Builder: Builder setPriority(int)>,0,"{
    mPriority = pri;
    return this;
}","{
    mN.priority = pri;
    return this;
}",1,"/**
 * Set the priority of this notification.
 *
 * @see Notification#priority
 */
","/**
 * Set the priority of this notification.
 *
 * @see Notification#priority
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is related to the assignment of the priority value to a different variable within the same object (from `mPriority` to `mN.priority`), which is categorized as another statement change. Hence, the change type is 4.","There's no compatibility issue detected as the method signature remains the same, and the change in the internal assignment does not affect the return value or the behavior seen by the API consumer. Thus, CI type is 0."
879,<android.app.admin.DevicePolicyManager: int getPasswordMinimumUpperCase(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPasswordMinimumUpperCase(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumUpperCase(ComponentName)>,0,"{
    return getPasswordMinimumUpperCase(admin, UserHandle.myUserId());
}","{
    return getPasswordMinimumUpperCase(admin, myUserId());
}",1,"/**
 * Retrieve the current number of upper case letters required in the
 * password for all admins of this user and its profiles or a particular one.
 * This is the same value as set by
 * {#link {@link #setPasswordMinimumUpperCase(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of upper case letters required in the
 * password.
 */
","/**
 * Retrieve the current number of upper case letters required in the password
 * for a particular admin or all admins that set retrictions on this user and
 * its participating profiles. Restrictions on profiles that have a separate challenge
 * are not taken into account.
 * This is the same value as set by
 * {@link #setPasswordMinimumUpperCase(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of upper case letters required in the
 * password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is simply the removal of 'UserHandle.' from the method call 'myUserId()'. The method seems to be the same, only called differently, indicating that the dependent API has experienced a change. Therefore, the change type is 5.","There is no indication that the change in how the `myUserId` method is called would lead to a compatibility issue, assuming the method itself has not changed its behavior. Therefore, there is no CI caused by this change. The CI type is 0."
881,<android.text.BidiFormatter.Builder: BidiFormatter build()>,23,24,<android.text.BidiFormatter.Builder: BidiFormatter build()>,<android.text.BidiFormatter.Builder: BidiFormatter build()>,0,"{
    if (mFlags == DEFAULT_FLAGS && mTextDirectionHeuristic == DEFAULT_TEXT_DIRECTION_HEURISTIC) {
        return getDefaultInstanceFromContext(mIsRtlContext);
    }
    return new BidiFormatter(mIsRtlContext, mFlags, mTextDirectionHeuristic);
}","{
    if (mFlags == DEFAULT_FLAGS && mTextDirectionHeuristic == DEFAULT_TEXT_DIRECTION_HEURISTIC) {
        return BidiFormatter.getDefaultInstanceFromContext(mIsRtlContext);
    }
    return new BidiFormatter(mIsRtlContext, mFlags, mTextDirectionHeuristic);
}",1,"/**
 * @return A BidiFormatter with the specified options.
 */
","/**
 * @return A BidiFormatter with the specified options.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the logic or behavior of the method between the two versions; the method `getDefaultInstanceFromContext` is just called with the class name `BidiFormatter`, but it indicates the same method is being called as in the early version. Since this does not alter the behavior or output of the method, there's no compatible issue or code change.","The change does not affect the behavior of the API, hence there are no compatibility issues."
882,<android.app.ActivityManager.AppTask: void moveToFront()>,23,24,<android.app.ActivityManager.AppTask: void moveToFront()>,<android.app.ActivityManager.AppTask: void moveToFront()>,0,"{
    try {
        mAppTaskImpl.moveToFront();
    } catch (RemoteException e) {
        Slog.e(TAG, ""Invalid AppTask"", e);
    }
}","{
    try {
        mAppTaskImpl.moveToFront();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Bring this task to the foreground.  If it contains activities, they will be
 * brought to the foreground with it and their instances re-created if needed.
 * If it doesn't contain activities, the root activity of the task will be
 * re-launched.
 */
","/**
 * Bring this task to the foreground.  If it contains activities, they will be
 * brought to the foreground with it and their instances re-created if needed.
 * If it doesn't contain activities, the root activity of the task will be
 * re-launched.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"Exception handling statement has changed from logging the exception to rethrowing it, so the change type is 2.","The early version catches the RemoteException and logs it, while the late version rethrows the exception, potentially causing the caller to have to handle this exception. This is a change in exception handling, so the CI type is 2."
883,<android.print.PrintJob: int hashCode()>,23,24,<android.print.PrintJob: int hashCode()>,<android.print.PrintJob: int hashCode()>,0,"{
    return mCachedInfo.getId().hashCode();
}","{
    PrintJobId printJobId = mCachedInfo.getId();
    if (printJobId == null) {
        return 0;
    } else {
        return printJobId.hashCode();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The method's implementation has a new control dependency (""if"" condition) and the return statements have been modified to include a new null-check condition, so the change type is 1,3.","The new null-check condition changes the behavior of the hashCode method as it will now return 0 instead of potentially throwing a NullPointerException if mCachedInfo.getId() is null in the late version. This leads to a different return value when mCachedInfo.getId() is null, so the CI type is 1."
884,"<android.provider.DocumentsContract: boolean isDocumentUri(Context,Uri)>",23,24,"<android.provider.DocumentsContract: boolean isDocumentUri(Context,Uri)>","<android.provider.DocumentsContract: boolean isDocumentUri(Context,Uri)>",0,"{
    final List<String> paths = uri.getPathSegments();
    if (paths.size() == 2 && PATH_DOCUMENT.equals(paths.get(0))) {
        return isDocumentsProvider(context, uri.getAuthority());
    }
    if (paths.size() == 4 && PATH_TREE.equals(paths.get(0)) && PATH_DOCUMENT.equals(paths.get(2))) {
        return isDocumentsProvider(context, uri.getAuthority());
    }
    return false;
}","{
    if (isContentUri(uri) && isDocumentsProvider(context, uri.getAuthority())) {
        final List<String> paths = uri.getPathSegments();
        if (paths.size() == 2) {
            return PATH_DOCUMENT.equals(paths.get(0));
        } else if (paths.size() == 4) {
            return PATH_TREE.equals(paths.get(0)) && PATH_DOCUMENT.equals(paths.get(2));
        }
    }
    return false;
}",1,"/**
 * Test if the given URI represents a {@link Document} backed by a
 * {@link DocumentsProvider}.
 *
 * @see #buildDocumentUri(String, String)
 * @see #buildDocumentUriUsingTree(Uri, String)
 */
","/**
 * Test if the given URI represents a {@link Document} backed by a
 * {@link DocumentsProvider}.
 *
 * @see #buildDocumentUri(String, String)
 * @see #buildDocumentUriUsingTree(Uri, String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The structure of the control flow has changed: early version has two separate if-statements and the late version has nested if-statements. Additionally, there are new conditions introduced such as `isContentUri(uri)` that changes how the return value is determined, so the code change type is 1,3.","The function now includes an additional check (`isContentUri(uri)`) before evaluating the paths, and the logic inside the if-statements has been restructured. This could lead the API to potentially return different results for the same input, hence the CI type is 1."
885,"<android.app.admin.DevicePolicyManager: boolean setPermittedInputMethods(ComponentName,List<String>)>",23,24,"<android.app.admin.DevicePolicyManager: boolean setPermittedInputMethods(ComponentName,List<String>)>","<android.app.admin.DevicePolicyManager: boolean setPermittedInputMethods(ComponentName,List<String>)>",0,"{
    if (mService != null) {
        try {
            return mService.setPermittedInputMethods(admin, packageNames);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""setPermittedInputMethods"");
    if (mService != null) {
        try {
            return mService.setPermittedInputMethods(admin, packageNames);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by a profile or device owner to set the permitted input methods services. When
 * set by a device owner or profile owner the restriction applies to all profiles of the
 * user the device owner or profile owner is an admin for.
 *
 * By default the user can use any input method. When zero or more packages have
 * been added, input method that are not in the list and not part of the system
 * can not be enabled by the user.
 *
 * This method will fail if it is called for a admin that is not for the foreground user
 * or a profile of the foreground user.
 *
 * <p> Calling with a null value for the list disables the restriction so that all input methods
 * can be used, calling with an empty list disables all but the system's own input methods.
 *
 * <p> System input methods are always available to the user this method can't modify this.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageNames List of input method package names.
 * @return true if setting the restriction succeeded. It will fail if there are
 * one or more non-system input methods currently enabled that are not in
 * the packageNames list.
 */
","/**
 * Called by a profile or device owner to set the permitted input methods services. When set by
 * a device owner or profile owner the restriction applies to all profiles of the user the
 * device owner or profile owner is an admin for. By default the user can use any input method.
 * When zero or more packages have been added, input method that are not in the list and not
 * part of the system can not be enabled by the user. This method will fail if it is called for
 * a admin that is not for the foreground user or a profile of the foreground user.
 * <p>
 * Calling with a null value for the list disables the restriction so that all input methods can
 * be used, calling with an empty list disables all but the system's own input methods.
 * <p>
 * System input methods are always available to the user this method can't modify this.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageNames List of input method package names.
 * @return true if setting the restriction succeeded. It will fail if there are one or more
 * non-system input methods currently enabled that are not in the packageNames list.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement changed, where the earlier version logged the exception and the late version throws it, and a new method call throwIfParentInstance(""setPermittedInputMethods"") is introduced before the existing code, therefore the changes are of type 2 and 4.","The new exception handling behavior where RemoteException is now being thrown can cause a Compatibility Issue due to the potential different exception handlings between the early and late versions, so the CI type is 2."
886,<android.os.UserManager: Bundle getApplicationRestrictions(String)>,23,24,<android.os.UserManager: Bundle getApplicationRestrictions(String)>,<android.os.UserManager: Bundle getApplicationRestrictions(String)>,0,"{
    try {
        return mService.getApplicationRestrictions(packageName);
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not get application restrictions for package "" + packageName);
    }
    return null;
}","{
    try {
        return mService.getApplicationRestrictions(packageName);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a Bundle containing any saved application restrictions for this user, for the
 * given package name. Only an application with this package name can call this method.
 * @param packageName the package name of the calling application
 * @return a Bundle with the restrictions as key/value pairs, or null if there are no
 * saved restrictions. The values can be of type Boolean, String or String[], depending
 * on the restriction type, as defined by the application.
 */
","/**
 * Returns a {@link Bundle} containing any saved application restrictions for this user, for the
 * given package name. Only an application with this package name can call this method.
 *
 * <p>The returned {@link Bundle} consists of key-value pairs, as defined by the application,
 * where the types of values may be:
 * <ul>
 * <li>{@code boolean}
 * <li>{@code int}
 * <li>{@code String} or {@code String[]}
 * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}
 * </ul>
 *
 * @param packageName the package name of the calling application
 * @return a {@link Bundle} with the restrictions for that package, or an empty {@link Bundle}
 * if there are no saved restrictions.
 *
 * @see #KEY_RESTRICTIONS_PENDING
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement changed; the catch block in the early version logs the RemoteException and returns null, while in the late version it rethrows the exception, so the code change type is 2.","The change in exception handling could potentially lead to a different behavior when an exception occurs; instead of returning null in the case of a RemoteException, the late version of the API will now throw an exception. This could lead to a Compatibility Issue as callers of this method need to handle a potentially thrown exception instead of just checking for null results. The CI type is 2."
887,"<android.app.admin.DevicePolicyManager: void setSecureSetting(ComponentName,String,String)>",23,24,"<android.app.admin.DevicePolicyManager: void setSecureSetting(ComponentName,String,String)>","<android.app.admin.DevicePolicyManager: void setSecureSetting(ComponentName,String,String)>",0,"{
    if (mService != null) {
        try {
            mService.setSecureSetting(admin, setting, value);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setSecureSetting"");
    if (mService != null) {
        try {
            mService.setSecureSetting(admin, setting, value);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by profile or device owners to update {@link Settings.Secure} settings. Validation
 * that the value of the setting is in the correct form for the setting type should be performed
 * by the caller.
 * <p>The settings that can be updated by a profile or device owner with this method are:
 * <ul>
 * <li>{@link Settings.Secure#DEFAULT_INPUT_METHOD}</li>
 * <li>{@link Settings.Secure#INSTALL_NON_MARKET_APPS}</li>
 * <li>{@link Settings.Secure#SKIP_FIRST_USE_HINTS}</li>
 * </ul>
 * <p>A device owner can additionally update the following settings:
 * <ul>
 * <li>{@link Settings.Secure#LOCATION_MODE}</li>
 * </ul>
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param setting The name of the setting to update.
 * @param value The value to update the setting to.
 */
","/**
 * Called by profile or device owners to update {@link Settings.Secure} settings. Validation
 * that the value of the setting is in the correct form for the setting type should be performed
 * by the caller.
 * <p>
 * The settings that can be updated by a profile or device owner with this method are:
 * <ul>
 * <li>{@link Settings.Secure#DEFAULT_INPUT_METHOD}</li>
 * <li>{@link Settings.Secure#INSTALL_NON_MARKET_APPS}</li>
 * <li>{@link Settings.Secure#SKIP_FIRST_USE_HINTS}</li>
 * </ul>
 * <p>
 * A device owner can additionally update the following settings:
 * <ul>
 * <li>{@link Settings.Secure#LOCATION_MODE}</li>
 * </ul>
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param setting The name of the setting to update.
 * @param value The value to update the setting to.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"An additional method call 'throwIfParentInstance(""setSecureSetting"")' is invoked before the existing implementation, an existing exception log has been replaced with a new 'throw' statement, and there is no new control statement added, so the change types are 2,3,4.","The addition of 'throwIfParentInstance(""setSecureSetting"")' may lead to a new exception before the rest of the method executes, which could lead to a Compatibility Issue. Furthermore, the modification within the 'catch' block to throw the exception rethrows a previously caught exception, which is also a change in exception handling behavior. Therefore, the CI type is 2."
888,"<android.widget.ImageView: boolean setFrame(int,int,int,int)>",23,24,"<android.widget.ImageView: boolean setFrame(int,int,int,int)>","<android.widget.ImageView: boolean setFrame(int,int,int,int)>",0,"{
    boolean changed = super.setFrame(l, t, r, b);
    mHaveFrame = true;
    configureBounds();
    return changed;
}","{
    final boolean changed = super.setFrame(l, t, r, b);
    mHaveFrame = true;
    configureBounds();
    return changed;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"The only change is the addition of the 'final' modifier to the local variable 'changed', which doesn't affect the behavior of the method. All other parts of the method remain the same.",There is no Compatibility Issue because the 'final' modifier on a local variable doesn't change how the method behaves externally. The return value and side-effects remain consistent.
889,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,23,24,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,0,"{
    getAccountsByTypeAndFeatures(mAccountType, mFeatures, new AccountManagerCallback<Account[]>() {

        public void run(AccountManagerFuture<Account[]> future) {
            Account[] accounts;
            try {
                accounts = future.getResult();
            } catch (OperationCanceledException e) {
                setException(e);
                return;
            } catch (IOException e) {
                setException(e);
                return;
            } catch (AuthenticatorException e) {
                setException(e);
                return;
            }
            mNumAccounts = accounts.length;
            if (accounts.length == 0) {
                if (mActivity != null) {
                    // no accounts, add one now. pretend that the user directly
                    // made this request
                    mFuture = addAccount(mAccountType, mAuthTokenType, mFeatures, mAddAccountOptions, mActivity, mMyCallback, mHandler);
                } else {
                    // send result since we can't prompt to add an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNT_NAME, null);
                    result.putString(KEY_ACCOUNT_TYPE, null);
                    result.putString(KEY_AUTHTOKEN, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            } else if (accounts.length == 1) {
                // have a single account, return an authtoken for it
                if (mActivity == null) {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, false, /* notifyAuthFailure */
                    mMyCallback, mHandler);
                } else {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                }
            } else {
                if (mActivity != null) {
                    IAccountManagerResponse chooseResponse = new IAccountManagerResponse.Stub() {

                        public void onResult(Bundle value) throws RemoteException {
                            Account account = new Account(value.getString(KEY_ACCOUNT_NAME), value.getString(KEY_ACCOUNT_TYPE));
                            mFuture = getAuthToken(account, mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                        }

                        public void onError(int errorCode, String errorMessage) throws RemoteException {
                            mResponse.onError(errorCode, errorMessage);
                        }
                    };
                    // have many accounts, launch the chooser
                    Intent intent = new Intent();
                    ComponentName componentName = ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseAccountActivity));
                    intent.setClassName(componentName.getPackageName(), componentName.getClassName());
                    intent.putExtra(KEY_ACCOUNTS, accounts);
                    intent.putExtra(KEY_ACCOUNT_MANAGER_RESPONSE, new AccountManagerResponse(chooseResponse));
                    mActivity.startActivity(intent);
                // the result will arrive via the IAccountManagerResponse
                } else {
                    // send result since we can't prompt to select an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNTS, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            }
        }
    }, mHandler);
}","{
    getAccountsByTypeAndFeatures(mAccountType, mFeatures, new AccountManagerCallback<Account[]>() {

        @Override
        public void run(AccountManagerFuture<Account[]> future) {
            Account[] accounts;
            try {
                accounts = future.getResult();
            } catch (OperationCanceledException e) {
                setException(e);
                return;
            } catch (IOException e) {
                setException(e);
                return;
            } catch (AuthenticatorException e) {
                setException(e);
                return;
            }
            mNumAccounts = accounts.length;
            if (accounts.length == 0) {
                if (mActivity != null) {
                    // no accounts, add one now. pretend that the user directly
                    // made this request
                    mFuture = addAccount(mAccountType, mAuthTokenType, mFeatures, mAddAccountOptions, mActivity, mMyCallback, mHandler);
                } else {
                    // send result since we can't prompt to add an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNT_NAME, null);
                    result.putString(KEY_ACCOUNT_TYPE, null);
                    result.putString(KEY_AUTHTOKEN, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            } else if (accounts.length == 1) {
                // have a single account, return an authtoken for it
                if (mActivity == null) {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, false, /* notifyAuthFailure */
                    mMyCallback, mHandler);
                } else {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                }
            } else {
                if (mActivity != null) {
                    IAccountManagerResponse chooseResponse = new IAccountManagerResponse.Stub() {

                        @Override
                        public void onResult(Bundle value) throws RemoteException {
                            Account account = new Account(value.getString(KEY_ACCOUNT_NAME), value.getString(KEY_ACCOUNT_TYPE));
                            mFuture = getAuthToken(account, mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                        }

                        @Override
                        public void onError(int errorCode, String errorMessage) throws RemoteException {
                            mResponse.onError(errorCode, errorMessage);
                        }
                    };
                    // have many accounts, launch the chooser
                    Intent intent = new Intent();
                    ComponentName componentName = ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseAccountActivity));
                    intent.setClassName(componentName.getPackageName(), componentName.getClassName());
                    intent.putExtra(KEY_ACCOUNTS, accounts);
                    intent.putExtra(KEY_ACCOUNT_MANAGER_RESPONSE, new AccountManagerResponse(chooseResponse));
                    mActivity.startActivity(intent);
                // the result will arrive via the IAccountManagerResponse
                } else {
                    // send result since we can't prompt to select an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNTS, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            }
        }
    }, mHandler);
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,,,,
890,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",23,24,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
    }
}","{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a new case (BluetoothProfile.PBAP_CLIENT) added to the switch statement, and inside the case, there is a method call to pbapClient.close(). This addition does not change any existing control flows or the method's return type, as there was no return value in the method to begin with. Therefore, the code changes involve control dependency and other statements, making it a type 3,4 change.","There is no Compatibility Issue with this change because the method's return type remains void, and the method behavior only differs if the new 'case BluetoothProfile.PBAP_CLIENT' matches, which is an addition of functionality. Existing functionality and behavior remain unchanged for previously supported cases, so there is no compatibility issue."
891,<android.app.UiModeManager: void disableCarMode(int)>,23,24,<android.app.UiModeManager: void disableCarMode(int)>,<android.app.UiModeManager: void disableCarMode(int)>,0,"{
    if (mService != null) {
        try {
            mService.disableCarMode(flags);
        } catch (RemoteException e) {
            Log.e(TAG, ""disableCarMode: RemoteException"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.disableCarMode(flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Turn off special mode if currently in car mode.
 * @param flags May be 0 or {@link #DISABLE_CAR_MODE_GO_HOME}.
 */
","/**
 * Turn off special mode if currently in car mode.
 * @param flags May be 0 or {@link #DISABLE_CAR_MODE_GO_HOME}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The code change includes the modification of the exception handling block, which originally logged the exception and now throws it after wrapping it with `rethrowFromSystemServer()`. There are no other code changes, so the change type is 2.","The previous implementation was catching the `RemoteException` and logging it, which would allow the method to complete normally after logging the exception. In contrast, the new implementation rethrows the exception, which could potentially terminate the method abruptly and propagate the exception to the caller. This marks a change in how exceptions are handled by the API thus, the CI type is 2."
892,<com.android.server.backup.PreferredActivityBackupHelper: byte[] getBackupPayload(String)>,23,24,<com.android.server.backup.PreferredActivityBackupHelper: byte[] getBackupPayload(String)>,<com.android.server.backup.PreferredActivityBackupHelper: byte[] getBackupPayload(String)>,0,"{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        switch(key) {
            case KEY_PREFERRED:
                return pm.getPreferredActivityBackup(UserHandle.USER_OWNER);
            case KEY_DEFAULT_APPS:
                return pm.getDefaultAppsBackup(UserHandle.USER_OWNER);
            case KEY_INTENT_VERIFICATION:
                return pm.getIntentFilterVerificationBackup(UserHandle.USER_OWNER);
            default:
                Slog.w(TAG, ""Unexpected backup key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key);
    }
    return null;
}","{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        // TODO: http://b/22388012
        switch(key) {
            case KEY_PREFERRED:
                return pm.getPreferredActivityBackup(UserHandle.USER_SYSTEM);
            case KEY_DEFAULT_APPS:
                return pm.getDefaultAppsBackup(UserHandle.USER_SYSTEM);
            case KEY_INTENT_VERIFICATION:
                return pm.getIntentFilterVerificationBackup(UserHandle.USER_SYSTEM);
            default:
                Slog.w(TAG, ""Unexpected backup key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key);
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,5,"The parameter passed to the getPreferredActivityBackup, getDefaultAppsBackup, and getIntentFilterVerificationBackup methods is changed from UserHandle.USER_OWNER to UserHandle.USER_SYSTEM, which alters the dependent API invocation.","Since the API implementation is dependent on the UserHandle constants, and these constants can result in different behavior (for instance, pointing to data owned by a different user), this could potentially lead to a Compatibility Issue due to the dependent API being altered to operate on a different set of user data. Thus, the CI is caused by the potential different return values."
893,<android.text.StaticLayout: int getLineTop(int)>,23,24,<android.text.StaticLayout: int getLineTop(int)>,<android.text.StaticLayout: int getLineTop(int)>,0,"{
    int top = mLines[mColumns * line + TOP];
    if (mMaximumVisibleLineCount > 0 && line >= mMaximumVisibleLineCount && line != mLineCount) {
        top += getBottomPadding();
    }
    return top;
}","{
    return mLines[mColumns * line + TOP];
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The code in the early version includes additional logic to modify the value of 'top' before returning it, whereas the late version simply returns 'mLines[mColumns * line + TOP]' without any modification. Therefore, the return statement has changed, so the change type is 1.","The removal of the conditional statement means that the additional padding is no longer applied under certain conditions. As a result, the method may now return a different value than it did in the early version under specific circumstances, leading to a potential Compatibility Issue of type 1."
894,<android.content.res.Resources: AssetManager getAssets()>,23,24,<android.content.res.Resources: AssetManager getAssets()>,<android.content.res.Resources: AssetManager getAssets()>,0,"{
    return mAssets;
}","{
    return mResourcesImpl.getAssets();
}",1,"/**
 * Retrieve underlying AssetManager storage for these resources.
 */
","/**
 * Retrieve underlying AssetManager storage for these resources.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation changed from returning 'mAssets' directly to calling 'mResourcesImpl.getAssets()', which implies that a dependent API is being used, leading to a change of type 5.","Given that the method is now relying on the implementation of 'mResourcesImpl.getAssets()' to return the AssetManager, if 'mResourcesImpl.getAssets()' behaves differently between versions or has been changed, this could lead to the current API returning a different value or type. Therefore, it is a compatibility issue of type 1."
896,<android.app.Notification.WearableExtender: WearableExtender clone()>,23,24,<android.app.Notification.WearableExtender: WearableExtender clone()>,<android.app.Notification.WearableExtender: WearableExtender clone()>,0,"{
    WearableExtender that = new WearableExtender();
    that.mActions = new ArrayList<Action>(this.mActions);
    that.mFlags = this.mFlags;
    that.mDisplayIntent = this.mDisplayIntent;
    that.mPages = new ArrayList<Notification>(this.mPages);
    that.mBackground = this.mBackground;
    that.mContentIcon = this.mContentIcon;
    that.mContentIconGravity = this.mContentIconGravity;
    that.mContentActionIndex = this.mContentActionIndex;
    that.mCustomSizePreset = this.mCustomSizePreset;
    that.mCustomContentHeight = this.mCustomContentHeight;
    that.mGravity = this.mGravity;
    that.mHintScreenTimeout = this.mHintScreenTimeout;
    return that;
}","{
    WearableExtender that = new WearableExtender();
    that.mActions = new ArrayList<Action>(this.mActions);
    that.mFlags = this.mFlags;
    that.mDisplayIntent = this.mDisplayIntent;
    that.mPages = new ArrayList<Notification>(this.mPages);
    that.mBackground = this.mBackground;
    that.mContentIcon = this.mContentIcon;
    that.mContentIconGravity = this.mContentIconGravity;
    that.mContentActionIndex = this.mContentActionIndex;
    that.mCustomSizePreset = this.mCustomSizePreset;
    that.mCustomContentHeight = this.mCustomContentHeight;
    that.mGravity = this.mGravity;
    that.mHintScreenTimeout = this.mHintScreenTimeout;
    that.mDismissalId = this.mDismissalId;
    return that;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The only change made in the implementation of the method is the addition of a single line of code that copies the state of `mDismissalId` from `this` object to `that` object being cloned. This is classified as an other statement change (4),"This additional line of copying does not constitute a compatibility issue because it does not affect the return type or value, nor does it introduce any new exception or change in exception handling. The clone will simply have one additional piece of state copied over, which aligns with the expected behavior of a clone operation where the new object should be a replica of the one being cloned. Therefore, no compatibility issue is expected from this change (0)."
898,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,23,24,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,0,"{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            convertSizesToPixels(info);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            convertSizesToPixels(info);
        }
        return info;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
","/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from throwing a general RuntimeException to a specific method call throw e.rethrowFromSystemServer(), and thus the change type is 2.","This change introduces a different way of handling RemoteException that could potentially cause the method to throw a different exception than in the early version. Hence, the CI type is 2."
899,<android.net.TrafficStats: long getUidTxPackets(int)>,23,24,<android.net.TrafficStats: long getUidTxPackets(int)>,<android.net.TrafficStats: long getUidTxPackets(int)>,0,"{
    return nativeGetUidStat(uid, TYPE_TX_PACKETS);
}","{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_TX_PACKETS);
    } else {
        return UNSUPPORTED;
    }
}",1,"/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The late version introduces a new control dependency (if statement) that checks the UID and conditionally returns the value from the native method, or a constant indicating unsupported operation. A Dependent API (Process.myUid()) is also called, so the code changes involve control dependency and a dependent API change.","The new control flow causes a potential Compatibility Issue due to different return values. If the calling UID does not match the system UID or the passed UID parameter, the method will return UNSUPPORTED instead of the value from nativeGetUidStat(uid, TYPE_TX_PACKETS), which is a CI caused by potentially different return values (CI type 1)."
900,<android.view.ViewGroup.HoverTarget: HoverTarget obtain(View)>,23,24,<android.view.ViewGroup.HoverTarget: HoverTarget obtain(View)>,<android.view.ViewGroup.HoverTarget: HoverTarget obtain(View)>,0,"{
    final HoverTarget target;
    synchronized (sRecycleLock) {
        if (sRecycleBin == null) {
            target = new HoverTarget();
        } else {
            target = sRecycleBin;
            sRecycleBin = target.next;
            sRecycledCount--;
            target.next = null;
        }
    }
    target.child = child;
    return target;
}","{
    if (child == null) {
        throw new IllegalArgumentException(""child must be non-null"");
    }
    final HoverTarget target;
    synchronized (sRecycleLock) {
        if (sRecycleBin == null) {
            target = new HoverTarget();
        } else {
            target = sRecycleBin;
            sRecycleBin = target.next;
            sRecycledCount--;
            target.next = null;
        }
    }
    target.child = child;
    return target;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An exception handling statement (throw new IllegalArgumentException(""child must be non-null"")) has been added and the newly added if condition (if (child == null)) represents a change in control dependency, so the code change types are 2,3.","The introduction of a new exception for a null 'child' parameter is a change in the code that will cause a different exception to be thrown when 'child' is null, leading to compatibility issues. There is thus a CI type of 2."
901,<android.app.WallpaperManager: Intent getCropAndSetWallpaperIntent(Uri)>,23,24,<android.app.WallpaperManager: Intent getCropAndSetWallpaperIntent(Uri)>,<android.app.WallpaperManager: Intent getCropAndSetWallpaperIntent(Uri)>,0,"{
    if (imageUri == null) {
        throw new IllegalArgumentException(""Image URI must not be null"");
    }
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException(""Image URI must be of the "" + ContentResolver.SCHEME_CONTENT + "" scheme type"");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    cropAndSetWallpaperIntent.setPackage(""com.android.wallpapercropper"");
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException(""Cannot use passed URI to set wallpaper; "" + ""check that the type returned by ContentProvider matches image/*"");
}","{
    if (imageUri == null) {
        throw new IllegalArgumentException(""Image URI must not be null"");
    }
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException(""Image URI must be of the "" + ContentResolver.SCHEME_CONTENT + "" scheme type"");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    final String cropperPackage = mContext.getString(com.android.internal.R.string.config_wallpaperCropperPackage);
    cropAndSetWallpaperIntent.setPackage(cropperPackage);
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException(""Cannot use passed URI to set wallpaper; "" + ""check that the type returned by ContentProvider matches image/*"");
}",1,"/**
 * Gets an Intent that will launch an activity that crops the given
 * image and sets the device's wallpaper. If there is a default HOME activity
 * that supports cropping wallpapers, it will be preferred as the default.
 * Use this method instead of directly creating a {@link #ACTION_CROP_AND_SET_WALLPAPER}
 * intent.
 *
 * @param imageUri The image URI that will be set in the intent. The must be a content
 * URI and its provider must resolve its type to ""image/*""
 *
 * @throws IllegalArgumentException if the URI is not a content URI or its MIME type is
 * not ""image/*""
 */
","/**
 * Gets an Intent that will launch an activity that crops the given
 * image and sets the device's wallpaper. If there is a default HOME activity
 * that supports cropping wallpapers, it will be preferred as the default.
 * Use this method instead of directly creating a {@link #ACTION_CROP_AND_SET_WALLPAPER}
 * intent.
 *
 * @param imageUri The image URI that will be set in the intent. The must be a content
 * URI and its provider must resolve its type to ""image/*""
 *
 * @throws IllegalArgumentException if the URI is not a content URI or its MIME type is
 * not ""image/*""
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change includes replacing the hardcoded string for the cropper package name with a call to mContext.getString(com.android.internal.R.string.config_wallpaperCropperPackage), indicating a change in the value being set to the package of cropAndSetWallpaperIntent, so the change type is 4,5.","There is no Compatibility Issue found because the behavior of the API remains consistent. It still checks for the validity of the imageUri and resolves the intent to set the wallpaper. Changing the way the cropper package name is obtained does not affect the external behavior of the method as long as the resolved string is correct. Hence, there's nothing suggesting different return values or exception handlings between the versions based on the given implementation."
902,"<android.view.View: boolean awakenScrollBars(int,boolean)>",23,24,"<android.view.View: boolean awakenScrollBars(int,boolean)>","<android.view.View: boolean awakenScrollBars(int,boolean)>",0,"{
    final ScrollabilityCache scrollCache = mScrollCache;
    if (scrollCache == null || !scrollCache.fadeScrollBars) {
        return false;
    }
    if (scrollCache.scrollBar == null) {
        scrollCache.scrollBar = new ScrollBarDrawable();
        scrollCache.scrollBar.setCallback(this);
        scrollCache.scrollBar.setState(getDrawableState());
    }
    if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {
        if (invalidate) {
            // Invalidate to show the scrollbars
            postInvalidateOnAnimation();
        }
        if (scrollCache.state == ScrollabilityCache.OFF) {
            // FIXME: this is copied from WindowManagerService.
            // We should get this value from the system when it
            // is possible to do so.
            final int KEY_REPEAT_FIRST_DELAY = 750;
            startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
        }
        // Tell mScrollCache when we should start fading. This may
        // extend the fade start time if one was already scheduled
        long fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
        scrollCache.fadeStartTime = fadeStartTime;
        scrollCache.state = ScrollabilityCache.ON;
        // Schedule our fader to run, unscheduling any old ones first
        if (mAttachInfo != null) {
            mAttachInfo.mHandler.removeCallbacks(scrollCache);
            mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
        }
        return true;
    }
    return false;
}","{
    final ScrollabilityCache scrollCache = mScrollCache;
    if (scrollCache == null || !scrollCache.fadeScrollBars) {
        return false;
    }
    if (scrollCache.scrollBar == null) {
        scrollCache.scrollBar = new ScrollBarDrawable();
        scrollCache.scrollBar.setState(getDrawableState());
        scrollCache.scrollBar.setCallback(this);
    }
    if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {
        if (invalidate) {
            // Invalidate to show the scrollbars
            postInvalidateOnAnimation();
        }
        if (scrollCache.state == ScrollabilityCache.OFF) {
            // FIXME: this is copied from WindowManagerService.
            // We should get this value from the system when it
            // is possible to do so.
            final int KEY_REPEAT_FIRST_DELAY = 750;
            startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
        }
        // Tell mScrollCache when we should start fading. This may
        // extend the fade start time if one was already scheduled
        long fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
        scrollCache.fadeStartTime = fadeStartTime;
        scrollCache.state = ScrollabilityCache.ON;
        // Schedule our fader to run, unscheduling any old ones first
        if (mAttachInfo != null) {
            mAttachInfo.mHandler.removeCallbacks(scrollCache);
            mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
        }
        return true;
    }
    return false;
}",1,"/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked every time a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Whether this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
","/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked every time a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Whether this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There has been a minor reordering in the statements within the 'if' block, specifically the order of calls to `scrollCache.scrollBar.setState(getDrawableState());` and `scrollCache.scrollBar.setCallback(this);` has been swapped. This change falls under the category of 'Other statement changed'.","Despite the reordering of method calls on the `scrollCache.scrollBar` object, this does not change the behavior of the method in terms of returned values or thrown exceptions. Therefore, there is no Compatibility Issue."
903,"<android.net.http.X509TrustManagerExtensions: List<X509Certificate> checkServerTrusted(X509Certificate[],String,String)>",23,24,"<android.net.http.X509TrustManagerExtensions: List<X509Certificate> checkServerTrusted(X509Certificate[],String,String)>","<android.net.http.X509TrustManagerExtensions: List<X509Certificate> checkServerTrusted(X509Certificate[],String,String)>",0,"{
    return mDelegate.checkServerTrusted(chain, authType, host);
}","{
    if (mDelegate != null) {
        return mDelegate.checkServerTrusted(chain, authType, host);
    } else {
        try {
            return (List<X509Certificate>) mCheckServerTrusted.invoke(mTrustManager, chain, authType, host);
        } catch (IllegalAccessException e) {
            throw new CertificateException(""Failed to call checkServerTrusted"", e);
        } catch (InvocationTargetException e) {
            if (e.getCause() instanceof CertificateException) {
                throw (CertificateException) e.getCause();
            }
            if (e.getCause() instanceof RuntimeException) {
                throw (RuntimeException) e.getCause();
            }
            throw new CertificateException(""checkServerTrusted failed"", e.getCause());
        }
    }
}",1,"/**
 * Verifies the given certificate chain.
 *
 * <p>See {@link X509TrustManager#checkServerTrusted(X509Certificate[], String)} for a
 * description of the chain and authType parameters. The final parameter, host, should be the
 * hostname of the server.</p>
 *
 * @throws CertificateException if the chain does not verify correctly.
 * @return the properly ordered chain used for verification as a list of X509Certificates.
 */
","/**
 * Verifies the given certificate chain.
 *
 * <p>See {@link X509TrustManager#checkServerTrusted(X509Certificate[], String)} for a
 * description of the chain and authType parameters. The final parameter, host, should be the
 * hostname of the server.</p>
 *
 * @throws CertificateException if the chain does not verify correctly.
 * @return the properly ordered chain used for verification as a list of X509Certificates.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The implementation has changed significantly. Firstly, there's an addition of a null-check for mDelegate which was previously not present, indicating a control dependency change (3). Secondly, another mechanism to check server trusted certificates has been introduced if mDelegate is null, which depends on a reflective method invocation of mCheckServerTrusted, a dependent API (5). Furthermore, the invocation is surrounded by a try-catch block that handles IllegalAccessException and InvocationTargetException, and rethrows them as a CertificateException or RuntimeException, indicating a change in exception handling statements (2). Lastly, because the whole block is enclosed in an if-else statement, the return value could be different, hence a change in return statement (1).","Given the late implementation is conditionally returning a different value based on whether mDelegate is null or not, and is now potentially throwing new exceptions (IllegalAccessException or InvocationTargetException as CertificateException or RuntimeException), there are potential compatibility issues due to possible different return values or types (1) and different exception handling (2)."
904,"<android.app.admin.DevicePolicyManager: void setProfileName(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: void setProfileName(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void setProfileName(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            mService.setProfileName(admin, profileName);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setProfileName"");
    if (mService != null) {
        try {
            mService.setProfileName(admin, profileName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Sets the name of the profile. In the device owner case it sets the name of the user
 * which it is called from. Only a profile owner or device owner can call this. If this is
 * never called by the profile or device owner, the name will be set to default values.
 *
 * @see #isProfileOwnerApp
 * @see #isDeviceOwnerApp
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associate with.
 * @param profileName The name of the profile.
 */
","/**
 * Sets the name of the profile. In the device owner case it sets the name of the user which it
 * is called from. Only a profile owner or device owner can call this. If this is never called
 * by the profile or device owner, the name will be set to default values.
 *
 * @see #isProfileOwnerApp
 * @see #isDeviceOwnerApp
 * @param admin Which {@link DeviceAdminReceiver} this request is associate with.
 * @param profileName The name of the profile.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"A new method call (throwIfParentInstance(""setProfileName"")) has been introduced in the early part of the method, and the exception handling statement has changed from just logging to throwing an exception. This means the change types are 2 for the exception handling change and 4 for other statement changed.","The introduction of a new throw statement before the execution of the existing code and the change in the way a RemoteException is handled (now rethrown instead of logged), indicating possible Compatibility Issues due to different exception handlings. Therefore, the CI type is 2."
906,<android.widget.Gallery: boolean showContextMenu()>,23,24,<android.widget.Gallery: boolean showContextMenu()>,<android.widget.Gallery: boolean showContextMenu()>,0,"{
    if (isPressed() && mSelectedPosition >= 0) {
        int index = mSelectedPosition - mFirstPosition;
        View v = getChildAt(index);
        return dispatchLongPress(v, mSelectedPosition, mSelectedRowId);
    }
    return false;
}","{
    return showContextMenuInternal(0, 0, false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The entire body of the showContextMenu() method has been refactored to call a different method (showContextMenuInternal(0, 0, false)) instead of the original implementation. Therefore, the code change type is 1.","Given the original method implementation invoked dispatchLongPress() under specific conditions and returned false otherwise, while the new implementation always calls showContextMenuInternal() ignoring those conditions, it can potentially return a different value. Hence, the compatibility issue type is 1."
908,<android.app.Notification.Builder: Builder setSmallIcon(Icon)>,23,24,<android.app.Notification.Builder: Builder setSmallIcon(Icon)>,<android.app.Notification.Builder: Builder setSmallIcon(Icon)>,0,"{
    mSmallIcon = icon;
    return this;
}","{
    mN.setSmallIcon(icon);
    if (icon != null && icon.getType() == Icon.TYPE_RESOURCE) {
        mN.icon = icon.getResId();
    }
    return this;
}",1,"/**
 * Set the small icon, which will be used to represent the notification in the
 * status bar and content view (unless overriden there by a
 * {@link #setLargeIcon(Bitmap) large icon}).
 *
 * @param icon An Icon object to use.
 * @see Notification#icon
 */
","/**
 * Set the small icon, which will be used to represent the notification in the
 * status bar and content view (unless overriden there by a
 * {@link #setLargeIcon(Bitmap) large icon}).
 *
 * @param icon An Icon object to use.
 * @see Notification#icon
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The implementation adds statements to handle the passed 'icon' before returning 'this'. It sets the small icon on the internal Notification ('mN') directly and conditionally assigns the resource ID to 'mN.icon' if the icon is of the 'TYPE_RESOURCE'. The change type is 4 as it involves an internal state change.,"Although the internal implementation has changed, the method signature remains the same and it still returns 'this' Builder object. So the API is unlikely to exhibit altered behavior to the caller based on available information, thus there seems to be no Compatibility Issue as far as the method's return value or exception throwing is concerned."
910,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,23,24,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(TAG, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                // The IME could not handle it, so skip along to the next InputStage
                return FORWARD;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}","{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(mTag, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                // The IME could not handle it, so skip along to the next InputStage
                return FORWARD;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the use of a different variable name (`mTag` instead of `TAG`) in a logging statement. Since logging does not affect the functional behavior of the code, the change falls under 'Other statement changed'.","Since the only change made does not impact the functionality of the method (it only affects the logging output), there is no potential for a Compatibility Issue."
912,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>",23,24,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",2,"The method prepareToLeaveProcess() called within the try block has been modified to pass 'this' as an argument in the late version (prepareToLeaveProcess(this)). There is also a change in the exception handling; instead of throwing a new RuntimeException, the late version throws the RemoteException with e.rethrowFromSystemServer(), so the changes are type 4 and 5.","The change in the method signature of prepareToLeaveProcess() could potentially lead to a different behavior due to the introduction of a new parameter, but this by itself does not indicate a change in the control flow or the value that is being returned by the API. However, since the exception handling has changed significantly because now the RemoteException is being thrown directly rather than being wrapped in a RuntimeException, this could lead to a different exception being thrown. Therefore, the CI type is 2."
914,"<android.bluetooth.le.BluetoothLeAdvertiser.AdvertiseCallbackWrapper: void onClientRegistered(int,int)>",23,24,"<android.bluetooth.le.BluetoothLeAdvertiser.AdvertiseCallbackWrapper: void onClientRegistered(int,int)>","<android.bluetooth.le.BluetoothLeAdvertiser.AdvertiseCallbackWrapper: void onClientRegistered(int,int)>",0,"{
    Log.d(TAG, ""onClientRegistered() - status="" + status + "" clientIf="" + clientIf);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            mClientIf = clientIf;
            try {
                mBluetoothGatt.startMultiAdvertising(mClientIf, mAdvertisement, mScanResponse, mSettings);
                return;
            } catch (RemoteException e) {
                Log.e(TAG, ""failed to start advertising"", e);
            }
        }
        // Registration failed.
        mClientIf = -1;
        notifyAll();
    }
}","{
    Log.d(TAG, ""onClientRegistered() - status="" + status + "" clientIf="" + clientIf);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mClientIf == -1) {
                    // Registration succeeds after timeout, unregister client.
                    mBluetoothGatt.unregisterClient(clientIf);
                } else {
                    mClientIf = clientIf;
                    mBluetoothGatt.startMultiAdvertising(mClientIf, mAdvertisement, mScanResponse, mSettings);
                }
                return;
            } catch (RemoteException e) {
                Log.e(TAG, ""failed to start advertising"", e);
            }
        }
        // Registration failed.
        mClientIf = -1;
        notifyAll();
    }
}",1,"/**
 * Application interface registered - app is ready to go
 */
","/**
 * Application interface registered - app is ready to go
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The code had added a 'if' condition inside the existing 'if' condition and also moved a statement (mClientIf = clientIf) inside the 'else' block. This is a control dependency change. Additionally, the sequence of the statements and the logic inside the 'if' block has changed as there is a new condition added to decide between unregistering a client and starting advertising, which is classified as another statement changed. The code change type is, therefore, 3,4.","Even though there is a code change, the change does not induce a compatibility issue since the method does not return a different value or throw a new exception compared to the previous one. It handles an additional case (where mClientIf is -1 after a timeout), but if the conditions met to enter the 'if' block vary, the resulting actions (unregistering or starting advertising) are internal state changes that do not affect the API contract. Additionally, RemoteException is already being handled and logged in the same way as before, so there's no change in exception handling from an API perspective. Hence, the CI type is 0."
917,<android.view.ViewRootImpl.ViewPostImeInputStage: int onProcess(QueuedInputEvent)>,23,24,<android.view.ViewRootImpl.ViewPostImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ViewPostImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (q.mEvent instanceof KeyEvent) {
        return processKeyEvent(q);
    } else {
        // If delivering a new non-key event, make sure the window is
        // now allowed to start updating.
        handleDispatchWindowAnimationStopped();
        final int source = q.mEvent.getSource();
        if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            return processPointerEvent(q);
        } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            return processTrackballEvent(q);
        } else {
            return processGenericMotionEvent(q);
        }
    }
}","{
    if (q.mEvent instanceof KeyEvent) {
        return processKeyEvent(q);
    } else {
        final int source = q.mEvent.getSource();
        if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            return processPointerEvent(q);
        } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            return processTrackballEvent(q);
        } else {
            return processGenericMotionEvent(q);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method handleDispatchWindowAnimationStopped() is removed in the late version, which is an other kind of statement (doesn't belong to return, exception handling, or control dependency statements), so the change type is 4.","Since the removed code in the late version does not alter any return statements, exception handling, or control flow, there's no indication that the return value of the method or the exceptions it might throw will be different as a consequence of the change. The API will still return the result of processKeyEvent(q), processPointerEvent(q), processTrackballEvent(q), or processGenericMotionEvent(q) which expectedly behave the same in both versions. Thus, there is no Compatibility Issue, and the CI type is 0."
919,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,23,24,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The arguments passed to the method `mService.readCharacteristic` have been changed by removing `service.getType()`, `service.getInstanceId()`, `new ParcelUuid(service.getUuid())`, and `new ParcelUuid(characteristic.getUuid())`. The implementation within the try block itself also has been changed, with the new method call having fewer parameters, which constitutes a change in a dependent API and other statement changed. This would affect the return type if `mService.readCharacteristic` behaves differently based on the different set of parameters provided.","Due to the dependent API `mService.readCharacteristic` changing its parameters, there is a potential for the API to behave differently, which could lead to a different return type or value when invoking `readCharacteristic(BluetoothGattCharacteristic)` of `BluetoothGatt`. This is identified as a compatibility issue where the API could potentially return a different value than before."
920,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,23,24,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,0,"{
    synchronized (mH) {
        try {
            return mService.switchToLastInputMethod(imeToken);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
            return false;
        }
    }
}","{
    synchronized (mH) {
        try {
            return mService.switchToLastInputMethod(imeToken);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 */
","/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from catching the RemoteException and logging an error to throwing the exception using rethrowFromSystemServer() method, so the change type is 2.","The introduction of a new exception handling behavior (throwing the exception again instead of returning false and logging the error) could lead to a different exception being thrown by the late version of the API, hence the CI type is 2."
921,"<android.text.BidiFormatter: String unicodeWrap(String,TextDirectionHeuristic,boolean)>",23,24,"<android.text.BidiFormatter: String unicodeWrap(String,TextDirectionHeuristic,boolean)>","<android.text.BidiFormatter: String unicodeWrap(String,TextDirectionHeuristic,boolean)>",0,"{
    if (str == null)
        return null;
    final boolean isRtl = heuristic.isRtl(str, 0, str.length());
    StringBuilder result = new StringBuilder();
    if (getStereoReset() && isolate) {
        result.append(markBefore(str, isRtl ? TextDirectionHeuristics.RTL : TextDirectionHeuristics.LTR));
    }
    if (isRtl != mIsRtlContext) {
        result.append(isRtl ? RLE : LRE);
        result.append(str);
        result.append(PDF);
    } else {
        result.append(str);
    }
    if (isolate) {
        result.append(markAfter(str, isRtl ? TextDirectionHeuristics.RTL : TextDirectionHeuristics.LTR));
    }
    return result.toString();
}","{
    if (str == null)
        return null;
    return unicodeWrap((CharSequence) str, heuristic, isolate).toString();
}",1,"/**
 * Formats a string of given directionality for use in plain-text output of the context
 * directionality, so an opposite-directionality string is neither garbled nor garbles its
 * surroundings. This makes use of Unicode bidi formatting characters.
 * <p>
 * The algorithm: In case the given directionality doesn't match the context directionality, wraps
 * the string with Unicode bidi formatting characters: RLE+{@code str}+PDF for RTL text, or
 * LRE+{@code str}+PDF for LTR text.
 * <p>
 * If {@code isolate}, directionally isolates the string so that it does not garble its
 * surroundings. Currently, this is done by ""resetting"" the directionality after the string by
 * appending a trailing Unicode bidi mark matching the context directionality (LRM or RLM) when
 * either the overall directionality or the exit directionality of the string is opposite to
 * that of the context. Unless the formatter was built using
 * {@link Builder#stereoReset(boolean)} with a {@code false} argument, also prepends a Unicode
 * bidi mark matching the context directionality when either the overall directionality or the
 * entry directionality of the string is opposite to that of the context. Note that as opposed
 * to the overall directionality, the entry and exit directionalities are determined from the
 * string itself.
 * <p>
 * Does *not* do HTML-escaping.
 *
 * @param str The input string.
 * @param heuristic The algorithm to be used to estimate the string's overall direction.
 * See {@link TextDirectionHeuristics} for pre-defined heuristics.
 * @param isolate Whether to directionally isolate the string to prevent it from garbling the
 * content around it
 * @return Input string after applying the above processing. {@code null} if {@code str} is
 * {@code null}.
 */
","/**
 * Formats a string of given directionality for use in plain-text output of the context
 * directionality, so an opposite-directionality string is neither garbled nor garbles its
 * surroundings. This makes use of Unicode bidi formatting characters.
 * <p>
 * The algorithm: In case the given directionality doesn't match the context directionality, wraps
 * the string with Unicode bidi formatting characters: RLE+{@code str}+PDF for RTL text, or
 * LRE+{@code str}+PDF for LTR text.
 * <p>
 * If {@code isolate}, directionally isolates the string so that it does not garble its
 * surroundings. Currently, this is done by ""resetting"" the directionality after the string by
 * appending a trailing Unicode bidi mark matching the context directionality (LRM or RLM) when
 * either the overall directionality or the exit directionality of the string is opposite to
 * that of the context. Unless the formatter was built using
 * {@link Builder#stereoReset(boolean)} with a {@code false} argument, also prepends a Unicode
 * bidi mark matching the context directionality when either the overall directionality or the
 * entry directionality of the string is opposite to that of the context. Note that as opposed
 * to the overall directionality, the entry and exit directionalities are determined from the
 * string itself.
 * <p>
 * Does *not* do HTML-escaping.
 *
 * @param str The input string.
 * @param heuristic The algorithm to be used to estimate the string's overall direction.
 * See {@link TextDirectionHeuristics} for pre-defined heuristics.
 * @param isolate Whether to directionally isolate the string to prevent it from garbling the
 * content around it
 * @return Input string after applying the above processing. {@code null} if {@code str} is
 * {@code null}.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed by calling unicodeWrap() with different parameters than the original code, and the handling of the string building operation has been potentially offloaded to this method. Moreover, the dependent API unicodeWrap(CharSequence, TextDirectionHeuristic, boolean) is being used, which indicates that the dependent API has changed. Therefore, the code change types are 1,5.","Since the new implementation calls another overload of the unicodeWrap() method and given that the implementation details of this method are not shown, it is possible that the behavior of this method is different, thus potentially leading to a different return value. Therefore, the CI type is 1."
922,<android.app.ActivityManager: void setWatchHeapLimit(long)>,23,24,<android.app.ActivityManager: void setWatchHeapLimit(long)>,<android.app.ActivityManager: void setWatchHeapLimit(long)>,0,"{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, pssSize, mContext.getPackageName());
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, pssSize, mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Request that the system start watching for the calling process to exceed a pss
 * size as given here.  Once called, the system will look for any occasions where it
 * sees the associated process with a larger pss size and, when this happens, automatically
 * pull a heap dump from it and allow the user to share the data.  Note that this request
 * continues running even if the process is killed and restarted.  To remove the watch,
 * use {@link #clearWatchHeapLimit()}.
 *
 * <p>This API only work if the calling process has been marked as
 * {@link ApplicationInfo#FLAG_DEBUGGABLE} or this is running on a debuggable
 * (userdebug or eng) build.</p>
 *
 * <p>Callers can optionally implement {@link #ACTION_REPORT_HEAP_LIMIT} to directly
 * handle heap limit reports themselves.</p>
 *
 * @param pssSize The size in bytes to set the limit at.
 */
","/**
 * Request that the system start watching for the calling process to exceed a pss
 * size as given here.  Once called, the system will look for any occasions where it
 * sees the associated process with a larger pss size and, when this happens, automatically
 * pull a heap dump from it and allow the user to share the data.  Note that this request
 * continues running even if the process is killed and restarted.  To remove the watch,
 * use {@link #clearWatchHeapLimit()}.
 *
 * <p>This API only work if the calling process has been marked as
 * {@link ApplicationInfo#FLAG_DEBUGGABLE} or this is running on a debuggable
 * (userdebug or eng) build.</p>
 *
 * <p>Callers can optionally implement {@link #ACTION_REPORT_HEAP_LIMIT} to directly
 * handle heap limit reports themselves.</p>
 *
 * @param pssSize The size in bytes to set the limit at.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. In the early implementation, it catches the RemoteException but does nothing, while in the late implementation, it rethrows the exception using e.rethrowFromSystemServer(). The exception handling has been altered, which is code change type 2.","The late version of the method could potentially throw a RuntimeException if a RemoteException is caught. This behavior is different from the early version, which swallows the exception and continues silently. The late version could lead to an application crash if the RemoteException occurs. Therefore, there's a compatibility issue caused by potential different exception handlings, and the CI type is 2."
924,"<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>",23,24,"<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>","<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>",0,"{
    try {
        mService.showAppDetailsAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
    // Oops!
    }
}","{
    try {
        mService.showAppDetailsAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts the settings activity to show the application details for a
 * package in the specified profile.
 *
 * @param component The ComponentName of the package to launch settings for.
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
","/**
 * Starts the settings activity to show the application details for a
 * package in the specified profile.
 *
 * @param component The ComponentName of the package to launch settings for.
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from a catch block that does nothing to one that throws an exception with throw re.rethrowFromSystemServer(), hence the code change type is 2.","The change in exception handling could lead to the late version of the API throwing an exception where the early version did not, which could impact the behavior of apps using this API and result in a Compatibility Issue of type 2."
925,"<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>",23,24,"<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>","<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>",0,"{
    try {
        ActivityManagerNative.getDefault().moveTaskToFront(taskId, flags, options);
    } catch (RemoteException e) {
    // System dead, we will be dead too soon!
    }
}","{
    try {
        ActivityManagerNative.getDefault().moveTaskToFront(taskId, flags, options);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Ask that the task associated with a given task ID be moved to the
 * front of the stack, so it is now visible to the user.  Requires that
 * the caller hold permission {@link android.Manifest.permission#REORDER_TASKS}
 * or a SecurityException will be thrown.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags, 0 or more of
 * {@link #MOVE_TASK_WITH_HOME}, {@link #MOVE_TASK_NO_USER_ACTION}.
 * @param options Additional options for the operation, either null or
 * as per {@link Context#startActivity(Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)}.
 */
","/**
 * Ask that the task associated with a given task ID be moved to the
 * front of the stack, so it is now visible to the user.  Requires that
 * the caller hold permission {@link android.Manifest.permission#REORDER_TASKS}
 * or a SecurityException will be thrown.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags, 0 or more of
 * {@link #MOVE_TASK_WITH_HOME}, {@link #MOVE_TASK_NO_USER_ACTION}.
 * @param options Additional options for the operation, either null or
 * as per {@link Context#startActivity(Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed; the early version eats the exception, while the late version rethrows it, so the code change type is 2.","The early version suppresses the RemoteException silently, but the late version rethrows it with throw e.rethrowFromSystemServer(). This means the behavior of the API when encountering this exception has changed, leading to a different exception handling which is a Compatibility Issue, and the CI type is 2."
928,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void startRegisteration()>,23,24,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void startRegisteration()>,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void startRegisteration()>,0,"{
    synchronized (this) {
        // Scan stopped.
        if (mClientIf == -1)
            return;
        try {
            UUID uuid = UUID.randomUUID();
            mBluetoothGatt.registerClient(new ParcelUuid(uuid), this);
            wait(REGISTRATION_CALLBACK_TIMEOUT_MILLIS);
        } catch (InterruptedException | RemoteException e) {
            Log.e(TAG, ""application registeration exception"", e);
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_INTERNAL_ERROR);
        }
        if (mClientIf > 0) {
            mLeScanClients.put(mScanCallback, this);
        } else {
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_APPLICATION_REGISTRATION_FAILED);
        }
    }
}","{
    synchronized (this) {
        // Scan stopped.
        if (mClientIf == -1)
            return;
        try {
            UUID uuid = UUID.randomUUID();
            mBluetoothGatt.registerClient(new ParcelUuid(uuid), this);
            wait(REGISTRATION_CALLBACK_TIMEOUT_MILLIS);
        } catch (InterruptedException | RemoteException e) {
            Log.e(TAG, ""application registeration exception"", e);
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_INTERNAL_ERROR);
        }
        if (mClientIf > 0) {
            mLeScanClients.put(mScanCallback, this);
        } else {
            // subsequent operations can proceed.
            if (mClientIf == 0)
                mClientIf = -1;
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_APPLICATION_REGISTRATION_FAILED);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional check for the value of mClientIf is introduced in the late version, accompanied by a new line that sets mClientIf to -1 if its value equals 0. This is not a return statement, exception handling statement, or a control dependency change. Therefore, it is classified as other statement changed (type 4).","The new line simply sets a variable's value under a certain condition which is within an existing control flow that leads to callback error posting, this change does not affect the return value or exception handling for the calling function, so it does not introduce a Compatibility Issue. Therefore, there is no compatibility issue (type 0)."
930,<android.widget.ArrayAdapter.ArrayFilter: FilterResults performFiltering(CharSequence)>,23,24,<android.widget.ArrayAdapter.ArrayFilter: FilterResults performFiltering(CharSequence)>,<android.widget.ArrayAdapter.ArrayFilter: FilterResults performFiltering(CharSequence)>,0,"{
    FilterResults results = new FilterResults();
    if (mOriginalValues == null) {
        synchronized (mLock) {
            mOriginalValues = new ArrayList<T>(mObjects);
        }
    }
    if (prefix == null || prefix.length() == 0) {
        ArrayList<T> list;
        synchronized (mLock) {
            list = new ArrayList<T>(mOriginalValues);
        }
        results.values = list;
        results.count = list.size();
    } else {
        String prefixString = prefix.toString().toLowerCase();
        ArrayList<T> values;
        synchronized (mLock) {
            values = new ArrayList<T>(mOriginalValues);
        }
        final int count = values.size();
        final ArrayList<T> newValues = new ArrayList<T>();
        for (int i = 0; i < count; i++) {
            final T value = values.get(i);
            final String valueText = value.toString().toLowerCase();
            // First match against the whole, non-splitted value
            if (valueText.startsWith(prefixString)) {
                newValues.add(value);
            } else {
                final String[] words = valueText.split("" "");
                final int wordCount = words.length;
                // Start at index 0, in case valueText starts with space(s)
                for (int k = 0; k < wordCount; k++) {
                    if (words[k].startsWith(prefixString)) {
                        newValues.add(value);
                        break;
                    }
                }
            }
        }
        results.values = newValues;
        results.count = newValues.size();
    }
    return results;
}","{
    final FilterResults results = new FilterResults();
    if (mOriginalValues == null) {
        synchronized (mLock) {
            mOriginalValues = new ArrayList<>(mObjects);
        }
    }
    if (prefix == null || prefix.length() == 0) {
        final ArrayList<T> list;
        synchronized (mLock) {
            list = new ArrayList<>(mOriginalValues);
        }
        results.values = list;
        results.count = list.size();
    } else {
        final String prefixString = prefix.toString().toLowerCase();
        final ArrayList<T> values;
        synchronized (mLock) {
            values = new ArrayList<>(mOriginalValues);
        }
        final int count = values.size();
        final ArrayList<T> newValues = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            final T value = values.get(i);
            final String valueText = value.toString().toLowerCase();
            // First match against the whole, non-splitted value
            if (valueText.startsWith(prefixString)) {
                newValues.add(value);
            } else {
                final String[] words = valueText.split("" "");
                for (String word : words) {
                    if (word.startsWith(prefixString)) {
                        newValues.add(value);
                        break;
                    }
                }
            }
        }
        results.values = newValues;
        results.count = newValues.size();
    }
    return results;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,The code changes include: ,These changes fall under 3 (Control dependency changed) because of the loop syntax change and 4 (Other statement changed) due to the use of Diamond Operator.
931,"<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>",23,24,"<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>","<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>",0,"{
    try {
        mService.hideMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        mService.hideMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Close/hide the input method's soft input area, so the user no longer
 * sees it or can interact with it.  This can only be called
 * from the currently active input method, as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 */
","/**
 * Close/hide the input method's soft input area, so the user no longer
 * sees it or can interact with it.  This can only be called
 * from the currently active input method, as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The method of handling the RemoteException has changed from 'throw new RuntimeException(e);' to 'throw e.rethrowFromSystemServer();', indicating a change in exception handling statement, hence the code change type is 2.","The change in the exception handling means that the exception thrown by the API could potentially be different between the two versions, which may alter how the caller has to handle the exception. This constitutes a CI of type 2, which is caused by potential different exception handlings."
933,<android.net.LocalSocketImpl: void accept(LocalSocketImpl)>,23,24,<android.net.LocalSocketImpl: void accept(LocalSocketImpl)>,<android.net.LocalSocketImpl: void accept(LocalSocketImpl)>,0,"{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    s.fd = accept(fd, s);
    s.mFdCreatedInternally = true;
}","{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    try {
        s.fd = Os.accept(fd, null);
        s.mFdCreatedInternally = true;
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Accepts a new connection to the socket. Blocks until a new
 * connection arrives.
 *
 * @param s a socket that will be used to represent the new connection.
 * @throws IOException
 */
","/**
 * Accepts a new connection to the socket. Blocks until a new
 * connection arrives.
 *
 * @param s a socket that will be used to represent the new connection.
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The method used to accept a connection on the socket has changed from accept(fd, s) to Os.accept(fd, null), which includes the change of dependent API, and the addition of a try-catch block that catches 'ErrnoException' and rethrows it as an 'IOException'. This constitutes a change in exception handling and control dependencies, so the change types are 2, 3, and 5.","The addition of catching a new type of exception ('ErrnoException') that wasn't present in the previous version will lead to a change in exception handling behavior, potentially causing a different exception to be thrown in cases of an error when accepting a connection. Similarly, since the dependent method Os.accept has been introduced with different parameters, it may produce different outcomes (for instance, different error handling or return values) from the old method accept, resulting in a different behavior. Thus, the CI types are 1 and 2."
934,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",23,24,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>","<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",0,"{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mHost = mHost;
                f.mParentFragment = mParent;
                f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();
                f.mCalled = false;
                f.onAttach(mHost.getContext());
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                if (f.mParentFragment == null) {
                    mHost.onAttachFragment(f);
                }
                if (!f.mRetaining) {
                    f.performCreate(f.mSavedFragmentState);
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + f.getResources().getResourceName(f.mContainerId) + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    setHWLayerAnimListenerIfAlpha(f.mView, anim);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mResumed = true;
                    f.performResume();
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            setHWLayerAnimListenerIfAlpha(f.mView, anim);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                                f.mChildFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    f.mState = newState;
}","{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mHost = mHost;
                f.mParentFragment = mParent;
                f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();
                f.mCalled = false;
                f.onAttach(mHost.getContext());
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                if (f.mParentFragment == null) {
                    mHost.onAttachFragment(f);
                } else {
                    f.mParentFragment.onAttachFragment(f);
                }
                if (!f.mRetaining) {
                    f.performCreate(f.mSavedFragmentState);
                } else {
                    f.restoreChildFragmentState(f.mSavedFragmentState, true);
                    f.mState = Fragment.CREATED;
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            if (f.mContainerId == View.NO_ID) {
                                throwException(new IllegalArgumentException(""Cannot create fragment "" + f + "" for a container view with no id""));
                            }
                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                String resName;
                                try {
                                    resName = f.getResources().getResourceName(f.mContainerId);
                                } catch (NotFoundException e) {
                                    resName = ""unknown"";
                                }
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + resName + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    setHWLayerAnimListenerIfAlpha(f.mView, anim);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
                if (newState > Fragment.ACTIVITY_CREATED) {
                    f.mState = Fragment.STOPPED;
                }
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.performResume();
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            setHWLayerAnimListenerIfAlpha(f.mView, anim);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                        } else {
                            f.mState = Fragment.INITIALIZING;
                        }
                        f.performDetach();
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    if (f.mState != newState) {
        Log.w(TAG, ""moveToState: Fragment state for "" + f + "" not updated inline; "" + ""expected state "" + newState + "" found "" + f.mState);
        f.mState = newState;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
936,<android.content.pm.PackageInstaller: Session openSession(int)>,23,24,<android.content.pm.PackageInstaller: Session openSession(int)>,<android.content.pm.PackageInstaller: Session openSession(int)>,0,"{
    try {
        return new Session(mInstaller.openSession(sessionId));
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        return new Session(mInstaller.openSession(sessionId));
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Open an existing session to actively perform work. To succeed, the caller
 * must be the owner of the install session.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
","/**
 * Open an existing session to actively perform work. To succeed, the caller
 * must be the owner of the install session.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The exception statement has changed from throw e.rethrowAsRuntimeException() to throw e.rethrowFromSystemServer(), so the change type is 2.","Because the exception handling statement has been changed, the late version could potentially raise a different type of exception when handling RemoteException, so the CI type is 2."
937,<android.widget.RemoteViewsAdapter.RemoteViewsMetaData: boolean isViewTypeInRange(int)>,23,24,<android.widget.RemoteViewsAdapter.RemoteViewsMetaData: boolean isViewTypeInRange(int)>,<android.widget.RemoteViewsAdapter.RemoteViewsMetaData: boolean isViewTypeInRange(int)>,0,"{
    int mappedType = getMappedViewType(typeId);
    if (mappedType >= viewTypeCount) {
        return false;
    } else {
        return true;
    }
}","{
    int mappedType = getMappedViewType(typeId);
    return (mappedType < viewTypeCount);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,0,"The if-else control structure was simplified to a single return statement without changing the behavior, so the change type is 1.","The simplification of the return statement does not lead to a different behavior, as the logic to determine the returned boolean value—the condition `(mappedType < viewTypeCount)`—remains the same. Therefore, no compatibility issue arises, and the CI type is 0."
938,<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,23,24,<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,0,"{
    if (resId != 0 && resId == mCheckMarkResource) {
        return;
    }
    mCheckMarkResource = resId;
    Drawable d = null;
    if (mCheckMarkResource != 0) {
        d = getContext().getDrawable(mCheckMarkResource);
    }
    setCheckMarkDrawable(d);
}","{
    if (resId != 0 && resId == mCheckMarkResource) {
        return;
    }
    final Drawable d = resId != 0 ? getContext().getDrawable(resId) : null;
    setCheckMarkDrawableInternal(d, resId);
}",1,"/**
 * Sets the check mark to the drawable with the specified resource ID.
 * <p>
 * When this view is checked, the drawable's state set will include
 * {@link android.R.attr#state_checked}.
 *
 * @param resId the resource identifier of drawable to use as the check
 * mark
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 * @see #setCheckMarkDrawable(Drawable)
 * @see #getCheckMarkDrawable()
 */
","/**
 * Sets the check mark to the drawable with the specified resource ID.
 * <p>
 * When this view is checked, the drawable's state set will include
 * {@link android.R.attr#state_checked}.
 *
 * @param resId the resource identifier of drawable to use as the check
 * mark
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 * @see #setCheckMarkDrawable(Drawable)
 * @see #getCheckMarkDrawable()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"Changes include: simplifying condition and variable assignment by using a ternary operator instead of an if-else block, altering the method call from setCheckMarkDrawable(d) to setCheckMarkDrawableInternal(d, resId), and removing the intermediate storage of mCheckMarkResource. Hence, the code change types are 1,3,4,5.","There is no Compatibility Issue; the refactor does not affect the behavioral contract of the method, the output remains the same provided the APIs getContext().getDrawable(int) and setCheckMarkDrawableInternal(Drawable, int) maintain the same contract as the former implementation."
940,"<com.android.server.backup.NotificationBackupHelper: void applyRestoredPayload(String,byte[])>",23,24,"<com.android.server.backup.NotificationBackupHelper: void applyRestoredPayload(String,byte[])>","<com.android.server.backup.NotificationBackupHelper: void applyRestoredPayload(String,byte[])>",0,"{
    if (DEBUG) {
        Slog.v(TAG, ""Got restore of "" + key);
    }
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            nm.applyRestore(payload, UserHandle.USER_OWNER);
        } catch (Exception e) {
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
        }
    }
}","{
    if (DEBUG) {
        Slog.v(TAG, ""Got restore of "" + key);
    }
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            // TODO: http://b/22388012
            nm.applyRestore(payload, UserHandle.USER_SYSTEM);
        } catch (Exception e) {
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the argument passed to the method nm.applyRestore from UserHandle.USER_OWNER to UserHandle.USER_SYSTEM. This is classified as ""Other statement changed"" (4) since it's neither a control dependency change, return statement change, nor an exception handling statement change, and it is not directly changing a dependent API's signature.",There is no Compatibility Issue since the method signature remains unchanged and the method behaviour is expected to remain consistent across the users passed to the method. The change appears to be an internal detail rather than something that would affect API consumers.
944,<android.net.ConnectivityManager: NetworkInfo[] getAllNetworkInfo()>,23,24,<android.net.ConnectivityManager: NetworkInfo[] getAllNetworkInfo()>,<android.net.ConnectivityManager: NetworkInfo[] getAllNetworkInfo()>,0,"{
    try {
        return mService.getAllNetworkInfo();
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return mService.getAllNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns connection status information about all network
 * types supported by the device.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of {@link NetworkInfo} objects.  Check each
 * {@link NetworkInfo#getType} for which type each applies.
 *
 * @deprecated This method does not support multiple connected networks
 * of the same type. Use {@link #getAllNetworks} and
 * {@link #getNetworkInfo(android.net.Network)} instead.
 */
","/**
 * Returns connection status information about all network
 * types supported by the device.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of {@link NetworkInfo} objects.  Check each
 * {@link NetworkInfo#getType} for which type each applies.
 *
 * @deprecated This method does not support multiple connected networks
 * of the same type. Use {@link #getAllNetworks} and
 * {@link #getNetworkInfo(android.net.Network)} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from returning null to throwing the exception, so the code change type is 2.","The code change will potentially lead to a Compatibility Issue due to different exception handling. In the early version, a RemoteException leads to a null return; in the late version, the same exception is thrown, possibly affecting upstream exception handling. Consequently, the CI type is 2."
945,<android.net.NetworkInfo: String toString()>,23,24,<android.net.NetworkInfo: String toString()>,<android.net.NetworkInfo: String toString()>,0,"{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""["");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", roaming: "").append(mIsRoaming).append("", failover: "").append(mIsFailover).append("", isAvailable: "").append(mIsAvailable).append(""]"");
        return builder.toString();
    }
}","{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""["");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", failover: "").append(mIsFailover).append("", available: "").append(mIsAvailable).append("", roaming: "").append(mIsRoaming).append("", metered: "").append(mIsMetered).append(""]"");
        return builder.toString();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There are changes in the sequence of appended strings for the StringBuilder object and the addition of the "", metered: "" part towards the end of the string, which correspond to other statement changes in the implementation of the `toString()` method. This is identified as code change type 4.","The changes in the sequence and addition of parts to the `StringBuilder` object do not lead to compatibility issues per se. The method still returns a `String` with additional information. The method signature remains the same, and the modifications do not affect how the method is called or the types of potential return values. This change is backward compatible as it doesn't alter the overall behavior or expected interaction with the method. Hence, there are no compatibility issues, and the CI type is 0."
947,<android.widget.TextView: boolean onPreDraw()>,23,24,<android.widget.TextView: boolean onPreDraw()>,<android.widget.TextView: boolean onPreDraw()>,0,"{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        if (mEditor.extractedTextModeWillBeStarted()) {
            mEditor.checkFieldAndSelectCurrentWord();
        } else {
            mEditor.startSelectionActionMode();
        }
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (isInExtractedMode() && hasSelection() && mEditor != null && mEditor.mTextActionMode == null && isShown() && hasWindowFocus()) {
        mEditor.startSelectionActionMode();
    }
    unregisterForPreDraw();
    return true;
}","{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.refreshTextActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    unregisterForPreDraw();
    return true;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is located in the block of code that checks if `mEditor.mCreatedWithASelection` is true. In the early version, it calls `mEditor.checkFieldAndSelectCurrentWord()` or `mEditor.startSelectionActionMode()`, while in the late version, it calls `mEditor.refreshTextActionMode()`. This change is not a return statement change, an exception handling change, a control dependency change, or a dependent API change—it is an 'Other statement changed' situation.","Although there is a change in the method being called, it does not affect the return value of the `onPreDraw()` method, which is always `true`. The exception handling hasn't changed, so there is no compatibility issue introduced by this change."
948,"<android.app.admin.DevicePolicyManager: void setLockTaskPackages(ComponentName,String[])>",23,24,"<android.app.admin.DevicePolicyManager: void setLockTaskPackages(ComponentName,String[])>","<android.app.admin.DevicePolicyManager: void setLockTaskPackages(ComponentName,String[])>",0,"{
    if (mService != null) {
        try {
            mService.setLockTaskPackages(admin, packages);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setLockTaskPackages"");
    if (mService != null) {
        try {
            mService.setLockTaskPackages(admin, packages);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Sets which packages may enter lock task mode.
 *
 * <p>Any packages that shares uid with an allowed package will also be allowed
 * to activate lock task.
 *
 * From {@link android.os.Build.VERSION_CODES#M} removing packages from the lock task
 * package list results in locked tasks belonging to those packages to be finished.
 *
 * This function can only be called by the device owner.
 * @param packages The list of packages allowed to enter lock task mode
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 *
 * @see Activity#startLockTask()
 * @see DeviceAdminReceiver#onLockTaskModeEntering(Context, Intent, String)
 * @see DeviceAdminReceiver#onLockTaskModeExiting(Context, Intent)
 * @see UserManager#DISALLOW_CREATE_WINDOWS
 */
","/**
 * Sets which packages may enter lock task mode.
 * <p>
 * Any packages that shares uid with an allowed package will also be allowed to activate lock
 * task. From {@link android.os.Build.VERSION_CODES#M} removing packages from the lock task
 * package list results in locked tasks belonging to those packages to be finished. This
 * function can only be called by the device owner.
 *
 * @param packages The list of packages allowed to enter lock task mode
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @throws SecurityException if {@code admin} is not a device owner.
 * @see Activity#startLockTask()
 * @see DeviceAdminReceiver#onLockTaskModeEntering(Context, Intent, String)
 * @see DeviceAdminReceiver#onLockTaskModeExiting(Context, Intent)
 * @see UserManager#DISALLOW_CREATE_WINDOWS
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The addition of the method throwIfParentInstance(""setLockTaskPackages"") is a change type 4 and changes regarding exception handling by replacing Log.w with throw e.rethrowFromSystemServer() is a change type 2. Both are dependent API changes which is change type 5.","Introduction of a new potential for throwing an unchecked exception (rethrowFromSystemServer) makes this an issue related to exception behavior as clients previously catching RemoteException will now encounter unchecked exceptions, so the CI type is 2."
949,<android.widget.TimePickerClockDelegate: void onRestoreInstanceState(Parcelable)>,23,24,<android.widget.TimePickerClockDelegate: void onRestoreInstanceState(Parcelable)>,<android.widget.TimePickerClockDelegate: void onRestoreInstanceState(Parcelable)>,0,"{
    SavedState ss = (SavedState) state;
    setInKbMode(ss.inKbMode());
    setTypedTimes(ss.getTypesTimes());
    initialize(ss.getHour(), ss.getMinute(), ss.is24HourMode(), ss.getCurrentItemShowing());
    mRadialTimePickerView.invalidate();
    if (mInKbMode) {
        tryStartingKbMode(-1);
        mHourView.invalidate();
    }
}","{
    if (state instanceof SavedState) {
        final SavedState ss = (SavedState) state;
        initialize(ss.getHour(), ss.getMinute(), ss.is24HourMode(), ss.getCurrentItemShowing());
        mRadialTimePickerView.invalidate();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency and other statements have changed. Specifically, the cast to `SavedState` is surrounded by an instanceof check, and the statements `setInKbMode(ss.inKbMode());`, `setTypedTimes(ss.getTypesTimes());`, and the check for `mInKbMode` are removed in the late version. The code change type is 3,4 since there are changes in control statements and other changes not related to return, exception handling, or dependent API.","The code change doesn't remove a return statement or introduce a new return statement, nor does it change exception handling. The changes are related to restoring state, and while behaviorally the control flow may be different if the input is not an instance of `SavedState`, it does not change the method's control flow related to returning a value or throwing an exception. Thus, no Compatibility Issue of type 1 or 2 is detected."
950,<android.widget.DigitalClock: void onAttachedToWindow()>,23,24,<android.widget.DigitalClock: void onAttachedToWindow()>,<android.widget.DigitalClock: void onAttachedToWindow()>,0,"{
    mTickerStopped = false;
    super.onAttachedToWindow();
    mHandler = new Handler();
    /**
     * requests a tick on the next hard-second boundary
     */
    mTicker = new Runnable() {

        public void run() {
            if (mTickerStopped)
                return;
            mCalendar.setTimeInMillis(System.currentTimeMillis());
            setText(DateFormat.format(mFormat, mCalendar));
            invalidate();
            long now = SystemClock.uptimeMillis();
            long next = now + (1000 - now % 1000);
            mHandler.postAtTime(mTicker, next);
        }
    };
    mTicker.run();
}","{
    mTickerStopped = false;
    super.onAttachedToWindow();
    mFormatChangeObserver = new FormatChangeObserver();
    getContext().getContentResolver().registerContentObserver(Settings.System.CONTENT_URI, true, mFormatChangeObserver);
    setFormat();
    mHandler = new Handler();
    /**
     * requests a tick on the next hard-second boundary
     */
    mTicker = new Runnable() {

        public void run() {
            if (mTickerStopped)
                return;
            mCalendar.setTimeInMillis(System.currentTimeMillis());
            setText(DateFormat.format(mFormat, mCalendar));
            invalidate();
            long now = SystemClock.uptimeMillis();
            long next = now + (1000 - now % 1000);
            mHandler.postAtTime(mTicker, next);
        }
    };
    mTicker.run();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"New variable `mFormatChangeObserver` is initialized and registered with the content resolver, and `setFormat()` method is called - neither of these changes the API's control flow or affects exception handling; hence, this change type is 4.","Since the changes do not affect the return value or introduce different exceptions, there would be no Compatibility Issue; hence, the CI type is 0."
952,<android.view.ViewOverlay.OverlayViewGroup: void add(View)>,23,24,<android.view.ViewOverlay.OverlayViewGroup: void add(View)>,<android.view.ViewOverlay.OverlayViewGroup: void add(View)>,0,"{
    if (child.getParent() instanceof ViewGroup) {
        ViewGroup parent = (ViewGroup) child.getParent();
        if (parent != mHostView && parent.getParent() != null && parent.mAttachInfo != null) {
            // Moving to different container; figure out how to position child such that
            // it is in the same location on the screen
            int[] parentLocation = new int[2];
            int[] hostViewLocation = new int[2];
            parent.getLocationOnScreen(parentLocation);
            mHostView.getLocationOnScreen(hostViewLocation);
            child.offsetLeftAndRight(parentLocation[0] - hostViewLocation[0]);
            child.offsetTopAndBottom(parentLocation[1] - hostViewLocation[1]);
        }
        parent.removeView(child);
        if (parent.getLayoutTransition() != null) {
            // LayoutTransition will cause the child to delay removal - cancel it
            parent.getLayoutTransition().cancel(LayoutTransition.DISAPPEARING);
        }
        // fail-safe if view is still attached for any reason
        if (child.getParent() != null) {
            child.mParent = null;
        }
    }
    super.addView(child);
}","{
    if (child == null) {
        throw new IllegalArgumentException(""view must be non-null"");
    }
    if (child.getParent() instanceof ViewGroup) {
        ViewGroup parent = (ViewGroup) child.getParent();
        if (parent != mHostView && parent.getParent() != null && parent.mAttachInfo != null) {
            // Moving to different container; figure out how to position child such that
            // it is in the same location on the screen
            int[] parentLocation = new int[2];
            int[] hostViewLocation = new int[2];
            parent.getLocationOnScreen(parentLocation);
            mHostView.getLocationOnScreen(hostViewLocation);
            child.offsetLeftAndRight(parentLocation[0] - hostViewLocation[0]);
            child.offsetTopAndBottom(parentLocation[1] - hostViewLocation[1]);
        }
        parent.removeView(child);
        if (parent.getLayoutTransition() != null) {
            // LayoutTransition will cause the child to delay removal - cancel it
            parent.getLayoutTransition().cancel(LayoutTransition.DISAPPEARING);
        }
        // fail-safe if view is still attached for any reason
        if (child.getParent() != null) {
            child.mParent = null;
        }
    }
    super.addView(child);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An additional null check and a throw statement have been added in the late version for the 'child' parameter. So this is a new exception handling statement added, hence the code change type is 2. Additionally, since this statement isn't a control flow or dependent API change and doesn't directly affect returns, it falls under other statement changes as well, which is type 4.","Before the addition of the null check, the early version would allow 'child' to be null and the method would not throw an exception, whereas the late version will explicitly throw an IllegalArgumentException if 'child' is null. This addition as such will create a Compatibility Issue of type 2, since the behavior now includes the possibility of a new exception being thrown."
954,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getInputMethodList()>,23,24,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getInputMethodList()>,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getInputMethodList()>,0,"{
    try {
        return mService.getInputMethodList();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        return mService.getInputMethodList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. Originally it wraps the RemoteException in a new RuntimeException, but in the late version, it throws the rethrown exception from the system server by calling e.rethrowFromSystemServer(), so the code change type is 2.","The change in the exception handling could lead to a different exception being thrown when the method is called, and therefore a different behavior. This change will cause client code that might have been written to catch RuntimeException to potentially break because now the catch block will no longer apply. Thus, the CI type is 2."
955,<android.speech.tts.AudioPlaybackQueueItem: void run()>,23,24,<android.speech.tts.AudioPlaybackQueueItem: void run()>,<android.speech.tts.AudioPlaybackQueueItem: void run()>,0,"{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    int sessionId = mAudioParams.mSessionId;
    mPlayer = MediaPlayer.create(mContext, mUri, null, mAudioParams.mAudioAttributes, sessionId > 0 ? sessionId : AudioSystem.AUDIO_SESSION_ALLOCATE);
    if (mPlayer == null) {
        dispatcher.dispatchOnError(TextToSpeech.ERROR_OUTPUT);
        return;
    }
    try {
        mPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() {

            @Override
            public boolean onError(MediaPlayer mp, int what, int extra) {
                Log.w(TAG, ""Audio playback error: "" + what + "", "" + extra);
                mDone.open();
                return true;
            }
        });
        mPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {

            @Override
            public void onCompletion(MediaPlayer mp) {
                mFinished = true;
                mDone.open();
            }
        });
        setupVolume(mPlayer, mAudioParams.mVolume, mAudioParams.mPan);
        mPlayer.start();
        mDone.block();
        finish();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, ""MediaPlayer failed"", ex);
        mDone.open();
    }
    if (mFinished) {
        dispatcher.dispatchOnSuccess();
    } else {
        dispatcher.dispatchOnStop();
    }
}","{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    int sessionId = mAudioParams.mSessionId;
    mPlayer = MediaPlayer.create(mContext, mUri, null, mAudioParams.mAudioAttributes, sessionId > 0 ? sessionId : AudioManager.AUDIO_SESSION_ID_GENERATE);
    if (mPlayer == null) {
        dispatcher.dispatchOnError(TextToSpeech.ERROR_OUTPUT);
        return;
    }
    try {
        mPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() {

            @Override
            public boolean onError(MediaPlayer mp, int what, int extra) {
                Log.w(TAG, ""Audio playback error: "" + what + "", "" + extra);
                mDone.open();
                return true;
            }
        });
        mPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {

            @Override
            public void onCompletion(MediaPlayer mp) {
                mFinished = true;
                mDone.open();
            }
        });
        setupVolume(mPlayer, mAudioParams.mVolume, mAudioParams.mPan);
        mPlayer.start();
        mDone.block();
        finish();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, ""MediaPlayer failed"", ex);
        mDone.open();
    }
    if (mFinished) {
        dispatcher.dispatchOnSuccess();
    } else {
        dispatcher.dispatchOnStop();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The argument passed to the MediaPlayer.create() function has changed from AudioSystem.AUDIO_SESSION_ALLOCATE to AudioManager.AUDIO_SESSION_ID_GENERATE. This change does not affect the return statement or exception handling; it is a change to a dependent API, so the code change type is 5.","Since the argument change from AudioSystem.AUDIO_SESSION_ALLOCATE to AudioManager.AUDIO_SESSION_ID_GENERATE is strictly related to how the session ID is generated and does not inherently affect the output or exception handling of the run() method, there is no Compatibility Issue; the relevant behavior is not affected. Hence the CI type is 0."
956,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,23,24,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,0,"{
    return new StringBuilder(ZenRule.class.getSimpleName()).append('[').append(""enabled="").append(enabled).append("",snoozing="").append(snoozing).append("",name="").append(name).append("",zenMode="").append(Global.zenModeToString(zenMode)).append("",conditionId="").append(conditionId).append("",condition="").append(condition).append("",component="").append(component).append(']').toString();
}","{
    return new StringBuilder(ZenRule.class.getSimpleName()).append('[').append(""enabled="").append(enabled).append("",snoozing="").append(snoozing).append("",name="").append(name).append("",zenMode="").append(Global.zenModeToString(zenMode)).append("",conditionId="").append(conditionId).append("",condition="").append(condition).append("",component="").append(component).append("",id="").append(id).append("",creationTime="").append(creationTime).append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The toString method has been updated to include the "".append("",id="").append(id).append("",creationTime="").append(creationTime)"" part. This represents a change type 4, as it's an addition to the method's output, but not a change in return type, exception handling, control flows or dependent APIs.","The change will cause the API to return a different value, as new information (id and creationTime) is added to the string output. Thus, the CI type is 1."
957,"<android.content.res.TypedArray: int getInteger(int,int)>",23,24,"<android.content.res.TypedArray: int getInteger(int,int)>","<android.content.res.TypedArray: int getInteger(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to integer: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to integer: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */
","/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The local variable `attrIndex` is introduced and used for error messages, and the multiplication with `AssetManager.STYLE_NUM_ENTRIES` is removed within the method `getValueAt()`. These are changes to local variables and statement values related to error message construction, so the changes are of types 3 (Control dependency change due to the modification in how `index` is used and constructed error messages) and 4 (Other statement changed due to the change in the error message string).","Though there's a change in the construction of error messages, it does not affect the function's return values or thrown exceptions in response to its inputs, as the error message construction does not influence the logic that determines the return value or thrown exception. Therefore, there's no Compatibility Issue, which is type 0."
958,<android.hardware.usb.UsbManager: boolean hasPermission(UsbAccessory)>,23,24,<android.hardware.usb.UsbManager: boolean hasPermission(UsbAccessory)>,<android.hardware.usb.UsbManager: boolean hasPermission(UsbAccessory)>,0,"{
    try {
        return mService.hasAccessoryPermission(accessory);
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in hasPermission"", e);
        return false;
    }
}","{
    try {
        return mService.hasAccessoryPermission(accessory);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the caller has permission to access the accessory.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbAccessory, PendingIntent)} or
 * by the user choosing the caller as the default application for the accessory.
 *
 * @param accessory to check permissions for
 * @return true if caller has permission
 */
","/**
 * Returns true if the caller has permission to access the accessory.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbAccessory, PendingIntent)} or
 * by the user choosing the caller as the default application for the accessory.
 *
 * @param accessory to check permissions for
 * @return true if caller has permission
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has changed: instead of catching the RemoteException and logging an error, the late version throws the exception using rethrowFromSystemServer(). So the change type is 2.","The early version of the API suppresses the RemoteException and returns false, while the late version propagates the exception. This difference can cause the late version API to terminate the caller with an unchecked exception instead of returning false, thus it is a CI type 2."
959,"<android.os.DropBoxManager: void addFile(String,File,int)>",23,24,"<android.os.DropBoxManager: void addFile(String,File,int)>","<android.os.DropBoxManager: void addFile(String,File,int)>",0,"{
    if (file == null)
        throw new NullPointerException(""file == null"");
    Entry entry = new Entry(tag, 0, file, flags);
    try {
        mService.add(entry);
    } catch (RemoteException e) {
    // ignore
    } finally {
        entry.close();
    }
}","{
    if (file == null)
        throw new NullPointerException(""file == null"");
    Entry entry = new Entry(tag, 0, file, flags);
    try {
        mService.add(entry);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } finally {
        entry.close();
    }
}",1,"/**
 * Stores the contents of a file, which may be ignored or discarded as with
 * {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param file to read from
 * @param flags describing the data
 * @throws IOException if the file can't be opened
 */
","/**
 * Stores the contents of a file, which may be ignored or discarded as with
 * {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param file to read from
 * @param flags describing the data
 * @throws IOException if the file can't be opened
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has changed, where the early version ignores the RemoteException but the late version throws it, so the code change type is 2.","The change in exception handling will cause the API to potentially throw a different exception when encountering a RemoteException, thus the CI type is 2."
960,"<android.view.ViewGroup: boolean getChildVisibleRect(View,Rect,Point)>",23,24,"<android.view.ViewGroup: boolean getChildVisibleRect(View,Rect,Point)>","<android.view.ViewGroup: boolean getChildVisibleRect(View,Rect,Point)>",0,"{
    // It doesn't make a whole lot of sense to call this on a view that isn't attached,
    // but for some simple tests it can be useful. If we don't have attach info this
    // will allocate memory.
    final RectF rect = mAttachInfo != null ? mAttachInfo.mTmpTransformRect : new RectF();
    rect.set(r);
    if (!child.hasIdentityMatrix()) {
        child.getMatrix().mapRect(rect);
    }
    final int dx = child.mLeft - mScrollX;
    final int dy = child.mTop - mScrollY;
    rect.offset(dx, dy);
    if (offset != null) {
        if (!child.hasIdentityMatrix()) {
            float[] position = mAttachInfo != null ? mAttachInfo.mTmpTransformLocation : new float[2];
            position[0] = offset.x;
            position[1] = offset.y;
            child.getMatrix().mapPoints(position);
            offset.x = (int) (position[0] + 0.5f);
            offset.y = (int) (position[1] + 0.5f);
        }
        offset.x += dx;
        offset.y += dy;
    }
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    boolean rectIsVisible = true;
    if (mParent == null || (mParent instanceof ViewGroup && ((ViewGroup) mParent).getClipChildren())) {
        // Clip to bounds.
        rectIsVisible = rect.intersect(0, 0, width, height);
    }
    if (rectIsVisible && (mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        // Clip to padding.
        rectIsVisible = rect.intersect(mPaddingLeft, mPaddingTop, width - mPaddingRight, height - mPaddingBottom);
    }
    if (rectIsVisible && mClipBounds != null) {
        // Clip to clipBounds.
        rectIsVisible = rect.intersect(mClipBounds.left, mClipBounds.top, mClipBounds.right, mClipBounds.bottom);
    }
    r.set((int) (rect.left + 0.5f), (int) (rect.top + 0.5f), (int) (rect.right + 0.5f), (int) (rect.bottom + 0.5f));
    if (rectIsVisible && mParent != null) {
        rectIsVisible = mParent.getChildVisibleRect(this, r, offset);
    }
    return rectIsVisible;
}","{
    return getChildVisibleRect(child, r, offset, false);
}",1,"/**
 * {@inheritDoc}
 */
",,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the late version replaces the entire body of the early version with a single return statement that invokes `getChildVisibleRect(child, r, offset, false);`. This indicates both a structural change in the method's statements (4 - Other statement changed) and a reliance on a different implementation, potentially a new overload of the method `getChildVisibleRect` (5 - Dependent API changed). Additionally, since the method's body has been completely replaced, the value returned by the method could potentially be different (1 - Return statement changed).","Because the early version includes various calculations and checks that can influence the resulting `boolean` value of `rectIsVisible`, removing all this and instead calling a different method could result in a different `boolean` value being returned. This consequence leads us to recognize a Compatibility Issue type 1 (Compatibility Issue caused by potential different return values or types)."
962,"<android.os.DropBoxManager: void addText(String,String)>",23,24,"<android.os.DropBoxManager: void addText(String,String)>","<android.os.DropBoxManager: void addText(String,String)>",0,"{
    try {
        mService.add(new Entry(tag, 0, data));
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.add(new Entry(tag, 0, data));
    } catch (RemoteException e) {
        if (e instanceof TransactionTooLargeException && mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data, so it was ignored"", e);
            return;
        }
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Stores human-readable text.  The data may be discarded eventually (or even
 * immediately) if space is limited, or ignored entirely if the tag has been
 * blocked (see {@link #isTagEnabled}).
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 */
","/**
 * Stores human-readable text.  The data may be discarded eventually (or even
 * immediately) if space is limited, or ignored entirely if the tag has been
 * blocked (see {@link #isTagEnabled}).
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The late version has added an 'if' condition in the catch block for RemoteException and based on this condition, it may log an error without rethrowing the exception, or may throw a new exception using e.rethrowFromSystemServer(). The control flow has changed due to this added if condition, while the catch statement has been enlarged to include a logging statement and a conditional throw statement. Hence, the changes include both exception handling statement changed (2) and control dependency changed (3).","Due to the added condition, the method can now either log and return quietly or throw a different exception than in the previous version, leading to different exception handling behaviors. Therefore, this change constitutes a compatibility issue of type 2 (Compatibility Issue caused by potential different exception handlings)."
963,<android.app.Notification.Builder: Builder setLargeIcon(Icon)>,23,24,<android.app.Notification.Builder: Builder setLargeIcon(Icon)>,<android.app.Notification.Builder: Builder setLargeIcon(Icon)>,0,"{
    mLargeIcon = icon;
    return this;
}","{
    mN.mLargeIcon = icon;
    mN.extras.putParcelable(EXTRA_LARGE_ICON, icon);
    return this;
}",1,"/**
 * Add a large icon to the notification content view.
 *
 * In the platform template, this image will be shown on the left of the notification view
 * in place of the {@link #setSmallIcon(Icon) small icon} (which will be placed in a small
 * badge atop the large icon).
 */
","/**
 * Add a large icon to the notification content view.
 *
 * In the platform template, this image will be shown on the left of the notification view
 * in place of the {@link #setSmallIcon(Icon) small icon} (which will be placed in a small
 * badge atop the large icon).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment statement has changed and an additional operation is added to put the icon in the extras. The return type and value have not changed and there are no changes in exception handling, so the code change type is 4.","There is no compatibility issue caused by these changes since they do not affect the method's return value or the exceptions it might throw but only change how the large icon is internally stored in the notification, so the CI type is 0."
964,<android.view.ViewRootImpl.SyntheticTrackballHandler: void process(MotionEvent)>,23,24,<android.view.ViewRootImpl.SyntheticTrackballHandler: void process(MotionEvent)>,<android.view.ViewRootImpl.SyntheticTrackballHandler: void process(MotionEvent)>,0,"{
    // Translate the trackball event into DPAD keys and try to deliver those.
    long curTime = SystemClock.uptimeMillis();
    if ((mLastTime + MAX_TRACKBALL_DELAY) < curTime) {
        // It has been too long since the last movement,
        // so restart at the beginning.
        mX.reset(0);
        mY.reset(0);
        mLastTime = curTime;
    }
    final int action = event.getAction();
    final int metaState = event.getMetaState();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            mX.reset(2);
            mY.reset(2);
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_CENTER, 0, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
            break;
        case MotionEvent.ACTION_UP:
            mX.reset(2);
            mY.reset(2);
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DPAD_CENTER, 0, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
            break;
    }
    if (DEBUG_TRACKBALL)
        Log.v(TAG, ""TB X="" + mX.position + "" step="" + mX.step + "" dir="" + mX.dir + "" acc="" + mX.acceleration + "" move="" + event.getX() + "" / Y="" + mY.position + "" step="" + mY.step + "" dir="" + mY.dir + "" acc="" + mY.acceleration + "" move="" + event.getY());
    final float xOff = mX.collect(event.getX(), event.getEventTime(), ""X"");
    final float yOff = mY.collect(event.getY(), event.getEventTime(), ""Y"");
    // Generate DPAD events based on the trackball movement.
    // We pick the axis that has moved the most as the direction of
    // the DPAD.  When we generate DPAD events for one axis, then the
    // other axis is reset -- we don't want to perform DPAD jumps due
    // to slight movements in the trackball when making major movements
    // along the other axis.
    int keycode = 0;
    int movement = 0;
    float accel = 1;
    if (xOff > yOff) {
        movement = mX.generate();
        if (movement != 0) {
            keycode = movement > 0 ? KeyEvent.KEYCODE_DPAD_RIGHT : KeyEvent.KEYCODE_DPAD_LEFT;
            accel = mX.acceleration;
            mY.reset(2);
        }
    } else if (yOff > 0) {
        movement = mY.generate();
        if (movement != 0) {
            keycode = movement > 0 ? KeyEvent.KEYCODE_DPAD_DOWN : KeyEvent.KEYCODE_DPAD_UP;
            accel = mY.acceleration;
            mX.reset(2);
        }
    }
    if (keycode != 0) {
        if (movement < 0)
            movement = -movement;
        int accelMovement = (int) (movement * accel);
        if (DEBUG_TRACKBALL)
            Log.v(TAG, ""Move: movement="" + movement + "" accelMovement="" + accelMovement + "" accel="" + accel);
        if (accelMovement > movement) {
            if (DEBUG_TRACKBALL)
                Log.v(TAG, ""Delivering fake DPAD: "" + keycode);
            movement--;
            int repeatCount = accelMovement - movement;
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_MULTIPLE, keycode, repeatCount, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
        }
        while (movement > 0) {
            if (DEBUG_TRACKBALL)
                Log.v(TAG, ""Delivering fake DPAD: "" + keycode);
            movement--;
            curTime = SystemClock.uptimeMillis();
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_DOWN, keycode, 0, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_UP, keycode, 0, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
        }
        mLastTime = curTime;
    }
}","{
    // Translate the trackball event into DPAD keys and try to deliver those.
    long curTime = SystemClock.uptimeMillis();
    if ((mLastTime + MAX_TRACKBALL_DELAY) < curTime) {
        // It has been too long since the last movement,
        // so restart at the beginning.
        mX.reset(0);
        mY.reset(0);
        mLastTime = curTime;
    }
    final int action = event.getAction();
    final int metaState = event.getMetaState();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            mX.reset(2);
            mY.reset(2);
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_CENTER, 0, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
            break;
        case MotionEvent.ACTION_UP:
            mX.reset(2);
            mY.reset(2);
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DPAD_CENTER, 0, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
            break;
    }
    if (DEBUG_TRACKBALL)
        Log.v(mTag, ""TB X="" + mX.position + "" step="" + mX.step + "" dir="" + mX.dir + "" acc="" + mX.acceleration + "" move="" + event.getX() + "" / Y="" + mY.position + "" step="" + mY.step + "" dir="" + mY.dir + "" acc="" + mY.acceleration + "" move="" + event.getY());
    final float xOff = mX.collect(event.getX(), event.getEventTime(), ""X"");
    final float yOff = mY.collect(event.getY(), event.getEventTime(), ""Y"");
    // Generate DPAD events based on the trackball movement.
    // We pick the axis that has moved the most as the direction of
    // the DPAD.  When we generate DPAD events for one axis, then the
    // other axis is reset -- we don't want to perform DPAD jumps due
    // to slight movements in the trackball when making major movements
    // along the other axis.
    int keycode = 0;
    int movement = 0;
    float accel = 1;
    if (xOff > yOff) {
        movement = mX.generate();
        if (movement != 0) {
            keycode = movement > 0 ? KeyEvent.KEYCODE_DPAD_RIGHT : KeyEvent.KEYCODE_DPAD_LEFT;
            accel = mX.acceleration;
            mY.reset(2);
        }
    } else if (yOff > 0) {
        movement = mY.generate();
        if (movement != 0) {
            keycode = movement > 0 ? KeyEvent.KEYCODE_DPAD_DOWN : KeyEvent.KEYCODE_DPAD_UP;
            accel = mY.acceleration;
            mX.reset(2);
        }
    }
    if (keycode != 0) {
        if (movement < 0)
            movement = -movement;
        int accelMovement = (int) (movement * accel);
        if (DEBUG_TRACKBALL)
            Log.v(mTag, ""Move: movement="" + movement + "" accelMovement="" + accelMovement + "" accel="" + accel);
        if (accelMovement > movement) {
            if (DEBUG_TRACKBALL)
                Log.v(mTag, ""Delivering fake DPAD: "" + keycode);
            movement--;
            int repeatCount = accelMovement - movement;
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_MULTIPLE, keycode, repeatCount, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
        }
        while (movement > 0) {
            if (DEBUG_TRACKBALL)
                Log.v(mTag, ""Delivering fake DPAD: "" + keycode);
            movement--;
            curTime = SystemClock.uptimeMillis();
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_DOWN, keycode, 0, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
            enqueueInputEvent(new KeyEvent(curTime, curTime, KeyEvent.ACTION_UP, keycode, 0, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FALLBACK, InputDevice.SOURCE_KEYBOARD));
        }
        mLastTime = curTime;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
966,<android.app.Fragment: void performPause()>,23,24,<android.app.Fragment: void performPause()>,<android.app.Fragment: void performPause()>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchPause();
    }
    mCalled = false;
    onPause();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onPause()"");
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchPause();
    }
    mState = STARTED;
    mCalled = false;
    onPause();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onPause()"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version adds a statement ""mState = STARTED;"" which is a change but does not alter any return values or the exception being thrown, so the code change type is 4.","There is no Compatibility Issue because the change in state assignment does not affect the return values or exceptions of the `performPause()` method; the behavior from the perspective of an API consumer should remain unchanged. Thus, there is no CI."
967,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",23,24,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mode, ""mode"");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mode, ""mode"");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                unstableProvider = null;
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,,,,
968,<android.content.pm.LauncherActivityInfo: long getFirstInstallTime()>,23,24,<android.content.pm.LauncherActivityInfo: long getFirstInstallTime()>,<android.content.pm.LauncherActivityInfo: long getFirstInstallTime()>,0,"{
    return mFirstInstallTime;
}","{
    try {
        return mPm.getPackageInfo(mActivityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
    } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        return 0;
    }
}",1,"/**
 * Returns the time at which the package was first installed.
 *
 * @return The time of installation of the package, in milliseconds.
 */
","/**
 * Returns the time at which the package was first installed.
 *
 * @return The time of installation of the package, in milliseconds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method of obtaining the first install time has changed from directly returning a member variable (mFirstInstallTime) to making a call to the PackageManager's getPackageInfo method. This change inherently results in a change in the return statement and also a potential change in the dependent API, so the code change types are 1 and 5.","Since the late version of the API no longer directly returns the member variable but instead calls a different method that could potentially yield a different result (or return 0 in case of an exception), there is likely to be a different return value. This represents a potential compatibility issue because the behavior of the method has changed, and therefore, the CI type is 1."
969,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",23,24,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.query(mPackageName, url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mPackageName, url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        if (""com.google.android.gms"".equals(mPackageName)) {
            // They're casting to a concrete subclass, sigh
            return cursor;
        } else {
            return new CursorWrapperInner(cursor);
        }
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
","/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version introduces new control flow statements that check if `cursor` is null and if `mPackageName` equals ""com.google.android.gms"", and conditionally wraps the returned cursor in a `CursorWrapperInner`. This means there are changes both to the control dependency (3), and a structure change within the try block without changing its control flow, characterized as other statement change (4).","The potential change in the return type of the `query` function from the base `Cursor` object to a `CursorWrapperInner` object represents a Compatibility Issue as it changes the type of the object that this method returns. If any calling code is depending on receiving a base `Cursor` object and not a `CursorWrapper`, it may cause class cast exceptions. Thus, the CI type is 1 due to the potential for different return types."
970,<android.content.res.Resources: String getResourceEntryName(int)>,23,24,<android.content.res.Resources: String getResourceEntryName(int)>,<android.content.res.Resources: String getResourceEntryName(int)>,0,"{
    String str = mAssets.getResourceEntryName(resid);
    if (str != null)
        return str;
    throw new NotFoundException(""Unable to find resource ID #0x"" + Integer.toHexString(resid));
}","{
    return mResourcesImpl.getResourceEntryName(resid);
}",1,"/**
 * Return the entry name for a given resource identifier.
 *
 * @param resid The resource identifier whose entry name is to be
 * retrieved.
 *
 * @return A string holding the entry name of the resource.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getResourceName
 */
","/**
 * Return the entry name for a given resource identifier.
 *
 * @param resid The resource identifier whose entry name is to be
 * retrieved.
 *
 * @return A string holding the entry name of the resource.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getResourceName
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method getResourceEntryName() inside the implementation has changed from calling `mAssets.getResourceEntryName(resid)` to `mResourcesImpl.getResourceEntryName(resid)`, which is a dependent API change. Additionally, the conditional check and the throw statement have been removed, leading to changes in the return statement. Consequently, both dependent API and return statement changes are present, so the change types are 1 and 5.","Since the internal implementation now calls a different method (`mResourcesImpl.getResourceEntryName(resid)` instead of `mAssets.getResourceEntryName(resid)`) and the conditional check for null with the associated throw statement has been removed, it can lead to different return values or types. This constitutes a compatibility issue due to the potential different return values or types, so the CI type is 1."
971,"<android.os.Parcel: void readException(int,String)>",23,24,"<android.os.Parcel: void readException(int,String)>","<android.os.Parcel: void readException(int,String)>",0,"{
    switch(code) {
        case EX_SECURITY:
            throw new SecurityException(msg);
        case EX_BAD_PARCELABLE:
            throw new BadParcelableException(msg);
        case EX_ILLEGAL_ARGUMENT:
            throw new IllegalArgumentException(msg);
        case EX_NULL_POINTER:
            throw new NullPointerException(msg);
        case EX_ILLEGAL_STATE:
            throw new IllegalStateException(msg);
        case EX_NETWORK_MAIN_THREAD:
            throw new NetworkOnMainThreadException();
        case EX_UNSUPPORTED_OPERATION:
            throw new UnsupportedOperationException(msg);
    }
    throw new RuntimeException(""Unknown exception code: "" + code + "" msg "" + msg);
}","{
    switch(code) {
        case EX_SECURITY:
            throw new SecurityException(msg);
        case EX_BAD_PARCELABLE:
            throw new BadParcelableException(msg);
        case EX_ILLEGAL_ARGUMENT:
            throw new IllegalArgumentException(msg);
        case EX_NULL_POINTER:
            throw new NullPointerException(msg);
        case EX_ILLEGAL_STATE:
            throw new IllegalStateException(msg);
        case EX_NETWORK_MAIN_THREAD:
            throw new NetworkOnMainThreadException();
        case EX_UNSUPPORTED_OPERATION:
            throw new UnsupportedOperationException(msg);
        case EX_SERVICE_SPECIFIC:
            throw new ServiceSpecificException(readInt(), msg);
    }
    throw new RuntimeException(""Unknown exception code: "" + code + "" msg "" + msg);
}",1,"/**
 * Throw an exception with the given message. Not intended for use
 * outside the Parcel class.
 *
 * @param code Used to determine which exception class to throw.
 * @param msg The exception message.
 */
","/**
 * Throw an exception with the given message. Not intended for use
 * outside the Parcel class.
 *
 * @param code Used to determine which exception class to throw.
 * @param msg The exception message.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The late version of the method includes a new case statement for a new exception code (EX_SERVICE_SPECIFIC) and the associated throw of a new exception (ServiceSpecificException), which makes both a new exception handling statement and changes in the dependent API (readInt method call) as part of the switch-case. So, the code change types are 2 for exception handling statement changed and 5 for dependent API changed.","The introduction of a new exception type (ServiceSpecificException) can potentially cause a different exception to be thrown when the service-specific error code is passed to the method, leading to different exception handling behavior in client code that uses this API. Thus, the CI type is 2."
972,"<android.text.method.BaseKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>",23,24,"<android.text.method.BaseKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>","<android.text.method.BaseKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>",0,"{
    boolean handled;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DEL:
            handled = backspace(view, content, keyCode, event);
            break;
        case KeyEvent.KEYCODE_FORWARD_DEL:
            handled = forwardDelete(view, content, keyCode, event);
            break;
        default:
            handled = false;
            break;
    }
    if (handled) {
        adjustMetaAfterKeypress(content);
    }
    return super.onKeyDown(view, content, keyCode, event);
}","{
    boolean handled;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DEL:
            handled = backspace(view, content, keyCode, event);
            break;
        case KeyEvent.KEYCODE_FORWARD_DEL:
            handled = forwardDelete(view, content, keyCode, event);
            break;
        default:
            handled = false;
            break;
    }
    if (handled) {
        adjustMetaAfterKeypress(content);
        return true;
    }
    return super.onKeyDown(view, content, keyCode, event);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"A new return statement (`return true;`) has been added inside the `if (handled)` block, and the control dependency has changed because the execution path can now end in this block instead of reaching the super class onKeyDown method. This means the type of change is 3 and 1.","The addition of `return true;` within the `if (handled)` block can lead to a different return value when the condition is met, which can cause a compatibility issue since the method will not call `super.onKeyDown` as in the earlier version. Thus, the CI type is 1."
973,"<android.app.admin.DevicePolicyManager: void setScreenCaptureDisabled(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setScreenCaptureDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setScreenCaptureDisabled(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setScreenCaptureDisabled(admin, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setScreenCaptureDisabled"");
    if (mService != null) {
        try {
            mService.setScreenCaptureDisabled(admin, disabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a device/profile owner to set whether the screen capture is disabled. Disabling
 * screen capture also prevents the content from being shown on display devices that do not have
 * a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about
 * secure surfaces and secure displays.
 *
 * <p>The calling device admin must be a device or profile owner. If it is not, a
 * security exception will be thrown.
 *
 * <p>From version {@link android.os.Build.VERSION_CODES#M} disabling screen capture also
 * blocks assist requests for all activities of the relevant user.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether screen capture is disabled or not.
 */
","/**
 * Called by a device/profile owner to set whether the screen capture is disabled. Disabling
 * screen capture also prevents the content from being shown on display devices that do not have
 * a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about
 * secure surfaces and secure displays.
 * <p>
 * The calling device admin must be a device or profile owner. If it is not, a security
 * exception will be thrown.
 * <p>
 * From version {@link android.os.Build.VERSION_CODES#M} disabling screen capture also blocks
 * assist requests for all activities of the relevant user.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether screen capture is disabled or not.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is a new exception handling statement introduced (throwIfParentInstance(""setScreenCaptureDisabled"")), and the exception handling has changed from logging a message to throwing an exception (throw e.rethrowFromSystemServer()), hence the type of change is 2,4.","The addition of a throw statement at the beginning of the method could potentially result in a new RuntimeException being thrown if the condition inside 'throwIfParentInstance' is met, which wasn't thrown in the earlier version, and the change in the exception handling (from logging an exception to throwing it) will cause it to throw an exception where it previously wouldn't have, so the Compatibility Issue is of type 2."
978,<android.app.ActivityManager: AppTask> getAppTasks()>,23,24,<android.app.ActivityManager: AppTask> getAppTasks()>,<android.app.ActivityManager: AppTask> getAppTasks()>,0,"{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IAppTask> appTasks;
    try {
        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(appTasks.get(i)));
    }
    return tasks;
}","{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IAppTask> appTasks;
    try {
        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(appTasks.get(i)));
    }
    return tasks;
}",1,"/**
 * Get the list of tasks associated with the calling application.
 *
 * @return The list of tasks associated with the application making this call.
 * @throws SecurityException
 */
","/**
 * Get the list of tasks associated with the calling application.
 *
 * @return The list of tasks associated with the application making this call.
 * @throws SecurityException
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has been changed, replacing a return null with a throw statement, so the code change type is 2.","Because the handling of RemoteException has been changed from returning null to throwing a newly created exception, the behavior in case of a RemoteException is altered. As a result, this could lead to a situation where the late version of the API throws an exception instead of returning null, constituting a Compatibility Issue of type 2."
979,<android.app.ActivityOptions: Bundle toBundle()>,23,24,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}","{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putInt(KEY_LAUNCH_STACK_ID, mLaunchStackId);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putInt(KEY_DOCK_CREATE_MODE, mDockCreateMode);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
980,<android.os.PowerManager: boolean isPowerSaveMode()>,23,24,<android.os.PowerManager: boolean isPowerSaveMode()>,<android.os.PowerManager: boolean isPowerSaveMode()>,0,"{
    try {
        return mService.isPowerSaveMode();
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return mService.isPowerSaveMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
","/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"There is an exception handling statement changed; the 'catch' block no longer returns false and instead throws the exception, so the code change type is 2.","With the new 'catch' block behavior, an exception will now be thrown rather than the method returning false. This change might lead to a different exception handling situation in the code that calls this API. Therefore, a Compatibility Issue could arise due to the potential different exception handling, making the CI type 2."
982,<android.app.AlarmManager: void cancel(PendingIntent)>,23,24,<android.app.AlarmManager: void cancel(PendingIntent)>,<android.app.AlarmManager: void cancel(PendingIntent)>,0,"{
    try {
        mService.remove(operation);
    } catch (RemoteException ex) {
    }
}","{
    if (operation == null) {
        final String msg = ""cancel() called with a null PendingIntent"";
        if (mTargetSdkVersion >= Build.VERSION_CODES.N) {
            throw new NullPointerException(msg);
        } else {
            Log.e(TAG, msg);
            return;
        }
    }
    try {
        mService.remove(operation, null);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Remove any alarms with a matching {@link Intent}.
 * Any alarm, of any type, whose Intent matches this one (as defined by
 * {@link Intent#filterEquals}), will be canceled.
 *
 * @param operation IntentSender which matches a previously added
 * IntentSender.
 *
 * @see #set
 */
","/**
 * Remove any alarms with a matching {@link Intent}.
 * Any alarm, of any type, whose Intent matches this one (as defined by
 * {@link Intent#filterEquals}), will be canceled.
 *
 * @param operation IntentSender which matches a previously added
 * IntentSender. This parameter must not be {@code null}.
 *
 * @see #set
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","A new control structure (if-else) has been introduced, modifying the exception handling, and altering the parameter list of the method call (mService.remove(operation) changed to mService.remove(operation, null)). Along with adding logging and potential new exception throwing for a null parameter, the code change types are 1,2,3 and 4.","The new code introduces different behavior: In the late version, the method can throw a NullPointerException if the input 'operation' is null and the application's target SDK version is higher than a certain API level. Hence, it leads to a compatibility issue both in terms of different return values (when operation is null and logs error instead of throwing an exception in early version) and in terms of different exception throwing (throws NullPointerException in late version), making the CI types 1 and 2."
985,"<android.view.ViewGroup: boolean onNestedFling(View,float,float,boolean)>",23,24,"<android.view.ViewGroup: boolean onNestedFling(View,float,float,boolean)>","<android.view.ViewGroup: boolean onNestedFling(View,float,float,boolean)>",0,"{
    return false;
}","{
    // Re-dispatch up the tree by default
    return dispatchNestedFling(velocityX, velocityY, consumed);
}",1,"/**
 * @inheritDoc
 */
","/**
 * @inheritDoc
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early version always returns false, but the late version calls a new method dispatchNestedFling(velocityX, velocityY, consumed) with parameters velocityX, velocityY, and consumed, which may return a different boolean value. The change includes the return value (1), a new method call (4), and a dependent API change (5).","The modification fundamentally changes what is returned - early version always returns 'false', while the late version may return 'true' or 'false' depending on the result of dispatchNestedFling. Thus, this results in a Compatibility Issue caused by potential different return values (1)."
986,"<android.text.SpannableStringBuilder: T[] getSpans(int,int,Class<T>)>",23,24,"<android.text.SpannableStringBuilder: T[] getSpans(int,int,Class<T>)>","<android.text.SpannableStringBuilder: T[] getSpans(int,int,Class<T>)>",0,"{
    if (kind == null || mSpanCount == 0)
        return ArrayUtils.emptyArray(kind);
    int count = countSpans(queryStart, queryEnd, kind, treeRoot());
    if (count == 0) {
        return ArrayUtils.emptyArray(kind);
    }
    // Safe conversion, but requires a suppressWarning
    T[] ret = (T[]) Array.newInstance(kind, count);
    getSpansRec(queryStart, queryEnd, kind, treeRoot(), ret, 0);
    return ret;
}","{
    return getSpans(queryStart, queryEnd, kind, true);
}",1,"/**
 * Return an array of the spans of the specified type that overlap
 * the specified range of the buffer.  The kind may be Object.class to get
 * a list of all the spans regardless of type.
 */
","/**
 * Return an array of the spans of the specified type that overlap
 * the specified range of the buffer.  The kind may be Object.class to get
 * a list of all the spans regardless of type.
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,5,1,"The later version of the method is invoking a different (potentially overloaded) method with an additional boolean parameter instead of the original logic, so the code change type is 5.","Since the dependent API is invoking a method that has a different signature (additional parameter), it's unclear if the behavior remains identical without more context. The change could potentially return a different value or type, and the CI type is 1."
987,"<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>",23,24,"<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>","<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>",0,"{
    // On restore, we also support a previous data schema ""system_files""
    addHelper(WALLPAPER_HELPER, new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO }, new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY }));
    addHelper(""system_files"", new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE }, new String[] { WALLPAPER_IMAGE_KEY }));
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    try {
        super.onRestore(data, appVersionCode, newState);
        IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
        if (wallpaper != null) {
            try {
                wallpaper.settingsRestored();
            } catch (RemoteException re) {
                Slog.e(TAG, ""Couldn't restore settings\n"" + re);
            }
        }
    } catch (IOException ex) {
        // If there was a failure, delete everything for the wallpaper, this is too aggressive,
        // but this is hopefully a rare failure.
        Slog.d(TAG, ""restore failed"", ex);
        (new File(WALLPAPER_IMAGE)).delete();
        (new File(WALLPAPER_INFO)).delete();
    }
}","{
    // Slot in a restore helper for the older wallpaper backup schema to support restore
    // from devices still generating data in that format.
    mWallpaperHelper = new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO }, new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY });
    addHelper(WALLPAPER_HELPER, mWallpaperHelper);
    // On restore, we also support a long-ago wallpaper data schema ""system_files""
    addHelper(""system_files"", new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE }, new String[] { WALLPAPER_IMAGE_KEY }));
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    addHelper(PERMISSION_HELPER, new PermissionBackupHelper());
    addHelper(USAGE_STATS_HELPER, new UsageStatsBackupHelper(this));
    addHelper(SHORTCUT_MANAGER_HELPER, new ShortcutBackupHelper());
    try {
        super.onRestore(data, appVersionCode, newState);
        IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
        if (wallpaper != null) {
            try {
                wallpaper.settingsRestored();
            } catch (RemoteException re) {
                Slog.e(TAG, ""Couldn't restore settings\n"" + re);
            }
        }
    } catch (IOException ex) {
        // If there was a failure, delete everything for the wallpaper, this is too aggressive,
        // but this is hopefully a rare failure.
        Slog.d(TAG, ""restore failed"", ex);
        (new File(WALLPAPER_IMAGE)).delete();
        (new File(WALLPAPER_INFO)).delete();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There are new backup helpers added for PERMISSION_HELPER, USAGE_STATS_HELPER, and SHORTCUT_MANAGER_HELPER. The construction of mWallpaperHelper was also changed slightly, but its purpose is the same. These changes do not affect return statements, exception handling, control flow, or dependent APIs. Therefore, the code change type is 4 (Other statement changed).","These changes do not alter how exceptions are handled nor do they alter the return values of the method since the additions are related to backup helpers which do not influence the output of the onRestore method itself. No Compatibility Issue arises from these changes, so the CI type is 0 (No Compatibility Issue)."
989,<android.view.View: boolean onTouchEvent(MotionEvent)>,23,24,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
990,"<android.content.res.TypedArray: int getColor(int,int)>",23,24,"<android.content.res.TypedArray: int getColor(int,int)>","<android.content.res.TypedArray: int getColor(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to color: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to color: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
","/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",-1,[@ColorInt],[@ColorInt],-1,-1,-1,-1,-1,-1,4,0,"The change encompasses adding a new local variable (final int attrIndex = index) and updating the thrown exception messages with the correct attribute index variable. Since these changes do not affect the return type, value, or control flow, the code change type is 4.","None of the changes made in the late implementation affect the behavior of the API in terms of return values or the types of exceptions thrown. Hence, there is no Compatibility Issue; pred_CI is 0."
991,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,23,24,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,0,"{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner(null, 0, 0, 0);
}","{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner(InputMethodClient.START_INPUT_REASON_APP_CALLED_RESTART_INPUT_API, null, 0, 0, 0);
}",1,"/**
 * If the input method is currently connected to the given view,
 * restart it with its new contents.  You should call this when the text
 * within your view changes outside of the normal input method or key
 * input flow, such as when an application calls TextView.setText().
 *
 * @param view The view whose text has changed.
 */
","/**
 * If the input method is currently connected to the given view,
 * restart it with its new contents.  You should call this when the text
 * within your view changes outside of the normal input method or key
 * input flow, such as when an application calls TextView.setText().
 *
 * @param view The view whose text has changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method startInputInner() now includes an additional parameter (InputMethodClient.START_INPUT_REASON_APP_CALLED_RESTART_INPUT_API) in its invocation, and there's a change in the method signature (from 3 to 4 parameters), so the code change types are 1,4.","Because of the addition of a new argument in the method startInputInner() call, the behavior of that method could potentially change, therefore the API may behave differently, and the CI type is 1."
992,<android.util.ArrayMap: int indexOfKey(Object)>,23,24,<android.util.ArrayMap: int indexOfKey(Object)>,<android.util.ArrayMap: int indexOfKey(Object)>,0,"{
    return key == null ? indexOfNull() : indexOf(key, key.hashCode());
}","{
    return key == null ? indexOfNull() : indexOf(key, mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());
}",1,"/**
 * Returns the index of a key in the set.
 *
 * @param key The key to search for.
 * @return Returns the index of the key if it exists, else a negative integer.
 */
","/**
 * Returns the index of a key in the set.
 *
 * @param key The key to search for.
 * @return Returns the index of the key if it exists, else a negative integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The way the hash code is calculated has been updated, by introducing a conditional use of either the identity hash code or the object's hash code based on the mIdentityHashCode boolean field. This change does not affect the method's control flow, but it does change how a value is computed within the method. Therefore, the change type is 4.","There should be no Compatibility Issue with existing code, assuming the contract that objects that are equal must have the same hash code is maintained. The objects that previously relied on `hashCode()` will continue to do so unless the `mIdentityHashCode` flag changes that behavior, but this is an internal change that should not affect the semantics of `indexOfKey(Object)`. Thus, the change should not lead to different behaviors from the perspective of the method's API contract, so the CI type is 0."
994,<android.app.ActivityManager: PendingIntent getRunningServiceControlPanel(ComponentName)>,23,24,<android.app.ActivityManager: PendingIntent getRunningServiceControlPanel(ComponentName)>,<android.app.ActivityManager: PendingIntent getRunningServiceControlPanel(ComponentName)>,0,"{
    try {
        return ActivityManagerNative.getDefault().getRunningServiceControlPanel(service);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getRunningServiceControlPanel(service);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a PendingIntent you can start to show a control panel for the
 * given running service.  If the service does not have a control panel,
 * null is returned.
 */
","/**
 * Returns a PendingIntent you can start to show a control panel for the
 * given running service.  If the service does not have a control panel,
 * null is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The change is that a new throw statement is introduced in the catch block, so the change type is 2.","Since the late version throws an exception where the early version was returning null, the method will throw a different exception in the two versions, and the CI type is 2."
995,<android.view.View: String toString()>,23,24,<android.view.View: String toString()>,<android.view.View: String toString()>,0,"{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE_MASK) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append((mViewFlags & CONTEXT_CLICKABLE) != 0 ? 'X' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    out.append(""}"");
    return out.toString();
}","{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE_MASK) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append((mViewFlags & CONTEXT_CLICKABLE) != 0 ? 'X' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (id > 0 && Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    out.append(""}"");
    return out.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
997,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,23,24,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.cancelDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Cancel the current device discovery process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
","/**
 * Cancel the current device discovery process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change introduces a read lock mechanism around the service call with mServiceLock.readLock().lock() and mServiceLock.readLock().unlock(). So the code change type falls under 3,4 due to the addition of a locking mechanism and try-finally blocks without affecting the current control flow.","The introduction of the read lock mechanism does not alter the behavior of how the method cancelDiscovery() works or its return statements. As there are no changes to the return statements, exception throws, or the conditions under which these might be invoked, there is no Compatibility Issue. The return statements and the exception handling remains the same, thus leading to equivalent method behavior from the perspective of the caller."
998,<android.printservice.PrintService: PrinterId generatePrinterId(String)>,23,24,<android.printservice.PrintService: PrinterId generatePrinterId(String)>,<android.printservice.PrintService: PrinterId generatePrinterId(String)>,0,"{
    throwIfNotCalledOnMainThread();
    return new PrinterId(new ComponentName(getPackageName(), getClass().getName()), localId);
}","{
    throwIfNotCalledOnMainThread();
    localId = Preconditions.checkNotNull(localId, ""localId cannot be null"");
    return new PrinterId(new ComponentName(getPackageName(), getClass().getName()), localId);
}",1,"/**
 * Generates a global printer id given the printer's locally unique one.
 *
 * @param localId A locally unique id in the context of your print service.
 * @return Global printer id.
 */
","/**
 * Generates a global printer id given the printer's locally unique one.
 *
 * @param localId A locally unique id in the context of your print service.
 * @return Global printer id.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",1,"The late version adds a precondition check for the `localId` parameter to ensure it is not null, which is a change in other statement, and also indirectly a dependent API change since `Preconditions.checkNotNull` is from the Android framework's utility classes. The code change type is 4,5.","Introducing a precondition check for `localId` means that if `localId` is passed as null, it will throw a `NullPointerException`. This is a change in the method's contract in that the early version would not have thrown this exception explicitly for a null `localId`. Therefore, there is a potential compatibility issue caused by a different exception being thrown, and potentially different return values if `localId` were null, due to the generation of `PrinterId` being dependent on the non-null `localId`. The CI type is 1."
999,<android.app.Service: void stopForeground(boolean)>,23,24,<android.app.Service: void stopForeground(boolean)>,<android.app.Service: void stopForeground(boolean)>,0,"{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, 0, null, removeNotification);
    } catch (RemoteException ex) {
    }
}","{
    stopForeground(removeNotification ? STOP_FOREGROUND_REMOVE : 0);
}",1,"/**
 * Remove this service from foreground state, allowing it to be killed if
 * more memory is needed.
 * @param removeNotification If true, the notification previously provided
 * to {@link #startForeground} will be removed.  Otherwise it will remain
 * until a later call removes it (or the service is destroyed).
 * @see #startForeground(int, Notification)
 */
","/**
 * Synonym for {@link #stopForeground(int)}.
 * @param removeNotification If true, the {@link #STOP_FOREGROUND_REMOVE} flag
 * will be supplied.
 * @see #stopForeground(int)
 * @see #startForeground(int, Notification)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation changed from directly calling `mActivityManager.setServiceForeground` to calling a different method `stopForeground` with conditional logic on its argument, so the code change type is 4,5.","There is no Compatibility Issue detected, assuming the internal `stopForeground` method being called in the late version simply wraps around the original implementation with appropriate argument translation. There is no apparent difference in exception handling or return values since there were none to begin with in the early version, therefore the CI type is 0."
1002,<android.os.Debug.MemoryInfo: int getTotalPss()>,23,24,<android.os.Debug.MemoryInfo: int getTotalPss()>,<android.os.Debug.MemoryInfo: int getTotalPss()>,0,"{
    return dalvikPss + nativePss + otherPss;
}","{
    return dalvikPss + nativePss + otherPss + getTotalSwappedOutPss();
}",1,"/**
 * Return total PSS memory usage in kB.
 */
","/**
 * Return total PSS memory usage in kB.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"There is an addition of a method call (getTotalSwappedOutPss()) to the return statement in the late version, which is a type of 'Other statement changed' (code change type 4).","Due to the added method call in the return statement, the late version can potentially return a higher value than the early version of getTotalPss(). Thus, there is a Compatibility Issue due to the potential for different return values (CI type 1)."
1004,"<android.widget.ListPopupWindow: boolean onKeyDown(int,KeyEvent)>",23,24,"<android.widget.ListPopupWindow: boolean onKeyDown(int,KeyEvent)>","<android.widget.ListPopupWindow: boolean onKeyDown(int,KeyEvent)>",0,"{
    // when the drop down is shown, we drive it directly
    if (isShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || !KeyEvent.isConfirmKey(keyCode))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            final ListAdapter adapter = mAdapter;
            boolean allEnabled;
            int firstItem = Integer.MAX_VALUE;
            int lastItem = Integer.MIN_VALUE;
            if (adapter != null) {
                allEnabled = adapter.areAllItemsEnabled();
                firstItem = allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0, true);
                lastItem = allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
            }
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                show();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.mListSelectionHidden = false;
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, ""Key down: code="" + keyCode + "" list consumed="" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                show();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // event to avoid going to the next focusable widget
                    if (curIndex == lastItem) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    // when the drop down is shown, we drive it directly
    if (isShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || !KeyEvent.isConfirmKey(keyCode))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            final ListAdapter adapter = mAdapter;
            boolean allEnabled;
            int firstItem = Integer.MAX_VALUE;
            int lastItem = Integer.MIN_VALUE;
            if (adapter != null) {
                allEnabled = adapter.areAllItemsEnabled();
                firstItem = allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0, true);
                lastItem = allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
            }
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                show();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.setListSelectionHidden(false);
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, ""Key down: code="" + keyCode + "" list consumed="" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                show();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // event to avoid going to the next focusable widget
                    if (curIndex == lastItem) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                    return true;
                }
            }
        }
    }
    return false;
}",1,"/**
 * Filter key down events. By forwarding key down events to this function,
 * views using non-modal ListPopupWindow can have it handle key selection of items.
 *
 * @param keyCode keyCode param passed to the host view's onKeyDown
 * @param event event param passed to the host view's onKeyDown
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 */
","/**
 * Filter key down events. By forwarding key down events to this function,
 * views using non-modal ListPopupWindow can have it handle key selection of items.
 *
 * @param keyCode keyCode param passed to the host view's onKeyDown
 * @param event event param passed to the host view's onKeyDown
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 * @see #onKeyUp(int, KeyEvent)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1005,"<android.appwidget.AppWidgetManager: void updateAppWidget(int[],RemoteViews)>",23,24,"<android.appwidget.AppWidgetManager: void updateAppWidget(int[],RemoteViews)>","<android.appwidget.AppWidgetManager: void updateAppWidget(int[],RemoteViews)>",0,"{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetIds(mPackageName, appWidgetIds, views);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetIds(mPackageName, appWidgetIds, views);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Set the RemoteViews to use for the specified appWidgetIds.
 * <p>
 * Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
 * contain a complete representation of the widget. For performing partial widget updates, see
 * {@link #partiallyUpdateAppWidget(int[], RemoteViews)}.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * The total Bitmap memory used by the RemoteViews object cannot exceed that required to
 * fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
 *
 * @param appWidgetIds The AppWidget instances for which to set the RemoteViews.
 * @param views The RemoteViews object to show.
 */
","/**
 * Set the RemoteViews to use for the specified appWidgetIds.
 * <p>
 * Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
 * contain a complete representation of the widget. For performing partial widget updates, see
 * {@link #partiallyUpdateAppWidget(int[], RemoteViews)}.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * The total Bitmap memory used by the RemoteViews object cannot exceed that required to
 * fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
 *
 * @param appWidgetIds The AppWidget instances for which to set the RemoteViews.
 * @param views The RemoteViews object to show.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing the result of e.rethrowFromSystemServer(), so the change type is 2.","The change to how RemoteException is handled represents a difference in the exception that could be thrown to consumers of the API. Since a different type of exception can alter the control flow and client's error handling, this constitutes a potential compatibility issue, so the CI type is 2."
1006,<android.view.ContextThemeWrapper: Resources getResources()>,23,24,<android.view.ContextThemeWrapper: Resources getResources()>,<android.view.ContextThemeWrapper: Resources getResources()>,0,"{
    if (mResources != null) {
        return mResources;
    }
    if (mOverrideConfiguration == null) {
        mResources = super.getResources();
        return mResources;
    } else {
        Context resc = createConfigurationContext(mOverrideConfiguration);
        mResources = resc.getResources();
        return mResources;
    }
}","{
    return getResourcesInternal();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation in the late version delegates to ""getResourcesInternal()"", which suggests that the logic from the early version may have been moved into this method. Thus, the change classification is 5 for Dependent API Changed.","Provided that the entire implementation is replaced with a call to another method, this could be a refactoring that doesn't necessarily change the external behavior. Since no further details about the ""getResourcesInternal()"" method are provided, we can't definitively conclude whether there is a compatibility issue based on behaviors like returning different values or exception handling. The change appears to be internal refactoring, hence no compatibility issue is presumed without evidence to the contrary."
1007,<android.print.PrintManager: void restartPrintJob(PrintJobId)>,23,24,<android.print.PrintManager: void restartPrintJob(PrintJobId)>,<android.print.PrintManager: void restartPrintJob(PrintJobId)>,0,"{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return;
    }
    try {
        mService.restartPrintJob(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error restarting a print job: "" + printJobId, re);
    }
}","{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return;
    }
    try {
        mService.restartPrintJob(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"An existing exception handling statement has been changed from logging the error to throwing an exception with 'throw re.rethrowFromSystemServer()', so the change type is 2.","The change in exception handling could lead to different behavior when an exception occurs, as the new version throws the error rather than logging it. This change may affect the callers of the method who have to handle or expect a different exception handling strategy. Therefore, the CI type is 2."
1008,<android.view.inputmethod.InputConnectionWrapper: void setTarget(InputConnection)>,23,24,<android.view.inputmethod.InputConnectionWrapper: void setTarget(InputConnection)>,<android.view.inputmethod.InputConnectionWrapper: void setTarget(InputConnection)>,0,"{
    if (mTarget != null && !mMutable) {
        throw new SecurityException(""not mutable"");
    }
    mTarget = target;
}","{
    if (mTarget != null && !mMutable) {
        throw new SecurityException(""not mutable"");
    }
    mTarget = target;
    mMissingMethodFlags = InputConnectionInspector.getMissingMethodFlags(target);
}",1,"/**
 * Change the target of the input connection.
 */
","/**
 * Change the target of the input connection.
 *
 * <p><b>Caveat:</b> Although the system can accept {@code (InputConnection) null} in some
 * places, you cannot emulate such a behavior by non-null {@link InputConnectionWrapper} that
 * has {@code null} in {@code target}.</p>
 * @param target the {@link InputConnection} to be proxied.
 * @throws SecurityException when this wrapper has non-null target and is immutable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"An additional statement is introduced in the late version to set `mMissingMethodFlags` which relies on another method `InputConnectionInspector.getMissingMethodFlags(target)`, so the code change types are 4 (Other statement changed) and 5 (Dependent API changed).","The added statement directly assigns a value to `mMissingMethodFlags` but does not affect the control flow or exception handling of the API method itself. Hence, it is unlikely to cause a Compatibility Issue as per the definitions provided. Therefore, the CI type is 0 (No Compatibility Issue)."
1009,<android.widget.TimePicker: int getMinute()>,23,24,<android.widget.TimePicker: int getMinute()>,<android.widget.TimePicker: int getMinute()>,0,"{
    return mDelegate.getCurrentMinute();
}","{
    return mDelegate.getMinute();
}",1,"/**
 * Returns the currently selected minute.
 *
 * @return the currently selected minute, in the range (0-59)
 * @see #setMinute(int)
 */
","/**
 * Returns the currently selected minute.
 *
 * @return the currently selected minute, in the range (0-59)
 * @see #setMinute(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method name used in the return statement is changed from getCurrentMinute() to getMinute(). Therefore, this is a change in the dependent API, so the code change type is 5.","There is no compatibility issue if the change in the dependent API's method does not alter the behavior seen by the client of the `getMinute()` method. Assuming `getCurrentMinute()` is simply renamed to `getMinute()` without changing its functionality or contract, it should not cause a CI for the clients using `getMinute()`. Therefore, the CI type is 0."
1010,<android.widget.DatePickerCalendarDelegate: void setMaxDate(long)>,23,24,<android.widget.DatePickerCalendarDelegate: void setMaxDate(long)>,<android.widget.DatePickerCalendarDelegate: void setMaxDate(long)>,0,"{
    mTempDate.setTimeInMillis(maxDate);
    if (mTempDate.get(Calendar.YEAR) == mMaxDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMaxDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    if (mCurrentDate.after(mTempDate)) {
        mCurrentDate.setTimeInMillis(maxDate);
        onDateChanged(false, true);
    }
    mMaxDate.setTimeInMillis(maxDate);
    mDayPickerView.setMaxDate(maxDate);
    mYearPickerView.setRange(mMinDate, mMaxDate);
}","{
    mTempDate.setTimeInMillis(maxDate);
    if (mTempDate.get(Calendar.YEAR) == mMaxDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) == mMaxDate.get(Calendar.DAY_OF_YEAR)) {
        // Same day, no-op.
        return;
    }
    if (mCurrentDate.after(mTempDate)) {
        mCurrentDate.setTimeInMillis(maxDate);
        onDateChanged(false, true);
    }
    mMaxDate.setTimeInMillis(maxDate);
    mDayPickerView.setMaxDate(maxDate);
    mYearPickerView.setRange(mMinDate, mMaxDate);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The condition inside the 'if' statement that leads to an early 'return' from the method has changed. The equal comparison operation has changed from != to ==. This is a control dependency change, so the code change type is 3.","Although there is an alteration in an 'if' condition, it will not result in any compatibility issue. The change in the 'if' condition merely inverts the scenario when an early return would occur. It doesn't affect the value that would be returned by the method, nor does it alter the exceptions that would be thrown. Therefore, there's no CI in this case, and the CI type is 0."
1011,<android.widget.TabWidget: void addView(View)>,23,24,<android.widget.TabWidget: void addView(View)>,<android.widget.TabWidget: void addView(View)>,0,"{
    if (child.getLayoutParams() == null) {
        final LinearLayout.LayoutParams lp = new LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.0f);
        lp.setMargins(0, 0, 0, 0);
        child.setLayoutParams(lp);
    }
    // Ensure you can navigate to the tab with the keyboard, and you can touch it
    child.setFocusable(true);
    child.setClickable(true);
    super.addView(child);
    // TODO: detect this via geometry with a tabwidget listener rather
    // than potentially interfere with the view's listener
    child.setOnClickListener(new TabClickListener(getTabCount() - 1));
    child.setOnFocusChangeListener(this);
}","{
    if (child.getLayoutParams() == null) {
        final LinearLayout.LayoutParams lp = new LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.0f);
        lp.setMargins(0, 0, 0, 0);
        child.setLayoutParams(lp);
    }
    // Ensure you can navigate to the tab with the keyboard, and you can touch it
    child.setFocusable(true);
    child.setClickable(true);
    super.addView(child);
    // TODO: detect this via geometry with a tabwidget listener rather
    // than potentially interfere with the view's listener
    child.setOnClickListener(new TabClickListener(getTabCount() - 1));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The statement ""child.setOnFocusChangeListener(this);"" was removed, which is an ""Other statement changed"". No other types of changes are present.","The removal of setOnFocusChangeListener does not directly affect the return value or throw any new exceptions, thus no Compatibility Issue of the specified types is introduced. The API's behavior changes, but it does not lead to a CI as per the definitions given."
1014,<android.widget.AdapterViewAnimator: LayoutParams createOrReuseLayoutParams(View)>,23,24,<android.widget.AdapterViewAnimator: LayoutParams createOrReuseLayoutParams(View)>,<android.widget.AdapterViewAnimator: LayoutParams createOrReuseLayoutParams(View)>,0,"{
    final ViewGroup.LayoutParams currentLp = v.getLayoutParams();
    if (currentLp instanceof ViewGroup.LayoutParams) {
        LayoutParams lp = (LayoutParams) currentLp;
        return lp;
    }
    return new ViewGroup.LayoutParams(0, 0);
}","{
    final LayoutParams currentLp = v.getLayoutParams();
    if (currentLp != null) {
        return currentLp;
    }
    return new LayoutParams(0, 0);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The type of `currentLp` has changed from `ViewGroup.LayoutParams` to `LayoutParams` and the check has changed from an `instanceof` check to a `null` check, so the code change type is 4.","However, the actual behavior of this API does not change because the method's contract appears to remain the same: it returns existing layout parameters for a view if they exist; otherwise, it creates new ones. The changes made streamline the process but do not affect the outcome from an API consumer's point of view. Therefore, there's no Compatibility Issue."
1015,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,23,24,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,0,"{
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: "" + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        notifyInputConnectionFinished();
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}","{
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: mServedView="" + dumpViewInfo(mServedView));
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}",1,"/**
 * Disconnect any existing input connection, clearing the served view.
 */
","/**
 * Disconnect any existing input connection, clearing the served view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The exception handling statement has changed from an empty catch block to a re-throw (throw e.rethrowFromSystemServer()). There is also a change in the log message content within the Log.v call which is an other statement change, so the code change type is 2,4.","The change in exception handling will lead to a different behavior as an exception is now being thrown in the newer version whereas previously it was being caught and ignored, thus the CI type is 2."
1016,<android.os.PowerManager: void wakeUp(long)>,23,24,<android.os.PowerManager: void wakeUp(long)>,<android.os.PowerManager: void wakeUp(long)>,0,"{
    try {
        mService.wakeUp(time, ""wakeUp"", mContext.getOpPackageName());
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.wakeUp(time, ""wakeUp"", mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Forces the device to wake up from sleep.
 * <p>
 * If the device is currently asleep, wakes it up, otherwise does nothing.
 * This is what happens when the power key is pressed to turn on the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to wake up was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the wake up request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to wake up.
 *
 * @see #userActivity
 * @see #goToSleep
 *
 * @removed Requires signature permission.
 */
","/**
 * Forces the device to wake up from sleep.
 * <p>
 * If the device is currently asleep, wakes it up, otherwise does nothing.
 * This is what happens when the power key is pressed to turn on the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to wake up was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the wake up request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to wake up.
 *
 * @see #userActivity
 * @see #goToSleep
 *
 * @removed Requires signature permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling has changed from being an empty catch block to throwing an exception using throw e.rethrowFromSystemServer(), so the code change type is 2.","A new throw statement is introduced in the late version which can potentially cause the method to throw an exception rather than silently catch it, which is a behavior change from the earlier version that did not throw any exception. Therefore, the CI type is 2."
1017,<android.view.inputmethod.InputMethodManager: boolean setCurrentInputMethodSubtype(InputMethodSubtype)>,23,24,<android.view.inputmethod.InputMethodManager: boolean setCurrentInputMethodSubtype(InputMethodSubtype)>,<android.view.inputmethod.InputMethodManager: boolean setCurrentInputMethodSubtype(InputMethodSubtype)>,0,"{
    synchronized (mH) {
        try {
            return mService.setCurrentInputMethodSubtype(subtype);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
            return false;
        }
    }
}","{
    synchronized (mH) {
        try {
            return mService.setCurrentInputMethodSubtype(subtype);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Switch to a new input method subtype of the current input method.
 * @param subtype A new input method subtype to switch.
 * @return true if the current subtype was successfully switched. When the specified subtype is
 * null, this method returns false.
 */
","/**
 * Switch to a new input method subtype of the current input method.
 * @param subtype A new input method subtype to switch.
 * @return true if the current subtype was successfully switched. When the specified subtype is
 * null, this method returns false.
 */
",-1,[@RequiresPermission(WRITE_SECURE_SETTINGS)],[@RequiresPermission(WRITE_SECURE_SETTINGS)],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. In the early version, the RemoteException is caught and logged, and false is returned. In the late version, the RemoteException is rethrown as a RuntimeException by the call to rethrowFromSystemServer(), so the code change type is 2.","Due to the change in the exception handling statement, an exception that would have been caught and suppressed in the early version, resulting in a return of false, will now be thrown in the late version. This can lead to a different behavior when an exception occurs, causing potential Compatibility Issues, classified under type 2."
1018,<android.app.Notification.Builder: Builder setGroup(String)>,23,24,<android.app.Notification.Builder: Builder setGroup(String)>,<android.app.Notification.Builder: Builder setGroup(String)>,0,"{
    mGroupKey = groupKey;
    return this;
}","{
    mN.mGroupKey = groupKey;
    return this;
}",1,"/**
 * Set this notification to be part of a group of notifications sharing the same key.
 * Grouped notifications may display in a cluster or stack on devices which
 * support such rendering.
 *
 * <p>To make this notification the summary for its group, also call
 * {@link #setGroupSummary}. A sort order can be specified for group members by using
 * {@link #setSortKey}.
 * @param groupKey The group key of the group.
 * @return this object for method chaining
 */
","/**
 * Set this notification to be part of a group of notifications sharing the same key.
 * Grouped notifications may display in a cluster or stack on devices which
 * support such rendering.
 *
 * <p>To make this notification the summary for its group, also call
 * {@link #setGroupSummary}. A sort order can be specified for group members by using
 * {@link #setSortKey}.
 * @param groupKey The group key of the group.
 * @return this object for method chaining
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment statement has changed from directly modifying an instance variable 'mGroupKey' to modifying the 'mGroupKey' field of an object 'mN'. This is a change in how the property is being set; therefore, the change type is 4.","No Compatibility Issue could arise from this change because the behavior of the method setGroup(String groupKey) remains the same from the API user's perspective. The value is still being set but now on a different object 'mN' which is internal to the functionality of the API. The return value and the capability of the method are unchanged; hence, it's a non-breaking internal change."
1019,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",23,24,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>","<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",0,"{
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, Process.myUserHandle());
}","{
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), Process.myUserHandle());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The late version of the implementation adds an additional parameter (mMainThread.getHandler()) to the method call bindServiceCommon(), without changing any other control or exception handling logic, so the code change type is 5 (Dependent API changed).","Since the additional parameter doesn't alter the control flow or exception handling of the current method, and considering that bound service connections are designed to handle different inputs flexibly, the change should not lead to Compatibility Issues. The API's contract itself does not seem to be affected by this additional parameter in terms of its expected behavior for callers, so the CI type is 0 (No Compatibility Issue)."
1020,"<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>",23,24,"<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>","<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"In the late version, there's an additional parameter `this` passed to `intent.prepareToLeaveProcess(this)`. This suggests that there is a change in the dependent method `prepareToLeaveProcess`, which is now expecting an additional parameter. The code change type is 5 because of the change in the method signature of the dependent API.","While the dependent method `prepareToLeaveProcess` has changed, there is no direct indication that this change leads to a compatibility issue in terms of the behavior of `sendBroadcast`. The intent is still being broadcast with the same parameters with the addition of the context `this` which is more likely used internally within the `prepareToLeaveProcess` rather than affecting the outward behavior of the `sendBroadcast` method. Therefore, there is no indication of a compatibility issue and thus the type is 0."
1022,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",23,24,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d(""PreloadDrawable"", name);
            }
        }
    }
    final boolean isColorDrawable;
    final DrawableCache caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = caches.getInstance(key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These may contain unresolved theme
    // attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    Drawable dr;
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, null);
    }
    // Determine if the drawable has unresolved theme attributes. If it
    // does, we'll need to apply a theme and store it in a theme-specific
    // cache.
    final boolean canApplyTheme = dr != null && dr.canApplyTheme();
    if (canApplyTheme && theme != null) {
        dr = dr.mutate();
        dr.applyTheme(theme);
        dr.clearMutated();
    }
    // cache: preload, not themed, null theme, or theme-specific.
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);
    }
    return dr;
}","{
    return mResourcesImpl.loadDrawable(this, value, id, theme, true);
}",1,,,-1,[@Nullable],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of loadDrawable has been replaced by a single line that calls another method (mResourcesImpl.loadDrawable(this, value, id, theme, true)), indicating a dependent API change. Additionally, the annotation has changed from @Nullable to @NonNull, signaling a return statement change as it guarantees the non-nullity of the return type in the late version.",The change to a dependent method and the change in annotation from `@Nullable` to `@NonNull` can result in a potential Compatibility Issue due to different return values or types.
1023,<android.app.admin.DevicePolicyManager: int getMaximumFailedPasswordsForWipe(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getMaximumFailedPasswordsForWipe(ComponentName)>,<android.app.admin.DevicePolicyManager: int getMaximumFailedPasswordsForWipe(ComponentName)>,0,"{
    return getMaximumFailedPasswordsForWipe(admin, UserHandle.myUserId());
}","{
    return getMaximumFailedPasswordsForWipe(admin, myUserId());
}",1,"/**
 * Retrieve the current maximum number of login attempts that are allowed
 * before the device wipes itself, for all admins of this user and its profiles
 * or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
","/**
 * Retrieve the current maximum number of login attempts that are allowed before the device
 * or profile is wiped, for a particular admin or all admins that set retrictions on this user
 * and its participating profiles. Restrictions on profiles that have a separate challenge are
 * not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * the value for the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from calling getMaximumFailedPasswordsForWipe(admin, UserHandle.myUserId()) to getMaximumFailedPasswordsForWipe(admin, myUserId()), but it's essentially calling the same method with likely the same resulting user ID since myUserId() is a shortcut/stub for UserHandle.myUserId() within the context of the caller's user. Consequently, this change indicates a dependency on a different API signature, signifying the change type is 5.","There is no Compatibility Issue since the functional behavior does not change. The change is an internal call to a likely equivalent method that obtains the user ID, which does not affect the output, exception handling, or control flow of the method. Therefore, the pred_CI is 0, indicating no Compatibility Issue."
1024,"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int[],int)>",23,24,"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int[],int)>","<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int[],int)>",0,"{
    if (mService == null) {
        return;
    }
    try {
        mService.notifyAppWidgetViewDataChanged(mPackageName, appWidgetIds, viewId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.notifyAppWidgetViewDataChanged(mPackageName, appWidgetIds, viewId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Notifies the specified collection view in all the specified AppWidget instances
 * to invalidate their data.
 *
 * @param appWidgetIds  The AppWidget instances to notify of view data changes.
 * @param viewId        The collection view id.
 */
","/**
 * Notifies the specified collection view in all the specified AppWidget instances
 * to invalidate their data.
 *
 * @param appWidgetIds  The AppWidget instances to notify of view data changes.
 * @param viewId        The collection view id.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The early version throws a new RuntimeException when catching RemoteException, while the late version throws the RemoteException with rethrowFromSystemServer. Therefore, the exception handling statement has changed (code change type 2).","This change in exception handling means that the exceptions that could be received from this method have changed, potentially causing existing users of the method who expect a RuntimeException to instead receive the original RemoteException wrapped by rethrowFromSystemServer. Thus, compatibility issues could arise due to different exceptions being thrown (CI type 2)."
1025,"<android.app.ContextImpl: FileOutputStream openFileOutput(String,int)>",23,24,"<android.app.ContextImpl: FileOutputStream openFileOutput(String,int)>","<android.app.ContextImpl: FileOutputStream openFileOutput(String,int)>",0,"{
    final boolean append = (mode & MODE_APPEND) != 0;
    File f = makeFilename(getFilesDir(), name);
    try {
        FileOutputStream fos = new FileOutputStream(f, append);
        setFilePermissionsFromMode(f.getPath(), mode, 0);
        return fos;
    } catch (FileNotFoundException e) {
    }
    File parent = f.getParentFile();
    parent.mkdir();
    FileUtils.setPermissions(parent.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
    FileOutputStream fos = new FileOutputStream(f, append);
    setFilePermissionsFromMode(f.getPath(), mode, 0);
    return fos;
}","{
    checkMode(mode);
    final boolean append = (mode & MODE_APPEND) != 0;
    File f = makeFilename(getFilesDir(), name);
    try {
        FileOutputStream fos = new FileOutputStream(f, append);
        setFilePermissionsFromMode(f.getPath(), mode, 0);
        return fos;
    } catch (FileNotFoundException e) {
    }
    File parent = f.getParentFile();
    parent.mkdir();
    FileUtils.setPermissions(parent.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
    FileOutputStream fos = new FileOutputStream(f, append);
    setFilePermissionsFromMode(f.getPath(), mode, 0);
    return fos;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method implementation has introduced a new statement, checkMode(mode), at the beginning of the code, so the code change type is 4.","The newly added call to checkMode(mode) does not affect the existing control flow or return values, nor does it introduce new exceptions; it's a security or verification check without changing the exposed behavior of the method. Therefore, there is no compatibility issue, so the CI type is 0."
1027,<android.print.PrintManager: PrintJobInfo getPrintJobInfo(PrintJobId)>,23,24,<android.print.PrintManager: PrintJobInfo getPrintJobInfo(PrintJobId)>,<android.print.PrintManager: PrintJobInfo getPrintJobInfo(PrintJobId)>,0,"{
    try {
        return mService.getPrintJobInfo(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error getting a print job info:"" + printJobId, re);
    }
    return null;
}","{
    try {
        return mService.getPrintJobInfo(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","A return statement is deleted and a new exception statement has been introduced (throw re.rethrowFromSystemServer()), and hence, the change type is 1,2.","The removal of the return statement of 'null' and the introduction of a new throw statement that can propagate the exception instead of catching and logging means that the method can now throw an exception instead of returning null. This is a change in both return value and exception handling, so the CI types are 1,2."
1028,<android.appwidget.AppWidgetHost: void startListening()>,23,24,<android.appwidget.AppWidgetHost: void startListening()>,<android.appwidget.AppWidgetHost: void startListening()>,0,"{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}","{
    final int[] idsToUpdate;
    synchronized (mViews) {
        int N = mViews.size();
        idsToUpdate = new int[N];
        for (int i = 0; i < N; i++) {
            idsToUpdate[i] = mViews.keyAt(i);
        }
    }
    List<RemoteViews> updatedViews;
    int[] updatedIds = new int[idsToUpdate.length];
    try {
        updatedViews = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, idsToUpdate, updatedIds).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    int N = updatedViews.size();
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}",1,"/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
","/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The internal implementation of 'startListening' method has various changes:,2. Views are now synchronized on the mViews object;
1030,<android.widget.RemoteViews: RemoteViews clone()>,23,24,<android.widget.RemoteViews: RemoteViews clone()>,<android.widget.RemoteViews: RemoteViews clone()>,0,"{
    Parcel p = Parcel.obtain();
    writeToParcel(p, 0);
    p.setDataPosition(0);
    RemoteViews rv = new RemoteViews(p);
    p.recycle();
    return rv;
}","{
    Preconditions.checkState(mIsRoot, ""RemoteView has been attached to another RemoteView. "" + ""May only clone the root of a RemoteView hierarchy."");
    Parcel p = Parcel.obtain();
    // Do not parcel the Bitmap cache - doing so creates an expensive copy of all bitmaps.
    // Instead pretend we're not owning the cache while parceling.
    mIsRoot = false;
    writeToParcel(p, 0);
    p.setDataPosition(0);
    mIsRoot = true;
    RemoteViews rv = new RemoteViews(p, mBitmapCache.clone());
    rv.mIsRoot = true;
    p.recycle();
    return rv;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version introduces a precondition check, changes the value of `mIsRoot`, and passes a cloned `mBitmapCache` to the new `RemoteViews` instance. These changes affect both control dependency and other statements, leading to type 3,4. Additionally, due to the changes, the returned `RemoteViews` instance may have different state (particularly the bitmap cache), which is a change in the return statement, leading to type 1.","The introduction of the precondition check may cause the method to throw an IllegalStateException where it would not have before, resulting in a different exception being thrown (type 2). Also, the fact that the new `RemoteViews` instance is created with a clone of the `mBitmapCache` can lead to a returned object with different internal state, resulting in different return values (type 1). Thus, both changes can cause potential Compatibility Issues."
1031,<android.app.ActivityManager: void killBackgroundProcesses(String)>,23,24,<android.app.ActivityManager: void killBackgroundProcesses(String)>,<android.app.ActivityManager: void killBackgroundProcesses(String)>,0,"{
    try {
        ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#KILL_BACKGROUND_PROCESSES} to be able to
 * call this method.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
","/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#KILL_BACKGROUND_PROCESSES} to be able to
 * call this method.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement changed: a new throw statement (throw e.rethrowFromSystemServer()) has been introduced in the catch block in the late version, which wasn't there in the early version. So, the change type is 2.","Because a new throw statement was introduced that wasn't there in the previous version, the late version of the API could throw an exception where the early version would not. Therefore, a Compatibility Issue of type 2 exists due to different exception handling behavior."
1032,<android.content.pm.PackageInstaller.Session: void close()>,23,24,<android.content.pm.PackageInstaller.Session: void close()>,<android.content.pm.PackageInstaller.Session: void close()>,0,"{
    try {
        mSession.close();
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        mSession.close();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Release this session object. You can open the session again if it
 * hasn't been finalized.
 */
","/**
 * Release this session object. You can open the session again if it
 * hasn't been finalized.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from `throw e.rethrowAsRuntimeException();` to `throw e.rethrowFromSystemServer();`, so the code change type is 2.","The modification in the exception handling means the API may throw a different type of exception under certain conditions, which makes the behaviour of the API different from its previous version, and the CI type is 2."
1033,<android.app.NotificationManager: StatusBarNotification[] getActiveNotifications()>,23,24,<android.app.NotificationManager: StatusBarNotification[] getActiveNotifications()>,<android.app.NotificationManager: StatusBarNotification[] getActiveNotifications()>,0,"{
    final INotificationManager service = getService();
    final String pkg = mContext.getPackageName();
    try {
        final ParceledListSlice<StatusBarNotification> parceledList = service.getAppActiveNotifications(pkg, UserHandle.myUserId());
        final List<StatusBarNotification> list = parceledList.getList();
        return list.toArray(new StatusBarNotification[list.size()]);
    } catch (RemoteException e) {
        Log.e(TAG, ""Unable to talk to notification manager. Woe!"", e);
    }
    return new StatusBarNotification[0];
}","{
    final INotificationManager service = getService();
    final String pkg = mContext.getPackageName();
    try {
        final ParceledListSlice<StatusBarNotification> parceledList = service.getAppActiveNotifications(pkg, UserHandle.myUserId());
        final List<StatusBarNotification> list = parceledList.getList();
        return list.toArray(new StatusBarNotification[list.size()]);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Recover a list of active notifications: ones that have been posted by the calling app that
 * have not yet been dismissed by the user or {@link #cancel(String, int)}ed by the app.
 *
 * Each notification is embedded in a {@link StatusBarNotification} object, including the
 * original <code>tag</code> and <code>id</code> supplied to
 * {@link #notify(String, int, Notification) notify()}
 * (via {@link StatusBarNotification#getTag() getTag()} and
 * {@link StatusBarNotification#getId() getId()}) as well as a copy of the original
 * {@link Notification} object (via {@link StatusBarNotification#getNotification()}).
 *
 * @return An array of {@link StatusBarNotification}.
 */
","/**
 * Recover a list of active notifications: ones that have been posted by the calling app that
 * have not yet been dismissed by the user or {@link #cancel(String, int)}ed by the app.
 *
 * Each notification is embedded in a {@link StatusBarNotification} object, including the
 * original <code>tag</code> and <code>id</code> supplied to
 * {@link #notify(String, int, Notification) notify()}
 * (via {@link StatusBarNotification#getTag() getTag()} and
 * {@link StatusBarNotification#getId() getId()}) as well as a copy of the original
 * {@link Notification} object (via {@link StatusBarNotification#getNotification()}).
 *
 * @return An array of {@link StatusBarNotification}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling has changed; specifically, the catch block for RemoteException used to log the error and return an empty array, but in the late version, it rethrows the exception using e.rethrowFromSystemServer(), so the code change type is 2.","The change in exception handling could lead to different behaviour when the late version API is invoked because previously caught exceptions are now thrown, potentially affecting the caller. The CI type is 2, as this could cause the API to throw a different exception than before."
1034,"<android.bluetooth.BluetoothGatt: boolean setCharacteristicNotification(BluetoothGattCharacteristic,boolean)>",23,24,"<android.bluetooth.BluetoothGatt: boolean setCharacteristicNotification(BluetoothGattCharacteristic,boolean)>","<android.bluetooth.BluetoothGatt: boolean setCharacteristicNotification(BluetoothGattCharacteristic,boolean)>",0,"{
    if (DBG)
        Log.d(TAG, ""setCharacteristicNotification() - uuid: "" + characteristic.getUuid() + "" enable: "" + enable);
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.registerForNotification(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), enable);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""setCharacteristicNotification() - uuid: "" + characteristic.getUuid() + "" enable: "" + enable);
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.registerForNotification(mClientIf, device.getAddress(), characteristic.getInstanceId(), enable);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Enable or disable notifications/indications for a given characteristic.
 *
 * <p>Once notifications are enabled for a characteristic, a
 * {@link BluetoothGattCallback#onCharacteristicChanged} callback will be
 * triggered if the remote device indicates that the given characteristic
 * has changed.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic The characteristic for which to enable notifications
 * @param enable Set to true to enable notifications/indications
 * @return true, if the requested notification status was set successfully
 */
","/**
 * Enable or disable notifications/indications for a given characteristic.
 *
 * <p>Once notifications are enabled for a characteristic, a
 * {@link BluetoothGattCallback#onCharacteristicChanged} callback will be
 * triggered if the remote device indicates that the given characteristic
 * has changed.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic The characteristic for which to enable notifications
 * @param enable Set to true to enable notifications/indications
 * @return true, if the requested notification status was set successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"There is a change in the statement within the try block as the parameters passed to the method `mService.registerForNotification` have been significantly reduced. This showcases that the depended API `registerForNotification` has been changed (change type 5) and additionally, non-control statements are changed (change type 4). Moreover, since the implementation changes how the method `registerForNotification` is called, the return value of the API may be affected (change type 1).","Since the dependent method `registerForNotification` has changed its parameters, it could potentially alter the return type or value when invoking `setCharacteristicNotification`, leading to a CI type 1 due to the potential changes in the behavior of the returned value."
1035,"<android.view.animation.Animation: boolean getTransformation(long,Transformation)>",23,24,"<android.view.animation.Animation: boolean getTransformation(long,Transformation)>","<android.view.animation.Animation: boolean getTransformation(long,Transformation)>",0,"{
    if (mStartTime == -1) {
        mStartTime = currentTime;
    }
    final long startOffset = getStartOffset();
    final long duration = mDuration;
    float normalizedTime;
    if (duration != 0) {
        normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration;
    } else {
        // time is a step-change with a zero duration
        normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
    }
    final boolean expired = normalizedTime >= 1.0f;
    mMore = !expired;
    if (!mFillEnabled)
        normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
    if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
        if (!mStarted) {
            fireAnimationStart();
            mStarted = true;
            if (USE_CLOSEGUARD) {
                guard.open(""cancel or detach or getTransformation"");
            }
        }
        if (mFillEnabled)
            normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
        if (mCycleFlip) {
            normalizedTime = 1.0f - normalizedTime;
        }
        final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
        applyTransformation(interpolatedTime, outTransformation);
    }
    if (expired) {
        if (mRepeatCount == mRepeated) {
            if (!mEnded) {
                mEnded = true;
                guard.close();
                fireAnimationEnd();
            }
        } else {
            if (mRepeatCount > 0) {
                mRepeated++;
            }
            if (mRepeatMode == REVERSE) {
                mCycleFlip = !mCycleFlip;
            }
            mStartTime = -1;
            mMore = true;
            fireAnimationRepeat();
        }
    }
    if (!mMore && mOneMoreTime) {
        mOneMoreTime = false;
        return true;
    }
    return mMore;
}","{
    if (mStartTime == -1) {
        mStartTime = currentTime;
    }
    final long startOffset = getStartOffset();
    final long duration = mDuration;
    float normalizedTime;
    if (duration != 0) {
        normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration;
    } else {
        // time is a step-change with a zero duration
        normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
    }
    final boolean expired = normalizedTime >= 1.0f || isCanceled();
    mMore = !expired;
    if (!mFillEnabled)
        normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
    if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
        if (!mStarted) {
            fireAnimationStart();
            mStarted = true;
            if (NoImagePreloadHolder.USE_CLOSEGUARD) {
                guard.open(""cancel or detach or getTransformation"");
            }
        }
        if (mFillEnabled)
            normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
        if (mCycleFlip) {
            normalizedTime = 1.0f - normalizedTime;
        }
        final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
        applyTransformation(interpolatedTime, outTransformation);
    }
    if (expired) {
        if (mRepeatCount == mRepeated || isCanceled()) {
            if (!mEnded) {
                mEnded = true;
                guard.close();
                fireAnimationEnd();
            }
        } else {
            if (mRepeatCount > 0) {
                mRepeated++;
            }
            if (mRepeatMode == REVERSE) {
                mCycleFlip = !mCycleFlip;
            }
            mStartTime = -1;
            mMore = true;
            fireAnimationRepeat();
        }
    }
    if (!mMore && mOneMoreTime) {
        mOneMoreTime = false;
        return true;
    }
    return mMore;
}",1,"/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A transformation object that is provided by the
 * caller and will be filled in by the animation.
 * @return True if the animation is still running
 */
","/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A transformation object that is provided by the
 * caller and will be filled in by the animation.
 * @return True if the animation is still running
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The method `isCanceled()` has been integrated into the boolean expression setting `expired`, and similarly into the if condition that checks for the end of the animation. There were no changes to existing return statements or exception handling statements, but the control flow of the program may change due to the integration of the `isCanceled()` method in the if conditions. Therefore, the changes involve control dependency as well as other non-categorized statements (likely the integration of the isCanceled method implies changes in internal state checks).","However, the changes do not directly affect the method's return statements or exception handling; the values that are returned are still determined in the same way, and no new exception types have been introduced. All changes pertain to the internal decision-making process which controls when certain actions are taken, but these don't manifest as observable changes in the method's outputs or exceptions, hence no compatibility issue."
1036,<android.util.ArraySet: int indexOf(Object)>,23,24,<android.util.ArraySet: int indexOf(Object)>,<android.util.ArraySet: int indexOf(Object)>,0,"{
    return key == null ? indexOfNull() : indexOf(key, key.hashCode());
}","{
    return key == null ? indexOfNull() : indexOf(key, mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());
}",1,"/**
 * Returns the index of a value in the set.
 *
 * @param key The value to search for.
 * @return Returns the index of the value if it exists, else a negative integer.
 */
","/**
 * Returns the index of a value in the set.
 *
 * @param key The value to search for.
 * @return Returns the index of the value if it exists, else a negative integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of how the hashCode is calculated for non-null keys in indexOf has changed. In the early version it always uses key.hashCode(), while in the late version it uses System.identityHashCode(key) when mIdentityHashCode is true, otherwise it uses key.hashCode(). This is considered as Other statement changed (4) since it's a change in the logic not covered by the return, exception handling, and control dependency criteria, and also a change in how a dependent API (hashCode calculation) is being used (5).","This change could lead to a different return value for objects with non-null keys that have the same data but are different instances. Since the identity hash code is used instead of the data-based hash code for comparisons when mIdentityHashCode is true, the method may return different indices for such objects between the early and late versions of the API. The CI type is 1 (Compatibility Issue caused by potential different return values or types)."
1037,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",23,24,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",0,"{
    final PackageParser parser = new PackageParser();
    final File apkFile = new File(archiveFilePath);
    try {
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            parser.collectCertificates(pkg, 0);
            parser.collectManifestDigest(pkg);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}","{
    final PackageParser parser = new PackageParser();
    final File apkFile = new File(archiveFilePath);
    try {
        if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
        // Caller expressed an explicit opinion about what encryption
        // aware/unaware components they want to see, so fall through and
        // give them what they want
        } else {
            // Caller expressed no opinion, so match everything
            flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            PackageParser.collectCertificates(pkg, 0);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}",1,"/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
","/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES}, {@link #GET_CONFIGURATIONS},
 * {@link #GET_GIDS}, {@link #GET_INSTRUMENTATION},
 * {@link #GET_INTENT_FILTERS}, {@link #GET_META_DATA},
 * {@link #GET_PERMISSIONS}, {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS}, {@link #GET_SERVICES},
 * {@link #GET_SHARED_LIBRARY_FILES}, {@link #GET_SIGNATURES},
 * {@link #GET_URI_PERMISSION_PATTERNS}, {@link #GET_UNINSTALLED_PACKAGES},
 * {@link #MATCH_DISABLED_COMPONENTS}, {@link #MATCH_DISABLED_UNTIL_USED_COMPONENTS},
 * {@link #MATCH_UNINSTALLED_PACKAGES}
 * to modify the data returned.
 *
 * @return A PackageInfo object containing information about the
 * package archive. If the package could not be parsed,
 * returns null.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_CONFIGURATIONS
 * @see #GET_GIDS
 * @see #GET_INSTRUMENTATION
 * @see #GET_INTENT_FILTERS
 * @see #GET_META_DATA
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SHARED_LIBRARY_FILES
 * @see #GET_SIGNATURES
 * @see #GET_URI_PERMISSION_PATTERNS
 * @see #MATCH_DISABLED_COMPONENTS
 * @see #MATCH_DISABLED_UNTIL_USED_COMPONENTS
 * @see #MATCH_UNINSTALLED_PACKAGES
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces new control flow logic to conditionally alter the 'flags' variable, and changes the way certificates are collected without the `collectManifestDigest(pkg)` call. The change type is 3 for the introduction of new if-else block and 4 due to the modification of method invocation from an instance method to a static method and the removal of the `collectManifestDigest(pkg)` call.","Despite the changes in the control flow and method invocation, there is no Compatibility Issue that would arise due to these changes. The `flags` variable is only modified to include both MATCH_DIRECT_BOOT_AWARE and MATCH_DIRECT_BOOT_UNAWARE when no opinion is specified, which ensures that existing behavior remains the same for any calling code that doesn't explicitly specify these MATCH flags. The change from instance method `parser.collectCertificates(pkg, 0)` to static method `PackageParser.collectCertificates(pkg, 0)` does not cause a difference in behavior as the instance `parser` is of type `PackageParser`, and the `collectManifestDigest(pkg)` removal does not influence the return value of `getPackageArchiveInfo`. Hence there's no change that would result in different return values or exceptions being thrown."
1038,"<android.app.admin.DevicePolicyManager: void setApplicationRestrictions(ComponentName,String,Bundle)>",23,24,"<android.app.admin.DevicePolicyManager: void setApplicationRestrictions(ComponentName,String,Bundle)>","<android.app.admin.DevicePolicyManager: void setApplicationRestrictions(ComponentName,String,Bundle)>",0,"{
    if (mService != null) {
        try {
            mService.setApplicationRestrictions(admin, packageName, settings);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setApplicationRestrictions"");
    if (mService != null) {
        try {
            mService.setApplicationRestrictions(admin, packageName, settings);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile or device owner to set the application restrictions for a given target
 * application running in the profile.
 *
 * <p>The provided {@link Bundle} consists of key-value pairs, where the types of values may be:
 * <ul>
 * <li>{@code boolean}
 * <li>{@code int}
 * <li>{@code String} or {@code String[]}
 * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}
 * </ul>
 *
 * <p>The application restrictions are only made visible to the target application and the
 * profile or device owner.
 *
 * <p>If the restrictions are not available yet, but may be applied in the near future,
 * the admin can notify the target application of that by adding
 * {@link UserManager#KEY_RESTRICTIONS_PENDING} to the settings parameter.
 *
 * <p>The calling device admin must be a profile or device owner; if it is not, a security
 * exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to update restricted settings for.
 * @param settings A {@link Bundle} to be parsed by the receiving application, conveying a new
 * set of active restrictions.
 *
 * @see UserManager#KEY_RESTRICTIONS_PENDING
 */
","/**
 * Sets the application restrictions for a given target application running in the calling user.
 * <p>
 * The caller must be a profile or device owner on that user, or the package allowed to manage
 * application restrictions via {@link #setApplicationRestrictionsManagingPackage}; otherwise a
 * security exception will be thrown.
 * <p>
 * The provided {@link Bundle} consists of key-value pairs, where the types of values may be:
 * <ul>
 * <li>{@code boolean}
 * <li>{@code int}
 * <li>{@code String} or {@code String[]}
 * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}
 * </ul>
 * <p>
 * If the restrictions are not available yet, but may be applied in the near future, the caller
 * can notify the target application of that by adding
 * {@link UserManager#KEY_RESTRICTIONS_PENDING} to the settings parameter.
 * <p>
 * The application restrictions are only made visible to the target application via
 * {@link UserManager#getApplicationRestrictions(String)}, in addition to the profile or device
 * owner, and the application restrictions managing package via
 * {@link #getApplicationRestrictions}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if called by the application restrictions managing package.
 * @param packageName The name of the package to update restricted settings for.
 * @param settings A {@link Bundle} to be parsed by the receiving application, conveying a new
 * set of active restrictions.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setApplicationRestrictionsManagingPackage
 * @see UserManager#KEY_RESTRICTIONS_PENDING
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement has been changed (`Log.w` has been replaced with `throw e.rethrowFromSystemServer()`), and a new line of code has been added at the beginning of the method (`throwIfParentInstance(""setApplicationRestrictions"")`). Therefore, the code change types are 2,4.","The addition of `throwIfParentInstance(""setApplicationRestrictions"")` changes the exception handling because it could throw an exception before the previous code is executed. The change from logging the exception to throwing it could also cause different exception handling in the late version. Consequently, the CI type is 2."
1039,<android.os.BatteryStats.HistoryItem: boolean sameNonEvent(HistoryItem)>,23,24,<android.os.BatteryStats.HistoryItem: boolean sameNonEvent(HistoryItem)>,<android.os.BatteryStats.HistoryItem: boolean sameNonEvent(HistoryItem)>,0,"{
    return batteryLevel == o.batteryLevel && batteryStatus == o.batteryStatus && batteryHealth == o.batteryHealth && batteryPlugType == o.batteryPlugType && batteryTemperature == o.batteryTemperature && batteryVoltage == o.batteryVoltage && states == o.states && states2 == o.states2 && currentTime == o.currentTime;
}","{
    return batteryLevel == o.batteryLevel && batteryStatus == o.batteryStatus && batteryHealth == o.batteryHealth && batteryPlugType == o.batteryPlugType && batteryTemperature == o.batteryTemperature && batteryVoltage == o.batteryVoltage && batteryChargeUAh == o.batteryChargeUAh && states == o.states && states2 == o.states2 && currentTime == o.currentTime;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The condition in the return statement has an additional check for batteryChargeUAh in the late version, which changes the return statement, therefore the change type is 1,4.","Due to the addition of the batteryChargeUAh check in the condition, this could lead to different return values, as a HistoryItem that previously would have been considered the same may now be deemed as different if the batteryChargeUAh values do not match; thus, the CI type is 1."
1040,<android.widget.AbsSeekBar: boolean verifyDrawable(Drawable)>,23,24,<android.widget.AbsSeekBar: boolean verifyDrawable(Drawable)>,<android.widget.AbsSeekBar: boolean verifyDrawable(Drawable)>,0,"{
    return who == mThumb || super.verifyDrawable(who);
}","{
    return who == mThumb || who == mTickMark || super.verifyDrawable(who);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An additional condition within the return statement has been introduced to verify another drawable (who == mTickMark), and this is neither a dependent API nor an exception handling or a control flow change; thus, it's an other statement change, resulting in type 1,4.","The new condition for 'mTickMark' in the return statement could potentially result in the method returning a different boolean value than before (when who == mTickMark is true, it would return true, where previously it would have returned the result of super.verifyDrawable(who)), this is a CI caused by different return values, type 1."
1042,<android.view.inputmethod.CursorAnchorInfo: String toString()>,23,24,<android.view.inputmethod.CursorAnchorInfo: String toString()>,<android.view.inputmethod.CursorAnchorInfo: String toString()>,0,"{
    return ""SelectionInfo{mSelection="" + mSelectionStart + "","" + mSelectionEnd + "" mComposingTextStart="" + mComposingTextStart + "" mComposingText="" + Objects.toString(mComposingText) + "" mInsertionMarkerFlags="" + mInsertionMarkerFlags + "" mInsertionMarkerHorizontal="" + mInsertionMarkerHorizontal + "" mInsertionMarkerTop="" + mInsertionMarkerTop + "" mInsertionMarkerBaseline="" + mInsertionMarkerBaseline + "" mInsertionMarkerBottom="" + mInsertionMarkerBottom + "" mCharacterBoundsArray="" + Objects.toString(mCharacterBoundsArray) + "" mMatrix="" + Objects.toString(mMatrix) + ""}"";
}","{
    return ""CursorAnchorInfo{mHashCode="" + mHashCode + "" mSelection="" + mSelectionStart + "","" + mSelectionEnd + "" mComposingTextStart="" + mComposingTextStart + "" mComposingText="" + Objects.toString(mComposingText) + "" mInsertionMarkerFlags="" + mInsertionMarkerFlags + "" mInsertionMarkerHorizontal="" + mInsertionMarkerHorizontal + "" mInsertionMarkerTop="" + mInsertionMarkerTop + "" mInsertionMarkerBaseline="" + mInsertionMarkerBaseline + "" mInsertionMarkerBottom="" + mInsertionMarkerBottom + "" mCharacterBoundsArray="" + Objects.toString(mCharacterBoundsArray) + "" mMatrix="" + Arrays.toString(mMatrixValues) + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return value of the toString method was changed by adding mHashCode to the beginning and changing the mMatrix part to Arrays.toString(mMatrixValues) at the end of the returned string, alongside the change in the object's name from ""SelectionInfo"" to ""CursorAnchorInfo"". Also, there is a modification to a method used on mMatrix from Objects.toString(mMatrix) to Arrays.toString(mMatrixValues) which is a change unrelated to control structures, thus it is classified under 'Other statement changed', so the code change type is 1,4.","The change to the return statement will definitely result in a different return value (different string representation of the object). Therefore, the change's CI type is 1."
1043,<android.content.res.Configuration: int diff(Configuration)>,23,24,<android.content.res.Configuration: int diff(Configuration)>,<android.content.res.Configuration: int diff(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
    }
    return changed;
}",1,"/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 * {@link android.content.pm.ActivityInfo#CONFIG_LAYOUT_DIRECTION
 * PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION}.
 */
","/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 * {@link android.content.pm.ActivityInfo#CONFIG_LAYOUT_DIRECTION
 * PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1044,"<android.app.admin.DevicePolicyManager: void clearPackagePersistentPreferredActivities(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: void clearPackagePersistentPreferredActivities(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void clearPackagePersistentPreferredActivities(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            mService.clearPackagePersistentPreferredActivities(admin, packageName);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""clearPackagePersistentPreferredActivities"");
    if (mService != null) {
        try {
            mService.clearPackagePersistentPreferredActivities(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile owner or device owner to remove all persistent intent handler preferences
 * associated with the given package that were set by {@link #addPersistentPreferredActivity}.
 *
 * <p>The calling device admin must be a profile owner. If it is not, a security
 * exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package for which preferences are removed.
 */
","/**
 * Called by a profile owner or device owner to remove all persistent intent handler preferences
 * associated with the given package that were set by {@link #addPersistentPreferredActivity}.
 * <p>
 * The calling device admin must be a profile owner. If it is not, a security exception will be
 * thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package for which preferences are removed.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The change in the implementation is the addition of the method call `throwIfParentInstance(""clearPackagePersistentPreferredActivities"")` before the existing if condition, as well as changing the catch block to throw an exception instead of just logging it. This is an 'Other statement changed' (code change type 4) and also an 'Exception handling statement changed' (code change type 2).","The addition of throwing an unchecked exception can cause the late version of the API to throw an exception where previously it did not, so the CI type is 2. The log statement was replaced with a throw, modifying the exception handling behavior of the method, which could cause a CI due to potential different exception handlings when the client code is using this API."
1045,<android.app.NotificationManager.Policy: int hashCode()>,23,24,<android.app.NotificationManager.Policy: int hashCode()>,<android.app.NotificationManager.Policy: int hashCode()>,0,"{
    return Objects.hash(priorityCategories, priorityCallSenders, priorityMessageSenders);
}","{
    return Objects.hash(priorityCategories, priorityCallSenders, priorityMessageSenders, suppressedVisualEffects);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The hashCode method's implementation has been changed by adding an additional object 'suppressedVisualEffects' to the hash calculation. Therefore, the change is in the return statement, which means the code change type is 1.","The change in the hashCode method's implementation signifies a potential Compatibility Issue due to the possibility of returning different values. The hash value will be different when the 'suppressedVisualEffects' field is considered in the hash calculation in the later version. This change definitely leads to a different return value, so the CI type is 1."
1047,"<android.accounts.AccountManager: String getUserData(Account,String)>",23,24,"<android.accounts.AccountManager: String getUserData(Account,String)>","<android.accounts.AccountManager: String getUserData(Account,String)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        return mService.getUserData(account, key);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        return mService.getUserData(account, key);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the user data named by ""key"" associated with the account.
 * This is intended for authenticators and related code to store
 * arbitrary metadata along with accounts.  The meaning of the keys
 * and values is up to the authenticator for the account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The account to query for user data
 * @return The user data, null if the account or key doesn't exist
 */
","/**
 * Gets the user data named by ""key"" associated with the account.
 * This is intended for authenticators and related code to store
 * arbitrary metadata along with accounts.  The meaning of the keys
 * and values is up to the authenticator for the account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The account to query for user data
 * @return The user data, null if the account or key doesn't exist
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from throwing a new RuntimeException to calling throw e.rethrowFromSystemServer(), so the change type is 2.","Due to the change in the exception handling statement, the API potentially throws a different exception in the late version, resulting in a CI type of 2."
1048,<android.os.Process: UserHandle myUserHandle()>,23,24,<android.os.Process: UserHandle myUserHandle()>,<android.os.Process: UserHandle myUserHandle()>,0,"{
    return new UserHandle(UserHandle.getUserId(myUid()));
}","{
    return UserHandle.of(UserHandle.getUserId(myUid()));
}",1,"/**
 * Returns this process's user handle.  This is the
 * user the process is running under.  It is distinct from
 * {@link #myUid()} in that a particular user will have multiple
 * distinct apps running under it each with their own uid.
 */
","/**
 * Returns this process's user handle.  This is the
 * user the process is running under.  It is distinct from
 * {@link #myUid()} in that a particular user will have multiple
 * distinct apps running under it each with their own uid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The method for creating a UserHandle instance changed from new UserHandle() to UserHandle.of(), so the code change type is 1,5 since a different dependent API constructor or factory method is used in the late version.","No Compatibility Issue arises because though the method to create a new UserHandle has changed, the actual outcome is the same - an equivalent UserHandle representing the same user is returned in both implementations. Hence, the behavior of the API remains consistent across both versions."
1049,"<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>",23,24,"<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>","<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>",0,"{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession().sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession().sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Send an arbitrary command to the current active wallpaper.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param action Name of the command to perform.  This must be a scoped
 * name to avoid collisions, such as ""com.mycompany.wallpaper.DOIT"".
 * @param x Arbitrary integer argument based on command.
 * @param y Arbitrary integer argument based on command.
 * @param z Arbitrary integer argument based on command.
 * @param extras Optional additional information for the command, or null.
 */
","/**
 * Send an arbitrary command to the current active wallpaper.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param action Name of the command to perform.  This must be a scoped
 * name to avoid collisions, such as ""com.mycompany.wallpaper.DOIT"".
 * @param x Arbitrary integer argument based on command.
 * @param y Arbitrary integer argument based on command.
 * @param z Arbitrary integer argument based on command.
 * @param extras Optional additional information for the command, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has changed, with the late version throwing a RuntimeException wrapping the RemoteException, so the code change type is 2.","Due to the change in exception handling which rethrows the RemoteException as a RuntimeException, the late version may throw an exception where the early version did not, leading to a CI type of 2."
1050,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNonLetter(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNonLetter(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of non-letter characters (numerical digits or symbols)
 * required in the password. After setting this, the user will not be able
 * to enter a new password that is not at least as restrictive as what has
 * been set. Note that the current password will remain until the user has
 * set a new one, so the change does not take place immediately. To prompt
 * the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator
 * has also requested {@link #PASSWORD_QUALITY_COMPLEX} with
 * {@link #setPasswordQuality}. The default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the minimum number of
 * non-letter characters (numerical digits or symbols) required in the password. After setting
 * this, the user will not be able to enter a new password that is not at least as restrictive
 * as what has been set. Note that the current password will remain until the user has set a new
 * one, so the change does not take place immediately. To prompt the user for a new password,
 * use {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of letters required in the password. A value of
 * 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The implementation change includes adding a parameter to the method 'setPasswordMinimumNonLetter' and an exception handling statement change (the old log statement is deleted and a new throw statement is introduced), so the change type is 2,4,5.","The change in exception handling from logging an exception to throwing it will result in a different behavior when an exception occurs, potentially leading to a different exception being thrown to the caller. Therefore, the CI type is 2."
1051,"<android.transition.Fade: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>",23,24,"<android.transition.Fade: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>","<android.transition.Fade: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>",0,"{
    return createAnimation(view, 1, 0);
}","{
    float startAlpha = getStartAlpha(startValues, 1);
    return createAnimation(view, startAlpha, 0);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 4",1,"The implementation has changed by introducing a new variable 'startAlpha' which involves a new method call 'getStartAlpha(startValues, 1)' that computes the starting alpha value. Consequently, the 'createAnimation' method now receives this 'startAlpha' instead of a fixed value of 1 as its second argument. This is both a specific change to the return statement and an other statement change, so the code change type is 1, 4.","The change in the starting alpha value could lead to a different starting state in the animation, which changes the behavior of the method. Therefore, this could potentially cause the API to return a different value (the resulting `Animator` object could represent a different animation state), and the CI type is 1."
1052,"<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>",23,24,"<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>","<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>",0,"{
    int which = doKeyDown(keyCode, event, null);
    if (which == 0) {
        return super.onKeyDown(keyCode, event);
    }
    return true;
}","{
    final int which = doKeyDown(keyCode, event, null);
    if (which == KEY_EVENT_NOT_HANDLED) {
        return super.onKeyDown(keyCode, event);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The constant value for comparison in the if statement has changed from '0' to 'KEY_EVENT_NOT_HANDLED', and a variable declaration has changed from 'int' to 'final int', meaning there's a Control dependency change (3) and an Other statement changed (4).","The substitution of '0' with 'KEY_EVENT_NOT_HANDLED' does not indicate a difference in behavior as it is likely that 'KEY_EVENT_NOT_HANDLED' is a constant that equals '0'. Therefore, there would be no change in the behavior of the method and hence no Compatibility Issue (0)."
1053,<android.app.admin.DevicePolicyManager: boolean isActivePasswordSufficient()>,23,24,<android.app.admin.DevicePolicyManager: boolean isActivePasswordSufficient()>,<android.app.admin.DevicePolicyManager: boolean isActivePasswordSufficient()>,0,"{
    if (mService != null) {
        try {
            return mService.isActivePasswordSufficient(UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.isActivePasswordSufficient(myUserId(), mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Determine whether the current password the user has set is sufficient
 * to meet the policy requirements (quality, minimum length) that have been
 * requested by the admins of this user and its profiles.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @return Returns true if the password meets the current requirements, else false.
 */
","/**
 * Determine whether the current password the user has set is sufficient to meet the policy
 * requirements (e.g. quality, minimum length) that have been requested by the admins of this
 * user and its participating profiles. Restrictions on profiles that have a separate challenge
 * are not taken into account.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to determine if the password set on
 * the parent profile is sufficient.
 *
 * @return Returns true if the password meets the current requirements, else false.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The number and type of parameters of the method mService.isActivePasswordSufficient() have changed. The mService.isActivePasswordSufficient(UserHandle.myUserId()) became mService.isActivePasswordSufficient(myUserId(), mParentInstance) with the addition of the second parameter, mParentInstance, making it a Dependent API change. Furthermore, an exception handling statement has changed from logging an exception to throwing it with throw e.rethrowFromSystemServer(), which is categorized as an Exception handling statement changed.","There is a Compatibility Issue here in two ways. The method's change to the type and number of parameters it takes could lead to different behaviors, such as validating password sufficiency based on a different user ID or criteria, leading to a different return value. So this is a CI caused by potential different return values or types (1). Additionally, there's a CI due to different exception handling. In the early version, RemoteException was caught and logged whereas, in the later version, it's caught and rethrown. This change could lead to the method throwing an exception where it previously did not, so the CI is also caused by different exception handlings (2)."
1055,<android.hardware.camera2.legacy.LegacyCameraDevice: long getSurfaceId(Surface)>,23,24,<android.hardware.camera2.legacy.LegacyCameraDevice: long getSurfaceId(Surface)>,<android.hardware.camera2.legacy.LegacyCameraDevice: long getSurfaceId(Surface)>,0,"{
    checkNotNull(surface);
    return nativeGetSurfaceId(surface);
}","{
    checkNotNull(surface);
    try {
        return nativeGetSurfaceId(surface);
    } catch (IllegalArgumentException e) {
        throw new BufferQueueAbandonedException();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement, 'try-catch', has been introduced, and in the event of an IllegalArgumentException, a new kind of exception (BufferQueueAbandonedException) is thrown, so the change type is 2.","The introduction of 'try-catch' block that throws a new BufferQueueAbandonedException instead of IllegalArgumentException represents a change in the exception handling behavior. Previously uncaught IllegalArgumentException would have propagated out of the method, but now it is caught and a different exception is thrown. Therefore, a CI is present due to a potentially different exception handling type, which is 2."
1056,<android.app.UiModeManager: void enableCarMode(int)>,23,24,<android.app.UiModeManager: void enableCarMode(int)>,<android.app.UiModeManager: void enableCarMode(int)>,0,"{
    if (mService != null) {
        try {
            mService.enableCarMode(flags);
        } catch (RemoteException e) {
            Log.e(TAG, ""disableCarMode: RemoteException"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.enableCarMode(flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Force device into car mode, like it had been placed in the car dock.
 * This will cause the device to switch to the car home UI as part of
 * the mode switch.
 * @param flags Must be 0.
 */
","/**
 * Force device into car mode, like it had been placed in the car dock.
 * This will cause the device to switch to the car home UI as part of
 * the mode switch.
 * @param flags Must be 0.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from logging the RemoteException to throwing it with rethrowFromSystemServer(), so the change type is 2.","The behavior in terms of exception handling has changed, leading to a potential different exception being thrown. In the early version, a RemoteException is caught and logged, while in the late version, it is rethrown as a RuntimeException. Thus, the CI type is 2."
1057,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,23,24,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,0,"{
    final ViewTreeObserver observer = getViewTreeObserver();
    if (observer != null && transition != null) {
        final Transition enterTransition = transition.clone();
        // Postpone the enter transition after the first layout pass.
        observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {

            @Override
            public void onGlobalLayout() {
                final ViewTreeObserver observer = getViewTreeObserver();
                if (observer != null) {
                    observer.removeOnGlobalLayoutListener(this);
                }
                final Rect epicenter = getRelativeAnchorBounds();
                enterTransition.setEpicenterCallback(new EpicenterCallback() {

                    @Override
                    public Rect onGetEpicenter(Transition transition) {
                        return epicenter;
                    }
                });
                startEnterTransition(enterTransition);
            }
        });
    }
}","{
    final ViewTreeObserver observer = getViewTreeObserver();
    if (observer != null && transition != null) {
        final Transition enterTransition = transition.clone();
        // Postpone the enter transition after the first layout pass.
        observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {

            @Override
            public void onGlobalLayout() {
                final ViewTreeObserver observer = getViewTreeObserver();
                if (observer != null) {
                    observer.removeOnGlobalLayoutListener(this);
                }
                final Rect epicenter = getTransitionEpicenter();
                enterTransition.setEpicenterCallback(new EpicenterCallback() {

                    @Override
                    public Rect onGetEpicenter(Transition transition) {
                        return epicenter;
                    }
                });
                startEnterTransition(enterTransition);
            }
        });
    }
}",1,"/**
 * Requests that an enter transition run after the next layout pass.
 */
","/**
 * Requests that an enter transition run after the next layout pass.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The reference to getRelativeAnchorBounds() has been changed to getTransitionEpicenter() within the method's internal anonymous class implementation, so the change type is 4.","There is no Compatibility Issue because the change is an internal detail within the method that does not affect the method's signature, return type, parameters, or exceptions thrown. It seems to be a simple renaming of a method that is likely used to fetch the bounds for a transition epicenter, which should not alter the general contract or expected behavior of requestEnterTransition(Transition). The renaming suggests a refactoring for clarity or consistency rather than an alteration in behavior."
1060,"<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>",23,24,"<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>","<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(method, ""method"");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        return provider.call(mPackageName, method, arg, extras);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(method, ""method"");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        final Bundle res = provider.call(mPackageName, method, arg, extras);
        Bundle.setDefusable(res, true);
        return res;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */
","/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The change is the addition of a new method call ""Bundle.setDefusable(res, true);"" before the return statement. This is internal to the method implementation and does not impact the returned value or the method signature, so the code change type is 4.","This additional method call will not cause a change in behaviour visible to the caller in terms of the API contract (return values or thrown exceptions), therefore there is no Compatibility Issue, and the CI type is 0."
1061,<android.app.job.JobInfo.Builder: Builder setPeriodic(long)>,23,24,<android.app.job.JobInfo.Builder: Builder setPeriodic(long)>,<android.app.job.JobInfo.Builder: Builder setPeriodic(long)>,0,"{
    mIsPeriodic = true;
    mIntervalMillis = intervalMillis;
    mHasEarlyConstraint = mHasLateConstraint = true;
    return this;
}","{
    return setPeriodic(intervalMillis, intervalMillis);
}",1,"/**
 * Specify that this job should recur with the provided interval, not more than once per
 * period. You have no control over when within this interval this job will be executed,
 * only the guarantee that it will be executed at most once within this interval.
 * Setting this function on the builder with {@link #setMinimumLatency(long)} or
 * {@link #setOverrideDeadline(long)} will result in an error.
 * @param intervalMillis Millisecond interval for which this job will repeat.
 */
","/**
 * Specify that this job should recur with the provided interval, not more than once per
 * period. You have no control over when within this interval this job will be executed,
 * only the guarantee that it will be executed at most once within this interval.
 * Setting this function on the builder with {@link #setMinimumLatency(long)} or
 * {@link #setOverrideDeadline(long)} will result in an error.
 * @param intervalMillis Millisecond interval for which this job will repeat.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"In the late version, the method setPeriodic(long) execution delegates to setPeriodic(long, long). Even though the internal implementation has changed, it does not change the behavior or outcome of the API itself. Since the method likely remains functionally identical to the consumer (qualifying under one set of parameters with default values is a common paradigm), the code change type is 1,5.","There is no compatibility issue as long as the overloaded setPeriodic method (most likely setPeriodic(long, long)) ensures identical behavior to the original, which would typically be the case when one method delegates to an overloaded version within the same API level. The absence of a change in the behavior of the API itself suggests no compatibility issues, hence the CI type is 0."
1062,<android.animation.ValueAnimator: long getCurrentPlayTime()>,23,24,<android.animation.ValueAnimator: long getCurrentPlayTime()>,<android.animation.ValueAnimator: long getCurrentPlayTime()>,0,"{
    if (!mInitialized || mPlayingState == STOPPED) {
        return 0;
    }
    return AnimationUtils.currentAnimationTimeMillis() - mStartTime;
}","{
    if (!mInitialized || (!mStarted && mSeekFraction < 0)) {
        return 0;
    }
    if (mSeekFraction >= 0) {
        return (long) (mDuration * mSeekFraction);
    }
    float durationScale = sDurationScale == 0 ? 1 : sDurationScale;
    return (long) ((AnimationUtils.currentAnimationTimeMillis() - mStartTime) / durationScale);
}",1,"/**
 * Gets the current position of the animation in time, which is equal to the current
 * time minus the time that the animation started. An animation that is not yet started will
 * return a value of zero.
 *
 * @return The current position in time of the animation.
 */
","/**
 * Gets the current position of the animation in time, which is equal to the current
 * time minus the time that the animation started. An animation that is not yet started will
 * return a value of zero, unless the animation has has its play time set via
 * {@link #setCurrentPlayTime(long)} or {@link #setCurrentFraction(float)}, in which case
 * it will return the time that was set.
 *
 * @return The current position in time of the animation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early version checks `mPlayingState == STOPPED`, whereas the late version checks `(!mStarted && mSeekFraction < 0)` and introduces additional checks and computations involving `mSeekFraction`. The method also introduces a new computation of the return value involving `durationScale`. There are changes in the control structures, and therefore we have a control dependency change as new 'if' conditions have been introduced. The method of calculating the return value has also changed with the introduction of `durationScale` and `mSeekFraction`, resulting in an 'Other statement changed'. Therefore, the code change types are 1, 3, and 4.","The modification of control statements and the differences in return values based on the new conditions (`mSeekFraction`, `durationScale`) introduce the possibility of the API returning different variable values. Therefore, the CI type is 1."
1063,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,23,24,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,0,"{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            return null;
        } else {
            return sGlobals.mService.getWallpaperInfo();
        }
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            return sGlobals.mService.getWallpaperInfo();
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */
","/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2",There is a change in the exception handling statements: ,
1064,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,23,24,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,0,"{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, ""strict mode violation stacks read from binder call.  i="" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
            String front = info.crashInfo.stackTrace.substring(256);
            // First, drain the remaining violations from the parcel.
            while (i < numViolations) {
                info = new ViolationInfo(p, !currentlyGathering);
                i++;
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, ""Stack is too large: numViolations="" + numViolations + "" policy=#"" + Integer.toHexString(policyMask) + "" front="" + front);
            return;
        }
        info.crashInfo.stackTrace += ""# via Binder call with stack:\n"" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}","{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, ""strict mode violation stacks read from binder call.  i="" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
            String front = info.crashInfo.stackTrace.substring(0, 256);
            // 30000 characters is way too large for this to be any sane kind of
            // strict mode collection of stacks.  We've had a problem where we leave
            // strict mode violations associated with the thread, and it keeps tacking
            // more and more stacks on to the violations.  Looks like we're in this casse,
            // so we'll report it and bail on all of the current strict mode violations
            // we currently are maintaining for this thread.
            // First, drain the remaining violations from the parcel.
            // Skip the current entry.
            i++;
            for (; i < numViolations; i++) {
                info = new ViolationInfo(p, !currentlyGathering);
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, ""Stack is too large: numViolations="" + numViolations + "" policy=#"" + Integer.toHexString(policyMask) + "" front="" + front);
            return;
        }
        info.crashInfo.stackTrace += ""# via Binder call with stack:\n"" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are multiple changes within the control structure and other statements. The `for` loop increment is changed from `i++` to `i = numViolations`, the `substring` method call parameters inside `if` condition is changed from `(256)` to `(0, 256)`, and a redundant for loop to drain remaining violations is modified to update `i` directly. These are changes in control dependency (3) and other statement changes (4).","Although there are changes in the implementation, none will cause a different return value or result in different exception handling; the violation handling logic is the same, just some optimizations and corrections in handling strings and loop increments are made. Thus, no Compatibility Issue should arise from this change."
1066,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,23,24,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int x = (int) ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int x = (int) ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = (int) ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = (int) ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    if (super.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int x = (int) ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int x = (int) ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = (int) ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = (int) ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1067,"<android.hardware.camera2.marshal.MarshalRegistry: Marshaler<T> getMarshaler(TypeReference<T>,int)>",23,24,"<android.hardware.camera2.marshal.MarshalRegistry: Marshaler<T> getMarshaler(TypeReference<T>,int)>","<android.hardware.camera2.marshal.MarshalRegistry: Marshaler<T> getMarshaler(TypeReference<T>,int)>",0,"{
    // TODO: can avoid making a new token each time by code-genning
    // the list of type tokens and native types from the keys (at the call sites)
    MarshalToken<T> marshalToken = new MarshalToken<T>(typeToken, nativeType);
    /*
         * Marshalers are instantiated lazily once they are looked up; successive lookups
         * will not instantiate new marshalers.
         */
    Marshaler<T> marshaler = (Marshaler<T>) sMarshalerMap.get(marshalToken);
    if (sRegisteredMarshalQueryables.size() == 0) {
        throw new AssertionError(""No available query marshalers registered"");
    }
    if (marshaler == null) {
        // Query each marshaler to see if they support the native/managed type combination
        for (MarshalQueryable<?> potentialMarshaler : sRegisteredMarshalQueryables) {
            MarshalQueryable<T> castedPotential = (MarshalQueryable<T>) potentialMarshaler;
            if (castedPotential.isTypeMappingSupported(typeToken, nativeType)) {
                marshaler = castedPotential.createMarshaler(typeToken, nativeType);
                break;
            }
        }
        if (marshaler == null) {
            throw new UnsupportedOperationException(""Could not find marshaler that matches the requested "" + ""combination of type reference "" + typeToken + "" and native type "" + MarshalHelpers.toStringNativeType(nativeType));
        }
        // Only put when no cached version exists to avoid +0.5ms lookup per call.
        sMarshalerMap.put(marshalToken, marshaler);
    }
    return marshaler;
}","{
    synchronized (sMarshalLock) {
        // TODO: can avoid making a new token each time by code-genning
        // the list of type tokens and native types from the keys (at the call sites)
        MarshalToken<T> marshalToken = new MarshalToken<T>(typeToken, nativeType);
        /*
             * Marshalers are instantiated lazily once they are looked up; successive lookups
             * will not instantiate new marshalers.
             */
        Marshaler<T> marshaler = (Marshaler<T>) sMarshalerMap.get(marshalToken);
        if (marshaler == null) {
            if (sRegisteredMarshalQueryables.size() == 0) {
                throw new AssertionError(""No available query marshalers registered"");
            }
            // Query each marshaler to see if they support the native/managed type combination
            for (MarshalQueryable<?> potentialMarshaler : sRegisteredMarshalQueryables) {
                MarshalQueryable<T> castedPotential = (MarshalQueryable<T>) potentialMarshaler;
                if (castedPotential.isTypeMappingSupported(typeToken, nativeType)) {
                    marshaler = castedPotential.createMarshaler(typeToken, nativeType);
                    break;
                }
            }
            if (marshaler == null) {
                throw new UnsupportedOperationException(""Could not find marshaler that matches the requested "" + ""combination of type reference "" + typeToken + "" and native type "" + MarshalHelpers.toStringNativeType(nativeType));
            }
            // Only put when no cached version exists to avoid +0.5ms lookup per call.
            sMarshalerMap.put(marshalToken, marshaler);
        }
        return marshaler;
    }
}",1,"/**
 * Lookup a marshaler between {@code T} and {@code nativeType}.
 *
 * <p>Marshalers are looked up in the order they were registered; earlier registered
 * marshal queriers get priority.</p>
 *
 * @param typeToken The compile-time type reference for {@code T}
 * @param nativeType The native type, e.g. {@link CameraMetadataNative#TYPE_BYTE TYPE_BYTE}
 * @return marshaler a non-{@code null} marshaler that supports marshaling the type combo
 *
 * @throws UnsupportedOperationException If no marshaler matching the args could be found
 */
","/**
 * Lookup a marshaler between {@code T} and {@code nativeType}.
 *
 * <p>Marshalers are looked up in the order they were registered; earlier registered
 * marshal queriers get priority.</p>
 *
 * @param typeToken The compile-time type reference for {@code T}
 * @param nativeType The native type, e.g. {@link CameraMetadataNative#TYPE_BYTE TYPE_BYTE}
 * @return marshaler a non-{@code null} marshaler that supports marshaling the type combo
 *
 * @throws UnsupportedOperationException If no marshaler matching the args could be found
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes the introduction of the `synchronized` block around the whole method implementation. Additionally, the if condition checking `sRegisteredMarshalQueryables.size() == 0` has been moved within the null check for `marshaler`, which is a control dependency change as it modifies the structure of control flow. Therefore, the change types are 3 and 4.","There is no Compatibility Issue detected here because the logic has not fundamentally changed in terms of what is returned or the exceptions that are thrown. The API behaves functionally the same as before, albeit with some internal synchronization to ensure thread safety. The movements of the checks do not change the behavior from an API consumer perspective, as the same conditions are checked and the same actions are taken. Thus, the result is 0 for no Compatibility Issue."
1068,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,23,24,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,0,"{
    AccessibilityWindowInfo infoClone = obtain();
    infoClone.mType = info.mType;
    infoClone.mLayer = info.mLayer;
    infoClone.mBooleanProperties = info.mBooleanProperties;
    infoClone.mId = info.mId;
    infoClone.mParentId = info.mParentId;
    infoClone.mBoundsInScreen.set(info.mBoundsInScreen);
    if (info.mChildIds != null && info.mChildIds.size() > 0) {
        if (infoClone.mChildIds == null) {
            infoClone.mChildIds = info.mChildIds.clone();
        } else {
            infoClone.mChildIds.addAll(info.mChildIds);
        }
    }
    infoClone.mConnectionId = info.mConnectionId;
    return infoClone;
}","{
    AccessibilityWindowInfo infoClone = obtain();
    infoClone.mType = info.mType;
    infoClone.mLayer = info.mLayer;
    infoClone.mBooleanProperties = info.mBooleanProperties;
    infoClone.mId = info.mId;
    infoClone.mParentId = info.mParentId;
    infoClone.mBoundsInScreen.set(info.mBoundsInScreen);
    infoClone.mTitle = info.mTitle;
    infoClone.mAnchorId = info.mAnchorId;
    if (info.mChildIds != null && info.mChildIds.size() > 0) {
        if (infoClone.mChildIds == null) {
            infoClone.mChildIds = info.mChildIds.clone();
        } else {
            infoClone.mChildIds.addAll(info.mChildIds);
        }
    }
    infoClone.mConnectionId = info.mConnectionId;
    return infoClone;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * @param info The other info.
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * @param info The other info.
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,Two new assignment statements are added to the method body: infoClone.mTitle = info.mTitle; and infoClone.mAnchorId = info.mAnchorId; so the code change type is 4.,"By adding these new assignments, the method is potentially returning a different value as the returned object now has more properties set from the input object, so the CI type is 1."
1069,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int,Handler,OnCloseListener)>",23,24,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int,Handler,OnCloseListener)>","<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int,Handler,OnCloseListener)>",0,"{
    if (handler == null) {
        throw new IllegalArgumentException(""Handler must not be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""Listener must not be null"");
    }
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    final FileDescriptor[] comm = createCommSocketPair();
    final ParcelFileDescriptor pfd = new ParcelFileDescriptor(fd, comm[0]);
    final MessageQueue queue = handler.getLooper().getQueue();
    queue.addOnFileDescriptorEventListener(comm[1], OnFileDescriptorEventListener.EVENT_INPUT, new OnFileDescriptorEventListener() {

        @Override
        public int onFileDescriptorEvents(FileDescriptor fd, int events) {
            Status status = null;
            if ((events & OnFileDescriptorEventListener.EVENT_INPUT) != 0) {
                final byte[] buf = new byte[MAX_STATUS];
                status = readCommStatus(fd, buf);
            } else if ((events & OnFileDescriptorEventListener.EVENT_ERROR) != 0) {
                status = new Status(Status.DEAD);
            }
            if (status != null) {
                queue.removeOnFileDescriptorEventListener(fd);
                IoUtils.closeQuietly(fd);
                listener.onClose(status.asIOException());
                return 0;
            }
            return EVENT_INPUT;
        }
    });
    return pfd;
}","{
    if (handler == null) {
        throw new IllegalArgumentException(""Handler must not be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""Listener must not be null"");
    }
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    return fromFd(fd, handler, listener);
}",1,"/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @param handler to call listener from; must not be null.
 * @param listener to be invoked when the returned descriptor has been
 * closed; must not be null.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */
","/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @param handler to call listener from; must not be null.
 * @param listener to be invoked when the returned descriptor has been
 * closed; must not be null.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",0,"The implementation has been significantly refactored by removing a block of code that created a pair of communication sockets and an event listener, and instead introduces a new method call to fromFd(fd, handler, listener). The return statement has not changed in the sense of the base method called, but how the ParcelFileDescriptor is obtained has changed, with the setup of the file descriptor being abstracted into the fromFd method.","There's no Compatibility Issue here because the final output to the user, the returned ParcelFileDescriptor, remains effectively the same from the caller’s perspective. The inner workings and setup for how this ParcelFileDescriptor is initialized have changed, but as long as the final object state and behavior are consistent with the previous version, the change should not cause any difference in behavior that a caller of this API would observe. Therefore, it does not lead to a different returned variable or throw a different exception from the public API's perspective."
1070,<android.app.admin.DevicePolicyManager: long getMaximumTimeToLock(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: long getMaximumTimeToLock(ComponentName)>,<android.app.admin.DevicePolicyManager: long getMaximumTimeToLock(ComponentName)>,0,"{
    return getMaximumTimeToLock(admin, UserHandle.myUserId());
}","{
    return getMaximumTimeToLock(admin, myUserId());
}",1,"/**
 * Retrieve the current maximum time to unlock for all admins of this user
 * and its profiles or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 * @return time in milliseconds for the given admin or the minimum value (strictest) of
 * all admins if admin is null. Returns 0 if there are no restrictions.
 */
","/**
 * Retrieve the current maximum time to unlock for a particular admin or all admins that set
 * retrictions on this user and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 * @return time in milliseconds for the given admin or the minimum value (strictest) of
 * all admins if admin is null. Returns 0 if there are no restrictions.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within return statement changed from getMaximumTimeToLock(admin, UserHandle.myUserId()) to getMaximumTimeToLock(admin, myUserId()), which indicates that the implementation of myUserId() method or the context in which it is executed might be different from UserHandle.myUserId(). This is a change in a dependent API, hence the code change type is 5.","There is no potential Compatibility Issue here if the myUserId() method returns the same value as UserHandle.myUserId() for the context of this call. It appears that the change was made only to simplify the code or perhaps `UserHandle.myUserId()` was deprecated and replaced with `myUserId()`. Without functional changes to what `myUserId()` returns compared to `UserHandle.myUserId()`, the behaviour of the API has not altered. Hence, there's no CI introduced by this change."
1071,<android.widget.SimpleMonthView: boolean onTouchEvent(MotionEvent)>,23,24,<android.widget.SimpleMonthView: boolean onTouchEvent(MotionEvent)>,<android.widget.SimpleMonthView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int x = (int) (event.getX() + 0.5f);
    final int y = (int) (event.getY() + 0.5f);
    final int action = event.getAction();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
        case MotionEvent.ACTION_MOVE:
            final int touchedItem = getDayAtLocation(x, y);
            if (mTouchedItem != touchedItem) {
                mTouchedItem = touchedItem;
                invalidate();
            }
            if (action == MotionEvent.ACTION_DOWN && touchedItem < 0) {
                // Touch something that's not an item, reject event.
                return false;
            }
            break;
        case MotionEvent.ACTION_UP:
            final int clickedDay = getDayAtLocation(x, y);
            onDayClicked(clickedDay);
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            // Reset touched day on stream end.
            mTouchedItem = -1;
            invalidate();
            break;
    }
    return true;
}","{
    final int x = (int) (event.getX() + 0.5f);
    final int y = (int) (event.getY() + 0.5f);
    final int action = event.getAction();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
        case MotionEvent.ACTION_MOVE:
            final int touchedItem = getDayAtLocation(x, y);
            mIsTouchHighlighted = true;
            if (mHighlightedDay != touchedItem) {
                mHighlightedDay = touchedItem;
                mPreviouslyHighlightedDay = touchedItem;
                invalidate();
            }
            if (action == MotionEvent.ACTION_DOWN && touchedItem < 0) {
                // Touch something that's not an item, reject event.
                return false;
            }
            break;
        case MotionEvent.ACTION_UP:
            final int clickedDay = getDayAtLocation(x, y);
            onDayClicked(clickedDay);
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            // Reset touched day on stream end.
            mHighlightedDay = -1;
            mIsTouchHighlighted = false;
            invalidate();
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency 'switch' remains the same, but inside the block there are changes in variable assignments (`mTouchedItem` vs `mHighlightedDay` and `mIsTouchHighlighted`), and a new variable is introduced (`mIsTouchHighlighted`). A variable assignment (`mTouchedItem =-1`) has been changed to `mHighlightedDay = -1` and `mIsTouchHighlighted = false` that shows both other statements and control dependency changes. Hence the change type is 3,4.","Despite the changes within the block, the logical flow and the final outcome of 'onTouchEvent' remain consistent between the two versions. At no point do the changes affect the return value or the exceptions thrown by the method. Thus, there is no Compatibility Issue."
1072,"<android.app.admin.DevicePolicyManager: void setBluetoothContactSharingDisabled(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setBluetoothContactSharingDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setBluetoothContactSharingDisabled(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setBluetoothContactSharingDisabled(admin, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setBluetoothContactSharingDisabled"");
    if (mService != null) {
        try {
            mService.setBluetoothContactSharingDisabled(admin, disabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile owner of a managed profile to set whether bluetooth
 * devices can access enterprise contacts.
 * <p>
 * The calling device admin must be a profile owner. If it is not, a
 * security exception will be thrown.
 * <p>
 * This API works on managed profile only.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param disabled If true, bluetooth devices cannot access enterprise
 * contacts.
 */
","/**
 * Called by a profile owner of a managed profile to set whether bluetooth devices can access
 * enterprise contacts.
 * <p>
 * The calling device admin must be a profile owner. If it is not, a security exception will be
 * thrown.
 * <p>
 * This API works on managed profile only.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled If true, bluetooth devices cannot access enterprise contacts.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The addition of `throwIfParentInstance(""setBluetoothContactSharingDisabled"");` is a new statement and is not a return, exception handling or control dependency change, which makes it an ""Other statement changed"" (type 4). Also, the way the `RemoteException` is handled has changed from simply logging the exception to re-throwing it, which is an ""Exception handling statement changed"" (type 2).","The new `throwIfParentInstance(""setBluetoothContactSharingDisabled"");` could throw an exception which is a behavior not present in the early version, while the change in exception handling from logging to throwing also changes what exceptions the API may propagate. Hence, these changes could lead to Compatibility Issues caused by potential different exception handlings (type 2)."
1073,<android.app.Notification.Builder: Builder setColor(int)>,23,24,<android.app.Notification.Builder: Builder setColor(int)>,<android.app.Notification.Builder: Builder setColor(int)>,0,"{
    mColor = argb;
    return this;
}","{
    mN.color = argb;
    sanitizeColor();
    return this;
}",1,"/**
 * Sets {@link Notification#color}.
 *
 * @param argb The accent color to use
 *
 * @return The same Builder.
 */
","/**
 * Sets {@link Notification#color}.
 *
 * @param argb The accent color to use
 *
 * @return The same Builder.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation assigns a color value to a different variable and calls a new method sanitizeColor(). Since there are additional operations performed in the late version, this change is classified as type 4.","There is no compatibility issue caused by these changes. The new method call sanitizeColor() appears to ensure the color value is in an acceptable range or format but does not affect the return type of the method. The return statement itself has not been altered and still returns 'this', implying no change to the return type or the value returned to the caller in any way that would result in a compatibility issue. Hence, the CI type is 0."
1074,<android.widget.AbsListView: boolean showContextMenuForChild(View)>,23,24,<android.widget.AbsListView: boolean showContextMenuForChild(View)>,<android.widget.AbsListView: boolean showContextMenuForChild(View)>,0,"{
    final int longPressPosition = getPositionForView(originalView);
    if (longPressPosition >= 0) {
        final long longPressId = mAdapter.getItemId(longPressPosition);
        boolean handled = false;
        if (mOnItemLongClickListener != null) {
            handled = mOnItemLongClickListener.onItemLongClick(AbsListView.this, originalView, longPressPosition, longPressId);
        }
        if (!handled) {
            mContextMenuInfo = createContextMenuInfo(getChildAt(longPressPosition - mFirstPosition), longPressPosition, longPressId);
            handled = super.showContextMenuForChild(originalView);
        }
        return handled;
    }
    return false;
}","{
    if (isShowingContextMenuWithCoords()) {
        return false;
    }
    return showContextMenuForChildInternal(originalView, 0, 0, false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control flow has changed, with the introduction of the if statement checking `isShowingContextMenuWithCoords()`, and the late implementation is also making a call to `showContextMenuForChildInternal(originalView, 0, 0, false)`, replacing the previous control flow and method calls. Therefore, the change type is 3,4.","Since a new if statement condition `isShowingContextMenuWithCoords()` is introduced which can potentially return false, and the method call to `showContextMenuForChildInternal(originalView, 0, 0, false)` replaces multiple condition checks and multiple return paths from early version, the API could behave differently. Hence, the CI type is 1 due to the potential of returning different values."
1075,"<android.widget.PopupWindow: void showAsDropDown(View,int,int,int)>",23,24,"<android.widget.PopupWindow: void showAsDropDown(View,int,int,int)>","<android.widget.PopupWindow: void showAsDropDown(View,int,int,int)>",0,"{
    if (isShowing() || mContentView == null) {
        return;
    }
    TransitionManager.endTransitions(mDecorView);
    registerForScrollChanged(anchor, xoff, yoff, gravity);
    mIsShowing = true;
    mIsDropdown = true;
    final WindowManager.LayoutParams p = createPopupLayoutParams(anchor.getWindowToken());
    preparePopup(p);
    final boolean aboveAnchor = findDropDownPosition(anchor, p, xoff, yoff, gravity);
    updateAboveAnchor(aboveAnchor);
    invokePopup(p);
}","{
    if (isShowing() || mContentView == null) {
        return;
    }
    TransitionManager.endTransitions(mDecorView);
    attachToAnchor(anchor, xoff, yoff, gravity);
    mIsShowing = true;
    mIsDropdown = true;
    final WindowManager.LayoutParams p = createPopupLayoutParams(anchor.getWindowToken());
    preparePopup(p);
    final boolean aboveAnchor = findDropDownPosition(anchor, p, xoff, yoff, p.width, p.height, gravity);
    updateAboveAnchor(aboveAnchor);
    p.accessibilityIdOfAnchor = (anchor != null) ? anchor.getAccessibilityViewId() : -1;
    invokePopup(p);
}",1,"/**
 * Displays the content view in a popup window anchored to the corner of
 * another view. The window is positioned according to the specified
 * gravity and offset by the specified x and y coordinates.
 * <p>
 * If there is not enough room on screen to show the popup in its entirety,
 * this method tries to find a parent scroll view to scroll. If no parent
 * view can be scrolled, the specified vertical gravity will be ignored and
 * the popup will anchor itself such that it is visible.
 * <p>
 * If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.
 *
 * @param anchor the view on which to pin the popup window
 * @param xoff A horizontal offset from the anchor in pixels
 * @param yoff A vertical offset from the anchor in pixels
 * @param gravity Alignment of the popup relative to the anchor
 *
 * @see #dismiss()
 */
","/**
 * Displays the content view in a popup window anchored to the corner of
 * another view. The window is positioned according to the specified
 * gravity and offset by the specified x and y coordinates.
 * <p>
 * If there is not enough room on screen to show the popup in its entirety,
 * this method tries to find a parent scroll view to scroll. If no parent
 * view can be scrolled, the specified vertical gravity will be ignored and
 * the popup will anchor itself such that it is visible.
 * <p>
 * If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.
 *
 * @param anchor the view on which to pin the popup window
 * @param xoff A horizontal offset from the anchor in pixels
 * @param yoff A vertical offset from the anchor in pixels
 * @param gravity Alignment of the popup relative to the anchor
 *
 * @see #dismiss()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The invocation of registerForScrollChanged() was replaced with attachToAnchor() and parameters of findDropDownPosition() were altered to include p.width and p.height. Additionally, the assignment to p.accessibilityIdOfAnchor was added. The code change type therefore includes a control dependency change (3) because the call to the updated method attachToAnchor() might rely on different control conditions, and other statement changed (4) due to the addition of parameters in the method call and the new assignment statement.","These modifications do not directly cause a change in return values or the throwing of exceptions. The signature indicates a void return type, meaning the method doesn't return any value. The added statements also do not contain any new exceptions that could be thrown. Hence, there is no compatibility issue arising from these changes."
1076,<android.animation.ValueAnimator: long getFrameDelay()>,23,24,<android.animation.ValueAnimator: long getFrameDelay()>,<android.animation.ValueAnimator: long getFrameDelay()>,0,"{
    return Choreographer.getFrameDelay();
}","{
    return AnimationHandler.getInstance().getFrameDelay();
}",1,"/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * The frame delay may be ignored when the animation system uses an external timing
 * source, such as the display refresh rate (vsync), to govern animations.
 *
 * @return the requested time between frames, in milliseconds
 */
","/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * The frame delay may be ignored when the animation system uses an external timing
 * source, such as the display refresh rate (vsync), to govern animations.
 *
 * Note that this method should be called from the same thread that {@link #start()} is
 * called in order to check the frame delay for that animation. A runtime exception will be
 * thrown if the calling thread does not have a Looper.
 *
 * @return the requested time between frames, in milliseconds
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation now calls `AnimationHandler.getInstance().getFrameDelay()` instead of `Choreographer.getFrameDelay()`. This indicates a change in the dependent API being used to get the frame delay, which is a change type 5.","Since the method is now relying on a different API to obtain the frame delay value, there is a possibility that the returned value could be different if the behavior of `AnimationHandler.getInstance().getFrameDelay()` deviates from `Choreographer.getFrameDelay()`. Thus, there is a potential Compatibility Issue causing the API to return a different value, which is CI type 1."
1077,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",23,24,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>","<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",0,"{
    if (view == null)
        return;
    final Integer pos = position;
    if (mReferences.containsKey(pos)) {
        // Notify all the references for that position of the newly loaded RemoteViews
        final LinkedList<RemoteViewsFrameLayout> refs = mReferences.get(pos);
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler);
            if (mViewToLinkedList.containsKey(ref)) {
                mViewToLinkedList.remove(ref);
            }
        }
        refs.clear();
        // Remove this set from the original mapping
        mReferences.remove(pos);
    }
}","{
    if (view == null)
        return;
    final LinkedList<RemoteViewsFrameLayout> refs = mReferences.get(position);
    if (refs != null) {
        // Notify all the references for that position of the newly loaded RemoteViews
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler);
            if (mViewToLinkedList.containsKey(ref)) {
                mViewToLinkedList.remove(ref);
            }
        }
        refs.clear();
        // Remove this set from the original mapping
        mReferences.remove(position);
    }
}",1,"/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
","/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition in the if-statement that checks for null references has been modified. The early version checks if mReferences contains the key for the provided position, while the late version checks if the retrieved reference list is not null directly. This is a change in the control dependency, so the code change type is 3.","This change does not introduce a compatibility issue because it seems to be a refactoring to clean up the code without changing the public-facing behavior. Both versions guard against a null reference before attempting to operate on the refs list, so the outcomes will be the same, meaning there is no compatibility issue with respect to the API's behavior."
1078,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,23,24,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,0,"{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }
    });
}","{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(@NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }
    });
}",1,"/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
","/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the implementation of the anonymous class `Callbacks`: the method `onServiceConnected()` now calls `AccessibilityService.this.dispatchServiceConnected()` instead of `AccessibilityService.this.onServiceConnected()`, and there are additional methods (`onMagnificationChanged`, `onSoftKeyboardShowModeChanged`, `onPerformGestureResult`) in the `Callbacks` implementation within the `IAccessibilityServiceClientWrapper`. These changes are inside the instantiation of an anonymous inner class and result in the dependent API change, so the code change type is 4,5.","There are additional callback methods implemented within the `Callbacks` anonymous inner class, but since `onBind()` is expected to return an `IBinder` object and the creation of the `IAccessibilityServiceClientWrapper` object does not intrinsically change the type or value returned by `onBind()`, there is no compatibility issue related to return values or types. All these changes indicate an extended functionality which does not affect the existing behavior and therefore should not cause a compatibility issue for the `onBind()` method itself, so the CI type is 0."
1079,"<android.app.LoaderManagerImpl: Loader<D> restartLoader(int,Bundle,LoaderCallbacks<D>)>",23,24,"<android.app.LoaderManagerImpl: Loader<D> restartLoader(int,Bundle,LoaderCallbacks<D>)>","<android.app.LoaderManagerImpl: Loader<D> restartLoader(int,Bundle,LoaderCallbacks<D>)>",0,"{
    if (mCreatingLoader) {
        throw new IllegalStateException(""Called while creating a loader"");
    }
    LoaderInfo info = mLoaders.get(id);
    if (DEBUG)
        Log.v(TAG, ""restartLoader in "" + this + "": args="" + args);
    if (info != null) {
        LoaderInfo inactive = mInactiveLoaders.get(id);
        if (inactive != null) {
            if (info.mHaveData) {
                // that now.
                if (DEBUG)
                    Log.v(TAG, ""  Removing last inactive loader: "" + info);
                inactive.mDeliveredData = false;
                inactive.destroy();
                info.mLoader.abandon();
                mInactiveLoaders.put(id, info);
            } else {
                // waiting for!  What to do, what to do...
                if (!info.mStarted) {
                    // thank-you-ma'am.
                    if (DEBUG)
                        Log.v(TAG, ""  Current loader is stopped; replacing"");
                    mLoaders.put(id, null);
                    info.destroy();
                } else {
                    // finishes or is canceled.
                    if (DEBUG)
                        Log.v(TAG, ""  Current loader is running; attempting to cancel"");
                    info.cancel();
                    if (info.mPendingLoader != null) {
                        if (DEBUG)
                            Log.v(TAG, ""  Removing pending loader: "" + info.mPendingLoader);
                        info.mPendingLoader.destroy();
                        info.mPendingLoader = null;
                    }
                    if (DEBUG)
                        Log.v(TAG, ""  Enqueuing as new pending loader"");
                    info.mPendingLoader = createLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
                    return (Loader<D>) info.mPendingLoader.mLoader;
                }
            }
        } else {
            // it when the new one completes.
            if (DEBUG)
                Log.v(TAG, ""  Making last loader inactive: "" + info);
            info.mLoader.abandon();
            mInactiveLoaders.put(id, info);
        }
    }
    info = createAndInstallLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
    return (Loader<D>) info.mLoader;
}","{
    if (mCreatingLoader) {
        throw new IllegalStateException(""Called while creating a loader"");
    }
    LoaderInfo info = mLoaders.get(id);
    if (DEBUG)
        Log.v(TAG, ""restartLoader in "" + this + "": args="" + args);
    if (info != null) {
        LoaderInfo inactive = mInactiveLoaders.get(id);
        if (inactive != null) {
            if (info.mHaveData) {
                // that now.
                if (DEBUG)
                    Log.v(TAG, ""  Removing last inactive loader: "" + info);
                inactive.mDeliveredData = false;
                inactive.destroy();
                info.mLoader.abandon();
                mInactiveLoaders.put(id, info);
            } else {
                // running and we have more work to do.
                if (!info.cancel()) {
                    // LoaderInfo will be created below.
                    if (DEBUG)
                        Log.v(TAG, ""  Current loader is stopped; replacing"");
                    mLoaders.put(id, null);
                    info.destroy();
                } else {
                    // finishes.
                    if (DEBUG)
                        Log.v(TAG, ""  Current loader is running; configuring pending loader"");
                    if (info.mPendingLoader != null) {
                        if (DEBUG)
                            Log.v(TAG, ""  Removing pending loader: "" + info.mPendingLoader);
                        info.mPendingLoader.destroy();
                        info.mPendingLoader = null;
                    }
                    if (DEBUG)
                        Log.v(TAG, ""  Enqueuing as new pending loader"");
                    info.mPendingLoader = createLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
                    return (Loader<D>) info.mPendingLoader.mLoader;
                }
            }
        } else {
            // it when the new one completes.
            if (DEBUG)
                Log.v(TAG, ""  Making last loader inactive: "" + info);
            info.mLoader.abandon();
            mInactiveLoaders.put(id, info);
        }
    }
    info = createAndInstallLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
    return (Loader<D>) info.mLoader;
}",1,"/**
 * Call to re-create the Loader associated with a particular ID.  If there
 * is currently a Loader associated with this ID, it will be
 * canceled/stopped/destroyed as appropriate.  A new Loader with the given
 * arguments will be created and its data delivered to you once available.
 *
 * <p>This function does some throttling of Loaders.  If too many Loaders
 * have been created for the given ID but not yet generated their data,
 * new calls to this function will create and return a new Loader but not
 * actually start it until some previous loaders have completed.
 *
 * <p>After calling this function, any previous Loaders associated with
 * this ID will be considered invalid, and you will receive no further
 * data updates from them.
 *
 * @param id A unique (to this LoaderManager instance) identifier under
 * which to manage the new Loader.
 * @param args Optional arguments that will be propagated to
 * {@link LoaderCallbacks#onCreateLoader(int, Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.
 * Its onCreateLoader() method will be called while inside of the function to
 * instantiate the Loader object.
 */
","/**
 * Call to re-create the Loader associated with a particular ID.  If there
 * is currently a Loader associated with this ID, it will be
 * canceled/stopped/destroyed as appropriate.  A new Loader with the given
 * arguments will be created and its data delivered to you once available.
 *
 * <p>This function does some throttling of Loaders.  If too many Loaders
 * have been created for the given ID but not yet generated their data,
 * new calls to this function will create and return a new Loader but not
 * actually start it until some previous loaders have completed.
 *
 * <p>After calling this function, any previous Loaders associated with
 * this ID will be considered invalid, and you will receive no further
 * data updates from them.
 *
 * @param id A unique (to this LoaderManager instance) identifier under
 * which to manage the new Loader.
 * @param args Optional arguments that will be propagated to
 * {@link LoaderCallbacks#onCreateLoader(int, Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.
 * Its onCreateLoader() method will be called while inside of the function to
 * instantiate the Loader object.
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"3,4",0,"There is a change within a control dependency. Instead of directly employing info.mStarted to check if the loader has started, the late implementation uses the return value of info.cancel() to determine action. This constitutes a control dependency change (3). There is also an additional logging statement to reflect the new logic, which is considered an ""Other statement changed"" (4).","Despite changes in the control flow and logging, no compatibility issue is introduced. The replacement of the check `if (!info.mStarted)` with `if (!info.cancel())` as well as new log messages do not affect the method’s contract or external behavior from the caller's perspective. It might internally change the loader's state in a different way, but ultimately the result of the method (either returning a newly created loader or a pending one) has not changed."
1083,"<android.app.admin.DevicePolicyManager: void clearUserRestriction(ComponentName,String)>",23,24,"<android.app.admin.DevicePolicyManager: void clearUserRestriction(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void clearUserRestriction(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            mService.setUserRestriction(admin, key, false);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""clearUserRestriction"");
    if (mService != null) {
        try {
            mService.setUserRestriction(admin, key, false);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile or device owner to clear a user restriction specified by the key.
 * <p>
 * The calling device admin must be a profile or device owner; if it is not,
 * a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param key The key of the restriction. See the constants in
 * {@link android.os.UserManager} for the list of keys.
 */
","/**
 * Called by a profile or device owner to clear a user restriction specified by the key.
 * <p>
 * The calling device admin must be a profile or device owner; if it is not, a security
 * exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param key The key of the restriction. See the constants in {@link android.os.UserManager}
 * for the list of keys.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5","1,2","An additional method call 'throwIfParentInstance(""clearUserRestriction"")' is introduced before the existing control dependency, and the exception handling has changed from logging an error to throwing an exception. Hence, the code changes identified are 4 for the additional method call and 5 since it's a possible dependent API change. ","The addition of 'throwIfParentInstance(""clearUserRestriction"")' could lead to a new RuntimeException being thrown if the condition is met (thus potentially changing the API's behavior by not performing the rest of the method when this new condition triggers an exception), and the new exception handling changes the API from catching and logging a RemoteException to rethrowing it. Therefore, there can be CI due to both different return values or types (1, because if an exception is thrown this call returns nothing) and different exception handlings (2, because it explicitly throws a new type of exception – SystemServerException – if 'throwIfParentInstance' fails)."
1084,"<android.content.res.Resources: InputStream openRawResource(int,TypedValue)>",23,24,"<android.content.res.Resources: InputStream openRawResource(int,TypedValue)>","<android.content.res.Resources: InputStream openRawResource(int,TypedValue)>",0,"{
    getValue(id, value, true);
    try {
        return mAssets.openNonAsset(value.assetCookie, value.string.toString(), AssetManager.ACCESS_STREAMING);
    } catch (Exception e) {
        NotFoundException rnf = new NotFoundException(""File "" + value.string.toString() + "" from drawable resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(e);
        throw rnf;
    }
}","{
    return mResourcesImpl.openRawResource(id, value);
}",1,"/**
 * Open a data stream for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset file -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * @param id The resource identifier to open, as generated by the appt tool.
 * @param value The TypedValue object to hold the resource information.
 *
 * @return InputStream Access to the resource data.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Open a data stream for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset file -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * @param id The resource identifier to open, as generated by the appt tool.
 * @param value The TypedValue object to hold the resource information.
 *
 * @return InputStream Access to the resource data.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed because now it directly calls a different method, `mResourcesImpl.openRawResource(id, value)`, instead of calling a sequence of method calls within the implementation. Therefore, we classify this as a return statement changed (1) and dependent API changed (5) since the implementation relies on a newly introduced API from the mResourcesImpl object.","This change could lead to a different return value since it is now using an entirely different method to acquire the InputStream, hence it is classified as a compatibility issue caused by potential different return values (1)."
1085,<android.os.PowerManager: void reboot(String)>,23,24,<android.os.PowerManager: void reboot(String)>,<android.os.PowerManager: void reboot(String)>,0,"{
    try {
        mService.reboot(false, reason, true);
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.reboot(false, reason, true);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Reboot the device.  Will not return if the reboot is successful.
 * <p>
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 * </p>
 *
 * @param reason code to pass to the kernel (e.g., ""recovery"") to
 * request special boot modes, or null.
 */
","/**
 * Reboot the device.  Will not return if the reboot is successful.
 * <p>
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 * </p>
 *
 * @param reason code to pass to the kernel (e.g., ""recovery"") to
 * request special boot modes, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"Exception handling statement has changed; a new 'throw' statement, throw e.rethrowFromSystemServer(), has been added in the catch block in the late version code, thus the change type is 2.","The addition of the throw statement in the catch block can lead to a different exception handling (propagating the exception instead of swallowing it). Therefore, a Compatibility Issue arises due to potential changes in exception behavior, and the CI type is 2."
1087,"<android.widget.TabWidget: void measureHorizontal(int,int)>",23,24,"<android.widget.TabWidget: void measureHorizontal(int,int)>","<android.widget.TabWidget: void measureHorizontal(int,int)>",0,"{
    if (MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        super.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    // First, measure with no constraint
    final int width = MeasureSpec.getSize(widthMeasureSpec);
    final int unspecifiedWidth = MeasureSpec.makeSafeMeasureSpec(width, MeasureSpec.UNSPECIFIED);
    mImposedTabsHeight = -1;
    super.measureHorizontal(unspecifiedWidth, heightMeasureSpec);
    int extraWidth = getMeasuredWidth() - width;
    if (extraWidth > 0) {
        final int count = getChildCount();
        int childCount = 0;
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() == GONE)
                continue;
            childCount++;
        }
        if (childCount > 0) {
            if (mImposedTabWidths == null || mImposedTabWidths.length != count) {
                mImposedTabWidths = new int[count];
            }
            for (int i = 0; i < count; i++) {
                final View child = getChildAt(i);
                if (child.getVisibility() == GONE)
                    continue;
                final int childWidth = child.getMeasuredWidth();
                final int delta = extraWidth / childCount;
                final int newWidth = Math.max(0, childWidth - delta);
                mImposedTabWidths[i] = newWidth;
                // Make sure the extra width is evenly distributed, no int division remainder
                // delta may have been clamped
                extraWidth -= childWidth - newWidth;
                childCount--;
                mImposedTabsHeight = Math.max(mImposedTabsHeight, child.getMeasuredHeight());
            }
        }
    }
    // Measure again, this time with imposed tab widths and respecting initial spec request
    super.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
}","{
    if (MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        super.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    // First, measure with no constraint
    final int width = MeasureSpec.getSize(widthMeasureSpec);
    final int unspecifiedWidth = MeasureSpec.makeSafeMeasureSpec(width, MeasureSpec.UNSPECIFIED);
    mImposedTabsHeight = -1;
    super.measureHorizontal(unspecifiedWidth, heightMeasureSpec);
    int extraWidth = getMeasuredWidth() - width;
    if (extraWidth > 0) {
        final int count = getChildCount();
        int childCount = 0;
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() == GONE)
                continue;
            childCount++;
        }
        if (childCount > 0) {
            if (mImposedTabWidths == null || mImposedTabWidths.length != count) {
                mImposedTabWidths = new int[count];
            }
            for (int i = 0; i < count; i++) {
                final View child = getChildAt(i);
                if (child.getVisibility() == GONE)
                    continue;
                final int childWidth = child.getMeasuredWidth();
                final int delta = extraWidth / childCount;
                final int newWidth = Math.max(0, childWidth - delta);
                mImposedTabWidths[i] = newWidth;
                // Make sure the extra width is evenly distributed, no int division remainder
                // delta may have been clamped
                extraWidth -= childWidth - newWidth;
                childCount--;
                mImposedTabsHeight = Math.max(mImposedTabsHeight, child.getMeasuredHeight());
            }
        }
    }
    // Measure again, this time with imposed tab widths and respecting
    // initial spec request.
    super.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"No change in the code between the two versions, both implementations and annotations are identical.","Since there is no code change, there is no compatibility issue between these two versions."
1088,"<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>",23,24,"<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>","<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There's a new variable introduced (`final int attrIndex = index;`) and the variable `index` is now used differently in `getValueAt(index, value);` compared to the early version `getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);`. Additionally, the error message in the UnsupportedOperationException thrown has been updated to include the attribute index. So, the changes are classified as 3 for the control dependency change due to different use of the 'index' and 4 for other statement changes due to the introduction of a new local variable and the modification of the error message.","The change in index calculation (removal of the multiplication with `AssetManager.STYLE_NUM_ENTRIES` in `getValueAt`) can potentially lead to a different value retrieved, and subsequently, a different exception message, which makes it a compatibility issue. The API could potentially return different values because `getValueAt` might resolve a different attribute, thus causing a CI type 1."
1089,<android.service.notification.ConditionProviderService.H: void handleMessage(Message)>,23,24,<android.service.notification.ConditionProviderService.H: void handleMessage(Message)>,<android.service.notification.ConditionProviderService.H: void handleMessage(Message)>,0,"{
    String name = null;
    try {
        switch(msg.what) {
            case ON_CONNECTED:
                name = ""onConnected"";
                onConnected();
                break;
            case ON_REQUEST_CONDITIONS:
                name = ""onRequestConditions"";
                onRequestConditions(msg.arg1);
                break;
            case ON_SUBSCRIBE:
                name = ""onSubscribe"";
                onSubscribe((Uri) msg.obj);
                break;
            case ON_UNSUBSCRIBE:
                name = ""onUnsubscribe"";
                onUnsubscribe((Uri) msg.obj);
                break;
        }
    } catch (Throwable t) {
        Log.w(TAG, ""Error running "" + name, t);
    }
}","{
    String name = null;
    try {
        switch(msg.what) {
            case ON_CONNECTED:
                name = ""onConnected"";
                onConnected();
                break;
            case ON_SUBSCRIBE:
                name = ""onSubscribe"";
                onSubscribe((Uri) msg.obj);
                break;
            case ON_UNSUBSCRIBE:
                name = ""onUnsubscribe"";
                onUnsubscribe((Uri) msg.obj);
                break;
        }
    } catch (Throwable t) {
        Log.w(TAG, ""Error running "" + name, t);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The `ON_REQUEST_CONDITIONS` case has been removed from the switch statement, meaning a return statement under this case condition has been deleted. The control condition has changed because a case in the switch statement (the control dependency) has been removed, so the change types are 1,3.","The removal of case `ON_REQUEST_CONDITIONS` could lead to a different execution flow, which could cause a different return behavior for input messages with `msg.what` corresponding to `ON_REQUEST_CONDITIONS`. This may manifest as either no operation occurring when the message is received or an exception being thrown if `msg.what` is not associated with other cases. Therefore, the API could behave differently than before, indicating a CI of type 1."
1090,<android.content.res.Resources: float getDimension(int)>,23,24,<android.content.res.Resources: float getDimension(int)>,<android.content.res.Resources: float getDimension(int)>,0,"{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimension(value.data, mMetrics);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimension(value.data, impl.getDisplayMetrics());
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Retrieve a dimensional for a particular resource ID.  Unit
 * conversions are based on the current {@link DisplayMetrics} associated
 * with the resources.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional for a particular resource ID.  Unit
 * conversions are based on the current {@link DisplayMetrics} associated
 * with the resources.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The way TypedValue is obtained and released has changed (introduction of obtainTempTypedValue() and releaseTempTypedValue(value)), and the reference to mMetrics has been changed to using impl.getDisplayMetrics() from a ResourcesImpl object. This constitutes changes in how resources are managed internally, but it looks like the return values should remain consistent. There are also internal resource management changes, which are reflected in the addition of a try-finally block. The code changes are categorized as control dependency change (3) due to the try-finally block, and other statement changed (4) due to changes in resource access patterns.","There is no Compatibility Issue because the method's behavior in terms of computing and returning a dimension, as well as the exception thrown, remain unchanged. The return value and exception throwing are the same under the same conditions, preserving compatibility for the user of the API."
1093,"<android.app.ActivityTransitionState: void setEnterActivityOptions(Activity,ActivityOptions)>",23,24,"<android.app.ActivityTransitionState: void setEnterActivityOptions(Activity,ActivityOptions)>","<android.app.ActivityTransitionState: void setEnterActivityOptions(Activity,ActivityOptions)>",0,"{
    if (activity.getWindow().hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS) && options != null && mEnterActivityOptions == null && mEnterTransitionCoordinator == null && options.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) {
        mEnterActivityOptions = options;
        mIsEnterTriggered = false;
        if (mEnterActivityOptions.isReturning()) {
            restoreExitedViews();
            int result = mEnterActivityOptions.getResultCode();
            if (result != 0) {
                activity.onActivityReenter(result, mEnterActivityOptions.getResultData());
            }
        }
    }
}","{
    final Window window = activity.getWindow();
    if (window == null) {
        return;
    }
    // ensure Decor View has been created so that the window features are activated
    window.getDecorView();
    if (window.hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS) && options != null && mEnterActivityOptions == null && mEnterTransitionCoordinator == null && options.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) {
        mEnterActivityOptions = options;
        mIsEnterTriggered = false;
        if (mEnterActivityOptions.isReturning()) {
            restoreExitedViews();
            int result = mEnterActivityOptions.getResultCode();
            if (result != 0) {
                activity.onActivityReenter(result, mEnterActivityOptions.getResultData());
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3, 4",0,"In the late version, an additional check for whether 'window' is 'null' is introduced and an additional method call 'window.getDecorView()' is added, which ensures the DecorView has been created. These changes account for additional control dependency (the null check) and other statement changes (the method call). The code change types are 3 and 4.","There is no Compatibility Issue because the changes made neither affect the return value (which does not exist since the return type of the method is 'void') nor the exception handling (no new exceptions are thrown, nor is the handling of existing exceptions changed). Therefore, an invocation of setEnterActivityOptions after these changes would not lead to different behavior in terms of output or error handling, and CI type is 0."
1094,"<android.content.pm.PackageInstaller: void uninstall(String,IntentSender)>",23,24,"<android.content.pm.PackageInstaller: void uninstall(String,IntentSender)>","<android.content.pm.PackageInstaller: void uninstall(String,IntentSender)>",0,"{
    try {
        mInstaller.uninstall(packageName, mInstallerPackageName, 0, statusReceiver, mUserId);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        mInstaller.uninstall(packageName, mInstallerPackageName, 0, statusReceiver, mUserId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Uninstall the given package, removing it completely from the device. This
 * method is only available to the current ""installer of record"" for the
 * package.
 */
","/**
 * Uninstall the given package, removing it completely from the device. This
 * method is only available to the current ""installer of record"" for the
 * package.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, from throw e.rethrowAsRuntimeException() to throw e.rethrowFromSystemServer(), so the code change type is 2.","The change in the exception handling could lead to a different exception being thrown, even though the handling is for the same base exception type (RemoteException), the method it calls is different. Therefore, there is a potential for a different exception behavior, and the CI type is 2."
1095,"<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String,Bundle)>",23,24,"<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String,Bundle)>","<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String,Bundle)>",0,"{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = mTarget.send(code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, options);
        if (res < 0) {
            throw new CanceledException();
        }
    } catch (RemoteException e) {
        throw new CanceledException(e);
    }
}","{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManagerNative.getDefault().sendIntentSender(mTarget, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, options);
        if (res < 0) {
            throw new CanceledException();
        }
    } catch (RemoteException e) {
        throw new CanceledException(e);
    }
}",1,"/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was
 * created, this argument will be ignored.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sending
 * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 * @see #send(Context, int, Intent, OnFinished, Handler)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
","/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was
 * created, this argument will be ignored.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sending
 * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 * @see #send(Context, int, Intent, OnFinished, Handler)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changed in the way it sends the intent from `mTarget.send` to `ActivityManagerNative.getDefault().sendIntentSender(mTarget, ...)`. This indicates that the dependent API being used to send the intent has changed, therefore the code change type is 5.","There is no CI detected since although the dependent API has changed, both the old and new methods serve the same purpose and are expected to have the same behavior when it comes to sending the intent. Thus, the changes should not result in potential Compatibility Issues related to return values or exceptions thrown by the method."
1096,"<android.util.Log: int w(String,Throwable)>",23,24,"<android.util.Log: int w(String,Throwable)>","<android.util.Log: int w(String,Throwable)>",0,"{
    return println_native(LOG_ID_MAIN, WARN, tag, getStackTraceString(tr));
}","{
    return printlns(LOG_ID_MAIN, WARN, tag, """", tr);
}",1,"/*
     * Send a {@link #WARN} log message and log the exception.
     * @param tag Used to identify the source of a log message.  It usually identifies
     *        the class or activity where the log call occurs.
     * @param tr An exception to log
     */
","/*
     * Send a {@link #WARN} log message and log the exception.
     * @param tag Used to identify the source of a log message.  It usually identifies
     *        the class or activity where the log call occurs.
     * @param tr An exception to log
     */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method called within the return statement has changed from println_native to printlns and the parameters passed to the method have also changed, indicating the code change type is 1,5.","The change in method invocation and the adjustment of parameters can potentially lead to a different return value, thus the CI type is 1."
1098,<android.app.ActivityThread.Profiler: void startProfiling()>,23,24,<android.app.ActivityThread.Profiler: void startProfiling()>,<android.app.ActivityThread.Profiler: void startProfiling()>,0,"{
    if (profileFd == null || profiling) {
        return;
    }
    try {
        VMDebug.startMethodTracing(profileFile, profileFd.getFileDescriptor(), 8 * 1024 * 1024, 0, samplingInterval != 0, samplingInterval);
        profiling = true;
    } catch (RuntimeException e) {
        Slog.w(TAG, ""Profiling failed on path "" + profileFile);
        try {
            profileFd.close();
            profileFd = null;
        } catch (IOException e2) {
            Slog.w(TAG, ""Failure closing profile fd"", e2);
        }
    }
}","{
    if (profileFd == null || profiling) {
        return;
    }
    try {
        int bufferSize = SystemProperties.getInt(""debug.traceview-buffer-size-mb"", 8);
        VMDebug.startMethodTracing(profileFile, profileFd.getFileDescriptor(), bufferSize * 1024 * 1024, 0, samplingInterval != 0, samplingInterval);
        profiling = true;
    } catch (RuntimeException e) {
        Slog.w(TAG, ""Profiling failed on path "" + profileFile);
        try {
            profileFd.close();
            profileFd = null;
        } catch (IOException e2) {
            Slog.w(TAG, ""Failure closing profile fd"", e2);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation change is an additional call to SystemProperties.getInt() to determine the bufferSize as opposed to a hard-coded value of 8 MB. This change does not alter the method's control flow or exception handling, so the code change type is 4.","Since the method's signature, return type, and the exceptions it can throw remain unaltered, and the change in buffer size will not affect how the method behaves from a caller's perspective (as it merely modifies the buffer size used for profiling), there is no compatibility issue. The method still starts the profiling process with a buffer size that is either default or defined by a system property. Hence, the behavior from the caller's standpoint remains consistent, and this change is unlikely to introduce a compatibility issue. The CI is 0."
1101,<android.bluetooth.BluetoothAdapter: boolean enable()>,23,24,<android.bluetooth.BluetoothAdapter: boolean enable()>,<android.bluetooth.BluetoothAdapter: boolean enable()>,0,"{
    int state = STATE_OFF;
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, ""enable(): BT is already enabled..!"");
        return true;
    }
    // Use service interface to get the exact state
    if (mService != null) {
        try {
            state = mService.getState();
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    if (state == BluetoothAdapter.STATE_BLE_ON) {
        Log.e(TAG, ""BT is in BLE_ON State"");
        notifyUserAction(true);
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, ""enable(): BT is already enabled..!"");
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */
","/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,"1,3",1,"The check for the Bluetooth adapter state and the associated code block has been removed. This is a control dependency change (type 3), which also alters a return statement (type 1).","This alteration could lead to a Compatibility Issue because in the early version, there is a scenario where the method would return true if the state was BluetoothAdapter.STATE_BLE_ON, which can no longer occur in the late version. Therefore, the method could return a different value, which constitutes a CI of type 1."
1102,"<android.content.pm.LauncherApps: boolean isActivityEnabled(ComponentName,UserHandle)>",23,24,"<android.content.pm.LauncherApps: boolean isActivityEnabled(ComponentName,UserHandle)>","<android.content.pm.LauncherApps: boolean isActivityEnabled(ComponentName,UserHandle)>",0,"{
    try {
        return mService.isActivityEnabled(component, user);
    } catch (RemoteException re) {
        throw new RuntimeException(""Failed to call LauncherAppsService"");
    }
}","{
    try {
        return mService.isActivityEnabled(component, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Checks if the activity exists and it enabled for a profile.
 *
 * @param component The activity to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the activity exists and is enabled.
 */
","/**
 * Checks if the activity exists and it enabled for a profile.
 *
 * @param component The activity to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the activity exists and is enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. The catch block now throws the RemoteException as rethrowFromSystemServer(), instead of throwing a new RuntimeException with a custom message as in the early version.","Since the late version of the API throws a different exception than the early version (rethrowFromSystemServer() instead of a new RuntimeException), this results in a compatibility issue due to potential different exception handlings. The CI type is 2 because the API may throw different exceptions between the two versions."
1103,<android.app.ContextImpl: Context createDisplayContext(Display)>,23,24,<android.app.ContextImpl: Context createDisplayContext(Display)>,<android.app.ContextImpl: Context createDisplayContext(Display)>,0,"{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mRestricted, display, null, Display.INVALID_DISPLAY);
}","{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mFlags, display, null, Display.INVALID_DISPLAY);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The parameter `mRestricted` is replaced by `mFlags` in the constructor of `ContextImpl`. This is a change in a parameter in the method call, and it does not affect control flow or exception handling, so the change type is 4 (Other statement changed).","The modification from `mRestricted` to `mFlags` does not introduce CI because it likely represents a change where different information is being passed to the `ContextImpl` constructor to maintain the same functionality under different names or flag definitions. There is no indication that this would affect the API's return value or the exceptions it throws, assuming the `ContextImpl` constructor properly processes the passed argument. Therefore, the CI type is 0 (No Compatibility Issue)."
1104,"<android.hardware.camera2.legacy.CameraDeviceUserShim: int createInputStream(int,int,int)>",23,24,"<android.hardware.camera2.legacy.CameraDeviceUserShim: int createInputStream(int,int,int)>","<android.hardware.camera2.legacy.CameraDeviceUserShim: int createInputStream(int,int,int)>",0,"{
    Log.e(TAG, ""creating input stream is not supported on legacy devices"");
    return CameraBinderDecorator.INVALID_OPERATION;
}","{
    String err = ""Creating input stream is not supported on legacy devices"";
    Log.e(TAG, err);
    throw new ServiceSpecificException(ICameraService.ERROR_INVALID_OPERATION, err);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2","1,2","The API originally returned a constant value indicating an invalid operation, but in the late version, it throws a new ServiceSpecificException instead, which constitutes a change in both the return statement and exception handling statement.","Due to the introduction of a new throw statement and the removal of the original return statement, the API will now throw an exception instead of returning a value which leads to a change in both the return behavior and the exception handling behavior. Thus, the CI type is 1,2."
1105,<android.content.res.Configuration: int compareTo(Configuration)>,23,24,<android.content.res.Configuration: int compareTo(Configuration)>,<android.content.res.Configuration: int compareTo(Configuration)>,0,"{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    if (this.locale == null) {
        if (that.locale != null)
            return 1;
    } else if (that.locale == null) {
        return -1;
    } else {
        n = this.locale.getLanguage().compareTo(that.locale.getLanguage());
        if (n != 0)
            return n;
        n = this.locale.getCountry().compareTo(that.locale.getCountry());
        if (n != 0)
            return n;
        n = this.locale.getVariant().compareTo(that.locale.getVariant());
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    // if (n != 0) return n;
    return n;
}","{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    fixUpLocaleList();
    that.fixUpLocaleList();
    // than any non-empty locale list.
    if (this.mLocaleList.isEmpty()) {
        if (!that.mLocaleList.isEmpty())
            return 1;
    } else if (that.mLocaleList.isEmpty()) {
        return -1;
    } else {
        final int minSize = Math.min(this.mLocaleList.size(), that.mLocaleList.size());
        for (int i = 0; i < minSize; ++i) {
            final Locale thisLocale = this.mLocaleList.get(i);
            final Locale thatLocale = that.mLocaleList.get(i);
            n = thisLocale.getLanguage().compareTo(thatLocale.getLanguage());
            if (n != 0)
                return n;
            n = thisLocale.getCountry().compareTo(thatLocale.getCountry());
            if (n != 0)
                return n;
            n = thisLocale.getVariant().compareTo(thatLocale.getVariant());
            if (n != 0)
                return n;
            n = thisLocale.toLanguageTag().compareTo(thatLocale.toLanguageTag());
            if (n != 0)
                return n;
        }
        n = this.mLocaleList.size() - that.mLocaleList.size();
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    // if (n != 0) return n;
    return n;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
1107,<android.app.admin.DevicePolicyManager: SystemUpdatePolicy getSystemUpdatePolicy()>,23,24,<android.app.admin.DevicePolicyManager: SystemUpdatePolicy getSystemUpdatePolicy()>,<android.app.admin.DevicePolicyManager: SystemUpdatePolicy getSystemUpdatePolicy()>,0,"{
    if (mService != null) {
        try {
            return mService.getSystemUpdatePolicy();
        } catch (RemoteException re) {
            Log.w(TAG, ""Error calling getSystemUpdatePolicy"", re);
        }
    }
    return null;
}","{
    throwIfParentInstance(""getSystemUpdatePolicy"");
    if (mService != null) {
        try {
            return mService.getSystemUpdatePolicy();
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Retrieve a local system update policy set previously by {@link #setSystemUpdatePolicy}.
 *
 * @return The current policy object, or {@code null} if no policy is set.
 */
","/**
 * Retrieve a local system update policy set previously by {@link #setSystemUpdatePolicy}.
 *
 * @return The current policy object, or {@code null} if no policy is set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"A new method call `throwIfParentInstance(""getSystemUpdatePolicy"")` is added at the beginning of the late version, and a catch block is changed to throw a new exception, so the change types are 2 (Exception handling statement changed), and 4 (Other statement changed).","The addition of the `throwIfParentInstance(""getSystemUpdatePolicy"")` call can throw an exception that was not thrown before, and the change in the catch block to throw an exception instead of logging it can lead to different exception handling behavior, therefore the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
1108,"<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>",23,24,"<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"1,4,5","1,2","There's an Other statement changed where `intent.prepareToLeaveProcess();` is replaced with `intent.prepareToLeaveProcess(this);` and the method signature changed to include an additional parameter. This change involves a Dependent API as the method `prepareToLeaveProcess` possibly has a different behavior with the new parameter. Also, the `throw` statement in the catch block has changed, so it could throw a different exception now. The code change types are 1 (because there's a change in the method `prepareToLeaveProcess` that could affect the return type), 4 (other change in the statement), and 5 (dependent API changed).","There is a Compatibility Issue caused by potential different return values or types (1) given that the method `prepareToLeaveProcess` now receives a parameter and could behave differently which can subsequently affect the outcomes from `ActivityManagerNative.getDefault().unbroadcastIntent(...)`. Additionally, there is a Compatibility Issue caused by potential different exception handlings (2) as the old implementation throws a `RuntimeException`, whereas the new implementation throws an exception from `rethrowFromSystemServer()` which could be different from `RuntimeException`. The CI types are 1 and 2."
1109,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,23,24,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,0,"{
    if (DEBUG) {
        Log.d(TAG, ""createStream called."");
    }
    if (mLegacyDevice.isClosed()) {
        Log.e(TAG, ""Cannot create stream, device has been closed."");
        return CameraBinderDecorator.ENODEV;
    }
    synchronized (mConfigureLock) {
        if (!mConfiguring) {
            Log.e(TAG, ""Cannot create stream, beginConfigure hasn't been called yet."");
            return CameraBinderDecorator.INVALID_OPERATION;
        }
        if (outputConfiguration.getRotation() != OutputConfiguration.ROTATION_0) {
            Log.e(TAG, ""Cannot create stream, stream rotation is not supported."");
            return CameraBinderDecorator.INVALID_OPERATION;
        }
        int id = ++mSurfaceIdCounter;
        mSurfaces.put(id, outputConfiguration.getSurface());
        return id;
    }
}","{
    if (DEBUG) {
        Log.d(TAG, ""createStream called."");
    }
    if (mLegacyDevice.isClosed()) {
        String err = ""Cannot create stream, device has been closed."";
        Log.e(TAG, err);
        throw new ServiceSpecificException(ICameraService.ERROR_DISCONNECTED, err);
    }
    synchronized (mConfigureLock) {
        if (!mConfiguring) {
            String err = ""Cannot create stream, beginConfigure hasn't been called yet."";
            Log.e(TAG, err);
            throw new ServiceSpecificException(ICameraService.ERROR_INVALID_OPERATION, err);
        }
        if (outputConfiguration.getRotation() != OutputConfiguration.ROTATION_0) {
            String err = ""Cannot create stream, stream rotation is not supported."";
            Log.e(TAG, err);
            throw new ServiceSpecificException(ICameraService.ERROR_ILLEGAL_ARGUMENT, err);
        }
        int id = ++mSurfaceIdCounter;
        mSurfaces.put(id, outputConfiguration.getSurface());
        return id;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The method in the late version replaces return statements with throw statements that include ServiceSpecificException, and additional String variables are declared to store error messages. The changes involve exception handling statements and variable declaration statements, so the code change type is 2,4.","The change from returning error codes to throwing exceptions signifies a difference in the control flow and the way error conditions are communicated, leading to potential Compatibility Issues due to different exception handlings. The client code that previously expected return values for certain error conditions will now have to handle exceptions instead. Therefore, the CI type is 2."
1110,"<android.app.DatePickerDialog: int resolveDialogTheme(Context,int)>",23,24,"<android.app.DatePickerDialog: int resolveDialogTheme(Context,int)>","<android.app.DatePickerDialog: int resolveDialogTheme(Context,int)>",0,"{
    if (resid == 0) {
        final TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(R.attr.datePickerDialogTheme, outValue, true);
        return outValue.resourceId;
    } else {
        return resid;
    }
}","{
    if (themeResId == 0) {
        final TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(R.attr.datePickerDialogTheme, outValue, true);
        return outValue.resourceId;
    } else {
        return themeResId;
    }
}",1,,,-1,,[@StyleRes],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the renaming of the parameter from `resid` to `themeResId`. This is a change in the parameter name, which corresponds to the refactoring of code and does not affect the method's behavior, so the code change type is 4.","Since only the parameter name has been changed, but the logic, return values, and exception handling remain untouched, there is no compatibility issue. The compatibility issue type is 0."
1111,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",23,24,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",0,"{
    int block = loadResourceValue(ident, (short) density, outValue, resolveRefs);
    if (block >= 0) {
        if (outValue.type != TypedValue.TYPE_STRING) {
            return true;
        }
        outValue.string = mStringBlocks[block].get(outValue.data);
        return true;
    }
    return false;
}","{
    final int block = loadResourceValue(resId, (short) densityDpi, outValue, resolveRefs);
    if (block < 0) {
        return false;
    }
    if (outValue.type == TypedValue.TYPE_STRING) {
        outValue.string = mStringBlocks[block].get(outValue.data);
    }
    return true;
}",1,"/*package*/
","/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The control dependency has changed. The `if` condition is negated and the positioning of the `return false;` and `return true;` statements are altered.,"The changes in control flow do not affect the potential behavior of the API. It still returns true if the block is found, false if not, and properly sets `outValue.string` if the type is `TYPE_STRING`. Therefore, there is no compatibility issue."
1113,<android.app.WallpaperManager: Drawable getBuiltInDrawable()>,23,24,<android.app.WallpaperManager: Drawable getBuiltInDrawable()>,<android.app.WallpaperManager: Drawable getBuiltInDrawable()>,0,"{
    return getBuiltInDrawable(0, 0, false, 0, 0);
}","{
    return getBuiltInDrawable(0, 0, false, 0, 0, FLAG_SYSTEM);
}",1,"/**
 * Returns a drawable for the system built-in static wallpaper .
 */
","/**
 * Obtain a drawable for the built-in static system wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,5,"The number of parameters in the call to the method getBuiltInDrawable() has changed by adding an additional flag parameter FLAG_SYSTEM. Therefore, the code change type is 5.","The change in parameters to the dependent method getBuiltInDrawable() could potentially alter the behavior of the API if the implementation of getBuiltInDrawable() behaves differently based on the new parameter. Therefore, the CI type is 5, indicating a potential difference in the returned Drawable."
1114,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,23,24,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,0,"{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !isTextSelectable() && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
    if (hasPasswordTransformationMethod()) {
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
    }
}","{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !isTextSelectable() && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
    if (hasPasswordTransformationMethod()) {
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
    }
    // PasswordTransformationMethod always have LTR text direction heuristics returned by
    // getTextDirectionHeuristic, needs reset
    mTextDir = getTextDirectionHeuristic();
}",1,"/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
","/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new line of code (`mTextDir = getTextDirectionHeuristic();`) has been added at the end of the method, which is not a part of return statement, exception handling or control dependency, hence the code change type is 4. ",The added line sets the `mTextDir` property but does not alter the method's behavior in terms of its return value (void method) or the exceptions it throws. There is no Compatibility Issue as the method's contract remains unchanged; it is an internal state change within the object.
1115,<android.app.ContextImpl: File getCacheDir()>,23,24,<android.app.ContextImpl: File getCacheDir()>,<android.app.ContextImpl: File getCacheDir()>,0,"{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDirFile(), ""cache"");
        }
        return createFilesDirLocked(mCacheDir);
    }
}","{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDir(), ""cache"");
        }
        return ensurePrivateDirExists(mCacheDir);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,The implementation has two changes: ,
1116,<android.net.ConnectivityManager: void reportBadNetwork(Network)>,23,24,<android.net.ConnectivityManager: void reportBadNetwork(Network)>,<android.net.ConnectivityManager: void reportBadNetwork(Network)>,0,"{
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
    }
}","{
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Report a problem network to the framework.  This provides a hint to the system
 * that there might be connectivity problems on this network and may cause
 * the framework to re-evaluate network connectivity and/or switch to another
 * network.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @deprecated Use {@link #reportNetworkConnectivity} which allows reporting both
 * working and non-working connectivity.
 */
","/**
 * Report a problem network to the framework.  This provides a hint to the system
 * that there might be connectivity problems on this network and may cause
 * the framework to re-evaluate network connectivity and/or switch to another
 * network.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @deprecated Use {@link #reportNetworkConnectivity} which allows reporting both
 * working and non-working connectivity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has been changed by adding ""throw e.rethrowFromSystemServer();"" in the late version, so the code change type is 2.","The change in exception handling could potentially lead to a different exception being thrown in the late version, hence the CI type is 2."
1117,<android.app.Notification.Builder: Builder setContentText(CharSequence)>,23,24,<android.app.Notification.Builder: Builder setContentText(CharSequence)>,<android.app.Notification.Builder: Builder setContentText(CharSequence)>,0,"{
    mContentText = safeCharSequence(text);
    return this;
}","{
    mN.extras.putCharSequence(EXTRA_TEXT, safeCharSequence(text));
    return this;
}",1,"/**
 * Set the second line of text in the platform notification template.
 */
","/**
 * Set the second line of text in the platform notification template.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method implementation has changed as it now uses a different approach to set the content text by putting it into an 'extras' bundle rather than directly setting a field. This indicates that a dependent API has changed, hence the code change type is 5.","Although the implementation has changed, there is no Compatibility Issue with respect to the set content text behavior from a client point of view. The Builder pattern is designed to allow such internal changes without affecting the API's contract. The method still accepts a CharSequence and returns the Builder with updated content, consistent with the earlier version. Therefore, there is no Compatibility Issue, 0."
1118,<android.view.View: void setForeground(Drawable)>,23,24,<android.view.View: void setForeground(Drawable)>,<android.view.View: void setForeground(Drawable)>,0,"{
    if (mForegroundInfo == null) {
        if (foreground == null) {
            // Nothing to do.
            return;
        }
        mForegroundInfo = new ForegroundInfo();
    }
    if (foreground == mForegroundInfo.mDrawable) {
        // Nothing to do
        return;
    }
    if (mForegroundInfo.mDrawable != null) {
        mForegroundInfo.mDrawable.setCallback(null);
        unscheduleDrawable(mForegroundInfo.mDrawable);
    }
    mForegroundInfo.mDrawable = foreground;
    mForegroundInfo.mBoundsChanged = true;
    if (foreground != null) {
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        foreground.setCallback(this);
        foreground.setLayoutDirection(getLayoutDirection());
        if (foreground.isStateful()) {
            foreground.setState(getDrawableState());
        }
        applyForegroundTint();
    } else if ((mViewFlags & WILL_NOT_DRAW) != 0 && mBackground == null) {
        mPrivateFlags |= PFLAG_SKIP_DRAW;
    }
    requestLayout();
    invalidate();
}","{
    if (mForegroundInfo == null) {
        if (foreground == null) {
            // Nothing to do.
            return;
        }
        mForegroundInfo = new ForegroundInfo();
    }
    if (foreground == mForegroundInfo.mDrawable) {
        // Nothing to do
        return;
    }
    if (mForegroundInfo.mDrawable != null) {
        if (isAttachedToWindow()) {
            mForegroundInfo.mDrawable.setVisible(false, false);
        }
        mForegroundInfo.mDrawable.setCallback(null);
        unscheduleDrawable(mForegroundInfo.mDrawable);
    }
    mForegroundInfo.mDrawable = foreground;
    mForegroundInfo.mBoundsChanged = true;
    if (foreground != null) {
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        foreground.setLayoutDirection(getLayoutDirection());
        if (foreground.isStateful()) {
            foreground.setState(getDrawableState());
        }
        applyForegroundTint();
        if (isAttachedToWindow()) {
            foreground.setVisible(getWindowVisibility() == VISIBLE && isShown(), false);
        }
        // Set callback last, since the view may still be initializing.
        foreground.setCallback(this);
    } else if ((mViewFlags & WILL_NOT_DRAW) != 0 && mBackground == null) {
        mPrivateFlags |= PFLAG_SKIP_DRAW;
    }
    requestLayout();
    invalidate();
}",1,"/**
 * Supply a Drawable that is to be rendered on top of all of the content in the view.
 *
 * @param foreground the Drawable to be drawn on top of the children
 *
 * @attr ref android.R.styleable#View_foreground
 */
","/**
 * Supply a Drawable that is to be rendered on top of all of the content in the view.
 *
 * @param foreground the Drawable to be drawn on top of the children
 *
 * @attr ref android.R.styleable#View_foreground
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a modification within a conditional block, specifically the addition of isVisible checks and setVisible method calls. These are not control dependency changes but changes to other internal statements of the method, so the code change type is 4.","Even though the internal statements have changed, there's no indication that these changes would directly affect the behaviour in a way that would lead to a compatibility issue. The additions seem to ensure that the foreground drawable visibility is properly set when the view is attached to the window, which is more of an internal state management and should not alter the API's contract or outward behavior. Hence, there's no CI."
1119,<android.print.PrintJobId: boolean equals(Object)>,23,24,<android.print.PrintJobId: boolean equals(Object)>,<android.print.PrintJobId: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrintJobId other = (PrintJobId) obj;
    if (!TextUtils.equals(mValue, other.mValue)) {
        return false;
    }
    return true;
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrintJobId other = (PrintJobId) obj;
    if (!mValue.equals(other.mValue)) {
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method of equality comparison changed from TextUtils.equals to String.equals, therefore the code change type is 4.","The replacement of TextUtils.equals with String.equals does not lead to a Compatibility Issue because TextUtils.equals is specifically designed to handle null safely, just like String.equals. Both methods will return the same boolean result for the same input values, hence there is no change in the behavior of the method."
1120,<android.os.UserManager: long getUserCreationTime(UserHandle)>,23,24,<android.os.UserManager: long getUserCreationTime(UserHandle)>,<android.os.UserManager: long getUserCreationTime(UserHandle)>,0,"{
    try {
        return mService.getUserCreationTime(userHandle.getIdentifier());
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not get user creation time"", re);
        return 0;
    }
}","{
    try {
        return mService.getUserCreationTime(userHandle.getIdentifier());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns creation time of the user or of a managed profile associated with the calling user.
 * @param userHandle user handle of the user or a managed profile associated with the
 * calling user.
 * @return creation time in milliseconds since Epoch time.
 */
","/**
 * Returns creation time of the user or of a managed profile associated with the calling user.
 * @param userHandle user handle of the user or a managed profile associated with the
 * calling user.
 * @return creation time in milliseconds since Epoch time.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from logging the error and returning 0 to rethrowing the exception, so the code change type is 2.","With this change, clients that previously handled the situation of getting a return value of 0 may now need to handle a thrown exception instead, so the CI type is 2, which involves potential different exception handling."
1124,"<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(int,String)>",23,24,"<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(int,String)>","<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(int,String)>",0,"{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_STRING) {
            return loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_STRING) {
            return impl.loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/*package*/
","/**
 * Loads an XML parser for the specified file.
 *
 * @param id the resource identifier for the file
 * @param type the type of resource (used for logging)
 * @return a parser for the specified XML file
 * @throws NotFoundException if the file could not be loaded
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The controlled variable 'value' has changed from being retrieved from a local field with potential initialization to being retrieved from a method call (obtainTempTypedValue()); the synchronization on 'mAccessLock' has been removed; and there is the addition of try-finally block to ensure releaseTempTypedValue is called. These changes involve control dependency (removal of synchronization), other statement changes (removal and addition of method calls), and dependent API changes (using methods obtainTempTypedValue() and releaseTempTypedValue()) which are different from early implementation. Hence, the change type is 3,4,5.","There is no Compatibility Issue because the core functionality of the method, including the conditions and the NotFoundException being thrown, has not changed. Thus, there is no change that would lead to a different return value or a different exception being thrown under the same input, making the CI type 0. The changes made are internal and do not affect the method's contract."
1125,"<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>",23,24,"<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>","<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,3",0,"There's an additional local variable introduced (final int attrIndex = index), and the throw statements include more detailed information using the new local variable to specify the index. There's also a change to the way `getValueAt` is called, but this change in the error message and the variable used for calling a method doesn't affect the returned value or thrown exception type. The change in the method 'getValueAt' parameter is from 'index * AssetManager.STYLE_NUM_ENTRIES' to 'index', which seems like an oversight, assuming 'index' was meant to be multiplied by 'AssetManager.STYLE_NUM_ENTRIES' to get the correct offset. The code change falls into categories 4 and 3 since there is an other statement change and a control dependency change due to an extra variable declaration.","Since these changes do not affect the execution flow in a way that would alter the returned value or exception type of the method under normal conditions, no compatibility issue arises from these changes. So, the CI situation is 0. However, the change in the `getValueAt` call may indicate a potential bug if the code doesn't behave as intended because of an incorrect index calculation, but this isn't related to API compatibility as defined here."
1126,"<android.hardware.usb.UsbManager: void requestPermission(UsbAccessory,PendingIntent)>",23,24,"<android.hardware.usb.UsbManager: void requestPermission(UsbAccessory,PendingIntent)>","<android.hardware.usb.UsbManager: void requestPermission(UsbAccessory,PendingIntent)>",0,"{
    try {
        mService.requestAccessoryPermission(accessory, mContext.getPackageName(), pi);
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in requestPermission"", e);
    }
}","{
    try {
        mService.requestAccessoryPermission(accessory, mContext.getPackageName(), pi);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Requests temporary permission for the given package to access the accessory.
 * This may result in a system dialog being displayed to the user
 * if permission had not already been granted.
 * Success or failure is returned via the {@link android.app.PendingIntent} pi.
 * If successful, this grants the caller permission to access the accessory only
 * until the device is disconnected.
 *
 * The following extras will be added to pi:
 * <ul>
 * <li> {@link #EXTRA_ACCESSORY} containing the accessory passed into this call
 * <li> {@link #EXTRA_PERMISSION_GRANTED} containing boolean indicating whether
 * permission was granted by the user
 * </ul>
 *
 * @param accessory to request permissions for
 * @param pi PendingIntent for returning result
 */
","/**
 * Requests temporary permission for the given package to access the accessory.
 * This may result in a system dialog being displayed to the user
 * if permission had not already been granted.
 * Success or failure is returned via the {@link android.app.PendingIntent} pi.
 * If successful, this grants the caller permission to access the accessory only
 * until the device is disconnected.
 *
 * The following extras will be added to pi:
 * <ul>
 * <li> {@link #EXTRA_ACCESSORY} containing the accessory passed into this call
 * <li> {@link #EXTRA_PERMISSION_GRANTED} containing boolean indicating whether
 * permission was granted by the user
 * </ul>
 *
 * @param accessory to request permissions for
 * @param pi PendingIntent for returning result
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"There is a change in the exception handling statement where the catch block has been changed from logging the exception to rethrowing it, so the change type is 2.","This change in the exception handling behavior represents a Compatibility Issue because the late version of the method now throws the encountered RemoteException to the caller, which represents a change in the exception handling and thus could lead to different behavior for code that calls this API. The API used to handle the exception internally (logging it), but now it potentially propagates that exception to the caller, which is a significant behavior change. Therefore, the CI type is 2."
1127,<android.provider.Settings: boolean canDrawOverlays(Context)>,23,24,<android.provider.Settings: boolean canDrawOverlays(Context)>,<android.provider.Settings: boolean canDrawOverlays(Context)>,0,"{
    int uid = Binder.getCallingUid();
    return Settings.isCallingPackageAllowedToDrawOverlays(context, uid, Settings.getPackageNameForUid(context, uid), false);
}","{
    return Settings.isCallingPackageAllowedToDrawOverlays(context, Process.myUid(), context.getOpPackageName(), false);
}",1,"/**
 * An app can use this method to check if it is currently allowed to draw on top of other
 * apps. In order to be allowed to do so, an app must first declare the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its manifest. If it
 * is currently disallowed, it can prompt the user to grant it this capability through a
 * management UI by sending an Intent with action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}.
 *
 * @param context A context
 * @return true if the calling app can draw on top of other apps, false otherwise.
 */
","/**
 * Checks if the specified context can draw on top of other apps. As of API
 * level 23, an app cannot draw on top of other apps unless it declares the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its
 * manifest, <em>and</em> the user specifically grants the app this
 * capability. To prompt the user to grant this approval, the app must send an
 * intent with the action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}, which
 * causes the system to display a permission management screen.
 *
 * @param context App context.
 * @return true if the specified context can draw on top of other apps, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API calls changed from `Binder.getCallingUid()`, `Settings.getPackageNameForUid(context, uid)` to `Process.myUid()`, `context.getOpPackageName()`, hence the code change type is 5.","Though the dependent APIs used to retrieve the UID and package name information have changed, as long as the APIs return the same values for UID and package name for a given context, which is the expected behavior, there should be no compatibility issue. Therefore, the CI type is 0."
1128,"<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String,MatchFilter,TransformFilter)>",23,24,"<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String,MatchFilter,TransformFilter)>","<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String,MatchFilter,TransformFilter)>",0,"{
    boolean hasMatches = false;
    String prefix = (scheme == null) ? """" : scheme.toLowerCase(Locale.ROOT);
    Matcher m = p.matcher(s);
    while (m.find()) {
        int start = m.start();
        int end = m.end();
        boolean allowed = true;
        if (matchFilter != null) {
            allowed = matchFilter.acceptMatch(s, start, end);
        }
        if (allowed) {
            String url = makeUrl(m.group(0), new String[] { prefix }, m, transformFilter);
            applyLink(url, start, end, s);
            hasMatches = true;
        }
    }
    return hasMatches;
}","{
    return addLinks(spannable, pattern, scheme, null, matchFilter, transformFilter);
}",1,"/**
 * Applies a regex to a Spannable turning the matches into
 * links.
 *
 * @param s            Spannable whose text is to be marked-up with
 * links
 * @param p            Regex pattern to be used for finding links
 * @param scheme       Url scheme string (eg <code>http://</code> to be
 * prepended to the url of links that do not have
 * a scheme specified in the link text
 * @param matchFilter  The filter that is used to allow the client code
 * additional control over which pattern matches are
 * to be converted into links.
 */
","/**
 * Applies a regex to a Spannable turning the matches into
 * links.
 *
 * @param spannable    Spannable whose text is to be marked-up with links
 * @param pattern      Regex pattern to be used for finding links
 * @param scheme       URL scheme string (eg <code>http://</code>) to be
 * prepended to the links that do not start with this scheme.
 * @param matchFilter  The filter that is used to allow the client code
 * additional control over which pattern matches are
 * to be converted into links.
 * @param transformFilter Filter to allow the client code to update the link found.
 *
 * @return True if at least one link is found and applied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version contains the actual implementation code for the method, while the late version calls another overloaded method with additional `null` parameter. This is a dependent API change because the implementation of the logic is now dependent on that newly referenced method. The return statement has also changed because now it is returning the result of a different method call.","Since the late version of the method relies on a different implementation (an overloaded method with different parameters), there could be different behavior introduced, which potentially leads to different return values. Thus, the CI type is 1."
1129,<android.animation.ValueAnimator: void end()>,23,24,<android.animation.ValueAnimator: void end()>,<android.animation.ValueAnimator: void end()>,0,"{
    AnimationHandler handler = getOrCreateAnimationHandler();
    if (!handler.mAnimations.contains(this) && !handler.mPendingAnimations.contains(this)) {
        // Special case if the animation has not yet started; get it ready for ending
        mStartedDelay = false;
        startAnimation(handler);
        mStarted = true;
    } else if (!mInitialized) {
        initAnimation();
    }
    animateValue(mPlayingBackwards ? 0f : 1f);
    endAnimation(handler);
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be run on Looper threads"");
    }
    if (!mRunning) {
        // Special case if the animation has not yet started; get it ready for ending
        startAnimation();
        mStarted = true;
    } else if (!mInitialized) {
        initAnimation();
    }
    animateValue(shouldPlayBackward(mRepeatCount) ? 0f : 1f);
    endAnimation();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",The changes include:,- Changing the check on the value of `mRunning` rather than checks involving handlers and their respective lists.
1130,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,23,24,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    final boolean result = super.onTouchEvent(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDownPositionX = ev.getRawX();
            mDownPositionY = ev.getRawY();
            break;
        case MotionEvent.ACTION_UP:
            if (!offsetHasBeenChanged()) {
                final float deltaX = mDownPositionX - ev.getRawX();
                final float deltaY = mDownPositionY - ev.getRawY();
                final float distanceSquared = deltaX * deltaX + deltaY * deltaY;
                final ViewConfiguration viewConfiguration = ViewConfiguration.get(mTextView.getContext());
                final int touchSlop = viewConfiguration.getScaledTouchSlop();
                if (distanceSquared < touchSlop * touchSlop) {
                    // Tapping on the handle toggles the insertion action mode.
                    if (mTextActionMode != null) {
                        mTextActionMode.finish();
                    } else {
                        startInsertionActionMode();
                    }
                }
            } else {
                if (mTextActionMode != null) {
                    mTextActionMode.invalidateContentRect();
                }
            }
            hideAfterDelay();
            break;
        case MotionEvent.ACTION_CANCEL:
            hideAfterDelay();
            break;
        default:
            break;
    }
    return result;
}","{
    final boolean result = super.onTouchEvent(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDownPositionX = ev.getRawX();
            mDownPositionY = ev.getRawY();
            break;
        case MotionEvent.ACTION_UP:
            if (!offsetHasBeenChanged()) {
                final float deltaX = mDownPositionX - ev.getRawX();
                final float deltaY = mDownPositionY - ev.getRawY();
                final float distanceSquared = deltaX * deltaX + deltaY * deltaY;
                final ViewConfiguration viewConfiguration = ViewConfiguration.get(mTextView.getContext());
                final int touchSlop = viewConfiguration.getScaledTouchSlop();
                if (distanceSquared < touchSlop * touchSlop) {
                    // Tapping on the handle toggles the insertion action mode.
                    if (mTextActionMode != null) {
                        stopTextActionMode();
                    } else {
                        startInsertionActionMode();
                    }
                }
            } else {
                if (mTextActionMode != null) {
                    mTextActionMode.invalidateContentRect();
                }
            }
            hideAfterDelay();
            break;
        case MotionEvent.ACTION_CANCEL:
            hideAfterDelay();
            break;
        default:
            break;
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in implementation is the change of method name from 'mTextActionMode.finish()' to 'stopTextActionMode()'. This is classified as a change type of 4 because only an internal method call within the method has been renamed, and it does not immediately suggest a change in return type/value or exception thrown.","Considering that the renaming of the method does not inherently affect the return value nor change the exceptions being thrown, and assuming that 'stopTextActionMode()' behaves the same as the previous 'mTextActionMode.finish()', there should be no Compatibility Issue resulting from this change. Therefore, the CI type is 0."
1131,<android.service.notification.NotificationListenerService: IBinder onBind(Intent)>,23,24,<android.service.notification.NotificationListenerService: IBinder onBind(Intent)>,<android.service.notification.NotificationListenerService: IBinder onBind(Intent)>,0,"{
    if (mWrapper == null) {
        mWrapper = new INotificationListenerWrapper();
    }
    return mWrapper;
}","{
    if (mWrapper == null) {
        mWrapper = new NotificationListenerWrapper();
    }
    return mWrapper;
}",1,,"/**
 * This is not the lifecycle event you are looking for.
 *
 * <p>The service should wait for the {@link #onListenerConnected()} event
 * before performing any operations.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The object type that mWrapper is instantiated as has changed from INotificationListenerWrapper to NotificationListenerWrapper. However, if both classes correctly implement the necessary interface for the IBinder return type, this change won't affect the return type. The code change is of type 4,5.","Assuming that both INotificationListenerWrapper and NotificationListenerWrapper provide the same interface to satisfy the return type IBinder and that there is no change in their behavior impacting the API contract, this should not lead to a Compatibility Issue. There is a dependent API change, but it does not necessarily lead to a difference in behavior. Thus, there is no Compatibility Issue, and the CI type is 0."
1132,"<android.hardware.usb.UsbManager: void requestPermission(UsbDevice,PendingIntent)>",23,24,"<android.hardware.usb.UsbManager: void requestPermission(UsbDevice,PendingIntent)>","<android.hardware.usb.UsbManager: void requestPermission(UsbDevice,PendingIntent)>",0,"{
    try {
        mService.requestDevicePermission(device, mContext.getPackageName(), pi);
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in requestPermission"", e);
    }
}","{
    try {
        mService.requestDevicePermission(device, mContext.getPackageName(), pi);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Requests temporary permission for the given package to access the device.
 * This may result in a system dialog being displayed to the user
 * if permission had not already been granted.
 * Success or failure is returned via the {@link android.app.PendingIntent} pi.
 * If successful, this grants the caller permission to access the device only
 * until the device is disconnected.
 *
 * The following extras will be added to pi:
 * <ul>
 * <li> {@link #EXTRA_DEVICE} containing the device passed into this call
 * <li> {@link #EXTRA_PERMISSION_GRANTED} containing boolean indicating whether
 * permission was granted by the user
 * </ul>
 *
 * @param device to request permissions for
 * @param pi PendingIntent for returning result
 */
","/**
 * Requests temporary permission for the given package to access the device.
 * This may result in a system dialog being displayed to the user
 * if permission had not already been granted.
 * Success or failure is returned via the {@link android.app.PendingIntent} pi.
 * If successful, this grants the caller permission to access the device only
 * until the device is disconnected.
 *
 * The following extras will be added to pi:
 * <ul>
 * <li> {@link #EXTRA_DEVICE} containing the device passed into this call
 * <li> {@link #EXTRA_PERMISSION_GRANTED} containing boolean indicating whether
 * permission was granted by the user
 * </ul>
 *
 * @param device to request permissions for
 * @param pi PendingIntent for returning result
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, with the old logging replaced by a throw statement, so the change type is 2.","The change from logging an exception to rethrowing it could lead to a different exception being propagated in the late version, which signifies a change in behavior. Thus, there's a Compatibility Issue of type 2, due to the potential different exception handlings."
1133,"<android.content.ClipData: ClipData newUri(ContentResolver,CharSequence,Uri)>",23,24,"<android.content.ClipData: ClipData newUri(ContentResolver,CharSequence,Uri)>","<android.content.ClipData: ClipData newUri(ContentResolver,CharSequence,Uri)>",0,"{
    Item item = new Item(uri);
    String[] mimeTypes = null;
    if (""content"".equals(uri.getScheme())) {
        String realType = resolver.getType(uri);
        mimeTypes = resolver.getStreamTypes(uri, ""*/*"");
        if (mimeTypes == null) {
            if (realType != null) {
                mimeTypes = new String[] { realType, ClipDescription.MIMETYPE_TEXT_URILIST };
            }
        } else {
            String[] tmp = new String[mimeTypes.length + (realType != null ? 2 : 1)];
            int i = 0;
            if (realType != null) {
                tmp[0] = realType;
                i++;
            }
            System.arraycopy(mimeTypes, 0, tmp, i, mimeTypes.length);
            tmp[i + mimeTypes.length] = ClipDescription.MIMETYPE_TEXT_URILIST;
            mimeTypes = tmp;
        }
    }
    if (mimeTypes == null) {
        mimeTypes = MIMETYPES_TEXT_URILIST;
    }
    return new ClipData(label, mimeTypes, item);
}","{
    Item item = new Item(uri);
    String[] mimeTypes = null;
    if (""content"".equals(uri.getScheme())) {
        String realType = resolver.getType(uri);
        mimeTypes = resolver.getStreamTypes(uri, ""*/*"");
        if (realType != null) {
            if (mimeTypes == null) {
                mimeTypes = new String[] { realType };
            } else {
                String[] tmp = new String[mimeTypes.length + 1];
                tmp[0] = realType;
                System.arraycopy(mimeTypes, 0, tmp, 1, mimeTypes.length);
                mimeTypes = tmp;
            }
        }
    }
    if (mimeTypes == null) {
        mimeTypes = MIMETYPES_TEXT_URILIST;
    }
    return new ClipData(label, mimeTypes, item);
}",1,"/**
 * Create a new ClipData holding a URI.  If the URI is a content: URI,
 * this will query the content provider for the MIME type of its data and
 * use that as the MIME type.  Otherwise, it will use the MIME type
 * {@link ClipDescription#MIMETYPE_TEXT_URILIST}.
 *
 * @param resolver ContentResolver used to get information about the URI.
 * @param label User-visible label for the clip data.
 * @param uri The URI in the clip.
 * @return Returns a new ClipData containing the specified data.
 */
","/**
 * Create a new ClipData holding a URI.  If the URI is a content: URI,
 * this will query the content provider for the MIME type of its data and
 * use that as the MIME type.  Otherwise, it will use the MIME type
 * {@link ClipDescription#MIMETYPE_TEXT_URILIST}.
 *
 * @param resolver ContentResolver used to get information about the URI.
 * @param label User-visible label for the clip data.
 * @param uri The URI in the clip.
 * @return Returns a new ClipData containing the specified data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The if conditions and the block related to 'realType != null' and the code block handling 'mimeTypes == null' have been simplified. The 'new String[] { realType, ClipDescription.MIMETYPE_TEXT_URILIST }' from early version is changed to 'new String[] { realType }' in the late version, and the late version code does not add ClipDescription.MIMETYPE_TEXT_URILIST to 'mimeTypes' when 'mimeTypes == null' and 'realType != null'. Besides, the 'else' block that adds ClipDescription.MIMETYPE_TEXT_URILIST is removed. These changes in control dependency and the actual return statement lead to the change categories 1,3.","Since the array 'mimeTypes' is part of the ClipData object being returned and these changes can affect its contents, they can lead to a different return value. Specifically, the presence or absence of ClipDescription.MIMETYPE_TEXT_URILIST in the returned 'mimeTypes' array could differ between the two versions. This constitutes a change in potential return values, thus the CI type is 1."
1134,"<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean,int)>",23,24,"<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean,int)>","<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean,int)>",0,"{
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + (rd != null ? rd.mReceiver : null));
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, ""Finishing broadcast to unregistered receiver"");
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            if (extras != null) {
                extras.setAllowFds(false);
            }
            mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags());
        } catch (RemoteException e) {
            Slog.w(ActivityThread.TAG, ""Couldn't finish broadcast to unregistered receiver"");
        }
    }
}","{
    final LoadedApk.ReceiverDispatcher rd;
    if (intent == null) {
        Log.wtf(TAG, ""Null intent received"");
        rd = null;
    } else {
        rd = mDispatcher.get();
    }
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + (rd != null ? rd.mReceiver : null));
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, ""Finishing broadcast to unregistered receiver"");
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            if (extras != null) {
                extras.setAllowFds(false);
            }
            mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"2,3","1,2","The late implementation has added a null check for `intent` variable with a logging statement, a control dependency change, and replaced a logging statement in an exception handling block with a throw statement, which indicates an exception handling statement change. Therefore, the change types are 2,3.","The added null check for `intent` can alter the behavior if `intent` is null, as the early version did not handle this case, potentially causing a method to fail that previously did not, or to behave differently (Compatibility Issue type 1). Moreover, the change in exception handling from logging the RemoteException to rethrowing it is also a behavior change that could lead to a different exception being thrown when handling the same error condition (Compatibility Issue type 2)."
1135,<android.widget.TextView: boolean canProcessText()>,23,24,<android.widget.TextView: boolean canProcessText()>,<android.widget.TextView: boolean canProcessText()>,0,"{
    if (!getContext().canStartActivityForResult() || getId() == View.NO_ID || hasPasswordTransformationMethod()) {
        return false;
    }
    if (mText.length() > 0 && hasSelection() && mEditor != null) {
        return true;
    }
    return false;
}","{
    if (getId() == View.NO_ID) {
        return false;
    }
    return canShare();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There has been a significant control dependency and other statements change in the code between the two versions. The checks for if the context can start an activity for result, if the text has a password transformation method, if the text length is more than 0, if it has a selection, and if mEditor is not null have been removed. Only the check for if the ID is NO_ID remains, and a new method call to canShare() is now used to determine the return value. The code change types are 3,4.","Due to the removal of several checks and the introduction of a new method call for the return statement, the behavior of the API has potentially changed. Now the return value is dependent solely on the ID check and the result of canShare(), which could be different from the previous checks in the early version. Therefore, there is a potential for a different return value, so the CI type is 1."
1136,"<android.view.textservice.SpellCheckerSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>",23,24,"<android.view.textservice.SpellCheckerSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>","<android.view.textservice.SpellCheckerSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>",0,"{
    final Locale locale = constructLocaleFromString(mSubtypeLocale);
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        return String.format(subtypeName.toString(), localeStr);
    } else {
        return localeStr;
    }
}","{
    final Locale locale = getLocaleObject();
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        return String.format(subtypeName.toString(), localeStr);
    } else {
        return localeStr;
    }
}",1,"/**
 * @param context Context will be used for getting Locale and PackageManager.
 * @param packageName The package name of the spell checker
 * @param appInfo The application info of the spell checker
 * @return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 * can have only one %s in it. If there is, the %s part will be replaced with the locale's
 * display name by the formatter. If there is not, this method simply returns the string
 * specified by mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the
 * framework to generate an appropriate display name.
 */
","/**
 * @param context Context will be used for getting Locale and PackageManager.
 * @param packageName The package name of the spell checker
 * @param appInfo The application info of the spell checker
 * @return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 * can have only one %s in it. If there is, the %s part will be replaced with the locale's
 * display name by the formatter. If there is not, this method simply returns the string
 * specified by mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the
 * framework to generate an appropriate display name.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation method for obtaining a Locale object has changed (from `constructLocaleFromString(mSubtypeLocale)` to `getLocaleObject()`). The statement itself that obtains the locale is changed; however, this does not guarantee a behavior change, as the locale used for display name is the same. There is no change in control structures, exceptions, or return statements that will affect the output. Therefore, classified under other statement changed (4) and dependent API changed (5).","The change in how the Locale object is obtained does not lead to a Compatibility Issue. Considering that the `getLocaleObject()` is expected to return the same Locale object that `constructLocaleFromString(mSubtypeLocale)` would have returned, it's assumed that the behavior remains consistent. As there are no changes to the return statements or exception handling that would affect the outcome of the method, this change does not cause a Compatibility Issue."
1137,"<android.app.NotificationManager: void notify(String,int,Notification)>",23,24,"<android.app.NotificationManager: void notify(String,int,Notification)>","<android.app.NotificationManager: void notify(String,int,Notification)>",0,"{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed(""Notification.sound"");
        }
    }
    fixLegacySmallIcon(notification, pkg);
    if (mContext.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
        if (notification.getSmallIcon() == null) {
            throw new IllegalArgumentException(""Invalid notification (no valid small icon): "" + notification);
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    Notification stripped = notification.clone();
    Builder.stripForDelivery(stripped);
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, stripped, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}","{
    notifyAsUser(tag, id, notification, new UserHandle(UserHandle.myUserId()));
}",1,"/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
","/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The entire early implementation is replaced with a single method call to notifyAsUser in the late version. There is the deletion of return statements, control flow statements such as if conditions, the addition of a new method call, and changes in how exceptions are handled. Also, the notifyAsUser method invoked could be considered a dependent API that has been changed. So, the change type is 1,4,5.","Due to the change in the early implementation replacing with a method call to notifyAsUser and the removal of the detailed implementation including exception handling, there are potential CI types 1 and 2. The previous implementation has various checks and a different exception handling mechanism that are no longer present in the late version, which could lead to different return behavior if exceptions are thrown and are caught within the new notifyAsUser method, resulting in different behavior or outcomes."
1139,"<android.content.res.Resources: ColorStateList getColorStateList(int,Theme)>",23,24,"<android.content.res.Resources: ColorStateList getColorStateList(int,Theme)>","<android.content.res.Resources: ColorStateList getColorStateList(int,Theme)>",0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValue(id, value, true);
    }
    final ColorStateList res = loadColorStateList(value, id, theme);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        return impl.loadColorStateList(this, value, id, theme);
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Returns a themed color state list associated with a particular resource
 * ID. The resource may contain either a single raw color value or a
 * complex {@link ColorStateList} holding multiple possible colors.
 *
 * @param id The desired resource identifier of a {@link ColorStateList},
 * as generated by the aapt tool. This integer encodes the
 * package, type, and resource entry. The value 0 is an invalid
 * identifier.
 * @param theme The theme used to style the color attributes, may be
 * {@code null}.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 *
 * @return A themed ColorStateList object containing either a single solid
 * color or multiple colors that can be selected based on a state.
 */
","/**
 * Returns a themed color state list associated with a particular resource
 * ID. The resource may contain either a single raw color value or a
 * complex {@link ColorStateList} holding multiple possible colors.
 *
 * @param id The desired resource identifier of a {@link ColorStateList},
 * as generated by the aapt tool. This integer encodes the
 * package, type, and resource entry. The value 0 is an invalid
 * identifier.
 * @param theme The theme used to style the color attributes, may be
 * {@code null}.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 *
 * @return A themed ColorStateList object containing either a single solid
 * color or multiple colors that can be selected based on a state.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The late version replaces the manual synchronization and reuse of `TypedValue` with try-finally blocks to obtain and release resources using `obtainTempTypedValue` and `releaseTempTypedValue`. The actual acquiring of the color state list is modified to directly use an instance of `ResourcesImpl`, but the fundamental behavior of obtaining a color state list for a given id and theme is preserved. This would be classified as an 'Other statement changed' and 'Dependent API changed'.","There is no Compatibility Issue introduced as the fundamental behavior of retrieving the color state list by providing an id and a theme remains the same. The changes are mainly about resource management and refactoring the code to use a different API (`ResourcesImpl`) internally, but the changes do not affect what the method returns or the exceptions it might throw under the same conditions. Thus, the sequence of operations from an external viewpoint remains equivalent."
1141,<android.app.ContextImpl: void sendBroadcast(Intent)>,23,24,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method call `intent.prepareToLeaveProcess();` has been changed to `intent.prepareToLeaveProcess(this);` by adding a parameter `this`. Additionally, the exception handling has changed from throwing a new `RuntimeException` to calling `e.rethrowFromSystemServer()`. However, these specific alterations do not have an impact on the return type or values (since the method is `void` and has no return value), nor do they necessarily suggest differing exceptions being thrown that the caller has to handle. The CI is determined by the effect of code; in this case, since the behavior from the caller's perspective remains effectively the same (an exception in the remote call will still result in an exception, just wrapped differently), there is no compatibility issue.","There is no Compatibility Issue because the nature of how the exception is being thrown does not affect the caller's control flow in a way that they need to handle differently - an exception was thrown before, and an exception is thrown now, it's the internal exception handling that has mildly changed. Moreover, since the method returns `void`, the changes in the implementation do not affect the return value or type."
1142,"<android.transition.Slide: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>",23,24,"<android.transition.Slide: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>","<android.transition.Slide: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>",0,"{
    if (endValues == null) {
        return null;
    }
    int[] position = (int[]) endValues.values.get(PROPNAME_SCREEN_POSITION);
    float endX = view.getTranslationX();
    float endY = view.getTranslationY();
    float startX = mSlideCalculator.getGoneX(sceneRoot, view);
    float startY = mSlideCalculator.getGoneY(sceneRoot, view);
    return TranslationAnimationCreator.createAnimation(view, endValues, position[0], position[1], startX, startY, endX, endY, sDecelerate, this);
}","{
    if (endValues == null) {
        return null;
    }
    int[] position = (int[]) endValues.values.get(PROPNAME_SCREEN_POSITION);
    float endX = view.getTranslationX();
    float endY = view.getTranslationY();
    float startX = mSlideCalculator.getGoneX(sceneRoot, view, mSlideFraction);
    float startY = mSlideCalculator.getGoneY(sceneRoot, view, mSlideFraction);
    return TranslationAnimationCreator.createAnimation(view, endValues, position[0], position[1], startX, startY, endX, endY, sDecelerate, this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The parameters in the methods `mSlideCalculator.getGoneX` and `mSlideCalculator.getGoneY` have changed by adding `mSlideFraction`, which affects the functionality of the method calls, so the code change type is 4,5.","Since the methods `mSlideCalculator.getGoneX` and `mSlideCalculator.getGoneY` are used as arguments to the `createAnimation` method, and these methods now receive an additional parameter `mSlideFraction` which could alter their return values, there is a potential that the animation created will have different behavior. Therefore, the CI type is 1 due to the potential different return values."
1143,"<android.hardware.ConsumerIrManager: void transmit(int,int[])>",23,24,"<android.hardware.ConsumerIrManager: void transmit(int,int[])>","<android.hardware.ConsumerIrManager: void transmit(int,int[])>",0,"{
    if (mService == null) {
        Log.w(TAG, ""failed to transmit; no consumer ir service."");
        return;
    }
    try {
        mService.transmit(mPackageName, carrierFrequency, pattern);
    } catch (RemoteException e) {
        Log.w(TAG, ""failed to transmit."", e);
    }
}","{
    if (mService == null) {
        Log.w(TAG, ""failed to transmit; no consumer ir service."");
        return;
    }
    try {
        mService.transmit(mPackageName, carrierFrequency, pattern);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Transmit an infrared pattern
 * <p>
 * This method is synchronous; when it returns the pattern has
 * been transmitted. Only patterns shorter than 2 seconds will
 * be transmitted.
 * </p>
 *
 * @param carrierFrequency The IR carrier frequency in Hertz.
 * @param pattern The alternating on/off pattern in microseconds to transmit.
 */
","/**
 * Transmit an infrared pattern
 * <p>
 * This method is synchronous; when it returns the pattern has
 * been transmitted. Only patterns shorter than 2 seconds will
 * be transmitted.
 * </p>
 *
 * @param carrierFrequency The IR carrier frequency in Hertz.
 * @param pattern The alternating on/off pattern in microseconds to transmit.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling logic has changed. Instead of logging a warning in the catch block, the late implementation throws an exception using `throw e.rethrowFromSystemServer()`.","The change in exception handling statement from logging an exception to throwing an exception could result in a different behavior when exceptions occur. Users of the method will now need to handle a possible `RemoteException` in their code which wasn't required in the earlier version, leading to a potential compatibility issue due to different exception handlings. Therefore, the CI type is 2."
1145,<android.animation.AnimatorSet: String toString()>,23,24,<android.animation.AnimatorSet: String toString()>,<android.animation.AnimatorSet: String toString()>,0,"{
    String returnVal = ""AnimatorSet@"" + Integer.toHexString(hashCode()) + ""{"";
    boolean prevNeedsSort = mNeedsSort;
    sortNodes();
    mNeedsSort = prevNeedsSort;
    for (Node node : mSortedNodes) {
        returnVal += ""\n    "" + node.animation.toString();
    }
    return returnVal + ""\n}"";
}","{
    String returnVal = ""AnimatorSet@"" + Integer.toHexString(hashCode()) + ""{"";
    int size = mNodes.size();
    for (int i = 0; i < size; i++) {
        Node node = mNodes.get(i);
        returnVal += ""\n    "" + node.mAnimation.toString();
    }
    return returnVal + ""\n}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There are multiple code changes. The early implementation uses `sortNodes();` and iterates through `mSortedNodes`, while the late implementation removes the sorting and iterates through `mNodes` directly. Furthermore, there's a change from `node.animation` to `node.mAnimation`. The code change type is 3,4 for the altered iteration logic and other statement change.","The change from sorted to unsorted iteration and the access to a potentially different field or property will likely change the output value of `toString()`. Therefore, the CI type is 1."
1146,<android.app.FragmentHostCallback: void doLoaderStop(boolean)>,23,24,<android.app.FragmentHostCallback: void doLoaderStop(boolean)>,<android.app.FragmentHostCallback: void doLoaderStop(boolean)>,0,"{
    if (mLoaderManager == null) {
        return;
    }
    if (!mLoadersStarted) {
        return;
    }
    mLoadersStarted = false;
    if (retain) {
        mLoaderManager.doRetain();
    } else {
        mLoaderManager.doStop();
    }
}","{
    mRetainLoaders = retain;
    if (mLoaderManager == null) {
        return;
    }
    if (!mLoadersStarted) {
        return;
    }
    mLoadersStarted = false;
    if (retain) {
        mLoaderManager.doRetain();
    } else {
        mLoaderManager.doStop();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's an addition of a new statement (mRetainLoaders = retain;) that does not affect the control flow or result of the method, so the code change type is 4.","The modification does not impact the control flow or return value of the method, as it only assigns a value to a member variable without affecting the behavior of the existing method's logic. There's no Compatibility Issue, so the CI type is 0."
1147,"<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>",23,24,"<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    if (!mIsWidgetCollectionChild) {
        Log.e(LOG_TAG, ""The method setOnClickFillInIntent is available "" + ""only from RemoteViewsFactory (ie. on collection items)."");
        return;
    }
    if (target == root) {
        target.setTagInternal(com.android.internal.R.id.fillInIntent, fillInIntent);
    } else if (fillInIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                // Insure that this view is a child of an AdapterView
                View parent = (View) v.getParent();
                while (parent != null && !(parent instanceof AdapterView<?>) && !(parent instanceof AppWidgetHostView)) {
                    parent = (View) parent.getParent();
                }
                if (parent instanceof AppWidgetHostView || parent == null) {
                    // Somehow they've managed to get this far without having
                    // and AdapterView as a parent.
                    Log.e(LOG_TAG, ""Collection item doesn't have AdapterView parent"");
                    return;
                }
                // Insure that a template pending intent has been set on an ancestor
                if (!(parent.getTag() instanceof PendingIntent)) {
                    Log.e(LOG_TAG, ""Attempting setOnClickFillInIntent without"" + "" calling setPendingIntentTemplate on parent."");
                    return;
                }
                PendingIntent pendingIntent = (PendingIntent) parent.getTag();
                final Rect rect = getSourceBounds(v);
                fillInIntent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, fillInIntent);
            }
        };
        target.setOnClickListener(listener);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    if (!mIsWidgetCollectionChild) {
        Log.e(LOG_TAG, ""The method setOnClickFillInIntent is available "" + ""only from RemoteViewsFactory (ie. on collection items)."");
        return;
    }
    if (target == root) {
        target.setTagInternal(com.android.internal.R.id.fillInIntent, fillInIntent);
    } else if (fillInIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                // Insure that this view is a child of an AdapterView
                View parent = (View) v.getParent();
                // correctly parented in an AdapterView.
                while (parent != null && !(parent instanceof AdapterView<?>) && !((parent instanceof AppWidgetHostView) && !(parent instanceof RemoteViewsAdapter.RemoteViewsFrameLayout))) {
                    parent = (View) parent.getParent();
                }
                if (!(parent instanceof AdapterView<?>)) {
                    // Somehow they've managed to get this far without having
                    // and AdapterView as a parent.
                    Log.e(LOG_TAG, ""Collection item doesn't have AdapterView parent"");
                    return;
                }
                // Insure that a template pending intent has been set on an ancestor
                if (!(parent.getTag() instanceof PendingIntent)) {
                    Log.e(LOG_TAG, ""Attempting setOnClickFillInIntent without"" + "" calling setPendingIntentTemplate on parent."");
                    return;
                }
                PendingIntent pendingIntent = (PendingIntent) parent.getTag();
                final Rect rect = getSourceBounds(v);
                fillInIntent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, fillInIntent);
            }
        };
        target.setOnClickListener(listener);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The change in the while loop's conditional statement includes an additional check to ensure parent is not an instance of `RemoteViewsAdapter.RemoteViewsFrameLayout`. This means the control flow can change, thereby altering the behavior of the `onClick` method within the `OnClickListener`. This change is classified as a control dependency change.","The conditional logic within the while loop now excludes `RemoteViewsAdapter.RemoteViewsFrameLayout` which can affect the determination of the parent view. As this could potentially alter the subsequent behavior of the `onClick` method, such as which `View` it considers as the parent or if it reaches the error log statement and returns early, this change can lead to a different interaction when the `onClick` event is triggered. Therefore, it is considered a compatibility issue that can result in different return values or types."
1149,"<android.app.ContextImpl: SharedPreferences getSharedPreferences(String,int)>",23,24,"<android.app.ContextImpl: SharedPreferences getSharedPreferences(String,int)>","<android.app.ContextImpl: SharedPreferences getSharedPreferences(String,int)>",0,"{
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) {
        if (sSharedPrefs == null) {
            sSharedPrefs = new ArrayMap<String, ArrayMap<String, SharedPreferencesImpl>>();
        }
        final String packageName = getPackageName();
        ArrayMap<String, SharedPreferencesImpl> packagePrefs = sSharedPrefs.get(packageName);
        if (packagePrefs == null) {
            packagePrefs = new ArrayMap<String, SharedPreferencesImpl>();
            sSharedPrefs.put(packageName, packagePrefs);
        }
        // we would stringify it to ""null.xml"".  Nice.
        if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
            if (name == null) {
                name = ""null"";
            }
        }
        sp = packagePrefs.get(name);
        if (sp == null) {
            File prefsFile = getSharedPrefsFile(name);
            sp = new SharedPreferencesImpl(prefsFile, mode);
            packagePrefs.put(name, sp);
            return sp;
        }
    }
    if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    }
    return sp;
}","{
    // we would stringify it to ""null.xml"".  Nice.
    if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
        if (name == null) {
            name = ""null"";
        }
    }
    File file;
    synchronized (ContextImpl.class) {
        if (mSharedPrefsPaths == null) {
            mSharedPrefsPaths = new ArrayMap<>();
        }
        file = mSharedPrefsPaths.get(name);
        if (file == null) {
            file = getSharedPreferencesPath(name);
            mSharedPrefsPaths.put(name, file);
        }
    }
    return getSharedPreferences(file, mode);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method implementation changed significantly, with the early version of the code utilizing a nested synchronized block and a local 'ArrayMap' to store 'SharedPreferencesImpl' objects, while the later version removed the synchronized block and instead used a different 'ArrayMap' to store files directly. This results in a change in return statements, control dependency due to the removed block structure, other statements, and the dependent API 'getSharedPreferences(file, mode)' being invoked instead of instantiating a new 'SharedPreferencesImpl'. Therefore the change types are 1,3,4,5.","There is a possibility for compatibility issues due to the fact that different mechanisms are used to obtain and return 'SharedPreferences' objects between the two versions, potentially resulting in different return values. This is because the means by which the 'SharedPreferences' are fetched has been altered. Thus, the CI type is 1."
1150,<android.print.PrinterId: boolean equals(Object)>,23,24,<android.print.PrinterId: boolean equals(Object)>,<android.print.PrinterId: boolean equals(Object)>,0,"{
    if (this == object) {
        return true;
    }
    if (object == null) {
        return false;
    }
    if (getClass() != object.getClass()) {
        return false;
    }
    PrinterId other = (PrinterId) object;
    if (mServiceName == null) {
        if (other.mServiceName != null) {
            return false;
        }
    } else if (!mServiceName.equals(other.mServiceName)) {
        return false;
    }
    if (!TextUtils.equals(mLocalId, other.mLocalId)) {
        return false;
    }
    return true;
}","{
    if (this == object) {
        return true;
    }
    if (object == null) {
        return false;
    }
    if (getClass() != object.getClass()) {
        return false;
    }
    PrinterId other = (PrinterId) object;
    if (!mServiceName.equals(other.mServiceName)) {
        return false;
    }
    if (!mLocalId.equals(other.mLocalId)) {
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The null check condition for mServiceName has been removed, so the code change type is 4.","There is no Compatibility Issue caused by this change. In the late version, if mServiceName is null, it will throw a NullPointerException, which is reasonable behavior for an equals method when comparing against an object with an unexpected null field. This is an intended and acceptable behavior change. Therefore, we consider that there's no potential Compatibility Issue."
1151,<android.widget.TimePicker: Integer getCurrentHour()>,23,24,<android.widget.TimePicker: Integer getCurrentHour()>,<android.widget.TimePicker: Integer getCurrentHour()>,0,"{
    return mDelegate.getCurrentHour();
}","{
    return mDelegate.getHour();
}",1,"/**
 * @return the current hour in the range (0-23)
 * @deprecated Use {@link #getHour()}
 */
","/**
 * @return the current hour in the range (0-23)
 * @deprecated Use {@link #getHour()}
 */
",-1,"[@NonNull, @Deprecated]","[@NonNull, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The method called on `mDelegate` has been changed from `getCurrentHour()` to `getHour()`. This indicates that there has been a change in the dependent API, so the code change type is 5.","Although the dependent API has been changed from `getCurrentHour()` to `getHour()`, unless more context is given about the modification of that specific method, we cannot assume that it will cause compatibility issues since it's possible that both methods are intended to return the same value as part of the API's contract. Thus without evidence of a difference in behavior, we consider there to be no compatibility issue and the CI type is 0."
1153,"<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>",23,24,"<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>","<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>",0,"{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetOptions(mPackageName, appWidgetId, options);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetOptions(mPackageName, appWidgetId, options);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Update the extras for a given widget instance.
 * <p>
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #getAppWidgetOptions(int)
 *
 * @param appWidgetId The AppWidget instances for which to set the RemoteViews.
 * @param options The options to associate with this widget
 */
","/**
 * Update the extras for a given widget instance.
 * <p>
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #getAppWidgetOptions(int)
 *
 * @param appWidgetId The AppWidget instances for which to set the RemoteViews.
 * @param options The options to associate with this widget
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from constructing a new RuntimeException to throwing a rethrown RemoteException, so the code change type is 2.","The late version of the API will throw the original RemoteException wrapped with RuntimeException that originates from the system server, while the early version could potentially throw any RuntimeException. Thus, this change could lead to a different type of exception being thrown by the API between the two versions, causing a CI of type 2."
1154,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNumeric(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNumeric(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNumeric(ComponentName)>,0,"{
    return getPasswordMinimumNumeric(admin, UserHandle.myUserId());
}","{
    return getPasswordMinimumNumeric(admin, myUserId());
}",1,"/**
 * Retrieve the current number of numerical digits required in the password
 * for all admins of this user and its profiles or a particular one.
 * This is the same value as set by
 * {#link {@link #setPasswordMinimumNumeric(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of numerical digits required in the password.
 */
","/**
 * Retrieve the current number of numerical digits required in the password
 * for a particular admin or all admins that set retrictions on this user
 * and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 * This is the same value as set by
 * {@link #setPasswordMinimumNumeric(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * @param admin The name of the admin component to check, or {@code null} to
 * aggregate all admins.
 * @return The minimum number of numerical digits required in the password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change is in the argument passed to the getPasswordMinimumNumeric method call, from using UserHandle.myUserId() to myUserId() directly. This is an internal change, and it can be classified as a change in a dependent API (if myUserId() behaves the same as UserHandle.myUserId()), so the change type is 4,5.","Considering the change is internal and assuming myUserId() returns the same value as UserHandle.myUserId(), this change should not cause any external behavior change or Compatibility Issue. Thus, the CI type is 0."
1155,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,23,24,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,0,"{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getOpPackageName());
            } catch (RemoteException e) {
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}","{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getOpPackageName());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from an empty catch block to a throw statement, so the change type is 2.","The change in the exception handling statement will cause a RemoteException to be thrown in the late version instead of being caught and ignored as in the early version, so this leads to a potential different exception handling and thus the CI type is 2."
1156,<android.app.admin.DevicePolicyManager: boolean isLockTaskPermitted(String)>,23,24,<android.app.admin.DevicePolicyManager: boolean isLockTaskPermitted(String)>,<android.app.admin.DevicePolicyManager: boolean isLockTaskPermitted(String)>,0,"{
    if (mService != null) {
        try {
            return mService.isLockTaskPermitted(pkg);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""isLockTaskPermitted"");
    if (mService != null) {
        try {
            return mService.isLockTaskPermitted(pkg);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * This function lets the caller know whether the given component is allowed to start the
 * lock task mode.
 * @param pkg The package to check
 */
","/**
 * This function lets the caller know whether the given component is allowed to start the
 * lock task mode.
 * @param pkg The package to check
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement has changed with the introduction of `throwIfParentInstance(""isLockTaskPermitted"")`, and the behavior of the catch block has been altered by replacing the log statement with `throw e.rethrowFromSystemServer()`. Additionally, `throwIfParentInstance` is not a control dependency, so its change is classified as 4.","The addition of the `throwIfParentInstance(""isLockTaskPermitted"")` method could potentially throw a new exception which was not present in the early version. The modification in the catch block to throw an exception instead of just logging an error message is also a change in exception handling. Both changes can cause this method to throw different exceptions across versions, hence the CI type is 2."
1157,<android.widget.ActionMenuPresenter.OpenOverflowRunnable: void run()>,23,24,<android.widget.ActionMenuPresenter.OpenOverflowRunnable: void run()>,<android.widget.ActionMenuPresenter.OpenOverflowRunnable: void run()>,0,"{
    mMenu.changeMenuMode();
    final View menuView = (View) mMenuView;
    if (menuView != null && menuView.getWindowToken() != null && mPopup.tryShow()) {
        mOverflowPopup = mPopup;
    }
    mPostedOpenRunnable = null;
}","{
    if (mMenu != null) {
        mMenu.changeMenuMode();
    }
    final View menuView = (View) mMenuView;
    if (menuView != null && menuView.getWindowToken() != null && mPopup.tryShow()) {
        mOverflowPopup = mPopup;
    }
    mPostedOpenRunnable = null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The code change involves wrapping the mMenu.changeMenuMode(); call with an if statement to check if mMenu is not null, which is a control dependency change, so the change type is 3.","The addition of the null check for mMenu does not constitute a compatibility issue because it is a protective measure to avoid potential NullPointerException; it has no effect on the API’s behavior when mMenu is not null (i.e., the pre-existing behavior is preserved). Thus, there is no CI, and the type is 0."
1158,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,23,24,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,0,"{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    final PointF localPoint = getLocalPoint();
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDrag = DragEvent.obtain(event);
                if (mDragNotifiedChildren == null) {
                    mDragNotifiedChildren = new HashSet<View>();
                } else {
                    mDragNotifiedChildren.clear();
                }
                // Now dispatch down to our children, caching the responses
                mChildAcceptsDrag = false;
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        final boolean handled = notifyChildOfDrag(children[i]);
                        if (handled) {
                            mChildAcceptsDrag = true;
                        }
                    }
                }
                // Return HANDLED if one of our children can accept the drag
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                if (mDragNotifiedChildren != null) {
                    for (View child : mDragNotifiedChildren) {
                        // If a child was notified about an ongoing drag, it's told that it's over
                        child.dispatchDragEvent(event);
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    mDragNotifiedChildren.clear();
                    if (mCurrentDrag != null) {
                        mCurrentDrag.recycle();
                        mCurrentDrag = null;
                    }
                }
                // had offered to handle the drag.
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                final View target = findFrontmostDroppableChildAt(event.mX, event.mY, localPoint);
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // If we've dragged off of a child view, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                        view.refreshDrawableState();
                    }
                    mCurrentDragView = target;
                    // If we've dragged over a new child view, send it the ENTERED message
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        target.dispatchDragEvent(event);
                        target.mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                        target.refreshDrawableState();
                    }
                    // restore the event's original state
                    event.mAction = action;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    event.mX = localPoint.x;
                    event.mY = localPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    view.dispatchDragEvent(event);
                    view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                    view.refreshDrawableState();
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, localPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = localPoint.x;
                    event.mY = localPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    // If none of our children could handle the event, try here
    if (!retval) {
        // Call up to the View implementation that dispatches to installed listeners
        retval = super.dispatchDragEvent(event);
    }
    return retval;
}","{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    final PointF localPoint = getLocalPoint();
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDragStartEvent = DragEvent.obtain(event);
                if (mChildrenInterestedInDrag == null) {
                    mChildrenInterestedInDrag = new HashSet<View>();
                } else {
                    mChildrenInterestedInDrag.clear();
                }
                // Now dispatch down to our children, caching the responses
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        if (notifyChildOfDragStart(children[i])) {
                            retval = true;
                        }
                    }
                }
                // Notify itself of the drag start.
                mIsInterestedInDrag = super.dispatchDragEvent(event);
                if (mIsInterestedInDrag) {
                    retval = true;
                }
                if (!retval) {
                    // Neither us nor any of our children are interested in this drag, so stop tracking
                    // the current drag event.
                    mCurrentDragStartEvent.recycle();
                    mCurrentDragStartEvent = null;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                final HashSet<View> childrenInterestedInDrag = mChildrenInterestedInDrag;
                if (childrenInterestedInDrag != null) {
                    for (View child : childrenInterestedInDrag) {
                        // If a child was interested in the ongoing drag, it's told that it's over
                        if (child.dispatchDragEvent(event)) {
                            retval = true;
                        }
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    childrenInterestedInDrag.clear();
                }
                if (mCurrentDragStartEvent != null) {
                    mCurrentDragStartEvent.recycle();
                    mCurrentDragStartEvent = null;
                }
                if (mIsInterestedInDrag) {
                    if (super.dispatchDragEvent(event)) {
                        retval = true;
                    }
                    mIsInterestedInDrag = false;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, localPoint);
                if (target == null && mIsInterestedInDrag) {
                    target = this;
                }
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // Position should not be available for ACTION_DRAG_ENTERED and ACTION_DRAG_EXITED.
                    event.mX = 0;
                    event.mY = 0;
                    // If we've dragged off of a child view or this window, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        if (view != this) {
                            view.dispatchDragEvent(event);
                            view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                            view.refreshDrawableState();
                        } else {
                            super.dispatchDragEvent(event);
                        }
                    }
                    mCurrentDragView = target;
                    // send it to this window.
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        if (target != this) {
                            target.dispatchDragEvent(event);
                            target.mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                            target.refreshDrawableState();
                        } else {
                            super.dispatchDragEvent(event);
                        }
                    }
                    // restore the event's original state
                    event.mAction = action;
                    event.mX = tx;
                    event.mY = ty;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    if (target != this) {
                        event.mX = localPoint.x;
                        event.mY = localPoint.y;
                        retval = target.dispatchDragEvent(event);
                        event.mX = tx;
                        event.mY = ty;
                    } else {
                        retval = super.dispatchDragEvent(event);
                    }
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    if (view != this) {
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                        view.refreshDrawableState();
                    } else {
                        super.dispatchDragEvent(event);
                    }
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, localPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = localPoint.x;
                    event.mY = localPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else if (mIsInterestedInDrag) {
                    retval = super.dispatchDragEvent(event);
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    return retval;
}",1,"// TODO: Write real docs
","// TODO: Write real docs
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1159,"<android.app.Activity: void requestPermissions(String[],int)>",23,24,"<android.app.Activity: void requestPermissions(String[],int)>","<android.app.Activity: void requestPermissions(String[],int)>",0,"{
    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
}","{
    if (mHasCurrentPermissionsRequest) {
        Log.w(TAG, ""Can reqeust only one set of permissions at a time"");
        // Dispatch the callback with empty arrays which means a cancellation.
        onRequestPermissionsResult(requestCode, new String[0], new int[0]);
        return;
    }
    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
    mHasCurrentPermissionsRequest = true;
}",1,"/**
 * Requests permissions to be granted to this application. These permissions
 * must be requested in your manifest, they should not be granted to your app,
 * and they should have protection level {@link android.content.pm.PermissionInfo
 * #PROTECTION_DANGEROUS dangerous}, regardless whether they are declared by
 * the platform or a third-party app.
 * <p>
 * Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}
 * are granted at install time if requested in the manifest. Signature permissions
 * {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at
 * install time if requested in the manifest and the signature of your app matches
 * the signature of the app declaring the permissions.
 * </p>
 * <p>
 * If your app does not have the requested permissions the user will be presented
 * with UI for accepting them. After the user has accepted or rejected the
 * requested permissions you will receive a callback on {@link
 * #onRequestPermissionsResult(int, String[], int[])} reporting whether the
 * permissions were granted or not.
 * </p>
 * <p>
 * Note that requesting a permission does not guarantee it will be granted and
 * your app should be able to run without having this permission.
 * </p>
 * <p>
 * This method may start an activity allowing the user to choose which permissions
 * to grant and which to reject. Hence, you should be prepared that your activity
 * may be paused and resumed. Further, granting some permissions may require
 * a restart of you application. In such a case, the system will recreate the
 * activity stack before delivering the result to {@link
 * #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * When checking whether you have a permission you should use {@link
 * #checkSelfPermission(String)}.
 * </p>
 * <p>
 * You cannot request a permission if your activity sets {@link
 * android.R.styleable#AndroidManifestActivity_noHistory noHistory} to
 * <code>true</code> because in this case the activity would not receive
 * result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * A sample permissions request looks like this:
 * </p>
 * <code><pre><p>
 * private void showContacts() {
 * if (checkSelfPermission(Manifest.permission.READ_CONTACTS)
 * != PackageManager.PERMISSION_GRANTED) {
 * requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},
 * PERMISSIONS_REQUEST_READ_CONTACTS);
 * } else {
 * doShowContacts();
 * }
 * }
 *
 * {@literal @}Override
 * public void onRequestPermissionsResult(int requestCode, String[] permissions,
 * int[] grantResults) {
 * if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS
 * && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
 * showContacts();
 * }
 * }
 * </code></pre></p>
 *
 * @param permissions The requested permissions.
 * @param requestCode Application specific request code to match with a result
 * reported to {@link #onRequestPermissionsResult(int, String[], int[])}.
 * Should be >= 0.
 *
 * @see #onRequestPermissionsResult(int, String[], int[])
 * @see #checkSelfPermission(String)
 * @see #shouldShowRequestPermissionRationale(String)
 */
","/**
 * Requests permissions to be granted to this application. These permissions
 * must be requested in your manifest, they should not be granted to your app,
 * and they should have protection level {@link android.content.pm.PermissionInfo
 * #PROTECTION_DANGEROUS dangerous}, regardless whether they are declared by
 * the platform or a third-party app.
 * <p>
 * Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}
 * are granted at install time if requested in the manifest. Signature permissions
 * {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at
 * install time if requested in the manifest and the signature of your app matches
 * the signature of the app declaring the permissions.
 * </p>
 * <p>
 * If your app does not have the requested permissions the user will be presented
 * with UI for accepting them. After the user has accepted or rejected the
 * requested permissions you will receive a callback on {@link
 * #onRequestPermissionsResult(int, String[], int[])} reporting whether the
 * permissions were granted or not.
 * </p>
 * <p>
 * Note that requesting a permission does not guarantee it will be granted and
 * your app should be able to run without having this permission.
 * </p>
 * <p>
 * This method may start an activity allowing the user to choose which permissions
 * to grant and which to reject. Hence, you should be prepared that your activity
 * may be paused and resumed. Further, granting some permissions may require
 * a restart of you application. In such a case, the system will recreate the
 * activity stack before delivering the result to {@link
 * #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * When checking whether you have a permission you should use {@link
 * #checkSelfPermission(String)}.
 * </p>
 * <p>
 * Calling this API for permissions already granted to your app would show UI
 * to the user to decide whether the app can still hold these permissions. This
 * can be useful if the way your app uses data guarded by the permissions
 * changes significantly.
 * </p>
 * <p>
 * You cannot request a permission if your activity sets {@link
 * android.R.styleable#AndroidManifestActivity_noHistory noHistory} to
 * <code>true</code> because in this case the activity would not receive
 * result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * The <a href=""http://developer.android.com/samples/RuntimePermissions/index.html"">
 * RuntimePermissions</a> sample app demonstrates how to use this method to
 * request permissions at run time.
 * </p>
 *
 * @param permissions The requested permissions. Must me non-null and not empty.
 * @param requestCode Application specific request code to match with a result
 * reported to {@link #onRequestPermissionsResult(int, String[], int[])}.
 * Should be >= 0.
 *
 * @see #onRequestPermissionsResult(int, String[], int[])
 * @see #checkSelfPermission(String)
 * @see #shouldShowRequestPermissionRationale(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The introduction of a new conditional check, logging statement, and method call onRequestPermissionsResult(requestCode, new String[0], new int[0]);, as well as setting the flag mHasCurrentPermissionsRequest represent both a control dependency change and other statement change, hence the change type is 3,4.","No Compatibility Issue is detected here. The addition of the check for mHasCurrentPermissionsRequest is designed to prevent multiple concurrent permission requests, and will only affect the flow if there is already a permissions request being processed. If such a condition occurs, instead of proceeding with another permissions request, onRequestPermissionsResult is called with empty arrays, signalling a cancellation. This change should not affect the behavior of existing code where permissions requests are managed correctly (one at a time), hence it should not result in a Compatibility Issue. It's an added behavior to handle specific erroneous concurrent requests. Existing single, well-managed requests will proceed as before without triggering the added code path. Thus, the Compatibility Issue situation is 0."
1160,"<android.hardware.camera2.impl.CameraDeviceImpl: boolean configureStreamsChecked(InputConfiguration,List<OutputConfiguration>,boolean)>",23,24,"<android.hardware.camera2.impl.CameraDeviceImpl: boolean configureStreamsChecked(InputConfiguration,List<OutputConfiguration>,boolean)>","<android.hardware.camera2.impl.CameraDeviceImpl: boolean configureStreamsChecked(InputConfiguration,List<OutputConfiguration>,boolean)>",0,"{
    // Treat a null input the same an empty list
    if (outputs == null) {
        outputs = new ArrayList<OutputConfiguration>();
    }
    if (outputs.size() == 0 && inputConfig != null) {
        throw new IllegalArgumentException(""cannot configure an input stream without "" + ""any output streams"");
    }
    checkInputConfiguration(inputConfig);
    boolean success = false;
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        // Streams to create
        HashSet<OutputConfiguration> addSet = new HashSet<OutputConfiguration>(outputs);
        // Streams to delete
        List<Integer> deleteList = new ArrayList<Integer>();
        // Determine which streams need to be created, which to be deleted
        for (int i = 0; i < mConfiguredOutputs.size(); ++i) {
            int streamId = mConfiguredOutputs.keyAt(i);
            OutputConfiguration outConfig = mConfiguredOutputs.valueAt(i);
            if (!outputs.contains(outConfig)) {
                deleteList.add(streamId);
            } else {
                // Don't create a stream previously created
                addSet.remove(outConfig);
            }
        }
        mDeviceHandler.post(mCallOnBusy);
        stopRepeating();
        try {
            waitUntilIdle();
            mRemoteDevice.beginConfigure();
            // reconfigure the input stream if the input configuration is different.
            InputConfiguration currentInputConfig = mConfiguredInput.getValue();
            if (inputConfig != currentInputConfig && (inputConfig == null || !inputConfig.equals(currentInputConfig))) {
                if (currentInputConfig != null) {
                    mRemoteDevice.deleteStream(mConfiguredInput.getKey());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(REQUEST_ID_NONE, null);
                }
                if (inputConfig != null) {
                    int streamId = mRemoteDevice.createInputStream(inputConfig.getWidth(), inputConfig.getHeight(), inputConfig.getFormat());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(streamId, inputConfig);
                }
            }
            // Delete all streams first (to free up HW resources)
            for (Integer streamId : deleteList) {
                mRemoteDevice.deleteStream(streamId);
                mConfiguredOutputs.delete(streamId);
            }
            // Add all new streams
            for (OutputConfiguration outConfig : outputs) {
                if (addSet.contains(outConfig)) {
                    int streamId = mRemoteDevice.createStream(outConfig);
                    mConfiguredOutputs.put(streamId, outConfig);
                }
            }
            try {
                mRemoteDevice.endConfigure(isConstrainedHighSpeed);
            } catch (IllegalArgumentException e) {
                // OK. camera service can reject stream config if it's not supported by HAL
                // This is only the result of a programmer misusing the camera2 api.
                Log.w(TAG, ""Stream configuration failed"");
                return false;
            }
            success = true;
        } catch (CameraRuntimeException e) {
            if (e.getReason() == CAMERA_IN_USE) {
                throw new IllegalStateException(""The camera is currently busy."" + "" You must wait until the previous operation completes."");
            }
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return false;
        } finally {
            if (success && outputs.size() > 0) {
                mDeviceHandler.post(mCallOnIdle);
            } else {
                // Always return to the 'unconfigured' state if we didn't hit a fatal error
                mDeviceHandler.post(mCallOnUnconfigured);
            }
        }
    }
    return success;
}","{
    // Treat a null input the same an empty list
    if (outputs == null) {
        outputs = new ArrayList<OutputConfiguration>();
    }
    if (outputs.size() == 0 && inputConfig != null) {
        throw new IllegalArgumentException(""cannot configure an input stream without "" + ""any output streams"");
    }
    checkInputConfiguration(inputConfig);
    boolean success = false;
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        // Streams to create
        HashSet<OutputConfiguration> addSet = new HashSet<OutputConfiguration>(outputs);
        // Streams to delete
        List<Integer> deleteList = new ArrayList<Integer>();
        // Determine which streams need to be created, which to be deleted
        for (int i = 0; i < mConfiguredOutputs.size(); ++i) {
            int streamId = mConfiguredOutputs.keyAt(i);
            OutputConfiguration outConfig = mConfiguredOutputs.valueAt(i);
            if (!outputs.contains(outConfig)) {
                deleteList.add(streamId);
            } else {
                // Don't create a stream previously created
                addSet.remove(outConfig);
            }
        }
        mDeviceHandler.post(mCallOnBusy);
        stopRepeating();
        try {
            waitUntilIdle();
            mRemoteDevice.beginConfigure();
            // reconfigure the input stream if the input configuration is different.
            InputConfiguration currentInputConfig = mConfiguredInput.getValue();
            if (inputConfig != currentInputConfig && (inputConfig == null || !inputConfig.equals(currentInputConfig))) {
                if (currentInputConfig != null) {
                    mRemoteDevice.deleteStream(mConfiguredInput.getKey());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(REQUEST_ID_NONE, null);
                }
                if (inputConfig != null) {
                    int streamId = mRemoteDevice.createInputStream(inputConfig.getWidth(), inputConfig.getHeight(), inputConfig.getFormat());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(streamId, inputConfig);
                }
            }
            // Delete all streams first (to free up HW resources)
            for (Integer streamId : deleteList) {
                mRemoteDevice.deleteStream(streamId);
                mConfiguredOutputs.delete(streamId);
            }
            // Add all new streams
            for (OutputConfiguration outConfig : outputs) {
                if (addSet.contains(outConfig)) {
                    int streamId = mRemoteDevice.createStream(outConfig);
                    mConfiguredOutputs.put(streamId, outConfig);
                }
            }
            mRemoteDevice.endConfigure(isConstrainedHighSpeed);
            success = true;
        } catch (IllegalArgumentException e) {
            // OK. camera service can reject stream config if it's not supported by HAL
            // This is only the result of a programmer misusing the camera2 api.
            Log.w(TAG, ""Stream configuration failed due to: "" + e.getMessage());
            return false;
        } catch (CameraAccessException e) {
            if (e.getReason() == CameraAccessException.CAMERA_IN_USE) {
                throw new IllegalStateException(""The camera is currently busy."" + "" You must wait until the previous operation completes."", e);
            }
            throw e;
        } finally {
            if (success && outputs.size() > 0) {
                mDeviceHandler.post(mCallOnIdle);
            } else {
                // Always return to the 'unconfigured' state if we didn't hit a fatal error
                mDeviceHandler.post(mCallOnUnconfigured);
            }
        }
    }
    return success;
}",1,"/**
 * Attempt to configure the input and outputs; the device goes to idle and then configures the
 * new input and outputs if possible.
 *
 * <p>The configuration may gracefully fail, if input configuration is not supported,
 * if there are too many outputs, if the formats are not supported, or if the sizes for that
 * format is not supported. In this case this function will return {@code false} and the
 * unconfigured callback will be fired.</p>
 *
 * <p>If the configuration succeeds (with 1 or more outputs with or without an input),
 * then the idle callback is fired. Unconfiguring the device always fires the idle callback.</p>
 *
 * @param inputConfig input configuration or {@code null} for no input
 * @param outputs a list of one or more surfaces, or {@code null} to unconfigure
 * @param isConstrainedHighSpeed If the streams configuration is for constrained high speed output.
 * @return whether or not the configuration was successful
 *
 * @throws CameraAccessException if there were any unexpected problems during configuration
 */
","/**
 * Attempt to configure the input and outputs; the device goes to idle and then configures the
 * new input and outputs if possible.
 *
 * <p>The configuration may gracefully fail, if input configuration is not supported,
 * if there are too many outputs, if the formats are not supported, or if the sizes for that
 * format is not supported. In this case this function will return {@code false} and the
 * unconfigured callback will be fired.</p>
 *
 * <p>If the configuration succeeds (with 1 or more outputs with or without an input),
 * then the idle callback is fired. Unconfiguring the device always fires the idle callback.</p>
 *
 * @param inputConfig input configuration or {@code null} for no input
 * @param outputs a list of one or more surfaces, or {@code null} to unconfigure
 * @param isConstrainedHighSpeed If the streams configuration is for constrained high speed output.
 * @return whether or not the configuration was successful
 *
 * @throws CameraAccessException if there were any unexpected problems during configuration
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1162,<android.app.Activity: void setActionBar(Toolbar)>,23,24,<android.app.Activity: void setActionBar(Toolbar)>,<android.app.Activity: void setActionBar(Toolbar)>,0,"{
    if (getActionBar() instanceof WindowDecorActionBar) {
        throw new IllegalStateException(""This Activity already has an action bar supplied "" + ""by the window decor. Do not request Window.FEATURE_ACTION_BAR and set "" + ""android:windowActionBar to false in your theme to use a Toolbar instead."");
    }
    // Clear out the MenuInflater to make sure that it is valid for the new Action Bar
    mMenuInflater = null;
    ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
    mActionBar = tbab;
    mWindow.setCallback(tbab.getWrappedWindowCallback());
    mActionBar.invalidateOptionsMenu();
}","{
    final ActionBar ab = getActionBar();
    if (ab instanceof WindowDecorActionBar) {
        throw new IllegalStateException(""This Activity already has an action bar supplied "" + ""by the window decor. Do not request Window.FEATURE_ACTION_BAR and set "" + ""android:windowActionBar to false in your theme to use a Toolbar instead."");
    }
    // If we reach here then we're setting a new action bar
    // First clear out the MenuInflater to make sure that it is valid for the new Action Bar
    mMenuInflater = null;
    // If we have an action bar currently, destroy it
    if (ab != null) {
        ab.onDestroy();
    }
    if (toolbar != null) {
        final ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
        mActionBar = tbab;
        mWindow.setCallback(tbab.getWrappedWindowCallback());
    } else {
        mActionBar = null;
        // Re-set the original window callback since we may have already set a Toolbar wrapper
        mWindow.setCallback(this);
    }
    invalidateOptionsMenu();
}",1,"/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */
","/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar, or {@code null} to clear it
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version introduces variables, a new if-condition to call ab.onDestroy(), an additional null check for 'toolbar', and changes the calling of 'mActionBar.invalidateOptionsMenu()' to 'invalidateOptionsMenu()'. These changes result in the control flow of the method to be different, as well as other statements outside of control structures being modified. Hence, the change types are 1, 3, 4.","The API introduces a scenario in which if there is already an action bar (non-null 'ab'), it will now call ab.onDestroy(). It also modifies the condition under which 'mActionBar' is set and changes the call at the end of the method. Furthermore, it changes which callback is set on 'mWindow' based on the toolbar's value, which could change the return behavior (as 'mActionBar' could now be set to null). Therefore, the CI type is 1, due to the potential different return values or types."
1163,"<android.hardware.camera2.CameraManager.CameraManagerGlobal: void setTorchMode(String,boolean)>",23,24,"<android.hardware.camera2.CameraManager.CameraManagerGlobal: void setTorchMode(String,boolean)>","<android.hardware.camera2.CameraManager.CameraManagerGlobal: void setTorchMode(String,boolean)>",0,"{
    synchronized (mLock) {
        if (cameraId == null) {
            throw new IllegalArgumentException(""cameraId was null"");
        }
        ICameraService cameraService = getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            int status = cameraService.setTorchMode(cameraId, enabled, mTorchClientBinder);
        } catch (CameraRuntimeException e) {
            int problem = e.getReason();
            switch(problem) {
                case CameraAccessException.CAMERA_ERROR:
                    throw new IllegalArgumentException(""the camera device doesn't have a flash unit."");
                default:
                    throw e.asChecked();
            }
        } catch (RemoteException e) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
    }
}","{
    synchronized (mLock) {
        if (cameraId == null) {
            throw new IllegalArgumentException(""cameraId was null"");
        }
        ICameraService cameraService = getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            cameraService.setTorchMode(cameraId, enabled, mTorchClientBinder);
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The catch block for `CameraRuntimeException` has been removed and replaced with a catch block for `ServiceSpecificException`, and then there is a call to a new method `throwAsPublicException(e)`. The type of exception caught has been changed and the way of handling the exception is updated (from a switch case to a method call), so the change type is 2,5.","With the handling of exceptions changing from a direct throw based on a switch case to a method call (`throwAsPublicException(e)`), the behaviour in terms of which exception the method may throw has potentially changed, so the CI type is 2."
1164,<android.app.AppOpsManager: void stopWatchingMode(OnOpChangedListener)>,23,24,<android.app.AppOpsManager: void stopWatchingMode(OnOpChangedListener)>,<android.app.AppOpsManager: void stopWatchingMode(OnOpChangedListener)>,0,"{
    synchronized (mModeWatchers) {
        IAppOpsCallback cb = mModeWatchers.get(callback);
        if (cb != null) {
            try {
                mService.stopWatchingMode(cb);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    synchronized (mModeWatchers) {
        IAppOpsCallback cb = mModeWatchers.get(callback);
        if (cb != null) {
            try {
                mService.stopWatchingMode(cb);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}",1,"/**
 * Stop monitoring that was previously started with {@link #startWatchingMode}.  All
 * monitoring associated with this callback will be removed.
 */
","/**
 * Stop monitoring that was previously started with {@link #startWatchingMode}.  All
 * monitoring associated with this callback will be removed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The only change is the addition of throw statement inside the catch block, so the code change type is 2.","The late version of the API introduces a new throw statement within the catch block, which means it could throw a new exception that the early version does not. This can lead to different exception handling behavior, so the CI type is 2."
1165,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,23,24,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"4,5",0,"In the late version, the prepareToLeaveProcess method has an additional parameter 'this', which means its signature has been modified, so the change type is 4,5.","There is no Compatibility Issue detected here. The additional parameter 'this' in the prepareToLeaveProcess method does not affect the return value since the method in question is 'void' (doesn't return any value), and the exception handling for RemoteException remains functionally the same with a different method (rethrowFromSystemServer) being called to throw a RuntimeException. The change in exception handling method shouldn't affect the caller since it's still a RuntimeException being thrown in case of RemoteException."
1166,<android.widget.TimePicker: boolean is24HourView()>,23,24,<android.widget.TimePicker: boolean is24HourView()>,<android.widget.TimePicker: boolean is24HourView()>,0,"{
    return mDelegate.is24HourView();
}","{
    return mDelegate.is24Hour();
}",1,"/**
 * @return {@code true} if this widget displays time in 24-hour mode,
 * {@code false} otherwise}
 * @see #setIs24HourView(Boolean)
 */
","/**
 * @return {@code true} if this widget displays time in 24-hour mode,
 * {@code false} otherwise}
 * @see #setIs24HourView(Boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called on the mDelegate object has changed from is24HourView() to is24Hour(), so the code change type is 5 (Dependent API changed).","Although the dependent API name has changed, it seems to be just a method name update and does not intrinsically suggest a change in return value or type. No new exception handling has been introduced, and there is no modification of the return type. If the semantics of 'is24Hour()' are the same as 'is24HourView()', there would be no Compatibility Issue, so the CI type is 0 (No Compatibility Issue). However, without further information on the implementation of the 'is24Hour()' method or confirmation that its behavior is identical to 'is24HourView()', we cannot be entirely certain there is no Compatibility Issue. With the information provided, we can only base our decision on the assumption that the method name change does not impact compatibility."
1167,<android.text.BidiFormatter: BidiFormatter getInstance(boolean)>,23,24,<android.text.BidiFormatter: BidiFormatter getInstance(boolean)>,<android.text.BidiFormatter: BidiFormatter getInstance(boolean)>,0,"{
    return new Builder(rtlContext).build();
}","{
    return getDefaultInstanceFromContext(rtlContext);
}",1,"/**
 * Factory for creating an instance of BidiFormatter given the context directionality.
 *
 * @param rtlContext Whether the context directionality is RTL.
 */
","/**
 * Factory for creating an instance of BidiFormatter given the context directionality.
 *
 * This does not create any new objects, and returns already existing static instances.
 *
 * @param rtlContext Whether the context directionality is RTL.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed from using 'new Builder(rtlContext).build();' to 'getDefaultInstanceFromContext(rtlContext);', which is calling a different method for getting the instance, so the code change type is 5.","There's no Compatibility Issue here since the returning type is still 'BidiFormatter', and the behavior is expected to be the same, which is to return a BidiFormatter instance based on the provided context. Just because it's not constructing a new BidiFormatter via the Builder class does not necessarily mean the behavior or the return type/value has changed. It may be an internal optimization or change, which doesn't affect the contract of the method. Therefore, there's no Compatibility Issue caused by potential different return values or types nor by potential different exception handlings."
1168,"<android.view.inputmethod.BaseInputConnection: boolean deleteSurroundingText(int,int)>",23,24,"<android.view.inputmethod.BaseInputConnection: boolean deleteSurroundingText(int,int)>","<android.view.inputmethod.BaseInputConnection: boolean deleteSurroundingText(int,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""deleteSurroundingText "" + beforeLength + "" / "" + afterLength);
    final Editable content = getEditable();
    if (content == null)
        return false;
    beginBatchEdit();
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // ignore the composing text.
    int ca = getComposingSpanStart(content);
    int cb = getComposingSpanEnd(content);
    if (cb < ca) {
        int tmp = ca;
        ca = cb;
        cb = tmp;
    }
    if (ca != -1 && cb != -1) {
        if (ca < a)
            a = ca;
        if (cb > b)
            b = cb;
    }
    int deleted = 0;
    if (beforeLength > 0) {
        int start = a - beforeLength;
        if (start < 0)
            start = 0;
        content.delete(start, a);
        deleted = a - start;
    }
    if (afterLength > 0) {
        b = b - deleted;
        int end = b + afterLength;
        if (end > content.length())
            end = content.length();
        content.delete(b, end);
    }
    endBatchEdit();
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""deleteSurroundingText "" + beforeLength + "" / "" + afterLength);
    final Editable content = getEditable();
    if (content == null)
        return false;
    beginBatchEdit();
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // Ignore the composing text.
    int ca = getComposingSpanStart(content);
    int cb = getComposingSpanEnd(content);
    if (cb < ca) {
        int tmp = ca;
        ca = cb;
        cb = tmp;
    }
    if (ca != -1 && cb != -1) {
        if (ca < a)
            a = ca;
        if (cb > b)
            b = cb;
    }
    int deleted = 0;
    if (beforeLength > 0) {
        int start = a - beforeLength;
        if (start < 0)
            start = 0;
        content.delete(start, a);
        deleted = a - start;
    }
    if (afterLength > 0) {
        b = b - deleted;
        int end = b + afterLength;
        if (end > content.length())
            end = content.length();
        content.delete(b, end);
    }
    endBatchEdit();
    return true;
}",1,"/**
 * The default implementation performs the deletion around the current
 * selection position of the editable text.
 * @param beforeLength
 * @param afterLength
 */
","/**
 * The default implementation performs the deletion around the current selection position of the
 * editable text.
 *
 * @param beforeLength The number of characters before the cursor to be deleted, in code unit.
 * If this is greater than the number of existing characters between the beginning of the
 * text and the cursor, then this method does not fail but deletes all the characters in
 * that range.
 * @param afterLength The number of characters after the cursor to be deleted, in code unit.
 * If this is greater than the number of existing characters between the cursor and
 * the end of the text, then this method does not fail but deletes all the characters in
 * that range.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation between the two versions; comments and code format do not affect the functionality.,"Since there are no changes in the actual code, there is no Compatibility Issue between the two versions."
1169,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,23,24,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.isDiscovering();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isDiscovering();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return true if discovering
 */
","/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return true if discovering
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"3,4",0,"There's the introduction of a lock mechanism around the remote service interaction using mServiceLock.readLock().lock() and mServiceLock.readLock().unlock(), which constitutes both a control dependency change and an other statement change. Therefore, the code change type is 3,4.","These changes don't affect the method's return values or exceptions it may throw. They are concerned with thread safety and avoiding potential concurrent access issues. The behavior of the method in terms of what it returns under various states (whether Bluetooth discovery is occurring or not) remains consistent with the earlier version. Thus, there is no Compatibility Issue."
1170,"<android.content.RestrictionsManager: void notifyPermissionResponse(String,PersistableBundle)>",23,24,"<android.content.RestrictionsManager: void notifyPermissionResponse(String,PersistableBundle)>","<android.content.RestrictionsManager: void notifyPermissionResponse(String,PersistableBundle)>",0,"{
    if (packageName == null) {
        throw new NullPointerException(""packageName cannot be null"");
    }
    if (response == null) {
        throw new NullPointerException(""request cannot be null"");
    }
    if (!response.containsKey(REQUEST_KEY_ID)) {
        throw new IllegalArgumentException(""REQUEST_KEY_ID must be specified"");
    }
    if (!response.containsKey(RESPONSE_KEY_RESULT)) {
        throw new IllegalArgumentException(""RESPONSE_KEY_RESULT must be specified"");
    }
    try {
        if (mService != null) {
            mService.notifyPermissionResponse(packageName, response);
        }
    } catch (RemoteException re) {
        Log.w(TAG, ""Couldn't reach service"");
    }
}","{
    if (packageName == null) {
        throw new NullPointerException(""packageName cannot be null"");
    }
    if (response == null) {
        throw new NullPointerException(""request cannot be null"");
    }
    if (!response.containsKey(REQUEST_KEY_ID)) {
        throw new IllegalArgumentException(""REQUEST_KEY_ID must be specified"");
    }
    if (!response.containsKey(RESPONSE_KEY_RESULT)) {
        throw new IllegalArgumentException(""RESPONSE_KEY_RESULT must be specified"");
    }
    try {
        if (mService != null) {
            mService.notifyPermissionResponse(packageName, response);
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by the Restrictions Provider to deliver a response to an application.
 *
 * @param packageName the application to deliver the response to. Cannot be null.
 * @param response the bundle containing the response status, request ID and other information.
 * Cannot be null.
 *
 * @throws IllegalArgumentException if any of the required parameters are missing.
 */
","/**
 * Called by the Restrictions Provider to deliver a response to an application.
 *
 * @param packageName the application to deliver the response to. Cannot be null.
 * @param response the bundle containing the response status, request ID and other information.
 * Cannot be null.
 *
 * @throws IllegalArgumentException if any of the required parameters are missing.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The catch block in the late version has changed, as it now throws an exception using rethrowFromSystemServer() instead of logging the exception with Log.w. This change is classified as 2.",The handling of RemoteException has changed from logging the exception to throwing it. This change in exception handling can lead to a different behavior when RemoteException occurs because the exception may now propagate further up the call stack instead of being logged and swallowed. The CI type is 2.
1171,<android.widget.Editor.HandleView: void updateDrawable()>,23,24,<android.widget.Editor.HandleView: void updateDrawable()>,<android.widget.Editor.HandleView: void updateDrawable()>,0,"{
    if (mIsDragging) {
        // Don't update drawable during dragging.
        return;
    }
    final int offset = getCurrentCursorOffset();
    final boolean isRtlCharAtOffset = mTextView.getLayout().isRtlCharAt(offset);
    final Drawable oldDrawable = mDrawable;
    mDrawable = isRtlCharAtOffset ? mDrawableRtl : mDrawableLtr;
    mHotspotX = getHotspotX(mDrawable, isRtlCharAtOffset);
    mHorizontalGravity = getHorizontalGravity(isRtlCharAtOffset);
    final Layout layout = mTextView.getLayout();
    if (layout != null && oldDrawable != mDrawable && isShowing()) {
        // Update popup window position.
        mPositionX = (int) (layout.getPrimaryHorizontal(offset) - 0.5f - mHotspotX - getHorizontalOffset() + getCursorOffset());
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionHasChanged = true;
        updatePosition(mLastParentX, mLastParentY, false, false);
        postInvalidate();
    }
}","{
    if (mIsDragging) {
        // Don't update drawable during dragging.
        return;
    }
    final Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final int offset = getCurrentCursorOffset();
    final boolean isRtlCharAtOffset = isAtRtlRun(layout, offset);
    final Drawable oldDrawable = mDrawable;
    mDrawable = isRtlCharAtOffset ? mDrawableRtl : mDrawableLtr;
    mHotspotX = getHotspotX(mDrawable, isRtlCharAtOffset);
    mHorizontalGravity = getHorizontalGravity(isRtlCharAtOffset);
    if (oldDrawable != mDrawable && isShowing()) {
        // Update popup window position.
        mPositionX = getCursorHorizontalPosition(layout, offset) - mHotspotX - getHorizontalOffset() + getCursorOffset();
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionHasChanged = true;
        updatePosition(mLastParentX, mLastParentY, false, false);
        postInvalidate();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"There is an additional return statement when `layout == null`. Additionally, the determination of `isRtlCharAtOffset` has changed by using a new method `isAtRtlRun(layout, offset)` instead of `layout.isRtlCharAt(offset)`, and the way to calculate `mPositionX` has been altered by introducing `getCursorHorizontalPosition(layout, offset)` instead of `layout.getPrimaryHorizontal(offset)`. Due to this, we identify the changes as return statement changed (1), control dependency changed (3), and other statement changed (4). There is also a change in a dependent API as we can see the method `isAtRtlRun` and `getCursorHorizontalPosition` are now used instead of directly calling methods on `layout`, which is classified as type (5).","The additional return statement may cause the method to exit earlier than before, possibly affecting the return value; hence it is classified as a Compatibility Issue (1). The changed determination of RTL could lead to different drawable states, and hence a different return value. The changes in the way `mPositionX` is calculated can also affect the return value by potentially positioning the handle view differently on screen."
1172,"<android.app.ContextImpl: void startActivity(Intent,Bundle)>",23,24,"<android.app.ContextImpl: void startActivity(Intent,Bundle)>","<android.app.ContextImpl: void startActivity(Intent,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
        throw new AndroidRuntimeException(""Calling startActivity() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivity(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1, options);
}","{
    warnIfCallingFromSystemProcess();
    // be launched in.
    if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0 && options != null && ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) {
        throw new AndroidRuntimeException(""Calling startActivity() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivity(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1, options);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The condition in the 'if' statement has been expanded to also account for the 'options' Bundle and checking if the launch task ID from the options is -1, so the code change type is 3.","The addition to the conditional statement refines the circumstances under which an AndroidRuntimeException is thrown, but it will not cause any change in behavior for existing code that is correctly passing the FLAG_ACTIVITY_NEW_TASK flag. It could potentially allow for more use cases without throwing an exception (when options are not null and launch task ID is not -1), but it would not adversely affect any code that was working correctly against the early version of the API. Hence, there is no Compatibility Issue, and the CI type is 0."
1173,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,23,24,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,0,"{
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedFilteringSupported, error: "", e);
    }
    return false;
}","{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedFilteringSupported, error: "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */
","/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",0,"The late version introduces locking around the mService calls and a new control flow (try-finally block), which is a control dependency change (type 3). The method now also contains additional statements, related to locking (type 4), and a change in exception handling inside the try block with the inclusion of the finally block (type 2).","Although there are changes to the control flow and the addition of the readLock, which affects other statements, these changes do not affect the return values or exception handling from the perspective of the method's client. The method still returns either false or the result of mService.isOffloadedFilteringSupported(), and on RemoteException, the method logs the error and returns false, similar to the earlier version. Thus, no Compatibility Issue is introduced, and there's no change in the potential behavior of this API from the perspective of the client."
1174,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumUpperCase(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumUpperCase(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of upper case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of upper case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
","/**
 * Called by an application that is administering the device to set the minimum number of upper
 * case letters required in the password. After setting this, the user will not be able to enter
 * a new password that is not at least as restrictive as what has been set. Note that the
 * current password will remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of upper case letters required in the password.
 * A value of 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The change includes adding a new parameter to the method call mService.setPasswordMinimumUpperCase(admin, length, mParentInstance) and altering the exception handling from logging the exception to throwing it. This indicates there's a change in the dependent API (parameter list of setPasswordMinimumUpperCase()), an 'other statement changed' due to the added parameter in the method call, and an 'exception handling statement changed' due to altered exception handling mechanism. Thus, the code changes types are 2,4,5.","The introduced change in exception handling from logging an exception to throwing can lead to different exception behavior in the client code, causing a CI due to potential different exception handlings. There is no change in return values because the method's return type is void and there's no change in the control flow that affects the method's outcome. Thus, the CI type is 2."
1176,<android.text.TextUtils: boolean isDigitsOnly(CharSequence)>,23,24,<android.text.TextUtils: boolean isDigitsOnly(CharSequence)>,<android.text.TextUtils: boolean isDigitsOnly(CharSequence)>,0,"{
    final int len = str.length();
    for (int i = 0; i < len; i++) {
        if (!Character.isDigit(str.charAt(i))) {
            return false;
        }
    }
    return true;
}","{
    final int len = str.length();
    for (int cp, i = 0; i < len; i += Character.charCount(cp)) {
        cp = Character.codePointAt(str, i);
        if (!Character.isDigit(cp)) {
            return false;
        }
    }
    return true;
}",1,"/**
 * Returns whether the given CharSequence contains only digits.
 */
","/**
 * Returns whether the given CharSequence contains only digits.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The for-loop has been modified to properly handle supplementary characters (potentially composed of two 'char') by updating 'i' with Character.charCount(cp) instead of i++, and instead of checking each 'char', the code is now checking the entire codepoint. This changes how the loop iterates over the characters and also which method is called inside the loop (Character.codePointAt(str, i) instead of str.charAt(i)), so the code change types are 3 and 5.","The method in the late version considers the full Unicode characters by using Character.codePointAt and Character.isDigit(cp), which can recognize digits outside the BMP (Basic Multilingual Plane). As a result, the method might return a different boolean value compared to the early version when the input CharSequence contains supplementary characters that represent digits. Thus, the CI type is 1."
1178,<android.view.ViewOverlay.OverlayViewGroup: void remove(Drawable)>,23,24,<android.view.ViewOverlay.OverlayViewGroup: void remove(Drawable)>,<android.view.ViewOverlay.OverlayViewGroup: void remove(Drawable)>,0,"{
    if (mDrawables != null) {
        mDrawables.remove(drawable);
        invalidate(drawable.getBounds());
        drawable.setCallback(null);
    }
}","{
    if (drawable == null) {
        throw new IllegalArgumentException(""drawable must be non-null"");
    }
    if (mDrawables != null) {
        mDrawables.remove(drawable);
        invalidate(drawable.getBounds());
        drawable.setCallback(null);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The late version adds a new condition that checks if the drawable is null and throws an IllegalArgumentException if it is, which means exception handling and control dependency have changed. Hence, the change types are 2,3.","Because the newly introduced exception handling with the if (drawable == null) check can cause an IllegalArgumentException to be thrown where it previously wouldn't have been thrown, there's a compatibility issue related to different exception handling between the early and late versions, so the CI type is 2."
1179,"<android.app.admin.DevicePolicyManager: boolean setApplicationHidden(ComponentName,String,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: boolean setApplicationHidden(ComponentName,String,boolean)>","<android.app.admin.DevicePolicyManager: boolean setApplicationHidden(ComponentName,String,boolean)>",0,"{
    if (mService != null) {
        try {
            return mService.setApplicationHidden(admin, packageName, hidden);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""setApplicationHidden"");
    if (mService != null) {
        try {
            return mService.setApplicationHidden(admin, packageName, hidden);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by profile or device owners to hide or unhide packages. When a package is hidden it
 * is unavailable for use, but the data and actual package file remain.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to hide or unhide.
 * @param hidden {@code true} if the package should be hidden, {@code false} if it should be
 * unhidden.
 * @return boolean Whether the hidden setting of the package was successfully updated.
 */
","/**
 * Called by profile or device owners to hide or unhide packages. When a package is hidden it is
 * unavailable for use, but the data and actual package file remain.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to hide or unhide.
 * @param hidden {@code true} if the package should be hidden, {@code false} if it should be
 * unhidden.
 * @return boolean Whether the hidden setting of the package was successfully updated.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The new method call `throwIfParentInstance(""setApplicationHidden"")` was added in the late version, which adds a call to a dependent API and hence falls under change type 4 and 5. Additionally, the exception handling statement changed from logging the exception to rethrowing it, so the change type is 2.","The change in exception handling where `RemoteException` is thrown instead of being logged could lead to different exception-handling behavior in the client code, which may not expect an exception to be thrown. Thus, the CI type is 2."
1180,"<android.inputmethodservice.InputMethodService: boolean onShowInputRequested(int,boolean)>",23,24,"<android.inputmethodservice.InputMethodService: boolean onShowInputRequested(int,boolean)>","<android.inputmethodservice.InputMethodService: boolean onShowInputRequested(int,boolean)>",0,"{
    if (!onEvaluateInputViewShown()) {
        return false;
    }
    if ((flags & InputMethod.SHOW_EXPLICIT) == 0) {
        if (!configChange && onEvaluateFullscreenMode()) {
            // mode at this point.
            return false;
        }
        Configuration config = getResources().getConfiguration();
        if (config.keyboard != Configuration.KEYBOARD_NOKEYS) {
            // These kinds of devices don't need it that much.
            return false;
        }
    }
    if ((flags & InputMethod.SHOW_FORCED) != 0) {
        mShowInputForced = true;
    }
    return true;
}","{
    if (!onEvaluateInputViewShown()) {
        return false;
    }
    if ((flags & InputMethod.SHOW_EXPLICIT) == 0) {
        if (!configChange && onEvaluateFullscreenMode()) {
            // mode at this point.
            return false;
        }
        if (!mSettingsObserver.shouldShowImeWithHardKeyboard() && getResources().getConfiguration().keyboard != Configuration.KEYBOARD_NOKEYS) {
            // These kinds of devices don't need it that much.
            return false;
        }
    }
    return true;
}",1,"/**
 * The system has decided that it may be time to show your input method.
 * This is called due to a corresponding call to your
 * {@link InputMethod#showSoftInput InputMethod.showSoftInput()}
 * method.  The default implementation uses
 * {@link #onEvaluateInputViewShown()}, {@link #onEvaluateFullscreenMode()},
 * and the current configuration to decide whether the input view should
 * be shown at this point.
 *
 * @param flags Provides additional information about the show request,
 * as per {@link InputMethod#showSoftInput InputMethod.showSoftInput()}.
 * @param configChange This is true if we are re-showing due to a
 * configuration change.
 * @return Returns true to indicate that the window should be shown.
 */
","/**
 * The system has decided that it may be time to show your input method.
 * This is called due to a corresponding call to your
 * {@link InputMethod#showSoftInput InputMethod.showSoftInput()}
 * method.  The default implementation uses
 * {@link #onEvaluateInputViewShown()}, {@link #onEvaluateFullscreenMode()},
 * and the current configuration to decide whether the input view should
 * be shown at this point.
 *
 * @param flags Provides additional information about the show request,
 * as per {@link InputMethod#showSoftInput InputMethod.showSoftInput()}.
 * @param configChange This is true if we are re-showing due to a
 * configuration change.
 * @return Returns true to indicate that the window should be shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"There is control dependency change with an additional condition check for `mSettingsObserver.shouldShowImeWithHardKeyboard()`. Also, a statement has been deleted (`mShowInputForced = true;`) which is an 'other statement change'. Moreover, the `shouldShowImeWithHardKeyboard()` method seems to be from a dependent API, which classifies it also as a dependent API change. The return statement type remains the same, but the logic that influences the result has changed, so code change types are 1, 3, 4, 5.","Since there is an addition of a new condition that affects the result of the boolean returned, there may be different return values under certain conditions. The removal of setting `mShowInputForced` to true can also potentially change the behavior of other methods that could have relied on this state being set within this method, leading to a CI. This means that the API could potentially return a different value, so the CI type is 1."
1181,<android.accounts.AccountManager: void clearPassword(Account)>,23,24,<android.accounts.AccountManager: void clearPassword(Account)>,<android.accounts.AccountManager: void clearPassword(Account)>,0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        mService.clearPassword(account);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        mService.clearPassword(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Forgets a saved password.  This erases the local copy of the password;
 * it does not change the user's account password on the server.
 * Has the same effect as setPassword(account, null) but requires fewer
 * permissions, and may be used by applications or management interfaces
 * to ""sign out"" from an account.
 *
 * <p>This method only successfully clear the account's password when the
 * caller has the same signature as the authenticator that owns the
 * specified account. Otherwise, this method will silently fail.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account whose password to clear
 */
","/**
 * Forgets a saved password.  This erases the local copy of the password;
 * it does not change the user's account password on the server.
 * Has the same effect as setPassword(account, null) but requires fewer
 * permissions, and may be used by applications or management interfaces
 * to ""sign out"" from an account.
 *
 * <p>This method only successfully clear the account's password when the
 * caller has the same signature as the authenticator that owns the
 * specified account. Otherwise, this method will silently fail.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account whose password to clear
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,The change in the exception handling statement from `throw new RuntimeException(e);` to `throw e.rethrowFromSystemServer();` indicates a change of type 2.,"This change in exception handling could result in a different exception being thrown (from RuntimeException to whatever rethrowFromSystemServer ends up throwing), which represents a change in behavior and can lead to compatibility issues. Therefore, the CI type is 2."
1182,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,23,24,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""id="").append(mId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", bounds="").append(mBoundsInScreen);
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""title="").append(mTitle);
    builder.append(""id="").append(mId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", bounds="").append(mBoundsInScreen);
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED);
        builder.append("", isAnchored="").append(mAnchorId != UNDEFINED);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"A new field mTitle has been added to the string builder, a check for mAnchorId has been added to the condition inside the DEBUG is false block, which also affects a control dependency since it is inside an if-else condition. Hence, the change types are 1 (as the return value string changes by inclusion of the title), 3 (control structure change due to the introduction of different condition checks; although this is debug code, it may affect output), and 4 (due to the addition of the new fields in the StringBuilder).","The string representation of the object has been modified to include the title and anchor status, which changes the return value, and consequently, this could lead to CI as the output when the toString method is called will be different. Therefore, it falls under CI type 1."
1183,<android.app.EnterTransitionCoordinator: boolean cancelEnter()>,23,24,<android.app.EnterTransitionCoordinator: boolean cancelEnter()>,<android.app.EnterTransitionCoordinator: boolean cancelEnter()>,0,"{
    setGhostVisibility(View.INVISIBLE);
    mHasStopped = true;
    mIsCanceled = true;
    mResultReceiver = null;
    if (mBackgroundAnimator != null) {
        mBackgroundAnimator.cancel();
        mBackgroundAnimator = null;
    }
    mActivity = null;
    clearState();
    return super.cancelPendingTransitions();
}","{
    setGhostVisibility(View.INVISIBLE);
    mHasStopped = true;
    mIsCanceled = true;
    clearState();
    return super.cancelPendingTransitions();
}",1,"/**
 * Cancels the enter transition.
 * @return True if the enter transition is still pending capturing the target state. If so,
 * any transition started on the decor will do nothing.
 */
","/**
 * Cancels the enter transition.
 * @return True if the enter transition is still pending capturing the target state. If so,
 * any transition started on the decor will do nothing.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change includes the deletion of 'mResultReceiver = null;', 'if (mBackgroundAnimator != null) { mBackgroundAnimator.cancel(); mBackgroundAnimator = null; }', and 'mActivity = null;'. Since these statements do not affect the return value or exception handling of the method, this change is classified as an 'Other statement changed,' which is 4.","No Compatibility Issue arises because the changes made do not affect the return value of the method (it always calls and returns the result of super.cancelPendingTransitions()) and do not alter exception handling. Thus, the behavior of the API in terms of what it returns and exceptions thrown has remained consistent between versions. The CI type is 0."
1184,"<android.content.res.TypedArray: float getDimension(int,float)>",23,24,"<android.content.res.TypedArray: float getDimension(int,float)>","<android.content.res.TypedArray: float getDimension(int,float)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The code change involves the introduction of a new variable `attrIndex` and a modification in the usage of `index` in the parameter of `getValueAt()` method. There is also a change in the string message inside the UnsupportedOperationException thrown at the end of the method. These changes are types 3 (there are changes in the way that control dependency is evaluated because of the local variable assignment) and 4 (because of the change in the message string).,"Despite the changes, there's no evidence that these alterations would lead to a potential Compatibility Issue, because they do not affect the type or value of what is returned by the method, nor do they introduce different exception handling behavior in the ways that would affect the outcome of method invocations. The updated string in the exception only provides more detailed information compared to the early version but does not change the exception being thrown."
1185,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",23,24,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>","<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",0,"{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, null, getUserId(), null);
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, null, getUserId(), null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing rethrowFromSystemServer, so the change type is 2.","Since the exception handling mechanism has been altered, this could potentially lead to a different exception being thrown under the same circumstances, causing a different behavior in the error handling of client code. Therefore, the CI type is 2."
1186,<android.os.UserManager: boolean isUserRunning(UserHandle)>,23,24,<android.os.UserManager: boolean isUserRunning(UserHandle)>,<android.os.UserManager: boolean isUserRunning(UserHandle)>,0,"{
    try {
        return ActivityManagerNative.getDefault().isUserRunning(user.getIdentifier(), false);
    } catch (RemoteException e) {
        return false;
    }
}","{
    return isUserRunning(user.getIdentifier());
}",1,"/**
 * Return whether the given user is actively running.  This means that
 * the user is in the ""started"" state, not ""stopped"" -- it is currently
 * allowed to run code through scheduled alarms, receiving broadcasts,
 * etc.  A started user may be either the current foreground user or a
 * background user; the result here does not distinguish between the two.
 * @param user The user to retrieve the running state for.
 */
","/**
 * Return whether the given user is actively running.  This means that
 * the user is in the ""started"" state, not ""stopped"" -- it is currently
 * allowed to run code through scheduled alarms, receiving broadcasts,
 * etc.  A started user may be either the current foreground user or a
 * background user; the result here does not distinguish between the two.
 * @param user The user to retrieve the running state for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has shifted from using ActivityManagerNative.getDefault().isUserRunning(user.getIdentifier(), false) to a direct call to isUserRunning(user.getIdentifier()), removing the RemoteException handling. Therefore, the change types are 1 (for the removal of exception handling) and 5 (for a change in a dependent API).","Given that the error handling for RemoteException has been removed, and now another method is directly called, there is a potential CI. If the new implementation of isUserRunning(int) doesn't handle RemoteExceptions, it could result in an unchecked exception being thrown to callers, who might not be prepared for it. This constitutes a CI of type 1."
1187,<android.app.Notification.Builder: Builder setStyle(Style)>,23,24,<android.app.Notification.Builder: Builder setStyle(Style)>,<android.app.Notification.Builder: Builder setStyle(Style)>,0,"{
    if (mStyle != style) {
        mStyle = style;
        if (mStyle != null) {
            mStyle.setBuilder(this);
        }
    }
    return this;
}","{
    if (mStyle != style) {
        mStyle = style;
        if (mStyle != null) {
            mStyle.setBuilder(this);
            mN.extras.putString(EXTRA_TEMPLATE, style.getClass().getName());
        } else {
            mN.extras.remove(EXTRA_TEMPLATE);
        }
    }
    return this;
}",1,"/**
 * Add a rich notification style to be applied at build time.
 *
 * @param style Object responsible for modifying the notification style.
 */
","/**
 * Add a rich notification style to be applied at build time.
 *
 * @param style Object responsible for modifying the notification style.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late implementation introduces a condition to check if 'mStyle' is null and updates 'mN.extras' accordingly, which are statements outside of any return or exception statements, so the code change type is 4.","There's no Compatibility Issue noted as the return value of the method ('this', referring to the Builder itself) and the method signature remain unchanged. The addition of setting or removing an extra does not affect the return type or value or the exception handling of the method. Hence, the behavior in terms of API contract concerning return values and exceptions remains the same."
1189,"<android.content.res.Resources: int getIdentifier(String,String,String)>",23,24,"<android.content.res.Resources: int getIdentifier(String,String,String)>","<android.content.res.Resources: int getIdentifier(String,String,String)>",0,"{
    if (name == null) {
        throw new NullPointerException(""name is null"");
    }
    try {
        return Integer.parseInt(name);
    } catch (Exception e) {
    // Ignore
    }
    return mAssets.getResourceIdentifier(name, defType, defPackage);
}","{
    return mResourcesImpl.getIdentifier(name, defType, defPackage);
}",1,"/**
 * Return a resource identifier for the given resource name.  A fully
 * qualified resource name is of the form ""package:type/entry"".  The first
 * two components (package and type) are optional if defType and
 * defPackage, respectively, are specified here.
 *
 * <p>Note: use of this function is discouraged.  It is much more
 * efficient to retrieve resources by identifier than by name.
 *
 * @param name The name of the desired resource.
 * @param defType Optional default resource type to find, if ""type/"" is
 * not included in the name.  Can be null to require an
 * explicit type.
 * @param defPackage Optional default package to find, if ""package:"" is
 * not included in the name.  Can be null to require an
 * explicit package.
 *
 * @return int The associated resource identifier.  Returns 0 if no such
 * resource was found.  (0 is not a valid resource ID.)
 */
","/**
 * Return a resource identifier for the given resource name.  A fully
 * qualified resource name is of the form ""package:type/entry"".  The first
 * two components (package and type) are optional if defType and
 * defPackage, respectively, are specified here.
 *
 * <p>Note: use of this function is discouraged.  It is much more
 * efficient to retrieve resources by identifier than by name.
 *
 * @param name The name of the desired resource.
 * @param defType Optional default resource type to find, if ""type/"" is
 * not included in the name.  Can be null to require an
 * explicit type.
 * @param defPackage Optional default package to find, if ""package:"" is
 * not included in the name.  Can be null to require an
 * explicit package.
 *
 * @return int The associated resource identifier.  Returns 0 if no such
 * resource was found.  (0 is not a valid resource ID.)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The early implementation attempts to parse an integer from the name, and if it fails, it falls back to mAssets.getResourceIdentifier(). In contrast, the late implementation directly calls mResourcesImpl.getIdentifier(). The whole try-catch block has been removed, and the method called for getting the identifier has changed, resulting in code change types 1,4,5.","Since the early version may return the result of Integer.parseInt(name) and has exception handling for any Exception, while the late version does not, this could potentially lead to both varying returned values (type 1) as well as different exception handling (type 2), thus both CI types 1 and 2 are applicable."
1191,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",23,24,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>","<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",0,"{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    activity.attach(context, aThread, this, token, 0, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, null);
    return activity;
}","{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    activity.attach(context, aThread, this, token, 0, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, null, null);
    return activity;
}",1,"/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the sytem.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
","/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the sytem.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"An additional null parameter is passed to the 'activity.attach' method. This means that the signature of the 'attach' method called has changed, which indicates a change in a dependent API. Therefore, the code change type is 5.","Since there is no observable change in the behavior of 'newActivity' method itself (it still creates an instance and attaches it in the same way from the perspective of this method's contract), there are no compatibility issues from this change. Hence, the CI type is 0."
1192,"<android.service.chooser.ChooserTargetService.IChooserTargetServiceWrapper: void getChooserTargets(ComponentName,IntentFilter,IChooserTargetResult)>",23,24,"<android.service.chooser.ChooserTargetService.IChooserTargetServiceWrapper: void getChooserTargets(ComponentName,IntentFilter,IChooserTargetResult)>","<android.service.chooser.ChooserTargetService.IChooserTargetServiceWrapper: void getChooserTargets(ComponentName,IntentFilter,IChooserTargetResult)>",0,"{
    List<ChooserTarget> targets = null;
    try {
        if (DEBUG) {
            Log.d(TAG, ""getChooserTargets calling onGetChooserTargets; "" + targetComponentName + "" filter: "" + matchedFilter);
        }
        targets = onGetChooserTargets(targetComponentName, matchedFilter);
    } finally {
        result.sendResult(targets);
        if (DEBUG)
            Log.d(TAG, ""Sent results"");
    }
}","{
    List<ChooserTarget> targets = null;
    final long id = clearCallingIdentity();
    try {
        if (DEBUG) {
            Log.d(TAG, ""getChooserTargets calling onGetChooserTargets; "" + targetComponentName + "" filter: "" + matchedFilter);
        }
        targets = onGetChooserTargets(targetComponentName, matchedFilter);
    } finally {
        restoreCallingIdentity(id);
        result.sendResult(targets);
        if (DEBUG)
            Log.d(TAG, ""Sent results"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes the additions of `final long id = clearCallingIdentity();` and `restoreCallingIdentity(id);` wrapped in a try-finally block which changes the sequence of method calls and the control flow, and thus the code change types are 3 (Control dependency changed) and 4 (Other statement changed).","These changes do not affect the method's return type or the values it returns, and they don't change the exception handling. Instead, they alter the calling identity of the IPC (inter-process communication), ensuring that the subsequent operations in the try block are done with the identity of the service itself rather than the identity of the calling process. Since the values sent by `result.sendResult(targets);` would remain the same irrespective of the calling identity, and exceptions are handled as they were before (no exception-specific code changed), there is no compatibility issue, therefore the CI type is 0."
1193,"<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>",23,24,"<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>","<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>",0,"{
    try {
        mService.showMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        mService.showMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Show the input method's soft input area, so the user
 * sees the input method window and can interact with it.
 * This can only be called from the currently active input method,
 * as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} or
 * {@link #SHOW_FORCED} bit set.
 */
","/**
 * Show the input method's soft input area, so the user
 * sees the input method window and can interact with it.
 * This can only be called from the currently active input method,
 * as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} or
 * {@link #SHOW_FORCED} bit set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing a rethrow from the system server, so the code change type is 2.","Since the method now throws a different exception in case of a RemoteException, this could lead to different exception handling behavior in code that uses this API. Therefore, the CI type is 2."
1194,<android.print.PrintJobInfo: String toString()>,23,24,<android.print.PrintJobInfo: String toString()>,<android.print.PrintJobInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrintJobInfo{"");
    builder.append(""label: "").append(mLabel);
    builder.append("", id: "").append(mId);
    builder.append("", state: "").append(stateToString(mState));
    builder.append("", printer: "" + mPrinterId);
    builder.append("", tag: "").append(mTag);
    builder.append("", creationTime: "" + mCreationTime);
    builder.append("", copies: "").append(mCopies);
    builder.append("", attributes: "" + (mAttributes != null ? mAttributes.toString() : null));
    builder.append("", documentInfo: "" + (mDocumentInfo != null ? mDocumentInfo.toString() : null));
    builder.append("", cancelling: "" + mCanceling);
    builder.append("", pages: "" + (mPageRanges != null ? Arrays.toString(mPageRanges) : null));
    builder.append("", hasAdvancedOptions: "" + (mAdvancedOptions != null));
    builder.append(""}"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrintJobInfo{"");
    builder.append(""label: "").append(mLabel);
    builder.append("", id: "").append(mId);
    builder.append("", state: "").append(stateToString(mState));
    builder.append("", printer: "" + mPrinterId);
    builder.append("", tag: "").append(mTag);
    builder.append("", creationTime: "" + mCreationTime);
    builder.append("", copies: "").append(mCopies);
    builder.append("", attributes: "" + (mAttributes != null ? mAttributes.toString() : null));
    builder.append("", documentInfo: "" + (mDocumentInfo != null ? mDocumentInfo.toString() : null));
    builder.append("", cancelling: "" + mCanceling);
    builder.append("", pages: "" + (mPageRanges != null ? Arrays.toString(mPageRanges) : null));
    builder.append("", hasAdvancedOptions: "" + (mAdvancedOptions != null));
    builder.append("", progress: "" + mProgress);
    builder.append("", status: "" + (mStatus != null ? mStatus.toString() : null));
    builder.append("", statusRes: "" + mStatusRes);
    builder.append("", statusResAppPackageName: "" + (mStatusResAppPackageName != null ? mStatusResAppPackageName.toString() : null));
    builder.append(""}"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation of the method adds new fields to the string builder, such as `progress`, `status`, `statusRes`, and `statusResAppPackageName`, making changes in the return statement when building the string, so the code change types are 1 and 4.","The addition of new fields to the string representation of the object implies that the return value of `toString()` will be different. It has a potential to return different values, thus causing a compatibility issue of type 1."
1195,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",23,24,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>","<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (isEnabled()) {
        int increment = mKeyProgressIncrement;
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
                increment = -increment;
            // fallthrough
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                increment = isLayoutRtl() ? -increment : increment;
                // Let progress bar handle clamping values.
                if (setProgress(getProgress() + increment, true)) {
                    onKeyChange();
                    return true;
                }
                break;
        }
    }
    return super.onKeyDown(keyCode, event);
}","{
    if (isEnabled()) {
        int increment = mKeyProgressIncrement;
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_MINUS:
                increment = -increment;
            // fallthrough
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_PLUS:
            case KeyEvent.KEYCODE_EQUALS:
                increment = isLayoutRtl() ? -increment : increment;
                if (setProgressInternal(getProgress() + increment, true, true)) {
                    onKeyChange();
                    return true;
                }
                break;
        }
    }
    return super.onKeyDown(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The switch case checks for additional KeyEvent cases (KEYCODE_MINUS, KEYCODE_PLUS, KEYCODE_EQUALS) and the method used inside the switch (setProgressInternal instead of setProgress, with an additional boolean argument) has changed. Therefore, there is a return statement change, control dependency change due to the additional switch cases, and a dependent API change because of the change in the method being used.","The API could now potentially return true for key events that it would not have previously (KEYCODE_MINUS, KEYCODE_PLUS, KEYCODE_EQUALS), and also the change in the method `setProgress` to `setProgressInternal` with a different signature could potentially alter the behavior of the method. Therefore, the CI type is 1."
1196,<android.app.admin.DevicePolicyManager: boolean getAutoTimeRequired()>,23,24,<android.app.admin.DevicePolicyManager: boolean getAutoTimeRequired()>,<android.app.admin.DevicePolicyManager: boolean getAutoTimeRequired()>,0,"{
    if (mService != null) {
        try {
            return mService.getAutoTimeRequired();
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    throwIfParentInstance(""getAutoTimeRequired"");
    if (mService != null) {
        try {
            return mService.getAutoTimeRequired();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * @return true if auto time is required.
 */
","/**
 * @return true if auto time is required.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The early version of the method logs the exception and returns false in case of a RemoteException, while the late version adds a new method call to throwIfParentInstance(""getAutoTimeRequired"") at the beginning and also the exception handling has changed to throw the exception instead of logging it. Therefore, the code change type is 2,4 due to the introduction of a new other statement (throwIfParentInstance call) and a change in the exception handling statement.","As the late version of the method throws an exception instead of just logging it when a RemoteException occurs, it can cause the method to behave differently and result in an unhandled exception propagating to the caller which is a compatibility issue. Thus, the CI type is 2."
1197,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolation(ViolationInfo)>,23,24,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolation(ViolationInfo)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolation(ViolationInfo)>,0,"{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, ""unexpected null stacktrace"");
        return;
    }
    if (LOG_V)
        Log.d(TAG, ""handleViolation; policy="" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        } else if (violations.size() >= 5) {
            // Too many.  In a loop or something?  Don't gather them all.
            return;
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<Integer, Long>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, ""StrictMode policy violation; ~duration="" + info.durationMillis + "" ms: "" + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, ""StrictMode policy violation: "" + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            Log.e(TAG, ""RemoteException trying to handle StrictMode violation"", e);
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}","{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, ""unexpected null stacktrace"");
        return;
    }
    if (LOG_V)
        Log.d(TAG, ""handleViolation; policy="" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        } else if (violations.size() >= 5) {
            // Too many.  In a loop or something?  Don't gather them all.
            return;
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<Integer, Long>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, ""StrictMode policy violation; ~duration="" + info.durationMillis + "" ms: "" + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, ""StrictMode policy violation: "" + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            if (e instanceof DeadObjectException) {
            // System process is dead; ignore
            } else {
                Log.e(TAG, ""RemoteException trying to handle StrictMode violation"", e);
            }
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}",1,"// hence the policy being passed around.
","// hence the policy being passed around.
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1198,<android.content.res.TypedArray: void recycle()>,23,24,<android.content.res.TypedArray: void recycle()>,<android.content.res.TypedArray: void recycle()>,0,"{
    if (mRecycled) {
        throw new RuntimeException(toString() + "" recycled twice!"");
    }
    mRecycled = true;
    // These may have been set by the client.
    mXml = null;
    mTheme = null;
    mResources.mTypedArrayPool.release(this);
}","{
    if (mRecycled) {
        throw new RuntimeException(toString() + "" recycled twice!"");
    }
    mRecycled = true;
    // These may have been set by the client.
    mXml = null;
    mTheme = null;
    mAssets = null;
    mResources.mTypedArrayPool.release(this);
}",1,"/**
 * Recycles the TypedArray, to be re-used by a later caller. After calling
 * this function you must not ever touch the typed array again.
 *
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
","/**
 * Recycles the TypedArray, to be re-used by a later caller. After calling
 * this function you must not ever touch the typed array again.
 *
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the addition of the line `mAssets = null;`. This change falls under the category of an 'Other statement changed', so the code change type is 4.","Setting `mAssets` to null does not affect the return value or throw a new type of exception as it does not influence the control flow or exception handling of the method. Therefore, no compatibility issue arises with respect to this code change. The CI type is 0."
1200,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>",23,24,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>",0,"{
    if (DEBUG) {
        Log.d(TAG, String.format(""Device error received, code %d, frame number %d, request ID %d, subseq ID %d"", errorCode, resultExtras.getFrameNumber(), resultExtras.getRequestId(), resultExtras.getSubsequenceId()));
    }
    synchronized (mInterfaceLock) {
        if (mRemoteDevice == null) {
            // Camera already closed
            return;
        }
        switch(errorCode) {
            case ERROR_CAMERA_DISCONNECTED:
                CameraDeviceImpl.this.mDeviceHandler.post(mCallOnDisconnected);
                break;
            default:
                Log.e(TAG, ""Unknown error from camera device: "" + errorCode);
            // no break
            case ERROR_CAMERA_DEVICE:
            case ERROR_CAMERA_SERVICE:
                mInError = true;
                Runnable r = new Runnable() {

                    @Override
                    public void run() {
                        if (!CameraDeviceImpl.this.isClosed()) {
                            mDeviceCallback.onError(CameraDeviceImpl.this, errorCode);
                        }
                    }
                };
                CameraDeviceImpl.this.mDeviceHandler.post(r);
                break;
            case ERROR_CAMERA_REQUEST:
            case ERROR_CAMERA_RESULT:
            case ERROR_CAMERA_BUFFER:
                onCaptureErrorLocked(errorCode, resultExtras);
                break;
        }
    }
}","{
    if (DEBUG) {
        Log.d(TAG, String.format(""Device error received, code %d, frame number %d, request ID %d, subseq ID %d"", errorCode, resultExtras.getFrameNumber(), resultExtras.getRequestId(), resultExtras.getSubsequenceId()));
    }
    synchronized (mInterfaceLock) {
        if (mRemoteDevice == null) {
            // Camera already closed
            return;
        }
        switch(errorCode) {
            case ERROR_CAMERA_DISCONNECTED:
                CameraDeviceImpl.this.mDeviceHandler.post(mCallOnDisconnected);
                break;
            default:
                Log.e(TAG, ""Unknown error from camera device: "" + errorCode);
            // no break
            case ERROR_CAMERA_DEVICE:
            case ERROR_CAMERA_SERVICE:
                mInError = true;
                final int publicErrorCode = (errorCode == ERROR_CAMERA_DEVICE) ? StateCallback.ERROR_CAMERA_DEVICE : StateCallback.ERROR_CAMERA_SERVICE;
                Runnable r = new Runnable() {

                    @Override
                    public void run() {
                        if (!CameraDeviceImpl.this.isClosed()) {
                            mDeviceCallback.onError(CameraDeviceImpl.this, publicErrorCode);
                        }
                    }
                };
                CameraDeviceImpl.this.mDeviceHandler.post(r);
                break;
            case ERROR_CAMERA_REQUEST:
            case ERROR_CAMERA_RESULT:
            case ERROR_CAMERA_BUFFER:
                onCaptureErrorLocked(errorCode, resultExtras);
                break;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change between early and late versions is the introduction of the 'publicErrorCode' variable and the assignment of a value to it based on a condition. This doesn't change the overall control flow or the type of exceptions thrown. Therefore, the change is classified as 4.","There's no Compatibility Issue as the changes made do not affect the return value or the exceptions thrown by the method. The behavior of the 'onError' callback still gets invoked with an error code, and the handling of this error code remains internal to the method without affecting the external behavior observed by the callers of the method."
1201,<android.hardware.radio.RadioManager.FmBandConfig: int hashCode()>,23,24,<android.hardware.radio.RadioManager.FmBandConfig: int hashCode()>,<android.hardware.radio.RadioManager.FmBandConfig: int hashCode()>,0,"{
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + (mStereo ? 1 : 0);
    result = prime * result + (mRds ? 1 : 0);
    result = prime * result + (mTa ? 1 : 0);
    result = prime * result + (mAf ? 1 : 0);
    return result;
}","{
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + (mStereo ? 1 : 0);
    result = prime * result + (mRds ? 1 : 0);
    result = prime * result + (mTa ? 1 : 0);
    result = prime * result + (mAf ? 1 : 0);
    result = prime * result + (mEa ? 1 : 0);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There is an additional line in the Late_Implementation that includes a term involving `mEa`. Since this line was not present in the Early_Implementation, the change type is 4, because of an additional statement that is not a control or exception handling statement.","The introduction of a new term in the calculation of the result affects the return value of the hashCode() method. Assuming `mEa` is a class member variable that didn't exist or wasn't taken into account in the previous method version, this could lead to a different hash code being returned for objects with differing `mEa` values. Thus, the CI type due to a possibility of a different return value is 1."
1202,<android.content.ClipboardManager: void removePrimaryClipChangedListener(OnPrimaryClipChangedListener)>,23,24,<android.content.ClipboardManager: void removePrimaryClipChangedListener(OnPrimaryClipChangedListener)>,<android.content.ClipboardManager: void removePrimaryClipChangedListener(OnPrimaryClipChangedListener)>,0,"{
    synchronized (mPrimaryClipChangedListeners) {
        mPrimaryClipChangedListeners.remove(what);
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().removePrimaryClipChangedListener(mPrimaryClipChangedServiceListener);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    synchronized (mPrimaryClipChangedListeners) {
        mPrimaryClipChangedListeners.remove(what);
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().removePrimaryClipChangedListener(mPrimaryClipChangedServiceListener);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, the newer version introduces a 'throw' statement inside the 'catch' block, which the earlier version does not have.","Due to the added 'throw' statement inside the 'catch' block, the newer API could potentially propagate an exception upwards, while the earlier version suppresses all RemoteExceptions. This change indicates a potential CI due to different exception handling, hence the CI type is 2."
1203,<android.app.Notification.Builder: Builder setWhen(long)>,23,24,<android.app.Notification.Builder: Builder setWhen(long)>,<android.app.Notification.Builder: Builder setWhen(long)>,0,"{
    mWhen = when;
    return this;
}","{
    mN.when = when;
    return this;
}",1,"/**
 * Add a timestamp pertaining to the notification (usually the time the event occurred).
 * It will be shown in the notification content view by default; use
 * {@link #setShowWhen(boolean) setShowWhen} to control this.
 *
 * @see Notification#when
 */
","/**
 * Add a timestamp pertaining to the notification (usually the time the event occurred).
 *
 * For apps targeting {@link android.os.Build.VERSION_CODES#N} and above, this time is not
 * shown anymore by default and must be opted into by using
 * {@link android.app.Notification.Builder#setShowWhen(boolean)}
 *
 * @see Notification#when
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the field that is being set; instead of directly setting the 'mWhen' field, the new version sets 'mN.when'. This is a field access change within the object, which falls under the 'Other statement changed' category.","Despite the internal field access change, there is no indication that there would be a different behavior in terms of the API's functionality. Both implementations assign the provided 'when' value to a field and return 'this'. There would be no compatibility issue as long as the 'mN' object's 'when' field is equivalent to the 'mWhen' field in the early version. Thus, this change is unlikely to cause a compatibility issue based on the provided information."
1204,<android.content.pm.PackageInstaller: SessionInfo getSessionInfo(int)>,23,24,<android.content.pm.PackageInstaller: SessionInfo getSessionInfo(int)>,<android.content.pm.PackageInstaller: SessionInfo getSessionInfo(int)>,0,"{
    try {
        return mInstaller.getSessionInfo(sessionId);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        return mInstaller.getSessionInfo(sessionId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return details for a specific session. No special permissions are
 * required to retrieve these details.
 *
 * @return details for the requested session, or {@code null} if the session
 * does not exist.
 */
","/**
 * Return details for a specific session. No special permissions are
 * required to retrieve these details.
 *
 * @return details for the requested session, or {@code null} if the session
 * does not exist.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from throw e.rethrowAsRuntimeException() to throw e.rethrowFromSystemServer(), so the change type is 2.","The changed exception handling code could cause a different exception to be thrown, which can affect how callers need to handle exceptions from this API. Therefore, the CI type is 2."
1205,"<android.os.Bundle: void writeToParcel(Parcel,int)>",23,24,"<android.os.Bundle: void writeToParcel(Parcel,int)>","<android.os.Bundle: void writeToParcel(Parcel,int)>",0,"{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        super.writeToParcelInner(parcel, flags);
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}","{
    final boolean oldAllowFds = parcel.pushAllowFds((mFlags & FLAG_ALLOW_FDS) != 0);
    try {
        super.writeToParcelInner(parcel, flags);
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The way 'oldAllowFds' is being set has changed by using a new bit flag check (mFlags & FLAG_ALLOW_FDS) != 0 instead of directly using the mAllowFds field. However, because this change modifies a local variable initialisation without affecting control flow or method contract, it is classified under ""Other statement changed"" type 4.","There is no indication that the modified local variable initialisation would lead to a different behavior visible to the API consumer. The change does not affect the outward behavior of the method in terms of different return types/values or exception handling; it merely alters an implementation detail under the assumption that 'mFlags' correctly represents the state previously held by 'mAllowFds'. Therefore, there is no Compatibility Issue, which is indicated by 0."
1207,<android.service.voice.VoiceInteractionSession: void startVoiceActivity(Intent)>,23,24,<android.service.voice.VoiceInteractionSession: void startVoiceActivity(Intent)>,<android.service.voice.VoiceInteractionSession: void startVoiceActivity(Intent)>,0,"{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        int res = mSystemService.startVoiceActivity(mToken, intent, intent.resolveType(mContext.getContentResolver()));
        Instrumentation.checkStartActivityResult(res, intent);
    } catch (RemoteException e) {
    }
}","{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(mContext);
        int res = mSystemService.startVoiceActivity(mToken, intent, intent.resolveType(mContext.getContentResolver()));
        Instrumentation.checkStartActivityResult(res, intent);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Ask that a new activity be started for voice interaction.  This will create a
 * new dedicated task in the activity manager for this voice interaction session;
 * this means that {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK}
 * will be set for you to make it a new task.
 *
 * <p>The newly started activity will be displayed to the user in a special way, as
 * a layer under the voice interaction UI.</p>
 *
 * <p>As the voice activity runs, it can retrieve a {@link android.app.VoiceInteractor}
 * through which it can perform voice interactions through your session.  These requests
 * for voice interactions will appear as callbacks on {@link #onGetSupportedCommands},
 * {@link #onRequestConfirmation}, {@link #onRequestPickOption},
 * {@link #onRequestCompleteVoice}, {@link #onRequestAbortVoice},
 * or {@link #onRequestCommand}
 *
 * <p>You will receive a call to {@link #onTaskStarted} when the task starts up
 * and {@link #onTaskFinished} when the last activity has finished.
 *
 * @param intent The Intent to start this voice interaction.  The given Intent will
 * always have {@link Intent#CATEGORY_VOICE Intent.CATEGORY_VOICE} added to it, since
 * this is part of a voice interaction.
 */
","/**
 * Ask that a new activity be started for voice interaction.  This will create a
 * new dedicated task in the activity manager for this voice interaction session;
 * this means that {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK}
 * will be set for you to make it a new task.
 *
 * <p>The newly started activity will be displayed to the user in a special way, as
 * a layer under the voice interaction UI.</p>
 *
 * <p>As the voice activity runs, it can retrieve a {@link android.app.VoiceInteractor}
 * through which it can perform voice interactions through your session.  These requests
 * for voice interactions will appear as callbacks on {@link #onGetSupportedCommands},
 * {@link #onRequestConfirmation}, {@link #onRequestPickOption},
 * {@link #onRequestCompleteVoice}, {@link #onRequestAbortVoice},
 * or {@link #onRequestCommand}
 *
 * <p>You will receive a call to {@link #onTaskStarted} when the task starts up
 * and {@link #onTaskFinished} when the last activity has finished.
 *
 * @param intent The Intent to start this voice interaction.  The given Intent will
 * always have {@link Intent#CATEGORY_VOICE Intent.CATEGORY_VOICE} added to it, since
 * this is part of a voice interaction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is observed in the 'intent.prepareToLeaveProcess();' method call, where in the late version 'mContext' is passed as an argument (intent.prepareToLeaveProcess(mContext);). This indicates a change in the code related to a dependent API (prepareToLeaveProcess), so the code change is 4,5.","Even though there is a change in a method call argument to `prepareToLeaveProcess`, which could be a dependent API change, there is no indication that this change leads to different return values or types, and exceptions are still caught and not re-thrown or handled differently. Therefore, there is no compatibility issue expected based on provided information, and the CI type is 0."
1209,<android.animation.AnimatorSet: boolean isRunning()>,23,24,<android.animation.AnimatorSet: boolean isRunning()>,<android.animation.AnimatorSet: boolean isRunning()>,0,"{
    for (Node node : mNodes) {
        if (node.animation.isRunning()) {
            return true;
        }
    }
    return false;
}","{
    int size = mNodes.size();
    for (int i = 0; i < size; i++) {
        Node node = mNodes.get(i);
        if (node != mRootNode && node.mAnimation.isStarted()) {
            return true;
        }
    }
    return false;
}",1,"/**
 * Returns true if any of the child animations of this AnimatorSet have been started and have
 * not yet ended.
 * @return Whether this AnimatorSet has been started and has not yet ended.
 */
","/**
 * Returns true if any of the child animations of this AnimatorSet have been started and have
 * not yet ended. Child animations will not be started until the AnimatorSet has gone past
 * its initial delay set through {@link #setStartDelay(long)}.
 *
 * @return Whether this AnimatorSet has gone past the initial delay, and at least one child
 * animation has been started and not yet ended.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method of iteration over `mNodes` is changed from an enhanced for loop to an indexed for loop. The check condition within the loop is also altered from `node.animation.isRunning()` to `node != mRootNode && node.mAnimation.isStarted()`. Finally, the method called on the node's animation object changed from `isRunning()` to `isStarted()`, and a null check `node != mRootNode` has been added. ",
1210,<android.widget.AccessibilityIterators.PageTextSegmentIterator: int[] following(int)>,23,24,<android.widget.AccessibilityIterators.PageTextSegmentIterator: int[] following(int)>,<android.widget.AccessibilityIterators.PageTextSegmentIterator: int[] following(int)>,0,"{
    final int textLegth = mText.length();
    if (textLegth <= 0) {
        return null;
    }
    if (offset >= mText.length()) {
        return null;
    }
    if (!mView.getGlobalVisibleRect(mTempRect)) {
        return null;
    }
    final int start = Math.max(0, offset);
    final int currentLine = mLayout.getLineForOffset(start);
    final int currentLineTop = mLayout.getLineTop(currentLine);
    final int pageHeight = mTempRect.height() - mView.getTotalPaddingTop() - mView.getTotalPaddingBottom();
    final int nextPageStartY = currentLineTop + pageHeight;
    final int lastLineTop = mLayout.getLineTop(mLayout.getLineCount() - 1);
    final int currentPageEndLine = (nextPageStartY < lastLineTop) ? mLayout.getLineForVertical(nextPageStartY) - 1 : mLayout.getLineCount() - 1;
    final int end = getLineEdgeIndex(currentPageEndLine, DIRECTION_END) + 1;
    return getRange(start, end);
}","{
    final int textLength = mText.length();
    if (textLength <= 0) {
        return null;
    }
    if (offset >= mText.length()) {
        return null;
    }
    if (!mView.getGlobalVisibleRect(mTempRect)) {
        return null;
    }
    final int start = Math.max(0, offset);
    final int currentLine = mLayout.getLineForOffset(start);
    final int currentLineTop = mLayout.getLineTop(currentLine);
    final int pageHeight = mTempRect.height() - mView.getTotalPaddingTop() - mView.getTotalPaddingBottom();
    final int nextPageStartY = currentLineTop + pageHeight;
    final int lastLineTop = mLayout.getLineTop(mLayout.getLineCount() - 1);
    final int currentPageEndLine = (nextPageStartY < lastLineTop) ? mLayout.getLineForVertical(nextPageStartY) - 1 : mLayout.getLineCount() - 1;
    final int end = getLineEdgeIndex(currentPageEndLine, DIRECTION_END) + 1;
    return getRange(start, end);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no changes between the early version and late version of the implementation, just a change in the local variable name from `textLegth` to `textLength`, which does not affect the method's functionality.",No Compatibility Issue arises as there are no functional changes in the method's implementation between the two versions.
1212,<android.content.pm.PackageInstaller: void abandonSession(int)>,23,24,<android.content.pm.PackageInstaller: void abandonSession(int)>,<android.content.pm.PackageInstaller: void abandonSession(int)>,0,"{
    try {
        mInstaller.abandonSession(sessionId);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        mInstaller.abandonSession(sessionId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Completely abandon the given session, destroying all staged data and
 * rendering it invalid. Abandoned sessions will be reported to
 * {@link SessionCallback} listeners as failures. This is equivalent to
 * opening the session and calling {@link Session#abandon()}.
 *
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
","/**
 * Completely abandon the given session, destroying all staged data and
 * rendering it invalid. Abandoned sessions will be reported to
 * {@link SessionCallback} listeners as failures. This is equivalent to
 * opening the session and calling {@link Session#abandon()}.
 *
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The catch block changes what is done with the RemoteException; from `rethrowAsRuntimeException()` to `rethrowFromSystemServer()`, so the change type is 2.","The method now throws a different type of exception due to the change in exception handling, which means the API would behave differently in terms of exception handling in the newer version, leading to CI type 2."
1214,<android.app.Notification.Style: RemoteViews getStandardView(int)>,23,24,<android.app.Notification.Style: RemoteViews getStandardView(int)>,<android.app.Notification.Style: RemoteViews getStandardView(int)>,0,"{
    checkBuilder();
    // Nasty.
    CharSequence oldBuilderContentTitle = mBuilder.mContentTitle;
    if (mBigContentTitle != null) {
        mBuilder.setContentTitle(mBigContentTitle);
    }
    RemoteViews contentView = mBuilder.applyStandardTemplateWithActions(layoutId);
    mBuilder.mContentTitle = oldBuilderContentTitle;
    if (mBigContentTitle != null && mBigContentTitle.equals("""")) {
        contentView.setViewVisibility(R.id.line1, View.GONE);
    } else {
        contentView.setViewVisibility(R.id.line1, View.VISIBLE);
    }
    // The last line defaults to the subtext, but can be replaced by mSummaryText
    final CharSequence overflowText = mSummaryTextSet ? mSummaryText : mBuilder.mSubText;
    if (overflowText != null) {
        contentView.setTextViewText(R.id.text, mBuilder.processLegacyText(overflowText));
        contentView.setViewVisibility(R.id.overflow_divider, View.VISIBLE);
        contentView.setViewVisibility(R.id.line3, View.VISIBLE);
    } else {
        // Clear text in case we use the line to show the profile badge.
        contentView.setTextViewText(R.id.text, """");
        contentView.setViewVisibility(R.id.overflow_divider, View.GONE);
        contentView.setViewVisibility(R.id.line3, View.GONE);
    }
    return contentView;
}","{
    checkBuilder();
    // Nasty.
    CharSequence oldBuilderContentTitle = mBuilder.getAllExtras().getCharSequence(EXTRA_TITLE);
    if (mBigContentTitle != null) {
        mBuilder.setContentTitle(mBigContentTitle);
    }
    RemoteViews contentView = mBuilder.applyStandardTemplateWithActions(layoutId);
    mBuilder.getAllExtras().putCharSequence(EXTRA_TITLE, oldBuilderContentTitle);
    if (mBigContentTitle != null && mBigContentTitle.equals("""")) {
        contentView.setViewVisibility(R.id.line1, View.GONE);
    } else {
        contentView.setViewVisibility(R.id.line1, View.VISIBLE);
    }
    return contentView;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"There are changes in the control dependency due to the modification in how 'oldBuilderContentTitle' is assigned and restored, and this might affect the state of 'mBuilder'. The way how 'oldBuilderContentTitle' is assigned and restored changes because now it uses 'mBuilder.getAllExtras().getCharSequence(EXTRA_TITLE)' and 'mBuilder.getAllExtras().putCharSequence(EXTRA_TITLE, oldBuilderContentTitle)' instead of directly accessing 'mBuilder.mContentTitle'. The method also omits the part that modifies 'contentView' visibility based on 'overflowText' and sets 'contentView' text, which is an other statement change (type 4). These changes suggest reliance on a different method of storing extras, which is a dependent API change (type 5).","Since there is a simplification in the code and the parts removed from the late implementation (such as setting text for 'R.id.text', or changing view visibility of 'R.id.overflow_divider' and 'R.id.line3') are not dependent on new conditions or control structures, they will not lead to different return values or exception handlings. Also, the operations removed do not seem to depend on the 'layoutId' parameter or internal states that would affect what 'contentView' is returned. These adjustments appear to be more associated with streamlining or refactoring rather than altering the behavior from an API consumer perspective, and as such, do not introduce a compatibility issue."
1215,<android.app.NotificationManager: void setInterruptionFilter(int)>,23,24,<android.app.NotificationManager: void setInterruptionFilter(int)>,<android.app.NotificationManager: void setInterruptionFilter(int)>,0,"{
    final INotificationManager service = getService();
    try {
        service.setInterruptionFilter(mContext.getOpPackageName(), interruptionFilter);
    } catch (RemoteException e) {
        Log.e(TAG, ""Unable to talk to notification manager. Woe!"", e);
    }
}","{
    final INotificationManager service = getService();
    try {
        service.setInterruptionFilter(mContext.getOpPackageName(), interruptionFilter);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */
","/**
 * Sets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from logging an error to throwing an exception, so the change type is 2.","This change can lead to different exception handling behavior because in the late version, the RemoteException is rethrown, potentially affecting the caller who now needs to handle this exception. Therefore, the CI type is 2."
1216,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",23,24,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData();
        intents[i].prepareToLeaveProcess();
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData();
        intents[i].prepareToLeaveProcess(context);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the method call from `intents[i].prepareToLeaveProcess();` to `intents[i].prepareToLeaveProcess(context);`, which indicates a modification in a dependent API (the `prepareToLeaveProcess` method). Thus, the code change type is 4,5.","The actual change is in a method call which doesn't directly affect the control flow or the return value of the `getActivities` method. Therefore, since there's no indication that the behavior of `intents[i].prepareToLeaveProcess(context)` is different from `intents[i].prepareToLeaveProcess()` in a way that would affect the return value or exception handling of this `getActivities` method, we conclude that there is no Compatibility Issue."
1217,<android.view.DragEvent: DragEvent obtain()>,23,24,<android.view.DragEvent: DragEvent obtain()>,<android.view.DragEvent: DragEvent obtain()>,0,"{
    return DragEvent.obtain(0, 0f, 0f, null, null, null, false);
}","{
    return DragEvent.obtain(0, 0f, 0f, null, null, null, null, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method DragEvent.obtain() now includes an additional 'null' parameter in the late version, indicating a change in the dependent API, so the change type is 5.","There is no Compatibility Issue since the additional 'null' parameter likely accommodates a new attribute in the DragEvent class without altering pre-existing behaviors. Existing code calling obtain() without arguments will still receive a DragEvent with default values, and since obtain() creates a new instance every time it is called, there's no change to the state of any existing objects. Therefore, the CI type is 0."
1221,<android.print.PrinterInfo: boolean equals(Object)>,23,24,<android.print.PrinterInfo: boolean equals(Object)>,<android.print.PrinterInfo: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrinterInfo other = (PrinterInfo) obj;
    if (mId == null) {
        if (other.mId != null) {
            return false;
        }
    } else if (!mId.equals(other.mId)) {
        return false;
    }
    if (!TextUtils.equals(mName, other.mName)) {
        return false;
    }
    if (mStatus != other.mStatus) {
        return false;
    }
    if (!TextUtils.equals(mDescription, other.mDescription)) {
        return false;
    }
    if (mCapabilities == null) {
        if (other.mCapabilities != null) {
            return false;
        }
    } else if (!mCapabilities.equals(other.mCapabilities)) {
        return false;
    }
    return true;
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrinterInfo other = (PrinterInfo) obj;
    if (!equalsIgnoringStatus(other)) {
        return false;
    }
    if (mStatus != other.mStatus) {
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The late version implementation introduces a method call `equalsIgnoringStatus(other)` to encapsulate part of the comparison logic. This is a refactoring that presumably does not alter the behavior of the method as long as `equalsIgnoringStatus` correctly implements the checks that it replaces.,"Assuming `equalsIgnoringStatus` performs the same checks as the inlined code it replaced, there should be no compatibility issues, as the behavior of `equals` would not change. The refactored method should still return the same boolean result for a given input, and this operation doesn't introduce potential for new exceptions to be thrown or caught differently. Thus, there should be no compatibility issue (CI type 0)."
1222,"<android.widget.PopupWindow: void update(int,int,int,int,boolean)>",23,24,"<android.widget.PopupWindow: void update(int,int,int,int,boolean)>","<android.widget.PopupWindow: void update(int,int,int,int,boolean)>",0,"{
    if (width >= 0) {
        mLastWidth = width;
        setWidth(width);
    }
    if (height >= 0) {
        mLastHeight = height;
        setHeight(height);
    }
    if (!isShowing() || mContentView == null) {
        return;
    }
    final WindowManager.LayoutParams p = (WindowManager.LayoutParams) mDecorView.getLayoutParams();
    boolean update = force;
    final int finalWidth = mWidthMode < 0 ? mWidthMode : mLastWidth;
    if (width != -1 && p.width != finalWidth) {
        p.width = mLastWidth = finalWidth;
        update = true;
    }
    final int finalHeight = mHeightMode < 0 ? mHeightMode : mLastHeight;
    if (height != -1 && p.height != finalHeight) {
        p.height = mLastHeight = finalHeight;
        update = true;
    }
    if (p.x != x) {
        p.x = x;
        update = true;
    }
    if (p.y != y) {
        p.y = y;
        update = true;
    }
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mDecorView, p);
    }
}","{
    if (width >= 0) {
        mLastWidth = width;
        setWidth(width);
    }
    if (height >= 0) {
        mLastHeight = height;
        setHeight(height);
    }
    if (!isShowing() || mContentView == null) {
        return;
    }
    final WindowManager.LayoutParams p = (WindowManager.LayoutParams) mDecorView.getLayoutParams();
    boolean update = force;
    final int finalWidth = mWidthMode < 0 ? mWidthMode : mLastWidth;
    if (width != -1 && p.width != finalWidth) {
        p.width = mLastWidth = finalWidth;
        update = true;
    }
    final int finalHeight = mHeightMode < 0 ? mHeightMode : mLastHeight;
    if (height != -1 && p.height != finalHeight) {
        p.height = mLastHeight = finalHeight;
        update = true;
    }
    if (p.x != x) {
        p.x = x;
        update = true;
    }
    if (p.y != y) {
        p.y = y;
        update = true;
    }
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    final int newGravity = computeGravity();
    if (newGravity != p.gravity) {
        p.gravity = newGravity;
        update = true;
    }
    int newAccessibilityIdOfAnchor = (mAnchor != null) ? mAnchor.get().getAccessibilityViewId() : -1;
    if (newAccessibilityIdOfAnchor != p.accessibilityIdOfAnchor) {
        p.accessibilityIdOfAnchor = newAccessibilityIdOfAnchor;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mDecorView, p);
    }
}",1,"/**
 * Updates the position and the dimension of the popup window.
 * <p>
 * Width and height can be set to -1 to update location only. Calling this
 * function also updates the window with the current popup state as
 * described for {@link #update()}.
 *
 * @param x the new x location
 * @param y the new y location
 * @param width the new width, must be >= 0 or -1 to ignore
 * @param height the new height, must be >= 0 or -1 to ignore
 * @param force {@code true} to reposition the window even if the specified
 * position already seems to correspond to the LayoutParams,
 * {@code false} to only reposition if needed
 */
","/**
 * Updates the position and the dimension of the popup window.
 * <p>
 * Width and height can be set to -1 to update location only. Calling this
 * function also updates the window with the current popup state as
 * described for {@link #update()}.
 *
 * @param x the new x location
 * @param y the new y location
 * @param width the new width in pixels, must be >= 0 or -1 to ignore
 * @param height the new height in pixels, must be >= 0 or -1 to ignore
 * @param force {@code true} to reposition the window even if the specified
 * position already seems to correspond to the LayoutParams,
 * {@code false} to only reposition if needed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"Two new blocks of assignment and comparison have been added to the method, therefore the control and other statements have changed, corresponding to change types 3 and 4.","The insertion of new control flow and statements which assign values to 'p.gravity' and 'p.accessibilityIdOfAnchor' changes the behavior of the method. Since these are conditionally updating the fields that may affect how 'updateViewLayout' is called and, consequently, how the PopupWindow is displayed, there is a potential for different return values or states (even though the return type is void, the visual output is considered the ""value""), thus the CI type is 1."
1223,<android.accounts.AccountManager: String getPreviousName(Account)>,23,24,<android.accounts.AccountManager: String getPreviousName(Account)>,<android.accounts.AccountManager: String getPreviousName(Account)>,0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.getPreviousName(account);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.getPreviousName(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the previous name associated with the account or {@code null}, if
 * none. This is intended so that clients of {@link
 * #LOGIN_ACCOUNTS_CHANGED_ACTION} broadcasts can determine if an
 * authenticator has renamed an account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * @param account The account to query for a previous name.
 * @return The account's previous name, null if the account has never been
 * renamed.
 */
","/**
 * Gets the previous name associated with the account or {@code null}, if
 * none. This is intended so that clients of {@link
 * #LOGIN_ACCOUNTS_CHANGED_ACTION} broadcasts can determine if an
 * authenticator has renamed an account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * @param account The account to query for a previous name.
 * @return The account's previous name, null if the account has never been
 * renamed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing the result of e.rethrowFromSystemServer(), so the code change type is 2.","Because the catch block has been modified to throw a different type of exception, this could lead to a divergence in how exceptions are handled when calling this API. Hence, there is a potential Compatibility Issue of type 2."
1224,<android.text.style.LocaleSpan: Locale getLocale()>,23,24,<android.text.style.LocaleSpan: Locale getLocale()>,<android.text.style.LocaleSpan: Locale getLocale()>,0,"{
    return mLocale;
}","{
    return mLocales.get(0);
}",1,"/**
 * Returns the {@link Locale}.
 *
 * @return The {@link Locale} for this span.
 */
","/**
 * @return The {@link Locale} for this span.  If multiple locales are associated with this
 * span, only the first locale is returned.  {@code null} if no {@link Locale} is specified.
 *
 * @see LocaleList#get()
 * @see #getLocales()
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The method used to return a member variable (mLocale) directly in the early version, whereas in the late version it returns the first element of a collection (mLocales.get(0)), indicating that the return type is still the same but the source of the returned data has changed and a dependent API is being used (get(0)), making the change type 1,5.","Since the source of the return value has changed from a direct member variable to the first element of a collection, it is possible for the return value to be different if the collection has different elements or behaviors. The API potentially returns a different value, making the CI type 1."
1225,<android.view.SurfaceControl.PhysicalDisplayInfo: String toString()>,23,24,<android.view.SurfaceControl.PhysicalDisplayInfo: String toString()>,<android.view.SurfaceControl.PhysicalDisplayInfo: String toString()>,0,"{
    return ""PhysicalDisplayInfo{"" + width + "" x "" + height + "", "" + refreshRate + "" fps, "" + ""density "" + density + "", "" + xDpi + "" x "" + yDpi + "" dpi, secure "" + secure + "", appVsyncOffset "" + appVsyncOffsetNanos + "", bufferDeadline "" + presentationDeadlineNanos + ""}"";
}","{
    return ""PhysicalDisplayInfo{"" + width + "" x "" + height + "", "" + refreshRate + "" fps, "" + ""density "" + density + "", "" + xDpi + "" x "" + yDpi + "" dpi, secure "" + secure + "", appVsyncOffset "" + appVsyncOffsetNanos + "", bufferDeadline "" + presentationDeadlineNanos + "", colorTransform "" + colorTransform + ""}"";
}",1,"// For debugging purposes
","// For debugging purposes
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An additional string concatenation has been added to include "", colorTransform "" + colorTransform at the end of the `return` statement in the method. Therefore, the type of the change is 4 (Other statement changed).","No Compatibility Issue arises due to the string representation change of `toString()`. The `toString()` method is designed to return a string that textually represents the object, and adding more information to this string does not alter the behavior of the method as per its contract. Therefore, the change to the return value does not lead to a CI – it's an enhancement to the detail provided and does not affect the existing callers."
1226,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNumeric(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNumeric(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of numerical digits required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of numerical digits required
 * in the password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the minimum number of
 * numerical digits required in the password. After setting this, the user will not be able to
 * enter a new password that is not at least as restrictive as what has been set. Note that the
 * current password will remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of numerical digits required in the password. A
 * value of 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"Exception handling statement changed from logging the exception to throwing it forward using `e.rethrowFromSystemServer()`. The number of parameters on the method `setPasswordMinimumNumeric` in the dependent API (possibly `mService`) has changed, indicating the change type is 2,5.","The change in exception handling could potentially cause different exceptions to be thrown when calling this API, resulting in a Compatibility Issue of type 2."
1227,"<android.hardware.camera2.legacy.CameraDeviceUserShim: CameraDeviceUserShim connectBinderShim(ICameraDeviceCallbacks,int)>",23,24,"<android.hardware.camera2.legacy.CameraDeviceUserShim: CameraDeviceUserShim connectBinderShim(ICameraDeviceCallbacks,int)>","<android.hardware.camera2.legacy.CameraDeviceUserShim: CameraDeviceUserShim connectBinderShim(ICameraDeviceCallbacks,int)>",0,"{
    if (DEBUG) {
        Log.d(TAG, ""Opening shim Camera device"");
    }
    /*
         * Put the camera open on a separate thread with its own looper; otherwise
         * if the main thread is used then the callbacks might never get delivered
         * (e.g. in CTS which run its own default looper only after tests)
         */
    CameraLooper init = new CameraLooper(cameraId);
    CameraCallbackThread threadCallbacks = new CameraCallbackThread(callbacks);
    // TODO: Make this async instead of blocking
    int initErrors = init.waitForOpen(OPEN_CAMERA_TIMEOUT_MS);
    Camera legacyCamera = init.getCamera();
    // Check errors old HAL initialization
    CameraBinderDecorator.throwOnError(initErrors);
    // Disable shutter sounds (this will work unconditionally) for api2 clients
    legacyCamera.disableShutterSound();
    CameraInfo info = new CameraInfo();
    Camera.getCameraInfo(cameraId, info);
    Camera.Parameters legacyParameters = null;
    try {
        legacyParameters = legacyCamera.getParameters();
    } catch (RuntimeException e) {
        throw new CameraRuntimeException(CameraAccessException.CAMERA_ERROR, ""Unable to get initial parameters"", e);
    }
    CameraCharacteristics characteristics = LegacyMetadataMapper.createCharacteristics(legacyParameters, info);
    LegacyCameraDevice device = new LegacyCameraDevice(cameraId, legacyCamera, characteristics, threadCallbacks);
    return new CameraDeviceUserShim(cameraId, device, characteristics, init, threadCallbacks);
}","{
    if (DEBUG) {
        Log.d(TAG, ""Opening shim Camera device"");
    }
    /*
         * Put the camera open on a separate thread with its own looper; otherwise
         * if the main thread is used then the callbacks might never get delivered
         * (e.g. in CTS which run its own default looper only after tests)
         */
    CameraLooper init = new CameraLooper(cameraId);
    CameraCallbackThread threadCallbacks = new CameraCallbackThread(callbacks);
    // TODO: Make this async instead of blocking
    int initErrors = init.waitForOpen(OPEN_CAMERA_TIMEOUT_MS);
    Camera legacyCamera = init.getCamera();
    // Check errors old HAL initialization
    LegacyExceptionUtils.throwOnServiceError(initErrors);
    // Disable shutter sounds (this will work unconditionally) for api2 clients
    legacyCamera.disableShutterSound();
    CameraInfo info = new CameraInfo();
    Camera.getCameraInfo(cameraId, info);
    Camera.Parameters legacyParameters = null;
    try {
        legacyParameters = legacyCamera.getParameters();
    } catch (RuntimeException e) {
        throw new ServiceSpecificException(ICameraService.ERROR_INVALID_OPERATION, ""Unable to get initial parameters: "" + e.getMessage());
    }
    CameraCharacteristics characteristics = LegacyMetadataMapper.createCharacteristics(legacyParameters, info);
    LegacyCameraDevice device = new LegacyCameraDevice(cameraId, legacyCamera, characteristics, threadCallbacks);
    return new CameraDeviceUserShim(cameraId, device, characteristics, init, threadCallbacks);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The exception handling statement has been changed from using CameraBinderDecorator.throwOnError to LegacyExceptionUtils.throwOnServiceError, indicating a difference in exception handling. Additionally, the type of exception thrown in the catch block has been changed from CameraRuntimeException to ServiceSpecificException, and the error message formation has changed as well. Moreover, the error handling mechanism now uses a different dependent API (LegacyExceptionUtils.throwOnServiceError instead of CameraBinderDecorator.throwOnError), hence the change types are 2,4 as well as 5, because the dependent API itself has changed.","The change in exception handling potentially leads to a different exception thrown, causing a change in the API's behavior. Thus, the CI type is 2."
1229,"<android.os.storage.StorageManager: boolean unmountObb(String,boolean,OnObbStateChangeListener)>",23,24,"<android.os.storage.StorageManager: boolean unmountObb(String,boolean,OnObbStateChangeListener)>","<android.os.storage.StorageManager: boolean unmountObb(String,boolean,OnObbStateChangeListener)>",0,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.unmountObb(rawPath, force, mObbActionListener, nonce);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to mount OBB"", e);
    }
    return false;
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.unmountObb(rawPath, force, mObbActionListener, nonce);
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Unmount an Opaque Binary Blob (OBB) file asynchronously. If the
 * <code>force</code> flag is true, it will kill any application needed to
 * unmount the given OBB (even the calling application).
 * <p>
 * The {@link OnObbStateChangeListener} registered with this call will
 * receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can obtain access to any other
 * application's OBB that shares its UID.
 * <p>
 *
 * @param rawPath path to the OBB file
 * @param force whether to kill any programs using this in order to unmount
 * it
 * @param listener will receive the success or failure of the operation
 * @return whether the unmount call was successfully queued or not
 */
","/**
 * Unmount an Opaque Binary Blob (OBB) file asynchronously. If the
 * <code>force</code> flag is true, it will kill any application needed to
 * unmount the given OBB (even the calling application).
 * <p>
 * The {@link OnObbStateChangeListener} registered with this call will
 * receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can obtain access to any other
 * application's OBB that shares its UID.
 * <p>
 *
 * @param rawPath path to the OBB file
 * @param force whether to kill any programs using this in order to unmount
 * it
 * @param listener will receive the success or failure of the operation
 * @return whether the unmount call was successfully queued or not
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from logging the error with `Log.e` and returning false, to throwing a RuntimeException, so the change type is 2.","Since the late version throws a RuntimeException where the early version returned false, the behavior of the API when encountering an exception has changed, which can lead to a different way exceptions are handled by user's code, and the CI type is 2."
1230,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,23,24,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,0,"{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}","{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
","/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement is changed from throwing a new RuntimeException to throwing e.rethrowFromSystemServer(), making this a change of type 2.","This change in the exception handling statement can potentially lead to a different type of exception being thrown, which constitutes a Compatibility Issue of type 2."
1231,"<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate,String)>",23,24,"<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate,String)>","<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate,String)>",0,"{
    try {
        final byte[] pemCert = Credentials.convertToPem(cert);
        final byte[] pkcs8Key = KeyFactory.getInstance(privKey.getAlgorithm()).getKeySpec(privKey, PKCS8EncodedKeySpec.class).getEncoded();
        return mService.installKeyPair(admin, pkcs8Key, pemCert, alias);
    } catch (RemoteException e) {
        Log.w(TAG, ""Failed talking with device policy service"", e);
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        Log.w(TAG, ""Failed to obtain private key material"", e);
    } catch (CertificateException | IOException e) {
        Log.w(TAG, ""Could not pem-encode certificate"", e);
    }
    return false;
}","{
    return installKeyPair(admin, privKey, new Certificate[] { cert }, alias, false);
}",1,"/**
 * Called by a device or profile owner to install a certificate and private key pair. The
 * keypair will be visible to all apps within the profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param privKey The private key to install.
 * @param cert The certificate to install.
 * @param alias The private key alias under which to install the certificate. If a certificate
 * with that alias already exists, it will be overwritten.
 * @return {@code true} if the keys were installed, {@code false} otherwise.
 */
","/**
 * Called by a device or profile owner, or delegated certificate installer, to install a
 * certificate and corresponding private key. All apps within the profile will be able to access
 * the certificate and use the private key, given direct user approval.
 *
 * <p>Access to the installed credentials will not be granted to the caller of this API without
 * direct user approval. This is for security - should a certificate installer become
 * compromised, certificates it had already installed will be protected.
 *
 * <p>If the installer must have access to the credentials, call
 * {@link #installKeyPair(ComponentName, PrivateKey, Certificate[], String, boolean)} instead.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param privKey The private key to install.
 * @param cert The certificate to install.
 * @param alias The private key alias under which to install the certificate. If a certificate
 * with that alias already exists, it will be overwritten.
 * @return {@code true} if the keys were installed, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early version directly uses internal logic and exception handling, whereas the late version calls another method. Specifically, the try-catch block and related logging have been removed, and the method now expects a different set of parameters for its call (the array of certificates and the additional boolean parameter), which indicates a different method signature being called. The changes include the removal of complex processing logic for the keys and the conversion of certificates to PEM format. Hence, the code change types are 1 and 4.","The change in the invoked method (from mService.installKeyPair to installKeyPair with different parameters) impacts the return value, as the implementation details of the actual key installation are abstracted away and now rely on another method. Therefore, it is likely to exhibit a change in the return value semantics, which leads to compatibility issues. Thus, the CI type is 1."
1232,<android.app.admin.DevicePolicyManager: void setProfileEnabled(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: void setProfileEnabled(ComponentName)>,<android.app.admin.DevicePolicyManager: void setProfileEnabled(ComponentName)>,0,"{
    if (mService != null) {
        try {
            mService.setProfileEnabled(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setProfileEnabled"");
    if (mService != null) {
        try {
            mService.setProfileEnabled(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Sets the enabled state of the profile. A profile should be enabled only once it is ready to
 * be used. Only the profile owner can call this.
 *
 * @see #isProfileOwnerApp
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 */
","/**
 * Sets the enabled state of the profile. A profile should be enabled only once it is ready to
 * be used. Only the profile owner can call this.
 *
 * @see #isProfileOwnerApp
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,2",2,"A new method call throwIfParentInstance(""setProfileEnabled"") is introduced at the beginning of the method, and there's also a change from logging an exception to throwing it, so the change type is 4,2.","Throwing an exception where it was previously caught and logged can lead to a different exception handling behavior. Therefore, there is a Compatibility Issue caused by potential different exception handlings, making CI type 2."
1233,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",23,24,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>","<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",0,"{
    try {
        return ActivityManagerNative.getDefault().getRecentTasks(maxNum, flags, UserHandle.myUserId());
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getRecentTasks(maxNum, flags, UserHandle.myUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
","/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The return statement has changed because a new method call `.getList()` is appended to the original method call in the try block, additionally, there's a change in the Exception handling because it changes from returning `null` to throwing a new exception (`throw e.rethrowFromSystemServer()`), and the code change type is then 1,2 based on the return and exception handling change. Moreover, the method `getRecentTasks` from `ActivityManagerNative` that is being used inside the method is also involved in the change (by appending `.getList()`), this is considered a dependent API change, leading to the code change type also being 5.","As the return statement now includes an additional method call `.getList()`, which could affect the value returned by the method, there is a potential Compatibility Issue of type 1 caused by different return values. Furthermore, an exception is no longer caught and returned as null; instead, it is rethrown, which alters the behavior in the face of a RemoteException, introducing a Compatibility Issue of type 2 caused by different exception handlings."
1235,"<android.widget.Toolbar: void onLayout(boolean,int,int,int,int)>",23,24,"<android.widget.Toolbar: void onLayout(boolean,int,int,int,int)>","<android.widget.Toolbar: void onLayout(boolean,int,int,int,int)>",0,"{
    final boolean isRtl = getLayoutDirection() == LAYOUT_DIRECTION_RTL;
    final int width = getWidth();
    final int height = getHeight();
    final int paddingLeft = getPaddingLeft();
    final int paddingRight = getPaddingRight();
    final int paddingTop = getPaddingTop();
    final int paddingBottom = getPaddingBottom();
    int left = paddingLeft;
    int right = width - paddingRight;
    final int[] collapsingMargins = mTempMargins;
    collapsingMargins[0] = collapsingMargins[1] = 0;
    // Align views within the minimum toolbar height, if set.
    final int alignmentHeight = getMinimumHeight();
    if (shouldLayout(mNavButtonView)) {
        if (isRtl) {
            right = layoutChildRight(mNavButtonView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mNavButtonView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mCollapseButtonView)) {
        if (isRtl) {
            right = layoutChildRight(mCollapseButtonView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mCollapseButtonView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mMenuView)) {
        if (isRtl) {
            left = layoutChildLeft(mMenuView, left, collapsingMargins, alignmentHeight);
        } else {
            right = layoutChildRight(mMenuView, right, collapsingMargins, alignmentHeight);
        }
    }
    collapsingMargins[0] = Math.max(0, getContentInsetLeft() - left);
    collapsingMargins[1] = Math.max(0, getContentInsetRight() - (width - paddingRight - right));
    left = Math.max(left, getContentInsetLeft());
    right = Math.min(right, width - paddingRight - getContentInsetRight());
    if (shouldLayout(mExpandedActionView)) {
        if (isRtl) {
            right = layoutChildRight(mExpandedActionView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mExpandedActionView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mLogoView)) {
        if (isRtl) {
            right = layoutChildRight(mLogoView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mLogoView, left, collapsingMargins, alignmentHeight);
        }
    }
    final boolean layoutTitle = shouldLayout(mTitleTextView);
    final boolean layoutSubtitle = shouldLayout(mSubtitleTextView);
    int titleHeight = 0;
    if (layoutTitle) {
        final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
        titleHeight += lp.topMargin + mTitleTextView.getMeasuredHeight() + lp.bottomMargin;
    }
    if (layoutSubtitle) {
        final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
        titleHeight += lp.topMargin + mSubtitleTextView.getMeasuredHeight() + lp.bottomMargin;
    }
    if (layoutTitle || layoutSubtitle) {
        int titleTop;
        final View topChild = layoutTitle ? mTitleTextView : mSubtitleTextView;
        final View bottomChild = layoutSubtitle ? mSubtitleTextView : mTitleTextView;
        final LayoutParams toplp = (LayoutParams) topChild.getLayoutParams();
        final LayoutParams bottomlp = (LayoutParams) bottomChild.getLayoutParams();
        final boolean titleHasWidth = layoutTitle && mTitleTextView.getMeasuredWidth() > 0 || layoutSubtitle && mSubtitleTextView.getMeasuredWidth() > 0;
        switch(mGravity & Gravity.VERTICAL_GRAVITY_MASK) {
            case Gravity.TOP:
                titleTop = getPaddingTop() + toplp.topMargin + mTitleMarginTop;
                break;
            default:
            case Gravity.CENTER_VERTICAL:
                final int space = height - paddingTop - paddingBottom;
                int spaceAbove = (space - titleHeight) / 2;
                if (spaceAbove < toplp.topMargin + mTitleMarginTop) {
                    spaceAbove = toplp.topMargin + mTitleMarginTop;
                } else {
                    final int spaceBelow = height - paddingBottom - titleHeight - spaceAbove - paddingTop;
                    if (spaceBelow < toplp.bottomMargin + mTitleMarginBottom) {
                        spaceAbove = Math.max(0, spaceAbove - (bottomlp.bottomMargin + mTitleMarginBottom - spaceBelow));
                    }
                }
                titleTop = paddingTop + spaceAbove;
                break;
            case Gravity.BOTTOM:
                titleTop = height - paddingBottom - bottomlp.bottomMargin - mTitleMarginBottom - titleHeight;
                break;
        }
        if (isRtl) {
            final int rd = (titleHasWidth ? mTitleMarginStart : 0) - collapsingMargins[1];
            right -= Math.max(0, rd);
            collapsingMargins[1] = Math.max(0, -rd);
            int titleRight = right;
            int subtitleRight = right;
            if (layoutTitle) {
                final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
                final int titleLeft = titleRight - mTitleTextView.getMeasuredWidth();
                final int titleBottom = titleTop + mTitleTextView.getMeasuredHeight();
                mTitleTextView.layout(titleLeft, titleTop, titleRight, titleBottom);
                titleRight = titleLeft - mTitleMarginEnd;
                titleTop = titleBottom + lp.bottomMargin;
            }
            if (layoutSubtitle) {
                final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
                titleTop += lp.topMargin;
                final int subtitleLeft = subtitleRight - mSubtitleTextView.getMeasuredWidth();
                final int subtitleBottom = titleTop + mSubtitleTextView.getMeasuredHeight();
                mSubtitleTextView.layout(subtitleLeft, titleTop, subtitleRight, subtitleBottom);
                subtitleRight = subtitleRight - mTitleMarginEnd;
                titleTop = subtitleBottom + lp.bottomMargin;
            }
            if (titleHasWidth) {
                right = Math.min(titleRight, subtitleRight);
            }
        } else {
            final int ld = (titleHasWidth ? mTitleMarginStart : 0) - collapsingMargins[0];
            left += Math.max(0, ld);
            collapsingMargins[0] = Math.max(0, -ld);
            int titleLeft = left;
            int subtitleLeft = left;
            if (layoutTitle) {
                final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
                final int titleRight = titleLeft + mTitleTextView.getMeasuredWidth();
                final int titleBottom = titleTop + mTitleTextView.getMeasuredHeight();
                mTitleTextView.layout(titleLeft, titleTop, titleRight, titleBottom);
                titleLeft = titleRight + mTitleMarginEnd;
                titleTop = titleBottom + lp.bottomMargin;
            }
            if (layoutSubtitle) {
                final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
                titleTop += lp.topMargin;
                final int subtitleRight = subtitleLeft + mSubtitleTextView.getMeasuredWidth();
                final int subtitleBottom = titleTop + mSubtitleTextView.getMeasuredHeight();
                mSubtitleTextView.layout(subtitleLeft, titleTop, subtitleRight, subtitleBottom);
                subtitleLeft = subtitleRight + mTitleMarginEnd;
                titleTop = subtitleBottom + lp.bottomMargin;
            }
            if (titleHasWidth) {
                left = Math.max(titleLeft, subtitleLeft);
            }
        }
    }
    // Get all remaining children sorted for layout. This is all prepared
    // such that absolute layout direction can be used below.
    addCustomViewsWithGravity(mTempViews, Gravity.LEFT);
    final int leftViewsCount = mTempViews.size();
    for (int i = 0; i < leftViewsCount; i++) {
        left = layoutChildLeft(mTempViews.get(i), left, collapsingMargins, alignmentHeight);
    }
    addCustomViewsWithGravity(mTempViews, Gravity.RIGHT);
    final int rightViewsCount = mTempViews.size();
    for (int i = 0; i < rightViewsCount; i++) {
        right = layoutChildRight(mTempViews.get(i), right, collapsingMargins, alignmentHeight);
    }
    // Centered views try to center with respect to the whole bar, but views pinned
    // to the left or right can push the mass of centered views to one side or the other.
    addCustomViewsWithGravity(mTempViews, Gravity.CENTER_HORIZONTAL);
    final int centerViewsWidth = getViewListMeasuredWidth(mTempViews, collapsingMargins);
    final int parentCenter = paddingLeft + (width - paddingLeft - paddingRight) / 2;
    final int halfCenterViewsWidth = centerViewsWidth / 2;
    int centerLeft = parentCenter - halfCenterViewsWidth;
    final int centerRight = centerLeft + centerViewsWidth;
    if (centerLeft < left) {
        centerLeft = left;
    } else if (centerRight > right) {
        centerLeft -= centerRight - right;
    }
    final int centerViewsCount = mTempViews.size();
    for (int i = 0; i < centerViewsCount; i++) {
        centerLeft = layoutChildLeft(mTempViews.get(i), centerLeft, collapsingMargins, alignmentHeight);
    }
    mTempViews.clear();
}","{
    final boolean isRtl = getLayoutDirection() == LAYOUT_DIRECTION_RTL;
    final int width = getWidth();
    final int height = getHeight();
    final int paddingLeft = getPaddingLeft();
    final int paddingRight = getPaddingRight();
    final int paddingTop = getPaddingTop();
    final int paddingBottom = getPaddingBottom();
    int left = paddingLeft;
    int right = width - paddingRight;
    final int[] collapsingMargins = mTempMargins;
    collapsingMargins[0] = collapsingMargins[1] = 0;
    // Align views within the minimum toolbar height, if set.
    final int alignmentHeight = getMinimumHeight();
    if (shouldLayout(mNavButtonView)) {
        if (isRtl) {
            right = layoutChildRight(mNavButtonView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mNavButtonView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mCollapseButtonView)) {
        if (isRtl) {
            right = layoutChildRight(mCollapseButtonView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mCollapseButtonView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mMenuView)) {
        if (isRtl) {
            left = layoutChildLeft(mMenuView, left, collapsingMargins, alignmentHeight);
        } else {
            right = layoutChildRight(mMenuView, right, collapsingMargins, alignmentHeight);
        }
    }
    final int contentInsetLeft = getCurrentContentInsetLeft();
    final int contentInsetRight = getCurrentContentInsetRight();
    collapsingMargins[0] = Math.max(0, contentInsetLeft - left);
    collapsingMargins[1] = Math.max(0, contentInsetRight - (width - paddingRight - right));
    left = Math.max(left, contentInsetLeft);
    right = Math.min(right, width - paddingRight - contentInsetRight);
    if (shouldLayout(mExpandedActionView)) {
        if (isRtl) {
            right = layoutChildRight(mExpandedActionView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mExpandedActionView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mLogoView)) {
        if (isRtl) {
            right = layoutChildRight(mLogoView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mLogoView, left, collapsingMargins, alignmentHeight);
        }
    }
    final boolean layoutTitle = shouldLayout(mTitleTextView);
    final boolean layoutSubtitle = shouldLayout(mSubtitleTextView);
    int titleHeight = 0;
    if (layoutTitle) {
        final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
        titleHeight += lp.topMargin + mTitleTextView.getMeasuredHeight() + lp.bottomMargin;
    }
    if (layoutSubtitle) {
        final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
        titleHeight += lp.topMargin + mSubtitleTextView.getMeasuredHeight() + lp.bottomMargin;
    }
    if (layoutTitle || layoutSubtitle) {
        int titleTop;
        final View topChild = layoutTitle ? mTitleTextView : mSubtitleTextView;
        final View bottomChild = layoutSubtitle ? mSubtitleTextView : mTitleTextView;
        final LayoutParams toplp = (LayoutParams) topChild.getLayoutParams();
        final LayoutParams bottomlp = (LayoutParams) bottomChild.getLayoutParams();
        final boolean titleHasWidth = layoutTitle && mTitleTextView.getMeasuredWidth() > 0 || layoutSubtitle && mSubtitleTextView.getMeasuredWidth() > 0;
        switch(mGravity & Gravity.VERTICAL_GRAVITY_MASK) {
            case Gravity.TOP:
                titleTop = getPaddingTop() + toplp.topMargin + mTitleMarginTop;
                break;
            default:
            case Gravity.CENTER_VERTICAL:
                final int space = height - paddingTop - paddingBottom;
                int spaceAbove = (space - titleHeight) / 2;
                if (spaceAbove < toplp.topMargin + mTitleMarginTop) {
                    spaceAbove = toplp.topMargin + mTitleMarginTop;
                } else {
                    final int spaceBelow = height - paddingBottom - titleHeight - spaceAbove - paddingTop;
                    if (spaceBelow < toplp.bottomMargin + mTitleMarginBottom) {
                        spaceAbove = Math.max(0, spaceAbove - (bottomlp.bottomMargin + mTitleMarginBottom - spaceBelow));
                    }
                }
                titleTop = paddingTop + spaceAbove;
                break;
            case Gravity.BOTTOM:
                titleTop = height - paddingBottom - bottomlp.bottomMargin - mTitleMarginBottom - titleHeight;
                break;
        }
        if (isRtl) {
            final int rd = (titleHasWidth ? mTitleMarginStart : 0) - collapsingMargins[1];
            right -= Math.max(0, rd);
            collapsingMargins[1] = Math.max(0, -rd);
            int titleRight = right;
            int subtitleRight = right;
            if (layoutTitle) {
                final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
                final int titleLeft = titleRight - mTitleTextView.getMeasuredWidth();
                final int titleBottom = titleTop + mTitleTextView.getMeasuredHeight();
                mTitleTextView.layout(titleLeft, titleTop, titleRight, titleBottom);
                titleRight = titleLeft - mTitleMarginEnd;
                titleTop = titleBottom + lp.bottomMargin;
            }
            if (layoutSubtitle) {
                final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
                titleTop += lp.topMargin;
                final int subtitleLeft = subtitleRight - mSubtitleTextView.getMeasuredWidth();
                final int subtitleBottom = titleTop + mSubtitleTextView.getMeasuredHeight();
                mSubtitleTextView.layout(subtitleLeft, titleTop, subtitleRight, subtitleBottom);
                subtitleRight = subtitleRight - mTitleMarginEnd;
                titleTop = subtitleBottom + lp.bottomMargin;
            }
            if (titleHasWidth) {
                right = Math.min(titleRight, subtitleRight);
            }
        } else {
            final int ld = (titleHasWidth ? mTitleMarginStart : 0) - collapsingMargins[0];
            left += Math.max(0, ld);
            collapsingMargins[0] = Math.max(0, -ld);
            int titleLeft = left;
            int subtitleLeft = left;
            if (layoutTitle) {
                final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
                final int titleRight = titleLeft + mTitleTextView.getMeasuredWidth();
                final int titleBottom = titleTop + mTitleTextView.getMeasuredHeight();
                mTitleTextView.layout(titleLeft, titleTop, titleRight, titleBottom);
                titleLeft = titleRight + mTitleMarginEnd;
                titleTop = titleBottom + lp.bottomMargin;
            }
            if (layoutSubtitle) {
                final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
                titleTop += lp.topMargin;
                final int subtitleRight = subtitleLeft + mSubtitleTextView.getMeasuredWidth();
                final int subtitleBottom = titleTop + mSubtitleTextView.getMeasuredHeight();
                mSubtitleTextView.layout(subtitleLeft, titleTop, subtitleRight, subtitleBottom);
                subtitleLeft = subtitleRight + mTitleMarginEnd;
                titleTop = subtitleBottom + lp.bottomMargin;
            }
            if (titleHasWidth) {
                left = Math.max(titleLeft, subtitleLeft);
            }
        }
    }
    // Get all remaining children sorted for layout. This is all prepared
    // such that absolute layout direction can be used below.
    addCustomViewsWithGravity(mTempViews, Gravity.LEFT);
    final int leftViewsCount = mTempViews.size();
    for (int i = 0; i < leftViewsCount; i++) {
        left = layoutChildLeft(mTempViews.get(i), left, collapsingMargins, alignmentHeight);
    }
    addCustomViewsWithGravity(mTempViews, Gravity.RIGHT);
    final int rightViewsCount = mTempViews.size();
    for (int i = 0; i < rightViewsCount; i++) {
        right = layoutChildRight(mTempViews.get(i), right, collapsingMargins, alignmentHeight);
    }
    // Centered views try to center with respect to the whole bar, but views pinned
    // to the left or right can push the mass of centered views to one side or the other.
    addCustomViewsWithGravity(mTempViews, Gravity.CENTER_HORIZONTAL);
    final int centerViewsWidth = getViewListMeasuredWidth(mTempViews, collapsingMargins);
    final int parentCenter = paddingLeft + (width - paddingLeft - paddingRight) / 2;
    final int halfCenterViewsWidth = centerViewsWidth / 2;
    int centerLeft = parentCenter - halfCenterViewsWidth;
    final int centerRight = centerLeft + centerViewsWidth;
    if (centerLeft < left) {
        centerLeft = left;
    } else if (centerRight > right) {
        centerLeft -= centerRight - right;
    }
    final int centerViewsCount = mTempViews.size();
    for (int i = 0; i < centerViewsCount; i++) {
        centerLeft = layoutChildLeft(mTempViews.get(i), centerLeft, collapsingMargins, alignmentHeight);
    }
    mTempViews.clear();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1236,"<android.widget.ArrayAdapter: ArrayAdapter<CharSequence> createFromResource(Context,int,int)>",23,24,"<android.widget.ArrayAdapter: ArrayAdapter<CharSequence> createFromResource(Context,int,int)>","<android.widget.ArrayAdapter: ArrayAdapter<CharSequence> createFromResource(Context,int,int)>",0,"{
    CharSequence[] strings = context.getResources().getTextArray(textArrayResId);
    return new ArrayAdapter<CharSequence>(context, textViewResId, strings);
}","{
    final CharSequence[] strings = context.getResources().getTextArray(textArrayResId);
    return new ArrayAdapter<>(context, textViewResId, strings);
}",1,"/**
 * Creates a new ArrayAdapter from external resources. The content of the array is
 * obtained through {@link android.content.res.Resources#getTextArray(int)}.
 *
 * @param context The application's environment.
 * @param textArrayResId The identifier of the array to use as the data source.
 * @param textViewResId The identifier of the layout used to create views.
 *
 * @return An ArrayAdapter<CharSequence>.
 */
","/**
 * Creates a new ArrayAdapter from external resources. The content of the array is
 * obtained through {@link android.content.res.Resources#getTextArray(int)}.
 *
 * @param context The application's environment.
 * @param textArrayResId The identifier of the array to use as the data source.
 * @param textViewResId The identifier of the layout used to create views.
 *
 * @return An ArrayAdapter<CharSequence>.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The only change in the late version is the use of the diamond operator `<>` in `new ArrayAdapter<>(...)`, which is a type inference shortcut introduced in Java 7 for generics. This change doesn't alter the functionality of the code nor the API contract. Therefore, the code change type is 4.","No Compatibility Issue could arise from this change since it doesn't affect the method's behavior, return types or values, or exception handling. The change is purely syntactical and uses type inference, which does not affect clients using the API. Hence, the CI type is 0."
1237,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,23,24,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,0,"{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mRestricted, mDisplay, overrideConfiguration, Display.INVALID_DISPLAY);
}","{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mFlags, mDisplay, overrideConfiguration, Display.INVALID_DISPLAY);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The constructor invocation of ContextImpl changed, with mRestricted being replaced by mFlags, so the code change type is 4,5.","However, there is no Compatibility Issue because the change in the constructor parameters (from mRestricted to mFlags) doesn't affect the behavior of the createConfigurationContext() method when it is called. It's an internal change and does not lead to a different return value or type, neither it introduces a change in exception handling."
1238,<android.net.TrafficStats: long getUidRxBytes(int)>,23,24,<android.net.TrafficStats: long getUidRxBytes(int)>,<android.net.TrafficStats: long getUidRxBytes(int)>,0,"{
    return nativeGetUidStat(uid, TYPE_RX_BYTES);
}","{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_RX_BYTES);
    } else {
        return UNSUPPORTED;
    }
}",1,"/**
 * Return number of bytes received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of bytes received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"Control dependency has changed due to the addition of an 'if' statement checking for the calling UID before calling nativeGetUidStat, which also introduces the use of a previously nonexistent constant 'UNSUPPORTED'. Also, the dependent native method nativeGetUidStat(uid, TYPE_RX_BYTES) is now called conditionally based on the UID check. These changes classify under change types 3 and 5.","The API now returns a different value ('UNSUPPORTED') when the UID calling the API is neither SYSTEM_UID nor the UID for which the stats are being requested. Previously, this method would have just returned the result from nativeGetUidStat without checks. Thus, different return values are possible between the versions, leading to CI type 1."
1239,<android.view.View: boolean performLongClick()>,23,24,<android.view.View: boolean performLongClick()>,<android.view.View: boolean performLongClick()>,0,"{
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
    boolean handled = false;
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnLongClickListener != null) {
        handled = li.mOnLongClickListener.onLongClick(View.this);
    }
    if (!handled) {
        handled = showContextMenu();
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    return handled;
}","{
    return performLongClickInternal(mLongClickX, mLongClickY);
}",1,"/**
 * Call this view's OnLongClickListener, if it is defined. Invokes the context menu if the
 * OnLongClickListener did not consume the event.
 *
 * @return True if one of the above receivers consumed the event, false otherwise.
 */
","/**
 * Calls this view's OnLongClickListener, if it is defined. Invokes the
 * context menu if the OnLongClickListener did not consume the event.
 *
 * @return {@code true} if one of the above receivers consumed the event,
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of the performLongClick() method has changed from executing multiple operations and condition checks to simply delegating the operation to another method called performLongClickInternal(mLongClickX, mLongClickY). This is not only a return statement change but also includes changes to the overall logic that determines the return value. As performLongClickInternal is a different API (dependent API), it indicates that the dependence of the current API has changed. This counts as both a return statement changed (1) and a dependent API changed (5).","Due to the change from a direct implementation to a delegation to a different method with extra parameters, there's a chance that the new implementation behaves differently than the old one, potentially returning different values. It would depend on the implementation of the new dependent API, but even without knowing that, this change could lead to a Compatibility Issue of type 1 due to the possibility of returning a different result."
1240,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> updateCredentials(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",23,24,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> updateCredentials(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> updateCredentials(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.updateCredentials(mResponse, account, authTokenType, activity != null, options);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.updateCredentials(mResponse, account, authTokenType, activity != null, options);
        }
    }.start();
}",1,"/**
 * Asks the user to enter a new password for an account, updating the
 * saved credentials for the account.  Normally this happens automatically
 * when the server rejects credentials during an auth token fetch, but this
 * can be invoked directly to ensure we have the correct credentials stored.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to update credentials for
 * @param authTokenType The credentials entered must allow an auth token
 * of this type to be created (but no actual auth token is returned);
 * may be null
 * @param options Authenticator-specific options for the request;
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to enter a
 * password; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * with these fields if an activity was supplied and the account
 * credentials were successfully updated:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * password prompt. If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the password prompt
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * verifying the password, usually because of network trouble
 * </ul>
 */
","/**
 * Asks the user to enter a new password for an account, updating the
 * saved credentials for the account.  Normally this happens automatically
 * when the server rejects credentials during an auth token fetch, but this
 * can be invoked directly to ensure we have the correct credentials stored.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to update credentials for
 * @param authTokenType The credentials entered must allow an auth token
 * of this type to be created (but no actual auth token is returned);
 * may be null
 * @param options Authenticator-specific options for the request;
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to enter a
 * password; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * with these fields if an activity was supplied and the account
 * credentials were successfully updated:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * password prompt. If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the password prompt
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * verifying the password, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the implementation or logic, only the `@Override` annotation has been added which does not affect the behavior of the method.",No compatibility issue arises since the method's behavior remains unaffected between the two versions.
1241,"<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>",23,24,"<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>","<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>",0,"{
    final ListAdapter adapter = getAdapter();
    if (position == INVALID_POSITION || adapter == null) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    if (!isEnabled() || !adapter.isEnabled(position)) {
        info.setEnabled(false);
        return;
    }
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        info.addAction(AccessibilityAction.ACTION_CLEAR_SELECTION);
    } else {
        info.addAction(AccessibilityAction.ACTION_SELECT);
    }
    if (isClickable()) {
        info.addAction(AccessibilityAction.ACTION_CLICK);
        info.setClickable(true);
    }
    if (isLongClickable()) {
        info.addAction(AccessibilityAction.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}","{
    if (position == INVALID_POSITION) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    final boolean isItemEnabled;
    final ViewGroup.LayoutParams lp = view.getLayoutParams();
    if (lp instanceof AbsListView.LayoutParams) {
        isItemEnabled = ((AbsListView.LayoutParams) lp).isEnabled;
    } else {
        isItemEnabled = false;
    }
    if (!isEnabled() || !isItemEnabled) {
        info.setEnabled(false);
        return;
    }
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        info.addAction(AccessibilityAction.ACTION_CLEAR_SELECTION);
    } else {
        info.addAction(AccessibilityAction.ACTION_SELECT);
    }
    if (isItemClickable(view)) {
        info.addAction(AccessibilityAction.ACTION_CLICK);
        info.setClickable(true);
    }
    if (isLongClickable()) {
        info.addAction(AccessibilityAction.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}",1,"/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
","/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The check for adapter being null was removed, which changes the control flow of the method - this makes it a control dependency change (3). Additionally, a new method of determining if an item is enabled has been introduced by checking the instance of the layout params and a new variable isItemEnabled is used, which involves an other statement change (4). Also, the method isItemClickable(view) is introduced in the late version, which implies a dependent API change (5), and the condition on adapter.isEnabled(position) has been completely removed which could potentially return a different value, marking a return statement changed (1).","The removal of the adapter null check as well as the change from adapter.isEnabled(position) to using layout parameters and isItemClickable(view) to determine item enabled state and clickability could all potentially result in different return values or behaviors, and therefore compatibility issues (1). Because isEnabled() behavior depends on a variable that might have been set differently according to the new implementation, and isItemClickable(view) is a new method that could potentially throw new exceptions, there might be a CI due to different exception handling (2)."
1242,<android.app.ActivityManager: void getMyMemoryState(RunningAppProcessInfo)>,23,24,<android.app.ActivityManager: void getMyMemoryState(RunningAppProcessInfo)>,<android.app.ActivityManager: void getMyMemoryState(RunningAppProcessInfo)>,0,"{
    try {
        ActivityManagerNative.getDefault().getMyMemoryState(outState);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().getMyMemoryState(outState);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return global memory state information for the calling process.  This
 * does not fill in all fields of the {@link RunningAppProcessInfo}.  The
 * only fields that will be filled in are
 * {@link RunningAppProcessInfo#pid},
 * {@link RunningAppProcessInfo#uid},
 * {@link RunningAppProcessInfo#lastTrimLevel},
 * {@link RunningAppProcessInfo#importance},
 * {@link RunningAppProcessInfo#lru}, and
 * {@link RunningAppProcessInfo#importanceReasonCode}.
 */
","/**
 * Return global memory state information for the calling process.  This
 * does not fill in all fields of the {@link RunningAppProcessInfo}.  The
 * only fields that will be filled in are
 * {@link RunningAppProcessInfo#pid},
 * {@link RunningAppProcessInfo#uid},
 * {@link RunningAppProcessInfo#lastTrimLevel},
 * {@link RunningAppProcessInfo#importance},
 * {@link RunningAppProcessInfo#lru}, and
 * {@link RunningAppProcessInfo#importanceReasonCode}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed as a new throw statement is introduced in the late implementation with `throw e.rethrowFromSystemServer()`, so the code change type is 2.","The change in exception handling could potentially cause the late version of the API to throw an exception where the early version would not, which constitutes a different behavior in exception handling. Therefore, the CI type is 2."
1244,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>",23,24,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>","<android.text.util.Linkify: boolean addLinks(Spannable,int)>",0,"{
    if (mask == 0) {
        return false;
    }
    URLSpan[] old = text.getSpans(0, text.length(), URLSpan.class);
    for (int i = old.length - 1; i >= 0; i--) {
        text.removeSpan(old[i]);
    }
    ArrayList<LinkSpec> links = new ArrayList<LinkSpec>();
    if ((mask & WEB_URLS) != 0) {
        gatherLinks(links, text, Patterns.WEB_URL, new String[] { ""http://"", ""https://"", ""rtsp://"" }, sUrlMatchFilter, null);
    }
    if ((mask & EMAIL_ADDRESSES) != 0) {
        gatherLinks(links, text, Patterns.EMAIL_ADDRESS, new String[] { ""mailto:"" }, null, null);
    }
    if ((mask & PHONE_NUMBERS) != 0) {
        gatherTelLinks(links, text);
    }
    if ((mask & MAP_ADDRESSES) != 0) {
        gatherMapLinks(links, text);
    }
    pruneOverlaps(links);
    if (links.size() == 0) {
        return false;
    }
    for (LinkSpec link : links) {
        applyLink(link.url, link.start, link.end, text);
    }
    return true;
}","{
    if (mask == 0) {
        return false;
    }
    URLSpan[] old = text.getSpans(0, text.length(), URLSpan.class);
    for (int i = old.length - 1; i >= 0; i--) {
        text.removeSpan(old[i]);
    }
    ArrayList<LinkSpec> links = new ArrayList<LinkSpec>();
    if ((mask & WEB_URLS) != 0) {
        gatherLinks(links, text, Patterns.AUTOLINK_WEB_URL, new String[] { ""http://"", ""https://"", ""rtsp://"" }, sUrlMatchFilter, null);
    }
    if ((mask & EMAIL_ADDRESSES) != 0) {
        gatherLinks(links, text, Patterns.AUTOLINK_EMAIL_ADDRESS, new String[] { ""mailto:"" }, null, null);
    }
    if ((mask & PHONE_NUMBERS) != 0) {
        gatherTelLinks(links, text);
    }
    if ((mask & MAP_ADDRESSES) != 0) {
        gatherMapLinks(links, text);
    }
    pruneOverlaps(links);
    if (links.size() == 0) {
        return false;
    }
    for (LinkSpec link : links) {
        applyLink(link.url, link.start, link.end, text);
    }
    return true;
}",1,"/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 */
","/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 *
 * @param text Spannable whose text is to be marked-up with links
 * @param mask Mask to define which kinds of links will be searched.
 *
 * @return True if at least one link is found and applied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API used in the implementation has changed from Patterns.WEB_URL and Patterns.EMAIL_ADDRESS in the early version to Patterns.AUTOLINK_WEB_URL and Patterns.AUTOLINK_EMAIL_ADDRESS in the late version, so the change type is 5.","The dependent API change leads to potential Compatibility Issues due to possible different return values as the pattern matching for web URLs and email addresses may behave differently with the new constants, therefore the CI type is 1."
1245,"<android.accounts.AccountManager: Account[] getAccountsByTypeForPackage(String,String)>",23,24,"<android.accounts.AccountManager: Account[] getAccountsByTypeForPackage(String,String)>","<android.accounts.AccountManager: Account[] getAccountsByTypeForPackage(String,String)>",0,"{
    try {
        return mService.getAccountsByTypeForPackage(type, packageName, mContext.getOpPackageName());
    } catch (RemoteException re) {
        // won't ever happen
        throw new RuntimeException(re);
    }
}","{
    try {
        return mService.getAccountsByTypeForPackage(type, packageName, mContext.getOpPackageName());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the accounts visible to the specified package, in an environment where some apps
 * are not authorized to view all accounts. This method can only be called by system apps.
 * @param type The type of accounts to return, null to retrieve all accounts
 * @param packageName The package name of the app for which the accounts are to be returned
 * @return An array of {@link Account}, one per matching account.  Empty
 * (never null) if no accounts of the specified type have been added.
 */
","/**
 * Returns the accounts visible to the specified package, in an environment where some apps
 * are not authorized to view all accounts. This method can only be called by system apps.
 * @param type The type of accounts to return, null to retrieve all accounts
 * @param packageName The package name of the app for which the accounts are to be returned
 * @return An array of {@link Account}, one per matching account.  Empty
 * (never null) if no accounts of the specified type have been added.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing re.rethrowFromSystemServer(), so the code change type is 2.","The change in the exception handling statement will cause the method to throw a different exception than before, so the CI type is 2."
1247,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>",23,24,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>","<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>",0,"{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return false;
        }
        try {
            return mService.showSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
        }
        return false;
    }
}","{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return false;
        }
        try {
            return mService.showSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Explicitly request that the current input method's soft input area be
 * shown to the user, if needed.  Call this if the user interacts with
 * your view in such a way that they have expressed they would like to
 * start performing input into it.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
","/**
 * Explicitly request that the current input method's soft input area be
 * shown to the user, if needed.  Call this if the user interacts with
 * your view in such a way that they have expressed they would like to
 * start performing input into it.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, with the older version having no action defined in the catch block, whereas the newer version includes a throw statement. So, the code change type is 2.","This change introduces a new exception throwing behavior for RemoteException. Previously the exception was caught and ignored; in the later version, it is rethrown using e.rethrowFromSystemServer(). Hence, there is potential for a different exception handling behavior, making the CI type 2."
1248,<android.net.LocalSocketImpl: LocalSocketAddress getSockAddress()>,23,24,<android.net.LocalSocketImpl: LocalSocketAddress getSockAddress()>,<android.net.LocalSocketImpl: LocalSocketAddress getSockAddress()>,0,"{
    return null;
// TODO implement this
// return getSockName_native(fd);
}","{
    // This method has never been implemented.
    return null;
}",1,"/**
 * Retrieves the socket name from the OS.
 *
 * @return non-null; socket name
 * @throws IOException on failure
 */
","/**
 * Retrieves the socket name from the OS.
 *
 * @return non-null; socket name
 * @throws IOException on failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change apart from a comment modification. The implementation of the method still returns null in both versions, so the actual behavior of the method has not been altered in any way.",There is no compatibility issue as the method's behavior has not changed between versions; it always returns null.
1250,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,boolean,AccountManagerCallback<Bundle>,Handler)>",23,24,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,boolean,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,boolean,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    final Bundle optionsIn = new Bundle();
    if (options != null) {
        optionsIn.putAll(options);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(null, handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, notifyAuthFailure, false, /* expectActivityLaunch */
            optionsIn);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    final Bundle optionsIn = new Bundle();
    if (options != null) {
        optionsIn.putAll(options);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(null, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, notifyAuthFailure, false, /* expectActivityLaunch */
            optionsIn);
        }
    }.start();
}",1,"/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
","/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no changes in the implementation of the method from the early version to the late version. The only variation is the addition of an `@Override` annotation which does not alter the functionality of the method.,"Since there are no changes in the functionality, parameters, or return type, there is no compatibility issue between these two versions."
1251,<android.app.ActivityThread.StopInfo: void run()>,23,24,<android.app.ActivityThread.StopInfo: void run()>,<android.app.ActivityThread.StopInfo: void run()>,0,"{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + activity);
        ActivityManagerNative.getDefault().activityStopped(activity.token, state, persistentState, description);
    } catch (RemoteException ex) {
    }
}","{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + activity);
        ActivityManagerNative.getDefault().activityStopped(activity.token, state, persistentState, description);
    } catch (RemoteException ex) {
        if (ex instanceof TransactionTooLargeException && activity.packageInfo.getTargetSdkVersion() < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data in instance state, so it was ignored"", ex);
            return;
        }
        throw ex.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The late version of the method has added a new exception handling block within the existing `catch` clause for `RemoteException`. This new block specifically checks if the `RemoteException` is an instance of `TransactionTooLargeException` and if the target SDK version of the application is below Android N. If this condition is true, it logs an error message and returns early from the method. Otherwise, it rethrows the exception using `rethrowFromSystemServer()`. This is a significant change because the early version does not discriminate between types of `RemoteException` nor SDK versions; it simply swallows all `RemoteException`. Thus, the change type is 2.","A Compatibility Issue may arise from the changed exception handling: the late version could throw a `TransactionTooLargeException` wrapped as a `RuntimeException` for newer apps targeting SDK version of Android N or later (previously, all RemoteException instances were swallowed), and for older apps, the exception is not thrown but logged instead. Previously, the handling of this exception would not have any effect on app behavior. Because of the potential for different exception handling outcomes, the CI type is 2."
1252,<android.widget.Toast.TN: void handleShow()>,23,24,<android.widget.Toast.TN: void handleShow()>,<android.widget.Toast.TN: void handleShow()>,0,"{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        Context context = mView.getContext().getApplicationContext();
        String packageName = mView.getContext().getOpPackageName();
        if (context == null) {
            context = mView.getContext();
        }
        mWM = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        // We can resolve the Gravity here by using the Locale for getting
        // the layout direction
        final Configuration config = mView.getContext().getResources().getConfiguration();
        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
        mParams.gravity = gravity;
        if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
            mParams.horizontalWeight = 1.0f;
        }
        if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
            mParams.verticalWeight = 1.0f;
        }
        mParams.x = mX;
        mParams.y = mY;
        mParams.verticalMargin = mVerticalMargin;
        mParams.horizontalMargin = mHorizontalMargin;
        mParams.packageName = packageName;
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        if (localLOGV)
            Log.v(TAG, ""ADD! "" + mView + "" in "" + this);
        mWM.addView(mView, mParams);
        trySendAccessibilityEvent();
    }
}","{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        Context context = mView.getContext().getApplicationContext();
        String packageName = mView.getContext().getOpPackageName();
        if (context == null) {
            context = mView.getContext();
        }
        mWM = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        // We can resolve the Gravity here by using the Locale for getting
        // the layout direction
        final Configuration config = mView.getContext().getResources().getConfiguration();
        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
        mParams.gravity = gravity;
        if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
            mParams.horizontalWeight = 1.0f;
        }
        if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
            mParams.verticalWeight = 1.0f;
        }
        mParams.x = mX;
        mParams.y = mY;
        mParams.verticalMargin = mVerticalMargin;
        mParams.horizontalMargin = mHorizontalMargin;
        mParams.packageName = packageName;
        mParams.removeTimeoutMilliseconds = mDuration == Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        if (localLOGV)
            Log.v(TAG, ""ADD! "" + mView + "" in "" + this);
        mWM.addView(mView, mParams);
        trySendAccessibilityEvent();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The addition of a new line that assigns a value to mParams.removeTimeoutMilliseconds based on the duration of the toast represents a change that is neither a return statement, exception handling, control dependency, nor a dependent API change. Hence, the code change type is 4.","The added line sets a property on the mParams object but does not alter behavior related to the method's return type, the exceptions it might throw, or its control flow. As such, no compatibility issue is introduced with respect to return values or exception handling, and the CI type is 0."
1253,<android.app.Activity: void performRestart()>,23,24,<android.app.Activity: void performRestart()>,<android.app.Activity: void performRestart()>,0,"{
    mFragments.noteStateNotSaved();
    if (mStopped) {
        mStopped = false;
        if (mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, false);
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                            throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                        }
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}","{
    mFragments.noteStateNotSaved();
    if (mToken != null && mParent == null) {
        // No need to check mStopped, the roots will check if they were actually stopped.
        WindowManagerGlobal.getInstance().setStoppedState(mToken, false);
    }
    if (mStopped) {
        mStopped = false;
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                            throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                        }
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"In the late version of the code, the condition checking the `mStopped` variable has been moved after the call to `setStoppedState()`. This is a control dependency change because the control flow has been altered, which is categorized as change type 3.","The reordering of the check for `mStopped` does not introduce a compatibility issue because the effect of this check remains conceptually the same. The check on `mStopped` is still performed before executing any logic that depends on it, ensuring similar behavior as the previous version. Therefore, it is classified as no compatibility issue, which is 0."
1254,<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(Surface)>,23,24,<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(Surface)>,<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(Surface)>,0,"{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        try {
            mRemoteDevice.prepare(streamId);
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return;
        }
    }
}","{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.prepare(streamId);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The change is the removal of a catch block for a RemoteException and thus the late version does not return early but lets any RemoteException propagate, which effectively removes a return statement. So, the code change type is 2.","The previous version catches RemoteException and does nothing (essentially ignoring it), while the new version no longer catches the exception, allowing it to propagate, possibly as an unchecked exception due to the surrounding CameraRuntimeException catch block. This is a change in exception handling behavior, leading to a different exception potentially being thrown to the caller, and thus the CI type is 2."
1255,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,23,24,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        mDeviceHandler.post(mCallOnBusy);
        // flush.
        if (mIdle) {
            mDeviceHandler.post(mCallOnIdle);
            return;
        }
        try {
            LongParcelable lastFrameNumberRef = new LongParcelable();
            mRemoteDevice.flush(/*out*/
            lastFrameNumberRef);
            if (mRepeatingRequestId != REQUEST_ID_NONE) {
                long lastFrameNumber = lastFrameNumberRef.getNumber();
                checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber);
                mRepeatingRequestId = REQUEST_ID_NONE;
            }
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return;
        }
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        mDeviceHandler.post(mCallOnBusy);
        // flush.
        if (mIdle) {
            mDeviceHandler.post(mCallOnIdle);
            return;
        }
        long lastFrameNumber = mRemoteDevice.flush();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber);
            mRepeatingRequestId = REQUEST_ID_NONE;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The control structure has changed, notably in removing the LongParcelable object and changing the flush method call to directly return a long type with the variable lastFrameNumber. Additionally, exception handling for RemoteException is no longer present, which constitutes a changed return statement and exception handling. Since the dependent API mRemoteDevice.flush() signature has changed, it is also a dependent API change. This makes the change types 1, 3, and 5.","The API previously could catch a RemoteException and just return, while in the later version, this exception would lead to a different flow (potentially propagating up), indicating a different value (no return in catch block) may be returned. Additionally, the dependent API change could lead to a different return value due to the signature and behavior difference. This makes the CI type 1."
1256,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,23,24,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                mTouchToWindowOffsetX = ev.getRawX() - mPositionX;
                mTouchToWindowOffsetY = ev.getRawY() - mPositionY;
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float rawX = ev.getRawX();
                final float rawY = ev.getRawY();
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = rawY - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = rawX - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = rawY - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY);
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp();
            mIsDragging = false;
            updateDrawable();
            break;
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable();
            break;
    }
    return true;
}","{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mLastParentXOnScreen = positionListener.getPositionXOnScreen();
                mLastParentYOnScreen = positionListener.getPositionYOnScreen();
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                mTouchToWindowOffsetX = xInWindow - mPositionX;
                mTouchToWindowOffsetY = yInWindow - mPositionY;
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = yInWindow - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = xInWindow - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = yInWindow - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY);
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp();
            mIsDragging = false;
            updateDrawable();
            break;
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable();
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The assignment statements for `mTouchToWindowOffsetX` and `mTouchToWindowOffsetY` have changed, including additional variables such as `mLastParentXOnScreen` and `mLastParentYOnScreen`. Additionally, the calculation of `xInWindow` and `yInWindow` has been introduced. Therefore, the code changes include both control dependency changes and other statement changes, hence types 3,4.","Although there are changes in the local calculations for touch coordinates and offsets, these changes do not affect the final returned value of the `onTouchEvent` method, which remains consistently `true`. Therefore, there is no Compatibility Issue, and the CI type is 0."
1257,"<android.widget.AbsListView.ListItemAccessibilityDelegate: boolean performAccessibilityAction(View,int,Bundle)>",23,24,"<android.widget.AbsListView.ListItemAccessibilityDelegate: boolean performAccessibilityAction(View,int,Bundle)>","<android.widget.AbsListView.ListItemAccessibilityDelegate: boolean performAccessibilityAction(View,int,Bundle)>",0,"{
    if (super.performAccessibilityAction(host, action, arguments)) {
        return true;
    }
    final int position = getPositionForView(host);
    final ListAdapter adapter = getAdapter();
    if ((position == INVALID_POSITION) || (adapter == null)) {
        // Cannot perform actions on invalid items.
        return false;
    }
    if (!isEnabled() || !adapter.isEnabled(position)) {
        // Cannot perform actions on disabled items.
        return false;
    }
    final long id = getItemIdAtPosition(position);
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLEAR_SELECTION:
            {
                if (getSelectedItemPosition() == position) {
                    setSelection(INVALID_POSITION);
                    return true;
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SELECT:
            {
                if (getSelectedItemPosition() != position) {
                    setSelection(position);
                    return true;
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                if (isClickable()) {
                    return performItemClick(host, position, id);
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_LONG_CLICK:
            {
                if (isLongClickable()) {
                    return performLongPress(host, position, id);
                }
            }
            return false;
    }
    return false;
}","{
    if (super.performAccessibilityAction(host, action, arguments)) {
        return true;
    }
    final int position = getPositionForView(host);
    if (position == INVALID_POSITION || mAdapter == null) {
        // Cannot perform actions on invalid items.
        return false;
    }
    if (position >= mAdapter.getCount()) {
        // click at whatever may have moved into that position.
        return false;
    }
    final boolean isItemEnabled;
    final ViewGroup.LayoutParams lp = host.getLayoutParams();
    if (lp instanceof AbsListView.LayoutParams) {
        isItemEnabled = ((AbsListView.LayoutParams) lp).isEnabled;
    } else {
        isItemEnabled = false;
    }
    if (!isEnabled() || !isItemEnabled) {
        // Cannot perform actions on disabled items.
        return false;
    }
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLEAR_SELECTION:
            {
                if (getSelectedItemPosition() == position) {
                    setSelection(INVALID_POSITION);
                    return true;
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SELECT:
            {
                if (getSelectedItemPosition() != position) {
                    setSelection(position);
                    return true;
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                if (isItemClickable(host)) {
                    final long id = getItemIdAtPosition(position);
                    return performItemClick(host, position, id);
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_LONG_CLICK:
            {
                if (isLongClickable()) {
                    final long id = getItemIdAtPosition(position);
                    return performLongPress(host, position, id);
                }
            }
            return false;
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,There are several changes across the implementation:,"2. A new check `position >= mAdapter.getCount()` is introduced to return false if the position is out of bounds, which isn't present in the early version."
1258,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",23,24,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mimeType, ""mimeType"");
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mimeType, ""mimeType"");
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        unstableProvider = null;
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}",1,"/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
","/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,,,,
1259,"<android.service.carrier.CarrierMessagingService.ICarrierMessagingWrapper: void filterSms(MessagePdu,String,int,int,ICarrierMessagingCallback)>",23,24,"<android.service.carrier.CarrierMessagingService.ICarrierMessagingWrapper: void filterSms(MessagePdu,String,int,int,ICarrierMessagingCallback)>","<android.service.carrier.CarrierMessagingService.ICarrierMessagingWrapper: void filterSms(MessagePdu,String,int,int,ICarrierMessagingCallback)>",0,"{
    onFilterSms(pdu, format, destPort, subId, new ResultCallback<Boolean>() {

        @Override
        public void onReceiveResult(final Boolean result) throws RemoteException {
            callback.onFilterComplete(result);
        }
    });
}","{
    onReceiveTextSms(pdu, format, destPort, subId, new ResultCallback<Integer>() {

        @Override
        public void onReceiveResult(Integer options) throws RemoteException {
            callback.onFilterComplete(options);
        }
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method called within the implementation has changed from `onFilterSms` to `onReceiveTextSms` and the ResultCallback generic type has changed from `Boolean` to `Integer`. Additionally, the callback method `onFilterComplete` now takes an `Integer` instead of a `Boolean`, so the change types included are 1,4,5.","The change in the generic type of ResultCallback and in the argument type passed to `onFilterComplete` method could lead to the API returning a different value (an `Integer` instead of a `Boolean`), which is a CI type of 1."
1260,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,23,24,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,0,"{
    if (mListening == listening)
        return;
    mListening = listening;
    if (listening) {
        final IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
        filter.addAction(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION);
        filter.addAction(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED);
        mContext.registerReceiver(this, filter);
    } else {
        mContext.unregisterReceiver(this);
    }
}","{
    if (mListening == listening)
        return;
    mListening = listening;
    if (listening) {
        final IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
        filter.addAction(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION);
        filter.addAction(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED);
        filter.addAction(AudioManager.STREAM_DEVICES_CHANGED_ACTION);
        mContext.registerReceiver(this, filter);
    } else {
        mContext.unregisterReceiver(this);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The addition of a new action filter.addAction(AudioManager.STREAM_DEVICES_CHANGED_ACTION) in the method relates to an other statement change in the control dependency, making it a code change type 4.","The added action to the intent filter does not cause a change in return values or exceptions thrown by the setListening method; it simply modifies the criteria that determine when the receiver should react to broadcasted intents. Therefore, there is no Compatibility Issue in this case."
1261,<android.app.WallpaperManager: void setBitmap(Bitmap)>,23,24,<android.app.WallpaperManager: void setBitmap(Bitmap)>,<android.app.WallpaperManager: void setBitmap(Bitmap)>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName());
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    setBitmap(bitmap, null, true);
}",1,"/**
 * Change the current system wallpaper to a bitmap.  The given bitmap is
 * converted to a PNG and stored as the wallpaper.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmap The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to a bitmap.  The given bitmap is
 * converted to a PNG and stored as the wallpaper.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method is equivalent to calling
 * {@link #setBitmap(Bitmap, Rect, boolean)} and passing {@code null} for the
 * {@code visibleCrop} rectangle and {@code true} for the {@code allowBackup}
 * parameter.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmap The bitmap to be used as the new system wallpaper.
 *
 * @throws IOException If an error occurs when attempting to set the wallpaper
 * to the provided image.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of the method has changed. The early version directly implemented the functionality, whereas the late version is delegating the operation using an overloaded method call setBitmap(bitmap, null, true), so the code change types are 1,5.","Since the method implementation in the late version calls a different method, setBitmap(bitmap, null, true), compared to the early version, which directly operates on sGlobals.mService, it can potentially return different results or exhibit different behaviors such as error handling, compression quality, etc., causing potential Compatibility Issues of type 1."
1262,<android.hardware.usb.UsbManager: ParcelFileDescriptor openAccessory(UsbAccessory)>,23,24,<android.hardware.usb.UsbManager: ParcelFileDescriptor openAccessory(UsbAccessory)>,<android.hardware.usb.UsbManager: ParcelFileDescriptor openAccessory(UsbAccessory)>,0,"{
    try {
        return mService.openAccessory(accessory);
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in openAccessory"", e);
        return null;
    }
}","{
    try {
        return mService.openAccessory(accessory);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Opens a file descriptor for reading and writing data to the USB accessory.
 *
 * @param accessory the USB accessory to open
 * @return file descriptor, or null if the accessor could not be opened.
 */
","/**
 * Opens a file descriptor for reading and writing data to the USB accessory.
 *
 * @param accessory the USB accessory to open
 * @return file descriptor, or null if the accessor could not be opened.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from logging an error and returning null to throwing the exception in the later version, so the code change type is 2.","Since the exception is no longer being caught and handled internally by returning null but is being propagated instead, this can lead to a different exception handling behavior for callers of the API. So the CI type is 2."
1266,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",23,24,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>","<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",0,"{
    final boolean restricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, user, restricted, mDisplay, null, Display.INVALID_DISPLAY);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, user, restricted, mDisplay, null, Display.INVALID_DISPLAY);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, user, flags, mDisplay, null, Display.INVALID_DISPLAY);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, user, flags, mDisplay, null, Display.INVALID_DISPLAY);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The code change is located in the parameters list of two new `ContextImpl` constructor calls where `restricted` has been replaced with `flags`. Since `restricted` is a boolean calculated from `flags`, changing this parameter potentially alters the behavior of the API. Additionally, there is no adaptation of the `restricted` calculation, making it an Other statement changed, so the change type is 1,4.","A change in the parameter being passed to the constructor of `ContextImpl` from a boolean `restricted` condition to directly passing the `flags` may result in the method potentially returning a `ContextImpl` with different configurations. This constitutes a change in the return value, making the CI type 1."
1267,<android.app.Activity: Uri getReferrer()>,23,24,<android.app.Activity: Uri getReferrer()>,<android.app.Activity: Uri getReferrer()>,0,"{
    Intent intent = getIntent();
    Uri referrer = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
    if (referrer != null) {
        return referrer;
    }
    String referrerName = intent.getStringExtra(Intent.EXTRA_REFERRER_NAME);
    if (referrerName != null) {
        return Uri.parse(referrerName);
    }
    if (mReferrer != null) {
        return new Uri.Builder().scheme(""android-app"").authority(mReferrer).build();
    }
    return null;
}","{
    Intent intent = getIntent();
    try {
        Uri referrer = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
        if (referrer != null) {
            return referrer;
        }
        String referrerName = intent.getStringExtra(Intent.EXTRA_REFERRER_NAME);
        if (referrerName != null) {
            return Uri.parse(referrerName);
        }
    } catch (BadParcelableException e) {
        Log.w(TAG, ""Cannot read referrer from intent;"" + "" intent extras contain unknown custom Parcelable objects"");
    }
    if (mReferrer != null) {
        return new Uri.Builder().scheme(""android-app"").authority(mReferrer).build();
    }
    return null;
}",1,"/**
 * Return information about who launched this activity.  If the launching Intent
 * contains an {@link android.content.Intent#EXTRA_REFERRER Intent.EXTRA_REFERRER},
 * that will be returned as-is; otherwise, if known, an
 * {@link Intent#URI_ANDROID_APP_SCHEME android-app:} referrer URI containing the
 * package name that started the Intent will be returned.  This may return null if no
 * referrer can be identified -- it is neither explicitly specified, nor is it known which
 * application package was involved.
 *
 * <p>If called while inside the handling of {@link #onNewIntent}, this function will
 * return the referrer that submitted that new intent to the activity.  Otherwise, it
 * always returns the referrer of the original Intent.</p>
 *
 * <p>Note that this is <em>not</em> a security feature -- you can not trust the
 * referrer information, applications can spoof it.</p>
 */
","/**
 * Return information about who launched this activity.  If the launching Intent
 * contains an {@link android.content.Intent#EXTRA_REFERRER Intent.EXTRA_REFERRER},
 * that will be returned as-is; otherwise, if known, an
 * {@link Intent#URI_ANDROID_APP_SCHEME android-app:} referrer URI containing the
 * package name that started the Intent will be returned.  This may return null if no
 * referrer can be identified -- it is neither explicitly specified, nor is it known which
 * application package was involved.
 *
 * <p>If called while inside the handling of {@link #onNewIntent}, this function will
 * return the referrer that submitted that new intent to the activity.  Otherwise, it
 * always returns the referrer of the original Intent.</p>
 *
 * <p>Note that this is <em>not</em> a security feature -- you can not trust the
 * referrer information, applications can spoof it.</p>
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"3,2",2,"The change includes the addition of a try-catch block and the movement of the existing code inside it, so the type is 3. Additionally, there is a change in exception handling where a new catch block for BadParcelableException has been added, hence the type is also 2.","The late implementation adds a catch block for BadParcelableException which was not present previously. It will catch a new exception type and log a warning instead of causing a crash or propagating the exception, which is a change in behavior when such an exception occurs. This means there is a potential Compatibility Issue caused by different exception handling. The CI type is 2."
1268,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,23,24,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                        imm.onPreWindowFocus(mView, hasWindowFocus);
                    }
                    if (mView != null) {
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_WINDOW_ANIMATION_STARTED:
            {
                int remainingFrameCount = msg.arg1;
                handleDispatchWindowAnimationStarted(remainingFrameCount);
            }
            break;
        case MSG_DISPATCH_WINDOW_ANIMATION_STOPPED:
            {
                handleDispatchWindowAnimationStopped();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeNavBar = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null && framesChanged) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                mPendingBackDropFrame.set(mWinFrame);
                // Suppress layouts during resizing - a correct layout will happen when resizing
                // is done, and this just increases system load.
                boolean isDockedDivider = mWindowAttributes.type == TYPE_DOCK_DIVIDER;
                boolean suppress = (mDragResizing && mResizeMode == RESIZE_MODE_DOCKED_DIVIDER) || isDockedDivider;
                if (!suppress) {
                    if (mView != null) {
                        forceLayout(mView);
                    }
                    requestLayout();
                } else {
                    maybeHandleWindowMove(mWinFrame);
                }
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(mTag, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(mTag, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                        imm.onPreWindowFocus(mView, hasWindowFocus);
                    }
                    if (mView != null) {
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1269,<android.content.res.Configuration: int updateFrom(Configuration)>,23,24,<android.content.res.Configuration: int updateFrom(Configuration)>,<android.content.res.Configuration: int updateFrom(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
        // If locale has changed, then layout direction is also changed ...
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
        // ... and we need to update the layout direction (represented by the first
        // 2 most significant bits in screenLayout).
        setLayoutDirection(locale);
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && (getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout))) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        // We need to preserve the previous layout dir bits if they were defined
        if ((delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) == 0) {
            screenLayout = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) | delta.screenLayout;
        } else {
            screenLayout = delta.screenLayout;
        }
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        mLocaleList = delta.mLocaleList;
        // delta.locale can't be null, since delta.mLocaleList is not empty.
        if (!delta.locale.equals(locale)) {
            locale = (Locale) delta.locale.clone();
            // If locale has changed, then layout direction is also changed ...
            changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
            // ... and we need to update the layout direction (represented by the first
            // 2 most significant bits in screenLayout).
            setLayoutDirection(locale);
        }
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && (getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout))) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        // We need to preserve the previous layout dir bits if they were defined
        if ((delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) == 0) {
            screenLayout = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) | delta.screenLayout;
        } else {
            screenLayout = delta.screenLayout;
        }
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}",1,"/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
","/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 */
",-1,,[@Config],-1,-1,-1,-1,-1,-1,,,,
1270,"<android.app.ActivityView.ActivityViewSurfaceTextureListener: void onSurfaceTextureAvailable(SurfaceTexture,int,int)>",23,24,"<android.app.ActivityView.ActivityViewSurfaceTextureListener: void onSurfaceTextureAvailable(SurfaceTexture,int,int)>","<android.app.ActivityView.ActivityViewSurfaceTextureListener: void onSurfaceTextureAvailable(SurfaceTexture,int,int)>",0,"{
    if (mActivityContainer == null) {
        return;
    }
    if (DEBUG)
        Log.d(TAG, ""onSurfaceTextureAvailable: width="" + width + "" height="" + height);
    mWidth = width;
    mHeight = height;
    attachToSurfaceWhenReady();
    if (mActivityViewCallback != null) {
        mActivityViewCallback.onSurfaceAvailable(ActivityView.this);
    }
}","{
    if (mActivityContainer == null) {
        return;
    }
    if (DEBUG)
        Log.d(TAG, ""onSurfaceTextureAvailable: width="" + width + "" height="" + height);
    mWidth = width;
    mHeight = height;
    mSurface = new Surface(surfaceTexture);
    setSurfaceAsync(mSurface, mWidth, mHeight, mDensityDpi, true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method no longer calls attachToSurfaceWhenReady() and the if block checking for the mActivityViewCallback. Instead, it now creates a new Surface with the given surfaceTexture and calls setSurfaceAsync() with additional parameters. Therefore, since there are changes in the method body that are not related to return statements or exception handling, the change type is 4.","There are no changes in the return type or exception handling; the method's signature and annotations remain unchanged. Moreover, the control flow of the method does not change in a way that would affect its external behavior; hence, there is no Compatibility Issue caused by potential different return values or potential different exception handlings. The changes are internal to the method's implementation and do not affect how the method behaves from the caller's perspective. The compatibility remains the same. Therefore, the CI type is 0."
1272,<android.speech.tts.FileSynthesisCallback: void stop()>,23,24,<android.speech.tts.FileSynthesisCallback: void stop()>,<android.speech.tts.FileSynthesisCallback: void stop()>,0,"{
    synchronized (mStateLock) {
        if (mDone) {
            return;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            return;
        }
        mStatusCode = TextToSpeech.STOPPED;
        cleanUp();
        if (mDispatcher != null) {
            mDispatcher.dispatchOnStop();
        }
    }
}","{
    synchronized (mStateLock) {
        if (mDone) {
            return;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            return;
        }
        mStatusCode = TextToSpeech.STOPPED;
        cleanUp();
        mDispatcher.dispatchOnStop();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change between these two versions is the null check for mDispatcher being removed. This is classified as an 'Other statement changed' because it doesn't involve return statements, exception handling, control dependencies, or dependent APIs.","Because the removal of the null check for mDispatcher does not alter the method's return value and does not introduce a new exception handling, there's no Compatibility Issue identified. Assuming that mDispatcher must not be null at this point in the code (perhaps enforced elsewhere), this change should not introduce any new behaviors as far as client code is concerned."
1274,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",23,24,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>","<android.app.ContextImpl: void sendBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `intent.prepareToLeaveProcess()` now takes `this` as an argument instead of no arguments. This is an internal change to the API, so the change type is 4. Additionally, the dependent API `prepareToLeaveProcess()` has changed, since the method signature now accepts an additional parameter, so the change type is also 5.","There's no Compatibility Issue because this change does not affect the behavior of `sendBroadcast()` from the caller's perspective. The addition of the context parameter to `intent.prepareToLeaveProcess()` does not alter the control flow, nor does it change the exceptions thrown or the values returned by `sendBroadcast()`; the `try` block's behavior remains unchanged for the caller, and the exception handling is consistent between versions. Hence, the CI type is 0."
1277,<android.accounts.AccountManager: boolean notifyAccountAuthenticated(Account)>,23,24,<android.accounts.AccountManager: boolean notifyAccountAuthenticated(Account)>,<android.accounts.AccountManager: boolean notifyAccountAuthenticated(Account)>,0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.accountAuthenticated(account);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.accountAuthenticated(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Notifies the system that the account has just been authenticated. This
 * information may be used by other applications to verify the account. This
 * should be called only when the user has entered correct credentials for
 * the account.
 * <p>
 * It is not safe to call this method from the main thread. As such, call it
 * from another thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * @param account The {@link Account} to be updated.
 * @return boolean {@code true} if the authentication of the account has been successfully
 * acknowledged. Otherwise {@code false}.
 */
","/**
 * Notifies the system that the account has just been authenticated. This
 * information may be used by other applications to verify the account. This
 * should be called only when the user has entered correct credentials for
 * the account.
 * <p>
 * It is not safe to call this method from the main thread. As such, call it
 * from another thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * @param account The {@link Account} to be updated.
 * @return boolean {@code true} if the authentication of the account has been successfully
 * acknowledged. Otherwise {@code false}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from ""throw new RuntimeException(e);"" to ""throw e.rethrowFromSystemServer();"", therefore the code change type is 2 (Exception handling statement changed).","As the way the exception is re-thrown has changed, the late version may throw an exception of a different type or with different characteristics. This change could lead to different exception handling behavior when the API is called, so the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
1279,<android.app.Dialog: void show()>,23,24,<android.app.Dialog: void show()>,<android.app.Dialog: void show()>,0,"{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new WindowDecorActionBar(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}","{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new WindowDecorActionBar(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    mWindowManager.addView(mDecor, l);
    mShowing = true;
    sendShowMessage();
}",1,"/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
","/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The code change type is 2,3 because the try-finally block was removed, which affects the exception handling (so there's an 'Exception handling statement changed'), and the control flow structure has been simplified (removing the finally block is a 'Control dependency change').","Since the early version wraps the call to 'mWindowManager.addView(mDecor, l);' inside a try-finally block without a catch block, and the late version removes this block, it could potentially lead to a difference in exception handling behavior (the early version would execute the 'finally' block even if an exception was thrown, while the late version could propagate the exception without such handling). Thus, the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
1281,<android.view.View: boolean post(Runnable)>,23,24,<android.view.View: boolean post(Runnable)>,<android.view.View: boolean post(Runnable)>,0,"{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler.post(action);
    }
    // Assume that post will succeed later
    ViewRootImpl.getRunQueue().post(action);
    return true;
}","{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler.post(action);
    }
    // Postpone the runnable until we know on which thread it needs to run.
    // Assume that the runnable will be successfully placed after attach.
    getRunQueue().post(action);
    return true;
}",1,"/**
 * <p>Causes the Runnable to be added to the message queue.
 * The runnable will be run on the user interface thread.</p>
 *
 * @param action The Runnable that will be executed.
 *
 * @return Returns true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.
 *
 * @see #postDelayed
 * @see #removeCallbacks
 */
","/**
 * <p>Causes the Runnable to be added to the message queue.
 * The runnable will be run on the user interface thread.</p>
 *
 * @param action The Runnable that will be executed.
 *
 * @return Returns true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.
 *
 * @see #postDelayed
 * @see #removeCallbacks
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the View.post(Runnable) method has slightly changed, with the specific change being the removal of the ViewRootImpl class qualifier from the call to getRunQueue().post(action). Instead, it now directly calls getRunQueue().post(action), indicating that a separate getRunQueue() method may now exist within the View class that wasn't there before, or it's utilizing an inherited method from a parent class. Therefore, the implementation detail of how getRunQueue() is accessed has been modified, which is classified as code change type 4 (Other statement changed). It also involves a dependent API change because the call to get the run queue no longer explicitly specifies the ViewRootImpl class, constituting a change type 5 (Dependent API changed).","There is no Compatibility Issue detected with this change. Despite the change in how the run queue is accessed, the behavior from the perspective of code that calls View.post(Runnable) remains the same: if mAttachInfo is not null, it will post the Runnable using the handler; otherwise, it will post the Runnable to some queue to be run later and return true. The change doesn't affect the method's return type, values, or the exceptions thrown, therefore no Compatibility Issue exists of type 1 or 2."
1283,<android.service.notification.StatusBarNotification: String toString()>,23,24,<android.service.notification.StatusBarNotification: String toString()>,<android.service.notification.StatusBarNotification: String toString()>,0,"{
    return String.format(""StatusBarNotification(pkg=%s user=%s id=%d tag=%s score=%d key=%s: %s)"", this.pkg, this.user, this.id, this.tag, this.score, this.key, this.notification);
}","{
    return String.format(""StatusBarNotification(pkg=%s user=%s id=%d tag=%s key=%s: %s)"", this.pkg, this.user, this.id, this.tag, this.key, this.notification);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change in the code is the removal of the 'score' part from the string format in the return statement. This change does not affect the return type, but the value of the string returned by the method is different. However, since `toString()` methods are typically used for debugging or logging purposes and not for program logic, this kind of change is generally not considered to cause a compatibility issue. Therefore, the change type is 4, indicating ""Other statement changed"".","No Compatibility Issue arises from this change because the method's behavior, in terms of execution flow or outcomes significant to program logic (such as exceptions thrown or types/values returned that are used programmatically), has not changed. It is assumed that this amendment to the `toString()` method will not break existing code as it is not meant to be relied upon for program behavior. Thus, CI type is 0."
1284,"<android.app.Notification.Builder: Builder setLights(int,int,int)>",23,24,"<android.app.Notification.Builder: Builder setLights(int,int,int)>","<android.app.Notification.Builder: Builder setLights(int,int,int)>",0,"{
    mLedArgb = argb;
    mLedOnMs = onMs;
    mLedOffMs = offMs;
    return this;
}","{
    mN.ledARGB = argb;
    mN.ledOnMS = onMs;
    mN.ledOffMS = offMs;
    if (onMs != 0 || offMs != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    return this;
}",1,"/**
 * Set the desired color for the indicator LED on the device, as well as the
 * blink duty cycle (specified in milliseconds).
 *
 * Not all devices will honor all (or even any) of these values.
 *
 * @see Notification#ledARGB
 * @see Notification#ledOnMS
 * @see Notification#ledOffMS
 */
","/**
 * Set the desired color for the indicator LED on the device, as well as the
 * blink duty cycle (specified in milliseconds).
 *
 * Not all devices will honor all (or even any) of these values.
 *
 * @see Notification#ledARGB
 * @see Notification#ledOnMS
 * @see Notification#ledOffMS
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The members where the ARGB, onMs, and offMs are saved have changed, and a new conditional control flow is introduced for setting a flag. The code change types are 3 for the added 'if' control flow and 4 for the assignment statement changes.","There is no compatibility issue here because the return type is the Builder itself, which is not affected by the internal state changes, and the new conditional does not impact the return type or throw a new exception. The changes to where the LED settings are kept or the condition that sets a flag are internal implementation details and do not affect the output of the method 'setLights', which continues to return 'this' (the Builder object)."
1285,"<android.os.Binder: boolean onTransact(int,Parcel,Parcel,int)>",23,24,"<android.os.Binder: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.Binder: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    if (code == INTERFACE_TRANSACTION) {
        reply.writeString(getInterfaceDescriptor());
        return true;
    } else if (code == DUMP_TRANSACTION) {
        ParcelFileDescriptor fd = data.readFileDescriptor();
        String[] args = data.readStringArray();
        if (fd != null) {
            try {
                dump(fd.getFileDescriptor(), args);
            } finally {
                try {
                    fd.close();
                } catch (IOException e) {
                // swallowed, not propagated back to the caller
                }
            }
        }
        // Write the StrictMode header.
        if (reply != null) {
            reply.writeNoException();
        } else {
            StrictMode.clearGatheredViolations();
        }
        return true;
    }
    return false;
}","{
    if (code == INTERFACE_TRANSACTION) {
        reply.writeString(getInterfaceDescriptor());
        return true;
    } else if (code == DUMP_TRANSACTION) {
        ParcelFileDescriptor fd = data.readFileDescriptor();
        String[] args = data.readStringArray();
        if (fd != null) {
            try {
                dump(fd.getFileDescriptor(), args);
            } finally {
                IoUtils.closeQuietly(fd);
            }
        }
        // Write the StrictMode header.
        if (reply != null) {
            reply.writeNoException();
        } else {
            StrictMode.clearGatheredViolations();
        }
        return true;
    } else if (code == SHELL_COMMAND_TRANSACTION) {
        ParcelFileDescriptor in = data.readFileDescriptor();
        ParcelFileDescriptor out = data.readFileDescriptor();
        ParcelFileDescriptor err = data.readFileDescriptor();
        String[] args = data.readStringArray();
        ResultReceiver resultReceiver = ResultReceiver.CREATOR.createFromParcel(data);
        try {
            if (out != null) {
                shellCommand(in != null ? in.getFileDescriptor() : null, out.getFileDescriptor(), err != null ? err.getFileDescriptor() : out.getFileDescriptor(), args, resultReceiver);
            }
        } finally {
            IoUtils.closeQuietly(in);
            IoUtils.closeQuietly(out);
            IoUtils.closeQuietly(err);
            // Write the StrictMode header.
            if (reply != null) {
                reply.writeNoException();
            } else {
                StrictMode.clearGatheredViolations();
            }
        }
        return true;
    }
    return false;
}",1,"/**
 * Default implementation is a stub that returns false.  You will want
 * to override this to do the appropriate unmarshalling of transactions.
 *
 * <p>If you want to call this, call transact().
 */
","/**
 * Default implementation is a stub that returns false.  You will want
 * to override this to do the appropriate unmarshalling of transactions.
 *
 * <p>If you want to call this, call transact().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The late version includes a new branch for handling `SHELL_COMMAND_TRANSACTION`, involved new control structures, calls to IoUtils.closeQuietly() instead of an empty try-catch for closing the ParcelFileDescriptor, and also a new call to shellCommand(). This covers changes in exception handling statement (replacement of the try-catch with IoUtils.closeQuietly), the introduction new control statement (else if branch for `SHELL_COMMAND_TRANSACTION`), other statements (IoUtils calls and shellCommand invocation), and dependent API changes (invoking new methods not present in earlier version). The change type is 1,3,4,5.","Since new functionality has been introduced (handling of `SHELL_COMMAND_TRANSACTION`) that was not present in the earlier version, and the manner of closing resources has been changed (which affects the flow of the method), the API can result in different behavior including return values (`return true`) when SHELL_COMMAND_TRANSACTION is passed as the code. Therefore, the CI type is 1."
1287,"<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>",23,24,"<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>","<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>",0,"{
    synchronized (this) {
        TypedValue tmpValue = mValue;
        int block = loadResourceBagValue(ident, bagEntryId, tmpValue, true);
        if (block >= 0) {
            if (tmpValue.type == TypedValue.TYPE_STRING) {
                return mStringBlocks[block].get(tmpValue.data);
            }
            return tmpValue.coerceToString();
        }
    }
    return null;
}","{
    synchronized (this) {
        final TypedValue outValue = mValue;
        final int block = loadResourceBagValue(resId, bagEntryId, outValue, true);
        if (block < 0) {
            return null;
        }
        if (outValue.type == TypedValue.TYPE_STRING) {
            return mStringBlocks[block].get(outValue.data);
        }
        return outValue.coerceToString();
    }
}",1,"/*package*/
","/**
 * Retrieves the string value associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param bagEntryId
 * @return the string value, or {@code null}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,0,0,"There are no changes to the method's implementation; only the variable name within the implementation was made more specific from ""tmpValue"" to ""outValue,"" and this doesn't affect the API behavior.","Since there is no actual change in what the method does or returns, and no new exceptions have been introduced, there is no Compatibility Issue between versions 23 and 24 for this method."
1288,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",23,24,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>","<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The Exception handling statement has changed as now in the late version it rethrows a RemoteException using throw e.rethrowFromSystemServer(), making the change type 2.","Previously, the RemoteException was caught and ignored, but in the late version, it's being rethrown, which changes the exception handling behavior of the method. Therefore, a Compatibility Issue arises due to the potential of different exception handlings causing the CI type to be 2."
1289,<android.app.ContextImpl: String[] databaseList()>,23,24,<android.app.ContextImpl: String[] databaseList()>,<android.app.ContextImpl: String[] databaseList()>,0,"{
    final String[] list = getDatabasesDir().list();
    return (list != null) ? list : EMPTY_STRING_ARRAY;
}","{
    return FileUtils.listOrEmpty(getDatabasesDir());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation's return statement now calls `FileUtils.listOrEmpty(getDatabasesDir())` instead of the inline ternary operation that was used earlier. Additionally, this change relies on 'FileUtils.listOrEmpty', which indicates a dependent API change, therefore the change types are 4,5.","There is no indication that the behavior of `FileUtils.listOrEmpty` would cause a Compatibility Issue; it likely serves the same purpose as the earlier inline ternary operation, which is to return either the file list or an empty array if the file list is `null`. Therefore, the expected behavior of the API hasn't changed, and there should be no Compatibility Issue."
1290,<android.widget.ZoomButton: boolean onLongClick(View)>,23,24,<android.widget.ZoomButton: boolean onLongClick(View)>,<android.widget.ZoomButton: boolean onLongClick(View)>,0,"{
    mIsInLongpress = true;
    mHandler.post(mRunnable);
    return true;
}","{
    mIsInLongpress = true;
    post(mRunnable);
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method used for posting a runnable has changed from mHandler.post(mRunnable) to post(mRunnable), but the logic and behaviour seem consistent, hence it’s an Other statement changed (4).",There doesn't appear to be a compatibility issue here because the ultimate outcome of onLongClick and the return value remain unchanged; both execute a runnable and return true (0).
1291,<android.app.NotificationManager: Policy getNotificationPolicy()>,23,24,<android.app.NotificationManager: Policy getNotificationPolicy()>,<android.app.NotificationManager: Policy getNotificationPolicy()>,0,"{
    INotificationManager service = getService();
    try {
        return service.getNotificationPolicy(mContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return null;
}","{
    INotificationManager service = getService();
    try {
        return service.getNotificationPolicy(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the current notification policy.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */
","/**
 * Gets the current notification policy.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The change is in the exception handling statement where the early version does not throw any exception in the catch block, whereas the late version throws an exception using `throw e.rethrowFromSystemServer()`. So the code change type is 2.","The introduction of a throw statement in the catch block in the late version creates a Compatibility Issue due to potentially different exception handlings. The API may now throw a RuntimeException wrapping the RemoteException, which it previously did not, and hence, the CI type is 2."
1292,"<android.app.ActivityManager: int addAppTask(Activity,Intent,TaskDescription,Bitmap)>",23,24,"<android.app.ActivityManager: int addAppTask(Activity,Intent,TaskDescription,Bitmap)>","<android.app.ActivityManager: int addAppTask(Activity,Intent,TaskDescription,Bitmap)>",0,"{
    Point size;
    synchronized (this) {
        ensureAppTaskThumbnailSizeLocked();
        size = mAppTaskThumbnailSize;
    }
    final int tw = thumbnail.getWidth();
    final int th = thumbnail.getHeight();
    if (tw != size.x || th != size.y) {
        Bitmap bm = Bitmap.createBitmap(size.x, size.y, thumbnail.getConfig());
        // Use ScaleType.CENTER_CROP, except we leave the top edge at the top.
        float scale;
        float dx = 0, dy = 0;
        if (tw * size.x > size.y * th) {
            scale = (float) size.x / (float) th;
            dx = (size.y - tw * scale) * 0.5f;
        } else {
            scale = (float) size.y / (float) tw;
            dy = (size.x - th * scale) * 0.5f;
        }
        Matrix matrix = new Matrix();
        matrix.setScale(scale, scale);
        matrix.postTranslate((int) (dx + 0.5f), 0);
        Canvas canvas = new Canvas(bm);
        canvas.drawBitmap(thumbnail, matrix, null);
        canvas.setBitmap(null);
        thumbnail = bm;
    }
    if (description == null) {
        description = new TaskDescription();
    }
    try {
        return ActivityManagerNative.getDefault().addAppTask(activity.getActivityToken(), intent, description, thumbnail);
    } catch (RemoteException e) {
        throw new IllegalStateException(""System dead?"", e);
    }
}","{
    Point size;
    synchronized (this) {
        ensureAppTaskThumbnailSizeLocked();
        size = mAppTaskThumbnailSize;
    }
    final int tw = thumbnail.getWidth();
    final int th = thumbnail.getHeight();
    if (tw != size.x || th != size.y) {
        Bitmap bm = Bitmap.createBitmap(size.x, size.y, thumbnail.getConfig());
        // Use ScaleType.CENTER_CROP, except we leave the top edge at the top.
        float scale;
        float dx = 0, dy = 0;
        if (tw * size.x > size.y * th) {
            scale = (float) size.x / (float) th;
            dx = (size.y - tw * scale) * 0.5f;
        } else {
            scale = (float) size.y / (float) tw;
            dy = (size.x - th * scale) * 0.5f;
        }
        Matrix matrix = new Matrix();
        matrix.setScale(scale, scale);
        matrix.postTranslate((int) (dx + 0.5f), 0);
        Canvas canvas = new Canvas(bm);
        canvas.drawBitmap(thumbnail, matrix, null);
        canvas.setBitmap(null);
        thumbnail = bm;
    }
    if (description == null) {
        description = new TaskDescription();
    }
    try {
        return ActivityManagerNative.getDefault().addAppTask(activity.getActivityToken(), intent, description, thumbnail);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Add a new {@link AppTask} for the calling application.  This will create a new
 * recents entry that is added to the <b>end</b> of all existing recents.
 *
 * @param activity The activity that is adding the entry.   This is used to help determine
 * the context that the new recents entry will be in.
 * @param intent The Intent that describes the recents entry.  This is the same Intent that
 * you would have used to launch the activity for it.  In generally you will want to set
 * both {@link Intent#FLAG_ACTIVITY_NEW_DOCUMENT} and
 * {@link Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS}; the latter is required since this recents
 * entry will exist without an activity, so it doesn't make sense to not retain it when
 * its activity disappears.  The given Intent here also must have an explicit ComponentName
 * set on it.
 * @param description Optional additional description information.
 * @param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
 * {@link #getAppTaskThumbnailSize()}.  If the bitmap is not that exact size, it will be
 * recreated in your process, probably in a way you don't like, before the recents entry
 * is added.
 *
 * @return Returns the task id of the newly added app task, or -1 if the add failed.  The
 * most likely cause of failure is that there is no more room for more tasks for your app.
 */
","/**
 * Add a new {@link AppTask} for the calling application.  This will create a new
 * recents entry that is added to the <b>end</b> of all existing recents.
 *
 * @param activity The activity that is adding the entry.   This is used to help determine
 * the context that the new recents entry will be in.
 * @param intent The Intent that describes the recents entry.  This is the same Intent that
 * you would have used to launch the activity for it.  In generally you will want to set
 * both {@link Intent#FLAG_ACTIVITY_NEW_DOCUMENT} and
 * {@link Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS}; the latter is required since this recents
 * entry will exist without an activity, so it doesn't make sense to not retain it when
 * its activity disappears.  The given Intent here also must have an explicit ComponentName
 * set on it.
 * @param description Optional additional description information.
 * @param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
 * {@link #getAppTaskThumbnailSize()}.  If the bitmap is not that exact size, it will be
 * recreated in your process, probably in a way you don't like, before the recents entry
 * is added.
 *
 * @return Returns the task id of the newly added app task, or -1 if the add failed.  The
 * most likely cause of failure is that there is no more room for more tasks for your app.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The only change between the two versions is the exception handling statement. In the early version, the RemoteException is caught and a new IllegalStateException is thrown, while in the late version, the RemoteException is re-thrown after being wrapped with a system server check.","The change in the exception handling could lead to a different exception being thrown when the late version of the API is invoked compared to the early version, which suggests a potential Compatibility Issue related to different exception handlings. Thus, the CI type is 2."
1293,"<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int[],RemoteViews)>",23,24,"<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int[],RemoteViews)>","<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int[],RemoteViews)>",0,"{
    if (mService == null) {
        return;
    }
    try {
        mService.partiallyUpdateAppWidgetIds(mPackageName, appWidgetIds, views);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.partiallyUpdateAppWidgetIds(mPackageName, appWidgetIds, views);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Perform an incremental update or command on the widget(s) specified by appWidgetIds.
 * <p>
 * This update  differs from {@link #updateAppWidget(int[], RemoteViews)} in that the
 * RemoteViews object which is passed is understood to be an incomplete representation of the
 * widget, and hence does not replace the cached representation of the widget. As of API
 * level 17, the new properties set within the views objects will be appended to the cached
 * representation of the widget, and hence will persist.
 *
 * Use with {@link RemoteViews#showNext(int)}, {@link RemoteViews#showPrevious(int)},
 * {@link RemoteViews#setScrollPosition(int, int)} and similar commands.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * This method will be ignored if a widget has not received a full update via
 * {@link #updateAppWidget(int[], RemoteViews)}.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views            The RemoteViews object containing the incremental update / command.
 */
","/**
 * Perform an incremental update or command on the widget(s) specified by appWidgetIds.
 * <p>
 * This update  differs from {@link #updateAppWidget(int[], RemoteViews)} in that the
 * RemoteViews object which is passed is understood to be an incomplete representation of the
 * widget, and hence does not replace the cached representation of the widget. As of API
 * level 17, the new properties set within the views objects will be appended to the cached
 * representation of the widget, and hence will persist.
 *
 * Use with {@link RemoteViews#showNext(int)}, {@link RemoteViews#showPrevious(int)},
 * {@link RemoteViews#setScrollPosition(int, int)} and similar commands.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * This method will be ignored if a widget has not received a full update via
 * {@link #updateAppWidget(int[], RemoteViews)}.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views            The RemoteViews object containing the incremental update / command.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from throwing a new RuntimeException to throwing the result of e.rethrowFromSystemServer(), so the code change type is 2.","Since the exception handling now rethrows the RemoteException as a RuntimeException with a specific message in the new version, it will behave differently from the old version. Therefore, the change may lead to a Compatibility Issue caused by potential different exception handlings, and the CI type is 2."
1294,<android.content.ClipboardManager: ClipData getPrimaryClip()>,23,24,<android.content.ClipboardManager: ClipData getPrimaryClip()>,<android.content.ClipboardManager: ClipData getPrimaryClip()>,0,"{
    try {
        return getService().getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return getService().getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the current primary clip on the clipboard.
 */
","/**
 * Returns the current primary clip on the clipboard.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. Instead of returning null in the early version, the late version throws a wrapped exception, so the change type is 2.","The late version API will throw a RuntimeException when encountering a RemoteException, unlike the early version API, which used to return null. This leads to different exception handling behavior, therefore, the CI type is 2."
1295,<android.hardware.camera2.DngCreator: DngCreator setOrientation(int)>,23,24,<android.hardware.camera2.DngCreator: DngCreator setOrientation(int)>,<android.hardware.camera2.DngCreator: DngCreator setOrientation(int)>,0,"{
    if (orientation < ExifInterface.ORIENTATION_UNDEFINED || orientation > ExifInterface.ORIENTATION_ROTATE_270) {
        throw new IllegalArgumentException(""Orientation "" + orientation + "" is not a valid EXIF orientation value"");
    }
    nativeSetOrientation(orientation);
    return this;
}","{
    if (orientation < ExifInterface.ORIENTATION_UNDEFINED || orientation > ExifInterface.ORIENTATION_ROTATE_270) {
        throw new IllegalArgumentException(""Orientation "" + orientation + "" is not a valid EXIF orientation value"");
    }
    // ""Unknown"" orientation; other values map directly
    if (orientation == ExifInterface.ORIENTATION_UNDEFINED) {
        orientation = TAG_ORIENTATION_UNKNOWN;
    }
    nativeSetOrientation(orientation);
    return this;
}",1,"/**
 * Set the orientation value to write.
 *
 * <p>
 * This will be written as the TIFF ""Orientation"" tag {@code (0x0112)}.
 * Calling this will override any prior settings for this tag.
 * </p>
 *
 * @param orientation the orientation value to set, one of:
 * <ul>
 * <li>{@link android.media.ExifInterface#ORIENTATION_NORMAL}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_FLIP_HORIZONTAL}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_180}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_FLIP_VERTICAL}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_TRANSPOSE}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_90}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_TRANSVERSE}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_270}</li>
 * </ul>
 * @return this {@link #DngCreator} object.
 */
","/**
 * Set the orientation value to write.
 *
 * <p>
 * This will be written as the TIFF ""Orientation"" tag {@code (0x0112)}.
 * Calling this will override any prior settings for this tag.
 * </p>
 *
 * @param orientation the orientation value to set, one of:
 * <ul>
 * <li>{@link android.media.ExifInterface#ORIENTATION_NORMAL}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_FLIP_HORIZONTAL}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_180}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_FLIP_VERTICAL}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_TRANSPOSE}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_90}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_TRANSVERSE}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_270}</li>
 * </ul>
 * @return this {@link #DngCreator} object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"There is an additional condition and assignment to the 'orientation' variable, which is neither a return statement nor an exception handling statement but is a control dependency change and an other statement change, thus the change type is 3,4.","This change should not cause an API compatibility issue because the API early implementation and the late implementation both throw the same IllegalArgumentException for invalid 'orientation' values. The additional assignment when 'orientation' equals ExifInterface.ORIENTATION_UNDEFINED does not alter the initial contract of the method, and it still returns 'this' after setting the orientation (modified or not), which means the method behavior and its contract stay consistent between the versions. Therefore, the CI type is 0."
1296,<android.widget.DayPickerPagerAdapter: CharSequence getPageTitle(int)>,23,24,<android.widget.DayPickerPagerAdapter: CharSequence getPageTitle(int)>,<android.widget.DayPickerPagerAdapter: CharSequence getPageTitle(int)>,0,"{
    final SimpleMonthView v = mItems.get(position).calendar;
    if (v != null) {
        return v.getTitle();
    }
    return null;
}","{
    final SimpleMonthView v = mItems.get(position).calendar;
    if (v != null) {
        return v.getMonthYearLabel();
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement inside the 'if' condition has changed from 'v.getTitle()' to 'v.getMonthYearLabel()', which indicates that the method being called on the object 'v' has changed. This is a type of dependent API change and the statement within the method has changed as well, hence the code change type is 1,5.","Since the method being called to retrieve the title has changed from 'getTitle()' to 'getMonthYearLabel()', it implies that the return value may potentially be different. Therefore, this constitutes a Compatibility Issue of type 1, due to potentially different return values."
1297,<android.app.admin.DevicePolicyManager: List<String> getPermittedAccessibilityServices(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: List<String> getPermittedAccessibilityServices(ComponentName)>,<android.app.admin.DevicePolicyManager: List<String> getPermittedAccessibilityServices(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPermittedAccessibilityServices(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return null;
}","{
    throwIfParentInstance(""getPermittedAccessibilityServices"");
    if (mService != null) {
        try {
            return mService.getPermittedAccessibilityServices(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Returns the list of permitted accessibility services set by this device or profile owner.
 *
 * <p>An empty list means no accessibility services except system services are allowed.
 * Null means all accessibility services are allowed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return List of accessiblity service package names.
 */
","/**
 * Returns the list of permitted accessibility services set by this device or profile owner.
 * <p>
 * An empty list means no accessibility services except system services are allowed. Null means
 * all accessibility services are allowed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return List of accessiblity service package names.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is a new invocation of a method throwIfParentInstance(""getPermittedAccessibilityServices"") at the beginning of the method, along with a new exception handling approach for RemoteException, so the code change types are 2 (Exception handling statement changed) and 4 (Other statement changed).","The introduction of a new method call that throws an exception represents a behavioral change that could lead to a CI, especially because the caller will now receive an exception instead of a null value if this service is used from within a ""parent instance"". Moreover, the change in the exception handling mechanism from logging the RemoteException to rethrowing it also creates a different exception being thrown to the caller, which is another CI. Therefore, the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
1299,"<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>",23,24,"<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    if (useIcons) {
        final Context ctx = target.getContext();
        final Drawable id1 = i1 == null ? null : i1.loadDrawable(ctx);
        final Drawable id2 = i2 == null ? null : i2.loadDrawable(ctx);
        final Drawable id3 = i3 == null ? null : i3.loadDrawable(ctx);
        final Drawable id4 = i4 == null ? null : i4.loadDrawable(ctx);
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(id1, id2, id3, id4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(id1, id2, id3, id4);
        }
    } else {
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(d1, d2, d3, d4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(d1, d2, d3, d4);
        }
    }
}","{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    if (drawablesLoaded) {
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(id1, id2, id3, id4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(id1, id2, id3, id4);
        }
    } else if (useIcons) {
        final Context ctx = target.getContext();
        final Drawable id1 = i1 == null ? null : i1.loadDrawable(ctx);
        final Drawable id2 = i2 == null ? null : i2.loadDrawable(ctx);
        final Drawable id3 = i3 == null ? null : i3.loadDrawable(ctx);
        final Drawable id4 = i4 == null ? null : i4.loadDrawable(ctx);
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(id1, id2, id3, id4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(id1, id2, id3, id4);
        }
    } else {
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(d1, d2, d3, d4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(d1, d2, d3, d4);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There's a change in the control dependency with the addition of the 'drawablesLoaded' condition, and variables 'id1', 'id2', 'id3', and 'id4' are now initialized outside of the 'useIcons' condition when 'drawablesLoaded' is true. Also, there are several members removed (i1, i2, i3, i4) which are not used elsewhere in the Late_Implementation. These changes are classified as 'Other statement changed' because there's a restructuring of the code that doesn't fit into the other categories. So, the code change types are 3 and 4.","Despite the structural changes within the method, the behavior of the API should remain consistent across versions because the use of either 'drawablesLoaded' or 'useIcons' results in setting the drawables on the TextView in the same way as before. Since the final outcome of applying the drawables to the target TextView is not affected, there is no Compatibility Issue; hence the CI type is 0."
1300,"<android.inputmethodservice.InputMethodService: boolean doMovementKey(int,KeyEvent,int)>",23,24,"<android.inputmethodservice.InputMethodService: boolean doMovementKey(int,KeyEvent,int)>","<android.inputmethodservice.InputMethodService: boolean doMovementKey(int,KeyEvent,int)>",0,"{
    final ExtractEditText eet = getExtractEditTextIfVisible();
    if (eet != null) {
        // If we are in fullscreen mode, the cursor will move around
        // the extract edit text, but should NOT cause focus to move
        // to other fields.
        MovementMethod movement = eet.getMovementMethod();
        Layout layout = eet.getLayout();
        if (movement != null && layout != null) {
            // cursor will properly move in our own word wrapping.
            if (count == MOVEMENT_DOWN) {
                if (movement.onKeyDown(eet, (Spannable) eet.getText(), keyCode, event)) {
                    reportExtractedMovement(keyCode, 1);
                    return true;
                }
            } else if (count == MOVEMENT_UP) {
                if (movement.onKeyUp(eet, (Spannable) eet.getText(), keyCode, event)) {
                    return true;
                }
            } else {
                if (movement.onKeyOther(eet, (Spannable) eet.getText(), event)) {
                    reportExtractedMovement(keyCode, count);
                } else {
                    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
                    if (movement.onKeyDown(eet, (Spannable) eet.getText(), keyCode, down)) {
                        KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
                        movement.onKeyUp(eet, (Spannable) eet.getText(), keyCode, up);
                        while (--count > 0) {
                            movement.onKeyDown(eet, (Spannable) eet.getText(), keyCode, down);
                            movement.onKeyUp(eet, (Spannable) eet.getText(), keyCode, up);
                        }
                        reportExtractedMovement(keyCode, count);
                    }
                }
            }
        }
        // we never allow DPAD navigation to the application.
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_DOWN:
                return true;
        }
    }
    return false;
}","{
    final ExtractEditText eet = getExtractEditTextIfVisible();
    if (eet != null) {
        // If we are in fullscreen mode, the cursor will move around
        // the extract edit text, but should NOT cause focus to move
        // to other fields.
        MovementMethod movement = eet.getMovementMethod();
        Layout layout = eet.getLayout();
        if (movement != null && layout != null) {
            // cursor will properly move in our own word wrapping.
            if (count == MOVEMENT_DOWN) {
                if (movement.onKeyDown(eet, eet.getText(), keyCode, event)) {
                    reportExtractedMovement(keyCode, 1);
                    return true;
                }
            } else if (count == MOVEMENT_UP) {
                if (movement.onKeyUp(eet, eet.getText(), keyCode, event)) {
                    return true;
                }
            } else {
                if (movement.onKeyOther(eet, eet.getText(), event)) {
                    reportExtractedMovement(keyCode, count);
                } else {
                    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
                    if (movement.onKeyDown(eet, eet.getText(), keyCode, down)) {
                        KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
                        movement.onKeyUp(eet, eet.getText(), keyCode, up);
                        while (--count > 0) {
                            movement.onKeyDown(eet, eet.getText(), keyCode, down);
                            movement.onKeyUp(eet, eet.getText(), keyCode, up);
                        }
                        reportExtractedMovement(keyCode, count);
                    }
                }
            }
        }
        // we never allow DPAD navigation to the application.
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_DOWN:
                return true;
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code has changed where casts to `Spannable` have been removed in the calls to `movement.onKeyDown` and `movement.onKeyUp`. This is a change in any other statement and control dependencies because the `getText()` method calls are now outside of the condition checks for specific movement count values. However, assuming that the `getText()` method always returns a `Spannable` instance, this change is merely a refactoring and should not change behavior since `eet.getText()` should have the same runtime type regardless of the casting.","There is no Compatibility Issue in this case because the removal of the cast to `Spannable` should not affect the runtime behavior as long as the object returned from `eet.getText()` is indeed a `Spannable`. If `eet.getText()` always returns a `Spannable`, then the cast is unnecessary, and its removal doesn't change the method's logic or the values it returns."
1303,"<android.app.KeyguardManager: Intent createConfirmDeviceCredentialIntent(CharSequence,CharSequence)>",23,24,"<android.app.KeyguardManager: Intent createConfirmDeviceCredentialIntent(CharSequence,CharSequence)>","<android.app.KeyguardManager: Intent createConfirmDeviceCredentialIntent(CharSequence,CharSequence)>",0,"{
    if (!isKeyguardSecure())
        return null;
    Intent intent = new Intent(ACTION_CONFIRM_DEVICE_CREDENTIAL);
    intent.putExtra(EXTRA_TITLE, title);
    intent.putExtra(EXTRA_DESCRIPTION, description);
    // For security reasons, only allow this to come from system settings.
    intent.setPackage(""com.android.settings"");
    return intent;
}","{
    if (!isDeviceSecure())
        return null;
    Intent intent = new Intent(ACTION_CONFIRM_DEVICE_CREDENTIAL);
    intent.putExtra(EXTRA_TITLE, title);
    intent.putExtra(EXTRA_DESCRIPTION, description);
    // For security reasons, only allow this to come from system settings.
    intent.setPackage(""com.android.settings"");
    return intent;
}",1,"/**
 * Get an intent to prompt the user to confirm credentials (pin, pattern or password)
 * for the current user of the device. The caller is expected to launch this activity using
 * {@link android.app.Activity#startActivityForResult(Intent, int)} and check for
 * {@link android.app.Activity#RESULT_OK} if the user successfully completes the challenge.
 *
 * @return the intent for launching the activity or null if no password is required.
 */
","/**
 * Get an intent to prompt the user to confirm credentials (pin, pattern or password)
 * for the current user of the device. The caller is expected to launch this activity using
 * {@link android.app.Activity#startActivityForResult(Intent, int)} and check for
 * {@link android.app.Activity#RESULT_OK} if the user successfully completes the challenge.
 *
 * @return the intent for launching the activity or null if no password is required.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The condition within the if-statement has changed from isKeyguardSecure() to isDeviceSecure(), and the method name of isKeyguardSecure() has been changed to isDeviceSecure(), so the code change types are 3 and 5.","Since the condition for returning null has changed, this could potentially change the behavior of the API if the new condition isDeviceSecure() has different logic or states compared to isKeyguardSecure(). This means a Compatibility Issue could arise due to potential different return values, making the CI type 1."
1305,"<android.webkit.WebViewFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>",23,24,"<android.webkit.WebViewFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>","<android.webkit.WebViewFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>",0,"{
    if (mWebView != null) {
        mWebView.destroy();
    }
    mWebView = new WebView(getActivity());
    mIsWebViewAvailable = true;
    return mWebView;
}","{
    if (mWebView != null) {
        mWebView.destroy();
    }
    mWebView = new WebView(getContext());
    mIsWebViewAvailable = true;
    return mWebView;
}",1,"/**
 * Called to instantiate the view. Creates and returns the WebView.
 */
","/**
 * Called to instantiate the view. Creates and returns the WebView.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method used to instantiate the WebView changed from getActivity() to getContext(), which is a change in a dependent API, so the change type is 5.","Although there is a change in the dependent API, it does not necessarily lead to a Compatibility Issue as both methods are legitimate ways to obtain a Context object, and the return type and value remain a WebView instance. Therefore, there is no CI."
1306,"<android.app.admin.DevicePolicyManager: void setSystemUpdatePolicy(ComponentName,SystemUpdatePolicy)>",23,24,"<android.app.admin.DevicePolicyManager: void setSystemUpdatePolicy(ComponentName,SystemUpdatePolicy)>","<android.app.admin.DevicePolicyManager: void setSystemUpdatePolicy(ComponentName,SystemUpdatePolicy)>",0,"{
    if (mService != null) {
        try {
            mService.setSystemUpdatePolicy(admin, policy);
        } catch (RemoteException re) {
            Log.w(TAG, ""Error calling setSystemUpdatePolicy"", re);
        }
    }
}","{
    throwIfParentInstance(""setSystemUpdatePolicy"");
    if (mService != null) {
        try {
            mService.setSystemUpdatePolicy(admin, policy);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by device owners to set a local system update policy. When a new policy is set,
 * {@link #ACTION_SYSTEM_UPDATE_POLICY_CHANGED} is broadcasted.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with. All
 * components in the device owner package can set system update policies and the
 * most recent policy takes
 * effect.
 * @param policy the new policy, or {@code null} to clear the current policy.
 * @see SystemUpdatePolicy
 */
","/**
 * Called by device owners to set a local system update policy. When a new policy is set,
 * {@link #ACTION_SYSTEM_UPDATE_POLICY_CHANGED} is broadcasted.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with. All
 * components in the device owner package can set system update policies and the most
 * recent policy takes effect.
 * @param policy the new policy, or {@code null} to clear the current policy.
 * @throws SecurityException if {@code admin} is not a device owner.
 * @see SystemUpdatePolicy
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"In the late implementation, there is the added call to the method throwIfParentInstance(""setSystemUpdatePolicy"") before the try-catch block, which is classified as a control dependency change (3). Additionally, the catch block has been modified to now throw an exception with throw re.rethrowFromSystemServer() instead of just logging the RemoteException, which should be considered as ""Other statement changed"" (4).","The added method call throwIfParentInstance(""setSystemUpdatePolicy"") could potentially throw an exception that wasn't thrown in the previous version, leading to different exception handling. Moreover, the modification to the catch block to throw an exception instead of logging it also leads to a different exception handling. Thus, the CI type is 2."
1308,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>",23,24,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>","<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method call prepareToLeaveProcess() now has a 'this' parameter in the late version, indicating a change in a dependent API (the parameter list has changed). However, there are no changes in return statements or exception handling statements. Hence, the code change type is 4,5.","Although the dependent API, intent.prepareToLeaveProcess(), has been altered to include a new parameter, this change does not inherently result in a return value difference or a different exception being thrown, as the method's behavior in handling the Intent before it is broadcasted remains consistent within the context of sendBroadcastMultiplePermissions(). Therefore, there is no compatibility issue from this change, so the CI type is 0."
1309,"<android.app.admin.DevicePolicyManager: boolean switchUser(ComponentName,UserHandle)>",23,24,"<android.app.admin.DevicePolicyManager: boolean switchUser(ComponentName,UserHandle)>","<android.app.admin.DevicePolicyManager: boolean switchUser(ComponentName,UserHandle)>",0,"{
    try {
        return mService.switchUser(admin, userHandle);
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not switch user "", re);
        return false;
    }
}","{
    throwIfParentInstance(""switchUser"");
    try {
        return mService.switchUser(admin, userHandle);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by a device owner to switch the specified user to the foreground.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param userHandle the user to switch to; null will switch to primary.
 * @return {@code true} if the switch was successful, {@code false} otherwise.
 *
 * @see Intent#ACTION_USER_FOREGROUND
 */
","/**
 * Called by a device owner to switch the specified user to the foreground.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param userHandle the user to switch to; null will switch to primary.
 * @return {@code true} if the switch was successful, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device owner.
 * @see Intent#ACTION_USER_FOREGROUND
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"A new method call throwIfParentInstance(""switchUser"") is added at the beginning and the exception handling strategy has changed from logging and returning false to throwing the exception using rethrowFromSystemServer(), so the change type is 2,4.","Because of the change in exception handling strategy, where previously a RemoteException was caught and the method returned false, now the same exception will be thrown and will propagate further, leading to a different behavior. Hence, the CI type is 2."
1310,<android.app.admin.DevicePolicyManager: boolean isProfileOwnerApp(String)>,23,24,<android.app.admin.DevicePolicyManager: boolean isProfileOwnerApp(String)>,<android.app.admin.DevicePolicyManager: boolean isProfileOwnerApp(String)>,0,"{
    if (mService != null) {
        try {
            ComponentName profileOwner = mService.getProfileOwner(Process.myUserHandle().getIdentifier());
            return profileOwner != null && profileOwner.getPackageName().equals(packageName);
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed to check profile owner"");
        }
    }
    return false;
}","{
    throwIfParentInstance(""isProfileOwnerApp"");
    if (mService != null) {
        try {
            ComponentName profileOwner = mService.getProfileOwner(myUserId());
            return profileOwner != null && profileOwner.getPackageName().equals(packageName);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Used to determine if a particular package is registered as the profile owner for the
 * current user. A profile owner is a special device admin that has additional privileges
 * within the profile.
 *
 * @param packageName The package name of the app to compare with the registered profile owner.
 * @return Whether or not the package is registered as the profile owner.
 */
","/**
 * Used to determine if a particular package is registered as the profile owner for the
 * user. A profile owner is a special device admin that has additional privileges
 * within the profile.
 *
 * @param packageName The package name of the app to compare with the registered profile owner.
 * @return Whether or not the package is registered as the profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5","1,2","The method call `throwIfParentInstance(""isProfileOwnerApp"")` has been introduced at the beginning of the method and the way the user ID is retrieved has changed from `Process.myUserHandle().getIdentifier()` to `myUserId()`. Besides, the exception handling statement has changed from logging the error to throwing it (with `rethrowFromSystemServer()`), so the change type is 2,4,5.","The added `throwIfParentInstance(""isProfileOwnerApp"")` can potentially throw an exception that wasn't thrown before, introducing a CI type 2. Additionally, changing from logging an exception to throwing it also introduces a different type of exception handling, causing a potential behavior change, CI type 2. The change in user ID retrieval could also cause the API to return a different result if the implementation of `myUserId()` differs from `Process.myUserHandle().getIdentifier()`, which is a CI type 1."
1312,<android.view.inputmethod.CursorAnchorInfo: boolean equals(Object)>,23,24,<android.view.inputmethod.CursorAnchorInfo: boolean equals(Object)>,<android.view.inputmethod.CursorAnchorInfo: boolean equals(Object)>,0,"{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof CursorAnchorInfo)) {
        return false;
    }
    final CursorAnchorInfo that = (CursorAnchorInfo) obj;
    if (hashCode() != that.hashCode()) {
        return false;
    }
    if (mSelectionStart != that.mSelectionStart || mSelectionEnd != that.mSelectionEnd) {
        return false;
    }
    if (mComposingTextStart != that.mComposingTextStart || !Objects.equals(mComposingText, that.mComposingText)) {
        return false;
    }
    if (mInsertionMarkerFlags != that.mInsertionMarkerFlags || !areSameFloatImpl(mInsertionMarkerHorizontal, that.mInsertionMarkerHorizontal) || !areSameFloatImpl(mInsertionMarkerTop, that.mInsertionMarkerTop) || !areSameFloatImpl(mInsertionMarkerBaseline, that.mInsertionMarkerBaseline) || !areSameFloatImpl(mInsertionMarkerBottom, that.mInsertionMarkerBottom)) {
        return false;
    }
    if (!Objects.equals(mCharacterBoundsArray, that.mCharacterBoundsArray)) {
        return false;
    }
    if (!Objects.equals(mMatrix, that.mMatrix)) {
        return false;
    }
    return true;
}","{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof CursorAnchorInfo)) {
        return false;
    }
    final CursorAnchorInfo that = (CursorAnchorInfo) obj;
    if (hashCode() != that.hashCode()) {
        return false;
    }
    if (mSelectionStart != that.mSelectionStart || mSelectionEnd != that.mSelectionEnd) {
        return false;
    }
    if (mInsertionMarkerFlags != that.mInsertionMarkerFlags || !areSameFloatImpl(mInsertionMarkerHorizontal, that.mInsertionMarkerHorizontal) || !areSameFloatImpl(mInsertionMarkerTop, that.mInsertionMarkerTop) || !areSameFloatImpl(mInsertionMarkerBaseline, that.mInsertionMarkerBaseline) || !areSameFloatImpl(mInsertionMarkerBottom, that.mInsertionMarkerBottom)) {
        return false;
    }
    if (!Objects.equals(mCharacterBoundsArray, that.mCharacterBoundsArray)) {
        return false;
    }
    if (mComposingTextStart != that.mComposingTextStart || !Objects.equals(mComposingText, that.mComposingText)) {
        return false;
    }
    // NaN, 0.0f, and -0.0f.
    if (mMatrixValues.length != that.mMatrixValues.length) {
        return false;
    }
    for (int i = 0; i < mMatrixValues.length; ++i) {
        if (mMatrixValues[i] != that.mMatrixValues[i]) {
            return false;
        }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"In the late version, code has been added to explicitly compare the 'mMatrixValues' arrays of both objects. This logic is in addition to comparing the 'mMatrix' instances with 'Objects.equals(mMatrix, that.mMatrix)' present in the early version. The control dependency change is due to the addition of an array length comparison and a loop to compare individual elements. And there are other changes in the placement of code blocks that compare member variables, but they don't affect the logic or the outcome. Therefore, the code change types are 3 (control dependency change) and 4 (other statement changed).","There is no compatibility issue detected because despite the added block to compare 'mMatrixValues', the overall logic of the method remains the same: it still returns true only if all the compared fields are equal, and false otherwise. The additional checks for the matrix values don't alter the existing comparison contract of the 'equals' method but clarify the equality check for one of the fields. The method still compares all the relevant fields of 'CursorAnchorInfo', so clients relying on 'equals' will not observe a change in behavior due to consistent comparison logic. Therefore, there is no compatibility issue."
1313,<android.bluetooth.le.BluetoothLeScanner: void startScan(ScanCallback)>,23,24,<android.bluetooth.le.BluetoothLeScanner: void startScan(ScanCallback)>,<android.bluetooth.le.BluetoothLeScanner: void startScan(ScanCallback)>,0,"{
    if (callback == null) {
        throw new IllegalArgumentException(""callback is null"");
    }
    startScan(null, new ScanSettings.Builder().build(), callback);
}","{
    startScan(null, new ScanSettings.Builder().build(), callback);
}",1,"/**
 * Start Bluetooth LE scan with default parameters and no filters. The scan results will be
 * delivered through {@code callback}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 * An app must hold
 * {@link android.Manifest.permission#ACCESS_COARSE_LOCATION ACCESS_COARSE_LOCATION} or
 * {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION} permission
 * in order to get results.
 *
 * @param callback Callback used to deliver scan results.
 * @throws IllegalArgumentException If {@code callback} is null.
 */
","/**
 * Start Bluetooth LE scan with default parameters and no filters. The scan results will be
 * delivered through {@code callback}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 * An app must hold
 * {@link android.Manifest.permission#ACCESS_COARSE_LOCATION ACCESS_COARSE_LOCATION} or
 * {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION} permission
 * in order to get results.
 *
 * @param callback Callback used to deliver scan results.
 * @throws IllegalArgumentException If {@code callback} is null.
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,"2,4",1,"The early version had a check for a null callback which would throw an IllegalArgumentException, but this check has been removed in the late version. Apart from the exception handling statement changed, this is also a change in the control dependency. Thus, the code change type is 2,4.","Removing the null check for the callback potentially changes the behavior of the method, because now the method could proceed with a null callback and could result in a NullPointerException at runtime. This would be a different exception from IllegalArgumentException that was previously thrown. The change in exception handling leads to CI type 1 (potential different return values or types), due to the removed null check leading to execution of subsequent code that was previously not executed in the case of a null callback."
1314,"<android.view.inputmethod.InputMethodManager: boolean hideSoftInputFromWindow(IBinder,int,ResultReceiver)>",23,24,"<android.view.inputmethod.InputMethodManager: boolean hideSoftInputFromWindow(IBinder,int,ResultReceiver)>","<android.view.inputmethod.InputMethodManager: boolean hideSoftInputFromWindow(IBinder,int,ResultReceiver)>",0,"{
    checkFocus();
    synchronized (mH) {
        if (mServedView == null || mServedView.getWindowToken() != windowToken) {
            return false;
        }
        try {
            return mService.hideSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
        }
        return false;
    }
}","{
    checkFocus();
    synchronized (mH) {
        if (mServedView == null || mServedView.getWindowToken() != windowToken) {
            return false;
        }
        try {
            return mService.hideSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Request to hide the soft input window from the context of the window
 * that is currently accepting input.  This should be called as a result
 * of the user doing some actually than fairly explicitly requests to
 * have the input window hidden.
 *
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
","/**
 * Request to hide the soft input window from the context of the window
 * that is currently accepting input.  This should be called as a result
 * of the user doing some actually than fairly explicitly requests to
 * have the input window hidden.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The code change is related to how the ""RemoteException"" is handled. The late version introduces a new exception throw statement (throw e.rethrowFromSystemServer();), so the exception handling statement changed.","The introduction of a new throw statement means that in the event of a RemoteException in the late version, the exception will be thrown instead of swallowed. This behavior change will cause the late version of the method to propagate an exception to its caller instead of returning false, so there is a potential Compatibility Issue caused by different exception handlings."
1315,"<android.accounts.AccountManager: void setPassword(Account,String)>",23,24,"<android.accounts.AccountManager: void setPassword(Account,String)>","<android.accounts.AccountManager: void setPassword(Account,String)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        mService.setPassword(account, password);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        mService.setPassword(account, password);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets or forgets a saved password. This modifies the local copy of the
 * password used to automatically authenticate the user; it does not change
 * the user's account password on the server. Intended for use by the
 * authenticator, not directly by applications.
 * <p>Calling this method does not update the last authenticated timestamp,
 * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * <p>It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account whose password is to be set. Cannot be
 * {@code null}.
 * @param password The password to set, null to clear the password
 */
","/**
 * Sets or forgets a saved password. This modifies the local copy of the
 * password used to automatically authenticate the user; it does not change
 * the user's account password on the server. Intended for use by the
 * authenticator, not directly by applications.
 * <p>Calling this method does not update the last authenticated timestamp,
 * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * <p>It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account whose password is to be set. Cannot be
 * {@code null}.
 * @param password The password to set, null to clear the password
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing a new RuntimeException to throwing the RemoteException rethrown from the system server, so the code change type is 2.","Since there's a change in the exception handling that could potentially lead to a different exception being thrown to the caller, the CI type is 2."
1316,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,23,24,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,0,"{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT, AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method signature of the call to `mService.writeDescriptor` within the `try` block has been significantly changed. The number of parameters passed to the method and the types of those parameters have been altered, so the code change type is 4,5.","The change in how `writeDescriptor` is called inside the `try` block is a dependent API change that potentially affects the outcome of calling `writeDescriptor()` on the `BluetoothGatt` object. This may lead to a different return value due to the changed behavior of the dependent method, hence the CI type is 1."
1317,"<android.app.admin.DevicePolicyManager: void addPersistentPreferredActivity(ComponentName,IntentFilter,ComponentName)>",23,24,"<android.app.admin.DevicePolicyManager: void addPersistentPreferredActivity(ComponentName,IntentFilter,ComponentName)>","<android.app.admin.DevicePolicyManager: void addPersistentPreferredActivity(ComponentName,IntentFilter,ComponentName)>",0,"{
    if (mService != null) {
        try {
            mService.addPersistentPreferredActivity(admin, filter, activity);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""addPersistentPreferredActivity"");
    if (mService != null) {
        try {
            mService.addPersistentPreferredActivity(admin, filter, activity);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by a profile owner or device owner to add a default intent handler activity for
 * intents that match a certain intent filter. This activity will remain the default intent
 * handler even if the set of potential event handlers for the intent filter changes and if
 * the intent preferences are reset.
 *
 * <p>The default disambiguation mechanism takes over if the activity is not installed
 * (anymore). When the activity is (re)installed, it is automatically reset as default
 * intent handler for the filter.
 *
 * <p>The calling device admin must be a profile owner or device owner. If it is not, a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param filter The IntentFilter for which a default handler is added.
 * @param activity The Activity that is added as default intent handler.
 */
","/**
 * Called by a profile owner or device owner to add a default intent handler activity for
 * intents that match a certain intent filter. This activity will remain the default intent
 * handler even if the set of potential event handlers for the intent filter changes and if the
 * intent preferences are reset.
 * <p>
 * The default disambiguation mechanism takes over if the activity is not installed (anymore).
 * When the activity is (re)installed, it is automatically reset as default intent handler for
 * the filter.
 * <p>
 * The calling device admin must be a profile owner or device owner. If it is not, a security
 * exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param filter The IntentFilter for which a default handler is added.
 * @param activity The Activity that is added as default intent handler.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,2",2,"A new method call 'throwIfParentInstance(""addPersistentPreferredActivity"")' is added at the beginning of the method and a new exception handling ('throw e.rethrowFromSystemServer();') is introduced. The code changes belong to 4 for an additional method and 2 for added exception handling.","The addition of 'throwIfParentInstance(""addPersistentPreferredActivity"");' could potentially lead to a new RuntimeException being thrown before rest of the code is executed, which is a change in exception handling and could thus lead to a compatibility issue if 'addPersistentPreferredActivity' was allowed to be called from a parent instance before and is not allowed now. Furthermore, the change in exception handling, from logging the exception to re-throwing it, could lead to a compatibility issue because it will cause RemoteException to propagate up the call stack, whereas previously it would have been caught and logged. The CI type is 2 because of the changes in how exceptions are handled."
1318,<android.app.Notification.Builder: Builder addExtras(Bundle)>,23,24,<android.app.Notification.Builder: Builder addExtras(Bundle)>,<android.app.Notification.Builder: Builder addExtras(Bundle)>,0,"{
    if (extras != null) {
        if (mExtras == null) {
            mExtras = new Bundle(extras);
        } else {
            mExtras.putAll(extras);
        }
    }
    return this;
}","{
    if (extras != null) {
        mUserExtras.putAll(extras);
    }
    return this;
}",1,"/**
 * Merge additional metadata into this notification.
 *
 * <p>Values within the Bundle will replace existing extras values in this Builder.
 *
 * @see Notification#extras
 */
","/**
 * Merge additional metadata into this notification.
 *
 * <p>Values within the Bundle will replace existing extras values in this Builder.
 *
 * @see Notification#extras
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The logic for adding extras has changed from conditionally initializing `mExtras` and then adding all from `extras`, to directly adding all from `extras` to `mUserExtras`. This change is not related to the control flow or exceptions but rather to the assignment logic, so the code change type is 4.","There is no Compatibility Issue; even though the logic for adding extras changed, the method still returns `this` (the Builder object) and there are no changes in exception handling or return type/values, so the behavior from a caller perspective remains effectively the same."
1319,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,23,24,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,0,"{
    synchronized (mInterfaceLock) {
        if (mClosing.getAndSet(true)) {
            return;
        }
        try {
            if (mRemoteDevice != null) {
                mRemoteDevice.disconnect();
            }
        } catch (CameraRuntimeException e) {
            Log.e(TAG, ""Exception while closing: "", e.asChecked());
        } catch (RemoteException e) {
        // impossible
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceHandler.post(mCallOnClosed);
        }
        mRemoteDevice = null;
    }
}","{
    synchronized (mInterfaceLock) {
        if (mClosing.getAndSet(true)) {
            return;
        }
        if (mRemoteDevice != null) {
            mRemoteDevice.disconnect();
            mRemoteDevice.unlinkToDeath(this, /*flags*/
            0);
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceHandler.post(mCallOnClosed);
        }
        mRemoteDevice = null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a change within the try block where a method call ""mRemoteDevice.unlinkToDeath(this, 0);"" has been added, and the exception handling for RemoteException has been removed. These changes are categorized as control dependency change (3) because the call is within a conditional block, and other statement changed (4) since there is a method call addition.","Although there is a change in the implementation, it does not constitute a compatibility issue since it does not affect the return value of the method nor the exception it throws to the caller. The method is defined to return void, and the exception that was caught in the previous version was considered impossible, meaning it was not expected to occur. The new method call to ""unlinkToDeath"" is an internal operation and should not change the observable behavior of the method in terms of API contract. Therefore, we can conclude there is no compatibility issue (0)."
1320,"<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>",23,24,"<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>","<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>",0,"{
    if (DBG)
        Log.d(TAG, ""startLeScan(): "" + serviceUuids);
    if (callback == null) {
        if (DBG)
            Log.e(TAG, ""startLeScan: null callback"");
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG)
            Log.e(TAG, ""startLeScan: cannot get BluetoothLeScanner"");
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG)
                Log.e(TAG, ""LE Scan has already started"");
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, ""LE Scan has already started"");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG)
                                Log.d(TAG, ""uuids does not match"");
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    return false;
}","{
    if (DBG)
        Log.d(TAG, ""startLeScan(): "" + Arrays.toString(serviceUuids));
    if (callback == null) {
        if (DBG)
            Log.e(TAG, ""startLeScan: null callback"");
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG)
            Log.e(TAG, ""startLeScan: cannot get BluetoothLeScanner"");
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG)
                Log.e(TAG, ""LE Scan has already started"");
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, ""LE Scan has already started"");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG)
                                Log.d(TAG, ""uuids does not match"");
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    return false;
}",1,"/**
 * Starts a scan for Bluetooth LE devices, looking for devices that
 * advertise given services.
 *
 * <p>Devices which advertise all specified services are reported using the
 * {@link LeScanCallback#onLeScan} callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param serviceUuids Array of services to look for
 * @param callback the callback LE scan results are delivered
 * @return true, if the scan was started successfully
 * @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}
 * instead.
 */
","/**
 * Starts a scan for Bluetooth LE devices, looking for devices that
 * advertise given services.
 *
 * <p>Devices which advertise all specified services are reported using the
 * {@link LeScanCallback#onLeScan} callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param serviceUuids Array of services to look for
 * @param callback the callback LE scan results are delivered
 * @return true, if the scan was started successfully
 * @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}
 * instead.
 */
",-1,"[@Deprecated, @RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)]","[@Deprecated, @RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)]",-1,-1,-1,-1,-1,-1,,,,
1321,"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>",23,24,"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>","<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>",0,"{
    checkRange(""replace"", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        boolean changed = false;
        if (selectionStart > start && selectionStart < end) {
            final int offset = (selectionStart - start) * newLen / origLen;
            selectionStart = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final int offset = (selectionEnd - start) * newLen / origLen;
            selectionEnd = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT);
        }
        if (changed) {
            restoreInvariants();
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}","{
    checkRange(""replace"", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        boolean changed = false;
        if (selectionStart > start && selectionStart < end) {
            final long diff = selectionStart - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionStart = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final long diff = selectionEnd - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionEnd = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT);
        }
        if (changed) {
            restoreInvariants();
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}",1,"// Documentation from interface
","// Documentation from interface
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1322,<android.view.ViewOverlay.OverlayViewGroup: void remove(View)>,23,24,<android.view.ViewOverlay.OverlayViewGroup: void remove(View)>,<android.view.ViewOverlay.OverlayViewGroup: void remove(View)>,0,"{
    super.removeView(view);
}","{
    if (view == null) {
        throw new IllegalArgumentException(""view must be non-null"");
    }
    super.removeView(view);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An 'if' statement has been introduced to check if 'view' is null, throwing an IllegalArgumentException if the condition is true. Additionally, the super.removeView(view) call remains unchanged. The new 'if' statement represents an ""Other statement change,"" (marked as 4) as well as an ""Exception handling statement changed"" (marked as 2) because of the new exception that is thrown.","A new exception handling for the IllegalArgumentException is introduced for cases where the 'view' is null. Therefore, this constitutes an addition of a new exception that could be thrown by the method, corresponding to a Compatibility Issue caused by potential different exception handlings, marked as 2."
1323,"<android.content.pm.PackageInstaller: void registerSessionCallback(SessionCallback,Handler)>",23,24,"<android.content.pm.PackageInstaller: void registerSessionCallback(SessionCallback,Handler)>","<android.content.pm.PackageInstaller: void registerSessionCallback(SessionCallback,Handler)>",0,"{
    // TODO: remove this temporary guard once we have new prebuilts
    final ApplicationInfo info = mContext.getApplicationInfo();
    if (""com.google.android.googlequicksearchbox"".equals(info.packageName) && info.versionCode <= 300400110) {
        Log.d(TAG, ""Ignoring callback request from old prebuilt"");
        return;
    }
    synchronized (mDelegates) {
        final SessionCallbackDelegate delegate = new SessionCallbackDelegate(callback, handler.getLooper());
        try {
            mInstaller.registerCallback(delegate, mUserId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        mDelegates.add(delegate);
    }
}","{
    synchronized (mDelegates) {
        final SessionCallbackDelegate delegate = new SessionCallbackDelegate(callback, handler.getLooper());
        try {
            mInstaller.registerCallback(delegate, mUserId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        mDelegates.add(delegate);
    }
}",1,"/**
 * Register to watch for session lifecycle events. No special permissions
 * are required to watch for these events.
 *
 * @param handler to dispatch callback events through, otherwise uses
 * calling thread.
 */
","/**
 * Register to watch for session lifecycle events. No special permissions
 * are required to watch for these events.
 *
 * @param handler to dispatch callback events through, otherwise uses
 * calling thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The temporary guard code checking package name and versionCode is removed, thus an 'if' statement is deleted, and this change can be classified under type 1 as it changes the flow of the method. Additionally, it can be considered a type 4 change as the specific block of code (including the 'if' statement and logging) has been removed.","With the removal of the conditional check for the package name and versionCode, the method no longer returns early for certain conditions which it did previously. This means that the method will now execute further lines of code for cases where it previously would not have, potentially leading to a different behaviour. Therefore, the CI type is 1."
1324,<android.hardware.input.InputManager: InputDevice getInputDevice(int)>,23,24,<android.hardware.input.InputManager: InputDevice getInputDevice(int)>,<android.hardware.input.InputManager: InputDevice getInputDevice(int)>,0,"{
    synchronized (mInputDevicesLock) {
        populateInputDevicesLocked();
        int index = mInputDevices.indexOfKey(id);
        if (index < 0) {
            return null;
        }
        InputDevice inputDevice = mInputDevices.valueAt(index);
        if (inputDevice == null) {
            try {
                inputDevice = mIm.getInputDevice(id);
            } catch (RemoteException ex) {
                throw new RuntimeException(""Could not get input device information."", ex);
            }
            if (inputDevice != null) {
                mInputDevices.setValueAt(index, inputDevice);
            }
        }
        return inputDevice;
    }
}","{
    synchronized (mInputDevicesLock) {
        populateInputDevicesLocked();
        int index = mInputDevices.indexOfKey(id);
        if (index < 0) {
            return null;
        }
        InputDevice inputDevice = mInputDevices.valueAt(index);
        if (inputDevice == null) {
            try {
                inputDevice = mIm.getInputDevice(id);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
            if (inputDevice != null) {
                mInputDevices.setValueAt(index, inputDevice);
            }
        }
        return inputDevice;
    }
}",1,"/**
 * Gets information about the input device with the specified id.
 * @param id The device id.
 * @return The input device or null if not found.
 */
","/**
 * Gets information about the input device with the specified id.
 * @param id The device id.
 * @return The input device or null if not found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has been changed. In the early version, it throws a new RuntimeException, while in the late version it throws the original RemoteException that has been wrapped with the rethrowFromSystemServer() method.","The modification in exception handling could lead to a change in exception type thrown by the method when an error occurs, introducing a potential exception handling Compatibility Issue, which is a CI type 2."
1326,<android.app.Fragment: boolean isResumed()>,23,24,<android.app.Fragment: boolean isResumed()>,<android.app.Fragment: boolean isResumed()>,0,"{
    return mResumed;
}","{
    return mState >= RESUMED;
}",1,"/**
 * Return true if the fragment is in the resumed state.  This is true
 * for the duration of {@link #onResume()} and {@link #onPause()} as well.
 */
","/**
 * Return true if the fragment is in the resumed state.  This is true
 * for the duration of {@link #onResume()} and {@link #onPause()} as well.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,The implementation of the method changed from directly returning the value of 'mResumed' to returning the result of a comparison between 'mState' and the constant 'RESUMED'. This indicates a change in the method's logic for determining the return value which classifies as Other statement changed.,"Since the logic determining the return value has changed from a direct variable return to a conditional comparison, this could potentially lead to different return values for the same object state, thus causing a Compatibility Issue due to potential different return values or types."
1327,<android.os.PowerManager.WakeLock: void release(int)>,23,24,<android.os.PowerManager.WakeLock: void release(int)>,<android.os.PowerManager.WakeLock: void release(int)>,0,"{
    synchronized (mToken) {
        if (!mRefCounted || --mCount == 0) {
            mHandler.removeCallbacks(mReleaser);
            if (mHeld) {
                Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0);
                try {
                    mService.releaseWakeLock(mToken, flags);
                } catch (RemoteException e) {
                }
                mHeld = false;
            }
        }
        if (mCount < 0) {
            throw new RuntimeException(""WakeLock under-locked "" + mTag);
        }
    }
}","{
    synchronized (mToken) {
        if (!mRefCounted || --mCount == 0) {
            mHandler.removeCallbacks(mReleaser);
            if (mHeld) {
                Trace.asyncTraceEnd(Trace.TRACE_TAG_POWER, mTraceName, 0);
                try {
                    mService.releaseWakeLock(mToken, flags);
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
                mHeld = false;
            }
        }
        if (mCount < 0) {
            throw new RuntimeException(""WakeLock under-locked "" + mTag);
        }
    }
}",1,"/**
 * Releases the wake lock with flags to modify the release behavior.
 * <p>
 * This method releases your claim to the CPU or screen being on.
 * The screen may turn off shortly after you release the wake lock, or it may
 * not if there are other wake locks still held.
 * </p>
 *
 * @param flags Combination of flag values to modify the release behavior.
 * Currently only {@link #RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY} is supported.
 * Passing 0 is equivalent to calling {@link #release()}.
 */
","/**
 * Releases the wake lock with flags to modify the release behavior.
 * <p>
 * This method releases your claim to the CPU or screen being on.
 * The screen may turn off shortly after you release the wake lock, or it may
 * not if there are other wake locks still held.
 * </p>
 *
 * @param flags Combination of flag values to modify the release behavior.
 * Currently only {@link #RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY} is supported.
 * Passing 0 is equivalent to calling {@link #release()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has changed, adding a throw statement in the catch block for a RemoteException, so the change type is 2.","The introduction of a new throw statement for RemoteException could lead to potential different exception handlings when the API is called, hence the CI type is 2."
1328,<android.bluetooth.BluetoothDevice: boolean createBond()>,23,24,<android.bluetooth.BluetoothDevice: boolean createBond()>,<android.bluetooth.BluetoothDevice: boolean createBond()>,0,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot create bond to Remote Device"");
        return false;
    }
    try {
        return sService.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot create bond to Remote Device"");
        return false;
    }
    try {
        Log.i(TAG, ""createBond() for device "" + getAddress() + "" called by pid: "" + Process.myPid() + "" tid: "" + Process.myTid());
        return sService.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return false on immediate error, true if bonding will begin
 */
","/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return false on immediate error, true if bonding will begin
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,4,0,"A logging statement has been introduced, so the code change is an Other statement changed (4), which is not related to the return values or exception handling.","The new log statement does not affect the return value or the exception handling of the method, so there is no Compatibility Issue (0)."
1330,"<android.print.PrintManager: PrintJob print(String,PrintDocumentAdapter,PrintAttributes)>",23,24,"<android.print.PrintManager: PrintJob print(String,PrintDocumentAdapter,PrintAttributes)>","<android.print.PrintManager: PrintJob print(String,PrintDocumentAdapter,PrintAttributes)>",0,"{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return null;
    }
    if (!(mContext instanceof Activity)) {
        throw new IllegalStateException(""Can print only from an activity"");
    }
    if (TextUtils.isEmpty(printJobName)) {
        throw new IllegalArgumentException(""printJobName cannot be empty"");
    }
    if (documentAdapter == null) {
        throw new IllegalArgumentException(""documentAdapter cannot be null"");
    }
    PrintDocumentAdapterDelegate delegate = new PrintDocumentAdapterDelegate((Activity) mContext, documentAdapter);
    try {
        Bundle result = mService.print(printJobName, delegate, attributes, mContext.getPackageName(), mAppId, mUserId);
        if (result != null) {
            PrintJobInfo printJob = result.getParcelable(EXTRA_PRINT_JOB);
            IntentSender intent = result.getParcelable(EXTRA_PRINT_DIALOG_INTENT);
            if (printJob == null || intent == null) {
                return null;
            }
            try {
                mContext.startIntentSender(intent, null, 0, 0, 0);
                return new PrintJob(printJob, this);
            } catch (SendIntentException sie) {
                Log.e(LOG_TAG, ""Couldn't start print job config activity."", sie);
            }
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error creating a print job"", re);
    }
    return null;
}","{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return null;
    }
    if (!(mContext instanceof Activity)) {
        throw new IllegalStateException(""Can print only from an activity"");
    }
    if (TextUtils.isEmpty(printJobName)) {
        throw new IllegalArgumentException(""printJobName cannot be empty"");
    }
    if (documentAdapter == null) {
        throw new IllegalArgumentException(""documentAdapter cannot be null"");
    }
    PrintDocumentAdapterDelegate delegate = new PrintDocumentAdapterDelegate((Activity) mContext, documentAdapter);
    try {
        Bundle result = mService.print(printJobName, delegate, attributes, mContext.getPackageName(), mAppId, mUserId);
        if (result != null) {
            PrintJobInfo printJob = result.getParcelable(EXTRA_PRINT_JOB);
            IntentSender intent = result.getParcelable(EXTRA_PRINT_DIALOG_INTENT);
            if (printJob == null || intent == null) {
                return null;
            }
            try {
                mContext.startIntentSender(intent, null, 0, 0, 0);
                return new PrintJob(printJob, this);
            } catch (SendIntentException sie) {
                Log.e(LOG_TAG, ""Couldn't start print job config activity."", sie);
            }
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    return null;
}",1,"/**
 * Creates a print job for printing a {@link PrintDocumentAdapter} with
 * default print attributes.
 * <p>
 * Calling this method brings the print UI allowing the user to customize
 * the print job and returns a {@link PrintJob} object without waiting for the
 * user to customize or confirm the print job. The returned print job instance
 * is in a {@link PrintJobInfo#STATE_CREATED created} state.
 * <p>
 * This method can be called only from an {@link Activity}. The rationale is that
 * printing from a service will create an inconsistent user experience as the print
 * UI would appear without any context.
 * </p>
 * <p>
 * Also the passed in {@link PrintDocumentAdapter} will be considered invalid if
 * your activity is finished. The rationale is that once the activity that
 * initiated printing is finished, the provided adapter may be in an inconsistent
 * state as it may depend on the UI presented by the activity.
 * </p>
 * <p>
 * The default print attributes are a hint to the system how the data is to
 * be printed. For example, a photo editor may look at the photo aspect ratio
 * to determine the default orientation and provide a hint whether the printing
 * should be in portrait or landscape. The system will do a best effort to
 * selected the hinted options in the print dialog, given the current printer
 * supports them.
 * </p>
 * <p>
 * <strong>Note:</strong> Calling this method will bring the print dialog and
 * the system will connect to the provided {@link PrintDocumentAdapter}. If a
 * configuration change occurs that you application does not handle, for example
 * a rotation change, the system will drop the connection to the adapter as the
 * activity has to be recreated and the old adapter may be invalid in this context,
 * hence a new adapter instance is required. As a consequence, if your activity
 * does not handle configuration changes (default behavior), you have to save the
 * state that you were printing and call this method again when your activity
 * is recreated.
 * </p>
 *
 * @param printJobName A name for the new print job which is shown to the user.
 * @param documentAdapter An adapter that emits the document to print.
 * @param attributes The default print job attributes or <code>null</code>.
 * @return The created print job on success or null on failure.
 * @throws IllegalStateException If not called from an {@link Activity}.
 * @throws IllegalArgumentException If the print job name is empty or the
 * document adapter is null.
 *
 * @see PrintJob
 */
","/**
 * Creates a print job for printing a {@link PrintDocumentAdapter} with
 * default print attributes.
 * <p>
 * Calling this method brings the print UI allowing the user to customize
 * the print job and returns a {@link PrintJob} object without waiting for the
 * user to customize or confirm the print job. The returned print job instance
 * is in a {@link PrintJobInfo#STATE_CREATED created} state.
 * <p>
 * This method can be called only from an {@link Activity}. The rationale is that
 * printing from a service will create an inconsistent user experience as the print
 * UI would appear without any context.
 * </p>
 * <p>
 * Also the passed in {@link PrintDocumentAdapter} will be considered invalid if
 * your activity is finished. The rationale is that once the activity that
 * initiated printing is finished, the provided adapter may be in an inconsistent
 * state as it may depend on the UI presented by the activity.
 * </p>
 * <p>
 * The default print attributes are a hint to the system how the data is to
 * be printed. For example, a photo editor may look at the photo aspect ratio
 * to determine the default orientation and provide a hint whether the printing
 * should be in portrait or landscape. The system will do a best effort to
 * selected the hinted options in the print dialog, given the current printer
 * supports them.
 * </p>
 * <p>
 * <strong>Note:</strong> Calling this method will bring the print dialog and
 * the system will connect to the provided {@link PrintDocumentAdapter}. If a
 * configuration change occurs that you application does not handle, for example
 * a rotation change, the system will drop the connection to the adapter as the
 * activity has to be recreated and the old adapter may be invalid in this context,
 * hence a new adapter instance is required. As a consequence, if your activity
 * does not handle configuration changes (default behavior), you have to save the
 * state that you were printing and call this method again when your activity
 * is recreated.
 * </p>
 *
 * @param printJobName A name for the new print job which is shown to the user.
 * @param documentAdapter An adapter that emits the document to print.
 * @param attributes The default print job attributes or <code>null</code>.
 * @return The created print job on success or null on failure.
 * @throws IllegalStateException If not called from an {@link Activity}.
 * @throws IllegalArgumentException If the print job name is empty or the
 * document adapter is null.
 *
 * @see PrintJob
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The catch block for RemoteException has been modified. Previously it logged an error, and now it throws a RuntimeException with `rethrowFromSystemServer()`, thus the change type is 2.","The modification in the RemoteException catch block from logging an error to throwing a wrapped RuntimeException will lead to a different exception being propagated when the RemoteException occurs. There is now a potential for the client code to catch a RuntimeException that was not possible before, thereby causing a CI of type 2."
1331,<android.os.Parcel: void writeValue(Object)>,23,24,<android.os.Parcel: void writeValue(Object)>,<android.os.Parcel: void writeValue(Object)>,0,"{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof Parcelable) {
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof PersistableBundle) {
        writeInt(VAL_PERSISTABLEBUNDLE);
        writePersistableBundle((PersistableBundle) v);
    } else if (v instanceof Size) {
        writeInt(VAL_SIZE);
        writeSize((Size) v);
    } else if (v instanceof SizeF) {
        writeInt(VAL_SIZEF);
        writeSizeF((SizeF) v);
    } else {
        Class<?> clazz = v.getClass();
        if (clazz.isArray() && clazz.getComponentType() == Object.class) {
            // Only pure Object[] are written here, Other arrays of non-primitive types are
            // handled by serialization as this does not record the component type.
            writeInt(VAL_OBJECTARRAY);
            writeArray((Object[]) v);
        } else if (v instanceof Serializable) {
            // Must be last
            writeInt(VAL_SERIALIZABLE);
            writeSerializable((Serializable) v);
        } else {
            throw new RuntimeException(""Parcel: unable to marshal value "" + v);
        }
    }
}","{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof PersistableBundle) {
        writeInt(VAL_PERSISTABLEBUNDLE);
        writePersistableBundle((PersistableBundle) v);
    } else if (v instanceof Parcelable) {
        // IMPOTANT: cases for classes that implement Parcelable must
        // come before the Parcelable case, so that their specific VAL_*
        // types will be written.
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof Size) {
        writeInt(VAL_SIZE);
        writeSize((Size) v);
    } else if (v instanceof SizeF) {
        writeInt(VAL_SIZEF);
        writeSizeF((SizeF) v);
    } else if (v instanceof double[]) {
        writeInt(VAL_DOUBLEARRAY);
        writeDoubleArray((double[]) v);
    } else {
        Class<?> clazz = v.getClass();
        if (clazz.isArray() && clazz.getComponentType() == Object.class) {
            // Only pure Object[] are written here, Other arrays of non-primitive types are
            // handled by serialization as this does not record the component type.
            writeInt(VAL_OBJECTARRAY);
            writeArray((Object[]) v);
        } else if (v instanceof Serializable) {
            // Must be last
            writeInt(VAL_SERIALIZABLE);
            writeSerializable((Serializable) v);
        } else {
            throw new RuntimeException(""Parcel: unable to marshal value "" + v);
        }
    }
}",1,"/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 *
 * <p class=""caution"">{@link Parcelable} objects are written with
 * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
 * serializing objects containing {@link ParcelFileDescriptor}s,
 * this may result in file descriptor leaks when they are returned from
 * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
 * should be used).</p>
 */
","/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 *
 * <p class=""caution"">{@link Parcelable} objects are written with
 * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
 * serializing objects containing {@link ParcelFileDescriptor}s,
 * this may result in file descriptor leaks when they are returned from
 * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
 * should be used).</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1332,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean containsRemoteViewAt(int)>,23,24,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean containsRemoteViewAt(int)>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean containsRemoteViewAt(int)>,0,"{
    return mIndexRemoteViews.containsKey(position);
}","{
    return mIndexRemoteViews.indexOfKey(position) >= 0;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method used to check the presence of the key has changed from using mIndexRemoteViews.containsKey(position) to mIndexRemoteViews.indexOfKey(position) >= 0, so the code change types are 1,4.","The two methods are designed to check for the presence of a key, which in this case is 'position'. While the implementation has changed, the intention remains the same; they both return a boolean value indicating the presence or absence of the given key. However, it is possible that there might be some edge cases where 'containsKey' and 'indexOfKey >= 0' could potentially behave differently (due to implementation details of the collection class). Therefore, we assume a potential change in the return value, making it a CI type 1."
1333,<android.app.admin.DevicePolicyManager: boolean isDeviceOwnerApp(String)>,23,24,<android.app.admin.DevicePolicyManager: boolean isDeviceOwnerApp(String)>,<android.app.admin.DevicePolicyManager: boolean isDeviceOwnerApp(String)>,0,"{
    if (mService != null) {
        try {
            return mService.isDeviceOwner(packageName);
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed to check device owner"");
        }
    }
    return false;
}","{
    throwIfParentInstance(""isDeviceOwnerApp"");
    return isDeviceOwnerAppOnCallingUser(packageName);
}",1,"/**
 * Used to determine if a particular package has been registered as a Device Owner app.
 * A device owner app is a special device admin that cannot be deactivated by the user, once
 * activated as a device admin. It also cannot be uninstalled. To check whether a particular
 * package is currently registered as the device owner app, pass in the package name from
 * {@link Context#getPackageName()} to this method.<p/>This is useful for device
 * admin apps that want to check whether they are also registered as the device owner app. The
 * exact mechanism by which a device admin app is registered as a device owner app is defined by
 * the setup process.
 * @param packageName the package name of the app, to compare with the registered device owner
 * app, if any.
 * @return whether or not the package is registered as the device owner app.
 */
","/**
 * Used to determine if a particular package has been registered as a Device Owner app.
 * A device owner app is a special device admin that cannot be deactivated by the user, once
 * activated as a device admin. It also cannot be uninstalled. To check whether a particular
 * package is currently registered as the device owner app, pass in the package name from
 * {@link Context#getPackageName()} to this method.<p/>This is useful for device
 * admin apps that want to check whether they are also registered as the device owner app. The
 * exact mechanism by which a device admin app is registered as a device owner app is defined by
 * the setup process.
 * @param packageName the package name of the app, to compare with the registered device owner
 * app, if any.
 * @return whether or not the package is registered as the device owner app.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The late version of the API now calls a different method, and the control flow has been changed due to the addition of the throwIfParentInstance(""isDeviceOwnerApp"") method call. Moreover, a new method, isDeviceOwnerAppOnCallingUser(packageName), replaces the previous call to the remote service (mService.isDeviceOwner(packageName)). It also removes the try-catch block that handled RemoteException. There is also an ""Other statement changed"" type of code change as the early version contains a log statement that has now been removed. Therefore, the code change type is 1,3,4,5.","The introduction of throwIfParentInstance could throw a runtime exception, which is not caught by any try-catch block, and the removal of the try-catch block that was handling RemoteException means that RemoteExceptions are no longer caught and logged but will propagate up to the caller. As for the behavior, the method isDeviceOwnerAppOnCallingUser may have different logic for checking device ownership, which could potentially lead to a different return value. Hence, the CI is 1 due to both the potential for different return values and different exception handling."
1335,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForUser(int,String,long,long)>",23,24,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForUser(int,String,long,long)>","<android.app.usage.NetworkStatsManager: Bucket querySummaryForUser(int,String,long,long)>",0,"{
    NetworkTemplate template = createTemplate(networkType, subscriberId);
    if (template == null) {
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}",1,"/**
 * Query network usage statistics summaries. Result is summarised data usage for all uids
 * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
 * This means the bucket's start and end timestamp are going to be the same as the 'startTime'
 * and 'endTime' parameters, state is going to be {@link NetworkStats.Bucket#STATE_ALL} and uid
 * {@link NetworkStats.Bucket#UID_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result is summarised data usage for all uids
 * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
 * This means the bucket's start and end timestamp are going to be the same as the 'startTime'
 * and 'endTime' parameters, state is going to be {@link NetworkStats.Bucket#STATE_ALL} and uid
 * {@link NetworkStats.Bucket#UID_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The implementation now introduces a 'try' block, and an exception handling 'catch' block for IllegalArgumentException. Within the 'try' block, it creates a new NetworkTemplate. This change also affects the control dependency because now there is an additional level of control around the creation of the NetworkTemplate. Since the exception handling changes, and the catching of IllegalArgumentException can result from a change in the createTemplate method (a dependent API), the change types are 2,3,5.","A change in the exception handling may lead to a CI because IllegalArgumentException can now be caught and the method may return null, where previously an uncaught IllegalArgumentException would not be handled. This means the behavior of the method can change, leading to different return values or throwing a different exception. Thus, the CI types are 1,2."
1337,"<android.database.sqlite.SQLiteConnection.OperationLog: int beginOperation(String,String,Object[])>",23,24,"<android.database.sqlite.SQLiteConnection.OperationLog: int beginOperation(String,String,Object[])>","<android.database.sqlite.SQLiteConnection.OperationLog: int beginOperation(String,String,Object[])>",0,"{
    synchronized (mOperations) {
        final int index = (mIndex + 1) % MAX_RECENT_OPERATIONS;
        Operation operation = mOperations[index];
        if (operation == null) {
            operation = new Operation();
            mOperations[index] = operation;
        } else {
            operation.mFinished = false;
            operation.mException = null;
            if (operation.mBindArgs != null) {
                operation.mBindArgs.clear();
            }
        }
        operation.mStartTime = System.currentTimeMillis();
        operation.mKind = kind;
        operation.mSql = sql;
        if (bindArgs != null) {
            if (operation.mBindArgs == null) {
                operation.mBindArgs = new ArrayList<Object>();
            } else {
                operation.mBindArgs.clear();
            }
            for (int i = 0; i < bindArgs.length; i++) {
                final Object arg = bindArgs[i];
                if (arg != null && arg instanceof byte[]) {
                    // Don't hold onto the real byte array longer than necessary.
                    operation.mBindArgs.add(EMPTY_BYTE_ARRAY);
                } else {
                    operation.mBindArgs.add(arg);
                }
            }
        }
        operation.mCookie = newOperationCookieLocked(index);
        mIndex = index;
        return operation.mCookie;
    }
}","{
    synchronized (mOperations) {
        final int index = (mIndex + 1) % MAX_RECENT_OPERATIONS;
        Operation operation = mOperations[index];
        if (operation == null) {
            operation = new Operation();
            mOperations[index] = operation;
        } else {
            operation.mFinished = false;
            operation.mException = null;
            if (operation.mBindArgs != null) {
                operation.mBindArgs.clear();
            }
        }
        operation.mStartWallTime = System.currentTimeMillis();
        operation.mStartTime = SystemClock.uptimeMillis();
        operation.mKind = kind;
        operation.mSql = sql;
        if (bindArgs != null) {
            if (operation.mBindArgs == null) {
                operation.mBindArgs = new ArrayList<Object>();
            } else {
                operation.mBindArgs.clear();
            }
            for (int i = 0; i < bindArgs.length; i++) {
                final Object arg = bindArgs[i];
                if (arg != null && arg instanceof byte[]) {
                    // Don't hold onto the real byte array longer than necessary.
                    operation.mBindArgs.add(EMPTY_BYTE_ARRAY);
                } else {
                    operation.mBindArgs.add(arg);
                }
            }
        }
        operation.mCookie = newOperationCookieLocked(index);
        if (Trace.isTagEnabled(Trace.TRACE_TAG_DATABASE)) {
            Trace.asyncTraceBegin(Trace.TRACE_TAG_DATABASE, operation.getTraceMethodName(), operation.mCookie);
        }
        mIndex = index;
        return operation.mCookie;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"Two statements for setting the start time have been modified; one additional timestamping line ('operation.mStartWallTime = System.currentTimeMillis();'), and the original timestamp line has changed from 'operation.mStartTime = System.currentTimeMillis();' to 'operation.mStartTime = SystemClock.uptimeMillis();'. Additionally, there is an added control statement for tracing the operation ('if (Trace.isTagEnabled(Trace.TRACE_TAG_DATABASE)) { Trace.asyncTraceBegin(Trace.TRACE_TAG_DATABASE, operation.getTraceMethodName(), operation.mCookie); }'), hence the code change type is 3,4.","There is no compatibility issue introduced by these changes because they relate to tracing and timing information which does not affect the API's return value or its exception handling. The method still returns 'operation.mCookie' which is calculated in the same way in both versions, and neither version introduces new exceptions that could be thrown. Thus, the CI type is 0."
1338,"<android.content.res.Resources: Drawable getDrawable(int,Theme)>",23,24,"<android.content.res.Resources: Drawable getDrawable(int,Theme)>","<android.content.res.Resources: Drawable getDrawable(int,Theme)>",0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValue(id, value, true);
    }
    final Drawable res = loadDrawable(value, id, theme);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        return impl.loadDrawable(this, value, id, theme, true);
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Return a drawable object associated with a particular resource ID and
 * styled for the specified theme. Various types of objects will be
 * returned depending on the underlying resource -- for example, a solid
 * color, PNG image, scalable image, etc.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param theme The theme used to style the drawable attributes, may be {@code null}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
","/**
 * Return a drawable object associated with a particular resource ID and
 * styled for the specified theme. Various types of objects will be
 * returned depending on the underlying resource -- for example, a solid
 * color, PNG image, scalable image, etc.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param theme The theme used to style the drawable attributes, may be {@code null}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
",-1,[@Nullable],,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The logic for obtaining, using, and releasing a `TypedValue` has been restructured with the introduction of `obtainTempTypedValue()` and `releaseTempTypedValue(value)`. There is a newly introduced try-finally block, deletion of synchronized blocks, changes in the variable 'value' initialization, and how the value is returned. Additionally, dependent API `loadDrawable()` invocation has changed to include a different set of parameters and call on a different object (`impl` instead of `this`). Therefore, the code change type is 1,3,4,5.","Since the method of obtaining a `TypedValue` object has changed, the method by which `loadDrawable()` is called has changed, and the `theme` parameter is now explicitly used in the `loadDrawable` call, the API could potentially return a different Drawable or behave differently, thus the CI type is 1."
1339,<android.app.Notification.Builder: Bundle getExtras()>,23,24,<android.app.Notification.Builder: Bundle getExtras()>,<android.app.Notification.Builder: Bundle getExtras()>,0,"{
    if (mExtras == null) {
        mExtras = new Bundle();
    }
    return mExtras;
}","{
    return mUserExtras;
}",1,"/**
 * Get the current metadata Bundle used by this notification Builder.
 *
 * <p>The returned Bundle is shared with this Builder.
 *
 * <p>The current contents of this Bundle are copied into the Notification each time
 * {@link #build()} is called.
 *
 * @see Notification#extras
 */
","/**
 * Get the current metadata Bundle used by this notification Builder.
 *
 * <p>The returned Bundle is shared with this Builder.
 *
 * <p>The current contents of this Bundle are copied into the Notification each time
 * {@link #build()} is called.
 *
 * @see Notification#extras
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning a variable 'mExtras', possibly initializing it if it's null, to returning a different variable 'mUserExtras'. The source of the data being returned has changed, which is reflected in the code change type 1.","The change of the return statement will make the API potentially return a different value, which is the content of 'mUserExtras' instead of 'mExtras', so the CI type is 1."
1340,<android.app.admin.DevicePolicyManager: boolean getScreenCaptureDisabled(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean getScreenCaptureDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getScreenCaptureDisabled(ComponentName)>,0,"{
    return getScreenCaptureDisabled(admin, UserHandle.myUserId());
}","{
    throwIfParentInstance(""getScreenCaptureDisabled"");
    return getScreenCaptureDisabled(admin, myUserId());
}",1,"/**
 * Determine whether or not screen capture has been disabled by the current
 * admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled screen capture.
 */
","/**
 * Determine whether or not screen capture has been disabled by the calling
 * admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled screen capture.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The change in the implementation includes adding a new method call (throwIfParentInstance(""getScreenCaptureDisabled"")), changing the method call from UserHandle.myUserId() to myUserId(), and introducing new control flow (the new method may throw an exception), so the code change types are 1,3,4.","The new method call throwIfParentInstance(""getScreenCaptureDisabled"") could potentially throw a new exception that the early version does not throw, hence leading to a possible Compatibility Issue of type 2. Also, the change in the method being called to obtain the user ID (from UserHandle.myUserId() to myUserId()) could potentially return a different value if myUserId() behaves differently from UserHandle.myUserId(), resulting in a Compatibility Issue of type 1."
1341,"<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>",23,24,"<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>","<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    FileChannel fileChannel = null;
    synchronized (mStateLock) {
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mStarted) {
            Log.e(TAG, ""Start called twice"");
            return TextToSpeech.ERROR;
        }
        mStarted = true;
        mSampleRateInHz = sampleRateInHz;
        mAudioFormat = audioFormat;
        mChannelCount = channelCount;
        if (mDispatcher != null) {
            mDispatcher.dispatchOnStart();
        }
        fileChannel = mFileChannel;
    }
    try {
        fileChannel.write(ByteBuffer.allocate(WAV_HEADER_LENGTH));
        return TextToSpeech.SUCCESS;
    } catch (IOException ex) {
        Log.e(TAG, ""Failed to write wav header to output file descriptor"", ex);
        synchronized (mStateLock) {
            cleanUp();
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
        }
        return TextToSpeech.ERROR;
    }
}","{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    if (audioFormat != AudioFormat.ENCODING_PCM_8BIT && audioFormat != AudioFormat.ENCODING_PCM_16BIT && audioFormat != AudioFormat.ENCODING_PCM_FLOAT) {
        Log.e(TAG, ""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT"");
    }
    mDispatcher.dispatchOnBeginSynthesis(sampleRateInHz, audioFormat, channelCount);
    FileChannel fileChannel = null;
    synchronized (mStateLock) {
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mStarted) {
            Log.e(TAG, ""Start called twice"");
            return TextToSpeech.ERROR;
        }
        mStarted = true;
        mSampleRateInHz = sampleRateInHz;
        mAudioFormat = audioFormat;
        mChannelCount = channelCount;
        mDispatcher.dispatchOnStart();
        fileChannel = mFileChannel;
    }
    try {
        fileChannel.write(ByteBuffer.allocate(WAV_HEADER_LENGTH));
        return TextToSpeech.SUCCESS;
    } catch (IOException ex) {
        Log.e(TAG, ""Failed to write wav header to output file descriptor"", ex);
        synchronized (mStateLock) {
            cleanUp();
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
        }
        return TextToSpeech.ERROR;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The added conditional block checking ""audioFormat"" along with the new method call to `mDispatcher.dispatchOnBeginSynthesis(sampleRateInHz, audioFormat, channelCount);` which is not present in the early version represent a change in other statements as well as in control dependency. Therefore, the change categories are 3 and 4.","The introduction of the check for ""audioFormat"" and the new call to `mDispatcher.dispatchOnBeginSynthesis` could potentially lead to different behaviors. Should the ""audioFormat"" parameter not meet the new requirements, the method would now continue executing without logging an error, and the invocation of `dispatchOnBeginSynthesis` introduces a change in execution flow that could affect the output, thus a CI from potentially different return values is present. The CI type is 1."
1342,"<android.widget.LinearLayout: void measureVertical(int,int)>",23,24,"<android.widget.LinearLayout: void measureVertical(int,int)>","<android.widget.LinearLayout: void measureVertical(int,int)>",0,"{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = heightSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}","{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}",1,"/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
","/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1343,"<android.app.DownloadManager: long addCompletedDownload(String,String,boolean,String,String,long,boolean)>",23,24,"<android.app.DownloadManager: long addCompletedDownload(String,String,boolean,String,String,long,boolean)>","<android.app.DownloadManager: long addCompletedDownload(String,String,boolean,String,String,long,boolean)>",0,"{
    return addCompletedDownload(title, description, isMediaScannerScannable, mimeType, path, length, showNotification, false);
}","{
    return addCompletedDownload(title, description, isMediaScannerScannable, mimeType, path, length, showNotification, false, null, null);
}",1,"/**
 * Adds a file to the downloads database system, so it could appear in Downloads App
 * (and thus become eligible for management by the Downloads App).
 * <p>
 * It is helpful to make the file scannable by MediaScanner by setting the param
 * isMediaScannerScannable to true. It makes the file visible in media managing
 * applications such as Gallery App, which could be a useful purpose of using this API.
 *
 * @param title the title that would appear for this file in Downloads App.
 * @param description the description that would appear for this file in Downloads App.
 * @param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
 * scanned by MediaScanner appear in the applications used to view media (for example,
 * Gallery app).
 * @param mimeType mimetype of the file.
 * @param path absolute pathname to the file. The file should be world-readable, so that it can
 * be managed by the Downloads App and any other app that is used to read it (for example,
 * Gallery app to display the file, if the file contents represent a video/image).
 * @param length length of the downloaded file
 * @param showNotification true if a notification is to be sent, false otherwise
 * @return  an ID for the download entry added to the downloads app, unique across the system
 * This ID is used to make future calls related to this download.
 */
","/**
 * Adds a file to the downloads database system, so it could appear in Downloads App
 * (and thus become eligible for management by the Downloads App).
 * <p>
 * It is helpful to make the file scannable by MediaScanner by setting the param
 * isMediaScannerScannable to true. It makes the file visible in media managing
 * applications such as Gallery App, which could be a useful purpose of using this API.
 *
 * @param title the title that would appear for this file in Downloads App.
 * @param description the description that would appear for this file in Downloads App.
 * @param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
 * scanned by MediaScanner appear in the applications used to view media (for example,
 * Gallery app).
 * @param mimeType mimetype of the file.
 * @param path absolute pathname to the file. The file should be world-readable, so that it can
 * be managed by the Downloads App and any other app that is used to read it (for example,
 * Gallery app to display the file, if the file contents represent a video/image).
 * @param length length of the downloaded file
 * @param showNotification true if a notification is to be sent, false otherwise
 * @return  an ID for the download entry added to the downloads app, unique across the system
 * This ID is used to make future calls related to this download.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The implementation has changed to call a different overload of the addCompletedDownload method, one with two additional parameters (null, null). Therefore, the change type includes 1 for the return statement modified, and 5 because a dependent API is invoked with additional parameters.","There is no Compatibility Issue as the additional parameters passed to the dependent API are static values ('null'), which do not affect the behavior of the current API. It will not change the return type or the exceptions that are thrown. Hence, the CI type is 0."
1345,"<android.util.Log: int d(String,String,Throwable)>",23,24,"<android.util.Log: int d(String,String,Throwable)>","<android.util.Log: int d(String,String,Throwable)>",0,"{
    return println_native(LOG_ID_MAIN, DEBUG, tag, msg + '\n' + getStackTraceString(tr));
}","{
    return printlns(LOG_ID_MAIN, DEBUG, tag, msg, tr);
}",1,"/**
 * Send a {@link #DEBUG} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
","/**
 * Send a {@link #DEBUG} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changed from calling `println_native` with string concatenation to calling `printlns` with separate parameters, which indicates that the dependent API (`printlns` instead of `println_native`) is called. This is a dependent API change, thus the code change type is 5.","The change does not introduce any new behaviors in terms of return values or exception throwing; it merely moves the responsibility of formatting and handling the message and throwable to another method. As long as the `printlns` method preserves the contract of the previous implementation in concatenating the message and stack trace, and since both versions are returning the result of the called method with the same parameters that correspond to the three arguments (logging tag, message, and throwable), there should not be a compatibility issue. Thus, the CI type is 0."
1346,<android.content.res.Configuration: String toString()>,23,24,<android.content.res.Configuration: String toString()>,<android.content.res.Configuration: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    if (locale != null) {
        sb.append("" "");
        sb.append(locale);
    } else {
        sb.append("" ?locale"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        case UI_MODE_TYPE_WATCH:
            sb.append("" watch"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    fixUpLocaleList();
    if (!mLocaleList.isEmpty()) {
        sb.append("" "");
        sb.append(mLocaleList);
    } else {
        sb.append("" ?localeList"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        case UI_MODE_TYPE_WATCH:
            sb.append("" watch"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
1347,"<android.os.BinderProxy: boolean transact(int,Parcel,Parcel,int)>",23,24,"<android.os.BinderProxy: boolean transact(int,Parcel,Parcel,int)>","<android.os.BinderProxy: boolean transact(int,Parcel,Parcel,int)>",0,"{
    Binder.checkParcel(this, code, data, ""Unreasonably large binder buffer"");
    return transactNative(code, data, reply, flags);
}","{
    Binder.checkParcel(this, code, data, ""Unreasonably large binder buffer"");
    if (Binder.isTracingEnabled()) {
        Binder.getTransactionTracker().addTrace();
    }
    return transactNative(code, data, reply, flags);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"An if-statement checking if tracing is enabled and a method call to addTrace() if true is introduced, which does not affect how the method performs a transaction or the result of the method. Therefore, the change is classified as another statement that has been changed, which is type 4.","The newly introduced tracing functionality only records additional information and does not interfere with the method's transaction process or outcome. Hence, there is no Compatibility Issue arising from this change. The Compatibility Issue situation is 0, as there is no impact on the method's return value or exception handling."
1348,<android.widget.TimePicker: Integer getCurrentMinute()>,23,24,<android.widget.TimePicker: Integer getCurrentMinute()>,<android.widget.TimePicker: Integer getCurrentMinute()>,0,"{
    return mDelegate.getCurrentMinute();
}","{
    return mDelegate.getMinute();
}",1,"/**
 * @return the current minute
 * @deprecated Use {@link #getMinute()}
 */
","/**
 * @return the current minute
 * @deprecated Use {@link #getMinute()}
 */
",-1,"[@NonNull, @Deprecated]","[@NonNull, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The implementation calls a different method on mDelegate, changing from getCurrentMinute() to getMinute() without altering the method signature of the API itself, so the code change type is 5.","Assuming that the new getMinute() method is functionally equivalent to the deprecated getCurrentMinute() method and that it returns the same type of value, there's no indication that this change leads to a Compatibility Issue. Thus, the CI type is 0."
1350,<android.app.Notification.Action.Builder: Action build()>,23,24,<android.app.Notification.Action.Builder: Action build()>,<android.app.Notification.Action.Builder: Action build()>,0,"{
    RemoteInput[] remoteInputs = mRemoteInputs != null ? mRemoteInputs.toArray(new RemoteInput[mRemoteInputs.size()]) : null;
    return new Action(mIcon, mTitle, mIntent, mExtras, remoteInputs);
}","{
    RemoteInput[] remoteInputs = mRemoteInputs != null ? mRemoteInputs.toArray(new RemoteInput[mRemoteInputs.size()]) : null;
    return new Action(mIcon, mTitle, mIntent, mExtras, remoteInputs, mAllowGeneratedReplies);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor call for 'new Action' has changed by including an additional parameter 'mAllowGeneratedReplies' in the late version. Therefore, the code change type is 1,5 as both the return statement and the parameters of a dependent API constructor change.",This modification potentially leads to a Compatibility Issue as the Action object returned by the method may now include new or different behavior due to the additional parameter 'mAllowGeneratedReplies'. This would fall under type 1 because it concerns the returned object which may be different in the late version.
1351,<android.app.Fragment: void performStop()>,23,24,<android.app.Fragment: void performStop()>,<android.app.Fragment: void performStop()>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchStop();
    }
    mCalled = false;
    onStop();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onStop()"");
    }
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (!mCheckedForLoaderManager) {
            mCheckedForLoaderManager = true;
            mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, false);
        }
        if (mLoaderManager != null) {
            if (mRetaining) {
                mLoaderManager.doRetain();
            } else {
                mLoaderManager.doStop();
            }
        }
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchStop();
    }
    mState = STOPPED;
    mCalled = false;
    onStop();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onStop()"");
    }
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (!mCheckedForLoaderManager) {
            mCheckedForLoaderManager = true;
            mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, false);
        }
        if (mLoaderManager != null) {
            if (mHost.getRetainLoaders()) {
                mLoaderManager.doRetain();
            } else {
                mLoaderManager.doStop();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the introduction of the assignment `mState = STOPPED;` which does not alter the return value or exception handling. Therefore, the code change type is 4.","There's no Compatibility Issue since the change does not involve any difference in the API's behavior in terms of controlling application flow, exception handling, or return values. The state assignment does not directly affect the output visible to the caller of the method."
1352,<android.accessibilityservice.AccessibilityServiceInfo: String capabilityToString(int)>,23,24,<android.accessibilityservice.AccessibilityServiceInfo: String capabilityToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String capabilityToString(int)>,0,"{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return ""CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT"";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return ""CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION"";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return ""CAPABILITY_CAN_FILTER_KEY_EVENTS"";
        default:
            return ""UNKNOWN"";
    }
}","{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return ""CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT"";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return ""CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION"";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return ""CAPABILITY_CAN_FILTER_KEY_EVENTS"";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return ""CAPABILITY_CAN_CONTROL_MAGNIFICATION"";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return ""CAPABILITY_CAN_PERFORM_GESTURES"";
        default:
            return ""UNKNOWN"";
    }
}",1,"/**
 * Returns the string representation of a capability. For example,
 * {@link #CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT} is represented
 * by the string CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT.
 *
 * @param capability The capability.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a capability. For example,
 * {@link #CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT} is represented
 * by the string CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT.
 *
 * @param capability The capability.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"New case statements have been added to the switch block to handle additional constants. This change is classified as other statement changed (code change type 4) because new return statements are introduced within the context of the switch control block, which is also considered a control dependency change (code change type 3).","There is no compatibility issue here, as the method has only been extended with new cases, which will not affect existing behavior for previously defined capabilities. It will simply provide new strings for additional capabilities (if the new constants are used), while still returning the same strings for the already defined capabilities in the early version. Thus, existing code that relies on this method will continue to work as expected, and no CI is introduced."
1353,<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,0,"{
    if (mService != null) {
        try {
            mService.removeActiveAdmin(admin, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""removeActiveAdmin"");
    if (mService != null) {
        try {
            mService.removeActiveAdmin(admin, myUserId());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Remove a current administration component.  This can only be called
 * by the application that owns the administration component; if you
 * try to remove someone else's component, a security exception will be
 * thrown.
 */
","/**
 * Remove a current administration component.  This can only be called
 * by the application that owns the administration component; if you
 * try to remove someone else's component, a security exception will be
 * thrown.
 *
 * <p>Note that the operation is not synchronous and the admin might still be active (as
 * indicated by {@link #getActiveAdmins()}) by the time this method returns.
 *
 * @param admin The administration compononent to remove.
 * @throws SecurityException if the caller is not in the owner application of {@code admin}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5",2,"There have been several changes in the code. A method call `throwIfParentInstance(""removeActiveAdmin"")` has been added at the beginning of the method, which is an ""Other statement changed"" and could potentially throw an exception since it is not wrapped in a try-catch block, marking it as a 4. The RemoteException handling within the try-catch block has changed from logging the exception to rethrowing it, which is an ""Exception handling statement changed"", indicating a 2. Additionally, `UserHandle.myUserId()` has been replaced by `myUserId()`, which is a change in a method call, indicating a ""Dependent API changed"", marking it as 5. No control dependency change has occurred as the control structures (`if` and `try` blocks) have not been modified or moved, except for the added `throwIfParentInstance` call which doesn't fall under the control dependency definition provided.","The potentially thrown exception from `throwIfParentInstance(""removeActiveAdmin"")` presents a new behavior that could cause a ""Compatibility Issue caused by potential different exception handlings"", and the way the `RemoteException` is handled has changed—instead of just logging the exception, it is being rethrown. These changes can cause the behavior of the method to differ from the previous version by potentially generating a different exception behavior, so the CI type is 2."
1354,"<android.app.Notification.Builder: Builder setTicker(CharSequence,RemoteViews)>",23,24,"<android.app.Notification.Builder: Builder setTicker(CharSequence,RemoteViews)>","<android.app.Notification.Builder: Builder setTicker(CharSequence,RemoteViews)>",0,"{
    mTickerText = safeCharSequence(tickerText);
    // we'll save it for you anyway
    mTickerView = views;
    return this;
}","{
    setTicker(tickerText);
    // views is ignored
    return this;
}",1,"/**
 * Obsolete version of {@link #setTicker(CharSequence)}.
 */
","/**
 * Obsolete version of {@link #setTicker(CharSequence)}.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The method setTicker(tickerText) is now being called instead of setting mTickerText and mTickerView directly in the method body. This indicates a change in the dependent API, so the code change type is 5.","There is no Compatibility Issue detected because the setTicker(tickerText) method is expected to encapsulate the functionality of setting mTickerText, and mTickerView is set to be ignored in both versions (which is also reflected by the comment). So, the behavior should remain consistent across versions, despite the change in implementation details."
1355,<android.widget.Editor.SuggestionsPopupWindow.CustomPopupWindow: void dismiss()>,23,24,<android.widget.Editor.SuggestionsPopupWindow.CustomPopupWindow: void dismiss()>,<android.widget.Editor.SuggestionsPopupWindow.CustomPopupWindow: void dismiss()>,0,"{
    super.dismiss();
    getPositionListener().removeSubscriber(SuggestionsPopupWindow.this);
    // Safe cast since show() checks that mTextView.getText() is an Editable
    ((Spannable) mTextView.getText()).removeSpan(mSuggestionRangeSpan);
    mTextView.setCursorVisible(mCursorWasVisibleBeforeSuggestions);
    if (hasInsertionController()) {
        getInsertionController().show();
    }
}","{
    if (!isShowing()) {
        return;
    }
    super.dismiss();
    getPositionListener().removeSubscriber(SuggestionsPopupWindow.this);
    // Safe cast since show() checks that mTextView.getText() is an Editable
    ((Spannable) mTextView.getText()).removeSpan(mSuggestionRangeSpan);
    mTextView.setCursorVisible(mCursorWasVisibleBeforeSuggestions);
    if (hasInsertionController() && !extractedTextModeWillBeStarted()) {
        getInsertionController().show();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",0,"The code change includes the introduction of a new control dependency ""if (!isShowing())"" with an associated return statement, and a change inside the 'if' condition for calling `getInsertionController().show();`. Therefore, the code change types are 1 (for the return statement) and 3 (for the control dependency change).","The change does not introduce a compatibility issue that would affect the behavior in cases other than preventing the method execution if the popup is not showing, which is a logical and non-breaking control flow adjustment. Moreover, the other change introduces a condition under which the insertion controller is not shown when extractedTextModeWillBeStarted() is true, which accounts for additional context but does not imply a behavior that would lead to a compatibility issue. Therefore, no compatibility issue is expected from these changes."
1356,<android.app.Notification.Builder: Builder setVisibility(int)>,23,24,<android.app.Notification.Builder: Builder setVisibility(int)>,<android.app.Notification.Builder: Builder setVisibility(int)>,0,"{
    mVisibility = visibility;
    return this;
}","{
    mN.visibility = visibility;
    return this;
}",1,"/**
 * Specify the value of {@link #visibility}.
 *
 * @param visibility One of {@link #VISIBILITY_PRIVATE} (the default),
 * {@link #VISIBILITY_SECRET}, or {@link #VISIBILITY_PUBLIC}.
 *
 * @return The same Builder.
 */
","/**
 * Specify the value of {@link #visibility}.
 *
 * @param visibility One of {@link #VISIBILITY_PRIVATE} (the default),
 * {@link #VISIBILITY_SECRET}, or {@link #VISIBILITY_PUBLIC}.
 *
 * @return The same Builder.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The member variable where the 'visibility' is being set has changed from 'mVisibility' to 'mN.visibility', this is considered an Other statement changed.","No Compatibility Issue will arise from this change since the method's contract is to set the visibility and return the Builder instance, without any changes to the method's return type or the thrown exceptions. The internal implementation change does not affect the API's expected behavior."
1357,<org.apache.http.conn.ssl.AbstractVerifier: String[] getCNs(X509Certificate)>,23,24,<org.apache.http.conn.ssl.AbstractVerifier: String[] getCNs(X509Certificate)>,<org.apache.http.conn.ssl.AbstractVerifier: String[] getCNs(X509Certificate)>,0,"{
    DistinguishedNameParser dnParser = new DistinguishedNameParser(cert.getSubjectX500Principal());
    List<String> cnList = dnParser.getAllMostSpecificFirst(""cn"");
    if (!cnList.isEmpty()) {
        String[] cns = new String[cnList.size()];
        cnList.toArray(cns);
        return cns;
    } else {
        return null;
    }
}","{
    AndroidDistinguishedNameParser dnParser = new AndroidDistinguishedNameParser(cert.getSubjectX500Principal());
    List<String> cnList = dnParser.getAllMostSpecificFirst(""cn"");
    if (!cnList.isEmpty()) {
        String[] cns = new String[cnList.size()];
        cnList.toArray(cns);
        return cns;
    } else {
        return null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The class name used to create dnParser object is changed from DistinguishedNameParser to AndroidDistinguishedNameParser, which is a change in a dependent API; however, the method's logic and structure remain the same. Therefore, the code change type is 4 (Other statement changed) and 5 (Dependent API changed).","There is no compatibility issue identified as the functionality remains consistent between versions, assuming AndroidDistinguishedNameParser provides the same API and behavior as DistinguishedNameParser. Therefore, CI type is 0 (No Compatibility Issue)."
1358,"<android.view.inputmethod.InputMethodManager: void setAdditionalInputMethodSubtypes(String,InputMethodSubtype[])>",23,24,"<android.view.inputmethod.InputMethodManager: void setAdditionalInputMethodSubtypes(String,InputMethodSubtype[])>","<android.view.inputmethod.InputMethodManager: void setAdditionalInputMethodSubtypes(String,InputMethodSubtype[])>",0,"{
    synchronized (mH) {
        try {
            mService.setAdditionalInputMethodSubtypes(imiId, subtypes);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    synchronized (mH) {
        try {
            mService.setAdditionalInputMethodSubtypes(imiId, subtypes);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Set additional input method subtypes. Only a process which shares the same uid with the IME
 * can add additional input method subtypes to the IME.
 * Please note that a subtype's status is stored in the system.
 * For example, enabled subtypes are remembered by the framework even after they are removed
 * by using this method. If you re-add the same subtypes again,
 * they will just get enabled. If you want to avoid such conflicts, for instance, you may
 * want to create a ""different"" new subtype even with the same locale and mode,
 * by changing its extra value. The different subtype won't get affected by the stored past
 * status. (You may want to take a look at {@link InputMethodSubtype#hashCode()} to refer
 * to the current implementation.)
 * @param imiId Id of InputMethodInfo which additional input method subtypes will be added to.
 * @param subtypes subtypes will be added as additional subtypes of the current input method.
 */
","/**
 * Set additional input method subtypes. Only a process which shares the same uid with the IME
 * can add additional input method subtypes to the IME.
 * Please note that a subtype's status is stored in the system.
 * For example, enabled subtypes are remembered by the framework even after they are removed
 * by using this method. If you re-add the same subtypes again,
 * they will just get enabled. If you want to avoid such conflicts, for instance, you may
 * want to create a ""different"" new subtype even with the same locale and mode,
 * by changing its extra value. The different subtype won't get affected by the stored past
 * status. (You may want to take a look at {@link InputMethodSubtype#hashCode()} to refer
 * to the current implementation.)
 *
 * <p>NOTE: If the same subtype exists in both the manifest XML file and additional subtypes
 * specified by {@code subtypes}, those multiple instances are automatically merged into one
 * instance.</p>
 *
 * <p>CAVEAT: In API Level 23 and prior, the system may do nothing if an empty
 * {@link InputMethodSubtype} is specified in {@code subtypes}, which prevents you from removing
 * the last one entry of additional subtypes. If your IME statically defines one or more
 * subtypes in the manifest XML file, you may be able to work around this limitation by
 * specifying one of those statically defined subtypes in {@code subtypes}.</p>
 *
 * @param imiId Id of InputMethodInfo which additional input method subtypes will be added to.
 * @param subtypes subtypes will be added as additional subtypes of the current input method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"There is a change in the exception handling statement: where it previously logged the exception, it now throws it, so the change type is 2.","The changed exception handling will lead to different behaviors when exceptions occur, as the late version will throw the exception instead of simply logging it. Hence, the CI type is 2."
1359,<android.content.res.Resources: Theme newTheme()>,23,24,<android.content.res.Resources: Theme newTheme()>,<android.content.res.Resources: Theme newTheme()>,0,"{
    return new Theme();
}","{
    Theme theme = new Theme();
    theme.setImpl(mResourcesImpl.newThemeImpl());
    mThemeRefs.add(new WeakReference<>(theme));
    return theme;
}",1,"/**
 * Generate a new Theme object for this set of Resources.  It initially
 * starts out empty.
 *
 * @return Theme The newly created Theme container.
 */
","/**
 * Generate a new Theme object for this set of Resources.  It initially
 * starts out empty.
 *
 * @return Theme The newly created Theme container.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation has added initialization for the Theme using setImpl and a mechanism to keep track of theme references using mThemeRefs, which affects instantiation of Theme object. These alterations are not present in the earlier version, so the code change type is 1,4.","Given that the returned Theme object now has additional operations performed on it before return (e.g., setImpl is being called, and the theme is being added to mThemeRefs), the behavior of the returned Theme object could be different. Thus, this change could potentially lead to a returned object with different state, so CI type is 1."
1361,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: boolean isActive()>,23,24,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: boolean isActive()>,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: boolean isActive()>,0,"{
    return mParentInputMethodManager.mActive && mActive;
}","{
    return mParentInputMethodManager.mActive && !isFinished();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The second condition in the return statement has changed from checking if 'mActive' is true to checking if 'isFinished()' is false. This is not a return statement change since the return type and signature remain Boolean; it's a change within the condition, so the code change type is 4.","As the condition within the return statement has been altered, the API could potentially return a different value. The 'isActive' method may now return a different result because it no longer directly relies on 'mActive', but instead calls 'isFinished()', potentially leading to a different behavior. Therefore, the CI type is 1."
1362,"<android.app.admin.DevicePolicyManager: void addCrossProfileIntentFilter(ComponentName,IntentFilter,int)>",23,24,"<android.app.admin.DevicePolicyManager: void addCrossProfileIntentFilter(ComponentName,IntentFilter,int)>","<android.app.admin.DevicePolicyManager: void addCrossProfileIntentFilter(ComponentName,IntentFilter,int)>",0,"{
    if (mService != null) {
        try {
            mService.addCrossProfileIntentFilter(admin, filter, flags);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""addCrossProfileIntentFilter"");
    if (mService != null) {
        try {
            mService.addCrossProfileIntentFilter(admin, filter, flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by the profile owner of a managed profile so that some intents sent in the managed
 * profile can also be resolved in the parent, or vice versa.
 * Only activity intents are supported.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param filter The {@link IntentFilter} the intent has to match to be also resolved in the
 * other profile
 * @param flags {@link DevicePolicyManager#FLAG_MANAGED_CAN_ACCESS_PARENT} and
 * {@link DevicePolicyManager#FLAG_PARENT_CAN_ACCESS_MANAGED} are supported.
 */
","/**
 * Called by the profile owner of a managed profile so that some intents sent in the managed
 * profile can also be resolved in the parent, or vice versa. Only activity intents are
 * supported.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param filter The {@link IntentFilter} the intent has to match to be also resolved in the
 * other profile
 * @param flags {@link DevicePolicyManager#FLAG_MANAGED_CAN_ACCESS_PARENT} and
 * {@link DevicePolicyManager#FLAG_PARENT_CAN_ACCESS_MANAGED} are supported.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The late version introduces a new method call (throwIfParentInstance(""addCrossProfileIntentFilter"")) before the existing statements, and changes the exception handling by throwing the exception instead of logging it. This constitutes a control dependency change (3) since a new control flow is introduced, an exception handling statement (2) as the behavior in exception handling has changed, and since a new method call is a change in the statements (4).","The new method call could potentially throw an exception, altering the control flow. Furthermore, the RemoteException is no longer caught and logged; it is rethrown, which constitutes a change in the behavior of exception handling. These changes could lead to a Compatibility Issue of type 2 due to the different exception handling."
1365,<android.app.admin.DeviceAdminInfo: CharSequence loadDescription(PackageManager)>,23,24,<android.app.admin.DeviceAdminInfo: CharSequence loadDescription(PackageManager)>,<android.app.admin.DeviceAdminInfo: CharSequence loadDescription(PackageManager)>,0,"{
    if (mReceiver.activityInfo.descriptionRes != 0) {
        String packageName = mReceiver.resolvePackageName;
        ApplicationInfo applicationInfo = null;
        if (packageName == null) {
            packageName = mReceiver.activityInfo.packageName;
            applicationInfo = mReceiver.activityInfo.applicationInfo;
        }
        return pm.getText(packageName, mReceiver.activityInfo.descriptionRes, applicationInfo);
    }
    throw new NotFoundException();
}","{
    if (mActivityInfo.descriptionRes != 0) {
        return pm.getText(mActivityInfo.packageName, mActivityInfo.descriptionRes, mActivityInfo.applicationInfo);
    }
    throw new NotFoundException();
}",1,"/**
 * Load user-visible description associated with this device admin.
 *
 * @param pm Supply a PackageManager used to load the device admin's
 * resources.
 */
","/**
 * Load user-visible description associated with this device admin.
 *
 * @param pm Supply a PackageManager used to load the device admin's
 * resources.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"There is a control dependency change in the way members of the activity info are accessed (from ""mReceiver.activityInfo"" to ""mActivityInfo"") along with the removal of conditional logic regarding the ""packageName"" and ""applicationInfo."" The structure of the code and the variables it depends upon have changed, which is considered a change in dependent APIs too because the structure and the intermediate variables used to obtain the parameters for pm.getText() have been modified.","Since the ""package name"" and ""application info"" that were conditionally set by either ""mReceiver.resolvePackageName"" or ""mReceiver.activityInfo.packageName"" and ""mReceiver.activityInfo.applicationInfo"" are now directly accessed using ""mActivityInfo"" without those conditions, the behavior of calling pm.getText() might differ due to these differences in handling the inputs. Therefore, the CI type is 1."
1366,<android.content.res.Resources: CharSequence[] getTextArray(int)>,23,24,<android.content.res.Resources: CharSequence[] getTextArray(int)>,<android.content.res.Resources: CharSequence[] getTextArray(int)>,0,"{
    CharSequence[] res = mAssets.getResourceTextArray(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""Text array resource ID #0x"" + Integer.toHexString(id));
}","{
    CharSequence[] res = mResourcesImpl.getAssets().getResourceTextArray(id);
    if (res != null) {
        return res;
    }
    throw new NotFoundException(""Text array resource ID #0x"" + Integer.toHexString(id));
}",1,"/**
 * Return the styled text array associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return The styled text array associated with the resource.
 */
","/**
 * Return the styled text array associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return The styled text array associated with the resource.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The code change involves calling getResourceTextArray() on a different object (mAssets to mResourcesImpl.getAssets()), which classifies as a dependent API changed (5).","The method's behavior remains consistent even though the object on which `getResourceTextArray` is called has changed. The same exception is thrown under the same condition, and the return value is unchanged if `res` is not null. Thus, there is no compatibility issue (0)."
1367,"<android.os.Parcel: void writeArrayMapInternal(ArrayMap<String, Object>)>",23,24,"<android.os.Parcel: void writeArrayMapInternal(ArrayMap<String, Object>)>","<android.os.Parcel: void writeArrayMapInternal(ArrayMap<String, Object>)>",0,"{
    if (val == null) {
        writeInt(-1);
        return;
    }
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException(""here"");
        here.fillInStackTrace();
        Log.d(TAG, ""Writing "" + N + "" ArrayMap entries"", here);
    }
    int startPos;
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            startPos = dataPosition();
        writeString(val.keyAt(i));
        writeValue(val.valueAt(i));
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, ""  Write #"" + i + "" "" + (dataPosition() - startPos) + "" bytes: key=0x"" + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + "" "" + val.keyAt(i));
    }
}","{
    if (val == null) {
        writeInt(-1);
        return;
    }
    // Keep the format of this Parcel in sync with writeToParcelInner() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException(""here"");
        here.fillInStackTrace();
        Log.d(TAG, ""Writing "" + N + "" ArrayMap entries"", here);
    }
    int startPos;
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            startPos = dataPosition();
        writeString(val.keyAt(i));
        writeValue(val.valueAt(i));
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, ""  Write #"" + i + "" "" + (dataPosition() - startPos) + "" bytes: key=0x"" + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + "" "" + val.keyAt(i));
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the actual code implementation between the early and late versions. Only a comment was added in the late version, which does not affect the actual functionality or behavior of the method.","No compatibility issues arise from adding a comment, as it does not alter the execution or output of the method."
1368,<android.view.View: void setBackgroundDrawable(Drawable)>,23,24,<android.view.View: void setBackgroundDrawable(Drawable)>,<android.view.View: void setBackgroundDrawable(Drawable)>,0,"{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawablesInternal();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPaddingInternal();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        applyBackgroundTint();
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mViewFlags & WILL_NOT_DRAW) != 0 && (mForegroundInfo == null || mForegroundInfo.mDrawable == null)) {
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}","{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable. setVisible first while we still have the callback set.
         */
    if (mBackground != null) {
        if (isAttachedToWindow()) {
            mBackground.setVisible(false, false);
        }
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawablesInternal();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPaddingInternal();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        // Set mBackground before we set this as the callback and start making other
        // background drawable state change calls. In particular, the setVisible call below
        // can result in drawables attempting to start animations or otherwise invalidate,
        // which requires the view set as the callback (us) to recognize the drawable as
        // belonging to it as per verifyDrawable.
        mBackground = background;
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        if (isAttachedToWindow()) {
            background.setVisible(getWindowVisibility() == VISIBLE && isShown(), false);
        }
        applyBackgroundTint();
        // Set callback last, since the view may still be initializing.
        background.setCallback(this);
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mViewFlags & WILL_NOT_DRAW) != 0 && (mForegroundInfo == null || mForegroundInfo.mDrawable == null)) {
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
    invalidateOutline();
}",1,"/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
","/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,,,,
1369,"<android.app.backup.FullBackup.BackupScheme: void parseBackupSchemeFromXmlLocked(XmlPullParser,Set<String>,Map<String, Set<String>>)>",23,24,"<android.app.backup.FullBackup.BackupScheme: void parseBackupSchemeFromXmlLocked(XmlPullParser,Set<String>,Map<String, Set<String>>)>","<android.app.backup.FullBackup.BackupScheme: void parseBackupSchemeFromXmlLocked(XmlPullParser,Set<String>,Map<String, Set<String>>)>",0,"{
    // START_DOCUMENT
    int event = parser.getEventType();
    while (event != XmlPullParser.START_TAG) {
        event = parser.next();
    }
    if (!""full-backup-content"".equals(parser.getName())) {
        throw new XmlPullParserException(""Xml file didn't start with correct tag"" + "" (<full-backup-content>). Found \"""" + parser.getName() + ""\"""");
    }
    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
        Log.v(TAG_XML_PARSER, ""\n"");
        Log.v(TAG_XML_PARSER, ""===================================================="");
        Log.v(TAG_XML_PARSER, ""Found valid fullBackupContent; parsing xml resource."");
        Log.v(TAG_XML_PARSER, ""===================================================="");
        Log.v(TAG_XML_PARSER, """");
    }
    while ((event = parser.next()) != XmlPullParser.END_DOCUMENT) {
        switch(event) {
            case XmlPullParser.START_TAG:
                validateInnerTagContents(parser);
                final String domainFromXml = parser.getAttributeValue(null, ""domain"");
                final File domainDirectory = getDirectoryForCriteriaDomain(domainFromXml);
                if (domainDirectory == null) {
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...parsing \"""" + parser.getName() + ""\"": "" + ""domain=\"""" + domainFromXml + ""\"" invalid; skipping"");
                    }
                    break;
                }
                final File canonicalFile = extractCanonicalFile(domainDirectory, parser.getAttributeValue(null, ""path""));
                if (canonicalFile == null) {
                    break;
                }
                Set<String> activeSet = parseCurrentTagForDomain(parser, excludes, includes, domainFromXml);
                activeSet.add(canonicalFile.getCanonicalPath());
                if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                    Log.v(TAG_XML_PARSER, ""...parsed "" + canonicalFile.getCanonicalPath() + "" for domain \"""" + domainFromXml + ""\"""");
                }
                // dir, so we add the -journal anyway to be safe.
                if (""database"".equals(domainFromXml) && !canonicalFile.isDirectory()) {
                    final String canonicalJournalPath = canonicalFile.getCanonicalPath() + ""-journal"";
                    activeSet.add(canonicalJournalPath);
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...automatically generated "" + canonicalJournalPath + "". Ignore if nonexistant."");
                    }
                }
        }
    }
    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
        Log.v(TAG_XML_PARSER, ""\n"");
        Log.v(TAG_XML_PARSER, ""Xml resource parsing complete."");
        Log.v(TAG_XML_PARSER, ""Final tally."");
        Log.v(TAG_XML_PARSER, ""Includes:"");
        if (includes.isEmpty()) {
            Log.v(TAG_XML_PARSER, ""  ...nothing specified (This means the entirety of app"" + "" data minus excludes)"");
        } else {
            for (Map.Entry<String, Set<String>> entry : includes.entrySet()) {
                Log.v(TAG_XML_PARSER, ""  domain="" + entry.getKey());
                for (String includeData : entry.getValue()) {
                    Log.v(TAG_XML_PARSER, ""  "" + includeData);
                }
            }
        }
        Log.v(TAG_XML_PARSER, ""Excludes:"");
        if (excludes.isEmpty()) {
            Log.v(TAG_XML_PARSER, ""  ...nothing to exclude."");
        } else {
            for (String excludeData : excludes) {
                Log.v(TAG_XML_PARSER, ""  "" + excludeData);
            }
        }
        Log.v(TAG_XML_PARSER, ""  "");
        Log.v(TAG_XML_PARSER, ""===================================================="");
        Log.v(TAG_XML_PARSER, ""\n"");
    }
}","{
    // START_DOCUMENT
    int event = parser.getEventType();
    while (event != XmlPullParser.START_TAG) {
        event = parser.next();
    }
    if (!""full-backup-content"".equals(parser.getName())) {
        throw new XmlPullParserException(""Xml file didn't start with correct tag"" + "" (<full-backup-content>). Found \"""" + parser.getName() + ""\"""");
    }
    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
        Log.v(TAG_XML_PARSER, ""\n"");
        Log.v(TAG_XML_PARSER, ""===================================================="");
        Log.v(TAG_XML_PARSER, ""Found valid fullBackupContent; parsing xml resource."");
        Log.v(TAG_XML_PARSER, ""===================================================="");
        Log.v(TAG_XML_PARSER, """");
    }
    while ((event = parser.next()) != XmlPullParser.END_DOCUMENT) {
        switch(event) {
            case XmlPullParser.START_TAG:
                validateInnerTagContents(parser);
                final String domainFromXml = parser.getAttributeValue(null, ""domain"");
                final File domainDirectory = getDirectoryForCriteriaDomain(domainFromXml);
                if (domainDirectory == null) {
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...parsing \"""" + parser.getName() + ""\"": "" + ""domain=\"""" + domainFromXml + ""\"" invalid; skipping"");
                    }
                    break;
                }
                final File canonicalFile = extractCanonicalFile(domainDirectory, parser.getAttributeValue(null, ""path""));
                if (canonicalFile == null) {
                    break;
                }
                Set<String> activeSet = parseCurrentTagForDomain(parser, excludes, includes, domainFromXml);
                activeSet.add(canonicalFile.getCanonicalPath());
                if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                    Log.v(TAG_XML_PARSER, ""...parsed "" + canonicalFile.getCanonicalPath() + "" for domain \"""" + domainFromXml + ""\"""");
                }
                // dir, so we add the -journal anyway to be safe.
                if (""database"".equals(domainFromXml) && !canonicalFile.isDirectory()) {
                    final String canonicalJournalPath = canonicalFile.getCanonicalPath() + ""-journal"";
                    activeSet.add(canonicalJournalPath);
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...automatically generated "" + canonicalJournalPath + "". Ignore if nonexistent."");
                    }
                    final String canonicalWalPath = canonicalFile.getCanonicalPath() + ""-wal"";
                    activeSet.add(canonicalWalPath);
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...automatically generated "" + canonicalWalPath + "". Ignore if nonexistent."");
                    }
                }
                // Special case for sharedpref files (not dirs) also add "".xml"" suffix file.
                if (""sharedpref"".equals(domainFromXml) && !canonicalFile.isDirectory() && !canonicalFile.getCanonicalPath().endsWith("".xml"")) {
                    final String canonicalXmlPath = canonicalFile.getCanonicalPath() + "".xml"";
                    activeSet.add(canonicalXmlPath);
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...automatically generated "" + canonicalXmlPath + "". Ignore if nonexistent."");
                    }
                }
        }
    }
    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
        Log.v(TAG_XML_PARSER, ""\n"");
        Log.v(TAG_XML_PARSER, ""Xml resource parsing complete."");
        Log.v(TAG_XML_PARSER, ""Final tally."");
        Log.v(TAG_XML_PARSER, ""Includes:"");
        if (includes.isEmpty()) {
            Log.v(TAG_XML_PARSER, ""  ...nothing specified (This means the entirety of app"" + "" data minus excludes)"");
        } else {
            for (Map.Entry<String, Set<String>> entry : includes.entrySet()) {
                Log.v(TAG_XML_PARSER, ""  domain="" + entry.getKey());
                for (String includeData : entry.getValue()) {
                    Log.v(TAG_XML_PARSER, ""  "" + includeData);
                }
            }
        }
        Log.v(TAG_XML_PARSER, ""Excludes:"");
        if (excludes.isEmpty()) {
            Log.v(TAG_XML_PARSER, ""  ...nothing to exclude."");
        } else {
            for (String excludeData : excludes) {
                Log.v(TAG_XML_PARSER, ""  "" + excludeData);
            }
        }
        Log.v(TAG_XML_PARSER, ""  "");
        Log.v(TAG_XML_PARSER, ""===================================================="");
        Log.v(TAG_XML_PARSER, ""\n"");
    }
}",1,,,-1,[@VisibleForTesting],[@VisibleForTesting],-1,-1,-1,-1,-1,-1,,,,
1370,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForDevice(int,String,long,long)>",23,24,"<android.app.usage.NetworkStatsManager: Bucket querySummaryForDevice(int,String,long,long)>","<android.app.usage.NetworkStatsManager: Bucket querySummaryForDevice(int,String,long,long)>",0,"{
    NetworkTemplate template = createTemplate(networkType, subscriberId);
    if (template == null) {
        return null;
    }
    Bucket bucket = null;
    NetworkStats stats = new NetworkStats(mContext, template, startTime, endTime);
    bucket = stats.getDeviceSummaryForNetwork();
    stats.close();
    return bucket;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    Bucket bucket = null;
    NetworkStats stats = new NetworkStats(mContext, template, startTime, endTime);
    bucket = stats.getDeviceSummaryForNetwork();
    stats.close();
    return bucket;
}",1,"/**
 * Query network usage statistics summaries. Result is summarised data usage for the whole
 * device. Result is a single Bucket aggregated over time, state and uid. This means the
 * bucket's start and end timestamp are going to be the same as the 'startTime' and 'endTime'
 * parameters, state is going to be {@link NetworkStats.Bucket#STATE_ALL} and uid
 * {@link NetworkStats.Bucket#UID_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result is summarised data usage for the whole
 * device. Result is a single Bucket aggregated over time, state, uid, tag and roaming. This
 * means the bucket's start and end timestamp are going to be the same as the 'startTime' and
 * 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid
 * {@link NetworkStats.Bucket#UID_ALL}, tag {@link NetworkStats.Bucket#TAG_NONE}
 * and roaming {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","Exception handling statement and control dependency change are present. There is a new try-catch block around the createTemplate method call, changing exception handling logic, which is type 2. There's also a new control structure (try-catch block), which alters the flow of the method (type 3).","This change introduces a compatibility issue due to two factors: different return values and different exception handlings. The early version does not handle IllegalArgumentException, potentially allowing higher-level handlers to catch it, while the late version explicitly catches the exception and returns null, providing different behavior (type 1). Additionally, the new exception handling (logging and returning null) alters how exceptions are processed, which can lead to a different API behavior (type 2)."
1371,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",23,24,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>","<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",0,"{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}","{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    if (constructor != null && !verifyClassLoader(constructor)) {
        constructor = null;
        sConstructorMap.remove(name);
    }
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}",1,"/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
","/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1372,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",23,24,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>","<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5","1,2","The dependent API change is identified as `intent.prepareToLeaveProcess()` in the early version is modified to `intent.prepareToLeaveProcess(this)` in the late version, with an extra parameter `this` being passed. Therefore, the dependent API changed. There is also an exception handling statement change: the `throw new RuntimeException(""Failure from system"", e)` has been replaced with `throw e.rethrowFromSystemServer()`, thus indicating an exception handling statement change.",These modifications can lead to a CI for the following reasons: 
1373,"<android.content.pm.LauncherApps: boolean isPackageEnabled(String,UserHandle)>",23,24,"<android.content.pm.LauncherApps: boolean isPackageEnabled(String,UserHandle)>","<android.content.pm.LauncherApps: boolean isPackageEnabled(String,UserHandle)>",0,"{
    try {
        return mService.isPackageEnabled(packageName, user);
    } catch (RemoteException re) {
        throw new RuntimeException(""Failed to call LauncherAppsService"");
    }
}","{
    try {
        return mService.isPackageEnabled(packageName, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Checks if the package is installed and enabled for a profile.
 *
 * @param packageName The package to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the package exists and is enabled.
 */
","/**
 * Checks if the package is installed and enabled for a profile.
 *
 * @param packageName The package to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the package exists and is enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement has changed, with the previous 'throw new RuntimeException' being replaced by 'throw re.rethrowFromSystemServer()', so the code change type is 2.","The modification in the exception handling will cause the method to throw a different type of exception under certain circumstances (when a RemoteException occurs). As such, we can expect a different behavior because the clients of the API now need to handle a different exception than before. Therefore, the CI is type 2."
1374,<android.app.ContextImpl: boolean deleteDatabase(String)>,23,24,<android.app.ContextImpl: boolean deleteDatabase(String)>,<android.app.ContextImpl: boolean deleteDatabase(String)>,0,"{
    try {
        File f = validateFilePath(name, false);
        return SQLiteDatabase.deleteDatabase(f);
    } catch (Exception e) {
    }
    return false;
}","{
    try {
        File f = getDatabasePath(name);
        return SQLiteDatabase.deleteDatabase(f);
    } catch (Exception e) {
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from using the validateFilePath method to getDatabasePath method, which affects the way the database file path is obtained. This is considered as the other statement changed because it doesn't involve a control structure or a return statement or an exception directly. Additionally, it's a change to a dependent API (the method used to obtain the database path), so the change type is 4,5.","Since the method used to obtain the file path has changed, but the overall structure of the try-catch block and return statements remain the same, and considering both methods are intended to return the path to a database file, there is no evidence of a Compatibility Issue based solely on the provided information, so the CI type is 0."
1375,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",23,24,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.prepareToLeaveProcess();
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change to the method is the addition of the context parameter in the call to intent.prepareToLeaveProcess(context). This could also impact the dependent API prepareToLeaveProcess due to a parameter change, so the change types are 4 for Other statement changed and 5 for Dependent API changed.","Although there's a dependent API change where an additional parameter is passed to the prepareToLeaveProcess method, if we assume that prepareToLeaveProcess is overloaded or that the context parameter doesn't change the method’s behavior significantly (which can be the case if the context provided is just used for additional processing that doesn't affect the result), this change might not lead to a different behavior from the perspective of the API client. Therefore, there is No Compatibility Issue detected, so the CI type is 0."
1376,"<android.widget.SearchView: void onMeasure(int,int)>",23,24,"<android.widget.SearchView: void onMeasure(int,int)>","<android.widget.SearchView: void onMeasure(int,int)>",0,"{
    // Let the standard measurements take effect in iconified state.
    if (isIconified()) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int width = MeasureSpec.getSize(widthMeasureSpec);
    switch(widthMode) {
        case MeasureSpec.AT_MOST:
            // If there is an upper limit, don't exceed maximum width (explicit or implicit)
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            } else {
                width = Math.min(getPreferredWidth(), width);
            }
            break;
        case MeasureSpec.EXACTLY:
            // If an exact width is specified, still don't exceed any specified maximum width
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            }
            break;
        case MeasureSpec.UNSPECIFIED:
            // Use maximum width, if specified, else preferred width
            width = mMaxWidth > 0 ? mMaxWidth : getPreferredWidth();
            break;
    }
    widthMode = MeasureSpec.EXACTLY;
    super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), heightMeasureSpec);
}","{
    // Let the standard measurements take effect in iconified state.
    if (isIconified()) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int width = MeasureSpec.getSize(widthMeasureSpec);
    switch(widthMode) {
        case MeasureSpec.AT_MOST:
            // If there is an upper limit, don't exceed maximum width (explicit or implicit)
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            } else {
                width = Math.min(getPreferredWidth(), width);
            }
            break;
        case MeasureSpec.EXACTLY:
            // If an exact width is specified, still don't exceed any specified maximum width
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            }
            break;
        case MeasureSpec.UNSPECIFIED:
            // Use maximum width, if specified, else preferred width
            width = mMaxWidth > 0 ? mMaxWidth : getPreferredWidth();
            break;
    }
    widthMode = MeasureSpec.EXACTLY;
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int height = MeasureSpec.getSize(heightMeasureSpec);
    switch(heightMode) {
        case MeasureSpec.AT_MOST:
        case MeasureSpec.UNSPECIFIED:
            height = Math.min(getPreferredHeight(), height);
            break;
    }
    heightMode = MeasureSpec.EXACTLY;
    super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), MeasureSpec.makeMeasureSpec(height, heightMode));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version introduces new control flow logic for handling height measurement and assignment, which was not present in the early version. A new switch statement has been added that checks `heightMode` and assigns a potentially different height value. It also changes the way `super.onMeasure` is called by adding `MeasureSpec.makeMeasureSpec(height, heightMode)`. Therefore, the code is changed in 1,3.","The addition of new control flow for the `height` and the modified call to `super.onMeasure` could cause the `View` to be measured with different `width` and `height` specs, potentially leading to a different measured size of the `SearchView`. This alteration in measurement behavior can affect how the view is displayed, thus it is a compatibility issue of type 1."
1377,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,23,24,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence);
                }
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && mServedView.hasWindowFocus()) {
                        // mServedInputConnection.finishComposingText.
                        if (checkFocusNoStartInput(mHasBeenInactive, false)) {
                            startInputInner(null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(InputMethodClient.START_INPUT_REASON_BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @InputMethodClient.UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodClient.getUnbindReason(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // we would like to re-connect to the next input method.
                    if (mServedView != null && mServedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(InputMethodClient.START_INPUT_REASON_UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && mServedView.hasWindowFocus()) {
                        if (checkFocusNoStartInput(mHasBeenInactive)) {
                            final int reason = active ? InputMethodClient.START_INPUT_REASON_ACTIVATED_BY_IMMS : InputMethodClient.START_INPUT_REASON_DEACTIVATED_BY_IMMS;
                            startInputInner(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1378,"<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>",23,24,"<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordQuality(admin, quality);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordQuality(admin, quality, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * password restrictions it is imposing.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 *
 * <p>Quality constants are ordered so that higher values are more restrictive;
 * thus the highest requested quality constant (between the policy set here,
 * the user's preference, and any other considerations) is the one that
 * is in effect.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param quality The new desired quality.  One of
 * {@link #PASSWORD_QUALITY_UNSPECIFIED}, {@link #PASSWORD_QUALITY_SOMETHING},
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX},
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, {@link #PASSWORD_QUALITY_ALPHANUMERIC}
 * or {@link #PASSWORD_QUALITY_COMPLEX}.
 */
","/**
 * Called by an application that is administering the device to set the password restrictions it
 * is imposing. After setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current password will remain
 * until the user has set a new one, so the change does not take place immediately. To prompt
 * the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} or
 * {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after calling this method.
 * <p>
 * Quality constants are ordered so that higher values are more restrictive; thus the highest
 * requested quality constant (between the policy set here, the user's preference, and any other
 * considerations) is the one that is in effect.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param quality The new desired quality. One of {@link #PASSWORD_QUALITY_UNSPECIFIED},
 * {@link #PASSWORD_QUALITY_SOMETHING}, {@link #PASSWORD_QUALITY_NUMERIC},
 * {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}, {@link #PASSWORD_QUALITY_ALPHABETIC},
 * {@link #PASSWORD_QUALITY_ALPHANUMERIC} or {@link #PASSWORD_QUALITY_COMPLEX}.
 * @throws SecurityException if {@code admin} is not an active administrator or if {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The implementation changes include the addition of a parameter 'mParentInstance' to the 'setPasswordQuality' method and changes in exception handling (from logging the exception to throwing it). As these are changes in statements other than return and control statements, the code change types are 2,4,5.","The changed exception handling from logging to throwing an exception alters the behavior of the method and could lead to a different exception being propagated to the caller instead of being logged and swallowed. So, the CI type is 2."
1379,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",23,24,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>","<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",0,"{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess();
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}","{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess(this);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}",1,"/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
","/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API `prepareToLeaveProcess()` has changed from `data.prepareToLeaveProcess()` to `data.prepareToLeaveProcess(this)`. This indicates a parameter list change in the dependent API used in the method implementation, so the code change type is 5.","Although there is a change in the dependent API, this does not introduce a compatibility issue as the `prepareToLeaveProcess()` method is called before creating the PendingIntent and has no effect on the return value or exception handling of the `createPendingResult()` method. Therefore, there's no compatibility issue introduced by this change."
1380,<android.widget.ProgressBar: void setSecondaryProgress(int)>,23,24,<android.widget.ProgressBar: void setSecondaryProgress(int)>,<android.widget.ProgressBar: void setSecondaryProgress(int)>,0,"{
    if (mIndeterminate) {
        return;
    }
    if (secondaryProgress < 0) {
        secondaryProgress = 0;
    }
    if (secondaryProgress > mMax) {
        secondaryProgress = mMax;
    }
    if (secondaryProgress != mSecondaryProgress) {
        mSecondaryProgress = secondaryProgress;
        refreshProgress(R.id.secondaryProgress, mSecondaryProgress, false);
    }
}","{
    if (mIndeterminate) {
        return;
    }
    if (secondaryProgress < 0) {
        secondaryProgress = 0;
    }
    if (secondaryProgress > mMax) {
        secondaryProgress = mMax;
    }
    if (secondaryProgress != mSecondaryProgress) {
        mSecondaryProgress = secondaryProgress;
        refreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false);
    }
}",1,"/**
 * <p>
 * Set the current secondary progress to the specified value. Does not do
 * anything if the progress bar is in indeterminate mode.
 * </p>
 *
 * @param secondaryProgress the new secondary progress, between 0 and {@link #getMax()}
 * @see #setIndeterminate(boolean)
 * @see #isIndeterminate()
 * @see #getSecondaryProgress()
 * @see #incrementSecondaryProgressBy(int)
 */
","/**
 * <p>
 * Set the current secondary progress to the specified value. Does not do
 * anything if the progress bar is in indeterminate mode.
 * </p>
 *
 * @param secondaryProgress the new secondary progress, between 0 and {@link #getMax()}
 * @see #setIndeterminate(boolean)
 * @see #isIndeterminate()
 * @see #getSecondaryProgress()
 * @see #incrementSecondaryProgressBy(int)
 */
",-1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the arguments passed to the method refreshProgress; an additional 'false' boolean value is added. This is a dependent API change (indicated by the fourth parameter being added to the refreshProgress method call), and it is also classified as another statement changed because it alters the function call without affecting control flow or exception handling.","Since only the arguments to a method call within the implementation have been changed, and assuming refreshProgress method is designed to handle the additional argument without altering the logic flow or causing side effects (as the arguments are static and do not depend on state), this would not lead to a different behavior visible from outside the method call - thus, no compatibility issue should arise. The change does not affect the control flow or the data returned by the setSecondaryProgress method."
1381,<android.animation.AnimatorSet.Builder: Builder after(Animator)>,23,24,<android.animation.AnimatorSet.Builder: Builder after(Animator)>,<android.animation.AnimatorSet.Builder: Builder after(Animator)>,0,"{
    mReversible = false;
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(node, Dependency.AFTER);
    mCurrentNode.addDependency(dependency);
    return this;
}","{
    mReversible = false;
    Node node = getNodeForAnimation(anim);
    mCurrentNode.addParent(node);
    return this;
}",1,"/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to start when the animation supplied in this method call ends.
 *
 * @param anim The animation whose end will cause the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method to play.
 */
","/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to start when the animation supplied in this method call ends.
 *
 * @param anim The animation whose end will cause the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method to play.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The early version directly manipulates the mNodeMap and mNodes, while the late version uses a method called getNodeForAnimation(anim) and addParent(node). This implies changes in method calls and control dependency, hence the change type is 3,4,5.","Although there has been a refactoring of the code, the outcome of after(Animator anim) seems to have the same behavior: setting mReversible to false and then establishing a relationship between mCurrentNode and the node associated with the Animator anim. There is no change in return type or thrown exceptions as the final return is still 'return this' in both versions and there is no exception handling code. Therefore, despite the changes in implementation, there's no indicated change in the outward behavior of this method; hence no compatibility issue is anticipated, which is type 0."
1382,<android.print.PrintManager: void cancelPrintJob(PrintJobId)>,23,24,<android.print.PrintManager: void cancelPrintJob(PrintJobId)>,<android.print.PrintManager: void cancelPrintJob(PrintJobId)>,0,"{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return;
    }
    try {
        mService.cancelPrintJob(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error canceling a print job: "" + printJobId, re);
    }
}","{
    if (mService == null) {
        Log.w(LOG_TAG, ""Feature android.software.print not available"");
        return;
    }
    try {
        mService.cancelPrintJob(printJobId, mAppId, mUserId);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from logging the error to throwing an exception with `throw re.rethrowFromSystemServer()`. Therefore, the change type is 2.","Since the exception handling statement has been modified to throw an exception instead of logging it, the method’s behavior in terms of exception handling has changed. This could potentially lead to a different behavior when exceptions occur. Thus, the CI type is 2."
1384,<android.os.PowerManager: boolean isDeviceIdleMode()>,23,24,<android.os.PowerManager: boolean isDeviceIdleMode()>,<android.os.PowerManager: boolean isDeviceIdleMode()>,0,"{
    try {
        return mService.isDeviceIdleMode();
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return mService.isDeviceIdleMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the device is currently in idle mode.  This happens when a device
 * has been sitting unused and unmoving for a sufficiently long period of time, so that
 * it decides to go into a lower power-use state.  This may involve things like turning
 * off network access to apps.  You can monitor for changes to this state with
 * {@link #ACTION_DEVICE_IDLE_MODE_CHANGED}.
 *
 * @return Returns true if currently in active device idle mode, else false.  This is
 * when idle mode restrictions are being actively applied; it will return false if the
 * device is in a long-term idle mode but currently running a maintenance window where
 * restrictions have been lifted.
 */
","/**
 * Returns true if the device is currently in idle mode.  This happens when a device
 * has been sitting unused and unmoving for a sufficiently long period of time, so that
 * it decides to go into a lower power-use state.  This may involve things like turning
 * off network access to apps.  You can monitor for changes to this state with
 * {@link #ACTION_DEVICE_IDLE_MODE_CHANGED}.
 *
 * @return Returns true if currently in active device idle mode, else false.  This is
 * when idle mode restrictions are being actively applied; it will return false if the
 * device is in a long-term idle mode but currently running a maintenance window where
 * restrictions have been lifted.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2",2,"The exception handling statement has changed from simply returning false to throwing an exception using throw e.rethrowFromSystemServer(), so the change type is 2.","This change will cause the late version API to throw an exception instead of returning false when a RemoteException occurs, hence the CI type is 2 due to different exception handling."
1385,<android.printservice.PrintService.ServiceHandler: void handleMessage(Message)>,23,24,<android.printservice.PrintService.ServiceHandler: void handleMessage(Message)>,<android.printservice.PrintService.ServiceHandler: void handleMessage(Message)>,0,"{
    final int action = message.what;
    switch(action) {
        case MSG_CREATE_PRINTER_DISCOVERY_SESSION:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_CREATE_PRINTER_DISCOVERY_SESSION "" + getPackageName());
                }
                PrinterDiscoverySession session = onCreatePrinterDiscoverySession();
                if (session == null) {
                    throw new NullPointerException(""session cannot be null"");
                }
                if (session.getId() == mLastSessionId) {
                    throw new IllegalStateException(""cannot reuse session instances"");
                }
                mDiscoverySession = session;
                mLastSessionId = session.getId();
                session.setObserver(mClient);
            }
            break;
        case MSG_DESTROY_PRINTER_DISCOVERY_SESSION:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_DESTROY_PRINTER_DISCOVERY_SESSION "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    mDiscoverySession.destroy();
                    mDiscoverySession = null;
                }
            }
            break;
        case MSG_START_PRINTER_DISCOVERY:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_START_PRINTER_DISCOVERY "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    List<PrinterId> priorityList = (ArrayList<PrinterId>) message.obj;
                    mDiscoverySession.startPrinterDiscovery(priorityList);
                }
            }
            break;
        case MSG_STOP_PRINTER_DISCOVERY:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_STOP_PRINTER_DISCOVERY "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    mDiscoverySession.stopPrinterDiscovery();
                }
            }
            break;
        case MSG_VALIDATE_PRINTERS:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_VALIDATE_PRINTERS "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    List<PrinterId> printerIds = (List<PrinterId>) message.obj;
                    mDiscoverySession.validatePrinters(printerIds);
                }
            }
            break;
        case MSG_START_PRINTER_STATE_TRACKING:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_START_PRINTER_STATE_TRACKING "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    PrinterId printerId = (PrinterId) message.obj;
                    mDiscoverySession.startPrinterStateTracking(printerId);
                }
            }
            break;
        case MSG_STOP_PRINTER_STATE_TRACKING:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_STOP_PRINTER_STATE_TRACKING "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    PrinterId printerId = (PrinterId) message.obj;
                    mDiscoverySession.stopPrinterStateTracking(printerId);
                }
            }
            break;
        case MSG_ON_REQUEST_CANCEL_PRINTJOB:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_ON_REQUEST_CANCEL_PRINTJOB "" + getPackageName());
                }
                PrintJobInfo printJobInfo = (PrintJobInfo) message.obj;
                onRequestCancelPrintJob(new PrintJob(printJobInfo, mClient));
            }
            break;
        case MSG_ON_PRINTJOB_QUEUED:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_ON_PRINTJOB_QUEUED "" + getPackageName());
                }
                PrintJobInfo printJobInfo = (PrintJobInfo) message.obj;
                if (DEBUG) {
                    Log.i(LOG_TAG, ""Queued: "" + printJobInfo);
                }
                onPrintJobQueued(new PrintJob(printJobInfo, mClient));
            }
            break;
        case MSG_SET_CLIENT:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_SET_CLIENT "" + getPackageName());
                }
                mClient = (IPrintServiceClient) message.obj;
                if (mClient != null) {
                    onConnected();
                } else {
                    onDisconnected();
                }
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}","{
    final int action = message.what;
    switch(action) {
        case MSG_CREATE_PRINTER_DISCOVERY_SESSION:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_CREATE_PRINTER_DISCOVERY_SESSION "" + getPackageName());
                }
                PrinterDiscoverySession session = onCreatePrinterDiscoverySession();
                if (session == null) {
                    throw new NullPointerException(""session cannot be null"");
                }
                if (session.getId() == mLastSessionId) {
                    throw new IllegalStateException(""cannot reuse session instances"");
                }
                mDiscoverySession = session;
                mLastSessionId = session.getId();
                session.setObserver(mClient);
            }
            break;
        case MSG_DESTROY_PRINTER_DISCOVERY_SESSION:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_DESTROY_PRINTER_DISCOVERY_SESSION "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    mDiscoverySession.destroy();
                    mDiscoverySession = null;
                }
            }
            break;
        case MSG_START_PRINTER_DISCOVERY:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_START_PRINTER_DISCOVERY "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    List<PrinterId> priorityList = (ArrayList<PrinterId>) message.obj;
                    mDiscoverySession.startPrinterDiscovery(priorityList);
                }
            }
            break;
        case MSG_STOP_PRINTER_DISCOVERY:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_STOP_PRINTER_DISCOVERY "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    mDiscoverySession.stopPrinterDiscovery();
                }
            }
            break;
        case MSG_VALIDATE_PRINTERS:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_VALIDATE_PRINTERS "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    List<PrinterId> printerIds = (List<PrinterId>) message.obj;
                    mDiscoverySession.validatePrinters(printerIds);
                }
            }
            break;
        case MSG_START_PRINTER_STATE_TRACKING:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_START_PRINTER_STATE_TRACKING "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    PrinterId printerId = (PrinterId) message.obj;
                    mDiscoverySession.startPrinterStateTracking(printerId);
                }
            }
            break;
        case MSG_REQUEST_CUSTOM_PRINTER_ICON:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_REQUEST_CUSTOM_PRINTER_ICON "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    PrinterId printerId = (PrinterId) message.obj;
                    mDiscoverySession.requestCustomPrinterIcon(printerId);
                }
            }
            break;
        case MSG_STOP_PRINTER_STATE_TRACKING:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_STOP_PRINTER_STATE_TRACKING "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    PrinterId printerId = (PrinterId) message.obj;
                    mDiscoverySession.stopPrinterStateTracking(printerId);
                }
            }
            break;
        case MSG_ON_REQUEST_CANCEL_PRINTJOB:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_ON_REQUEST_CANCEL_PRINTJOB "" + getPackageName());
                }
                PrintJobInfo printJobInfo = (PrintJobInfo) message.obj;
                onRequestCancelPrintJob(new PrintJob(PrintService.this, printJobInfo, mClient));
            }
            break;
        case MSG_ON_PRINTJOB_QUEUED:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_ON_PRINTJOB_QUEUED "" + getPackageName());
                }
                PrintJobInfo printJobInfo = (PrintJobInfo) message.obj;
                if (DEBUG) {
                    Log.i(LOG_TAG, ""Queued: "" + printJobInfo);
                }
                onPrintJobQueued(new PrintJob(PrintService.this, printJobInfo, mClient));
            }
            break;
        case MSG_SET_CLIENT:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_SET_CLIENT "" + getPackageName());
                }
                mClient = (IPrintServiceClient) message.obj;
                if (mClient != null) {
                    onConnected();
                } else {
                    onDisconnected();
                }
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,,,,
1386,"<android.bluetooth.BluetoothGatt: boolean connect(Boolean,BluetoothGattCallback)>",23,24,"<android.bluetooth.BluetoothGatt: boolean connect(Boolean,BluetoothGattCallback)>","<android.bluetooth.BluetoothGatt: boolean connect(Boolean,BluetoothGattCallback)>",0,"{
    if (DBG)
        Log.d(TAG, ""connect() - device: "" + mDevice.getAddress() + "", auto: "" + autoConnect);
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException(""Not idle"");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    if (!registerApp(callback)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, ""Failed to register callback"");
        return false;
    }
    // the connection will continue after successful callback registration
    mAutoConnect = autoConnect;
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""connect() - device: "" + mDevice.getAddress() + "", auto: "" + autoConnect);
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException(""Not idle"");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    mAutoConnect = autoConnect;
    if (!registerApp(callback)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, ""Failed to register callback"");
        return false;
    }
    // The connection will continue in the onClientRegistered callback
    return true;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,0,There is a reordering of the statements: the assignment `mAutoConnect = autoConnect;` is moved above the `registerApp(callback)` conditional block. This is an other statement change.,"The reordering of these statements does not lead to a compatibility issue because the outcome of the `connect()` method (either successful connection with `true` or failure with `false`) remains the same in both cases. The change does not introduce a new control dependency, alter exception handling, or modify the return type or value under any condition that the API method can be invoked."
1387,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",23,24,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    final Bundle optionsIn = new Bundle();
    if (options != null) {
        optionsIn.putAll(options);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, false, /* notifyOnAuthFailure */
            true, /* expectActivityLaunch */
            optionsIn);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    final Bundle optionsIn = new Bundle();
    if (options != null) {
        optionsIn.putAll(options);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, false, /* notifyOnAuthFailure */
            true, /* expectActivityLaunch */
            optionsIn);
        }
    }.start();
}",1,"/**
 * Gets an auth token of the specified type for a particular account,
 * prompting the user for credentials if necessary.  This method is
 * intended for applications running in the foreground where it makes
 * sense to ask the user directly for a password.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, the user is prompted to enter a password.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user for a password
 * if necessary; used only to call startActivity(); must not be null.
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If an auth token
 * could not be fetched, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
","/**
 * Gets an auth token of the specified type for a particular account,
 * prompting the user for credentials if necessary.  This method is
 * intended for applications running in the foreground where it makes
 * sense to ask the user directly for a password.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, the user is prompted to enter a password.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user for a password
 * if necessary; used only to call startActivity(); must not be null.
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If an auth token
 * could not be fetched, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of the `@Override` annotation to the `doWork` method within the `AmsTask` anonymous class. This is a method annotation and does not affect the method implementation, so the code change type is 4 (other statement changed).","The addition of the `@Override` annotation does not introduce any compatibility issues. It simply indicates that the `doWork` method overrides or implements a method declared in a supertype. Thus, there is no compatibility issue, indicated by 0 (No Compatibility Issue)."
1388,"<android.view.View: void setFlags(int,int)>",23,24,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE_MASK) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}","{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE_MASK) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1389,<android.animation.ValueAnimator: ValueAnimator clone()>,23,24,<android.animation.ValueAnimator: ValueAnimator clone()>,<android.animation.ValueAnimator: ValueAnimator clone()>,0,"{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>(mUpdateListeners);
    }
    anim.mSeekFraction = -1;
    anim.mPlayingBackwards = false;
    anim.mReversing = false;
    anim.mCurrentIteration = 0;
    anim.mInitialized = false;
    anim.mPlayingState = STOPPED;
    anim.mStartedDelay = false;
    anim.mStarted = false;
    anim.mRunning = false;
    anim.mPaused = false;
    anim.mResumed = false;
    anim.mStartListenersCalled = false;
    anim.mStartTime = 0;
    anim.mStartTimeCommitted = false;
    anim.mPauseTime = 0;
    anim.mCurrentFraction = 0;
    anim.mDelayStartTime = 0;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder newValuesHolder = oldValues[i].clone();
            anim.mValues[i] = newValuesHolder;
            anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
        }
    }
    return anim;
}","{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>(mUpdateListeners);
    }
    anim.mSeekFraction = -1;
    anim.mReversing = false;
    anim.mInitialized = false;
    anim.mStarted = false;
    anim.mRunning = false;
    anim.mPaused = false;
    anim.mResumed = false;
    anim.mStartListenersCalled = false;
    anim.mStartTime = 0;
    anim.mStartTimeCommitted = false;
    anim.mAnimationEndRequested = false;
    anim.mPauseTime = 0;
    anim.mLastFrameTime = 0;
    anim.mOverallFraction = 0;
    anim.mCurrentFraction = 0;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder newValuesHolder = oldValues[i].clone();
            anim.mValues[i] = newValuesHolder;
            anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
        }
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code modifications include the removal of some field assignments (for instance, anim.mPlayingBackwards, anim.mCurrentIteration, anim.mStartedDelay, anim.mDelayStartTime) and addition of others (anim.mLastFrameTime, anim.mOverallFraction, anim.mAnimationEndRequested). This indicates an update of the state initialization logic for the cloned ValueAnimator object, so the change type is 4. ","There seems to be no compatibility issue due to these changes. All the fields being modified are internal states and the removed or added fields are likely reflective of internal architectural changes that do not affect the external behavior as far as the clone's return interface is concerned. The fields being changed (added/removed/modified) do not affect the return type nor do they introduce new exceptions. Therefore, the CI type is 0."
1390,<android.app.Notification.Action: Action clone()>,23,24,<android.app.Notification.Action: Action clone()>,<android.app.Notification.Action: Action clone()>,0,"{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, new Bundle(mExtras), getRemoteInputs());
}","{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, new Bundle(mExtras), getRemoteInputs(), getAllowGeneratedReplies());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The constructor call for `new Action()` includes an additional parameter `getAllowGeneratedReplies()` in the late version, which is a change in the dependent API, making the change type 5.","The addition of new parameter `getAllowGeneratedReplies()` to the constructor call could potentially change the behavior of the returned `Action` object, likely providing additional functionality, such as allowing generated replies. Thus, the CI type is 1, due to potential different return values between the two versions."
1391,<android.app.Notification.Builder: Builder setExtras(Bundle)>,23,24,<android.app.Notification.Builder: Builder setExtras(Bundle)>,<android.app.Notification.Builder: Builder setExtras(Bundle)>,0,"{
    mExtras = extras;
    return this;
}","{
    if (extras != null) {
        mUserExtras = extras;
    }
    return this;
}",1,"/**
 * Set metadata for this notification.
 *
 * <p>A reference to the Bundle is held for the lifetime of this Builder, and the Bundle's
 * current contents are copied into the Notification each time {@link #build()} is
 * called.
 *
 * <p>Replaces any existing extras values with those from the provided Bundle.
 * Use {@link #addExtras} to merge in metadata instead.
 *
 * @see Notification#extras
 */
","/**
 * Set metadata for this notification.
 *
 * <p>A reference to the Bundle is held for the lifetime of this Builder, and the Bundle's
 * current contents are copied into the Notification each time {@link #build()} is
 * called.
 *
 * <p>Replaces any existing extras values with those from the provided Bundle.
 * Use {@link #addExtras} to merge in metadata instead.
 *
 * @see Notification#extras
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation changed where it's now assigning the parameter `extras` to a different variable `mUserExtras` instead of `mExtras`. Additionally, there's a new `if` control to check for `null`. This pertains to type 4, ""Other statement changed.""","The change does not lead to a CI. The method's contract appears to still stand - it accepts a `Bundle` and returns the builder instance. Assigning the `extras` to a potentially different variable does not inherently affect the return type or value. The null check protects against setting `null` extras, but this doesn't change the API behavior in a way that would cause a CI since the builder pattern is typically designed to ignore setting a null field. Thus, no return value or exception handling is fundamentally altered for the API consumers."
1393,<android.animation.AnimatorSet: void setStartDelay(long)>,23,24,<android.animation.AnimatorSet: void setStartDelay(long)>,<android.animation.AnimatorSet: void setStartDelay(long)>,0,"{
    if (mStartDelay > 0) {
        mReversible = false;
    }
    mStartDelay = startDelay;
}","{
    // Clamp start delay to non-negative range.
    if (startDelay < 0) {
        Log.w(TAG, ""Start delay should always be non-negative"");
        startDelay = 0;
    }
    long delta = startDelay - mStartDelay;
    if (delta == 0) {
        return;
    }
    mStartDelay = startDelay;
    if (mStartDelay > 0) {
        mReversible = false;
    }
    if (!mDependencyDirty) {
        // Dependency graph already constructed, update all the nodes' start/end time
        int size = mNodes.size();
        for (int i = 0; i < size; i++) {
            Node node = mNodes.get(i);
            if (node == mRootNode) {
                node.mEndTime = mStartDelay;
            } else {
                node.mStartTime = node.mStartTime == DURATION_INFINITE ? DURATION_INFINITE : node.mStartTime + delta;
                node.mEndTime = node.mEndTime == DURATION_INFINITE ? DURATION_INFINITE : node.mEndTime + delta;
            }
        }
        // Update total duration, if necessary.
        if (mTotalDuration != DURATION_INFINITE) {
            mTotalDuration += delta;
        }
    }
}",1,"/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
","/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called. Note that the start delay should always be non-negative. Any
 * negative start delay will be clamped to 0 on N and above.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Control statements and other statements are added to check and modify the startDelay, and the flow of how mStartDelay is set has changed, so the types of changes are 3,4.","The early version does not limit the `startDelay` to non-negative numbers, while the late version sets a non-negative constraint on `startDelay`. The late version also adds new behaviors related to updating nodes and total duration. These modifications can potentially lead to different behaviors when the method is called, specifically, the changed flow may lead to a situation where `mStartDelay` is not set to a negative value even if a negative `startDelay` is provided. Therefore, the `setStartDelay` method potentially behaves differently, causing a CI of type 1."
1395,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getEnabledInputMethodList()>,23,24,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getEnabledInputMethodList()>,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getEnabledInputMethodList()>,0,"{
    try {
        return mService.getEnabledInputMethodList();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        return mService.getEnabledInputMethodList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,2,2,"The way how the `RemoteException` is handled has changed, with the RemoteException being rethrown in a specific way in the late version (`throw e.rethrowFromSystemServer();`), so the change type is 2.","The change in the exception handling mechanism will alter the exception thrown by the API method. The newer version may throw a different type of exception, hence potentially changing the behavior observed by the caller. So, this would be a Compatibility Issue of type 2, caused by potential different exception handlings."
1396,<android.app.Notification.Builder: Builder setContentInfo(CharSequence)>,23,24,<android.app.Notification.Builder: Builder setContentInfo(CharSequence)>,<android.app.Notification.Builder: Builder setContentInfo(CharSequence)>,0,"{
    mContentInfo = safeCharSequence(info);
    return this;
}","{
    mN.extras.putCharSequence(EXTRA_INFO_TEXT, safeCharSequence(info));
    return this;
}",1,"/**
 * A small piece of additional information pertaining to this notification.
 *
 * The platform template will draw this on the last line of the notification, at the far
 * right (to the right of a smallIcon if it has been placed there).
 */
","/**
 * A small piece of additional information pertaining to this notification.
 *
 * The platform template will draw this on the last line of the notification, at the far
 * right (to the right of a smallIcon if it has been placed there).
 *
 * @deprecated use {@link #setSubText(CharSequence)} instead to set a text in the header.
 * For legacy apps targeting a version below {@link android.os.Build.VERSION_CODES#N} this
 * field will still show up, but the subtext will take precedence.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of what is done inside the method has changed from setting a member variable directly to using a putCharSequence on an 'extras' Bundle within an object mN. Also, there is a change in the dependent API with a different field being accessed (mContentInfo vs. mN.extras). The statement to assign the value is different (direct assignment vs. putCharSequence method call), so the change types are 1,4,5.","With the change in how the information is stored - from a direct member variable to being part of a Bundle, along with a change in the API that is being depended upon ('safeCharSequence' is still being called, but the target of its result has shifted) - it's possible that this could lead to different behavior in how the data is retrieved or used elsewhere in the system. Hence, it is a CI of type 1 because the method potentially returns different variables (even though 'this' reference is returned in both cases, the state of 'this' is different due to the different ways the 'info' is being stored)."
1397,<android.hardware.ConsumerIrManager: CarrierFrequencyRange[] getCarrierFrequencies()>,23,24,<android.hardware.ConsumerIrManager: CarrierFrequencyRange[] getCarrierFrequencies()>,<android.hardware.ConsumerIrManager: CarrierFrequencyRange[] getCarrierFrequencies()>,0,"{
    if (mService == null) {
        Log.w(TAG, ""no consumer ir service."");
        return null;
    }
    try {
        int[] freqs = mService.getCarrierFrequencies();
        if (freqs.length % 2 != 0) {
            Log.w(TAG, ""consumer ir service returned an uneven number of frequencies."");
            return null;
        }
        CarrierFrequencyRange[] range = new CarrierFrequencyRange[freqs.length / 2];
        for (int i = 0; i < freqs.length; i += 2) {
            range[i / 2] = new CarrierFrequencyRange(freqs[i], freqs[i + 1]);
        }
        return range;
    } catch (RemoteException e) {
    }
    return null;
}","{
    if (mService == null) {
        Log.w(TAG, ""no consumer ir service."");
        return null;
    }
    try {
        int[] freqs = mService.getCarrierFrequencies();
        if (freqs.length % 2 != 0) {
            Log.w(TAG, ""consumer ir service returned an uneven number of frequencies."");
            return null;
        }
        CarrierFrequencyRange[] range = new CarrierFrequencyRange[freqs.length / 2];
        for (int i = 0; i < freqs.length; i += 2) {
            range[i / 2] = new CarrierFrequencyRange(freqs[i], freqs[i + 1]);
        }
        return range;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Query the infrared transmitter's supported carrier frequencies
 *
 * @return an array of
 * {@link android.hardware.ConsumerIrManager.CarrierFrequencyRange}
 * objects representing the ranges that the transmitter can support, or
 * null if there was an error communicating with the Consumer IR Service.
 */
","/**
 * Query the infrared transmitter's supported carrier frequencies
 *
 * @return an array of
 * {@link android.hardware.ConsumerIrManager.CarrierFrequencyRange}
 * objects representing the ranges that the transmitter can support, or
 * null if there was an error communicating with the Consumer IR Service.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling has changed. In the early version, the RemoteException is caught and swallowed, while in the late version, it is thrown again using the rethrowFromSystemServer() method, so the change type is 2.","Given that the way RemoteException is handled has changed from being swallowed to being thrown, the behavior of the method could potentially throw an exception when it didn't before. Therefore, the CI type is 2."
1398,<android.content.pm.PackageInstaller: List<SessionInfo> getMySessions()>,23,24,<android.content.pm.PackageInstaller: List<SessionInfo> getMySessions()>,<android.content.pm.PackageInstaller: List<SessionInfo> getMySessions()>,0,"{
    try {
        return mInstaller.getMySessions(mInstallerPackageName, mUserId).getList();
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        return mInstaller.getMySessions(mInstallerPackageName, mUserId).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return list of all known install sessions owned by the calling app.
 */
","/**
 * Return list of all known install sessions owned by the calling app.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from `throw e.rethrowAsRuntimeException();` to `throw e.rethrowFromSystemServer();`, so the code change type is 2.","The change in exception handling could potentially cause the API to throw a different exception (or a different type of exception) than it did before, which may not be handled in the same way by calling code. Therefore, the CI type is 2."
1399,<android.net.NetworkStats.Entry: String toString()>,23,24,<android.net.NetworkStats.Entry: String toString()>,<android.net.NetworkStats.Entry: String toString()>,0,"{
    final StringBuilder builder = new StringBuilder();
    builder.append(""iface="").append(iface);
    builder.append("" uid="").append(uid);
    builder.append("" set="").append(setToString(set));
    builder.append("" tag="").append(tagToString(tag));
    builder.append("" rxBytes="").append(rxBytes);
    builder.append("" rxPackets="").append(rxPackets);
    builder.append("" txBytes="").append(txBytes);
    builder.append("" txPackets="").append(txPackets);
    builder.append("" operations="").append(operations);
    return builder.toString();
}","{
    final StringBuilder builder = new StringBuilder();
    builder.append(""iface="").append(iface);
    builder.append("" uid="").append(uid);
    builder.append("" set="").append(setToString(set));
    builder.append("" tag="").append(tagToString(tag));
    builder.append("" roaming="").append(roamingToString(roaming));
    builder.append("" rxBytes="").append(rxBytes);
    builder.append("" rxPackets="").append(rxPackets);
    builder.append("" txBytes="").append(txBytes);
    builder.append("" txPackets="").append(txPackets);
    builder.append("" operations="").append(operations);
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"A new line builder.append("" roaming="").append(roamingToString(roaming)); is inserted in the late version, so the change type is 4.","The inserted line changes the value being returned by the method, specifically by adding new data regarding ""roaming"", which means the method now returns a different string representation than before, so the CI type is 1."
1400,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",23,24,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>","<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",0,"{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the implementation is the addition of ""this"" to the method call ""intent.prepareToLeaveProcess(this);"" which changes the method's parameters, indicating the method signature has changed. This suggests that the dependent API, ""prepareToLeaveProcess"", has undergone a change, classifying this as a dependent API change (5). There's another statement change (4) but no control dependency change, return statement change, or exception handling statement change.","Although there's a change in the method call, this does not constitute a compatibility issue with respect to return types or exceptions because the method's behavior with respect to return values or thrown exceptions is unchanged. Hence, there is no Compatibility Issue (0)."
1401,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",23,24,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>","<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",0,"{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession().setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession().setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
","/**
 * Set the display position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the display.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed. In the early version, the RemoteException was ignored, while in the late version, it is being thrown using rethrowFromSystemServer(), which is a change type 2.","The change in the exception handling statement potentially leads to a different behaviour if a RemoteException occurs. In the early version of the API, it would be suppressed, but in the late version, it would be thrown as a system-level error. This constitutes a CI because it changes how exceptions are handled, making it a type 2 CI."
1402,<android.content.res.Resources: String getResourceName(int)>,23,24,<android.content.res.Resources: String getResourceName(int)>,<android.content.res.Resources: String getResourceName(int)>,0,"{
    String str = mAssets.getResourceName(resid);
    if (str != null)
        return str;
    throw new NotFoundException(""Unable to find resource ID #0x"" + Integer.toHexString(resid));
}","{
    return mResourcesImpl.getResourceName(resid);
}",1,"/**
 * Return the full name for a given resource identifier.  This name is
 * a single string of the form ""package:type/entry"".
 *
 * @param resid The resource identifier whose name is to be retrieved.
 *
 * @return A string holding the name of the resource.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getResourcePackageName
 * @see #getResourceTypeName
 * @see #getResourceEntryName
 */
","/**
 * Return the full name for a given resource identifier.  This name is
 * a single string of the form ""package:type/entry"".
 *
 * @param resid The resource identifier whose name is to be retrieved.
 *
 * @return A string holding the name of the resource.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getResourcePackageName
 * @see #getResourceTypeName
 * @see #getResourceEntryName
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has changed from calling `mAssets.getResourceName(resid)` and potential throw of `NotFoundException` to directly returning the result of `mResourcesImpl.getResourceName(resid)`, and hence change types 1 and 5 are applicable.","The early version method implementation potentially throws `NotFoundException`, and there is also a condition check for null. In the late version, if `mResourcesImpl.getResourceName(resid)` behaves the same way as the early version's `mAssets.getResourceName(resid)`, including throwing an exception for not found resources, the API behavior would remain consistent. However, since the code change no longer explicitly throws `NotFoundException` and the null check is also removed, if `mResourcesImpl.getResourceName(resid)` does not throw an appropriate exception or handles null differently, it could directly impact the expected behavior of the API. This leads to a Compatibility Issue of type 1."
1403,<android.app.WallpaperManager: Drawable peekDrawable()>,23,24,<android.app.WallpaperManager: Drawable peekDrawable()>,<android.app.WallpaperManager: Drawable peekDrawable()>,0,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}","{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}",1,"/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
","/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method peekWallpaperBitmap called in the late implementation includes an extra parameter compared to the early implementation, indicating that the dependent API has changed; therefore, the code change type is 5.","Since the return statements are equivalent in both versions and no control flow or exception handling is altered, adding an argument to the method call does not necessarily indicate a behavior change from the perspective of someone using the peekDrawable() method. The wallpaper bitmap is obtained in the same manner from the perspective of the API client, and the Drawable constructed from it is handled identically. Thus, there's no Compatibility Issue; the type is 0."
1404,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,23,24,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,0,"{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
            return HAL_DATASPACE_DEPTH;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}","{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
            return HAL_DATASPACE_DEPTH;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}",1,"/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
","/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,The return value for the case `ImageFormat.JPEG` has changed from `HAL_DATASPACE_JFIF` to `HAL_DATASPACE_V0_JFIF`. The change type is 1.,"This change in the return value for the `ImageFormat.JPEG` case means the API will potentially return a different value for inputs that match this case, which is a CI of type 1."
1405,<com.android.server.backup.AccountSyncSettingsBackupHelper: void restoreEntity(BackupDataInputStream)>,23,24,<com.android.server.backup.AccountSyncSettingsBackupHelper: void restoreEntity(BackupDataInputStream)>,<com.android.server.backup.AccountSyncSettingsBackupHelper: void restoreEntity(BackupDataInputStream)>,0,"{
    byte[] dataBytes = new byte[data.size()];
    try {
        // Read the data and convert it to a String.
        data.read(dataBytes);
        String dataString = new String(dataBytes, JSON_FORMAT_ENCODING);
        // Convert data to a JSON object.
        JSONObject dataJSON = new JSONObject(dataString);
        boolean masterSyncEnabled = dataJSON.getBoolean(KEY_MASTER_SYNC_ENABLED);
        JSONArray accountJSONArray = dataJSON.getJSONArray(KEY_ACCOUNTS);
        boolean currentMasterSyncEnabled = ContentResolver.getMasterSyncAutomatically();
        if (currentMasterSyncEnabled) {
            // Disable master sync to prevent any syncs from running.
            ContentResolver.setMasterSyncAutomatically(false);
        }
        try {
            HashSet<Account> currentAccounts = getAccountsHashSet();
            for (int i = 0; i < accountJSONArray.length(); i++) {
                JSONObject accountJSON = (JSONObject) accountJSONArray.get(i);
                String accountName = accountJSON.getString(KEY_ACCOUNT_NAME);
                String accountType = accountJSON.getString(KEY_ACCOUNT_TYPE);
                Account account = new Account(accountName, accountType);
                // yet won't be restored.
                if (currentAccounts.contains(account)) {
                    restoreExistingAccountSyncSettingsFromJSON(accountJSON);
                } else {
                // TODO:
                // Stash the data to a file that the SyncManager can read from to restore
                // settings at a later date.
                }
            }
        } finally {
            // Set the master sync preference to the value from the backup set.
            ContentResolver.setMasterSyncAutomatically(masterSyncEnabled);
        }
        Log.i(TAG, ""Restore successful."");
    } catch (IOException | JSONException e) {
        Log.e(TAG, ""Couldn't restore account sync settings\n"" + e);
    }
}","{
    byte[] dataBytes = new byte[data.size()];
    try {
        // Read the data and convert it to a String.
        data.read(dataBytes);
        String dataString = new String(dataBytes, JSON_FORMAT_ENCODING);
        // Convert data to a JSON object.
        JSONObject dataJSON = new JSONObject(dataString);
        boolean masterSyncEnabled = dataJSON.getBoolean(KEY_MASTER_SYNC_ENABLED);
        JSONArray accountJSONArray = dataJSON.getJSONArray(KEY_ACCOUNTS);
        boolean currentMasterSyncEnabled = ContentResolver.getMasterSyncAutomatically();
        if (currentMasterSyncEnabled) {
            // Disable master sync to prevent any syncs from running.
            ContentResolver.setMasterSyncAutomatically(false);
        }
        try {
            restoreFromJsonArray(accountJSONArray);
        } finally {
            // Set the master sync preference to the value from the backup set.
            ContentResolver.setMasterSyncAutomatically(masterSyncEnabled);
        }
        Log.i(TAG, ""Restore successful."");
    } catch (IOException | JSONException e) {
        Log.e(TAG, ""Couldn't restore account sync settings\n"" + e);
    }
}",1,"/**
 * Restore account sync settings from the given data input stream.
 */
","/**
 * Restore account sync settings from the given data input stream.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The internal implementation of the account restoration logic has been refactored from a for loop directly in the method to a call to a new method, restoreFromJsonArray(accountJSONArray), which represents an 'Other statement changed.' It is also a 'Dependent API changed' because the new method restoreFromJsonArray is likely to be a dependency for the restoreEntity method.","Even though there is a code change, no Compatibility Issue is directly implied by this alteration. The refactoring seems to extract the loop's functionality into a separate method without altering the behavior of the existing code. Assuming restoreFromJsonArray properly handles the JSONArray, the behavior of the restoreEntity method would remain the same. Therefore, we have no clear evidence of a potential Compatibility Issue from this change alone."
1406,<android.net.LocalSocketImpl: Object getOption(int)>,23,24,<android.net.LocalSocketImpl: Object getOption(int)>,<android.net.LocalSocketImpl: Object getOption(int)>,0,"{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    if (optID == SocketOptions.SO_TIMEOUT) {
        return 0;
    }
    int value = getOption_native(fd, optID);
    switch(optID) {
        case SocketOptions.SO_RCVBUF:
        case SocketOptions.SO_SNDBUF:
            return value;
        case SocketOptions.SO_REUSEADDR:
        default:
            return value;
    }
}","{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    try {
        Object toReturn;
        switch(optID) {
            case SocketOptions.SO_TIMEOUT:
                StructTimeval timeval = Os.getsockoptTimeval(fd, OsConstants.SOL_SOCKET, OsConstants.SO_SNDTIMEO);
                toReturn = (int) timeval.toMillis();
                break;
            case SocketOptions.SO_RCVBUF:
            case SocketOptions.SO_SNDBUF:
            case SocketOptions.SO_REUSEADDR:
                int osOpt = javaSoToOsOpt(optID);
                toReturn = Os.getsockoptInt(fd, OsConstants.SOL_SOCKET, osOpt);
                break;
            case SocketOptions.SO_LINGER:
                StructLinger linger = Os.getsockoptLinger(fd, OsConstants.SOL_SOCKET, OsConstants.SO_LINGER);
                if (!linger.isOn()) {
                    toReturn = -1;
                } else {
                    toReturn = linger.l_linger;
                }
                break;
            case SocketOptions.TCP_NODELAY:
                toReturn = Os.getsockoptInt(fd, OsConstants.IPPROTO_TCP, OsConstants.TCP_NODELAY);
                break;
            default:
                throw new IOException(""Unknown option: "" + optID);
        }
        return toReturn;
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2",The implementation has been completely changed:,"- New case scenarios (e.g., SO_LINGER, TCP_NODELAY) have been introduced, including a default error throw."
1407,<android.app.ContextImpl: Display getDisplay()>,23,24,<android.app.ContextImpl: Display getDisplay()>,<android.app.ContextImpl: Display getDisplay()>,0,"{
    if (mDisplay != null) {
        return mDisplay;
    }
    return ResourcesManager.getInstance().getAdjustedDisplay(Display.DEFAULT_DISPLAY, mDisplayAdjustments);
}","{
    final DisplayAdjustments displayAdjustments = mResources.getDisplayAdjustments();
    if (mDisplay == null) {
        return mResourcesManager.getAdjustedDisplay(Display.DEFAULT_DISPLAY, displayAdjustments);
    }
    if (!mDisplay.getDisplayAdjustments().equals(displayAdjustments)) {
        mDisplay = mResourcesManager.getAdjustedDisplay(mDisplay.getDisplayId(), displayAdjustments);
    }
    return mDisplay;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method implementation changed the order of the checks and added a new condition checking for equality of display adjustments. It also modified the way `mDisplay` is accessed and updated. Therefore, the return statements and control dependencies have changed, and a change to the dependent API can be inferred due to different methods and parameters being used to obtain the display, which makes the change type 1,3,5.","Given that the return value now depends on the new check for display adjustments equality and the different pathways for obtaining the display, there is a potential change in the return type or value. Consequently, the late version of the API may yield a different `Display` object, which indicates a compatibility issue of type 1."
1408,"<android.app.ContextImpl: int checkPermission(String,int,int)>",23,24,"<android.app.ContextImpl: int checkPermission(String,int,int)>","<android.app.ContextImpl: int checkPermission(String,int,int)>",0,"{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    try {
        return ActivityManagerNative.getDefault().checkPermission(permission, pid, uid);
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}","{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    try {
        return ActivityManagerNative.getDefault().checkPermission(permission, pid, uid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed from returning PackageManager.PERMISSION_DENIED to throwing an exception with e.rethrowFromSystemServer(), so the change type is 2.","Since the exception handling has been altered to throw an exception instead of returning a constant, the behavior of the API changes significantly when an exception is caught. Thus, the CI type is 2."
1410,<android.text.BidiFormatter: boolean isRtl(String)>,23,24,<android.text.BidiFormatter: boolean isRtl(String)>,<android.text.BidiFormatter: boolean isRtl(String)>,0,"{
    return mDefaultTextDirectionHeuristic.isRtl(str, 0, str.length());
}","{
    return isRtl((CharSequence) str);
}",1,"/**
 * Estimates the directionality of a string using the default text direction heuristic.
 *
 * @param str String whose directionality is to be estimated.
 * @return true if {@code str}'s estimated overall directionality is RTL. Otherwise returns
 * false.
 */
","/**
 * Estimates the directionality of a string using the default text direction heuristic.
 *
 * @param str String whose directionality is to be estimated.
 * @return true if {@code str}'s estimated overall directionality is RTL. Otherwise returns
 * false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation has changed from calling mDefaultTextDirectionHeuristic.isRtl(...) directly with parameters to calling another method isRtl(CharSequence). This change involves the dependent API changed since it alters the internal method call, so the change type is 5.","The implementation now potentially calls a different logic to determine if the text is RTL. Because we don't have the implementation of the newly called isRtl(CharSequence) method, we can't tell if it behaves the same way as the original direct call. The change in the dependent method could lead to the API returning a different value, so the CI type is 1."
1411,<android.app.WallpaperManager: Drawable getFastDrawable()>,23,24,<android.app.WallpaperManager: Drawable getFastDrawable()>,<android.app.WallpaperManager: Drawable getFastDrawable()>,0,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}","{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true, FLAG_SYSTEM);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}",1,"/**
 * Like {@link #getDrawable()}, but the returned Drawable has a number
 * of limitations to reduce its overhead as much as possible. It will
 * never scale the wallpaper (only centering it if the requested bounds
 * do match the bitmap bounds, which should not be typical), doesn't
 * allow setting an alpha, color filter, or other attributes, etc.  The
 * bounds of the returned drawable will be initialized to the same bounds
 * as the wallpaper, so normally you will not need to touch it.  The
 * drawable also assumes that it will be used in a context running in
 * the same density as the screen (not in density compatibility mode).
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */
","/**
 * Like {@link #getDrawable()}, but the returned Drawable has a number
 * of limitations to reduce its overhead as much as possible. It will
 * never scale the wallpaper (only centering it if the requested bounds
 * do match the bitmap bounds, which should not be typical), doesn't
 * allow setting an alpha, color filter, or other attributes, etc.  The
 * bounds of the returned drawable will be initialized to the same bounds
 * as the wallpaper, so normally you will not need to touch it.  The
 * drawable also assumes that it will be used in a context running in
 * the same density as the screen (not in density compatibility mode).
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API `peekWallpaperBitmap` has an additional parameter in the late version. The `FLAG_SYSTEM` parameter has been added, indicating a change in the way the dependent API is called, which corresponds to code change type 5.","Despite the addition of the parameter, this change does not affect the return type or cause the method to return a different value under the same circumstances because the additional flag would be part of the internal implementation details of how the bitmap is retrieved. The behavior of returning either a `FastBitmapDrawable` or `null` based on the existence of `bm` remains the same. Therefore, there is no Compatibility Issue, and the CI type is 0."
1412,<android.view.ViewGroup: boolean onInterceptTouchEvent(MotionEvent)>,23,24,<android.view.ViewGroup: boolean onInterceptTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    return false;
}","{
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE) && ev.getAction() == MotionEvent.ACTION_DOWN && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) && isOnScrollbarThumb(ev.getX(), ev.getY())) {
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to intercept all touch screen motion events.  This
 * allows you to watch events as they are dispatched to your children, and
 * take ownership of the current gesture at any point.
 *
 * <p>Using this function takes some care, as it has a fairly complicated
 * interaction with {@link View#onTouchEvent(MotionEvent)
 * View.onTouchEvent(MotionEvent)}, and using it requires implementing
 * that method as well as this one in the correct way.  Events will be
 * received in the following order:
 *
 * <ol>
 * <li> You will receive the down event here.
 * <li> The down event will be handled either by a child of this view
 * group, or given to your own onTouchEvent() method to handle; this means
 * you should implement onTouchEvent() to return true, so you will
 * continue to see the rest of the gesture (instead of looking for
 * a parent view to handle it).  Also, by returning true from
 * onTouchEvent(), you will not receive any following
 * events in onInterceptTouchEvent() and all touch processing must
 * happen in onTouchEvent() like normal.
 * <li> For as long as you return false from this function, each following
 * event (up to and including the final up) will be delivered first here
 * and then to the target's onTouchEvent().
 * <li> If you return true from here, you will not receive any
 * following events: the target view will receive the same event but
 * with the action {@link MotionEvent#ACTION_CANCEL}, and all further
 * events will be delivered to your onTouchEvent() method and no longer
 * appear here.
 * </ol>
 *
 * @param ev The motion event being dispatched down the hierarchy.
 * @return Return true to steal motion events from the children and have
 * them dispatched to this ViewGroup through onTouchEvent().
 * The current target will receive an ACTION_CANCEL event, and no further
 * messages will be delivered here.
 */
","/**
 * Implement this method to intercept all touch screen motion events.  This
 * allows you to watch events as they are dispatched to your children, and
 * take ownership of the current gesture at any point.
 *
 * <p>Using this function takes some care, as it has a fairly complicated
 * interaction with {@link View#onTouchEvent(MotionEvent)
 * View.onTouchEvent(MotionEvent)}, and using it requires implementing
 * that method as well as this one in the correct way.  Events will be
 * received in the following order:
 *
 * <ol>
 * <li> You will receive the down event here.
 * <li> The down event will be handled either by a child of this view
 * group, or given to your own onTouchEvent() method to handle; this means
 * you should implement onTouchEvent() to return true, so you will
 * continue to see the rest of the gesture (instead of looking for
 * a parent view to handle it).  Also, by returning true from
 * onTouchEvent(), you will not receive any following
 * events in onInterceptTouchEvent() and all touch processing must
 * happen in onTouchEvent() like normal.
 * <li> For as long as you return false from this function, each following
 * event (up to and including the final up) will be delivered first here
 * and then to the target's onTouchEvent().
 * <li> If you return true from here, you will not receive any
 * following events: the target view will receive the same event but
 * with the action {@link MotionEvent#ACTION_CANCEL}, and all further
 * events will be delivered to your onTouchEvent() method and no longer
 * appear here.
 * </ol>
 *
 * @param ev The motion event being dispatched down the hierarchy.
 * @return Return true to steal motion events from the children and have
 * them dispatched to this ViewGroup through onTouchEvent().
 * The current target will receive an ACTION_CANCEL event, and no further
 * messages will be delivered here.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late implementation introduces a new control dependency 'if' with several conditions and a new return statement that returns true in certain cases, while the early implementation simply returns false, so the code change types are 1,3.","The late version of the method can potentially return true under certain conditions where the early version would return false. This change in return value based on input conditions indicates a possible different behavior; therefore, the CI type is 1."
1413,<android.app.NotificationManager: boolean isNotificationPolicyAccessGranted()>,23,24,<android.app.NotificationManager: boolean isNotificationPolicyAccessGranted()>,<android.app.NotificationManager: boolean isNotificationPolicyAccessGranted()>,0,"{
    INotificationManager service = getService();
    try {
        return service.isNotificationPolicyAccessGranted(mContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return false;
}","{
    INotificationManager service = getService();
    try {
        return service.isNotificationPolicyAccessGranted(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Checks the ability to read/modify notification policy for the calling package.
 *
 * <p>
 * Returns true if the calling package can read/modify notification policy.
 *
 * <p>
 * Request policy access by sending the user to the activity that matches the system intent
 * action {@link android.provider.Settings#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS}.
 *
 * <p>
 * Use {@link #ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED} to listen for
 * user grant or denial of this access.
 */
","/**
 * Checks the ability to read/modify notification policy for the calling package.
 *
 * <p>
 * Returns true if the calling package can read/modify notification policy.
 *
 * <p>
 * Request policy access by sending the user to the activity that matches the system intent
 * action {@link android.provider.Settings#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS}.
 *
 * <p>
 * Use {@link #ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED} to listen for
 * user grant or denial of this access.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed; the catch block in the early version does nothing, whereas the late version throws a runtime exception, so the code change type is 2.","Due to the exception handling change, where previously the method swallowed the RemoteException and returned false, now it throws a runtime exception. This can lead to a different exception being thrown by the API, hence the CI type is 2."
1414,<android.app.admin.DevicePolicyManager: List<String> getCrossProfileWidgetProviders(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: List<String> getCrossProfileWidgetProviders(ComponentName)>,<android.app.admin.DevicePolicyManager: List<String> getCrossProfileWidgetProviders(ComponentName)>,0,"{
    if (mService != null) {
        try {
            List<String> providers = mService.getCrossProfileWidgetProviders(admin);
            if (providers != null) {
                return providers;
            }
        } catch (RemoteException re) {
            Log.w(TAG, ""Error calling getCrossProfileWidgetProviders"", re);
        }
    }
    return Collections.emptyList();
}","{
    throwIfParentInstance(""getCrossProfileWidgetProviders"");
    if (mService != null) {
        try {
            List<String> providers = mService.getCrossProfileWidgetProviders(admin);
            if (providers != null) {
                return providers;
            }
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return Collections.emptyList();
}",1,"/**
 * Called by the profile owner of a managed profile to query providers from which packages are
 * available in the parent profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return The white-listed package list.
 *
 * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)
 * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)
 */
","/**
 * Called by the profile owner of a managed profile to query providers from which packages are
 * available in the parent profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return The white-listed package list.
 * @see #addCrossProfileWidgetProvider(android.content.ComponentName, String)
 * @see #removeCrossProfileWidgetProvider(android.content.ComponentName, String)
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late version has an additional method call `throwIfParentInstance(""getCrossProfileWidgetProviders"")`, a new exception handling statement is introduced (throw re.rethrowFromSystemServer()), and control dependency has changed due to the introduction of the new method call. Therefore, the code change types are 2, 3, and 4.","The addition of a method that potentially throws an exception (`throwIfParentInstance`) and the change in exception handling (from logging the exception to rethrowing it) could cause different behavior in exception scenarios. Therefore, the CI types are 1 due to the new control dependency which could affect return values and 2 due to the change in exception handling that will lead to potential compatibility issues."
1416,<android.os.UserManager: Bundle getUserRestrictions(UserHandle)>,23,24,<android.os.UserManager: Bundle getUserRestrictions(UserHandle)>,<android.os.UserManager: Bundle getUserRestrictions(UserHandle)>,0,"{
    try {
        return mService.getUserRestrictions(userHandle.getIdentifier());
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not get user restrictions"", re);
        return Bundle.EMPTY;
    }
}","{
    try {
        return mService.getUserRestrictions(userHandle.getIdentifier());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the user-wide restrictions imposed on the user specified by <code>userHandle</code>.
 * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.
 * @return a Bundle containing all the restrictions.
 */
","/**
 * Returns the user-wide restrictions imposed on the user specified by <code>userHandle</code>.
 * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.
 * @return a Bundle containing all the restrictions.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The change in the catch block from logging the exception and returning Bundle.EMPTY to throwing the exception with rethrowFromSystemServer() indicates a change in exception handling statement, so the code change type is 2.","The behavior of the method has changed in terms of exception handling: previously it captured a RemoteException and returned an empty Bundle, but now it propagates the exception after wrapping with rethrowFromSystemServer(). This change can lead to a different exception being thrown, thus the CI type is 2."
1417,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean queuePositionsToBePreloadedFromRequestedPosition(int)>,23,24,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean queuePositionsToBePreloadedFromRequestedPosition(int)>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: boolean queuePositionsToBePreloadedFromRequestedPosition(int)>,0,"{
    // Check if we need to preload any items
    if (mPreloadLowerBound <= position && position <= mPreloadUpperBound) {
        int center = (mPreloadUpperBound + mPreloadLowerBound) / 2;
        if (Math.abs(position - center) < mMaxCountSlack) {
            return false;
        }
    }
    int count = 0;
    synchronized (mMetaData) {
        count = mMetaData.count;
    }
    synchronized (mLoadIndices) {
        mLoadIndices.clear();
        // Add all the requested indices
        mLoadIndices.addAll(mRequestedIndices);
        // Add all the preload indices
        int halfMaxCount = mMaxCount / 2;
        mPreloadLowerBound = position - halfMaxCount;
        mPreloadUpperBound = position + halfMaxCount;
        int effectiveLowerBound = Math.max(0, mPreloadLowerBound);
        int effectiveUpperBound = Math.min(mPreloadUpperBound, count - 1);
        for (int i = effectiveLowerBound; i <= effectiveUpperBound; ++i) {
            mLoadIndices.add(i);
        }
        // But remove all the indices that have already been loaded and are cached
        mLoadIndices.removeAll(mIndexRemoteViews.keySet());
    }
    return true;
}","{
    // Check if we need to preload any items
    if (mPreloadLowerBound <= position && position <= mPreloadUpperBound) {
        int center = (mPreloadUpperBound + mPreloadLowerBound) / 2;
        if (Math.abs(position - center) < mMaxCountSlack) {
            return false;
        }
    }
    int count = 0;
    synchronized (mMetaData) {
        count = mMetaData.count;
    }
    synchronized (mIndicesToLoad) {
        // Remove all indices which have not been previously requested.
        for (int i = mIndicesToLoad.size() - 1; i >= 0; i--) {
            if (!mIndicesToLoad.valueAt(i)) {
                mIndicesToLoad.removeAt(i);
            }
        }
        // Add all the preload indices
        int halfMaxCount = mMaxCount / 2;
        mPreloadLowerBound = position - halfMaxCount;
        mPreloadUpperBound = position + halfMaxCount;
        int effectiveLowerBound = Math.max(0, mPreloadLowerBound);
        int effectiveUpperBound = Math.min(mPreloadUpperBound, count - 1);
        for (int i = effectiveLowerBound; i <= effectiveUpperBound; ++i) {
            if (mIndexRemoteViews.indexOfKey(i) < 0 && !mIndicesToLoad.get(i)) {
                // If the index has not been requested, and has not been loaded.
                mIndicesToLoad.put(i, false);
            }
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are multiple changes in the code: the name of the collection for loading indices has changed from mLoadIndices to mIndicesToLoad, and the logic to add indices to be preloaded has been changed. A new loop has been introduced to remove indices that have not been previously requested, and the mechanism to add indices differs in that it checks if the index has not been loaded or requested before adding it. These changes are related to control dependency as well as other non-control statements. Therefore, the changes are classified as 3,4.","Despite the changes, there is no Compatibility Issue with the modified approach. The new implementation introduces additional checks to prevent loading already requested or loaded indices, but the core functionality and behaviour seem to be preserved, and it will still return 'true' at the end as it was in the early version except under conditions where 'false' would have been returned previously as well which is not altered. Hence, no Compatibility Issue is detected."
1418,<android.app.ActivityOptions: void update(ActivityOptions)>,23,24,<android.app.ActivityOptions: void update(ActivityOptions)>,<android.app.ActivityOptions: void update(ActivityOptions)>,0,"{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}","{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
}",1,"/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
","/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1419,<android.view.inputmethod.CursorAnchorInfo: Matrix getMatrix()>,23,24,<android.view.inputmethod.CursorAnchorInfo: Matrix getMatrix()>,<android.view.inputmethod.CursorAnchorInfo: Matrix getMatrix()>,0,"{
    return new Matrix(mMatrix);
}","{
    final Matrix matrix = new Matrix();
    matrix.setValues(mMatrixValues);
    return matrix;
}",1,"/**
 * Returns a new instance of {@link android.graphics.Matrix} that indicates the transformation
 * matrix that is to be applied other positional data in this class.
 * @return a new instance (copy) of the transformation matrix.
 */
","/**
 * Returns a new instance of {@link android.graphics.Matrix} that indicates the transformation
 * matrix that is to be applied other positional data in this class.
 * @return a new instance (copy) of the transformation matrix.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The method of creating and returning the `Matrix` object has changed. Instead of directly copying `mMatrix`, a new `Matrix` object is being created, and it uses `setValues` to copy values from `mMatrixValues`. The implementation of constructing the `Matrix` object to be returned has changed, which is an other statement changed (4).","Due to the change in the way the `Matrix` object is constructed, there's the potential for a different `Matrix` object (with potentially different values) being returned in the late version. If the content of `mMatrixValues` does not represent the same transformation as the original `mMatrix`, there would be a compatibility issue due to a potential difference in the returned `Matrix` object. Thus, the CI type is 1."
1420,<android.app.admin.DevicePolicyManager: void uninstallAllUserCaCerts(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: void uninstallAllUserCaCerts(ComponentName)>,<android.app.admin.DevicePolicyManager: void uninstallAllUserCaCerts(ComponentName)>,0,"{
    if (mService != null) {
        try {
            mService.uninstallCaCerts(admin, new TrustedCertificateStore().userAliases().toArray(new String[0]));
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed talking with device policy service"", re);
        }
    }
}","{
    throwIfParentInstance(""uninstallAllUserCaCerts"");
    if (mService != null) {
        try {
            mService.uninstallCaCerts(admin, new TrustedCertificateStore().userAliases().toArray(new String[0]));
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
 * means other than device policy will also be removed, except for system CA certificates.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 */
","/**
 * Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
 * means other than device policy will also be removed, except for system CA certificates.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The late version adds a new method call throwIfParentInstance(""uninstallAllUserCaCerts"") before the if statement (control dependency change), and it changes how a RemoteException is handled by rethrowing it (exception handling statement changed), so the changes are 2,3.","The introduction of throwIfParentInstance(""uninstallAllUserCaCerts"") can potentially throw an exception before reaching the existing functionality, which could lead to a different behavior before the main body of the method is executed, and the changed exception handling behavior can cause a different exception to be thrown to the method caller (changes the exception behavior). It means both return values and exceptions differ, resulting in CI types 1 and 2."
1421,"<android.speech.tts.FileSynthesisCallback: int audioAvailable(byte[],int,int)>",23,24,"<android.speech.tts.FileSynthesisCallback: int audioAvailable(byte[],int,int)>","<android.speech.tts.FileSynthesisCallback: int audioAvailable(byte[],int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.audioAvailable("" + buffer + "","" + offset + "","" + length + "")"");
    }
    FileChannel fileChannel = null;
    synchronized (mStateLock) {
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (!mStarted) {
            Log.e(TAG, ""Start method was not called"");
            return TextToSpeech.ERROR;
        }
        fileChannel = mFileChannel;
    }
    try {
        fileChannel.write(ByteBuffer.wrap(buffer, offset, length));
        return TextToSpeech.SUCCESS;
    } catch (IOException ex) {
        Log.e(TAG, ""Failed to write to output file descriptor"", ex);
        synchronized (mStateLock) {
            cleanUp();
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
        }
        return TextToSpeech.ERROR;
    }
}","{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.audioAvailable("" + buffer + "","" + offset + "","" + length + "")"");
    }
    FileChannel fileChannel = null;
    synchronized (mStateLock) {
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (!mStarted) {
            Log.e(TAG, ""Start method was not called"");
            return TextToSpeech.ERROR;
        }
        fileChannel = mFileChannel;
    }
    final byte[] bufferCopy = new byte[length];
    System.arraycopy(buffer, offset, bufferCopy, 0, length);
    mDispatcher.dispatchOnAudioAvailable(bufferCopy);
    try {
        fileChannel.write(ByteBuffer.wrap(buffer, offset, length));
        return TextToSpeech.SUCCESS;
    } catch (IOException ex) {
        Log.e(TAG, ""Failed to write to output file descriptor"", ex);
        synchronized (mStateLock) {
            cleanUp();
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
        }
        return TextToSpeech.ERROR;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is an addition of statements to copy the buffer and dispatch an audio available event in the late implementation which were not present in the early implementation. This change is neither a control dependency change, return statement change, nor an exception handling statement change, so the code change type is 4.","The additional statements do not affect the return value of the method or the exceptions thrown by the method. It makes a copy of the audio buffer and dispatches it but ultimately still writes the original buffer to the file channel and returns the same values as the early implementation. Therefore, there is no Compatibility Issue caused by the code changes, and the CI type is 0."
1422,<android.content.res.Resources: int getDimensionPixelOffset(int)>,23,24,<android.content.res.Resources: int getDimensionPixelOffset(int)>,<android.content.res.Resources: int getDimensionPixelOffset(int)>,0,"{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimensionPixelOffset(value.data, mMetrics);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimensionPixelOffset(value.data, impl.getDisplayMetrics());
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Retrieve a dimensional for a particular resource ID for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional for a particular resource ID for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early version uses a manual synchronization with mAccessLock, and creates or reuses a TypedValue instance (`mTmpValue`) for getting the resource value, then it computes the return value using `mMetrics`. The late version of the method uses new methods `obtainTempTypedValue()` and `releaseTempTypedValue(value)` for managing the TypedValue lifecycle. It also uses `mResourcesImpl` instead of its own members to get values, therefore, the implementation uses new dependent APIs to manage the TypedValue instance and to retrieve display metrics. This is sufficient to classify the code change type as both 4 and 5.","There is no compatibility issue detected because although the way to obtain and release `TypedValue` and the metrics reference (`mMetrics` vs `impl.getDisplayMetrics()`) have changed, the end result of `getDimensionPixelOffset` should be the same. The calculation logic for the return value is identical and the exceptions thrown are for the same conditions. Thus, no CI is expected."
1423,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",23,24,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>","<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",0,"{
    checkPendingIntent(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
    }
}","{
    checkPendingIntent(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */
","/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The code change is the addition of a throw statement within the catch block for RemoteException, so there is a change in exception handling statement (type 2).","Because the late version now throws the exception caught instead of swallowing it, this can potentially lead to the API throwing a different exception in the new version. Therefore, there is a Compatibility Issue caused by potential different exception handlings (type 2)."
1425,<android.net.TrafficStats: long getUidTxBytes(int)>,23,24,<android.net.TrafficStats: long getUidTxBytes(int)>,<android.net.TrafficStats: long getUidTxBytes(int)>,0,"{
    return nativeGetUidStat(uid, TYPE_TX_BYTES);
}","{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_TX_BYTES);
    } else {
        return UNSUPPORTED;
    }
}",1,"/**
 * Return number of bytes transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
","/**
 * Return number of bytes transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A control dependency has been introduced to check the calling UID before proceeding to get the transmission bytes, which did not exist in the early version. In the late version, there is now a new return statement that may return UNSUPPORTED under certain conditions. This is a combination of a changed control dependency and a new return statement, so the code change types are 1,3.","Due to the added condition for checking the UID and the potential return of UNSUPPORTED for certain UIDs, this can lead to different return values depending on the UID of the calling process. Hence, there is a potential Compatibility Issue caused by different return values or types, and the CI type is 1."
1426,<android.view.View: boolean onHoverEvent(MotionEvent)>,23,24,<android.view.View: boolean onHoverEvent(MotionEvent)>,<android.view.View: boolean onHoverEvent(MotionEvent)>,0,"{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
        }
    }
    if (isHoverable()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        // return true.
        return true;
    }
    return false;
}","{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
        }
    }
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && event.isFromSource(InputDevice.SOURCE_MOUSE) && isOnScrollbar(event.getX(), event.getY())) {
        awakenScrollBars();
    }
    if (isHoverable()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        // return true.
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
","/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a new block of code that checks if the action is either ACTION_HOVER_ENTER or ACTION_HOVER_MOVE and is from the source InputDevice.SOURCE_MOUSE and whether the event occurs on a scrollbar and then calls awakenScrollBars. This is an other statement change (control-independent) and also adds additional control dependencies due to the new if conditions, so the types are 3,4.","Although there is a code change, any hover events that weren't previously handled and resulted in a 'false' return would still not be handled after the update due to the position of the new code (it doesn't impact the final return conditions). The execution flow for all previously handled hover events remains the same, hence there is no compatibility issue; thus the CI type is 0."
1427,<android.animation.AnimatorSet.Builder: Builder with(Animator)>,23,24,<android.animation.AnimatorSet.Builder: Builder with(Animator)>,<android.animation.AnimatorSet.Builder: Builder with(Animator)>,0,"{
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(mCurrentNode, Dependency.WITH);
    node.addDependency(dependency);
    return this;
}","{
    Node node = getNodeForAnimation(anim);
    mCurrentNode.addSibling(node);
    return this;
}",1,"/**
 * Sets up the given animation to play at the same time as the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method starts.
 */
","/**
 * Sets up the given animation to play at the same time as the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method starts.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"There are changes in the code logic. The Early_Version is directly manipulating the mNodeMap and mNodes and adding a dependency, while the Late_Version is using getNodeForAnimation(anim) to retrieve a node, then adding a sibling to the mCurrentNode. This indicates changes in control dependencies and other statements due to refactoring and use of new methods (Dependency and Node relationships are handled differently), and since getNodeForAnimation(anim) is used, which is not defined here, this suggests a change in a dependent API. Therefore, the change type is a combination of 1,3,4,5.","Despite the changes in implementation logic and the use of a new method, there is no Compatibility Issue because there is no evidence that these changes would lead to different return values of the 'with' method. The return value is always 'this', which is the Builder instance on which the method is invoked, regardless of the changes inside the method. Hence, CI type is 0."
1428,<android.net.LocalSocketImpl.SocketOutputStream: void flush()>,23,24,<android.net.LocalSocketImpl.SocketOutputStream: void flush()>,<android.net.LocalSocketImpl.SocketOutputStream: void flush()>,0,"{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    while (pending_native(myFd) > 0) {
        try {
            Thread.sleep(10);
        } catch (InterruptedException ie) {
            return;
        }
    }
}","{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    // Loop until the output buffer is empty.
    MutableInt pending = new MutableInt(0);
    while (true) {
        try {
            // See linux/net/unix/af_unix.c
            Os.ioctlInt(myFd, OsConstants.TIOCOUTQ, pending);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
        if (pending.value <= 0) {
            // The output buffer is empty.
            break;
        }
        try {
            Thread.sleep(10);
        } catch (InterruptedException ie) {
            break;
        }
    }
}",1,"/**
 * Wait until the data in sending queue is emptied. A polling version
 * for flush implementation.
 * @throws IOException
 * if an i/o error occurs.
 */
","/**
 * Wait until the data in sending queue is emptied. A polling version
 * for flush implementation.
 * @throws IOException
 * if an i/o error occurs.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4,5",2,"The control dependency, exception handling, and other statements have changed. The new code introduces a MutableInt class, uses a different method (Os.ioctlInt) to check if the buffer is empty, changes the way the loop terminates, and replaces the catch for InterruptedException to break out of the loop instead of returning. The dependent API being called also changed from pending_native() to Os.ioctlInt(). These changes correspond to change types 2, 3, 4, and 5.","The new exception handling throws a rethrown ErrnoException as an IOException, which is a change in behaviour that could lead to a different exception being propagated by the method in case of an error with the ioctlInt system call. Moreover, the InterruptedException in the late version no longer returns from the method but breaks the loop, changing how the function reacts to interruptions. Therefore, the CI type is 2."
1429,<android.view.inputmethod.InputMethodManager: boolean isAcceptingText()>,23,24,<android.view.inputmethod.InputMethodManager: boolean isAcceptingText()>,<android.view.inputmethod.InputMethodManager: boolean isAcceptingText()>,0,"{
    checkFocus();
    return mServedInputConnection != null;
}","{
    checkFocus();
    return mServedInputConnectionWrapper != null && mServedInputConnectionWrapper.getInputConnection() != null;
}",1,"/**
 * Return true if the currently served view is accepting full text edits.
 * If false, it has no input connection, so can only handle raw key events.
 */
","/**
 * Return true if the currently served view is accepting full text edits.
 * If false, it has no input connection, so can only handle raw key events.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition in the return statement has been expanded with additional checks, so there's a code change in control dependency (3) and other statement (4) since a new method call "".getInputConnection() != null"" is introduced.","The logic within the return statement has changed to include additional checks which could potentially lead to the method returning a different boolean value. Therefore, there is a Compatibility Issue of type 1 caused by the potential of returning different values."
1430,<android.bluetooth.le.ScanFilter: boolean equals(Object)>,23,24,<android.bluetooth.le.ScanFilter: boolean equals(Object)>,<android.bluetooth.le.ScanFilter: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ScanFilter other = (ScanFilter) obj;
    return Objects.equals(mDeviceName, other.mDeviceName) && Objects.equals(mDeviceAddress, other.mDeviceAddress) && mManufacturerId == other.mManufacturerId && Objects.deepEquals(mManufacturerData, other.mManufacturerData) && Objects.deepEquals(mManufacturerDataMask, other.mManufacturerDataMask) && Objects.deepEquals(mServiceDataUuid, other.mServiceDataUuid) && Objects.deepEquals(mServiceData, other.mServiceData) && Objects.deepEquals(mServiceDataMask, other.mServiceDataMask) && Objects.equals(mServiceUuid, other.mServiceUuid) && Objects.equals(mServiceUuidMask, other.mServiceUuidMask);
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ScanFilter other = (ScanFilter) obj;
    return Objects.equals(mDeviceName, other.mDeviceName) && Objects.equals(mDeviceAddress, other.mDeviceAddress) && mManufacturerId == other.mManufacturerId && Objects.deepEquals(mManufacturerData, other.mManufacturerData) && Objects.deepEquals(mManufacturerDataMask, other.mManufacturerDataMask) && Objects.equals(mServiceDataUuid, other.mServiceDataUuid) && Objects.deepEquals(mServiceData, other.mServiceData) && Objects.deepEquals(mServiceDataMask, other.mServiceDataMask) && Objects.equals(mServiceUuid, other.mServiceUuid) && Objects.equals(mServiceUuidMask, other.mServiceUuidMask);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There are no changes in the implementation of the method between the two versions provided.,"Since there is no change in the code, there is no compatibility issue."
1431,<android.app.UiModeManager: int getNightMode()>,23,24,<android.app.UiModeManager: int getNightMode()>,<android.app.UiModeManager: int getNightMode()>,0,"{
    if (mService != null) {
        try {
            return mService.getNightMode();
        } catch (RemoteException e) {
            Log.e(TAG, ""getNightMode: RemoteException"", e);
        }
    }
    return -1;
}","{
    if (mService != null) {
        try {
            return mService.getNightMode();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return -1;
}",1,"/**
 * @return the currently configured night mode. May be one of
 * {@link #MODE_NIGHT_NO}, {@link #MODE_NIGHT_YES},
 * {@link #MODE_NIGHT_AUTO}, or -1 on error.
 */
","/**
 * Returns the currently configured night mode.
 * <p>
 * May be one of:
 * <ul>
 * <li>{@link #MODE_NIGHT_NO}</li>
 * <li>{@link #MODE_NIGHT_YES}</li>
 * <li>{@link #MODE_NIGHT_AUTO}</li>
 * <li>{@code -1} on error</li>
 * </ul>
 *
 * @return the current night mode, or {@code -1} on error
 * @see #setNightMode(int)
 */
",-1,,[@NightMode],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed; while the early version logs the exception and continues, the late version throws the exception, so the change type is 2.","The change in exception handling could lead to different behavior when an exception occurs, which was previously being logged and now is thrown. Therefore, the CI type is 2."
1432,<android.content.RestrictionsManager: boolean hasRestrictionsProvider()>,23,24,<android.content.RestrictionsManager: boolean hasRestrictionsProvider()>,<android.content.RestrictionsManager: boolean hasRestrictionsProvider()>,0,"{
    try {
        if (mService != null) {
            return mService.hasRestrictionsProvider();
        }
    } catch (RemoteException re) {
        Log.w(TAG, ""Couldn't reach service"");
    }
    return false;
}","{
    try {
        if (mService != null) {
            return mService.hasRestrictionsProvider();
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    return false;
}",1,"/**
 * Called by an application to check if there is an active Restrictions Provider. If
 * there isn't, {@link #requestPermission(String, String, PersistableBundle)} is not available.
 *
 * @return whether there is an active Restrictions Provider.
 */
","/**
 * Called by an application to check if there is an active Restrictions Provider. If
 * there isn't, {@link #requestPermission(String, String, PersistableBundle)} is not available.
 *
 * @return whether there is an active Restrictions Provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from logging a warning to throwing the exception. Since there is a new throw statement introduced, the change type is 2.","The change in the exception handling statement could result in the late version throwing an exception where the early version would not have, causing a change in the API's behavior. Therefore, the CI type is 2."
1433,<android.content.pm.FeatureInfo: String toString()>,23,24,<android.content.pm.FeatureInfo: String toString()>,<android.content.pm.FeatureInfo: String toString()>,0,"{
    if (name != null) {
        return ""FeatureInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + name + "" fl=0x"" + Integer.toHexString(flags) + ""}"";
    } else {
        return ""FeatureInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" glEsVers="" + getGlEsVersion() + "" fl=0x"" + Integer.toHexString(flags) + ""}"";
    }
}","{
    if (name != null) {
        return ""FeatureInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + name + "" v="" + version + "" fl=0x"" + Integer.toHexString(flags) + ""}"";
    } else {
        return ""FeatureInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" glEsVers="" + getGlEsVersion() + "" fl=0x"" + Integer.toHexString(flags) + ""}"";
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been altered for the case where `name` is not null, adding the version information to the returned String. This constitutes a Return statement changed (category 1).","Since the return value has been modified to include the `version`, clients receiving this string will observe a difference, which introduces the potential for a Compatibility Issue of type 1 (different return values)."
1436,<android.os.BatteryManager: boolean isCharging()>,23,24,<android.os.BatteryManager: boolean isCharging()>,<android.os.BatteryManager: boolean isCharging()>,0,"{
    try {
        return mBatteryStats.isCharging();
    } catch (RemoteException e) {
        return true;
    }
}","{
    try {
        return mBatteryStats.isCharging();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return true if the battery is currently considered to be charging.  This means that
 * the device is plugged in and is supplying sufficient power that the battery level is
 * going up (or the battery is fully charged).  Changes in this state are matched by
 * broadcasts of {@link #ACTION_CHARGING} and {@link #ACTION_DISCHARGING}.
 */
","/**
 * Return true if the battery is currently considered to be charging.  This means that
 * the device is plugged in and is supplying sufficient power that the battery level is
 * going up (or the battery is fully charged).  Changes in this state are matched by
 * broadcasts of {@link #ACTION_CHARGING} and {@link #ACTION_DISCHARGING}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed, where the early version returned true in case of a RemoteException, whereas the late version throws the exception.","This change can lead to a Compatibility Issue caused by different exception handlings because callers of the earlier version of the API would never receive an exception, whereas callers of the later version might. Therefore, the CI type is 2."
1438,<android.app.ActivityManager: boolean isUserAMonkey()>,23,24,<android.app.ActivityManager: boolean isUserAMonkey()>,<android.app.ActivityManager: boolean isUserAMonkey()>,0,"{
    try {
        return ActivityManagerNative.getDefault().isUserAMonkey();
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return ActivityManagerNative.getDefault().isUserAMonkey();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns ""true"" if the user interface is currently being messed with
 * by a monkey.
 */
","/**
 * Returns ""true"" if the user interface is currently being messed with
 * by a monkey.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The early version catches the RemoteException and returns false, while the late version rethrows the exception, so the error handling logic has changed, leading to the change type being 2.","This change in exception handling potentially leads to a different behavior, as the late version throws an exception instead of returning false. This represents a CI because the clients calling the method in the late version must now handle the possible exception, which was not the case before. Therefore, the CI type is 2."
1439,<android.accounts.AccountManager.AmsTask.Response: void onResult(Bundle)>,23,24,<android.accounts.AccountManager.AmsTask.Response: void onResult(Bundle)>,<android.accounts.AccountManager.AmsTask.Response: void onResult(Bundle)>,0,"{
    Intent intent = bundle.getParcelable(KEY_INTENT);
    if (intent != null && mActivity != null) {
        // since the user provided an Activity we will silently start intents
        // that we see
        mActivity.startActivity(intent);
    // leave the Future running to wait for the real response to this request
    } else if (bundle.getBoolean(""retry"")) {
        try {
            doWork();
        } catch (RemoteException e) {
        // this will only happen if the system process is dead, which means
        // we will be dying ourselves
        }
    } else {
        set(bundle);
    }
}","{
    Intent intent = bundle.getParcelable(KEY_INTENT);
    if (intent != null && mActivity != null) {
        // since the user provided an Activity we will silently start intents
        // that we see
        mActivity.startActivity(intent);
    // leave the Future running to wait for the real response to this request
    } else if (bundle.getBoolean(""retry"")) {
        try {
            doWork();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        set(bundle);
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed due to the addition of 'throw e.rethrowFromSystemServer();' inside the catch block, so the change type is 2.","The new exception handling behavior introduced via 'throw e.rethrowFromSystemServer();' could potentially cause the API to throw a different exception than previously, therefore the CI type is 2."
1441,<android.widget.FrameLayout: LayoutParams generateLayoutParams(LayoutParams)>,23,24,<android.widget.FrameLayout: LayoutParams generateLayoutParams(LayoutParams)>,<android.widget.FrameLayout: LayoutParams generateLayoutParams(LayoutParams)>,0,"{
    return new LayoutParams(p);
}","{
    if (lp instanceof LayoutParams) {
        return new LayoutParams((LayoutParams) lp);
    } else if (lp instanceof MarginLayoutParams) {
        return new LayoutParams((MarginLayoutParams) lp);
    } else {
        return new LayoutParams(lp);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late implementation includes control flow checks to determine the type of the passed 'lp' parameter and to construct an appropriate 'LayoutParams' object accordingly, which introduces control dependency change and may potentially lead to different return types or values, thus the code change type is 1,3.","The addition of instanceof checks and the decision on which constructor to call could result in different 'LayoutParams' objects being returned. Consequently, this could lead to a compatibility issue due to the potential of returning different types or values from this method, which classifies as CI type 1."
1443,<android.view.TextureView: HardwareLayer getHardwareLayer()>,23,24,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"{
    // NOTE: Maintain these two lines very carefully (see View.java)
    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createTextureLayer();
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = new SurfaceTexture(false);
            mLayer.setSurfaceTexture(mSurface);
        }
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}","{
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createTextureLayer();
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = new SurfaceTexture(false);
            mLayer.setSurfaceTexture(mSurface);
        }
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    return mLayer;
}",1,,,-1,[@Override],,-1,-1,-1,-1,-1,-1,4,0,"The two lines related to the flags (`mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; mPrivateFlags &= ~PFLAG_DIRTY_MASK;`) and the calls to `applyUpdate()` and `applyTransformMatrix()` methods have been removed. These changes are not related to return statements or exception handling, hence the change type is 4.","The removed lines seem to be related to the internal state management of the view flags and transformations rather than affecting the return value of the `getHardwareLayer()` method. The method's return value is influenced by the state of `mLayer`, which is not altered by the removed statements. Therefore, there seems to be no Compatibility Issue, as the API's behavior (in terms of return value or exceptions thrown) does not appear to be altered."
1444,<android.content.res.Resources: String getString(int)>,23,24,<android.content.res.Resources: String getString(int)>,<android.content.res.Resources: String getString(int)>,0,"{
    final CharSequence res = getText(id);
    if (res != null) {
        return res.toString();
    }
    throw new NotFoundException(""String resource ID #0x"" + Integer.toHexString(id));
}","{
    return getText(id).toString();
}",1,"/**
 * Return the string value associated with a particular resource ID.  It
 * will be stripped of any styled text information.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
","/**
 * Return the string value associated with a particular resource ID.  It
 * will be stripped of any styled text information.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,1,0,"The later version of the API implementation has removed the null check for the CharSequence 'res' before calling 'toString()' method on it, implying the getText(id) is presumed not to return null. Given that @NonNull annotation exists for both versions, this implies a guarantee of no-null return value, therefore, it may indicate an underlying assumption change rather than an explicit change in return value behavior as reflected in the method contract due to annotation. ","There appears to be no Compatibility Issue due to the presence of the @NonNull annotation in both versions, indicating that the API guarantees that a non-null value will be returned. Assuming the contract enforced by @NonNull is respected in the implementation, it suggests that a null value should not have been possible in early versions as well, despite the explicit null check that has been removed in the late implementation. However, if the assumption does not hold, and if getText(id) can return null, then indeed the late version could cause a NullPointerException, which wasn't the case in the early version where a NotFoundException would be thrown instead. This would be a CI but given the information and the annotations present, it's reasonable to conclude there is no CI under the assumption that the annotations accurately reflect the API’s contract."
